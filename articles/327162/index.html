<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Detect and track multiple objects in a video stream on an FPGA</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I want to talk about the implementation of the system for detecting and tracking multiple objects in a video stream. This article is b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Detect and track multiple objects in a video stream on an FPGA</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/37f/62c/0ee/37f62c0eeabb409ebe52ad7db0f0f871.png"></div><br>  In this article I want to talk about the implementation of the system for detecting and tracking multiple objects in a video stream.  This article is based on the two previous ones: <a href="https://habrahabr.ru/post/323258/"><b>Motion detection in a video stream on FPGA</b></a> and <a href="https://habrahabr.ru/post/325808/"><b>Image filtering using the method of mathematical morphology on FPGA</b></a> .  Capture and initial image processing is carried out using the methods described in the first article, and image filtering is described in the second. <br><br>  Following the goals set in the first article, I decided to implement an algorithm for drawing a frame around the detected object.  In the process of performing this task, I was faced with the question: what frame should I draw around exactly what object?  There may be many objects in the frame after filtering: some of them are small and others are large.  If you draw one frame around all the objects in the frame, this is not difficult, but the result of the work of such a system is unlikely to be interesting to anyone. <br><a name="habracut"></a><br>  Rummaging in the network, I got acquainted with a variety of documents describing different approaches to the detection of multiple objects.  Some turned out to be unsuitable for implementation on the FPGA, others require large amounts of block memory to store the whole frame, others do the work in several passes through the image, which is also not suitable in my case.  I want for one. <br><br>  Nevertheless, one of the <a href="http://www.electronics.dit.ie/staff/aschwarzbacher/research/mpc08-1Blob.pdf">documents</a> attracted my attention.  It describes an algorithm that implements the detection of multiple objects in a single pass through the image using the implementation of linked lists for analyzing image areas.  After analyzing this material, I realized that this algorithm suits me, provided that the object detector itself will work in a faster clok domain than the logic of entering data into the detector and displaying the image on the screen.  This is due to the fact that this algorithm searches through linked lists with each new piece of data received at its input, and the number of linked lists at the maximum reaches a value of half the number of pixels in a row.  In other words, in the worst case, with each new piece of data we need to process 160 linked lists if the width of the line of our image is 320 pixels. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Below is a functional diagram of the detector of multiple objects: <br><img src="https://habrastorage.org/files/df2/a65/e60/df2a65e6075a49e5bf9c5172e82909a6.png"><br><br>  The detector consists of three main blocks: <b>RUN detector</b> , <b>BLOB detector</b> and <b>Bounding box generator</b> .  Each block operates in its own klokov domain and is connected to another block via an asynchronous FIFO. <br><br><h3>  RUN detector </h3><br>  The input data of this block are the output data from the <a href="https://habrahabr.ru/post/325808/">filter based on mathematical morphology</a> . <br>  This block searches for the input stream of a sequence of pixels consisting of one units, the so-called RUNs.  This name is taken from the <b>RLE (Run Length Encoding)</b> compression algorithm used for JPEG compression and the like.  The picture below shows several types of RUNs: <b>class-length</b> , <b>class-start</b> and <b>start-end</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/365/f1c/bff/365f1cbffd76493fa54bf5e9fcc68864.png"></div><br>  In our detector, the last one is used ( <b>start-end</b> ).  It is most suitable for our system.  In the <b>start</b> field, the initial position of the sequence of units is recorded, and in the <b>end</b> field, the <b>end</b> position, then the generated <b>start-end</b> field is transmitted to the RUN output of the detector and written to the FIFO.  Along with RUNs, the end of line and end of frame data are recorded in the FIFO for the next block to work correctly. <br><br>  Verilog Detector Code <br><br><div class="spoiler">  <b class="spoiler_title">Run detector</b> <div class="spoiler_text"><pre><code class="hljs vhdl">module run_detector #( <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> RES_X=<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> RES_Y=<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d240</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> XOFFSET=<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d320</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> YOFFSET=<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>) ( input wire clk, input wire nRst, input wire data_valid, input wire [<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_in, input wire [<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] xi, input wire [<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] yi, output reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_start, output reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_end, output reg row_end, output reg frame_end, output reg new_run, output reg rd_req ); localparam ST_IDLE=<span class="hljs-number"><span class="hljs-number">0</span></span>, ST_RUN_START=<span class="hljs-number"><span class="hljs-number">1</span></span>, ST_RUN_END=<span class="hljs-number"><span class="hljs-number">2</span></span>, ST_ROW_END=<span class="hljs-number"><span class="hljs-number">3</span></span>, ST_FRAME_END=<span class="hljs-number"><span class="hljs-number">4</span></span>; localparam XRES = RES_X + XOFFSET - <span class="hljs-number"><span class="hljs-number">1</span></span>; localparam YRES = RES_Y + YOFFSET - <span class="hljs-number"><span class="hljs-number">1</span></span>; reg [<span class="hljs-number"><span class="hljs-number">2</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_state = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_start_d; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_end_d; wire row_done_w = ((xi == XRES) &amp;&amp; (yi &lt;= YRES)) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; wire frame_done_w = ((xi == XRES) &amp;&amp; (yi == YRES)) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; always @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge nRst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_state &lt;= ST_IDLE; run_start &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; run_end &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; row_end &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; frame_end &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; new_run &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; rd_req &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> new_run &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; row_end &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; frame_end &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (run_state) ST_IDLE: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data_valid) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data_in) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_state &lt;= ST_RUN_START; run_start &lt;= xi[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_RUN_START: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!data_in) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_state &lt;= ST_RUN_END; run_end &lt;= xi[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] - <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; new_run &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_RUN_END: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (data_in) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_start &lt;= xi[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; run_state &lt;= ST_RUN_START; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_state &lt;= ST_IDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_ROW_END, ST_FRAME_END: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!data_valid) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_state &lt;= ST_IDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endcase <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (row_done_w || frame_done_w) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_state &lt;= frame_done_w ? ST_FRAME_END : ST_ROW_END; row_end &lt;= row_done_w ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; frame_end &lt;= frame_done_w ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; run_start &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; run_end &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; new_run &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre> <br></div></div><br><h3>  BLOB detector </h3><br>  A flowchart of the detector is shown below. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/786/f95/838/786f95838c584c098b101e3ca34e6175.png"></div><br>  Consider the work of the detector in more detail.  The detector, in my implementation, is a large synchronous state machine.  Also, two modules of block memory are used for the detector operation: one for storing RUNs ( <b>run memory</b> ) of the current and previous lines, the second for storing properties of the detected object ( <b>object memory</b> ).  Total 32 objects. <br><br>  <b>INIT</b> <br>  The detector starts in the <b>INIT</b> state.  In this state, one of the <b>run memory</b> buffers is initialized with invalid label values.  Then the detector enters the <b>IDLE</b> state. <br><br>  <b>IDLE</b> <br>  In this state, the detector waits for data in the input FIFO from the RUN detector, then enters the <b>FIND_RUN</b> state. <br><br>  <b>FIND_RUN</b> <br>  Here the detector reads the start and end coordinates of the RUN from the FIFO and goes to the <b>FIND_OVERLAP</b> state to search for the intersections of the current RUN with the RUNs of the previous line.  A new RUN is assigned an invalid tag. <br><br>  <b>FIND_OVERLAP</b> <br>  The data in the memory of <b>run memory is</b> located in 2 rows - the current and the previous one.  Each new RUN from the FIFO is recorded in the current memory block and by passing through the entire block of the previous line is compared for intersections (overlaps).  The figure below illustrates how RUNs are stored in <b>run memory</b> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/da8/471/e73/da8471e737bb4de7b569a5b8328191ad.png"></div><br>  If the read from the memory of the previous RUN line has a invalid tag, this means that there are no more <b>RUNs of the</b> previous line in this block, and the detector switches to the <b>CREATE_OBJ</b> state to create a new object from the current RUN.  Otherwise, if the intersection is set, then the <b>object is</b> read from the <b>object memory</b> at the address of the RUN tag and the detector switches to the <b>UPDATE_OBJ</b> state to update the properties of an already existing object.  If the current RUN has a label that is not invalid, given to it from reading from the FIFO, then this means that this RUN belongs to some object and there was an intersection with another existing object and these objects need to be merged into one object, and the detector enters the <b>MERGE_OBJ</b> state. <br><br>  <b>CREATE_OBJ</b> <br>  Here a new object is created, all its properties are filled. <br><br><ul><li>  <b>X start</b> - Starting X coordinate </li><li>  <b>X end</b> - The final X coordinate </li><li>  <b>Y start</b> - Starting Y coordinate </li><li>  <b>Y end</b> - the final coordinate Y </li><li>  <b>Object mass</b> - The number of pixels in the object. </li></ul><br>  The created object is stored in <b>object memory</b> at the next free address (label of the current RUN).  The detector enters the <b>IDLE</b> state of reading a new RUN from the FIFO. <br><br>  <b>UPDATE_OBJ</b> <br>  In this state, the properties of an existing object from <b>object memory</b> are updated, new coordinates of the object are calculated based on the length of the current RUN being attached to it.  After the object has been updated, the detector enters the <b>FIND_OVERLAP</b> state of the <b>intersection</b> search with the next RUN from the run memory. <br><br>  <b>MERGE_OBJ</b> <br>  Here, two existing objects merge into one, their properties are updated and assigned to the first object, and the second object is invalidated to be excluded from subsequent processing.  After the merge, the detector enters the <b>FIND_OVERLAP</b> state of <b>intersection</b> search with the next RUN from the <b>run memory</b> . <br><br>  The figure below shows the merging of objects <b>1</b> and <b>2</b> by means of a common RUN-a shaded in red. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fd5/f84/a69/fd5f84a69abf43bf83d6e5ef3c5c5700.png"></div><br>  <b>FINISH_OBJ</b> <br>  The detector enters this state every time when a sign of the end of the line or the end of the frame is read from the FIFO.  In the case of a line terminator, the write and read areas in the <b>run memory</b> are swapped and the detector enters the state of waiting for data from the FIFO.  In the case of the end of the frame, the detector enters the <b>UPLOAD_DATA</b> state of unloading the objects found from the <b>object memory</b> into the output FIFO. <br><br>  <b>UPLOAD_DATA</b> <br>  Passing through the entire <b>object memory, the object</b> properties are unloaded into the output FIFO.  The word unloaded in the FIFO is the layout of the address of the object and the four coordinates <b>Xstart</b> , <b>Xend</b> , <b>Ystart</b> and <b>Yend</b> .  A total of 32 objects are implemented and this is quite enough for a frame of <b>320x240</b> pixels.  But not all found objects will be valid.  Objects with a mass of less than <b>100</b> pixels will be unloaded into the output FIFO as invalid and subsequently will not be processed by the frame generator.  After unloading all objects, the detector erases all <b>object memory</b> and changes its state to <b>START</b> , and a new cycle of accumulation of objects begins. <br><br>  Verilog Detector Code <br><br><div class="spoiler">  <b class="spoiler_title">Blob detector</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">module blob_detector #( parameter RES_X=<span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'d320, parameter RES_Y=10'</span></span>d240) ( <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> wire clk, <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> wire nRst, // <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> RUN FIFO <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> wire fifo_empty, <span class="hljs-keyword"><span class="hljs-keyword">input</span></span> wire [<span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] fifo_data, output wire fifo_rd_en, // output boxes interface output reg we, output reg [<span class="hljs-number"><span class="hljs-number">47</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data_o ); localparam ST_START = <span class="hljs-number"><span class="hljs-number">0</span></span>, ST_INIT = <span class="hljs-number"><span class="hljs-number">1</span></span>, ST_IDLE = <span class="hljs-number"><span class="hljs-number">2</span></span>, ST_FIND_RUN = <span class="hljs-number"><span class="hljs-number">3</span></span>, ST_FIND_OVERLAP = <span class="hljs-number"><span class="hljs-number">4</span></span>, ST_FIND_OVERLAP_0 = <span class="hljs-number"><span class="hljs-number">5</span></span>, ST_CREATE_OBJ = <span class="hljs-number"><span class="hljs-number">6</span></span>, ST_UPDATE_OBJ_2 = <span class="hljs-number"><span class="hljs-number">7</span></span>, ST_UPDATE_OBJ = <span class="hljs-number"><span class="hljs-number">8</span></span>, ST_MERGE_OBJ = <span class="hljs-number"><span class="hljs-number">9</span></span>, ST_MERGE_OBJ_2 = <span class="hljs-number"><span class="hljs-number">10</span></span>, ST_FINISH_OBJ = <span class="hljs-number"><span class="hljs-number">11</span></span>, ST_FINISH_OBJ_2 = <span class="hljs-number"><span class="hljs-number">12</span></span>, ST_UPLOAD_DATA_START = <span class="hljs-number"><span class="hljs-number">13</span></span>, ST_UPLOAD_DATA = <span class="hljs-number"><span class="hljs-number">14</span></span>, ST_UPLOAD_DATA_END = <span class="hljs-number"><span class="hljs-number">15</span></span>; localparam MAX_RUNS = RES_X &gt;&gt; <span class="hljs-number"><span class="hljs-number">1</span></span>; //`define DETECTOR_DEBUG_MODE //<span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> modeling // RUN memory reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_mem_wr_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_mem_rd_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_mem_saved_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg run_mem_wr_en = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg run_mem_flip = <span class="hljs-number"><span class="hljs-number">0</span></span>; // RUN memory data wire [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_rd_start_x; wire [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_rd_end_x; wire [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_rd_label; // RUN FIFO data reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_cur_start_x = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_cur_end_x = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_cur_label = <span class="hljs-number"><span class="hljs-number">0</span></span>; wire [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] eb; reg [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] free_label = <span class="hljs-number"><span class="hljs-number">0</span></span>; `define OBJ_MASS_THR <span class="hljs-number"><span class="hljs-number">19</span></span><span class="hljs-string"><span class="hljs-string">'d100 `define OBJ_LIMIT 32 `define FRAME_END fifo_data[21] `define ROW_CHANGED fifo_data[20] `define RUN_EMPTY_LABEL 10'</span></span>h200 `define EMPY_RUN_SLOT <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'h1FF // FSM reg [5:0] blob_detector_fsm_state = 0; // Internal reg [9:0] current_row = 0; reg [9:0] temp_label = 0; reg frame_end_r = 0; `ifdef DETECTOR_DEBUG_MODE // DEBUG reg create_obj = 0; reg merge_obj = 0; reg update_obj = 0; reg skip_obj = 0; reg finish_obj = 0; wire [8:0] rd_ram_addr = {~run_mem_flip, run_mem_rd_addr}; wire [8:0] wr_ram_addr = {run_mem_flip, run_mem_wr_addr}; `endif // read the input FIFO assign fifo_rd_en = (!fifo_empty &amp;&amp; blob_detector_fsm_state == ST_FIND_RUN); // RUN memory alt_ram_30x512 run_ram ( .clock(clk), .data({2'</span></span>h0, run_cur_start_x, run_cur_end_x, run_cur_label}), .rdaddress({~run_mem_flip, run_mem_rd_addr}), .wraddress({run_mem_flip, run_mem_wr_addr}), .wren(run_mem_wr_en), .q({eb, run_rd_start_x, run_rd_end_x, run_rd_label}) ); reg [<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] obj_wr_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>, obj_rd_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>, obj_saved_rd_addr = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg obj_mem_wr_en = <span class="hljs-number"><span class="hljs-number">0</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">object</span></span><span class="hljs-string"><span class="hljs-string">'s fields for writing reg [9:0] obj_start_x = 0, obj_start_y = 0, obj_end_x = 0, obj_end_y = 0; reg [21:0] obj_mass = 0; reg obj_valid = 0, obj_updated = 0; // object'</span></span>s wires <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> reading wire [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] obj_rd_start_x, obj_rd_start_y, obj_rd_end_x, obj_rd_end_y; wire [<span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] obj_rd_mass; wire obj_rd_valid, obj_rd_updated; // <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> detection condition wire obj_detected_valid = (obj_rd_valid &amp;&amp; (obj_rd_mass &gt; `OBJ_MASS_THR)); // <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span> memory object_ram obj_ram ( .clock(clk), .data({obj_valid,obj_updated,obj_start_x,obj_end_x,obj_start_y,obj_end_y,obj_mass}), .rdaddress(obj_rd_addr), .wraddress(obj_wr_addr), .wren(obj_mem_wr_en), .q({obj_rd_valid,obj_rd_updated,obj_rd_start_x,obj_rd_end_x,obj_rd_start_y,obj_rd_end_y,obj_rd_mass}) ); <span class="hljs-comment"><span class="hljs-comment">/* * The main detector process */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">always</span></span> @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge nRst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> blob_detector_fsm_state &lt;= ST_START; run_mem_flip &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; free_label &lt;= 10'</span></span>d0; temp_label &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'d0; current_row &lt;= 10'</span></span>d0; frame_end_r &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; run_mem_wr_en &lt;= 1'</span></span>b0; obj_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; we &lt;= 1'</span></span>b0; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; obj_mem_wr_en &lt;= 1'</span></span>b0; we &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; `ifdef DETECTOR_DEBUG_MODE // DEBUG create_obj &lt;= 1'</span></span>b0; merge_obj &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; update_obj &lt;= 1'</span></span>b0; skip_obj &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; finish_obj &lt;= 1'</span></span>b0; `endif <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (blob_detector_fsm_state) ST_START: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> current_row &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'d0; free_label &lt;= 10'</span></span>d0; run_mem_rd_addr &lt;= <span class="hljs-number"><span class="hljs-number">8</span></span><span class="hljs-string"><span class="hljs-string">'d0; run_mem_wr_addr &lt;= 8'</span></span>d0; obj_rd_addr &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-string"><span class="hljs-string">'d0; obj_wr_addr &lt;= 5'</span></span>d0; frame_end_r &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; run_mem_flip &lt;= 1'</span></span>b0; blob_detector_fsm_state &lt;= ST_INIT; run_cur_start_x &lt;= `EMPY_RUN_SLOT; run_cur_end_x &lt;= `EMPY_RUN_SLOT; run_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; end ST_INIT: begin if (run_mem_wr_addr &gt;= MAX_RUNS) begin run_mem_wr_addr &lt;= 8'</span></span>d0; run_mem_flip &lt;= ~run_mem_flip; run_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; blob_detector_fsm_state &lt;= ST_IDLE; end else begin run_mem_wr_addr &lt;= run_mem_wr_addr + 1'</span></span>b1; run_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; end end ST_IDLE: begin if (!fifo_empty) begin blob_detector_fsm_state &lt;= ST_FIND_RUN; end end ST_FIND_RUN: begin // fifo is already read by now // ALWAYS set the empty label to the new run temp_label &lt;= `RUN_EMPTY_LABEL; run_cur_start_x &lt;= fifo_data[19:10]; run_cur_end_x &lt;= fifo_data[9:0]; if (`ROW_CHANGED) begin frame_end_r &lt;= `FRAME_END; blob_detector_fsm_state &lt;= ST_FINISH_OBJ; end else begin // set first read addres of a RUN run_mem_rd_addr &lt;= 8'</span></span>d0; blob_detector_fsm_state &lt;= ST_FIND_OVERLAP_0; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_FIND_OVERLAP_0: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // an empty <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (altera<span class="hljs-string"><span class="hljs-string">'s altsyncram is read in 2 cycles, one of them is empty) blob_detector_fsm_state &lt;= ST_FIND_OVERLAP; end ST_FIND_OVERLAP: begin if ((run_rd_start_x == `EMPY_RUN_SLOT) || (run_rd_start_x &gt; run_cur_end_x + 1'</span></span>b1)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_label == `RUN_EMPTY_LABEL) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // asssign the run a free label run_cur_label &lt;= free_label; // ??? obj_saved_rd_addr &lt;= obj_rd_addr; obj_rd_addr &lt;= free_label[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; // store <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> run <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> the memory run_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; blob_detector_fsm_state &lt;= ST_CREATE_OBJ; end else begin // some garbage was read from the FIFO run_mem_rd_addr &lt;= 8'</span></span>d0; blob_detector_fsm_state &lt;= ST_IDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty slot <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memory <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (((run_rd_start_x &gt;= run_cur_start_x) &amp;&amp; (run_rd_start_x &lt;= run_cur_end_x)) || ((run_rd_end_x &gt;= run_cur_start_x) &amp;&amp; (run_rd_end_x &lt;= run_cur_end_x)) || ((run_rd_end_x &gt;= run_cur_start_x) &amp;&amp; (run_rd_start_x &lt;= run_cur_end_x)) ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // overlap <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_label == `RUN_EMPTY_LABEL) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> run_cur_label &lt;= run_rd_label; temp_label &lt;= run_rd_label; // <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> RUN run_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; // read the object with the overlaped RUN, save the current read addres obj_saved_rd_addr &lt;= obj_rd_addr + 1'</span></span>b1; obj_rd_addr &lt;= run_rd_label[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; // leave the RUN <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> address the same run_mem_saved_addr &lt;= run_mem_rd_addr; blob_detector_fsm_state &lt;= ST_UPDATE_OBJ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> label <span class="hljs-keyword"><span class="hljs-keyword">exists</span></span> (we came <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> state) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_label != run_rd_label) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // merge <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> RUN <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> existent <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> (objects might <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> be overlaped) obj_rd_addr &lt;= run_rd_label[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; // goto merge state blob_detector_fsm_state &lt;= ST_MERGE_OBJ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // otherwise this <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> the same RUN, skip it run_mem_rd_addr &lt;= run_mem_rd_addr + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; blob_detector_fsm_state &lt;= ST_FIND_OVERLAP_0; end end end else begin // not overlaps, skip it run_mem_rd_addr &lt;= run_mem_rd_addr + 1'</span></span>b1; blob_detector_fsm_state &lt;= ST_FIND_OVERLAP_0; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_CREATE_OBJ: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> `ifdef DETECTOR_DEBUG_MODE // <span class="hljs-keyword"><span class="hljs-keyword">DEBUG</span></span> create_obj &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; `endif // the label of the current RUN obj_wr_addr &lt;= run_cur_label[4:0]; // features obj_valid &lt;= 1'</span></span>b1; obj_updated &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; obj_start_x &lt;= run_cur_start_x; obj_end_x &lt;= run_cur_end_x; obj_start_y &lt;= current_row; obj_end_y &lt;= current_row; obj_mass &lt;= run_cur_end_x - run_cur_start_x + 1'</span></span>b1; free_label &lt;= free_label + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; // write this OBJ into mem obj_mem_wr_en &lt;= 1'</span></span>b1; // <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span> the next RUN write address run_mem_wr_addr &lt;= run_mem_wr_addr + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; // RUN read address starts from the begining run_mem_rd_addr &lt;= 8'</span></span>d0; // <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> the FIFO <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> the next RUN blob_detector_fsm_state &lt;= ST_IDLE; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_UPDATE_OBJ: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // we mut take altsyncram<span class="hljs-string"><span class="hljs-string">'s latency into account (one empty cycle) obj_rd_addr &lt;= run_rd_label[4:0]; blob_detector_fsm_state &lt;= ST_UPDATE_OBJ_2; end ST_UPDATE_OBJ_2: begin `ifdef DETECTOR_DEBUG_MODE // DEBUG update_obj &lt;= 1'</span></span>b1; `endif // <span class="hljs-keyword"><span class="hljs-keyword">update</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">only</span></span> it was previously <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> // thus we avoid updating unused objects came <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> the // merge state <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj_rd_valid) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> obj_valid &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; obj_updated &lt;= 1'</span></span>b1; obj_start_x &lt;= (run_cur_start_x &lt; obj_rd_start_x) ? run_cur_start_x : obj_rd_start_x ; obj_end_x &lt;= (run_cur_end_x &gt; obj_rd_end_x) ? run_cur_end_x : obj_rd_end_x; obj_start_y &lt;= (current_row &lt; obj_rd_start_y) ? current_row : obj_rd_start_y; obj_end_y &lt;= (current_row &gt; obj_rd_end_y) ? current_row : obj_rd_end_y; obj_mass &lt;= obj_rd_mass + (run_cur_end_x - run_cur_start_x); // save updated obj <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> it<span class="hljs-string"><span class="hljs-string">'s original address obj_wr_addr &lt;= obj_rd_addr; // restore saved read address run_mem_rd_addr &lt;= run_mem_saved_addr; // write updated object obj_mem_wr_en &lt;= 1'</span></span>b1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> `ifdef DETECTOR_DEBUG_MODE <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // just skip this <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> // perhaps it was updated previously <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> going <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be updated <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the next RUN skip_obj &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; end `endif // let store current run into the memory blob_detector_fsm_state &lt;= ST_FIND_OVERLAP_0; // increment the next RUN write address run_mem_wr_addr &lt;= run_mem_wr_addr + 1'</span></span>b1; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_MERGE_OBJ: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> // invalidate the (second) <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> // !!!free list MUST be updated ??? I can<span class="hljs-string"><span class="hljs-string">'t figure out how it should be done... obj_valid &lt;= 1'</span></span>b0; obj_wr_addr &lt;= run_rd_label[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; obj_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; blob_detector_fsm_state &lt;= ST_MERGE_OBJ_2; end ST_MERGE_OBJ_2: begin `ifdef DETECTOR_DEBUG_MODE // DEBUG merge_obj &lt;= 1'</span></span>b1; `endif <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj_rd_valid) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> obj_valid &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; obj_start_x &lt;= (obj_start_x &lt; obj_rd_start_x) ? obj_start_x : obj_rd_start_x; obj_end_x &lt;= (obj_end_x &gt; obj_rd_end_x) ? obj_end_x : obj_rd_end_x; obj_start_y &lt;= (obj_start_y &lt; obj_rd_start_y) ? obj_start_y : obj_rd_start_y; obj_end_y &lt;= (obj_end_y &gt; obj_rd_end_y) ? obj_end_y : obj_rd_end_y; obj_mass &lt;= obj_mass + obj_rd_mass; obj_wr_addr &lt;= temp_label[4:0]; // write updated (first) object obj_mem_wr_en &lt;= 1'</span></span>b1; // <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> just written <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj_rd_addr &lt;= temp_label[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> blob_detector_fsm_state &lt;= ST_FIND_OVERLAP_0; run_mem_rd_addr &lt;= run_mem_rd_addr + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; end ST_FINISH_OBJ: begin // if there are NO opened objects in the row run_cur_start_x &lt;= `EMPY_RUN_SLOT; run_cur_end_x &lt;= `EMPY_RUN_SLOT; run_mem_rd_addr &lt;= 8'</span></span>d0; blob_detector_fsm_state &lt;= ST_FINISH_OBJ_2; run_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; end ST_FINISH_OBJ_2: begin run_mem_flip &lt;= ~run_mem_flip; run_mem_wr_addr &lt;= 8'</span></span>d0; current_row &lt;= current_row + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; if (frame_end_r) begin `ifdef DETECTOR_DEBUG_MODE // DEBUG finish_obj &lt;= 1'</span></span>b1; `endif // <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">some</span></span> stuff around bounding boxes frame_end_r &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; obj_rd_addr &lt;= 5'</span></span>d0; obj_saved_rd_addr &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-string"><span class="hljs-string">'d0;; blob_detector_fsm_state &lt;= ST_UPLOAD_DATA_START; end else begin blob_detector_fsm_state &lt;= ST_IDLE; end end ST_UPLOAD_DATA_START: begin // an empty case (altera'</span></span>s altsyncram <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> cycles, one <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> them <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> empty) obj_saved_rd_addr &lt;= obj_rd_addr; blob_detector_fsm_state &lt;= ST_UPLOAD_DATA; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_UPLOAD_DATA: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj_rd_addr &gt;= (`OBJ_LIMIT - <span class="hljs-number"><span class="hljs-number">1</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> blob_detector_fsm_state &lt;= ST_UPLOAD_DATA_END; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> data_o &lt;= {<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'h0, obj_saved_rd_addr, obj_detected_valid, obj_rd_start_x, obj_rd_end_x, obj_rd_start_y, obj_rd_end_y}; //data_o &lt;= {2'</span></span>h0, obj_saved_rd_addr, obj_rd_valid, obj_rd_start_x, obj_rd_end_x, obj_rd_start_y - <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'d320, obj_rd_end_y - 10'</span></span>d320}; //data_o &lt;= {<span class="hljs-number"><span class="hljs-number">2</span></span><span class="hljs-string"><span class="hljs-string">'h0, obj_saved_rd_addr, 1'</span></span>b1, <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'d340, 10'</span></span>d380, <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'d120, 10'</span></span>d160}; we &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; // clean obj memory obj_wr_addr &lt;= obj_rd_addr; obj_valid &lt;= 1'</span></span>b0; obj_updated &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b0; obj_start_x &lt;= 10'</span></span>d0; obj_end_x &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'d0; obj_start_y &lt;= 10'</span></span>d0; obj_end_y &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span><span class="hljs-string"><span class="hljs-string">'d0; obj_mass &lt;= 20'</span></span>d0; obj_mem_wr_en &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; // set box generator'</span></span>s address //<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj_detected_valid) obj_saved_rd_addr &lt;= obj_saved_rd_addr + <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-string"><span class="hljs-string">'b1; // set the next read address obj_rd_addr &lt;= obj_rd_addr + 1'</span></span>b1; blob_detector_fsm_state &lt;= ST_UPLOAD_DATA_START; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ST_UPLOAD_DATA_END: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> obj_rd_addr &lt;= <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-string"><span class="hljs-string">'d0; blob_detector_fsm_state &lt;= ST_START; end default: blob_detector_fsm_state &lt;= ST_START; endcase end endmodule</span></span></code> </pre><br></div></div><br>  The presence of intermediate states: <b>FIND_OVERLAP_0</b> , <b>UPDATE_OBJ_2</b> , <b>MERGE_OBJ_2</b> , <b>FINISH_OBJ_2</b> and <b>UPLOAD_DATA_START</b> is associated with reading the 2-port FPGA memory.  It turned out that reading memory for 1 clock cycle is not possible, in other words, setting the address in the current clock cycle, we will not receive valid data from the memory in the next clock cycle, but we will receive only after one clock cycle.  The altsyncram <b>mega-</b> function <b>inputs are</b> register and synchronous to the recording block.  This is where the lag in 1 clock is obtained.  I hope that I understood this correctly :) <br><br><h3>  Bounding box generator </h3><br>  This block is used to draw a rectangular frame around the found object.  Since the objects are implemented in the amount of 32, then the frame generators are also 32. All of them are connected in series and each of them has its own unique address.  This address is the same as the object's address in the <b>object memory of</b> the <b>Blob detector</b> module.  When reading data from a FIFO, the frame generator compares the address from the FIFO with its unique address and either loads the coordinates of the object to draw the frame into itself or skips them. <br><br>  Further operation of the generator is rather trivial: the coordinates of this pixel come to the frame generator along with the pixel data, and the detector compares them with the loaded coordinates from the FIFO.  If the incoming coordinates are within the loaded coordinates, then the color of the pixel changes to the color of the frame, otherwise the pixel remains unchanged. <br><br>  Box generator code <br><br><div class="spoiler">  <b class="spoiler_title">Bounding box generator</b> <div class="spoiler_text"><pre> <code class="hljs vhdl">module box_generator #( <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> BADDR = <span class="hljs-number"><span class="hljs-number">5</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> COLOR = <span class="hljs-number"><span class="hljs-number">16</span></span><span class="hljs-symbol"><span class="hljs-symbol">'hF8_00</span></span> ) ( input clk, input nRst, input [<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] addr, input [<span class="hljs-number"><span class="hljs-number">40</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data, input we, input [<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] hcount, input [<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] vcount, input [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] pixel_i, output wire [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] pixel_o ); reg [<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] xs = <span class="hljs-number"><span class="hljs-number">0</span></span>,xe = <span class="hljs-number"><span class="hljs-number">0</span></span>,ys = <span class="hljs-number"><span class="hljs-number">0</span></span>,ye = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg box_valid = <span class="hljs-number"><span class="hljs-number">0</span></span>; reg [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] pixel_r; wire addr_valid = (addr == BADDR) ? <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b1</span></span> : <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; always @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge nRst) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nRst) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xs &lt;= <span class="hljs-number"><span class="hljs-number">11</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; ys &lt;= <span class="hljs-number"><span class="hljs-number">11</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; xe &lt;= <span class="hljs-number"><span class="hljs-number">11</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; ye &lt;= <span class="hljs-number"><span class="hljs-number">11</span></span><span class="hljs-symbol"><span class="hljs-symbol">'d0</span></span>; box_valid &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span><span class="hljs-symbol"><span class="hljs-symbol">'b0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (we &amp;&amp; addr_valid) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> xs = data[<span class="hljs-number"><span class="hljs-number">39</span></span>:<span class="hljs-number"><span class="hljs-number">30</span></span>]; xe = data[<span class="hljs-number"><span class="hljs-number">29</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span>]; ys = data[<span class="hljs-number"><span class="hljs-number">19</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>]; ye = data[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]; box_valid = data[<span class="hljs-number"><span class="hljs-number">40</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> always @(*) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((hcount &gt;= xs &amp;&amp; hcount &lt;= xe) &amp;&amp; (vcount == ys || vcount == ye)) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pixel_r = COLOR; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((hcount == xs || hcount == xe) &amp;&amp; (vcount &gt;= ys &amp;&amp; vcount &lt;= ye)) pixel_r = COLOR; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> pixel_r = pixel_i; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign pixel_o = box_valid ? pixel_r : pixel_i; endmodule</code> </pre><br></div></div><br>  The insertion of 32 frame generators is sequentially performed using the <b>generate</b> operator.  The output of each previous module is input to the following. <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">wire</span></span> [<span class="hljs-number"><span class="hljs-number">15</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] box_out [<span class="hljs-number"><span class="hljs-number">0</span></span>:`<span class="hljs-type"><span class="hljs-type">OBJ_LIMIT</span></span><span class="hljs-number"><span class="hljs-number">-1</span></span>]; genvar i; generate for(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; `<span class="hljs-type"><span class="hljs-type">OBJ_LIMIT</span></span>; i = i + <span class="hljs-number"><span class="hljs-number">1</span></span> ) begin : box_gen <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == <span class="hljs-number"><span class="hljs-number">0</span></span>) begin box_generator #( .<span class="hljs-type"><span class="hljs-type">BADDR</span></span>(i), .<span class="hljs-type"><span class="hljs-type">COLOR</span></span>(`<span class="hljs-type"><span class="hljs-type">CL_RED</span></span>) ) <span class="hljs-type"><span class="hljs-type">BOX_GEN</span></span> ( .clk(pix_clk), .nRst(nRst), .addr(box_data[<span class="hljs-number"><span class="hljs-number">45</span></span>:<span class="hljs-number"><span class="hljs-number">41</span></span>]), .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_data</span></span></span><span class="hljs-class">[40:0]), .we(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_fifo_rd_en</span></span></span><span class="hljs-class">), .hcount(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter_x</span></span></span><span class="hljs-class">), .vcount(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter_y</span></span></span><span class="hljs-class">), .pixel_i({</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">morph_out</span></span></span><span class="hljs-class">[7:3], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">morph_out</span></span></span><span class="hljs-class">[7:2], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">morph_out</span></span></span><span class="hljs-class">[7:3]}), .pixel_o(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_out</span></span></span><span class="hljs-class">[0]) ); end else begin box_generator #( .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BADDR(i)</span></span></span><span class="hljs-class">, .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">COLOR</span></span></span><span class="hljs-class">(`</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">CL_RED</span></span></span><span class="hljs-class">) ) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BOX_GEN</span></span></span><span class="hljs-class"> ( .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clk</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pix_clk</span></span></span><span class="hljs-class">), .nRst(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nRst</span></span></span><span class="hljs-class">), .addr(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_data</span></span></span><span class="hljs-class">[45:41]), .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_data</span></span></span><span class="hljs-class">[40:0]), .we(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_fifo_rd_en</span></span></span><span class="hljs-class">), .hcount(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter_x</span></span></span><span class="hljs-class">), .vcount(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter_y</span></span></span><span class="hljs-class">), .pixel_i(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_out</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">-1]), .pixel_o(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_out</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">i</span></span></span><span class="hljs-class">]) ); end end ndgenerate</span></span></code> </pre><br>  The above blocks are connected as follows: <br><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">wire</span></span> [<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_start, run_end; wire row_end, frame_end, new_run; wire [<span class="hljs-number"><span class="hljs-number">21</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_fifo_data_o; wire run_fifo_full, run_fifo_empty, run_fifo_wr_en, run_fifo_rd_en; run_detector #( .<span class="hljs-type"><span class="hljs-type">RES_X</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>'d320), .<span class="hljs-type"><span class="hljs-type">RES_Y</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>'d240), .<span class="hljs-type"><span class="hljs-type">XOFFSET</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>'d320), .<span class="hljs-type"><span class="hljs-type">YOFFSET</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>'d0) ) <span class="hljs-type"><span class="hljs-type">RUN_DETECTOR</span></span> ( .clk(pix_clk), .nRst(nRst), .data_valid(in_frame2), .data_in(&amp;morph_out), .xi(counter_x), .yi(counter_y), .run_start(run_start), .run_end(run_end), .row_end(row_end), .frame_end(frame_end), .new_run(new_run), .rd_req(run_read_req) ); wire [<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] run_fifo_rd_used, run_fifo_wr_used; wire run_fifo_rd_avail = |run_fifo_rd_used[<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>]; wire run_fifo_almost_full = &amp;run_fifo_wr_used[<span class="hljs-number"><span class="hljs-number">9</span></span>:<span class="hljs-number"><span class="hljs-number">2</span></span>]; assign run_fifo_wr_en = (!run_fifo_almost_full &amp;&amp; new_run) ? <span class="hljs-number"><span class="hljs-number">1</span></span>'b1: <span class="hljs-number"><span class="hljs-number">1</span></span>'b0; alt_fifo_22x512 <span class="hljs-type"><span class="hljs-type">RUN_FIFO</span></span> ( .wrclk(pix_clk), .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">({</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">frame_end</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">row_end</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_start</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_end</span></span></span><span class="hljs-class">}), .aclr(~</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nRst</span></span></span><span class="hljs-class">), .rdreq(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_rd_en</span></span></span><span class="hljs-class">), .wrreq(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_wr_en</span></span></span><span class="hljs-class">), .rdempty(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_empty</span></span></span><span class="hljs-class">), .rdclk(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clk</span></span></span><span class="hljs-class">), .wrfull(), .q(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_data_o</span></span></span><span class="hljs-class">), .rdusedw(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_rd_used</span></span></span><span class="hljs-class">), .wrusedw(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_wr_used</span></span></span><span class="hljs-class">) ); wire box_we; wire [47:0] box_data; wire [47:0] box_data_det; blob_detector #( .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RES_X</span></span></span><span class="hljs-class">(10'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d320</span></span></span><span class="hljs-class">), .</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RES_Y</span></span></span><span class="hljs-class">(10'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d240</span></span></span><span class="hljs-class">) ) </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BLOB_DET</span></span></span><span class="hljs-class"> ( .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clk</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clk</span></span></span><span class="hljs-class">), .nRst(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nRst</span></span></span><span class="hljs-class">), // input </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RUN</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FIFO</span></span></span><span class="hljs-class"> .fifo_empty(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_empty</span></span></span><span class="hljs-class">), .fifo_data(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_data_o</span></span></span><span class="hljs-class">), .fifo_rd_en(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">run_fifo_rd_en</span></span></span><span class="hljs-class">), // output boxes interface .we(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_we</span></span></span><span class="hljs-class">), .data_o(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_data_det</span></span></span><span class="hljs-class">) ); wire [7:0] box_fifo_rd_used, box_fifo_wr_used; wire box_fifo_rd_avail = |box_fifo_rd_used[7:0]; wire box_fifo_almost_full = &amp;box_fifo_wr_used[6:2]; wire box_fifo_wr_en = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_we</span></span></span><span class="hljs-class"> &amp;&amp; !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_fifo_almost_full</span></span></span><span class="hljs-class">) ? 1'b1 : 1'b0; // read object </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">FIFO</span></span></span><span class="hljs-class"> right after valid first screen (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">might</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">be</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">done</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">anywhere</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">within</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">frame</span></span></span><span class="hljs-class">) wire obj_read_ena = ((</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter_y</span></span></span><span class="hljs-class"> == 11'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d0</span></span></span><span class="hljs-class">) &amp;&amp; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">counter_x</span></span></span><span class="hljs-class"> &lt; 10'</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d32</span></span></span><span class="hljs-class">)) ? 1'b1 : 1'b0; wire box_fifo_rd_en = box_fifo_rd_avail &amp;&amp; obj_read_ena; dcfifo_41x128 </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">BOX_FIFO</span></span></span><span class="hljs-class"> ( .</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">aclr</span></span></span><span class="hljs-class">(~</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nRst</span></span></span><span class="hljs-class">), .</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_data_det</span></span></span><span class="hljs-class">), .rdclk(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pix_clk</span></span></span><span class="hljs-class">), .rdreq(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_fifo_rd_en</span></span></span><span class="hljs-class">), .wrclk(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clk</span></span></span><span class="hljs-class">), .wrreq(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_fifo_wr_en</span></span></span><span class="hljs-class">), .q(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_data</span></span></span><span class="hljs-class">), .rdempty(), .rdusedw(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_fifo_rd_used</span></span></span><span class="hljs-class">), .wrfull(), .wrusedw(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">box_fifo_wr_used</span></span></span><span class="hljs-class">) );</span></span></code> </pre><br><h3>  results </h3><br>  The result of the work of the detector of multiple objects is presented in this video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/O5qaqyZWG6A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h3>  findings </h3><br>  The resulting multi-object detector is scalable.  To work with large resolutions of the input image, there is a possibility of increasing the number of detected objects by increasing the memory capacity of objects and RUNs. <br><br><h3>  Materials on the topic </h3><br>  ‚Üí <a href="http://libgen.me/view.php%3Fid%3D738271">Donald G. Bailey Design for Embedded Image Processing on FPGAs</a> <br>  ‚Üí <a href="http://www.electronics.dit.ie/staff/aschwarzbacher/research/mpc08-1Blob.pdf">Real-Time Blob Analysis Using the Run Length Encoding</a> ‚Üí <a href="http://www.electronics.dit.ie/staff/aschwarzbacher/research/mpc08-1Blob.pdf">FPGA</a> <br>  ‚Üí <a href="http://seat.massey.ac.nz/research/centres/SPRG/pdfs/2015_CASVT_PP.pdf">A Resource-Efficient Hardware Architecture for Connected Components Analysis</a> </div><p>Source: <a href="https://habr.com/ru/post/327162/">https://habr.com/ru/post/327162/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../327148/index.html">A simple reminder in Telegram</a></li>
<li><a href="../327150/index.html">Setting up Zabbix 3.2 on Ubuntu Server 16.04 LTS</a></li>
<li><a href="../327152/index.html">Mikrotik L2TP / IPSec for NAT: ipsec, error failed to pre-process ph2 packet</a></li>
<li><a href="../327158/index.html">7 Barriers to Implementing Flexible Methodologies in Large Organizations</a></li>
<li><a href="../327160/index.html">SQL query for PHP (Version 0.2)</a></li>
<li><a href="../327164/index.html">Genres and settings of mobile games - statistics for April 2017</a></li>
<li><a href="../327166/index.html">Fast roaming (802.11r) on a Lede-based WiFi network (aka OpenWRT)</a></li>
<li><a href="../327168/index.html">Autonumber in four languages. Part 2</a></li>
<li><a href="../327170/index.html">Yii2-advanced: Flexible configuration of Yii2 RBAC (roles, permissions, rules)</a></li>
<li><a href="../327172/index.html">"SQL Server 2017": Now with Python support</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>