<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Add instructions to the microprocessor MIPS, which work in the pipeline as his own</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Is it possible to add instructions (commands) to the microprocessor? If you use FPGA / FPGA chips with reconfigurable logic and a microprocessor core,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Add instructions to the microprocessor MIPS, which work in the pipeline as his own</h1><div class="post__text post__text-html js-mediator-article">  Is it possible to add instructions (commands) to the microprocessor?  If you use FPGA / FPGA chips with reconfigurable logic and a microprocessor core, which are synthesized from the description in Verilog and VHDL languages, you can.  Moreover, it will be an ‚Äúhonest‚Äù, true expansion of the instruction set, and not a trick of the type of software emulation of instructions in the exception handler from the reserved instruction, and not the ‚Äúmicrocode‚Äù popular in the historical processors of the 1970s. <br><br>  Commands added to a modern synthesized processor by modifying its source code on Verilog or VHDL can work in the pipeline and be processed by the processor as its own, without time delays. <br><br>  The main problem with modifying the source design of the processor on Verilog or VHDL is the complexity.  You need to understand how the logic of the various blocks works and avoid unwanted side effects.  Fortunately, there is a processor expansion method that turns a semester student project into something that a student can design in one lab.  This method is the CorExtend / UDI (User Defined Instructions) interface in the microprocessor core MIPS microAptiv UP, which is used in the package to form the MIPSfpga. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As part of Imagination Technologies' MIPSfpga university program, you can download this industrial code on the Verilog MIPS microAptiv UP processor. <br>  <a href="https://community.imgtec.com/university/resources/">https://community.imgtec.com/university/resources/</a> <br><br>  One of the common uses for UDI is bit manipulation in encryption algorithms.  Another example is the creation of special instructions for accelerating DSP <a href="http://cdn.imgtec.com/mips-documentation/login-required/accelerating_dsp_filter_loops_with_mips_corextend_instructions.pdf">Accelerating DSP Filter Loops with MIPS¬Æ CorExtend¬Æ Instructions algorithms</a> . <br><br>  However, in the MIPSfpga documentation set, the interface between the kernel and CorExtend is not described in sufficient detail.  Detailed documentation is provided only to licensees of kernels.  This article presents my description of this interface based on the study of the source code.  It can also be downloaded in pdf format. <a href="http://zatslogic.blogspot.com/p/my-pdf-articles.html">MIPS microAptiv UP Processor CorExtend UDI interface protocol guide</a> . <br><br>  CorExtend occupies the next place in the RTL hierarchy of the m14k microAptiv core. <br><br> <a href=""><img alt="CorExtend RTL Hierarchy" height="273" src="https://habrastorage.org/getpro/habr/post_images/ec9/af0/244/ec9af0244fd25600e3391772c23896dc.png" title="CorExtend RTL Hierarchy" width="640"></a> <br><a name="habracut"></a><br>  All m14k_cpu level signals, including CorExtend UDI, are described in the MIPS32 microAptiv UP Processor Core Family Integrators Guide document (Table 2.3 Signal Descriptions for m14k cpu Level).  It is better to look there, but for clarity, below is an excerpt from there exclusively with CorExtend UDI signals. <br><table border="1"><tbody><tr><td width="130">  <b>Signal name</b> </td><td width="40">  <b>Type of</b> </td><td>  <b>Description</b> </td></tr><tr><td>  UDI_ir_e [31: 0] </td><td align="center">  Out </td><td>  Full word instructions.  Although the module receives rs and rt operands, the entire instruction is transmitted in order to be able to transmit data in the address fields of the operands.  Note that the person who will implement his own UDI block must decode the Opcode and Function field on his own. </td></tr><tr><td>  UDI_irvalid_e </td><td align="center">  Out </td><td>  The valid signal for the instruction word (UDI_ir_e). </td></tr><tr><td>  UDI_rs_e [31: 0] </td><td align="center">  Out </td><td>  Operand rs. </td></tr><tr><td>  UDI_rt_e [31: 0] </td><td align="center">  Out </td><td>  Operand rt. </td></tr><tr><td>  UDI_endianb_e </td><td align="center">  Out </td><td>  Signals that the instruction is executed in Big Endian mode.  The signal is usually not needed, unless a) the UDI instruction operates on part of the data word and is dependent on endian, b) the UDI block operates in big-endian mode. </td></tr><tr><td>  UDI_kd_mode e </td><td align="center">  Out </td><td>  Signals that the instruction is executed in kernel or debug mode.  It can be used to prevent execution of certain instructions in kernel or debug modes. </td></tr><tr><td>  UDI_kill_m </td><td align="center">  Out </td><td>  The kill signal from the exception generated by the previous instruction.  It can be used to remove UDI_stall_m, which will reduce the delay for multi-stroke UDI instructions whose results will not be used. </td></tr><tr><td>  UDI_start_e </td><td align="center">  Out </td><td>  The signal mpc_run_ie from the control unit (Master Pipeline Control). </td></tr><tr><td>  UDI_run_m </td><td align="center">  Out </td><td>  The signal mpc_run_m, used as valid for UDI_kill_m. </td></tr><tr><td>  UDI_greset </td><td align="center">  Out </td><td>  Reset, can be used to reset automata in a UDI block. </td></tr><tr><td>  UDI_gclk </td><td align="center">  Out </td><td>  Clock input in UDI block. </td></tr><tr><td>  UDI gscanenable </td><td align="center">  Out </td><td>  Global scan enable. </td></tr><tr><td>  UDI_ri_e </td><td align="center">  In </td><td>  Signals the Master Pipeline Control (MPC) that the currently executing instruction is reserved.  However, the MPC will take it into account only if the instruction is included in a subset of the user-defined instructions of SPECIAL2 (bits [5: 4] in instruction 2'b01). </td></tr><tr><td>  UDI_rd_m [31: 0] </td><td align="center">  In </td><td>  32-bit result of the executed instruction, available at the stage of M (Memory fetch). </td></tr><tr><td>  UDI_wrreg_e [4: 0] </td><td align="center">  In </td><td>  Register address for recording the result of a user-defined instruction.  Also transmitted to MPC. </td></tr><tr><td>  UDI_stall_m </td><td align="center">  In </td><td>  Signals that the UDI block performs a multi-cycle instruction and must stop the pipeline before writing to the general register.  must be set to 0 for one-cycle instructions.  Signal stage M. </td></tr><tr><td>  UDI_present </td><td align="center">  In </td><td>  A static signal indicating that a UDI block is available. </td></tr><tr><td>  UDI_honor_cee </td><td align="center">  In </td><td>  Indicates whether the processor should take into account the CorExtend Enable (CEE) Status register bit.  If the UDI_honor_cee is set to one and the Status.CEE bit of the Status register is not set, a CorExtend Unusable Exception exception is thrown. </td></tr></tbody></table><br>  In addition to these signals, the CorExtend block has external signals with the number of bits determined by the developer. <br><table border="1"><tbody><tr><td width="150">  <b>Signal name</b> </td><td width="40">  <b>Type of</b> </td><td>  <b>Description</b> </td></tr><tr><td>  UDI_toudi [x-1: 0] </td><td align="center">  In </td><td>  External input CorExtend block of variable length. </td></tr><tr><td>  UDI_fromudi [x-1: 0] </td><td align="center">  Out </td><td>  External output CorExtend block of variable length. </td></tr></tbody></table><br>  To create your CorExtend block you need to change the files m14k_edp_buf misc and m14k_udi_stub should.  In file <br>  m14k_edp_buf_misc input and output ports can be connected, for example, like this. <br><br><pre><code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_ir_e[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = mpc_ir_e ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_irvalid_e = mpc_irval_e ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_rs_e[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = edp_abus_e ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_rt_e[<span class="hljs-number"><span class="hljs-number">31</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = edp_bbus_e ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_endianb_e = cpz_rbigend_e ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_kd_mode_e = cpz_kuc_e ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_kill_m = mpc_killmd_m ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_start_e = mpc_run_ie ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_run_m = mpc_run_m ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_greset = greset ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_gscanenable = gscanenable ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> UDI_gclk = gclk ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> edp_udi_wrreg_e[<span class="hljs-number"><span class="hljs-number">4</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] = UDI_wrreg_e ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> edp_udi_ri_e = UDI_ri_e ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> edp_udi_stall_m = UDI_stall_m ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> edp_udi_present = UDI_present ; <span class="hljs-attribute"><span class="hljs-attribute">assign</span></span> edp_udi_honor_cee = UDI_honor_cee ; <span class="hljs-attribute"><span class="hljs-attribute">mvp_mux2</span></span> <span class="hljs-comment"><span class="hljs-comment">#(32) _res_m_31_0_(res_m[31:0],mpc_udislt_sel_m, asp_m, UDI_rd_m);</span></span></code> </pre> <br><br>  The CorExtend block itself should replace the m14k_udi_stub file.  An example of the interaction between CorExtend and the microAptiv UP kernel is presented in the timeline below. <br> <a href=""><img alt="CorExtend interface protocol waveform" src="https://habrastorage.org/getpro/habr/post_images/63d/546/34d/63d54634d6f287bf16423acd9053c3fa.png" title="CorExtend interface protocol waveform"></a> <br><br>  The UDI_present signal must be pulled to one.  UDI_honor_cee may be pulled to zero.  If you pull it up to one, you will need to reset the Status CEE bit with the mtc0 instruction before executing CorExtend instructions.  If this is not done, a CorExtend unusable exception will appear, and the next clock after UDI_start_e will set the UDI_kill_m signal to two clock cycles. <br><br>  Partially, the instruction must be decoded on the same clock cycle at which the UDI_start_e signal appeared.  This is necessary for generating a UDI_ri_e signal, which should be set at the same time as UDI_start_e appears if the instruction is reserved.  If the instruction implies writing the result to the general register, its address must also be set to UDI_wrreg_e [4: 0] simultaneously with UDI_start_e.  The remaining instruction fields can be written to the register and decoded later. <br><br>  The signal UDI_wrreg_e [4: 0] can address 31 general-purpose registers, a value of 5'd0 means no entry to registers. <br><br>  The result of the UDI instruction to be written to the general register must be set to UDI_rd_m [31: 0] on the next clock after UDI_start_e.  If it is to be recorded later, on the next clock after UDI_start_e, you should set UDI_stall_m.  UDI_stall_m should be reset to zero in one cycle before setting the result to UDI_rd_m [31: 0]. <br><br>  The figure below shows the general format of the UDI instruction.  The Major opcode field is included in the special2 subset and is 6'd28.  The RS and RT fields contain the addresses of the operand registers.  Bits 15..6 can be used at the discretion of the developer.  For example, there you can write the address of the destination register to record the result or send an instantaneous value.  The Function field consists of bits 5..4, which are always 2'b01, and bits 3..0, with which you can encode up to 16 UDI instructions. <br><br> <a href=""><img height="81" src="https://habrastorage.org/getpro/habr/post_images/04c/f26/0a3/04cf260a311a1a74db46bb1591729f1b.png" width="640"></a> <br><br>  The development of the CorExtend block is illustrated by the following example of a DSP accelerator, which calculates the instantaneous power of a complex signal, which is defined as <br>  P (t) = a <sup>2</sup> (t) + b <sup>2</sup> (t), <br>  where a (t) and b (t) are the real and imaginary parts of the signal, respectively. <br>  This operation is useful for detecting a signal by comparing it with a threshold value. <br>  The table below lists the instructions for the DSP accelerator. <br><table border="1"><tbody><tr><td>  <b>Instruction</b> </td><td>  <b>Description</b> </td><td>  <b>function field</b> </td></tr><tr><td>  UDI0 R <sub>D</sub> ;  R <sub>S</sub> ;  R <sub>t</sub> </td><td>  R <sub>D</sub> = R <sub>S</sub> [31:16] <sup>2</sup> + R <sub>T</sub> [31:16] <sup>2</sup> </td><td>  6'b010000 </td></tr><tr><td>  UDI1 R <sub>D</sub> ;  R <sub>S</sub> ;  R <sub>t</sub> </td><td>  R <sub>D</sub> = (R <sub>S</sub> [31:16] <sup>2</sup> + R <sub>T</sub> [31:16] <sup>2</sup> ) &gt;&gt; 1 </td><td>  6'b010001 </td></tr><tr><td>  UDI2 R <sub>D</sub> ;  R <sub>s</sub> </td><td>  R <sub>D</sub> = R <sub>S</sub> [31:16] <sup>2</sup> </td><td>  6'b010010 </td></tr><tr><td>  UDI3 R <sub>S</sub> </td><td>  stored_threshold = R <sub>S</sub> </td><td>  6'b010011 </td></tr><tr><td>  UDI4 R <sub>D</sub> ;  R <sub>S</sub> ;  R <sub>t</sub> </td><td>  R <sub>D</sub> = ((R <sub>S</sub> [31:16] <sup>2</sup> + R <sub>T</sub> [31:16] <sup>2</sup> )&gt; stored_threshold)?  1: 0 </td><td>  6'b010100 </td></tr><tr><td>  UDI5 R <sub>D</sub> ;  R <sub>S</sub> ;  R <sub>t</sub> </td><td>  R <sub>D</sub> = (((R <sub>S</sub> [31:16] <sup>2</sup> + R <sub>T</sub> [31:16] <sup>2</sup> ) &gt;&gt; 1)&gt; stored_threshold)?  1: 0 </td><td>  6'b010101 </td></tr><tr><td>  UDI6 R <sub>D</sub> ;  R <sub>S</sub> ;  R <sub>t</sub> </td><td>  R <sub>D</sub> = (R <sub>S</sub> [31:16] <sup>2</sup> &gt; stored_threshold)?  1: 0 </td><td>  6'b010110 </td></tr></tbody></table><br>  UDI0 calculates the instantaneous signal strength.  The RS and RT operands contain 16-bit real and imaginary parts of the signal.  The 32-bit result is written to the general register at address RD. <br><br>  UDI1 does the same as UDI0.  The difference is that UDI1 shifts the result to prevent overflow. <br><br>  UDI2 calculates the instantaneous signal power using only the real part of the signal.  RT operand is not used. <br><br>  UDI3 writes a 32-bit threshold value to the internal register of the CorExtend block, the result is not returned. <br><br>  UDI4, UDI5 and UDI6 perform the operations of the instructions UDI0, UDI1 and UDI2, respectively, and compare the result with a stored threshold value.  If the threshold is exceeded, the result is 32'd1, otherwise 32'd0. <br><br>  All instructions, except UDI3, write the results in general registers, for which it is necessary to specify its address.  To do this, the RD field was entered, as shown in the figure below. <br> <a href=""><img height="80" src="https://habrastorage.org/getpro/habr/post_images/969/af9/723/969af97234dacb12219b5b4f8be66f05.png" width="640"></a> <br>  The code below shows an example program in MIPS assembly language for testing all the developed UDI instructions. <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">Machine</span></span> Code Instruction Address Assembly Code 3c088000 // bfc00000: lui <span class="hljs-variable"><span class="hljs-variable">$8</span></span>, 0x8000 3c09beaf // bfc00004: lui <span class="hljs-variable"><span class="hljs-variable">$9</span></span>, 0xbeaf <span class="hljs-number"><span class="hljs-number">71095010</span></span> // bfc00008: udi0 <span class="hljs-variable"><span class="hljs-variable">$8</span></span> <span class="hljs-variable"><span class="hljs-variable">$9</span></span> <span class="hljs-variable"><span class="hljs-variable">$10</span></span> <span class="hljs-number"><span class="hljs-number">71095011</span></span> // bfc0000c: udi1 <span class="hljs-variable"><span class="hljs-variable">$8</span></span> <span class="hljs-variable"><span class="hljs-variable">$9</span></span> <span class="hljs-variable"><span class="hljs-variable">$10</span></span> <span class="hljs-number"><span class="hljs-number">71005012</span></span> // bfc00010: udi2 <span class="hljs-variable"><span class="hljs-variable">$8</span></span> <span class="hljs-variable"><span class="hljs-variable">$10</span></span> 3c0bbeaf // bfc00014: lui <span class="hljs-variable"><span class="hljs-variable">$11</span></span>, 0xbeaf 356bdead // bfc00018: ori <span class="hljs-variable"><span class="hljs-variable">$11</span></span>,<span class="hljs-variable"><span class="hljs-variable">$11</span></span>, 0xdead <span class="hljs-number"><span class="hljs-number">71600013</span></span> // bfc0001c: udi3 <span class="hljs-variable"><span class="hljs-variable">$11</span></span> <span class="hljs-number"><span class="hljs-number">71095014</span></span> // bfc00020: L1: udi4 <span class="hljs-variable"><span class="hljs-variable">$8</span></span> <span class="hljs-variable"><span class="hljs-variable">$9</span></span> <span class="hljs-variable"><span class="hljs-variable">$10</span></span> <span class="hljs-number"><span class="hljs-number">71095015</span></span> // bfc00024: udi5 <span class="hljs-variable"><span class="hljs-variable">$8</span></span> <span class="hljs-variable"><span class="hljs-variable">$9</span></span> <span class="hljs-variable"><span class="hljs-variable">$10</span></span> <span class="hljs-number"><span class="hljs-number">71095016</span></span> // bfc00028: udi6 <span class="hljs-variable"><span class="hljs-variable">$8</span></span> <span class="hljs-variable"><span class="hljs-variable">$9</span></span> <span class="hljs-variable"><span class="hljs-variable">$10</span></span> 3c0b0001 // bfc0002c: lui <span class="hljs-variable"><span class="hljs-variable">$11</span></span>, 0x0001 356bfeed // bfc00030: ori <span class="hljs-variable"><span class="hljs-variable">$11</span></span>,<span class="hljs-variable"><span class="hljs-variable">$11</span></span>, 0xfeed <span class="hljs-number"><span class="hljs-number">71600013</span></span> // bfc00034: udi3 <span class="hljs-variable"><span class="hljs-variable">$11</span></span> 1000fff9 // bfc00038: beq <span class="hljs-variable"><span class="hljs-variable">$0</span></span>, <span class="hljs-variable"><span class="hljs-variable">$0</span></span>, L1 <span class="hljs-number"><span class="hljs-number">00000000</span></span> // bfc0003c: nop</code> </pre><br>  A sample project with the implementation of a CorExtend block with the above instructions can be downloaded at <a href="https://github.com/zatslogic/UDI_example">https://github.com/zatslogic/UDI_example</a> . <br><br>  The project includes the source code for the simulation, with the exception of files from the rtl_up directory.  To get them, you must register with the Imagination University Program and request a download ( <a href="https://community.imgtec.com/downloads/mipsfpga-getting-started-version-1-2">https://community.imgtec.com/downloads/mipsfpga-getting-started-version-1-2</a> ).  Also, to run the simulation, you must have XilinxCorelib, you can compile it in Vivado using the compile_simlib command. <br><br>  The project includes two options for the implementation of the CorExtend block.  In the first case, all UDI instructions are executed in one cycle.  In the second, additional registers were inserted and some instructions require more clocks to execute.  This was done specifically to enable the UDI_stall_m signal. <br><br>  On the time diagrams, the simulation of the above program in assembler is presented below. <br><br>  For the first one-stroke variant of the block, the instructions UDI0, UDI1 and UDI2 are executed as follows. <br> <a href=""><img height="369" src="https://habrastorage.org/getpro/habr/post_images/614/f6f/3bb/614f6f3bb7e5b408f9b6575d47bca9b7.png" width="640"></a> <br><br>  You can see the instructions appear on UDI_ir_e with the signals UDI_irvalid_e and UDI_start_e.  Operands are also available on this clock.  At the same tact, the address of the result record in the general register is formed.  The result is set to UDI_rd_m on the next clock cycle. <br>  In addition, the time diagram shows the signals of the block of general-purpose registers.  The address of the entry in them can be seen on mpc_dest_w.  The data is presented on edp_wrdata_w with the write enable signal to mpc_rfwrite_w.  The signals mpc_rega_i and mpc_regb_i contain the addresses of operands read from general registers. <br><br>  This timing diagram shows the execution of instructions UDI3, UDI4, UDI5 and UDI6. <br> <a href=""><img height="370" src="https://habrastorage.org/getpro/habr/post_images/c98/075/836/c98075836605b8adfba32a9289e69567.png" width="640"></a> <br><br>  As can be seen from the program's listing in assembler, UDI3 writes 0xbeafdead to the stored_threshold.  The results of the execution of instructions UDI4, UDI5 and UDI6 are zero, because the threshold has never been exceeded. <br><br>  In the following timing diagram, the instructions UDI3, UDI4, UDI5 and UDI6 are executed after the conditional transition.  Now the threshold value is less than the results of calculations and you can see that 0x000001 is written to the result registers. <br> <a href=""><img height="370" src="https://habrastorage.org/getpro/habr/post_images/b85/7ef/041/b857ef04101c01d20b0f2033fa0f4b65.png" width="640"></a> <br><br>  The following three timing diagrams show a UDI block simulation with additional registers. <br><br>  This timing diagram shows the execution of instructions UDI0, UDI1 and UDI2.  The signal UDI_stall_m is set for the duration of the calculations.  On the next clock after its removal, the result is set to UDI_rd_m.  Even after the beat, the result is recorded in general registers. <br> <a href=""><img height="370" src="https://habrastorage.org/getpro/habr/post_images/684/daf/9d7/684daf9d701c0493f7671a26ad9ff32b.png" width="640"></a> <br><br>  This timing diagram shows UDI4, UDI5 and UDI6 instructions with a UDI_stall_m signal. <br> <a href=""><img height="370" src="https://habrastorage.org/getpro/habr/post_images/360/202/dc9/360202dc970da729bff053bc9a6f4002.png" width="640"></a> <br><br>  On the diagram after it, the instructions UDI4, UDI5 and UDI6 are executed temporarily after the conditional transition. <br> <a href=""><img height="370" src="https://habrastorage.org/getpro/habr/post_images/9f5/ca8/dbb/9f5ca8dbb13e25450f8fbeef76365096.png" width="640"></a> <br><br>  I hope this material will be useful for those who want to also participate in the MIPSfpga program and create a project using UDI instructions. </div><p>Source: <a href="https://habr.com/ru/post/276205/">https://habr.com/ru/post/276205/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276185/index.html">XAML Developer Chips: Embedded Converters</a></li>
<li><a href="../276187/index.html">We are implementing an analogue of Apple iCloud Voicemail using free grammars from Yandex</a></li>
<li><a href="../276189/index.html">Moxy - MVP implementation for Android with a pinch of magic</a></li>
<li><a href="../276193/index.html">Finite Volume method - implementation on the example of thermal conductivity</a></li>
<li><a href="../276195/index.html">Algorithms for searching palindromes</a></li>
<li><a href="../276209/index.html">Millimetric is back. Now - Open Source</a></li>
<li><a href="../276211/index.html">The study of common Malvari under Android</a></li>
<li><a href="../276213/index.html">OpenSSL eliminates a dangerous vulnerability that allowed an attacker to decrypt HTTPS traffic</a></li>
<li><a href="../276217/index.html">What actually virtual memory can do</a></li>
<li><a href="../276219/index.html">Researchers have found many critical vulnerabilities in payment protocols</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>