<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Towers of Hanoi - a theoretical solution without recursion</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The task of the Towers of Hanoi is one of the very first tasks that are offered to novice programmers, mainly to illustrate the concept of recursive s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Towers of Hanoi - a theoretical solution without recursion</h1><div class="post__text post__text-html js-mediator-article"><p>  The task of the Towers of Hanoi is one of the very first tasks that are offered to novice programmers, mainly to illustrate the concept of recursive solutions.  This article provides a method that allows you to theoretically, without recursion, indicate the optimal solution for the current course. </p><br><p><img src="https://lh3.googleusercontent.com/v9kYFJghQXa7AOf1vm5KwfqB6p4luPgpdnIl_go-dBbqAr7-SexpbFbS7YTjFEm5R74=h310" alt="image"></p><a name="habracut"></a><br><p>  The Tower of Hanoi is one of the popular puzzles of the 19th century.  Three rods are given, on one of which eight rings are strung, with the rings differing in size and smaller on the larger one.  The task is to transfer the pyramid of eight rings for the smallest number of moves to another rod.  It is allowed to transfer only one ring at a time, and you cannot put a larger ring on a smaller one. </p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/07/Tower_of_Hanoi.jpeg/300px-Tower_of_Hanoi.jpeg" alt="image"></p><br><p>  The classical solution of this problem with three rods assumes that for a given number of rings <strong>n the</strong> number of rearrangements is calculated by the formula <br><img src="https://tex.s2cms.ru/png/2%5En-1" alt="image">  . </p><br><p>  An additional attraction to this task is given by the accompanying legend: </p><br><blockquote>  In the Great Temple of the city of Benares, under the cathedral, which marks the middle of the world, there is a bronze disk, on which 3 diamond rods are fixed, one elbow high and the thickness of a bee.  Long ago, at the very beginning of time, the monks of this monastery were guilty before the god Brahma.  Enraged, Brahma erected three tall rods and on one of them laid 64 discs made of pure gold.  And so that each smaller disk lies on a larger one.  As soon as all 64 disks are shifted from the rod, on which Brahma laid them while creating the world, to another rod, the tower together with the temple will turn into dust and the world will perish under the thunder of thunder. </blockquote><p><img src="http://biysk-liceum.ru/projects_stud/2004/hanoybashny/pic/han.jpg" alt="image"></p><br><p>  In the meantime, the newcomer is invited to evaluate the complexity of this decision in order to impress with the result: the number of disk movements that the monks have to make is equal to <strong>18,446,744,073,709,551,615</strong> .  If the monks, working day and night, did one second disk movement every second, their work would last <strong>584 billion</strong> years. </p><br><p><img src="http://biysk-liceum.ru/projects_stud/2004/hanoybashny/pic/logo.gif" alt="image"></p><br><p>  The essence of the solution is reduced to the understanding that to move the current disk, it is necessary to solve the problem of transferring all previous disks to a free core, moving the required disk and then moving back all previous smaller disks to the desired core.  Thus, the solution of the problem is reduced to the previous solutions, which illustrates the recursion mechanism. </p><br><p>  Alexander Busarov <a href="https://habrahabr.ru/users/mrshoor/" class="user_link">MrShoor has</a> written a very informative <a href="https://habrahabr.ru/post/200758/">post</a> that perfectly complements the corresponding <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B1%25D0%25B0%25D1%2588%25D0%25BD%25D1%258F">article in Wikipedia</a> , with a very detailed program code, I recommend to get acquainted with its implementation of recursion. </p><br><p>  In the same post there is a description of the fractal nature of the algorithm.  I will try to continue this direction, revealing the application of the Gray code for this particular task. </p><br><p>  I will quote from the corresponding article in Wikipedia: </p><br><blockquote>  Gray codes are used in solving the problem of the Hanoi Towers.  Let N be the number of disks.  We start with the Gray code of length N, consisting of only zeros (that is, G (0)), and we will move along Gray codes (from G (i) go to G (i + 1)).  Let us assign each first bit of the current Gray code to the first disk (with the smallest bit corresponding to the smallest disk, and the oldest bit to the largest one).  Since at each step exactly one bit changes, we can understand the change in bit I as the movement of the I-th disk.  Note that for all discs except the smallest, at each step there is exactly one course option (with the exception of the starting and final positions).  For the smallest disk, there are always two options for the move, however, there is a strategy for selecting the move, which always leads to the answer: if N is odd, then the sequence of movements of the smallest disk is f-&gt; t-&gt; r-&gt; f-&gt; t-&gt; r-&gt; (where is f-starting rod, t-final rod, r-remaining rod), and if N is even, then f-&gt; r-&gt; t-&gt; f-&gt; r-&gt; t-&gt; ... </blockquote><p>  The optimal solution of the problem is reduced to determining the position of the disks after the next move.  At the very beginning (at zero stroke) all the disks are on the same starting rod f.  The numbering of the scales of the disks is carried out from number 1 in ascending order.  It is required to describe the position of the disks on the course with the number <strong>m</strong> . </p><br><p>  Obviously, with the optimal solution after move <strong>m, the</strong> number of disks moved <strong>n</strong> will be no more than </p><br><p><img src="//tex.s2cms.ru/png/n%3D%5Clceil%20log%7B_2%7D(m%2B1)%5Crceil" alt="image">  <strong>(1)</strong> . <br>  The remaining disks of a larger size can be disregarded, which is very convenient given the more general assumption of an infinite number of disks in the initial problem with three rods. </p><br><p>  Further, having defined the number of disks moved, we will determine their position. </p><br><p>  In view of the fractality of the solution, which was described in the sources mentioned above, it becomes obvious that, thanks to the ‚Äúnesting‚Äù of the solutions into each other, the connection between the binary code of the move number and the number of the disk being moved is seen. </p><br><p>  In particular, during this move, the disk whose weight " <strong>i</strong> " correlates with the maximum power of two in the binary decomposition of the number <strong>m of the</strong> current move minus one moves: <br><img src="//tex.s2cms.ru/png/m%5Cequiv0(mod%5C%3A2%5E%7Bi-1%7D)" alt="image">  <strong>(2)</strong> . </p><br><p>  In the same Pascal / Delphi notation that <a href="https://habrahabr.ru/users/mrshoor/" class="user_link">MrShoor</a> uses in its code, this can be written as follows: </p><br><pre><code class="delphi hljs">i:=<span class="hljs-number"><span class="hljs-number">0</span></span>; deg2value:=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((m <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> deg2value) = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> i:=i+<span class="hljs-number"><span class="hljs-number">1</span></span>; deg2value:=deg2value*<span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><p>  Thus, for each of the disks with weight <strong>i,</strong> we can determine the move <strong>j</strong> on which the disk of a given weight was last moved: </p><br><p><img src="//tex.s2cms.ru/png/max(j)%3Aj%5Cequiv0(mod%5C%3A2%5E%7Bi-1%7D)%5C%3A%5C%26%5C%3Aj%5Cequiv1(mod%5C%3A2%5Ei)%5C%3A%5C%26%5C%3Aj%3C%3Dm" alt="image">  . </p><br><p>  The code to determine the <strong>num_move</strong> stroke <strong>number of the</strong> last disk move with weight <strong>i</strong> may look similar (with the condition for enabling the Math module): </p><br><pre> <code class="delphi hljs">deg2value:=Power(<span class="hljs-number"><span class="hljs-number">2</span></span>,i-<span class="hljs-number"><span class="hljs-number">1</span></span>); q_move:=m <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> deg2value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (q_move <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>) = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> q_move:=q_move-<span class="hljs-number"><span class="hljs-number">1</span></span>; num_move:=q_move * deg2value; q_move=(q_move+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">div</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre> <br><p>  It is worth paying attention to the fact that along with the q_move variable, the number of disk movements with weight <strong>i</strong> from the beginning of the game is obtained. </p><br><p>  So, in the interim, we know how many times each disc was moved during the game after each turn.  Now we will decide on where each of the disks moved. </p><br><p>  As noted in Wikipedia, the movement of the upper disk is cyclical and, when choosing a specific destination bar t, if N is odd, then the sequence of movements of the smallest disk is f-&gt; t-&gt; r-&gt; f-&gt; t-&gt; r-&gt; ... (where f-starting rod, t-final rod, r-remaining rod), and if N is even, then f-&gt; r-&gt; t-&gt; f-&gt; r-&gt; t-&gt; ... </p><br><p>  Recalling the fractality, you can see that if you discard the upper part of the previous disks, the current disk also performs a similar cyclical movement during its own moves.  Taking into account this fact, it becomes obvious that, depending on the parity of the disk number, the cycle of movement of the odd disk coincides with the cycle of movement of the first disk, and the cycle of movement of even disks differs in the order of the rods t and r. <br>  In particular, knowing the q_move displacement number and the parity of the current disk number, it is possible by simple division by 3 of the remainder to determine the last rod where the given disk was moved. </p><br><p>  Therefore, having the total number of disks N at the input, the selected destination rod t and the number of the current stroke m, you can restore the position of all disks at the optimal solution without resorting to recursive algorithms. </p><br><p>  For those who are interested in variations of the task of the Tower of Hanoi, in particular, cases of 4 or more rods, I suggest to get acquainted with the experience of <a href="https://habrahabr.ru/users/papabubadiop/" class="user_link">PapaBubaDiop</a> , <a href="https://habrahabr.ru/post/118862/">developing this direction</a> in the form of games, while trying to monetize some versions on different platforms. </p><br><p>  I hope that for those readers who are interested in theoretical solutions that are more optimized for such problems with a large amount of input data and computational resources, this publication will be useful in the future as a basis for your own results. </p><br><p>  The style and language are a bit dry and are more suitable for academic work, so please do not judge it very harshly, especially considering the attempt to straighten karma and get out of the minus.  All the best and bright, Happy New 2017 Year: success and success in all good! </p><br><p>  UPD: Thank you all for the comments, comments and tips.  An example of a script <a href="http://www.sibars.net/media/hanoi.php">that</a> works according to the above algorithm is available at <a href="http://www.sibars.net/media/hanoi.php">this link</a> .  A GMP library was used to handle large numbers. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/318964/">https://habr.com/ru/post/318964/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318952/index.html">Let's Encrypt and nginx: configuration in Debian and Ubuntu</a></li>
<li><a href="../318954/index.html">Processing preprocessor directives in Objective-C</a></li>
<li><a href="../318958/index.html">json-api-normalizer: an easy way to make friends with Redux and the JSON API</a></li>
<li><a href="../318960/index.html">Scala type classes (with a little overview of the cats library)</a></li>
<li><a href="../318962/index.html">About string formatting in modern C ++</a></li>
<li><a href="../318966/index.html">Features of the development of mobile MMO RTS. Part 2</a></li>
<li><a href="../318968/index.html">Security in IoT: Security Architecture</a></li>
<li><a href="../318970/index.html">Neural network optimization methods</a></li>
<li><a href="../318972/index.html">Adaptive jQuery without window.matchMedia</a></li>
<li><a href="../318976/index.html">How IT professionals work. Ilya Safonov, Senior Research Scientist at Schlumberger</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>