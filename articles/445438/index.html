<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to lit-element and web components based on it</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At one point, I had to urgently get acquainted with web components and find a way to conveniently develop with their help. I plan to write a series of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to lit-element and web components based on it</h1><div class="post__text post__text-html js-mediator-article"><p>  At one point, I had to urgently get acquainted with web components and find a way to conveniently develop with their help.  I plan to write a series of articles that <br>  somehow systematize knowledge of web components, lit-element and give a brief acquaintance with this technology for others. <a name="habracut"></a>  I am not an expert in this technology and will gladly accept any feedback. </p><br><p>  <a href="https://github.com/Polymer/lit-element">lit-element</a> is a wrapper (base template) for native web components.  It implements many convenient methods that are not in the specification.  Due to its proximity to the native implementation, the lit-element shows very good results in various <a href="https://vogloblinsky.github.io/web-components-benchmark/">benchmark</a> relative to other approaches (as of 06.02.2019). </p><br><p>  The bonuses that I see from using lit-element as the base class of web components: </p><br><ol><li>  This technology implements the second version and ‚Äúhad children with childhood diseases‚Äù characteristic of the instruments that have just appeared. </li><li>  Assembly can be carried out both polymer, and webpack, typescript, rollup, etc., it allows you to embed the lit-element in any modern project without any problems. </li><li>  The lit-element has a very convenient system of working with property in terms of typing, initiating and converting values. </li><li>  The lit-element implements almost the same logic as the reactant, i.e.  it provides the very minimum ‚Äî a single template for building components and rendering it, and does not limit the developer in choosing an ecosystem and additional libraries. </li></ol><br><p>  Let's create a simple web component on lit-element.  Refer to the documentation.  We need the following: </p><br><ol><li>  Add a lit-element package to our npm build <br><br><pre><code class="plaintext hljs">npm install --save lit-element</code> </pre> </li><li>  Create our component. </li></ol><br><p>  For example, we need to create a web component that is initialized in the <code>my-component</code> tag.  To do this, create a js file <code>my-component.js</code> and define its basic template: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//       lit-element import { } from ''; //      class MyComponent { } //      customElements.define();</span></span></code> </pre><br><p>  First of all, import our basic template: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// LitElement -    ()   - // html -  lit-html,     ,  //    html   </span></span></code> </pre><br><p>  Second, create the web component itself using <code>LitElement</code> </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   ,    //  LitElement    HTMLElement class MyComponent extends LitElement { //    LitElement   //      constructor  connectedCallback //           //    ,       // shadowDOM   {mode: 'open'} render() { return html`&lt;p&gt;Hello World!&lt;/p&gt;` } }</span></span></code> </pre><br><p>  And the last thing is to register the web component in the browser. </p><br><pre> <code class="javascript hljs">customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  As a result, we obtain the following: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { LitElement, html } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">`&lt;p&gt;Hello World!&lt;/p&gt;`</span></span> } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-component'</span></span>, MyComponent);</code> </pre><br><p>  If you eliminate the need to connect <code>my-component.js</code> to html, then that's all.  The simplest component is ready. </p><br><p>  I suggest not to reinvent the wheel and take a ready-made assembly of the lit-element-build-rollup.  Follow the instructions: </p><br><pre> <code class="plaintext hljs">git clone https://github.com/PolymerLabs/lit-element-build-rollup.git cd lit-element-build-rollup npm install npm run build npm run start</code> </pre><br><p>  After executing all the commands, go to the page in the browser <a href="http://localhost:5000/">http: // localhost: 5000 /</a> . </p><br><p>  If you take a look at html, we see that before the closing tag is <a href="https://github.com/webcomponents/webcomponentsjs">webcomponents-loader.js</a> .  This is a set of polyfills for web components, and for cross-browser web component, it is desirable that this polyfill be.  Let's take a look at the <a href="https://www.webcomponents.org/">table of browsers</a> that implement all the standards for web components, it says that EDGE still doesn‚Äôt fully implement the standards (I‚Äôm not talking about IE11, which is still required to be supported). </p><br><img src="https://habrastorage.org/webt/q1/g2/6w/q1g26wcj65en1zl0z0d4d2ar67c.png"><br><p>  Implemented 2 variants of this polyfill: </p><br><ol><li>  <a href="https://github.com/webcomponents/webcomponentsjs">webcomponents-bundle.js</a> - this version contains all possible polyfilling options, all of them are initiated, but each polyfill will work only on the basis of the detected features. </li><li>  <a href="https://github.com/webcomponents/webcomponentsjs">webcomponents-loader.js</a> is a minimal downloader that, based on the detected features, loads the necessary polyfills </li></ol><br><p>  Also please pay attention to another polyfill - <a href="https://github.com/webcomponents/webcomponentsjs">custom-elements-es5-adapter.js</a> .  According to the specification, only ES6 classes can be added to the native customElements.define.  For better performance, the code on ES6 should be transferred only to those browsers that support it, and ES5 - to everyone else.  It‚Äôs not always possible to do this, so for better cross-browser compatibility, it is recommended to transfer the entire ES6 code to ES5.  But in this case, the web components on ES5 will not work in browsers.  To solve this problem, there is a custom-elements-es5-adapter.js. </p><br><p>  Now let's open the <code>./src/my-element.js</code> file </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// @property - ,    babel  ts //         //  ,   @property({type: String}) myProp = 'stuff'; render() { return html` &lt;p&gt;Hello World&lt;/p&gt; ${this.myProp} `; } } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  The lit-html template engine can handle a string differently.  I will give several options: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  : html`&lt;div&gt;Hi&lt;/div&gt;` // : html`&lt;div&gt;${this.disabled ? 'Off' : 'On'}&lt;/div&gt;` // : html`&lt;x-foo .bar="${this.bar}"&gt;&lt;/x-foo&gt;` // : html`&lt;div class="${this.color} special"&gt;&lt;/div&gt;` //   boolean,  checked === false, //        HTML: html`&lt;input type="checkbox" ?checked=${checked}&gt;` //  : html`&lt;button @click="${this._clickHandler}"&gt;&lt;/button&gt;`</span></span></code> </pre><br><p>  Tips for optimizing the render () function: </p><br><ul><li>  must not change the state of the element </li><li>  should not have side effects </li><li>  should depend only on the properties of the element </li><li>  should return the same result when passing the same value. </li></ul><br><p>  Do not update the DOM outside the render () function. </p><br><p>  The lit-element is responsible for rendering the lit-html - this is a declarative way of describing how the web component should be displayed.  lit-html guarantees fast updates, changing only those parts of the DOM that need to be changed. </p><br><p>  Almost all of this code was in a simple example, but the <code>@property</code> <a href="https://github.com/tc39/proposal-decorators">decorator was</a> added to the <code>myProp</code> property.  This decorator indicates that we are expecting an attribute named <code>myprop</code> in our <code>my-element</code> .  If such an attribute is not specified, it defaults to the string value <code>stuff</code> . </p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!--  myProp  ,       -   'stuff' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">&lt;!--  myprop         lowerCamelCase .. myProp   -      'else' --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">myprop</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"else"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">my-element</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><p>  lit-element provides 2 ways to work with <code>property</code> : </p><br><ol><li>  Through the decorator. </li><li>  Through static getter <code>properties</code> . </li></ol><br><p>  The first option allows you to specify each property separately: </p><br><pre> <code class="javascript hljs">@property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}) prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}) prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}) prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}) prop4 = []; @property({<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>}) prop5 = {};</code> </pre><br><p>  The second is to specify everything in one place, but in this case, if the property has a default value, you must write it in the class constructor method: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get properties() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">prop1</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop2</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop3</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop4</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>}, <span class="hljs-attr"><span class="hljs-attr">prop5</span></span>: {<span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>} }; } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop1 = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop2 = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop3 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop4 = []; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.prop5 = {}; }</code> </pre><br><p>  The API for working with properties in the lit-element is quite extensive: </p><br><ul><li>  <b>attribute</b> : whether a property can become an observable attribute.  If the value is <code>false</code> , then the attribute will be excluded from observation; a getter will not be created for it.  If <code>true</code> or <code>attribute</code> missing, then the property specified in the getter in the format lowerCamelCase will correspond to the attribute in the string format.  If a string is specified, for example <code>my-prop</code> , it will correspond with the same name in the attributes. </li><li>  <b>converter</b> : contains a description of how to convert a value from / to an attribute / property.  A value can be a function that works to serialize and deserialize a value, or it can be an object with keys <code>fromAttribute</code> and <code>toAttribute</code> , these keys contain separate functions for converting values.  By default, the property contains a conversion to the base types <code>Boolean</code> , <code>String</code> , <code>Number</code> , <code>Object</code> and <code>Array</code> .  Conversion rules are listed <a href="https://lit-element.polymer-project.org/guide/properties">here</a> . </li><li>  <b>type</b> : indicates one of the base types that will contain this property.  Used as a ‚Äúhint‚Äù for the converter as to which type the property should contain. </li><li>  <b>reflect</b> : indicates whether the attribute should be associated with a property ( <code>true</code> ) and changed according to the rules of <code>type</code> and <code>converter</code> . </li><li>  <b>hasChanged</b> : each property has one, contains a function that determines whether there is a change between the old and the new value, respectively, returns a <code>Boolean</code> .  If <code>true</code> , it starts the item update. </li><li>  <b>noAccessor</b> : this property takes <code>Boolean</code> and defaults to <code>false</code> .  It prohibits the generation of getters and setters for each property to access them from the class.  This does not cancel the conversion. </li></ul><br><p>  Let's make a hypothetical example: write a web component that contains a parameter that contains a string, this word should be drawn on the screen, in which each letter is greater than the previous one. <br></p><br><pre> <code class="html hljs xml"><span class="hljs-comment"><span class="hljs-comment">&lt;!-- index.html --&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">letters</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">""</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ladder-of-letters</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//ladder-of-letters.js import {html, LitElement, property} from 'lit-element'; class LadderOfLetters extends LitElement { @property({ type: Array, converter: { fromAttribute: (val) =&gt; { // console.log('in fromAttribute', val); return val.split(''); } }, hasChanged: (value, oldValue) =&gt; { if(value === undefined || oldValue === undefined) { return false; } // console.log('in hasChanged', value, oldValue.join('')); return value !== oldValue; }, reflect: true }) letters = []; changeLetter() { this.letters = ['','','','','']; } render() { // console.log('in render', this.letters); //    ,    //        return html` &lt;div&gt;${this.letters.map((i, idx) =&gt; html`&lt;span style="font-size: ${idx + 2}em"&gt;${i}&lt;/span&gt;`)}&lt;/div&gt; // @click     ,     //   'click'    &lt;button @click=${this.changeLetter}&gt;  ''&lt;/button&gt; `; } } customElements.define('ladder-of-letters', LadderOfLetters);</span></span></code> </pre><br><p>  as a result we get: </p><br><img src="https://habrastorage.org/webt/fu/jt/ka/fujtka5wih6jghe9wfdwktv8pqw.png"><br><p>  when you clicked on the button, the property was changed, which caused the check first, and then it was sent to redraw. </p><br><img src="https://habrastorage.org/webt/sx/wi/bs/sxwibswpdvdynof2p9adjxt2ysq.png"><br><p>  and using <code>reflect</code> we can also see changes in html </p><br><img src="https://habrastorage.org/webt/z1/oy/i9/z1oyi9lbcznkigdcmr7acffgsca.png"><br><p>  If this attribute is changed by code outside this web component, we will also cause the web component to be redrawn. </p><br><p>  Now consider the styling component.  We have 2 ways to style the lit-element: </p><br><ol><li>  Styling by adding a style tag to the render method <br><br><pre> <code class="javascript hljs">render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;style&gt; p { color: green; } &lt;/style&gt; &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; }</code> </pre><br><img src="https://habrastorage.org/webt/6r/70/ba/6r70bawofzxkhbtbx8pif2fu_au.png"><br></li><li>  Through static <code>styles</code> getter 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html, LitElement, css} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ css<span class="hljs-string"><span class="hljs-string">` p { color: red; } `</span></span> ]; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> html<span class="hljs-string"><span class="hljs-string">` &lt;p&gt;Hello World&lt;/p&gt; `</span></span>; } } customElements.define(<span class="hljs-string"><span class="hljs-string">'my-element'</span></span>, MyElement);</code> </pre><br></li></ol><br><p>  As a result, we get that a tag with styles is not created, but is written ( <code>&gt;= Chrome 73</code> ) into the <code>Shadow DOM</code> element in accordance with the <a href="https://wicg.github.io/construct-stylesheets/">specification</a> .  Thus, performance improves with a large number of elements, since  when registering a new component, he already knows what properties his styles define for him, they do not need to be registered every time and recalculated. </p><br><img src="https://habrastorage.org/webt/tc/ew/rs/tcewrs9bnnmopzuprmi3kgapbam.png"><br><br><p>  In this case, if this specification is not supported, then the usual <code>style</code> tag is created in the component. </p><br><img src="https://habrastorage.org/webt/ah/kl/9h/ahkl9hm7c8wmkevk8fctarpkdao.png"><br><br><p>  Plus, do not forget that in this way we can also share which styles will be added and calculated on the page.  For example, use media queries not in css, but in JS and implement only the necessary style, for example (this is wild, but it is the place to be): </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> get styles() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> mobileStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: red; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> desktopStyle = css<span class="hljs-string"><span class="hljs-string">`p { color: green; }`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.matchMedia(<span class="hljs-string"><span class="hljs-string">"(min-width: 400px)"</span></span>).matches ? desktopStyle : mobileStyle ]; }</code> </pre><br><p>  Accordingly, we will see this if the user logged on to a device with a screen width of more than 400px. </p><br><img src="https://habrastorage.org/webt/k5/cu/it/k5cuitrmqpwb-76qid-1qamtpuw.png"><br><p>  And this is - if the user entered the site from a device with a width of less than 400px. </p><br><img src="https://habrastorage.org/webt/z-/jy/jw/z-jyjw7canilafm3cmsjfuxtv6g.png"><br><p>  My opinion: there is practically no adequate case when the user, working on a mobile device, suddenly appears in front of a full-fledged monitor with a screen width of 1920px.  Add to this the lazy loading of components.  As a result, we get a very optimized front with fast rendering of components.  The only problem is the difficulty of support. </p><br><p>  Now I suggest to get acquainted with the life-cycle methods of the lit-element: </p><br><ul><li>  <b>render ()</b> : implements the description of the DOM element using <code>lit-html</code> .  Ideally, the <code>render</code> function is a pure function that uses only the current properties of the element.  The <code>render()</code> method is called by the <code>update()</code> function. </li><li>  <b>shouldUpdate (changedProperties)</b> : implemented if you need to control the update and rendering, when the properties were changed or when <code>requestUpdate()</code> called.  The argument of the <code>changedProperties</code> function is a <code>Map</code> containing the keys of the changed properties.  By default, this method always returns <code>true</code> , but the logic of the method can be changed to control the update component. </li><li>  <b>performUpdate ()</b> : implemented to control the update time, for example, to integrate with the scheduler. </li><li>  <b>update (changedProperties)</b> : this method calls <code>render()</code> .  It also updates the attributes of the element according to the value of the property.  Setting properties inside this method will not trigger another update. </li><li>  <b>firstUpdated (changedProperties)</b> : is called after the first DOM element is <code>updated()</code> immediately before the <code>updated()</code> call.  This method can be useful for capturing links to rendered static nodes that you need to work with directly, for example, in <code>updated()</code> . </li><li>  <b>updated (changedProperties)</b> : called whenever the DOM element is updated and displayed.  An implementation to perform tasks after an update through the DOM API, for example, focusing on an element. </li><li>  <b>requestUpdate (name, oldValue)</b> : Causes a request for an asynchronous update of the item.  This should be called when the element needs to be updated based on some state that is not caused by setting the property. </li><li>  <b>createRenderRoot ()</b> : by default creates a Shadow Root for the item.  If the use of the Shadow DOM is not needed, then the method should return <code>this</code> . </li></ul><br><p>  How the item is updated: </p><br><ul><li>  The property is given a new value. </li><li>  If the <code>hasChanged(value, oldValue)</code> returns <code>false</code> , the item is not updated.  Otherwise, an update is planned by calling <code>requestUpdate()</code> . </li><li>  <b>requestUpdate ()</b> : updates the element after the microtask (at the end of the event loop and before the next redraw). </li><li>  <b>performUpdate ()</b> : performs an update, and continues the rest of the update API. </li><li>  <b>shouldUpdate (changedProperties)</b> : the update continues if <code>true</code> returned. </li><li>  <b>firstUpdated (changedProperties)</b> : called when the element is updated for the first time, immediately before the <code>updated()</code> call. </li><li>  <b>update (changedProperties)</b> : updates the item.  Changing properties in this method does not trigger another update. <br><ul><li>  <b>render ()</b> : returns a <code>lit-html</code> template for drawing an element in the DOM.  Changing properties in this method does not trigger another update. </li></ul><br></li><li>  <b>updated (changedProperties)</b> : called whenever an item is updated. </li></ul><br><p>  To understand all the nuances of the component life cycle, I advise you to refer to the <a href="https://lit-element.polymer-project.org/guide/lifecycle">documentation</a> . </p><br><p>  At work, I have a project on the adobe experience manager (AEM), in its authoring, the user can drag and drop components onto the page, and according to the AEM ideology, this component contains a <code>script</code> tag, which contains everything you need to implement the logic of this component.  But in fact, such an approach gave rise to many blocking resources and difficulties with the implementation of the front in this system.  For the implementation of the front, web components were chosen as a way not to change the server-side rendering (with which he did an excellent job), and also gently, element by element, to enrich the old implementation with a new approach.  In my opinion, there are several options for implementing web component loading for this system: build a bundle (it can become very large) or split it into chunks (a lot of small files, dynamic loading is needed), or use the already current approach with embedding a script into each a component that is rendered on the server side (I really don't want to go back to this).  In my opinion, the first and third options are not options.  For the second, you need a dynamic loader, as in stencil.  But for the lit-element in the "box" is not provided.  From the side of the lit-element developers, there was <a href="https://github.com/PolymerLabs/split-element">an attempt to create a dynamic loader</a> , but it is an experiment and it is not recommended to use it in production.  Also from the lit-element developers there is an <a href="https://github.com/w3c/webcomponents/issues/782">issue</a> in the <a href="https://github.com/w3c/webcomponents">repository of the specification of web components</a> with the proposal to add to the specification the ability to dynamically load the necessary js for the web component based on html markup on the page.  And, in my opinion, this native tool is a very good idea that will allow you to create one initialization point for web components and simply add it to all pages of the site. </p><br><p>  For dynamic loading of web components based on lit-element, guys from PolymerLabs developed a <a href="https://github.com/PolymerLabs/split-element">split-element</a> .  This is an experimental solution.  It works in the following way: </p><br><ul><li>  To create a SplitElement, you write two element definitions in two modules. </li><li>  One of them is a ‚Äústub‚Äù that defines the loaded parts of an element: usually this is the name and properties.  Properties must be defined with a stub so that the lit-element can timely generate observable attributes to call <code>customElements.define()</code> . </li><li>  The stub should also have a static asynchronous loading method that returns an implementation class. </li><li>  Another class is an ‚Äúimplementation‚Äù that contains everything else. </li><li>  The <code>SplitElement</code> constructor loads the implementation class and executes <code>upgrade()</code> . </li></ul><br><p>  Stub example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {SplitElement, property} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyElement</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SplitElement</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// MyElement    load   //      connectedCallback()   static async load() { //        //      MyElement return (await import('./my-element-impl.js')).MyElementImpl; } //      //   - @property() message: string; } customElements.define('my-element', MyElement);</span></span></code> </pre><br><p>  Example of implementation: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {MyElement} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./my-element.js'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../split-element.js'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// MyElementImpl  render    - export class MyElementImpl extends MyElement { render() { return html` &lt;h1&gt;I've been upgraded&lt;/h1&gt; My message is ${this.message}. `; } }</span></span></code> </pre><br><p>  ES6 SplitElement Example: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {LitElement, html} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'lit-element'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    LitElement  SplitElement //       export class SplitElement extends LitElement { static load; static _resolveLoaded; static _rejectLoaded; static _loadedPromise; static implClass; static loaded() { if (!this.hasOwnProperty('_loadedPromise')) { this._loadedPromise = new Promise((resolve, reject) =&gt; { this._resolveLoaded = resolve; this._rejectLoaded = reject; }); } return this._loadedPromise; } //      - //      static _upgrade(element, klass) { SplitElement._upgradingElement = element; Object.setPrototypeOf(element, klass.prototype); new klass(); SplitElement._upgradingElement = undefined; element.requestUpdate(); if (element.isConnected) { element.connectedCallback(); } } static _upgradingElement; constructor() { if (SplitElement._upgradingElement !== undefined) { return SplitElement._upgradingElement; } super(); const ctor = this.constructor; if (ctor.hasOwnProperty('implClass')) { //   ,   ctor._upgrade(this, ctor.implClass); } else { //    if (typeof ctor.load !== 'function') { throw new Error('A SplitElement must have a static `load` method'); } (async () =&gt; { ctor.implClass = await ctor.load(); ctor._upgrade(this, ctor.implClass); })(); } } //       render() { return html``; } }</span></span></code> </pre><br><p>  If you are still using the build suggested above on Rollup, do not forget to set the babel to handle dynamic imports. </p><br><pre> <code class="plaintext hljs">npm install @babel/plugin-syntax-dynamic-import</code> </pre> <br><p>  And in the settings .babelrc add </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"plugins"</span></span>: [<span class="hljs-string"><span class="hljs-string">"@babel/plugin-syntax-dynamic-import"</span></span>] }</code> </pre><br><p>  Here I made a small example of the implementation of deferred web components: <a href="https://github.com/malay76a/elbrus-split-litelement-web-components">https://github.com/malay76a/elbrus-split-litelement-web-components</a> </p><br><p>  I tried to apply the approach of dynamic loading of web components, I came to the following conclusion: the tool is quite working, all the definitions of web components should be assembled into one file, and the description of the component itself should be connected via chunks separately.  Without http2, this approach does not work, because  a very large pool of small files describing the components is formed.  If we proceed from the principle of <a href="http://bradfrost.com/blog/post/atomic-web-design/">atomic design</a> , then the import of atoms must be determined in the body, but the body is already connected as a separate component.  One of the ‚Äúbottlenecks‚Äù is that the user will receive many definitions of user elements in the browser, which will be somehow initialized in the browser, and they will be determined by the initial state.  This decision is redundant.  One of the simple solutions for the component loader is the following algorithm: </p><br><ol><li>  load the required utilities </li><li>  load polyfills, </li><li>  collect custom elements from light DOM: <br><ol><li>  select all DOM elements that contain hyphens in the tag name, </li><li>  the list is filtered and the list of the first elements is formed. </li></ol></li><li>       : <br><ol><li>    Intersection Observer, </li><li>        +- 100px      import. </li></ol></li><li><ol><li>     3       shadowDOM, </li><li>  ,   shadowDOM  ,     ,  import   JS. </li></ol><br></li></ol><br><p>      -  lit-element        <a href="http://open-wc.org/">open-wc.org</a> .        webpack  rollup,    -      storybook,          IDE. </p><br><h2>  Additional links: </h2><br><ol><li> <a href="https://dev.to/bennypowers/lets-build-web-components-part-5-litelement-906">Let's Build Web Components! Part 5: LitElement</a> </li><li> <a href="https://books.google.ru/books%3Fid%3DHStxDwAAQBAJ%26pg%3DPA71%26lpg%3DPA71%26dq%3DLitElement%2Bperformance%26source%3Dbl%26ots%3Dd_axG-lsTB%26sig%3DsdyQdApVjn0kGsi4ov6x6d3Sm6Q%26hl%3Dru%26sa%3DX%26ved%3D2ahUKEwirjtq11KbfAhWKZlAKHdPXB34Q6AEwB3oECAAQAQ">Web Component Essentials</a> </li><li> <a href="https://medium.com/%40lucamezzalira/a-night-experimenting-with-lit-html-585a8c69892a">A night experimenting with Lit-HTML‚Ä¶</a> </li><li> <a href="https://medium.com/%40westbrook/litelement-to-do-app-1e08a31707a4">LitElement To Do App</a> </li><li> <a href="https://www.youtube.com/watch%3Fv%3DUcCsGZDCw-Q">LitElement app tutorial part 1: Getting started</a> </li><li> <a href="https://www.youtube.com/watch%3Fv%3Ds6P3R-J0IiI">LitElement tutorial part 2: Templating, properties, and events</a> </li><li> <a href="https://www.youtube.com/watch%3Fv%3D_Gt12UhGLY0">LitElement tutorial part 3: State management with Redux</a> </li><li> <a href="https://www.youtube.com/watch%3Fv%3DJajSgc7xelI">LitElement tutorial part 4: Navigation and code splitting</a> </li><li> <a href="https://www.youtube.com/watch%3Fv%3DToxKlmqgZHw">LitElement tutorial part 5: PWA and offline</a> </li><li> <a href="https://github.com/LarsDenBakker/lit-html-workshop">Lit-html workshop</a> </li><li> <a href="https://github.com/web-padawan/awesome-lit-html">Awesome lit-html</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/445438/">https://habr.com/ru/post/445438/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445424/index.html">Experience in developing the Refund Tool service with an asynchronous API on Kafka</a></li>
<li><a href="../445428/index.html">High-quality Wi-Fi is the basis of modern hospitality and the engine of business.</a></li>
<li><a href="../445432/index.html">Unity Package Manager</a></li>
<li><a href="../445434/index.html">The best worst job in the world: we are looking for a habra</a></li>
<li><a href="../445436/index.html">Retraining in DevOps - what to prepare for yourself</a></li>
<li><a href="../445440/index.html">Code review: bad advice for contributor and reviewer</a></li>
<li><a href="../445444/index.html">Upgrade of high performance solar modules from REC and Trina (Solar)</a></li>
<li><a href="../445446/index.html">How we used deferred replication for disaster recovery with PostgreSQL</a></li>
<li><a href="../445448/index.html">Configuring automatic receipt of letsencrypt certificates using docker for linux</a></li>
<li><a href="../445450/index.html">Browser extension for the site toster.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>