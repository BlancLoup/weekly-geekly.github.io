<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Branch model and git module management for a large project</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Almost two years ago, we began using the new model of branching and managing git submodules in the development of our flagship DBMS Linter project. Te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Branch model and git module management for a large project</h1><div class="post__text post__text-html js-mediator-article">  Almost two years ago, we began using the new model of branching and managing git submodules in the development of our flagship <a href="https://www.linter.ru/">DBMS Linter</a> project.  Tens of thousands of commits made during this time by a group of developers make it possible to consider innovations successful with a certain degree of confidence.  This article is a brief overview of the principles of organizing a source code repository in a large project based on an alternative implementation of git modules, the established branching strategy and linflow toolkit. <br><br><img src="https://habrastorage.org/files/4e8/9f7/12e/4e89f712eae74fedb81dcb4c47c6bc8f.jpg"><br><a name="habracut"></a><br><h1>  Monorepository, git submodules, git subtree or ... </h1><br>  Previously, Linter source codes were stored in CVS.  Despite the obsolescence of this version control system, it possessed certain features that we actively used (in part, this allowed the dinosaur to hold out for so long): to work on a specific task, it was possible to extract only the necessary modules with its dependencies.  This is convenient, since the modules in our project are mostly mutually low and free mate. <br><br>  Technically, the process of obtaining the necessary source codes was organized more simply: the server stored a set of modules in directories, but the developer had extraction tools and a file descriptor for the tree needed for a particular process.  For greater clarity, here is a small fragment of such a descriptor: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs vala"><span class="hljs-meta"><span class="hljs-meta">#RepositoryDir Unix RELAPI relapi LINDESKX lindeskx KERNEL5/SQL sql KERNEL5/TSP tsp</span></span></code> </pre> <br>  It is easy to see that the rules determined not only which modules should be extracted, but also where to extract them, that is, the tree in the central repository and the tree in the working copy were different.  These file descriptors varied for different target distributions, operating systems, and versions of the DBMS. <br><br>  But as you know, git does not provide a simple mechanism for cloning a part of the repository.  Therefore, when there was a question about migration from CVS to git, first of all we considered the two most obvious ways to organize it: use a single repository (mono-repository) for the entire project tree with the inevitable changes to the product assembly process or store the project in a collection of independent modules and use git-ovsky submodule / subtree to work with them. <br><br><h3>  Mono-pository </h3><br>  The idea of ‚Äã‚Äãusing one repository for the entire project tree was abandoned almost immediately.  And for good reason: <br><ul><li>  <b>Performance.</b>  No, we did not have 1.3 million files, as in tests from Facebook ( <a href="http://habrahabr.ru/post/137615/">http://habrahabr.ru/post/137615/</a> ), but 114800 commits of the exported history for ~ 14000 files turned out to be enough to fix a noticeable drop in performance when working with an index. </li><li>  <b>Story.</b>  A mono-repository has a general history of revisions: in one chain of logs, revisions of the kernel, examples, utilities, documentation, etc. can be intermixed. </li><li>  <b>Support.</b>  The unification of the source tree would lead to a change in the assembly mechanisms for all versions of the product released since the end of the last century.  Development of these releases, of course, is no longer underway, but I didn‚Äôt want to lose the opportunity to ‚Äúblow off dust‚Äù from the archive version. </li></ul><br><br><h3>  git submodules / git subtree </h3><br>  If there were no difficulties in terms of storing a group of modules in the main repository, then there were difficulties with their cloning into the correct working tree.  Of course, git supports native submodules and subtree, however, there are enough shortcomings in their use (see <a href="http://habrahabr.ru/post/75964/">http://habrahabr.ru/post/75964/</a> ), such are the architectural features of this version control system.  But the most unpleasant moment was the need to ensure that the main repository of the module-container did not get links to non-public states of the child modules.  So, after working with the experimental repository, we came to the conclusion that we need an alternative mechanism for managing modules on the client side. <br><br><h3>  linmodules </h3><br>  To eliminate the shortcomings of the native git submodules and git subtree, we have developed our own module management mechanism, which functions above the git level.  The implementation of this mechanism has become part of the toolkit we call linflow. <br><br>  The scheme is quite simple: each of the project modules is stored in a separate repository with exported history, and one of the modules (in our case it has the name linter.git) is a container module that does not contain any source codes and its main task is to set tree of global branches for everyone else.  Each of these global branches in the container module may have its own file descriptor (with the name .linmodules) necessary to retrieve the correct project tree. <br><br>  However surprising it may sound to the reader, who was fortunate enough to not work daily with native git submodules, but this scheme turned out to be simpler and more convenient than a regular implementation. <br><br><img src="https://habrastorage.org/files/dee/9a7/1e2/dee9a71e201346518250a829e983722e.png"><br>  <i>Figure 1: How to get the source tree version.</i>  <i>1 - cloning of a module-container with a file descriptor, 2 - initialization, 3 - cloning of registered modules into target directories.</i> <br><br>  The syntax of the template description (the .linmodules file) repeats the ‚Äúnative‚Äù, which is used in git for the .gitmodules file.  This was done intentionally for backward compatibility. <br><br>  Here is a fragment of the placement pattern from Figure 1: <br><br><pre> <code class="hljs pgsql">[submodule "tick"] <span class="hljs-type"><span class="hljs-type">path</span></span> = lib/tick url = git@linter-git.common.relex.ru:TICK [submodule "odbc"] <span class="hljs-type"><span class="hljs-type">path</span></span> = odbc url = git@linter-git.common.relex.ru:ODBC [submodule "inl"] <span class="hljs-type"><span class="hljs-type">path</span></span> = app/inl url = git@linter-git.common.relex.ru:INL</code> </pre> <br>  Thus, we managed to keep the ability to extract modules into an arbitrary working copy structure.  The initial formation of templates and their subsequent change is made by means of linflow. <br><br><h1>  Branching model </h1><br>  It would not be a big mistake to assume that many developers looking for the optimal organization of their git-based repositories are familiar with the work of Vincent Driessen ‚ÄúA successful Git branching model‚Äù (those who didn‚Äôt have time to do this can always familiarize themselves with the original <a href="http://nvie.com/posts/a-successful-git-branching-model/">http: // nvie .com / posts / a-successful-git-branching-model /</a> or by transferring to habr ( <a href="http://habrahabr.ru/post/106912/">http://habrahabr.ru/post/106912/</a> ).  We did not become an exception and, having begun testing the model, made adjustments to it, as a result we came to our own, which inherited some features of the ‚Äúparent‚Äù one.  And although the title of the original article is cunning (the model is really successful), but this is true exactly until it becomes necessary to apply it to a really large project with a long history. <br><br>  There were several reasons why the ‚Äúsuccessful‚Äù model from Vincent Driessen demanded changes.  We present only the most important for us in the order of their appearance and solution: <br><ul><li>  The original model does not specify the behavior when decomposing initial projects into submodules and modules with dependencies. </li><li>  The release branches cannot be closed while the product is being maintained, so at the time of this writing, bug fixes and part of the new functionality are being added to all versions released since the beginning of 2009.  Because of this, builds of different versions of a product cannot be represented by a single sequence of commits on any branch. </li><li>  The branches of corrections and functionality can be transferred to the old versions that do not contain all the changes of the development branch, so merge is simply impossible. </li><li>  The overwhelming majority of corrections contain one commit (at the time of writing these lines from 2598 branches with corrections only 262 had two or more commit), therefore using the no-ff merge strategy, which generates an additional merge commit each time, is not very convenient. </li></ul><br>  The result of the work on the modification of the ‚Äúsuccessful‚Äù model was the creation of its own strategy, which partly inherits some of the terms, agreements, naming and original workflows.  For the sake of simplicity, we will highlight the key changes, which will be discussed in more detail below: <br><ul><li>  The rules for the maintenance of branches in the submodules of one project are stipulated; </li><li>  Changed the rules for working with the <b>develop</b> branch; </li><li>  Changed release rules for versions and, consequently; </li><li>  Changed release branch maintenance rules; </li><li>  Changed rules for transferring edits from branch to branch. </li></ul><br><br><img src="https://habrastorage.org/files/ccf/51d/02d/ccf51d02dfa24d8a92caffabfcc20801.png"><br>  <i>Figure 2: A variant of branching and code transfer in a module.</i>  <i>The release branch RELEASE # 2 is the newest and allows you to transfer edits using merge, RELEASE # 1 supports the previous version and receives changes selectively.</i> <br><br><h3>  Main branches </h3><br>  The central repository contains a group of branches that exists all the time <u>and in all modules</u> : <br><ul><li>  <b>release branches</b> - a group of project branches, supplemented as versions are released; </li><li>  <b>develop (master)</b> - the main branch of development. </li></ul><br>  The <b>origin / release</b> branches are considered to be the main production ones, i.e. the source code for them should allow to release a version or build at any time.  The <b>origin / master</b> branch is considered the main production one, which contains all changes to the project and serves as the source for creating <b>origin / release</b> .  When the source code in <b>origin / master is</b> ready for release, the changes should be transferred in a certain way to the corresponding origin / release or generate a new version, and therefore - a branch in <b>origin / release</b> . <br><br><h3>  Auxiliary branches </h3><br>  In addition to the main branches, the structure of the repositories (both central and working copies) implies the presence of auxiliary branches of the following types: <br><ul><li>  <b>feature branches</b> - branches of new functionality; </li><li>  <b>fix branches</b> </li></ul><br>  Each of these types of branches has a specific purpose and a set of rules of reference, which will be described below. <br><br><img src="https://habrastorage.org/files/496/993/ba7/496993ba78f246cfa76c308e53da3ddf.png"><br>  <i>Figure 3: Distribution of branches by modules: the main branches are present in all, auxiliary branches - only in the necessary ones.</i> <br><br><h3>  General rules </h3><br>  General rules for maintaining branches in the central and local repositories: <br><ul><li>  <b>develop (master)</b> contains stable code; </li><li>  <b>develop (master)</b> exists in all modules; </li><li>  development on the <b>develop (master)</b> branch is prohibited; </li><li>  <b>develop (master)</b> stores the code required to release a new <b>version</b> or <b>release</b> ; </li><li>  if necessary, a new release from <b>develop (master)</b> branch <b>release branches</b> ; </li><li>  <b>release branches</b> store the code for the release of a new <b>build</b> ; </li><li>  build releases are tagged on the head commits of the corresponding <b>release branches</b> ; </li><li>  the creation of a branch of the type of branches in the module-container spawns the creation of a branch of the same name in each of the submodules (see Fig. 2); </li><li>  <b>fix branches</b> can branch from <b>develop (master)</b> or <b>release branches</b> and can join both <b>develop (master)</b> and <b>release branches</b> ; </li><li>  <b>feature branches</b> branch out only from <b>develop (master)</b> and necessarily join it; </li><li>  commits that form part of the <b>branches</b> , if necessary, can be transferred to one or several <b>release branches</b> (but this fact does not cancel the previous rule on mandatory merging with <b>develop</b> ); </li><li>  branches <b>feature branches</b> and <b>hotfix branches are</b> regularly published in the central repository. </li></ul><br><br><h3>  The branches of releases / versions (release branches) </h3><br>  The branches of releases ( <b>release branches</b> ) are referred to as <b>release / Blinter_AB_C</b> , where <b>A</b> is the major version, <b>B</b> is the minor version, and <b>C</b> is the release number.  Release branches originate from develop, and there are all the time support for the Linter version.  The branch is the recipient of the code: there is no development in it.  Each fact of the release of a new build is marked with the corresponding tag of the form <b>Blinter_AB_C_D</b> , where <b>D</b> is the build number.  Branches of this type can be links (from the point of view of organization to <b>origin</b> ) to another release branch.  In this case, the publication in one of these branches will lead to an update of all related.  The release branch is global, i.e., it exists in all modules if created in a module-container.  Tags with build tags are set at the same time in all modules. <br><br><h3>  Fix branches </h3><br>  The branches of corrections ( <b>fix branches</b> ) are referred to as <b>hotfix / *</b> , can be generated from develop (mostly) or release, can be merged into <b>develop (master)</b> and <b>release</b> .  If the fixes contain one commit, the merge is performed without creating a merge commit.  The final commit in the comment body contains a reference to the number of the corresponding ticket in the bugtracker.  After the edits are migrated, the repair branch closes. <br><br><h3>  Branches of functionality (feature branches) </h3><br>  The branches of the functionality are referred to as <b>feature / *</b> and are generated only from <b>develop (master)</b> . <br>  The branches of functionality ( <b>feature branches</b> ) are used to develop new features that should appear in current or future releases.  A branch exists for as long as the development of functionality continues.  As interim results are achieved, the branch is published in the central repository.  When the work in the branch is completed, the latter <u>necessarily</u> merges into the main branch of development (which means that the functionality will be added to the next release) and optionally into the release branches.  After the code is migrated, the branch of functionality is closed. <br><br><h1>  linflow </h1><br>  It is worth saying a few words about the linflow toolkit, which has been mentioned several times above in the text.  Linflow is intended for operations with modules of the source tree, as well as to support our branch model.  The linflow client part is a fork of the git-flow project ( <a href="https://github.com/nvie/gitflow">https://github.com/nvie/gitflow</a> ), which has been modified for our strategy and extended to support linmodules.  In addition, we developed the server part, which works as an extension for gitolite ( <a href="http://gitolite.com/">http://gitolite.com</a> ). <br><br>  The functional of module management in linflow allows: <br><ul><li>  register / delete modules; </li><li>  edit the source and target directory of an existing module; </li><li>  initial setting of the working copy; </li><li>  monitor the status of the module-container and timely switch and update the nested modules; </li><li>  produce packaging modules; </li><li>  check the consistency of the entire project tree. </li></ul><br>  The functionality of managing branches in linflow allows you to: <br><ul><li>  create / delete / publish branches of all allowed types; </li><li>  control over the implementation of the branch naming convention; </li><li>  consistently switch to branches and tags in all modules after the container module; </li><li>  perform bulk operations on modules; </li><li>  transfer code from branch to branch using different strategies; </li><li>  transfer code to branches with changed history; </li><li>  prevent erroneous removal of branches. </li></ul><br>  The functionality of the server part allows you to: <br><ul><li>  to monitor compliance with the rules of naming; </li><li>  delimit the rights of users by roles; </li><li>  manage branch links; </li><li>  to send notifications of changes on a dynamically generated list of potential interested participants; </li><li>  make a full backup. </li></ul><br>  The possibility of publishing the full technical documentation on the branch model and linflow tools is currently being discussed.  Not the last role in this can play responses (or lack thereof) to this publication. </div><p>Source: <a href="https://habr.com/ru/post/258505/">https://habr.com/ru/post/258505/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258491/index.html">64-bit code in 2015: what's new in diagnosing possible problems?</a></li>
<li><a href="../258495/index.html">About data transmission via audio jack</a></li>
<li><a href="../258499/index.html">OWASP TOP-10: A Practical View of Web Application Security</a></li>
<li><a href="../258501/index.html">Free functional test webinar from TestCafe</a></li>
<li><a href="../258503/index.html">Useful Wordpress plugins. OptionTree - site settings page</a></li>
<li><a href="../258507/index.html">Transistor amplifier class A do it yourself</a></li>
<li><a href="../258509/index.html">‚ÄúWhispering‚Äù neighbor through chanspy [FreePBX]</a></li>
<li><a href="../258513/index.html">How I once hacked an online casino</a></li>
<li><a href="../258515/index.html">How I wrote a simple application for Android / iOS</a></li>
<li><a href="../258519/index.html">A new way of fraud has appeared: domain pseudo-registrars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>