<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using code blocks from Objective-C to Delphi on macOS: how we built bridges</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many have probably heard of a great way to solve programmer tasks called duckling (rubber duck debugging). The essence of the method is that it is nec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using code blocks from Objective-C to Delphi on macOS: how we built bridges</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/02d/df6/357/02ddf63577545394ade5204bb053acbe.jpg" alt="image"></p><br><p>  Many have probably heard of a great way to solve programmer tasks called <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D1%2583%25D1%2582%25D1%2591%25D0%25BD%25D0%25BA%25D0%25B0">duckling</a> (rubber duck debugging).  The essence of the method is that it is necessary to sit in the bathroom, relax, put a toy duck on the water, and explain to it the essence of the problem that you cannot find a solution to.  And, miraculously, after such a conversation, the solution is found. </p><br><p>  In my <a href="https://habrahabr.ru/post/319922">last article on Habr√©</a> , where I talked about developing a program for inspecting Wi-Fi networks for macOS, Habr himself turned out to be the duckling: I complained that we couldn‚Äôt think of a way to implement the code blocks from Objective-C in Delphi .  And it helped!  Enlightenment came, and everything worked out.  I want to tell you about the course of thoughts and the final result. </p><a name="habracut"></a><br><p> So, for those who have not read the previous article, I once again summarize the essence of the problem.  <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/WorkingwithBlocks/WorkingwithBlocks.html">Code blocks</a> is a C ++ and Objective-C language feature that is not supported in Delphi.  More precisely, Delphi has its analogue of code blocks, but it is incompatible with those code blocks that it expects from macOS API.  The fact is that many classes have functions that use code blocks as handler's for completion.  The simplest example is the <a href="https://developer.apple.com/reference/appkit/nssavepanel/1527007-beginwithcompletionhandler%3Flanguage%3Dobjc">beginWithCompletionHandler</a> classes <code>NSSavePanel</code> and <code>NSOpenPanel</code> .  The transmitted code block is executed at the moment of closing the dialog: </p><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">IBAction</span></span>)openExistingDocument:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)sender { <span class="hljs-built_in"><span class="hljs-built_in">NSOpenPanel</span></span>* panel = [<span class="hljs-built_in"><span class="hljs-built_in">NSOpenPanel</span></span> openPanel]; <span class="hljs-comment"><span class="hljs-comment">// This method displays the panel and returns immediately. // The completion handler is called when the user selects an // item or cancels the panel. [panel beginWithCompletionHandler:^(NSInteger result){ if (result == NSFileHandlingPanelOKButton) { NSURL* theDoc = [[panel URLs] objectAtIndex:0]; // Open the document. } }]; }</span></span></code> </pre> <br><p>  After talking with the duckling, I realized that I had not approached the solution to the problem from the wrong end.  Surely this problem exists not only in Delphi.  Therefore, we must start with how the problem is solved in other languages.  Google in hand and we find very close to our topic code for Python and JavaScript <a href="https://github.com/jsbain/objc_hacks/blob/master/objcblock.py">here</a> and <a href="https://developer.mozilla.org/en-US/docs/Mozilla/js-ctypes/Examples/Using_Objective-C_from_js-ctypes">here</a> .  Good start: if they succeeded, then we will succeed.  In essence, we just need to create a structure in the correct format, fill in the fields, and a pointer to such a structure will be the very magic pointer that we can pass into those macOS class methods that expect blocks from us.  A little more googling, and we find the <a href="">header</a> on the Apple website: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block_descriptor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reserved; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*copy)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *dst, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *src); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*dispose)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *); }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block_layout</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *isa; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> reserved; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*invoke)(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *, ...); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Block_descriptor</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">descriptor</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">// imported variables };</span></span></code> </pre> <br><p>  We put it in Pascal: </p><br><pre> <code class="delphi hljs"> Block_Descriptor = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PBlock_Literal = ^Block_Literal;</code> </pre> <br><p>  Now, after reading a little more about blocks ( <a href="https://www.cocoawithlove.com/2009/10/how-blocks-are-implemented-and.html">How blocks are implemented</a> and on Habr√©, <a href="https://habrahabr.ru/post/271255/">Objective-C: how blocks work</a> ), let's move on to creating a block, while in the simplest version, on the knee: </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">Var</span></span> OurBlock: Block_Literal; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlock</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FillChar(OurBlock, SizeOf(Block_Literal), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Isa ‚Äì    -,      //    , "NSBlock". OurBlock.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); //    .    cdecl,    . OurBlock.Invoke := @InvokeCallback; //    Block_Descriptor New(aDesc); aDesc.Reserved := 0; //   aDesc.Size := SizeOf(Block_Literal); OurBlock.Descriptor := aDesc; result:= @OurBlock; end;</span></span></code> </pre> <br><p>  We still leave the <code>flags</code> field zero, for simplicity.  Later it will be useful to us.  It remains for us to declare as long as the empty function of the callback.  The first argument in the callback will be a pointer to an instance of the <code>NSBlock</code> class, and the list of other parameters depends on the specific method of the Cocoa class that will call the code block.  In the example above, with <code>NSSavePanel</code> , this is a procedure with a single argument of type <code>NSInteger</code> .  So we write to start: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer; i1: NSInteger)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><p>  Responsible moment, shot on goal: </p><br><pre> <code class="delphi hljs"> FSaveFile := TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; objc_msgSendP2( (FSaveFile <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID, sel_getUid(PAnsiChar(<span class="hljs-string"><span class="hljs-string">'beginSheetModalForWindow:completionHandler:'</span></span>)), (NSWin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ILocalObject).GetObjectID, CreateBlock );</code> </pre><br><p>  The file saving dialog opens, we click OK or Cancel and ... yes!  We will get to the break point, which was set to <code>Sleep(0)</code> , and yes, in the argument <code>i1</code> will be either 0 or 1, depending on which button in the dialog we pressed.  Victory!  We are happy with the duckling, but there is a lot of work ahead: </p><br><ul><li>  The number and type of callback arguments can be different.  There are certain most popular kits, but flexibility is required. </li><li>  We may have a lot of code blocks working at the same time.  For example, we can download the file with the completion handler call upon completion and, in parallel, open and close the file save dialog.  First, the code block that we created second will work, and when the file is downloaded, the first code block will work.  It would be good to keep records. </li><li>  We need to somehow identify the block that caused the callback, and call the Delphi code corresponding to this block. </li><li>  It would be great to make a bridge between anonymous methods in Delphi and code blocks, without which all convenience and beauty is lost.  I want the call to look something like this: </li></ul><br><pre> <code class="delphi hljs">SomeNSClassInstance.SomeMethodWithCallback ( Arg1, Arg2, TObjCBlock.CreateBlockWithProcedure( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1: NSInteger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">p1</span></span></span><span class="hljs-function"> = 0 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">then</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowMessage</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'Cancel'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">else</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShowMessage</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'OK'</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) );</code> </pre> <br><p>  Let's start with the kind of callbacks.  Obviously, the easiest and most reliable way is to have a callback for each type of function: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer; p1: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer; p1, p2: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback3</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer; p1, p2, p3: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>;</code> </pre> <br><p>  And so on.  But somehow it is tedious and inelegant, right?  Therefore, thought leads us further.  What if you declare only one kind of callback, identify the block that caused the callback, find out the number of arguments and crawl along the stack, reading the required number of arguments? </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, ArgNum: integer; p: PByte; Args: <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> i:= FindMatchingBlock(aNSBlock); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> p:= @aNSBlock; Inc(p, Sizeof(pointer)); <span class="hljs-comment"><span class="hljs-comment">//      ArgNum:= GetArgNum(...); if ArgNum &gt; 0 then begin SetLength(Args, ArgNum); Move(p^, Args[0], SizeOf(pointer) * ArgNum); end; ... end;</span></span></code> </pre> <br><p>  Good idea?  No, bad.  It will work in 32-bit code, but crashes to hell in 64-bit, because no cdecl in 64-bit code happens, but there is one general calling convention, which, unlike cdecl, passes arguments in a stack , and in the registers of the processor.  Well, then let's act even easier, we will declare a callback like this: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeCallback</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(aNSBlock, p1, p2, p3, p4: pointer)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>;</code> </pre> <br><p>  And we will just read as many arguments as we need.  The remaining arguments will be rubbish, but we will not turn to them.  And at the same time we changed the procedure to function, in case the code block requires a result.  Disclaimer: if you are not sure about the security of this approach, use separate callbacks for each type of function.  I think the approach is quite safe, but, as they say, tastes differ. </p><br><p>  As for block identification, everything turned out to be quite simple: <code>aNSBlock</code> , which comes to us, as the first argument in the callback, points to exactly the same <code>Descriptor</code> that we allocated when creating the block. </p><br><p>  Now we can deal with anonymous methods of different types, we will cover 90 percent of the possible sets of arguments that are encountered in practice in the macOS classes and we can always expand the list: </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithCFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc1)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc2)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc3)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc4)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc5)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc6)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc7)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">overload</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><p>  Thus, creating a block with a procedure that, for example, has two arguments of size <code>SizeOf(pointer)</code> , will look like this: </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithProcedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aProc: TProc3)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><p>  CreateBlockWithCFunc looks like this: </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateBlockWithCFunc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> result:= BlockObj.AddNewBlock(aTProc, aType); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><p>  I.e.  we refer to BlockObj, a singleton instance of the <code>TObjCBlockList</code> class, which is needed to manage the entire farm and is not accessible from outside the unit: </p><br><pre> <code class="delphi hljs"> TBlockInfo = <span class="hljs-keyword"><span class="hljs-keyword">packed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">record</span></span> BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; PBlockInfo = ^TBlockInfo; <span class="hljs-title"><span class="hljs-title">TObjCBlockList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> (TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FBlockList: TArray&lt;TBlockInfo&gt;; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearAllBlocks</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindMatchingBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aCurrBlock: pointer)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> idx: integer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> BlockList: TArray&lt;TBlockInfo&gt; <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FBlockList ; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> BlockObj: TObjCBlockList;</code> </pre> <br><p>  The "heart" of our class beats here: </p><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlockList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddNewBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aTProc: TProc; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> aType: TProcType)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> aDesc: PBlock_Descriptor; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> BLOCK_HAS_COPY_DISPOSE = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shl</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-comment"><span class="hljs-comment">//           SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); //      FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; //  ,       . , //  copy  displose. ?   . FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; //         : FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); //   -: aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end;</span></span></code> </pre> <br><p>  Well, we wrote all the main things.  There are only a few subtle points. </p><br><p>  First, we need to add thread safety so that we can work with a class instance from different threads.  It's pretty simple, and we added the appropriate code. </p><br><p>  Secondly, we need to find out, and when it is possible to finally ‚Äúbeat‚Äù the structure created by us, i.e.  array element <code>FBlockList</code> .  At first glance it seems that as soon as the system called the callback, the block can be deleted: the file was loaded, the completion handler was called - everything is done.  In fact, this is not always the case.  There are blocks that are called as many times as necessary;  For example, in the <a href="https://developer.apple.com/reference/appkit/nsimage/1519860-imagewithsize">imageWithSize: flipped: drawingHandler:</a> <code>NSImage</code> you need to pass a pointer to a block that will draw a picture, which, as you understand, can occur at least a million times.  This is where <code>aDesc.dispose_helper := @DisposeCallback</code> useful to <code>aDesc.dispose_helper := @DisposeCallback</code> .  A call to the <code>DisposeCallback</code> procedure will signal that the block is no longer needed and can be safely removed. </p><br><h3 id="vishenka-na-torte">  Cherry on the cake </h3><br><p>  And let's write a self-test, right in the same unit?  Suddenly, something will break in the next version of the compiler or when switching to 64 bits.  How can I test blocks without referring to Cocoa classes?  It turns out that for this there are special low-level functions that we first need to declare in Delphi like this: </p><br><pre> <code class="delphi hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">imp_implementationWithBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: id)</span></span></span><span class="hljs-function">:</span></span> pointer; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> libobjc <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> _PU + <span class="hljs-string"><span class="hljs-string">'imp_implementationWithBlock'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">imp_removeBlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(anImp: pointer)</span></span></span><span class="hljs-function">:</span></span> integer; <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">external</span></span> libobjc <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> _PU + <span class="hljs-string"><span class="hljs-string">'imp_removeBlock'</span></span>;</code> </pre> <br><p>  The first function returns a pointer to a C function, which calls the block we passed as an argument.  The second simply cleans up the memory.  Great, then we need to create a block using our beautiful class, transfer it to <code>imp_implementationWithBlock</code> , call the function at the received address and look at how the unit worked with a sinking heart.  We try to fulfill all this.  Option one, <strong>naive</strong> : </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelfTest</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; test: NativeUint; func : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( p1, p2, p3, p4: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> test:= <span class="hljs-number"><span class="hljs-number">0</span></span>; p:= TObjCBlock.CreateBlockWithProcedure( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1, p2, p3, p4: pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">:</span></span>= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); @func := imp_implementationWithBlock(p); func(pointer(<span class="hljs-number"><span class="hljs-number">1</span></span>), pointer(<span class="hljs-number"><span class="hljs-number">2</span></span>), pointer(<span class="hljs-number"><span class="hljs-number">3</span></span>), pointer(<span class="hljs-number"><span class="hljs-number">4</span></span>)); imp_removeBlock(@func); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test &lt;&gt; (<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> Exception.Create(<span class="hljs-string"><span class="hljs-string">'Objective-C code block self-test failed!'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><p>  Run and ... oops.  We fall into an anonymous method: p1 = 1, p2 = 3, p3 = 4, p4 = garbage.  What the ...?  Who ate a deuce?  And why is garbage in the last parameter?  It turns out that the point is that <code>imp_implementationWithBlock</code> returns a trampoline, which allows you to call a block as an <code>IMP</code> .  The problem is that <code>IMP</code> in Objective-C always have two required first arguments, <code>(id self, SEL _cmd)</code> , i.e.  pointers to the object and to the selector, and the code block has only one mandatory argument at the beginning.  The returned trampoline, when called, edits the list of arguments: the second argument, <code>_cmd</code> , is thrown out for uselessness, the first argument is written in its place, but the pointer to <code>NSBlock</code> substituted for the first argument. </p><br><p>  Yes, like this, the trampoline crept unnoticed.  Ok, second variant, <strong>correct</strong> : </p><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TObjCBlock</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SelfTest</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p: pointer; test: NativeUint; func : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( p1, _cmd, p2, p3, p4: pointer)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">cdecl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> test:= <span class="hljs-number"><span class="hljs-number">0</span></span>; p:= TObjCBlock.CreateBlockWithProcedure( <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p1, p2, p3, p4: pointer)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">begin</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-function">:</span></span>= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>); @func := imp_implementationWithBlock(p); <span class="hljs-comment"><span class="hljs-comment">// , _cmd  ! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end;</span></span></code> </pre> <br><p>  Now everything runs smoothly and you can enjoy working with blocks.  The whole unit can be downloaded <a href="">here</a> or viewed below.  Comments ("lamers, you have a memory flowing here") and suggestions for improvement are welcome. </p><br><div class="spoiler">  <b class="spoiler_title">Full Source Code</b> <div class="spoiler_text"><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Implementation of Objective-C Code Blocks }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ Copyright(c) 2017 TamoSoft Limited }</span></span> <span class="hljs-comment"><span class="hljs-comment">{ }</span></span> <span class="hljs-comment"><span class="hljs-comment">{*******************************************************}</span></span> <span class="hljs-comment"><span class="hljs-comment">{ LICENSE: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: You may not use the Software in any projects published under viral licenses, including, but not limited to, GNU GPL. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE }</span></span> <span class="hljs-comment"><span class="hljs-comment">//USAGE EXAMPLE // // FSaveFile :=TNSSavePanel.Wrap(TNSSavePanel.OCClass.savePanel); // NSWin := WindowHandleToPlatform(Screen.ActiveForm.Handle).Wnd; // objc_msgSendP2( // (FSaveFile as ILocalObject).GetObjectID, // sel_getUid(PAnsiChar('beginSheetModalForWindow:completionHandler:')), // (NSWin as ILocalObject).GetObjectID, // TObjCBlock.CreateBlockWithProcedure( // procedure (p1: NSInteger) // begin // if p1 = 0 // then ShowMessage ('Cancel') // else ShowMessage ('OK'); // end) // ); unit Mac.CodeBlocks; interface uses System.SysUtils, Macapi.ObjectiveC, Macapi.Foundation, Macapi.Helpers, Macapi.ObjCRuntime, Macapi.CocoaTypes; type TProc1 = TProc; TProc2 = TProc&lt;pointer&gt;; TProc3 = TProc&lt;pointer, pointer&gt;; TProc4 = TProc&lt;pointer, pointer, pointer&gt;; TProc5 = TProc&lt;pointer, pointer, pointer, pointer&gt;; TProc6 = TProc&lt;NSInteger&gt;; TProc7 = TFunc&lt;NSRect, boolean&gt;; TProcType = (ptNone, pt1, pt2, pt3, pt4, pt5, pt6, pt7); TObjCBlock = record private class procedure SelfTest; static; class function CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; static; public class function CreateBlockWithProcedure(const aProc: TProc1): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc2): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc3): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc4): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc5): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc6): pointer; overload; static; class function CreateBlockWithProcedure(const aProc: TProc7): pointer; overload; static; end; implementation function imp_implementationWithBlock(block: id): pointer; cdecl; external libobjc name _PU + 'imp_implementationWithBlock'; function imp_removeBlock(anImp: pointer): integer; cdecl; external libobjc name _PU + 'imp_removeBlock'; type Block_Descriptor = packed record Reserved: NativeUint; Size: NativeUint; copy_helper: pointer; dispose_helper: pointer; end; PBlock_Descriptor = ^Block_Descriptor; Block_Literal = packed record Isa: pointer; Flags: integer; Reserved: integer; Invoke: pointer; Descriptor: PBlock_Descriptor; end; PBlock_Literal = ^Block_Literal; TBlockInfo = packed record BlockStructure: Block_Literal; LocProc: TProc; ProcType: TProcType; end; PBlockInfo = ^TBlockInfo; TObjCBlockList = class (TObject) private FBlockList: TArray&lt;TBlockInfo&gt;; procedure ClearAllBlocks; public constructor Create; destructor Destroy; override; function AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; function FindMatchingBlock(const aCurrBlock: pointer): integer; procedure ClearBlock(const idx: integer); property BlockList: TArray&lt;TBlockInfo&gt; read FBlockList ; end; var BlockObj: TObjCBlockList; function InvokeCallback(aNSBlock, p1, p2, p3, p4: pointer): pointer; cdecl; var i: integer; aRect: NSRect; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then begin case BlockObj.BlockList[i].ProcType of TProcType.pt1: TProc1(BlockObj.BlockList[i].LocProc)(); TProcType.pt2: TProc2(BlockObj.BlockList[i].LocProc)(p1); TProcType.pt3: TProc3(BlockObj.BlockList[i].LocProc)(p1, p2); TProcType.pt4: TProc4(BlockObj.BlockList[i].LocProc)(p1, p2, p3); TProcType.pt5: TProc5(BlockObj.BlockList[i].LocProc)(p1, p2, p3, p4); TProcType.pt6: TProc6(BlockObj.BlockList[i].LocProc)(NSinteger(p1)); TProcType.pt7: begin aRect.origin.x := CGFloat(p1); aRect.origin.y := CGFloat(p2); aRect.size.width := CGFloat(p3); aRect.size.height:= CGFloat(p4); result:= pointer(TProc7(BlockObj.BlockList[i].LocProc)(aRect)); end; end; end; finally TMonitor.Exit(BlockObj); end; end; end; procedure DisposeCallback(aNSBlock: pointer) cdecl; var i: integer; begin if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try i:= BlockObj.FindMatchingBlock(aNSBlock); if i &gt;= 0 then BlockObj.ClearBlock(i); finally TMonitor.Exit(BlockObj); end; end; TNSObject.Wrap(aNSBlock).release; end; procedure CopyCallback(scr, dst: pointer) cdecl; begin // end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc1): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt1); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc2): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt2); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc3): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt3); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc4): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt4); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc5): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt5); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc6): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt6); end; class function TObjCBlock.CreateBlockWithProcedure(const aProc: TProc7): pointer; begin result:= CreateBlockWithCFunc(TProc(aProc), TProcType.pt7); end; class function TObjCBlock.CreateBlockWithCFunc(const aTProc: TProc; const aType: TProcType): pointer; begin result:= nil; if Assigned(BlockObj) then begin TMonitor.Enter(BlockObj); try result:= BlockObj.AddNewBlock(aTProc, aType); finally TMonitor.Exit(BlockObj); end; end; end; class procedure TObjCBlock.SelfTest; var p: pointer; test: NativeUint; // Yes, _cmd is ignored! func : procedure ( p1, _cmd, p2, p3, p4: pointer); cdecl; begin test:= 0; p:= TObjCBlock.CreateBlockWithProcedure( procedure (p1, p2, p3, p4: pointer) begin test:= NativeUint(p1) + NativeUint(p2) + NativeUint(p3) + NativeUint(p4); end); @func := imp_implementationWithBlock(p); // Yes, _cmd is ignored! func(pointer(1), nil, pointer(2), pointer(3), pointer(4)); imp_removeBlock(@func); if test &lt;&gt; (1 + 2 + 3 + 4) then raise Exception.Create('Objective-C code block self-test failed!'); end; {TObjCBlockList} constructor TObjCBlockList.Create; begin inherited; end; destructor TObjCBlockList.Destroy; begin TMonitor.Enter(Self); try ClearAllBlocks; finally TMonitor.Exit(Self); end; inherited Destroy; end; procedure TObjCBlockList.ClearBlock(const idx: integer); begin Dispose(FBlockList[idx].BlockStructure.Descriptor); FBlockList[idx].BlockStructure.isa:= nil; FBlockList[idx].LocProc:= nil; Delete(FBlockList, idx, 1); end; function TObjCBlockList.AddNewBlock(const aTProc: TProc; const aType: TProcType): pointer; var aDesc: PBlock_Descriptor; const BLOCK_HAS_COPY_DISPOSE = 1 shl 25; begin SetLength(FBlockList, Length(FBlockList) + 1); FillChar(FBlockList[High(FBlockList)], SizeOf(TBlockInfo), 0); FBlockList[High(FBlockList)].BlockStructure.Isa := NSClassFromString ((StrToNSStr('NSBlock') as ILocalobject).GetObjectID); FBlockList[High(FBlockList)].BlockStructure.Invoke := @InvokeCallback; FBlockList[High(FBlockList)].BlockStructure.Flags := BLOCK_HAS_COPY_DISPOSE; FBlockList[High(FBlockList)].ProcType := aType; FBlockList[High(FBlockList)].LocProc := aTProc; New(aDesc); aDesc.Reserved := 0; aDesc.Size := SizeOf(Block_Literal); aDesc.copy_helper := @CopyCallback; aDesc.dispose_helper := @DisposeCallback; FBlockList[High(FBlockList)].BlockStructure.Descriptor := aDesc; result:= @FBlockList[High(FBlockList)].BlockStructure; end; procedure TObjCBlockList.ClearAllBlocks(); var i: integer; begin for i := High(FBlockList) downto Low(FBlockList) do ClearBlock(i); end; function TObjCBlockList.FindMatchingBlock(const aCurrBlock: pointer): integer; var i: integer; begin result:= -1; if aCurrBlock &lt;&gt; nil then begin for i:= Low(FBlockList) to High(FBlockList) do begin if FBlockList[i].BlockStructure.Descriptor = PBlock_Literal(aCurrBlock).Descriptor then Exit(i); end; end; end; initialization BlockObj:=TObjCBlockList.Create; TObjCBlock.SelfTest; finalization FreeAndNil(BlockObj); end.</span></span></code> </pre> </div></div></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/325204/">https://habr.com/ru/post/325204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325194/index.html">Passing configuration parameters to Autofac modules in ASP.NET Core</a></li>
<li><a href="../325196/index.html">CAPWAP State Machine in the Cisco Unified Wireless Implementation: Discovery State</a></li>
<li><a href="../325198/index.html">Qt: Embedded World 2017 and roadmap</a></li>
<li><a href="../325200/index.html">Employee conversations with the company: how and why?</a></li>
<li><a href="../325202/index.html">Reincarnation of the PIX graphics debugger for DirectX 12</a></li>
<li><a href="../325206/index.html">Recommender systems in online education. Adaptive learning</a></li>
<li><a href="../325210/index.html">Mobile platform. ReactNative Hybrid Application Architecture</a></li>
<li><a href="../325216/index.html">Probability of data loss in large clusters</a></li>
<li><a href="../325218/index.html">"Introduction to Elixir" - the first book on the Elixir in Russian</a></li>
<li><a href="../325220/index.html">Making your first game on the Phaser. Part 2 - Loading Resources</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>