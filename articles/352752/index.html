<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural worlds from simple tiles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post I will describe two algorithms for creating complex procedural worlds from simple sets of colored tiles and based on the constraints of t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural worlds from simple tiles</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/919/111/7de919111d9102996bf475377cd0fa32.png" alt="image"></div><br>  In this post I will describe two algorithms for creating complex procedural worlds from simple sets of colored tiles and based on the constraints of the location of these tiles.  I will show how, with a neat design of these tile sets, you can create interesting procedurally generated content, for example, landscapes with cities or dungeons with a complex internal structure.  The video below shows a system that creates a procedural world based on the rules encoded in 43 color tiles. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/XVIYY0AQF-8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  The image below shows a set of tiles (tileset), on the basis of which the world is generated from the video.  The world is equipped with notes that will help to present it in a real environment. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/92c/213/90d92c213f933f60a78e965f9dec96d3.svg"></div><br>  We can define tiling as the final grid, in which each of the tiles is in its own grid cell.  We define the correct world as a world in which the colors along the edges of neighboring tiles must be the same. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/01b/0e0/82c/01b0e082cd1c4fecb947ace9dd1e88a3.svg"></div><br>  <em>The tiling has only one iron rule: the colors of the edges of the tiles must match.</em>  <em>The entire high-level structure evolves based on this rule.</em> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The correct tiling looks like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7de/919/111/7de919111d9102996bf475377cd0fa32.png"></div><br>  <em>This is a tiling, which should represent a map with water, coasts, grass, cities with buildings (blue rectangles), and mountains with snowy peaks.</em>  <em>Black lines show borders between tiles.</em> <br><br>  I think this is an interesting way of describing and creating worlds, because very often the top-down approach is used in procedural generation algorithms.  For example, in L-systems, a recursive description of an object is used, in which high-level, large parts are determined earlier than low-level ones.  There is nothing wrong with this approach, but I think it is interesting to create sets of tiles that can encode only simple low-level relationships (for example, sea water and grass should be separated by the coast, buildings should have only convex corners at 90 degrees) and watch the emergence of high-level patterns (for example, square buildings). <br><br><h2>  Tiling is an NP-complete task of satisfying constraints </h2><br>  For a reader familiar with the problems of satisfying constraints (CSP), it is already obvious that the tiling of a finite world is an OWL.  In PWD, we have a set of variables, a set of values ‚Äã‚Äãthat each variable can take (called its definition domain), and a set of constraints.  In our case, the variables are the coordinates on the map, the definition of each variable is tileset, and the limitations are that the edges of the tiles must correspond to the edges of the neighbors. <br><br>  It is intuitively clear that the task of creating a non-trivial tiling correctly is difficult, since tilesets can encode arbitrary extensive dependencies.  When we consider a tileset as a whole, from a formal point of view, this is an NP-complete task of satisfying constraints.  The naive algorithm for creating tilings consists of an exhaustive search for the space of tilings and is executed in exponential time.  There is a hope that we can create interesting worlds on the basis of tilesets solved by a search that can be accelerated by heuristics.  Another option is to create tilings that are approximately correct, but contain a small number of incorrect locations.  I found two algorithms that work well with some interesting tilesets, and I‚Äôll describe them below. <br><br><h2>  Method 1: greedy arrangement with reverse transitions </h2><br>  <em>Select random places and put the appropriate tiles there.</em>  <em>If we get stuck, remove some of them and try again.</em> <br><br> <code>     <br> <br>       <br>         <br> t &lt;-       <br> l &lt;-    t,     <br>  l   <br>  <br>           </code> <br> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a85/759/e75/a85759e75cb28e7bc473f643ee136cb1.svg"></div><br>  The first attempt to create a tiling from a tileset was that the entire grid was in an unresolved state, after which I iteratively placed a random tile in a suitable place for it, or, if there were no suitable places, assigned a small area next to the unsolved tile and continued the greedy arrangement of the tiles.  ‚ÄúGreedy arrangement‚Äù is a strategy of tile arrangement as long as its faces correspond to the tiles already placed, regardless of whether such an arrangement will create partial tiling that cannot be completed without replacing the already set tiles.  When such a situation arises and we can no longer arrange tiles, we must delete some of the previously located tiles.  But we do not know which of them is best to remove, because if we could solve the problem, then, probably, we could also solve the problem of the correct arrangement of tiles in the first place.  To give the algorithm one more chance to find a suitable tile for a given area, we assign the state ‚Äúunsolved‚Äù to all the tiles around the unresolved point and continue to carry out the strategy of the greedy arrangement.  We hope that sooner or later the correct tiling will be found, but there is no guarantee of this.  The algorithm will be executed until the correct tiling is found, which can take infinite time.  He does not have the ability to determine that tileset is undecidable. <br><br>  There are no guarantees that the algorithm will complete its work.  A simple tileset with two tiles that have no common colors will cause the algorithm to perform an infinite loop.  An even simpler case would be one tile with different colors above and below.  It will be reasonable to find some way to determine that tile sets cannot create the correct tilings.  We can say that a tileset is definitely true if it can pave an infinite plane.  In some cases, it can be easily proved that a tileset can or cannot pave an infinite plane, but in the general case this problem is unsolvable.  Therefore, the task of the designer is to create a tileset that can create the correct tiling. <br><br>  This algorithm is unable to find good solutions for the dungeon tileset from the video at the beginning of the post.  It works well with simpler tilesets.  We would like to learn how to solve more complex tilesets with a variety of possible types of transitions between tiles and various coded rules (for example, that roads must begin and end next to buildings). <br><br>  We need an algorithm that can look ahead and create tile locations, somehow aware of the ways in which these locations are open for future tile locations.  This will allow us to effectively solve difficult tilesets. <br><br><h3>  In terms of satisfying the constraints </h3><br>  This algorithm is similar to search with a reverse transition.  At each step, we try to assign one variable.  If we cannot, then we cancel the assignment of a variable and all variables that are attached to it by constraints.  This is called ‚Äúbackjumping‚Äù and is different from backtracking, in which we cancel the assignment of one variable at a time until we can continue to make the correct assignments.  When you go back, we generally cancel the assignment of variables in the reverse order of their assignment, however, when going back, we cancel the assignment of variables according to the structure of the task in question.  It is logical that if we cannot place any tile at a specific point, then we must change the location of neighboring tiles, since their location created an unsolvable situation.  Returning back instead can lead us to cancel the assignment of variables that are spatially far apart, but have been assigned recently. <br><br>  This search does not use any methods of local integrity.  That is, we do not attempt to locate the tiles, which will later lead to an unsolvable situation, even through a single search step in the future.  It is possible to accelerate the search by tracking the influence that the location will have on the possible locations in several tiles from the current point.  At the same time, it is hoped that this will allow the search not to spend so much time on the cancellation of its work.  This is exactly what our algorithm does. <br><br><h2>  Method 2: location with the greatest restrictions and distribution of local information </h2><br>  <em>We preserve the probability distribution for tiles at each point, introducing non-local changes to these distributions when deciding on the location.</em>  <em>Never backtracking.</em> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/225/3fb/4bf/2253fb4bfe48b817e51ebf002fc42fd8.svg"></div><br>  Next, I will describe an algorithm that is guaranteed to be completed and creates more visually pleasing results for all the tiles I have tested.  In addition, it can create almost true tilings for much more complex tilesets.  The compromise here is that this algorithm does not guarantee that the output will always be correct tiling.  The Optimizations section describes optimizations that allow you to perform this algorithm more quickly, even with larger tilesets and maps. <br><br>  The complexity of creating the right tiling strongly depends on the number of transitions necessary for the transition between two types of tiles.  In a simple tileset there can only be sand, water and grass.  If grass and water cannot touch each other, then there must be a transition to the sand between them.  This is a simple example that the algorithm presented earlier can easily solve.  In a more complicated case, multiple built-in levels of tile types can be represented.  For example, we may have deep water, water, sand, grass, a high plain, a mountain, and a snowy peak.  In order for all these types of tiles to appear on the map, it is necessary to have seven transitions, if we assume that these types cannot touch each other except in the order I specified.  Additional complexity can be added by creating tiles that naturally create extensive dependencies between tiles, for example, roads that must start and end next to certain types of tiles. <br><br>  Intuitively, the algorithm for this task should be able to ‚Äúlook ahead‚Äù and consider at least a few transitions that may be the consequences of the chosen location.  To do this, you can think of a tile map as a probability distribution for tiles at each point.  When the algorithm places a tile, it updates the probability distribution around this tile in response to its location in such a way that it increases the likelihood of neighboring tiles, which can probably be compatible with the current location. <br><br>  For example, if there is a water tile on the card, then the tiles next to it must contain water.  Tiles near them can also contain water, but there are other probabilities, for example, grass, if the coast is placed near the original water tile.  The further we move away from the tile located, the more types of tiles it becomes possible.  To take advantage of this observation, we can count the number of ways in which we can reach the location of each tile next to the source tile.  In some cases, only a single sequence of transitions can lead to the transition of one tile to another at a given distance.  In other cases, there may be many different sequences of transitions.  After the location of the tile, we can determine the probability distribution of tiles in neighboring points, counting the number of ways we can make the transition from the tile, which we have arranged, to neighboring tiles.  The ‚Äúlook ahead‚Äù performed by this algorithm is tracking of such numbers of transitions and their processing as probability distributions from which one can choose available new tiles. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d19/0d3/3f0/d190d33f07a37df8dbe40ba66d9ec8a1.svg"></div><br>  At each step, the algorithm examines all the unresolved tile locations, each of which has a probability distribution over the tiles, and selects one place to ‚Äúconverge‚Äù to the tile.  He chooses a distribution from a map with minimal entropy.  In the case of multinomial distributions with low entropy, the probabilities are usually concentrated in several modes, therefore the convergence of these first ones leads to the effect of placing tiles, for which some of the limitations already exist.  That is why the algorithm places the tiles next to the tiles that we decided first. <br><br>  This is the most efficient algorithm that I managed to implement for this task.  It has another advantage: it creates beautiful visualizations while performing.  Perhaps there is a way to improve this algorithm by entering some form of reversion.  If there is an incorrect point in the resulting finished tiling, then canceling the locations of neighboring tiles and resampling from the resulting distributions at their points may allow finding a fix for this ready tiling.  Of course, if you want to continue searching until you find the correct tiling, then exceed the limits of the specified guaranteed execution time. <br><br><h3>  Optimization </h3><br>  The most important operation of this method is to update the probabilities around the tile located.  One approach would be to count the possible transitions "out" from the tile located each time the tile is located.  This will be very slow, since for each point of the map, to which the new probabilities will extend, it will be necessary to consider many pairs of transitions.  Obvious optimization will not be spreading to the entire map.  A more interesting optimization is the caching of influence that each tile arrangement will have on points around it, so that each tile arrangement simply performs a search to check what types of changes the arrangement makes to adjacent probabilities, followed by applying this change with some simple operations.  Below I will describe my implementation of this optimization method. <br><br>  Imagine a tile placed on a completely empty card.  This location will update the adjacent tile probabilities.  We can consider these updated distributions as having the previous distribution defined by the previous tile locations.  If several tiles are placed, this previous distribution will be shared.  I approximate this posterior probability taking into account the previous joint as the product of distributions for each location in the past. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/557/5c1/bd5/5575c1bd57561b01cdfc05f19c178cbf.svg"></div><br>  To realize this, I will imagine that when the tile is located on an empty map, it introduces significant changes in the distribution of neighboring points of the map.  I will call these updates the <em>sphere of a</em> tile, that is, the sphere of influence of a tile projected around it when it is placed on an empty map.  When two tiles are located next to each other, their spheres interact and create finite distributions, which are influenced by both locations.  Given that many tiles can be located near a given unresolved place, there will be a large number of interacting constraints, making a counting decision to determine the probability of different tiles appearing at this point as a very slow process.  What if, instead, we consider only a simple model of interaction between previously calculated tile spheres that were already located on the map? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/788/b48/7db/788b487db122422770bcfd6711191724.svg"></div><br>  With the location of the tile, I update the probability map for each element, multiplying the distribution of the sphere of this tile by each point of the map by the distribution already stored at that point of the map.  It may be helpful to look at an example of what this can do with the distribution map.  Suppose a given map point currently has a distribution that can equally select grass or water, and we place a water tile next to this point.  The sphere of the water tile will have a high probability of water near the water tile and a low probability of grass tile.  When we multiply these distributions element by element, the likelihood of water will be high as a result, because it is the product of two large probabilities, but the likelihood of grass will be low, because it is the product of a high probability stored on the map, with a low probability stored in the field. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c8/732/1af/1c87321af26a29ce5d8594e7ac30e3d4.svg"></div><br>  This strategy allows us to efficiently approximate the effect that each tile arrangement should have on a probability map. <br><br><h3>  In terms of satisfying the restrictions </h3><br>  In order to effectively solve problems of satisfying constraints, it is often reasonable to track those assignments of other variables that become impossible when assigning a particular variable.  This principle is called the introduction of local compatibility conditions.  Introducing some kind of local compatibility avoids assigning a variable a value when assigning an adjacent variable an incompatible value when it is necessary to go back.  Such transformations are related to the field of methods of propagation of restrictions in the literature on CBD.  In our algorithm, we spread information to a small area of ‚Äã‚Äãthe map each time we place a tile.  The information disseminated informs which tiles can and cannot appear next to each other.  For example, if we have a mountain tile, then we know that there cannot be an open sea tile in two tiles of it, that is, the probability of a sea tile at all points of the map in two tiles from a tile located is zero.  This information is recorded in the areas of which we spoke above.  The spheres encode the local compatibility we want to impose. <br><br>  By reducing the number of possible assignments of neighboring tiles, we significantly reduce the search space that the algorithm should process after each location.  We know that in this small neighborhood all the probabilities of the appearance of tiles that are incompatible with the location are zero.  This is analogous to removing these values ‚Äã‚Äãfrom the variable definition areas at these points.  That is, each pair of neighboring points in the area around a tile has in its domain a certain tile that is compatible with some tile that is still in the domain of definition of neighbors.  When two variables are connected by a constraint to the task of the PP, and their domains of definition contain only values ‚Äã‚Äãsatisfying the constraint, they are said to have arc compatibility, that is, this method is actually an effective strategy for introducing arc compatibility. <br><br>  In PWD, the ‚Äúmost limited‚Äù variable in a given partial assignment is the one with the least possible values ‚Äã‚Äãin the definition area.  The principle of the location of a tile at a point by the minimum distribution of entropy on the map is similar to assigning the value to the most limited variable in the OIL, which is the standard heuristic of the ordering of variables when solving OAT using a search. <br><br><h2>  Tiller manipulation of changing tile selection probabilities </h2><br>  So far I have only talked about how to create the right tilings, but besides correctness, other properties may be required from the tiling.  For example, we may need a certain ratio of the number of one type of tiles to another, or we want to ensure that not all tiles have the same type, even if such a tiling is correct.  To solve this problem, both algorithms described by me receive as input the basic probability associated with each tile.  The higher this probability, the more likely this tile will be present in the finished tiling.  Both algorithms make a random selection from a collection of tiles, and I will simply add weights to this random selection according to the basic probabilities of the tiles. <br><br>  Below is an example of using this principle.  By changing the likelihood of a solid water tile, I can adjust the size and frequency of water appearing on the map. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ad2/30f/042/ad230f042cb48f0f5381915a63ef5cd0.svg"></div><br><h2>  Create your own tilesets </h2><br>  In short: <br><br><ul><li>  clone my <a href="https://github.com/IJDykeman/wangTiles">repository on github</a> </li><li>  install Processing </li><li>  in the data / repository folder, change tiles.png </li><li>  use processing to open wangTiles.pde and click on the play button </li></ul><br>  With the help of the code laid out on github (you can change it, but do it at your own peril and risk - I wrote most of it in high school) you can create your own tilesets using the image editor and watch the tiling solver create worlds with them .  Simply clone the repository and edit the image of dungeon.png, and then use Processing to launch wangTiles.pde and view the animation of the generated map.  Below I will describe the ‚Äúlanguage‚Äù that this tiling solver needs. <br><br><h3>  Tilesets specification </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/233/50a/d6b/23350ad6b5addff23fc3307094735a8c.svg"></div><br>  Tiles are arranged in a grid of 4x4 cells.  Each cell in the upper left 3x3 area contains a color tile, and the remaining 7 pixels contain tile metadata.  Pixel under the center of the tile can be painted in red to comment out the tile and exclude it from the tileset.  Solvers will never put it on the map.  The upper pixel on the right side of the tile can be painted black to add all four tile turns to the tileset.   ,     -  ,     . ,           .        .   ,     . <br><br><h2>     </h2><br>    <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BB%25D0%25B8%25D1%2582%25D0%25BA%25D0%25B8_%25D0%2592%25D0%25B0%25D0%25BD%25D0%25B0"> </a> ,            ,     ,   ,     . <br><br>  ¬´Most Constrained Placement with Fuzzy Arc Consistency¬ª    Wave Function Collapse  Twitter <a href="https://twitter.com/ExUtumno">@ExUtumno</a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">This algorithm stores a map of ‚Äúpartially observable‚Äù assignments and, to create a final image, takes samples from them, which is similar to the distributions I keep for tiles. </font><font style="vertical-align: inherit;">These approaches differ in some aspects. </font><font style="vertical-align: inherit;">For each point of the map, this algorithm preserves binary potentials, and not multinomial distributions. </font><font style="vertical-align: inherit;">In addition, it does not use cached "spheres" of the number of transitions needed to speed up the calculations, which I talked about in the "Optimization" section.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Conclusions and thanks </font></font></h2><br>       , ,   ¬´   ¬ª     ,       - ,   ,  .       .          .        ,          .          ,       .         ,          . <br><br>     <a href="http://cannontwo.com/"> </a>            .             .         ,              . </div><p>Source: <a href="https://habr.com/ru/post/352752/">https://habr.com/ru/post/352752/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352742/index.html">The book ‚ÄúHigh-loaded applications. Programming, scaling, support</a></li>
<li><a href="../352744/index.html">Mobio Talks with Natalia Shagarina (Foodadil) about product growth, launching a cashback service and partnership with Yandex</a></li>
<li><a href="../352746/index.html">Data Center in Miniature</a></li>
<li><a href="../352748/index.html">We are looking for problems with website conversion to Google Spreadsheets</a></li>
<li><a href="../352750/index.html">Cretaceous lettering for dummies on the example of working on an art object</a></li>
<li><a href="../352754/index.html">Introducing Google's S2 Geo-Library and Case Studies</a></li>
<li><a href="../352758/index.html">What is behind the cleanliness in your apartment, or Qlean preparation</a></li>
<li><a href="../352760/index.html">Compare Tarantool with Redis and Memcached</a></li>
<li><a href="../352762/index.html">Code Conventions: how we maintain the fast pace of developing a PHP project</a></li>
<li><a href="../352764/index.html">EGAIS 3.0 or how not to answer for the mistakes of others</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>