<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why do physicists still use Fortran</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I do not know what the programming language will look like in the year 2000, but I know that it will be called FORTRAN. 
 - Charles Anthony Richard Ho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why do physicists still use Fortran</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  I do not know what the programming language will look like in the year 2000, but I know that it will be called FORTRAN. <br>  - Charles Anthony Richard Hoare, ca.  1982 </blockquote><br>  In the industry, Fortran is rarely used today - it <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">was ranked 28th</a> in one of the lists of popular languages.  But Fortran is still the main language for large-scale simulations of physical systems ‚Äî that is, for such things as astrophysical modeling of stars and galaxies (eg <a href="http://flash.uchicago.edu/site/flashcode/">Flash</a> ), large-scale molecular dynamics, electronic structure counting codes ( <a href="http://departments.icmab.es/leem/siesta/">SIESTA</a> ), climate models, and so on.  In the field of high-performance computing, a subset of which are large-scale numerical simulations, today only two languages ‚Äã‚Äãare used - C / C ++ and ‚Äúmodern Fortran‚Äù (Fortran 90/95/03/08).  Popular <a href="https://en.wikipedia.org/wiki/Open_MPI">Open MPI</a> libraries for code parallelization were developed for these two languages.  In general, if you need fast code running on multiple processors, you have only two options.  In modern Fortran there is such a feature as " <a href="https://habrahabr.ru/company/intel/blog/203618/">coarray</a> ", which allows working with parallel programming directly in the language.  Coarray appeared in the expansion Fortran 95, and then were included in Fortran 2008. <br><br>  The active use of Fortran by physicists often confuses computer scientists and other unrelated people who feel that Fortran is a historical anachronism. <br><a name="habracut"></a><br>  I would like to explain why Fortran still remains useful.  I don‚Äôt encourage students who study physics to teach Fortran ‚Äî since most of them will be doing research, they‚Äôd better study C / C ++ (or stay at Matlab / Octave / Python).  I would like to clarify why Fortran is still in use, and prove that this is not only because physicists are ‚Äúlagging behind fashion‚Äù (although sometimes this is the case - last year I saw a physics student who worked with code Fortran 77, while neither he nor his head heard anything about Fortran 90).  Computer scientists should consider the predominance of Fortran in numerical calculations as a challenge. <br><br>  Before I delve into the topic, I want to discuss the story, because when people hear the word "Fortran", they immediately imagine punch cards and code with numbered lines.  The first Fortran specification was written in 1954.  The early Fortran (then its name was written in capital letters, FORTRAN) was, by modern standards, a hell of a language, but it was an incredible step forward from previous programming in assembler.  FORTRAN was often programmed using punched cards, as Professor Miriam Forman of Stony Brooke University remembers without pleasure.  Fortran had many versions, the most famous of which are the standards 66, 77, 90, 95, 03 and 08. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is often said that Fortran is still used because of its speed.  But is he the fastest?  The site <a href="http://benchmarksgame.alioth.debian.org/">benchmarksgame.alioth.debian.org</a> has a <a href="http://benchmarksgame.alioth.debian.org/u64q/fortran.html">comparison of C and Fortran</a> in several tests among many languages.  In most cases, Fortran and C / C ++ are the fastest.  Python loved by programmers often lags 100 times behind, but it‚Äôs in the order of things for interpreted code.  Python is not suitable for complex numerical calculations, but works well for another.  Interestingly, C / C ++ wins Fortran in all tests, except two, although in general they differ little in results.  The tests, where Fortran wins, the most ‚Äúphysical‚Äù ones are the simulation of a system of n bodies and the calculation of the spectrum.  The results depend on the number of processor cores, for example, Fortran is a little behind C / C ++ on the quad core.  Tests, in which Fortran lags far behind C / C ++, most of the time are engaged in reading and writing data, and in this respect, Fortran's slowness is known. <br><br>  So, C / C ++ is as fast as Fortran, and sometimes a bit faster.  We are interested in, ‚Äúwhy do physics professors continue to advise their students to use Fortran instead of C / C ++?‚Äù <br><br><h2>  Fortran has inherited code </h2><br>  Due to the long history of Fortran, it is not surprising that there are mountains of physics code written on it.  Physicists are trying to minimize programming time, so if they find an earlier code, they will use it.  Even if the old code is unreadable, poorly documented and not the most effective, it is more likely to use the old code that is checked than to write a new one.  The task of physicists is not to write code, they are trying to understand the nature of reality.  Professors have the inherited code always at hand (they often wrote this code decades ago), and they pass it on to their students.  This saves their time and removes uncertainties from the process of eliminating errors. <br><br><h2>  Physic students learn Fortran more easily than C / C ++ </h2><br>  I think learning Fortran is easier than C / C ++.  Fortran 90 and C are very similar, but Fortran is easier to write.  C is a relatively primitive language, so physicists who choose C / C ++ for themselves are engaged in object-oriented programming.  OOP can be useful, especially in large software projects, but it is much longer to study it.  We need to learn abstractions such as classes and inheritance.  The PLO paradigm is very different from the procedural one used in Fortran.  Fortran is based on the simplest procedural paradigm, more similar to what is happening at the computer "under the hood."  When you optimize / vectorize code to increase speed, the procedural paradigm is easier to work with.  Physicists usually understand how computers work, and think in terms of physical processes, such as transferring data from disk to RAM, and from RAM to the processor's cache.  They differ from mathematicians who prefer to think in terms of abstract functions and logic.  Also this thinking is different from object-oriented.  Optimization of OOP code is more complicated from my point of view than procedural.  Objects are very bulky structures compared to data structures preferred by physicists: arrays. <br><br><h2>  Easy first: Fortran work with arrays </h2><br>  Arrays, or, as physicists call them, matrices, are at the heart of all physical computing.  In Fortran 90+ you can find many opportunities to work with them, similar to <a href="https://en.wikipedia.org/wiki/APL_(programming_language)">APL</a> and Matlab / Octave.  Arrays can be copied, multiplied by a scalar, multiplied with each other in a very intuitive way: <br><br><pre><code class="hljs lisp">A = B A = <span class="hljs-number"><span class="hljs-number">3.24</span></span>*B C = A*B B = exp(<span class="hljs-name"><span class="hljs-name">A</span></span>) norm = sqrt(<span class="hljs-name"><span class="hljs-name">sum</span></span>(<span class="hljs-name"><span class="hljs-name">A**2</span></span>))</code> </pre> <br>  Here, A, B, C are arrays of some dimension (say, 10x10x10).  C = A * B gives us the elementwise multiplication of matrices, if A and B are the same size.  For matrix multiplication, C = matmul (A, B) is used.  Almost all internal functions Fortran (Sin (), Exp (), Abs (), Floor (), etc.) take arrays as arguments, which results in simple and clean code.  There is simply no similar code in C / C ++.  In the basic implementation of C / C ++, simple copying of an array requires running for loops on all elements or calling a library function.  If you feed an array of the wrong library function in C, an error will occur.  The need to use libraries instead of internal functions means that the resulting code will not be clean and portable, or easy to learn. <br><br>  In Fortran, access to the elements of an array using the simple syntax A [x, y, z], when in C / C ++ you need to write A [x] [y] [z].  The elements of the arrays start from 1, which corresponds to the physicists' ideas about matrices, and in arrays of C / C ++, the numbering starts from zero.  Here are some more functions for working with arrays in Fortran. <br><br><pre> <code class="hljs lisp">A = (<span class="hljs-name"><span class="hljs-name">/</span></span> i , i = <span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span> /) B = A(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">100</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) C(<span class="hljs-number"><span class="hljs-number">10</span></span>:) = B</code> </pre> <br>  First, the vector A is created through an implicit do loop, also known as an array constructor.  Then a vector B is created, consisting of every 10th element A, with the help of step 10. And finally, the array B is copied into array C, starting with the 10th element.  Fortran supports declaring arrays with zero or negative indices: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, dimension(<span class="hljs-number"><span class="hljs-number">-1</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span>) :: myArray</code> </pre> <br>  The negative index at first looks silly, but I heard about their usefulness - for example, imagine that this is an additional area for placing any explanations.  Fortran also supports <a href="http://www.fortran.gantep.edu.tr/local/HPFCourse/HTMLHPFCourseNotesnode102.html">vector indices</a> .  For example, you can transfer elements 1.5 and 7 from array A of dimension N x 1 to array B of dimension 3 x 1: <br><br><pre> <code class="hljs lisp">subscripts = (<span class="hljs-name"><span class="hljs-name">/</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> /) B = A(<span class="hljs-name"><span class="hljs-name">subscripts</span></span>)</code> </pre> <br>  Fortran supports array <a href="http://www.fortran.gantep.edu.tr/local/HPFCourse/HTMLHPFCourseNotesnode100.html">masks</a> in all internal functions.  For example, if we need to calculate the logarithm of all the elements of the matrix greater than zero, we use: <br><br><pre> <code class="hljs lisp">log_of_A = log(<span class="hljs-name"><span class="hljs-name">A</span></span>, mask= A .gt. <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Or we can zero out all negative elements of the array in one line: <br><br><pre> <code class="hljs lisp">where(<span class="hljs-name"><span class="hljs-name">my_array</span></span> .lt. <span class="hljs-number"><span class="hljs-number">0.0</span></span>) my_array = <span class="hljs-number"><span class="hljs-number">0.0</span></span></code> </pre> <br>  Fortran makes it easy to dynamically allocate and free arrays.  For example, to place a two-dimensional array: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">real</span></span>, dimension(:,:), allocatable :: name_of_array allocate(name_of_array(xdim, ydim))</code> </pre> <br>  In C / C ++, this <a href="http://www.eskimo.com/~scs/cclass/int/sx9b.html">requires the following entry</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> **<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">array</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(nrows * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> *)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){ <span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i] = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(ncolumns * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)); }</code> </pre> <br>  To free an array in Fortran <br><br><pre> <code class="hljs lisp">deallocate(<span class="hljs-name"><span class="hljs-name">name_of_array</span></span>)</code> </pre> <br>  In C / C ++ for this <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &amp;lt; nrows; i++){ <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>[i]); } <span class="hljs-built_in"><span class="hljs-built_in">free</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>);</code> </pre> <br><h2>  Easy second: no need to worry about pointers and memory allocation </h2><br>  In languages ‚Äã‚Äãlike C / C ++, all variables are passed by value, with the exception of arrays passed by reference.  But in many cases, passing an array by value makes more sense.  For example, let the data consist of the positions of 100 molecules in different periods of time.  We need to analyze the movement of a single molecule.  We take a slice of the array (sub-array) corresponding to the coordinates of the atoms in this molecule and transfer it to the function.  In it, we will deal with a complex analysis of the transferred subarray.  If we passed it by reference, the transferred data would not be located in memory in a row.  Because of the peculiarities of memory access, working with such an array would be slow.  If we pass it by value, we will create in memory a new array located in a row.  To the delight of physicists, the compiler takes on all the dirty work of memory optimization. <br><br>  In Fortran, variables are usually passed by reference, not by value.  Under the hood, the Fortran compiler automatically optimizes their transfer for increased efficiency.  From the point of view of the professor in the field of optimizing memory usage, the compiler should be trusted more than the student!  As a result, physicists rarely use pointers, although <a href="http://www.personal.psu.edu/jhm/f90/lectures/42.html">they do exist</a> in Fortran-90 +. <br><br><h2>  Some more examples of differences between Fortran and C </h2><br>  Fortran has several options for managing the compiler when searching for errors and optimizing.  Errors in the code can be caught at the compilation stage, and not during execution.  For example, any variable can be declared as a parameter, that is, a constant. <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">double</span></span> <span class="hljs-type"><span class="hljs-type">precision</span></span>, parameter :: hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code> </pre> <br>  If the parameter in the code changes, the compiler returns an error.  In C this is called <a href="https://en.wikipedia.org/wiki/Const_(computer_programming)">const</a> <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> hbar = <span class="hljs-number"><span class="hljs-number">6.63e-34</span></span></code> </pre> <br>  The problem is that const real is different from simple real.  If the function that accepts real receives const real, it will return an error.  It's easy to imagine how this can lead to interoperability problems in code. <br><br>  Fortran also has an intent specification that tells the compiler whether the argument passed to the function is an input, an output, or both an input and an output parameter.  This helps the compiler to optimize the code and increases its readability and reliability. <br><br>  Fortran has other features used with varying frequencies.  For example, in Fortran 95 it is possible to declare functions with the pure modifier.  Such a function has no side effects - it changes only its arguments, and does not change global variables.  A special case of such a function is the elemental function, which receives and returns scalars.  It is used to process the elements of an array.  Information that the pure or elemental function allows the compiler to perform additional optimization, especially when code is parallelized. <br><br><h2>  What to expect in the future? </h2><br>  In scientific calculations, Fortran remains the main language, and is not going to disappear in the near future.  In a <a href="https://software.intel.com/en-us/blogs/2015/03/27/doctor-fortran-in-the-future-of-fortran">survey</a> among those using the language of the visitors of the 2014 Supercomputing Convention conference, 100% of them said that they were going to use it in the next 5 years.  It also follows from the survey that 90% used a mixture of Fortran and C. Anticipating an increase in mixing these languages, the creators of the Fortran 2015 specification include more possibilities for interoperability of the code.  Fortran code is increasingly being invoked from Python code.  Computer scientists who criticize the use of Fortran do not understand that this language remains uniquely adapted to what it was called FOrmula TRANslation, which translates formulas, that is, transforms physical formulas into code.  Many of them do not realize that the language is developing and constantly includes all the new features. <br><br>  To call modern Fortran 90+ old is the same as calling old C ++, because C was developed in 1973. On the other hand, even in the newest standard Fortran 2008 there is backward compatibility with Fortran 77 and most of Fortran 66. Therefore, the development of language is associated with certain difficulties.  Recently, MIT researchers decided to overcome these difficulties by developing from scratch a language for HPC called <a href="http://newsoffice.mit.edu/2014/high-performance-computing-programming-ease">Julia</a> , first published in 2012.  Does Julia take the place of Fortran, remains to be seen.  In any case, I suspect that this will take a very long time. </div><p>Source: <a href="https://habr.com/ru/post/400523/">https://habr.com/ru/post/400523/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../400511/index.html">On the modern method of storing spent nuclear fuel</a></li>
<li><a href="../400513/index.html">G√∂del‚Äôs incompleteness theorem in 20 minutes</a></li>
<li><a href="../400515/index.html">Blockchenizer: advantages of the blockchain for those who do not like cryptocurrency</a></li>
<li><a href="../400519/index.html">Modular 3D-printer "3D-Start" as a source of interest for 3D-cats</a></li>
<li><a href="../400521/index.html">Apple fixed a bug and accuses Consumer Reports of incorrect testing methodology.</a></li>
<li><a href="../400525/index.html">Developing a mnemonic number memorization system</a></li>
<li><a href="../400527/index.html">Recampling II. Comparison of the operation of digital and analog filters of high order in the sound path and answers to questions</a></li>
<li><a href="../400529/index.html">Vision correction equipment</a></li>
<li><a href="../400531/index.html">The State Duma Committee approved a bill on the regulation of audiovisual services.</a></li>
<li><a href="../400533/index.html">The main paradox of consciousness. Why does not it make sense to copy the brain or personality</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>