<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Fast Data Recipe Based on Big Data Solution</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Image source 

 When discussing how to work with big data, the issues of analytics and the problems of organizing the computation process are most oft...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Fast Data Recipe Based on Big Data Solution</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/6c4/38d/423/6c438d42309c44c39391904ee9028018.jpg" alt="source: http://searchsoa.techtarget.com/photostory/2240203721/Five-potential-big-data-problems-and-solutions/5/Velocity-Catch-it-Capture-fast-moving-data-and-use- it"></div><br>  <a href="http://searchsoa.techtarget.com/photostory/2240203721/Five-potential-big-data-problems-and-solutions/5/Velocity-Catch-it-Capture-fast-moving-data-and-use-it"><sup>Image source</sup></a> <br><br>  <i>When discussing how to work with big data, the issues of analytics and the problems of organizing the computation process are most often affected.</i>  <i>My colleagues and I had the opportunity to work on tasks of another kind - accelerating data access and balancing the load on the storage system.</i>  <i>Below I will talk about how we dealt with this.</i> <br><br>  We made our own ‚Äúrecipe‚Äù from the already existing ‚Äúingredients‚Äù: hardware and software tools.  First, I will tell you how the task of speeding up access arose.  Then consider the hardware and software tool.  In conclusion, let's talk about two problems that we had to face in the course of work. <br><a name="habracut"></a><br>  Let's start with a description of the problem. <br>  In an environment that we had to optimize, a horizontally scalable <a href="https://ru.wikipedia.org/wiki/NAS">network</a> storage is used for data <a href="https://ru.wikipedia.org/wiki/NAS">storage</a> .  If you are not familiar with these words, do not worry, I'll explain everything now :) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      A horizontally scalable data storage system (in English, ‚Äúscale-out NAS‚Äù) is a cluster system consisting of a set of nodes interconnected by a high-speed internal network.  All nodes are available to the user separately through an external network, for example, via the Internet. <br><br><img src="https://habrastorage.org/files/69d/50e/c44/69d50ec44ae04ef180474c3e49fddacc.jpg" alt="Scale out NAS"><br><br>  The diagram shows only three nodes.  In fact, they can be much more.  This is the beauty of scale-out systems.  As soon as you need additional disk space or performance, you simply add new nodes to the cluster. <br><br>  Above, I said that each of the cluster nodes is available separately.  It means that a separate network connection can be established with each node (or even several).  However, no matter what node the user connects to the cluster, he sees a single file system. <br><br>  In the data center, the scale-out storage looks like this (the cluster nodes are packed in stylish racks). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/138/4f4/010/1384f40104d140fc92d4cc7596c8242e.jpg" alt="Isilon"></div><br><br>  In our case, the system shown in the picture was used for data storage: <a href="https://www.emc.com/isilon">Isilon</a> from EMC.  It was chosen because of its almost unlimited scalability: one cluster can provide up to 30 petabytes of disk space.  And from the outside all the space will be available as a single file system. <br><br>  The problem that we had to solve was related to the specific model of using Isilon.  In an environment that we optimize, data is accessed through a data management system.  I will not go into details here, because  This is a separate big topic.  I'll tell you only about the consequences of this approach.  Moreover, I will significantly simplify the overall picture in order to concentrate only on those things that are most essential for the future. <br><br>  A simplified picture of data access in our environment is as follows: <br><br><img src="https://habrastorage.org/files/522/819/728/522819728598481081c898a7529be1c6.jpg" alt="image"><br><br>  Multiple clients access a data management system that runs on a dedicated server.  Clients do not write / read data from Isilone directly.  This is done only through a control system that can potentially perform some kind of manipulation on the data: for example, encrypt. <br><br>  In the diagram, the management system server communicates with only one storage system node (DSS).  And this is what we really had.  The flow of numerous client requests went to a single storage node.  It turns out that the load on the cluster could be very unbalanced in the case when the other nodes were not loaded by other servers or clients. <br><br>  Isilon, generally speaking, provides excellent opportunities for automatic load balancing.  For example, if a server tries to establish a connection with Isilon, then it will be serviced by the node that is least loaded at the moment.  Of course, in order for such balancing to become possible, it is necessary to configure and use Isylon accordingly. <br><br>  However, automatic load balancing on storage is possible only at the network connection level.  For example, if a large number of ‚Äúvoracious‚Äù compounds accumulate on some cluster node, the storage system will be able to ‚Äúscatter‚Äù them over more free nodes.  But in the case of a single loaded connection, the storage system is powerless. <br><br>  Now a few words about what constitutes the only high-loaded connection that we had to unload.  This is just an NFS mount.  If you are not familiar with NFS, look under the spoiler. <br><div class="spoiler">  <b class="spoiler_title">Nfs</b> <div class="spoiler_text">  In Unix, there is the concept of a virtual file system.  This is such a generic interface for accessing information.  Through it, you can already access specific file systems.  In fact, the file systems of various devices are simply embedded in the local file system and look to the user as part of it.  At the lower level, the floppy file system or remote file systems can be used, which can be accessed via the network.  One example of such a remote file system is NFS. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/ce4/99d/bd6/ce499dbd620b462aa2b105e978fb8937.jpg" alt="Nfs"></div><br></div></div><br>  Now that the problem is clear, it's time to tell how we solved it. <br><br>  As I said, we were helped by a piece of hardware and a software solution designed for working with big data.  The iron is all the same Isilon.  And we were very lucky that two and a half years ago one interesting property was added to it.  Without it, dealing with load balancing would be much more difficult.  The property in question is HDFS protocol support.  It is based on the second ingredient of our recipe. <br><br>  If you are not familiar with this abbreviation and the technical side of the question, we recommend you as a spoiler. <br><div class="spoiler">  <b class="spoiler_title">HDFS</b> <div class="spoiler_text">  HDFS is a distributed file system that is part of Hadoop, a platform for developing and executing distributed programs.  Hadoop is now widely used for big data analytics. <br><br>  A classic computing solution based on Hadoop is a cluster consisting of compute nodes and data nodes.  Computing nodes perform distributed computing by loading / storing information from data nodes.  Both types of nodes are, rather, the logical components of a cluster, rather than physical.  For example, one compute node and several data nodes can be deployed on one physical server.  Although the most typical is the situation when two nodes are running on the same physical machine, one of each type. <br><br>  Communication of computational nodes with data nodes takes place exactly according to the HDFS protocol.  The intermediary in this communication is the directory of the file system HDFS, which is represented in the cluster by a node of another type - the name node.  If we discard irrelevant reservations, we can assume that there is only one directory node in the cluster. <br><br>  Data nodes store data blocks.  In the same directory, among other things, information is stored about how the blocks relating to specific files are distributed across data nodes. <br><br>  The process of placing a file in HDFS on the client‚Äôs side looks something like this: <br><ul><li>  HDFS client requests a directory to create a file. </li><li>  if everything is fine, the directory signals that the file has been created </li><li>  when the client is ready to write the next block of this file, he again addresses the directory with a request to provide the address of the data node to which the block should be sent </li><li>  directory returns the corresponding address </li><li>  client sends block to this address </li><li>  successful entry is confirmed </li><li>  when the client has sent all the blocks, he can request to close the file </li></ul><br></div></div><br>  Initially, the HDFS interface was not supported in Isilone so that my colleagues and I could use it to balance the load on the storage system.  If you're wondering what purpose HDFS is implemented in Isilon, then go to the next spoiler. <br><div class="spoiler">  <b class="spoiler_title">Native HDFS support</b> <div class="spoiler_text">  In Isilone, the HDFS interface was supported so that the storage system can be used directly with Hadoop.  What did it lead to?  See diagrams below.  The first shows one of the typical scenarios for organizing an Hadoop cluster (not all kinds of nodes that exist in a cluster are depicted) <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/096/03d/d33/09603dd339d343f1a5943600643cac2b.jpg" alt="Classic Hadoop usage"></div><br><br>  Worker node is a server that combines the functions of computing and data storage.  Data node is a server that only stores data.  Next to all the servers are depicted "thick" drives, which host data that are running HDFS. <br><br>  Why does the image show storage?  It is a grocery data store.  It stores the files that go into the product environment when performing daily business operations.  Usually these files are transferred to the storage system using some widely accepted protocol.  For example, NFS.  If we want to analyze them, then we need to copy the files (do the staging) into the Hadupovsky cluster.  If we are talking about many terabytes, then staging can take many hours. <br><br>  The second picture shows what changes if an environment with HDFS support is used in the environment.  At servers big disks disappear.  In addition, servers that were engaged exclusively in providing access to data are removed from the cluster.  All disk resources are now consolidated in a single storage system.  There is no need to do staging.  Analytical calculations can now be performed directly on product copies of files. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6a2/8ac/a4b/6a28aca4b39a405ba741ee689218cd8d.jpg" alt="Native HDFS support by Storage System"></div><br><br>  Data can still be stored in the storage system using the NFS protocol.  And read via HDFS.  If, for some reason, calculations cannot be performed on product copies of files, then the data can be copied inside the same storage system.  I will not list all the delights of this approach.  There are many of them, and much has already been written about them in English-language blogs and news feeds. <br><br>  Better, I will say a few words about how working with the Isfilonovsky HDFS interface looks from the client.  Each of the cluster nodes can act as a HDFS data node (if not prohibited by settings).  But what is more interesting and what is not in the "real" HDFS, each node can also perform the role of a directory (name node).  At the same time, it must be borne in mind that Isilonov's HDFS, from the point of view of "entrails", has almost nothing in common with the Hadupov implementation of HDFS.  The file system HDFS in Isilon is duplicated only at the interface level.  The whole internal kitchen is original and very efficient.  For example, to protect data, they use their own cost-effective and fast Isonian technologies, as opposed to copying a chain of data nodes, which is implemented in the "standard" HDFS. <br></div></div><br>  Now let's see how HDFS helped us cope with load balancing on Isylon.  Let's return to the example of writing a file to HDFS that was parsed above in the spoiler.  What do we have in the case of Isilon? <br><br>  To add another block to the file, the client must refer to the directory in order to find out the address of the data node that will receive this block.  In Isilone, <i><b>any</b></i> cluster node can be accessed as a directory.  This is done either directly through the node address, or through a special service that balances the connections.  The address that the directory returns corresponds to the least loaded node at the moment.  It turns out that sending blocks to HDFS, you always transfer them to the most free nodes.  Those.  you automatically have a very fine, granular balancing: at the level of individual elementary operations, and not mount, as is the case with NFS. <br><br>  Noticing this, we decided to use HDFS as a standalone interface.  ‚ÄúIndependent‚Äù here means that the interface is activated in isolation from Hadoop.  Perhaps this is the first example of this kind.  At least, so far I have not heard that HDFS is used separately from the family of Hadup or okolokhadupovsky products. <br><br>  As a result, we ‚Äúscrewed‚Äù HDFS to our data management system.  Most of the problems that we had to solve at the same time were on the side of the management system itself.  I will not talk about them here, because  This is a separate large topic, tied to the same on the specifics of a particular system.  But I‚Äôll tell you about two minor issues that are associated with using HDFS as a standalone file system. <br><br>  The first problem is that HDFS is not allocated to a separate product.  It is distributed as part of Hadoop.  Therefore, there is no ‚ÄúHDFS standard‚Äù or ‚ÄúHDFS specification‚Äù.  In fact, HDFS exists as a reference implementation from Apache.  So if you want to know the details of the implementation (for example, what is the policy of capturing and releasing leases), then you will have to do reverse engineering, or reading the source code, or searching for people who have already done this before you. <br><br>  The second problem is finding a low-level library for HDFS. <br><br>  After a superficial web search, it may seem that there are many such libraries.  In reality, however, there is one Apache Java reference library.  Most other libraries for C ++, C, Python, and other languages ‚Äã‚Äãare just wrappers around the Java library. <br><br>  We could not take a Java library for our C ++ project.  Even with the appropriate wrapper.  First of all, dragging the data management system along with our small HDFS module onto the server was also an impermissible luxury.  Secondly, on the Internet there are some complaints about the performance of the Java-library. <br><br>  The situation was such that if we had not found a ready-made C ++ library for HDFS, we would have to write our own.  And this is extra time for reverse engineering.  Fortunately, we found a library. <br><br>  Last year (and maybe even earlier) the first native-libraries for HDFS began to appear.  At the moment, I know about two of them: for C and Python.  <a href="https://github.com/cemeyer/hadoofus">Hadoofus</a> and <a href="https://labs.spotify.com/2013/05/07/snakebite/">Snakebite</a> .  Perhaps something else has appeared.  I have not repeated the search for a long time. <br><br>  For our project we took Hadoofus.  For all the time of use, we found only two errors in it.  The first - simple - led to the fact that the library was not going to C + + - compiler.  The second is more unpleasant: deadlock with multi-threaded use.  He manifested itself very rarely, which complicated the analysis of the problem.  To date, both errors are fixed.  Although we are still working on the full testing of deadlock absence. <br><br>  We did not have to solve any other problems associated with the use of HDFS. <br><br>  In general, it should be noted that writing an HDFS client for Isilon is simpler than writing a client for ‚Äústandard‚Äù HDFS.  Undoubtedly, any ‚Äústandard‚Äù HDFS client will work seamlessly with Isilon.  The reverse does not have to be true.  If you are writing an HDFS client exclusively for Isilon, the task is simplified. <br><br>  Consider an example.  Suppose you need to read a block of data from HDFS.  To do this, the client accesses the directory and asks which data nodes to take this block from.  In general, in response to such a request, the catalog returns the coordinates of not one node, but several, on which copies of this block are stored.  If the client fails to receive a response from the first node in the list (for example, this node has fallen), then he will turn to the second, third, etc., until there is a node that will respond. <br><br>  In the case of Isilon, you do not need to think about such scenarios.  Ishilon always returns the address of a single node that will serve you.  This does not mean that the Isilon nodes cannot ‚Äúfall.‚Äù  In the end, you can disable the node at least with an ax.  However, if Isilon, for some reason, loses a node, he simply transfers his address to another - surviving - node in the cluster.  So, the fault tolerance scenario is largely already embedded in the piece of hardware, and you do not need to fully implement it in the software. <br><br>  On this story of our "recipe" can be considered complete.  It remains only to add a few words about the results. <br><br>  The depreciated performance gain, compared to working through NFS, is about 25% in our environment.  This figure was obtained by comparing "with themselves": in both cases, the performance was measured on the same hardware and the same software.  The only thing that differed was the module for accessing the file system. <br><br>  If we consider only read operations, then a 25% gain is also observed when downloading each individual file.  In the case of recording data, you can only talk about the amortized gain.  Writing each individual file is slower than through NFS.  There are two reasons for this: <br><ul><li>  HDFS does not support multi-threaded file writing. </li><li>  Our data management system has features that, due to the above HDFS limitation, do not allow organizing a quick recording of a separate file. </li></ul><br>  If the files were organized in a data management system more optimally, a 25% gain in writing could be expected for a separate transfer. <br><br>  I note that slowing the download of each specific file did not upset us greatly, because  for us the most significant throughput at peak loads.  In addition, in environments similar to ours, reading data is a much more frequent operation than writing. <br><br>  In conclusion, I will give an illustration that gives an idea of ‚Äã‚Äãhow Isilon‚Äôs workload changes when using HDFS as an interface. <br><br>  The screenshot shows the cluster load when transferring a 2GB file to both sides (the file was downloaded and downloaded 14 times in a row).  The blue high peak on the left is obtained when working via NFS.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Reading and writing occur through one mount, and in this case one cluster node takes over the entire load. </font><font style="vertical-align: inherit;">The multi-colored low peaks on the right correspond to HDFS operation. </font><font style="vertical-align: inherit;">It can be seen that now the load is ‚Äúsmeared‚Äù across all nodes in the cluster (3 pieces).</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cd5/056/693/cd50566938474853a9c249ef94b89db3.jpg" alt="Isilon workload"></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On this, perhaps, everything. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let everything always work for you quickly and reliably!</font></font></div><p>Source: <a href="https://habr.com/ru/post/247669/">https://habr.com/ru/post/247669/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../247659/index.html">Visual Studio + Roslyn = configurator for 1C: Enterprise</a></li>
<li><a href="../247661/index.html">Using AWS Lambda to create an archive of specific files with AWS S3</a></li>
<li><a href="../247663/index.html">We program Arduino on pure C</a></li>
<li><a href="../247665/index.html">A drone based on the Raspberry Pi. Part 1</a></li>
<li><a href="../247667/index.html">Guide to the Car Tutorial (Unity3d) part 1 of 3</a></li>
<li><a href="../247671/index.html">How to create a robotic startup: a textbook for the entrepreneur</a></li>
<li><a href="../247673/index.html">FAT32 media emulation on stm32f4</a></li>
<li><a href="../247677/index.html">Calculate the average temperature at the hospital</a></li>
<li><a href="../247679/index.html">Qmpot - programmable sound editor</a></li>
<li><a href="../247681/index.html">Introduction to Distributed Switch Architecture: Network Management Technology as a Single Device</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>