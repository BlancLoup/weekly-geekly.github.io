<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Lesson 5.3 - Shadow Maps</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Shadow is the absence of light. If the rays from the light source do not fall on the object, as they are absorbed by another object, then the first ob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Lesson 5.3 - Shadow Maps</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/20f/e6a/5f3/20fe6a5f38cfacad9ea8355ca097e8f4.png" width="200" align="left"><br><p>  Shadow is the absence of light.  If the rays from the light source do not fall on the object, as they are absorbed by another object, then the first object is in the shade.  Shadows add realism to the image and let you see the relative position of objects.  Thanks to him, the scene gets "depth."  Compare the following scene images with and without shadows: </p><br><p><img src="https://habrastorage.org/webt/g6/dj/qh/g6djqh4wgzwvwxsw90mqzeqbhty.png" alt="with_shadows_and_without"></p><br><p>  As you can see, the shadows make it much more obvious how objects are located relative to each other.  Thanks to the shadows you can see that one of the cubes hangs in the air. </p><br><p>  Shadows are difficult to implement, especially because the realtime algorithm for perfect shadows has not yet been invented.  There are several good ways to approximate shadows, but they all have their own characteristics that need to be taken into account. </p><br><p>  One of the methods, <em>shadow maps,</em> is relatively simple to implement, is used in most video games and gives decent results.  Shadow maps are not so difficult to understand, they are quite cheap in terms of performance and easy to upgrade to more advanced algorithms (such as shadows from a <a href="https://learnopengl.com/">point source of light</a> or cascading shadow maps) </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text"><p>  Part 1. Start <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br><p>  Part 2. Basic lighting <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br><p>  Part 3. Loading 3D Models 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    </p><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br><p>  Part 4. OpenGL advanced features <br><br></p><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li><li>  <a href="https://habrahabr.ru/post/350156/">Advanced GLSL</a> </li><li>  <a href="https://habrahabr.ru/post/350782/">Geometric shader</a> </li><li>  <a href="https://habrahabr.ru/post/352962/">Instancing</a> </li><li>  <a href="https://habrahabr.ru/post/351706/">Smoothing</a> </li></ol><br><p>  Part 5. Advanced Lighting </p><br><ol><li>  <a href="https://habrahabr.ru/post/353054/">Advanced lighting.</a>  <a href="https://habrahabr.ru/post/353054/">Model Blinna-Phong.</a> </li><li>  <a href="https://habrahabr.ru/post/353632/">Gamma Correction</a> </li><li>  <a href="https://habrahabr.ru/post/353956/">Shadow maps</a> </li></ol></div></div><br><p>  <em>(Translator's note - in the future, some Russian versions of the terms will be duplicated by the well-established English version. If you know them - there will be no misconceptions, you do not know - memorize together with the original term, there are a lot of good articles on the Internet in English and quite a few in Russian)</em> </p><br><br><h2 id="karty-teney">  Shadow maps </h2><br><p>  The idea behind the shadow map is quite simple: we draw the scene from the point of view of the light source.  Everything that we see is lit, the rest is in the shade.  Imagine a piece of floor with a large cube between it and the light source.  Since the light source "sees" a cube, rather than a piece of floor, this part of the floor will be shaded. </p><br><p><img src="https://habrastorage.org/webt/w4/5l/sw/w45lsweo1_acepaehuxre-iwnem.png" alt="shadow_mapping_theory"></p><br><p>  In the picture above, blue lines draw surfaces that the light source can see.  Closed surfaces are painted black - they will be painted shaded.  If you draw a line (ray) from a light source at the top of the rightmost cube, it will first cross the cube hanging in the air.  Because of this, the left surface of the hanging cube is lit, unlike the cube on the right. </p><br><p>  We want to find the point of the very first intersection of the ray with the surface and compare it with the other intersections.  If the point of intersection of the ray with the surface does not coincide with the nearest intersection, then it is in the shadow.  The repetition of such an operation for thousands of different rays from the source will be extremely inefficient and not suitable for drawing in each frame of the game. </p><br><p>  Perhaps you have already read about the depth test: <a href="https://habrahabr.ru/post/342610">the Habr√© translation</a> , the <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing">original</a> .  The value in the depth buffer is the fragment depth from the camera point of view, limited to values ‚Äã‚Äãfrom 0 to 1. What if we render the scene from the point of view of the light source and store the depth values ‚Äã‚Äãin the texture?  In this way, we get the smallest depth values ‚Äã‚Äãthat can be seen from the point of view of the light source.  In addition, the depth values ‚Äã‚Äãshow the surface closest to the light source.  Such a texture is called a depth map <em>(depth map)</em> or a <em>shadow map (shadow map)</em> . </p><br><p><img src="https://habrastorage.org/webt/qx/r9/wi/qxr9wics8cquqas0snsimyvnf6s.png" alt="shadow_mapping_theory_spaces"></p><br><p>  The left picture shows a directional light source (all rays are parallel), casting a shadow on the surface below the cube.  Using the depth values ‚Äã‚Äãstored in the texture, we find the surface closest to the source and with its help we determine what is in the shadow.  We create a depth map by rendering the scene as the view and projection matrices using the matrices corresponding to our light source. </p><br><blockquote>  Directional light with parallel rays has no position and is, as it were, "infinitely far."  However, in order to create a shadow map, we will have to draw a scene from a position in the direction of light. </blockquote><p>  <em>Note</em>  <em>translator - openGL cuts off surfaces that are too far away (z&gt; 1) or too close (z &lt;0 or z &lt;-1 depending on the settings)).</em>  <em>The camera matrix is ‚Äã‚Äãchosen so that the z coordinate for objects on the scene is in this interval, otherwise we will not see them.</em>  <em>From a mathematical point of view, there is no position, but in reality the position of the camera can be considered a point that when drawn is displayed at the closest point in the center of the screen</em> </p><br><p> In the picture on the right, we see the same light, the cube and the observer.  We draw a fragment of the surface at point <code>P</code> , and we need to determine if it is in the shadow.  To do this, we translate <code>P</code> into the coordinate space of the light source <code>T(P)</code> .  Since the point <code>P</code> not visible from the point of view of light, its <code>z</code> coordinate in our example will be <code>0.9</code> .  According to the coordinates of point <code>x,</code> we can look at the depth map and find out that the point closest to the light source is <code></code> with a depth of 0.4. This value is smaller than for point <code>P</code> , therefore point <code>P</code> is in the shade. </p><br><p>  Drawing shadows consists of two passes: first we draw a depth map, in the second pass we draw the world as usual, using the depth map to determine which parts of the surface are in the shadow.  This may seem complicated, but when we go through everything step by step, everything will become clear. </p><br><h2 id="karta-glubiny">  Depth map </h2><br><p>  In the first pass, we will generate a depth map.  A depth map is a texture with depth values, rendered from the point of view of the light source.  We will then use it to calculate the shadows.  To save the rendered result to the texture, we need a frame buffer <em>(framebuffer)</em> : <a href="https://habrahabr.ru/post/347354/">Habre translation</a> , the <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">original</a> . </p><br><p>  First, create a frame buffer to draw a depth map: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depthMapFBO; glGenFramebuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthMapFBO);</code> </pre> <br><p>  After we create a 2D texture to use as a depth buffer for the frame buffer. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SHADOW_WIDTH = <span class="hljs-number"><span class="hljs-number">1024</span></span>, SHADOW_HEIGHT = <span class="hljs-number"><span class="hljs-number">1024</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> depthMap; glGenTextures(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;depthMap); glBindTexture(GL_TEXTURE_2D, depthMap); glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEPTH_COMPONENT, SHADOW_WIDTH, SHADOW_HEIGHT, <span class="hljs-number"><span class="hljs-number">0</span></span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</code> </pre> <br><p>  Creating a depth map does not look complicated.  Since we are only interested in the depth values ‚Äã‚Äã(and not the colors <code>r,g,b,a</code> ), we specify the texture format <code>GL_DEPTH_COMPONENT</code> .  Set the height and width of the texture 1024 * 1024 - this will be the size of the depth map. </p><br><p>  Now we attach the depth texture to the frame buffer as the depth buffer. </p><br><pre> <code class="hljs lisp">glBindFramebuffer(<span class="hljs-name"><span class="hljs-name">GL_FRAMEBUFFER</span></span>, depthMapFBO)<span class="hljs-comment"><span class="hljs-comment">; glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, 0); glDrawBuffer(GL_NONE); glReadBuffer(GL_NONE); glBindFramebuffer(GL_FRAMEBUFFER, 0);</span></span></code> </pre> <br><p>  When we draw the scene from the point of view of the light source, we are only interested in the depth, the color buffer is not needed.  The frame buffer will be incomplete without the color buffer, so we must explicitly indicate that we are not going to render the color.  To do this, we set <code>GL_NONE</code> for <code>glDrawBuffer</code> and <code>glReadBuffer</code> . </p><br><p>  Now we have a properly configured framebuffer, which writes the depth values ‚Äã‚Äãto the texture, and we can render the depth map.  The full implementation for both rendering passes looks like this: </p><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">// 1.     glViewport(0, 0, SHADOW_WIDTH, SHADOW_HEIGHT); glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO); glClear(GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); RenderScene(); // 2.       (  ) glBindFramebuffer(GL_FRAMEBUFFER, 0); glViewport(0, 0, SCR_WIDTH, SCR_HEIGHT); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); ConfigureShaderAndMatrices(); glBindTexture(GL_TEXTURE_2D, depthMap); RenderScene();</span></span></code> </pre> <br><p>  This code does not contain some details, but it gives the general idea of ‚Äã‚Äãshadow maps.  Focusing on <code>glViewport</code> calls: usually the size of the depth map is different from the size of the screen (or the texture into which the final image is rendered).  If you forget to change it, only a square piece with a screen size will be updated to the depth texture or (if the texture is smaller) some of the information on it will not be displayed (it will remain outside the edges). </p><br><h2 id="prostranstvo-istochnika-sveta">  Light source space </h2><br><p>  The only thing that is unknown in the code above is what does the <code>ConfigureShaderAndMatrices()</code> function do? <br>  In the second pass, it works as usual - it sets the appropriate view and projection matrices for the camera and the model matrix for the objects.  However, in the first pass we use other matrices for projection and appearance: for drawing the scene from the point of view of the light source. </p><br><p>  We simulate a directional light source, so all rays of light are parallel.  For this reason, we will use the orthographic projection matrix for the light source (there are no perespect distortions in it). </p><br><pre> <code class="hljs go">float near_plane = <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, far_plane = <span class="hljs-number"><span class="hljs-number">7.5f</span></span>; glm::mat4 lightProjection = glm::ortho(<span class="hljs-number"><span class="hljs-number">-10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-10.0f</span></span>, <span class="hljs-number"><span class="hljs-number">10.0f</span></span>, near_plane, far_plane);</code> </pre> <br><p>  This is an example of the orthographic projection matrix used in the demo for this article.  Since the projection matrix determines the distance at which you will see objects (i.e., the video card will not cut off as too close or far), you should make sure that the size of the clipping region contains all the objects you want to display in the depth map. </p><br><p>  To create a view matrix in which all objects will be visible from the point of view of the light source, we will use the unpopular function <code>glm::lookAt</code> , now the light source ‚Äúlooks‚Äù to the center of the scene. </p><br><pre> <code class="hljs go">glm::mat4 lightView = glm::lookAt(glm::vec3(<span class="hljs-number"><span class="hljs-number">-2.0f</span></span>, <span class="hljs-number"><span class="hljs-number">4.0f</span></span>, <span class="hljs-number"><span class="hljs-number">-1.0f</span></span>), glm::vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>), glm::vec3( <span class="hljs-number"><span class="hljs-number">0.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>));</code> </pre> <br><p>  <em>(Approx. Lane - the first vector is the location of the camera, the second is where it looks, the third is the direction of looking up)</em> </p><br><p>  The combination of these two matrices gives us a transformation matrix from the coordinates of the world to the coordinates in which the light source "sees" the world.  This is exactly what we need for rendering a depth map. </p><br><pre> <code class="hljs ruby">glm::mat4 lightSpaceMatrix = lightProjection * lightView;</code> </pre> <br><p>  The <code>lightSpaceMatrix</code> matrix is ‚Äã‚Äãexactly what we designated above as <code>T</code>  With this matrix, we can average the scene as usual, using it instead of the view and projection matrixes of a conventional camera.  However, we are only interested in the depth values, and we want to maintain performance without making unnecessary calculations for unused color.  Therefore, we will write the simplest possible shader for drawing only the depth map. </p><br><h2 id="rendering-v-kartu-glubiny">  Rendering to a depth map </h2><br><p>  When we render a scene for a light source, we only need the coordinates of the vertices and nothing else.  For such a simple shader (let's call it <code>simpleDepthShader</code> ), we write a vertex shader: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 aPos; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 lightSpaceMatrix; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 model; void main() { gl_Position = lightSpaceMatrix * model * vec4(aPos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  For each model, this shader maps the vertices of the model into the light source space using <code>lightSpaceMatrix</code> . <br>  Since we do not have a color buffer in the frame buffer for shadows, the fragment shader does not require any calculations, and we can leave it empty: </p><br><pre> <code class="hljs 1c"><span class="hljs-meta"><span class="hljs-meta">#version 330 core void main() { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// gl_FragDepth = gl_FragCoord.z; }</span></span></span></span></code> </pre> <br><p>  An empty fragmentary shader does nothing, and at the end of the shader we will get an updated depth buffer.  We can uncomment this line of code, the actual depth will be calculated in any case. </p><br><p>  Drawing to the depth buffer turns into the following code: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">simpleDepthShader</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.use</span></span>(); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glUniformMatrix4fv</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">lightSpaceMatrixLocation</span></span>, 1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">GL_FALSE</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">glm</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">::value_ptr(lightSpaceMatrix))</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">glViewport</span></span>(0, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">SHADOW_WIDTH</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">SHADOW_HEIGHT</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glBindFramebuffer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL_FRAMEBUFFER</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">depthMapFBO</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glClear</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL_DEPTH_BUFFER_BIT</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">RenderScene</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">simpleDepthShader</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">glBindFramebuffer</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">GL_FRAMEBUFFER</span></span>, 0);</code> </pre> <br><p>  The <code>RenderScene</code> function accepts a shader, calls the functions needed to draw, and instances the matrix of the model if necessary. </p><br><p>  As a result, we have a filled depth buffer, for each pixel containing the depth of the nearest fragment from the point of view of light.  You can project this texture onto a screen-sized rectangle and display it.  (similar to what was in the post-processing in the example with frame buffer. <a href="https://habrahabr.ru/post/347354/">Habr√© translation</a> , <a href="https://learnopengl.com/Advanced-OpenGL/Framebuffers">original</a> .) </p><br><p><img src="https://habrastorage.org/webt/b3/ph/ai/b3phait29ohw_sfkglefyl5_y40.png" alt="shadow_mapping_depth_map"></p><br><p>  To draw a depth map on a rectangle, use the following shader: </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core out vec4 FragColor; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 TexCoords; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D depthMap; void main() { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depthValue = texture(depthMap, TexCoords).r; FragColor = vec4(vec3(depthValue), <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  If, when rendering the shadow, the projection matrix is ‚Äã‚Äãperspective, not orthogonal, then the depth will vary nonlinearly.  At the end of the article we will discuss this difference. </p><br><p>  The source code for rendering the scene to a depth map can be seen <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/5.advanced_lighting/3.1.1.shadow_mapping_depth/shadow_mapping_depth.cpp">here</a> . </p><br><h3 id="risovanie-teney">  Drawing shadows </h3><br><p>  With the help of a properly made depth map, we can draw shadows.  We check if the fragment is in the shadow with a fragment shader, but we are converting it to the light source space in the vertex shader. </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 aPos; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec3 aNormal; <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> (location = <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 aTexCoords; out VS_OUT { vec3 FragPos; vec3 Normal; vec2 TexCoords; vec4 FragPosLightSpace; } vs_out; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 projection; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 view; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 model; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> mat4 lightSpaceMatrix; void main() { vs_out.FragPos = vec3(model * vec4(aPos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>)); vs_out.Normal = transpose(inverse(mat3(model))) * aNormal; vs_out.TexCoords = aTexCoords; vs_out.FragPosLightSpace = lightSpaceMatrix * vec4(vs_out.FragPos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_Position = projection * view * model * vec4(aPos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br><p>  From the new here - an additional vector <code>FragPosLightSpace</code> at the output of the vertex shader.  We accept the same <code>lightSpaceMatrix</code> that was used in the first pass for drawing depth, and with its help we translate the vector into the space of the light source.  The vertex shader transmits the vertices both in the current camera space ( <code>vs_out.FragPos</code> ) and in the light source space ( <code>vs_out.FragPosLightSpace</code> ) to the fragment simultaneously. </p><br><p>  We will use a fragment shader based on the Blinna-Phong light model.  In the fragment shader we will find the value of <code>shadow</code> - it will be equal to 1.0 if the fragment is in the shadow and 0.0 for the lit.  The resulting <code>diffuse</code> and <code>specular</code> colors (diffuse and specular lighting) will be multiplied by <code>(1.0 - shadow)</code> .  Shadows are rarely completely black due to indirect lighting, so background lighting will be present regardless of the shadow. </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core out vec4 FragColor; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> VS_OUT { vec3 FragPos; vec3 Normal; vec2 TexCoords; vec4 FragPosLightSpace; } fs_in; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D diffuseTexture; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D shadowMap; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec3 lightPos; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> vec3 viewPos; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ShadowCalculation(vec4 fragPosLightSpace) { [...] } void main() { vec3 <span class="hljs-keyword"><span class="hljs-keyword">color</span></span> = texture(diffuseTexture, fs_in.TexCoords).rgb; vec3 normal = <span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>(fs_in.Normal); vec3 lightColor = vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ambient vec3 ambient = 0.15 * color; // diffuse vec3 lightDir = normalize(lightPos - fs_in.FragPos); float diff = max(dot(lightDir, normal), 0.0); vec3 diffuse = diff * lightColor; // specular vec3 viewDir = normalize(viewPos - fs_in.FragPos); float spec = 0.0; vec3 halfwayDir = normalize(lightDir + viewDir); spec = pow(max(dot(normal, halfwayDir), 0.0), 64.0); vec3 specular = spec * lightColor; // calculate shadow float shadow = ShadowCalculation(fs_in.FragPosLightSpace); vec3 lighting = (ambient + (1.0 - shadow) * (diffuse + specular)) * color; FragColor = vec4(lighting, 1.0); }</span></span></code> </pre> <br><p>  This is mostly a copy of the shader, which we used in the example with lighting: <a href="https://habrahabr.ru/post/353054/">Habre</a> , <a href="https://learnopengl.com/Advanced-Lighting/Advanced-Lighting">advanced lighting</a> . </p><br><p>  Only the shadow calculation is added here.  The main part of the work is done by the <code>ShadowCalculation</code> function.  At the end of the fragment shader, we multiply the contribution from the diffuse and specular reflection of light by (1.0 - shadow) - that is, depending on how strongly the fragment is not obscured.  In addition, this input shader additionally assumes the position of the fragment in the light source space and the texture with depth values ‚Äã‚Äã(which was rendered in the first pass). </p><br><p>  To check whether the fragment is in the shadow, let us position the position in the space of the light source to the normalized coordinates.  When we return the vertex position in <code>gl_Position</code> in the vertex shader, openGL automatically divides <code>x,y,z</code> by <code>w</code> so that the perspective works correctly.  Since <code>FragPosLightSpace</code> not transmitted as <code>gl_Position</code> , we will have to do this division ourselves. </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShadowCalculation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vec4 fragPosLightSpace</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// perform perspective divide vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w; [...] }</span></span></code> </pre> <br><p>  Get the position of the fragment in the light source space. </p><br><blockquote>  When using orthographic projection, the coordinate <code>w=1.0</code> does not change and division by w becomes unnecessary.  But division is necessary when using a perspective projection, and our code will work correctly for both cases. </blockquote><p>  <em>(Note of the lane - the division by w must be done exactly in the fragment shader. In <a href="https://habrahabr.ru/post/249467/">this article,</a> the first picture shows the difference between the linear and perspective interpolation for texture coordinates.)</em> </p><br><p>  Texture coordinates are in the interval [0,1], and the coordinates of visible fragments during rendering take values ‚Äã‚Äãin [-1,1].  We give them to the interval [0,1]: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">projCoords</span></span> = projCoords * <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span> + <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">5</span></span>;</code> </pre> <br><p>  According to these coordinates, we can see the depth value in the texture - this will be the depth of the object closest to the light source. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> closestDepth = texture(shadowMap, projCoords.xy).r;</code> </pre> <br><p>  To get the depth of the current fragment, we simply take its z coordinate in the light source space. </p><br><p>  `` `with <br>  float currentDepth = projCoords.z; </p><br><pre> <code class="hljs perl">    <span class="hljs-string"><span class="hljs-string">``</span></span><span class="hljs-string"><span class="hljs-string">`currentDepth`</span></span><span class="hljs-string"><span class="hljs-string">``</span></span>  <span class="hljs-string"><span class="hljs-string">``</span></span><span class="hljs-string"><span class="hljs-string">`closestDepth`</span></span><span class="hljs-string"><span class="hljs-string">``</span></span>  ,         . <span class="hljs-string"><span class="hljs-string">``</span></span><span class="hljs-string"><span class="hljs-string">`c float shadow = currentDepth &gt; closestDepth ? 1.0 : 0.0;</span></span></code> </pre> <br><p>  The entire code of the ShadowCalculation function is as follows: </p><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">float</span></span> ShadowCalculation(vec4 fragPosLightSpace) { // <span class="hljs-keyword"><span class="hljs-keyword">perform</span></span> perspective divide vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w; // <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>] range projCoords = projCoords * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>; // <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> closest depth <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> light<span class="hljs-string"><span class="hljs-string">'s perspective (using [0,1] range fragPosLight as coords) float closestDepth = texture(shadowMap, projCoords.xy).r; // get depth of current fragment from light'</span></span>s perspective <span class="hljs-type"><span class="hljs-type">float</span></span> currentDepth = projCoords.z; // <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> whether <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> frag pos <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> shadow <span class="hljs-type"><span class="hljs-type">float</span></span> shadow = currentDepth &gt; closestDepth ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shadow; }</code> </pre> <br><p>  Using this shader together with textures and regular view and projection matrices for the second pass of the render will give the result approximately as in the picture: </p><br><p><img src="https://habrastorage.org/webt/du/rw/bw/durwbwuxnbndkwb7xt6huf4zwvu.png" alt="shadow_mapping_shadows"></p><br><p>  If you did everything correctly, you will see shadows on the floor and dice (however, with some artifacts).  <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/5.advanced_lighting/3.1.2.shadow_mapping_base/shadow_mapping_base.cpp">Source code demo</a> . </p><br><h2 id="uluchshaem-karty-teney">  Improving shadow maps </h2><br><p>  We were able to achieve work for shadow maps, but you can see some artifacts in the image.  The following text is devoted to their correction. </p><br><h2 id="muarovyy-uzor">  Moire pattern </h2><br><p>  Obviously there is something wrong in the image below.  The larger image resembles a <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D1%2583%25D0%25B0%25D1%2580%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D1%2583%25D0%25B7%25D0%25BE%25D1%2580">moire pattern</a> . </p><br><p><img src="https://habrastorage.org/webt/yn/sn/zr/ynsnzrizcsu2rohjtjv1p5-sjc8.png" alt="shadow_mapping_acne"></p><br><p>  The entire floor is covered with clearly visible alternating black stripes.  This effect can be explained with one karinka: </p><br><p><img src="https://habrastorage.org/webt/ec/8x/db/ec8xdb1qco2p32gzpaz_u43ldm0.png" alt="shadow_mapping_acne_diagram"></p><br><p>  <em>(Note. Trans. - to describe the effect, the author uses the term " <strong>shadow acne</strong> ". I could not find an established translation. I could translate this as "shadow points", but I still can‚Äôt find anything on the Russian-language Internet.)</em> </p><br><p>  Since the shadow map has a limited resolution (in the example above, we used a texture of <code>1024*1024</code> ), several pixels on the final image can get the same value from the depth map.  The picture above shows the floor on which each slanting piece (from bottom to left up to right) is one texel from the depth map.  <em>(texel - texture pixel)</em> </p><br><p>  In general, this is normal, but it can be a problem if the light falls at an angle to the surface, as in the example above.  Some fragments that receive depth from a texture get a value greater or less, which does not correspond to the real depth of the floor for this fragment.  Because of this, some fragments are considered shaded - and we see stripes. </p><br><p>  We can solve this problem with a small hack ‚Äî a shift in depth values ‚Äã‚Äãby a small amount <em>(shadow bias)</em> so that all the fragments are above the surface. </p><br><p><img src="https://habrastorage.org/webt/xa/ps/6p/xaps6pwdf7hq3n4gpyfy1hqo-wk.png" alt="shadow_mapping_acne_bias"></p><br><p>  <em>(Approx. Lane - I have a strong feeling that the pictures are not drawn correctly. In order for the fragment not to be obscured, the zigzag lines describing the values ‚Äã‚Äãfrom the depth map must be below the surface)</em> </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bias = <span class="hljs-number"><span class="hljs-number">0.005</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = currentDepth - bias &gt; closestDepth ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>;</code> </pre> <br><p>  A shift of 0.005 for our scene as a whole solves the problem, but some surfaces that the light falls on at a very small angle will still have stripes of shadow.  A more serious approach would be to change the shift depending on the angle at which the light falls on the surface.  We use the scalar product. </p><br><pre> <code class="hljs mel"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> bias = <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>(<span class="hljs-number"><span class="hljs-number">0.05</span></span> * (<span class="hljs-number"><span class="hljs-number">1.0</span></span> - <span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>(normal, lightDir)), <span class="hljs-number"><span class="hljs-number">0.005</span></span>);</code> </pre> <br><p>  Thus, floor-like surfaces that are almost perpendicular to the rays of light will have a very small shift.  The greater the angle between the normal and the direction of the light, the greater the shift.  The following picture shows the same scene, but using the shift: it looks clearly better. </p><br><p><img src="https://habrastorage.org/webt/vu/lb/-v/vulb-vneforpolylyzwzgoxck0u.png" alt="shadow_mapping_with_bias"></p><br><p>  The selection of the correct values ‚Äã‚Äãfor the shift requires their selection, since they may differ for each scene, but this is usually done by simply increasing the shift until the artifacts disappear. </p><br><h2 id="effekt-pitera-pena">  Peter Pan Effect </h2><br><p>  <em>(Piter Panning)</em> </p><br><p>  The disadvantage of using shear for depth is that we apply it to the actual depth of the object.  As a result, this shift can become large enough so that there is a noticeable distance between the object and the shadow, which it casts as in the picture below (with an exaggeratedly large offset): </p><br><p><img src="https://habrastorage.org/webt/h4/va/fw/h4vafw-mnqarfdyt0eauhtd-dlu.png" alt="shadow_mapping_peter_panning"></p><br><p>  This is called the Peter Pan effect, since the shadow runs a little away from its object.  We can use a little trick to solve most problems: use clipping of front-oriented polygons when drawing a depth map.  Read about the facet <a href="https://habrahabr.ru/post/346964/">on the Habr√©</a> , the <a href="https://learnopengl.com/Advanced-OpenGL/Face-Culling">original</a> . <br>  By default, openGL cuts back oriented polygons.  We can switch openGL to do the opposite. </p><br><p>  In the first rendering pass, we need only the depth values, and it does not matter to us what depth to take - from the front or back surface.  We will not notice the wrong results, since it doesn‚Äôt matter to us whether there are shadows inside the object - they are still not visible. </p><br><p><img src="https://habrastorage.org/webt/cd/h7/5b/cdh75bc16u7vsd6rfutggtyy0t0.png" alt="shadow_mapping_culling"></p><br><p>  To remove the effect of Peter Pan, we cut off the frontal edges on the first pass.  Note that you need to enable <code>GL_CULL_FACE</code> . </p><br><pre> <code class="hljs lisp">glCullFace(<span class="hljs-name"><span class="hljs-name">GL_FRONT</span></span>)<span class="hljs-comment"><span class="hljs-comment">; RenderSceneToDepthMap(); glCullFace(GL_BACK); //    </span></span></code> </pre> <br><p>  This solves the problem with the Peter Pen effect, but only for objects that have a surface on all sides.  In our example, this works perfectly for cubes, but will not work for the floor, since cutting off the frontal polygons will completely remove the floor.  If you are going to use this method, use cutting off fronted oriented polygons only where it makes sense. </p><br><p>  <em>(Note of the lane - specifically in this example, there is nothing to worry about cutting off the floor completely, as there are no objects below it, and it does not matter if there is a shadow under it or not.)</em> </p><br><p>  If objects are too close to the shaded surface, the result may look wrong.  Use frontal clipping only for objects for which it makes sense.  However, using well-chosen values ‚Äã‚Äãfor the shift, you can completely avoid the Peter Pen effect. </p><br><p>  Another visible flaw that you might like or not is that some surfaces outside the scope of the light source can be painted shaded, even if theoretically the light should fall on them.  This is due to the fact that for a remote point in the reference system of the light source, the coordinates will be greater than 1.0, and the texture coordinates will only vary from 0.0 to 1.0.  If the surface is too far away from the light source, then there is no value for it in the depth map. </p><br><p><img src="https://habrastorage.org/webt/nx/41/ik/nx41ikwanl4ve74fbpsxlb1vjf4.png" alt="shadow_mapping_outside_frustum"></p><br><p>  In the image above you can imagine a region of light - everything else is in the shadow.  The lighted area shows how the depth map is projected onto the floor.  The reason for this behavior is that earlier we set the <code>GL_REPEAT</code> mode for the depth texture. </p><br><p>        1.0 ‚Äî  ,        (          ).            "GL_CLAMP_TO_BORDER" </p><br><pre> <code class="hljs go">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER); float borderColor[] = { <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span> }; glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);</code> </pre> <br><p> ,            [0,1],       1.0,     <code>shadow</code>    0.0.    : </p><br><p><img src="https://habrastorage.org/webt/fo/mv/ep/fomvepqjexjo2g4eyu1xcy_vpts.png" alt="shadow_mapping_clamp_edge"></p><br><p> ,        .  ,         .   ,          . </p><br><p>     <code>z</code>      ,  1.0,     <code>GL_CLAMP_TO_BORDER</code>   .     (  1.0)      (       1.0) ‚Äî      . </p><br><p>      ‚Äî      ,   z   . </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShadowCalculation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">vec4 fragPosLightSpace</span></span></span><span class="hljs-function">)</span></span> { [...] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(projCoords.z &gt; <span class="hljs-number"><span class="hljs-number">1.0</span></span>) shadow = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> shadow; }</code> </pre> <br><p>           1.0         . </p><br><p><img src="https://habrastorage.org/webt/_i/y4/iu/_iy4iugoqtpxwffowmz0n8hnoq8.png" alt="shadow_mapping_over_sampling_fixed"></p><br><p>     ,      ,           ,      .         ,      ,   . </p><br><h2 id="pcf"> PCF </h2><br><p> <strong>Percentage-closer filtering</strong> </p><br><p>        ,      ,   .      ,        . </p><br><p><img src="https://habrastorage.org/webt/rv/dp/nh/rvdpnhhvftx5igcjugmfnk63xf8.png" alt="shadow_mapping_zoom.png"></p><br><p>     ,                  .      . </p><br><p>      ,           . </p><br><p>   ()       ‚Äî PCF (Percentage-closer filtering),    ,     .    ,        ‚Äî     .     ,     .         . </p><br><p>   PCF ‚Äî          : </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> shadow = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; vec2 texelSize = <span class="hljs-number"><span class="hljs-number">1.0</span></span> / textureSize(shadowMap, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">-1</span></span>; x &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; ++x) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">-1</span></span>; y &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; ++y) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pcfDepth = texture(shadowMap, projCoords.xy + vec2(x, y) * texelSize).r; shadow += currentDepth - bias &gt; pcfDepth ? <span class="hljs-number"><span class="hljs-number">1.0</span></span> : <span class="hljs-number"><span class="hljs-number">0.0</span></span>; } } shadow /= <span class="hljs-number"><span class="hljs-number">9.0</span></span>;</code> </pre> <br><p>  <code>textureSize</code> ‚Äî    ,     . ,    ,     .      ,      .      9     <code>(x,y)</code> ,           ,   . </p><br><p>     /  <code>texelSize</code> ,      .       PCF : </p><br><p><img src="https://habrastorage.org/webt/qv/fz/ug/qvfzugpouvtj78r05knskbqxqg8.png" alt="shadow_mapping_soft_shadows"></p><br><p>     .     ,   ,      (, 9    ).  , PCF      . </p><br><p> <a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/5.advanced_lighting/3.1.3.shadow_mapping/shadow_mapping.cpp">  </a> </p><br><p>   ,      PCF,        .       ,     . </p><br><h2 id="perspektivnaya-proekciya-vs-ortograficheskaya">   vs  </h2><br><p>             .        ,     ,     .     .           . </p><br><p><img src="https://habrastorage.org/webt/xd/ne/pp/xdneppp6yo6c3sbqhl30w0ktlwk.png" alt="shadow_mapping_projection"><br>         (     ).         ,   ‚Äî   . </p><br><p>       ‚Äî         .   ,      ,         .       ,    ,        .       : <a href="https://habrahabr.ru/post/342610/"></a> , <a href="https://learnopengl.com/Advanced-OpenGL/Depth-testing"></a> . </p><br><pre> <code class="hljs mel">#version <span class="hljs-number"><span class="hljs-number">330</span></span> core out vec4 FragColor; <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vec2 TexCoords; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> sampler2D depthMap; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> near_plane; <span class="hljs-keyword"><span class="hljs-keyword">uniform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> far_plane; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> LinearizeDepth(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> depth) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> z = depth * <span class="hljs-number"><span class="hljs-number">2.0</span></span> - <span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Back to NDC return (2.0 * near_plane * far_plane) / (far_plane + near_plane - z * (far_plane - near_plane)); } void main() { float depthValue = texture(depthMap, TexCoords).r; FragColor = vec4(vec3(LinearizeDepth(depthValue) / far_plane), 1.0); // perspective // FragColor = vec4(vec3(depthValue), 1.0); // orthographic }</span></span></code> </pre> <br><p>     ,   ,      .  ,      .               ,     . </p><br><h2 id="dopolnitelnye-resursy">  : </h2><br><ul><li> <a href="http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-16-shadow-mapping/">tutorial-16-shadow-mapping</a> ‚Äî      . </li><li> <a href="http://ogldev.atspace.co.uk/www/tutorial23/tutorial23.html">Shadow mapping ‚Äî Part 1</a> :     ogldev </li><li> <a href="https://www.youtube.com/watch%3Fv%3DEsccgeUpdsM">How shadow mapping works:</a> ‚Äî   3        </li><li> <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ee416324%2528v%3Dvs.85%2529.aspx">Common Techniques to Improve Shadow Depth Maps</a> :    Microsoft,        . </li></ul><br><p> <a href="https://learnopengl.com/Advanced-Lighting/Shadows/Shadow-Mapping"> </a> </p></div><p>Source: <a href="https://habr.com/ru/post/353956/">https://habr.com/ru/post/353956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353946/index.html">Character kotlin</a></li>
<li><a href="../353948/index.html">Hijacking Telegram on Panic Waves</a></li>
<li><a href="../353950/index.html">Experiments on cats: how to increase the number of purchases in the application</a></li>
<li><a href="../353952/index.html">Issue # 19: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../353954/index.html">Experience using Megaplan API</a></li>
<li><a href="../353958/index.html">Compare Draft, Gitkube, Helm, Ksonnet, Metaparticle and Skaffold</a></li>
<li><a href="../353960/index.html">Money & Design. How to earn more than 200.000 ‚ÇΩ if you work alone</a></li>
<li><a href="../353962/index.html">Automate UI testing on PhoneGap. Payment application case</a></li>
<li><a href="../353966/index.html">New standards for passwordless authentication: how they work</a></li>
<li><a href="../353968/index.html">Why doesn‚Äôt the extension of a security staff result in increased security, and what to do</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>