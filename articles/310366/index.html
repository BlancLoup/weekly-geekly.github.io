<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we made even load balancing on the frontend cluster</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Yuri Nasretdinov ( youROCK , Badoo ) 


 Deciphering the report of Yuri Nasretdinov at the HighLoad ++ 2015 conference. Yuri will tell you about how B...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we made even load balancing on the frontend cluster</h1><div class="post__text post__text-html js-mediator-article"><h2>  Yuri Nasretdinov ( <a href="https://habrahabr.ru/users/yourock/" class="user_link">youROCK</a> , <a href="https://habrahabr.ru/company/badoo/">Badoo</a> ) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/68f/7df/cac/68f7dfcac4017e85de2eb1fb8216b7c4.jpg" alt="Yuri Nasretdinov"><br><br><blockquote>  Deciphering the report of Yuri Nasretdinov at the HighLoad ++ 2015 conference. Yuri will tell you about how Badoo (the largest social network for meeting new people) made an almost perfectly smooth load balancing on our cluster.  Give him the word ... </blockquote><br>  To serve the number of users, the number of requests per second that we receive, we have about three thousand servers, and PHP-FPM specifically accounts for 70 thousand at the peak. <br><br>  About how we distribute these requests across our cluster, I will tell. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/51c/282/aed/51c282aedef943c04d7e3582074bc206.png"><br><br>  Briefly - about what I will tell.  First of all, I will tell you how ‚Äúfrom a bird's eye view‚Äù the routing of requests on our site is arranged.  Then I will tell you what, in general, there are algorithms for balancing;  about how we did the balancing before we made the automatic system.  I'll tell you about this automatic system, well, there will be some conclusions.  I also wanted to say that this system will be posted in open-source after this report. <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/150099278" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Let's start with architecture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/75b/b73/415/75bb734159baa363c407e3d5cb08f6f5.png"><br><br>  This slide shows the path that the query passes when you type <a href="http://badoo.com/">badoo.com</a> and, accordingly, get on our website.  To begin with, since we have more than one data center, there is a system from the company ‚ÄúF5‚Äù, which is called ‚ÄúGlobal Traffic Manager‚Äù.  It is able for different continents to resolve DNS queries to the corresponding data center.  Then, when the IP address has already been received, the traffic arrives at the Local Traffic Manager system of the same company.  It's just a ‚Äúpiece of hardware‚Äù that can take on all the traffic and distribute it according to the rules that you set, distribute it to different clusters.  And we have two types of traffic - this is mobile traffic and traffic on websites.  For mobile traffic, we still have a separate proxy that accepts connections from mobile clients and holds them.  It is not shown on the slide, but it is he who communicates with Nginx, which in turn distributes requests for PHP-FPM.  For a website, LTM can balance such requests directly. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c1e/366/daa/c1e366daa7b8599f3f73faeec5e94d24.png"><br><br>  Thus, all this is served by either PHP-FPM, or in the case of the web, this is Nginx + PHP-FPM. <br><br>  Why, in general, need balancing and what is it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a25/b99/0e3/a25b990e3a91c63aa8169df4e1563559.png"><br><br>  If the number of requests you have on the site is more than one server can handle, then, in principle, you need load balancing in order to distribute traffic across multiple servers.  And also, in principle, quite obvious, but it is still worth noting that the more evenly distributed the load is on those servers that are in the backend, the less servers you need to maintain traffic peaks, and the better is User Experience, because As a rule, the response time depends on the server load, and the higher, the smaller the server is loaded. <br><br>  What, in general, are the algorithms? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/25d/54f/5ad/25d54f5ad2f1d5ba4bce8a72fc589064.png"><br><br>  I consider frequently used algorithms that are used to balance web traffic.  I divided them into four categories. <br><br>  The first type of balancing I classified as "stupid." <br><br><img src="https://habrastorage.org/getpro/habr/post_images/582/74a/239/58274a2390efc6444932ca12c75930f8.png"><br><br>  The simplest balancing algorithm is not to balance the load at all, i.e.  Your load is perfectly supported by one server, and you transfer the entire load to this server. <br><br>  Further, a very simple algorithm is Sticky sessions, when requests from the same IP address or from the same client go to the same server.  This is an easy-to-implement algorithm and, in principle, it has a lot of advantages, especially if your application is not in PHP.  But he also has a lot of pitfalls, which I wouldn‚Äôt like to talk about now, this is a topic for a separate report. <br><br>  And, of course, there is a very simple way of balancing - this is a random choice of server.  He, in principle, works well, especially if you do not have a lot of servers and simple requests.  But there may be bursts of loading on some specific servers due to the fact that you choose them randomly, and 10 requests may come to the same server, and the second server will not get anything. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc2/9b7/690/bc29b769022455bb068d1c17f156555e.png"><br><br>  And, more commonly, this is the Round-robin algorithm.  This algorithm is more complex than random balancing, but has the most important advantage in comparison with it - it is the load uniformity, i.e.  if you have the same server and you have the same requests, then you will get a perfectly even balancing with this algorithm.  Those.  this algorithm is that you send each next request to the next server, and thus it is easy enough to show that the load will be uniform, there will be no bursts. <br><br>  But life is a bit more complicated and in practice such an algorithm is used, but with some modification. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c08/29e/92d/c0829e92d102013e4a4638459faeeea0.png"><br><br>  We also use it, this is a weighted Round-robin, when servers are not the same, and you have to somehow make it so that more requests fall on those servers that are more powerful and can hold a large load.  This can be implemented in different ways, for example, repeating the same server several times in a regular Round-robin.  Thus, the greater the weight of the machine, the more repetitions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d3b/03e/098/d3b03e0987e802bcfd9e1f5352872fcd.png"><br><br>  A group of algorithms, which, roughly speaking, I referred to the category of "smart", which somehow must monitor the state of the system and balance the load, based on this.  For example, a very common algorithm that is used a lot where - Least Connections, when your balancer sends the following requests to the server with which the least connections are established.  This also allows you to achieve a uniform load, because it is assumed that while the connection is open, the requester is processed. <br><br>  Since the servers are not identical, there is a modification of this algorithm, which takes into account the weights - Weighted Least Connections. <br><br>  Weighted Round-robin assumes static weights for servers that are set once and do not change after that.  But strictly speaking, you can change them over time.  And this is what I will discuss next. <br><br>  There are some other algorithms that can also be mentioned. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d3/09f/3a6/3d309f3a6eb6c3017cb676be9dcd2025.png"><br><br>  How did we distribute the load before we wrote the automatic system?  This was done by administrators' hands - roughly speaking, the system administrator comes, adds 10, 20, some servers to our cluster and ‚Äúsee‚Äù what weight to assign to him based on processor frequency, number of cores, memory timings, etc.  He edits a config that looks like this in Nginx: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ac5/b26/afe/ac5b26afe083ce53ff31c09d0aa6d285.png"><br><br>  It can be understood that here it is quite difficult to see something and even more difficult to do something so that the download is smooth.  Here is a load chart for several months on different servers: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2ba/0a5/0e3/2ba0a50e30c36992bb27374772c4678c.png"><br><br>  For different servers, CPU usage is shown in different colors.  You can see that the lines of different colors are strictly above each other.  Those.  the load is stable, but it differs quite significantly from different servers.  It differs somewhere by 20-30%. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4b/b5e/610/c4bb5e610538f0b263a048e0ac0c7bdd.png"><br><br>  You probably ask: why admins could not tat weight with their hands?  In fact, there are a lot of reasons.  The main reason is that a very large amount of time passes between making changes and getting some result.  Those.  You can align each line separately, but you will need to do 200 iterations and the update should not be done too often, for example, we do it no more than once every 15 minutes.  In general, this is a very big effort and manual work that I would not like to do.  Therefore, we decided to do it differently. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/632/a82/11c/632a8211cf0d65d85181f8c3b2bcea65.png"><br><br>  When traffic began to grow on our website, especially on a mobile cluster, we decided to do automatic balancing, which allowed, in addition to load balancing, to have fewer servers in order to serve traffic at the peak, and not to run into 100% of the processor, and and it is desirable to keep the load less than 75% (conditionally). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d87/e73/b7a/d87e73b7a21b1fed2dfa82f0f08cc8d8.png"><br><br>  I, again, highlighted two main approaches to the selection of weights for the balancer: <br><br><ol><li>  This is the calculation of some kind of performance index and the task of static weight servers; </li><li>  And the opposite of the first - based on the state of the system, evaluate which weights should be given, and, accordingly, give out weights in the process of work, watching how it behaves. </li></ol><br><img src="https://habrastorage.org/getpro/habr/post_images/0bc/3fd/8f7/0bc3fd8f7b6f2747794f70d5ff4966f8.png"><br><br>  On these two graphs, I tried to portray the problems with the first approach.  The left graph shows the daily performance of the machine, i.e.  we wrote a script that runs a certain number of cycles of our application and measures how many were per unit of time (per second), and it runs on one core.  You can see that the performance per se, at least for one core, depends on the load on the system, and this is very strange.  For example, on AMD processors you will not see this, but we use Intel processors, which include hyper-threading.  The slides are not very well seen, but the performance drawdown starts somewhere after 50%, while the server continues to serve the increasing load and does it quite successfully, and in our case, hyper-threading works very well, we leave it turned on.  Those.  I wanted to say that to give out one weight is actually quite problematic, because the performance of the machine changes with time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/17b/26b/363/17b26b363647f6e585fdcf5101849ed7.png"><br><br>  And do not forget about the fact that many use virtual machines, which have the concept of performance is a very floating quantity, i.e.  It is not very clear what weight to take. <br><br>  Unfortunately, this approach, despite the fact that it is very reliable (that is, there is nothing to break, nothing to break down), it did not work very well in our conditions.  And, actually, this algorithm is no different from the manual selection of weights, which admins should do.  Therefore, after many iterations, we have come up with the following algorithm. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c4a/a3f/9f4/c4aa3f9f4fde08a789d6d92a0e7e93aa.png"><br><br>  Assume that the processor load depends linearly on the weight, which, in principle, should be performed in most cases.  Those.  your application starts proportionately more ‚Äúis‚Äù processor, the more requests per second it receives, if it is able to process them.  And then we get a very simple formula - we multiply the current weight by the ratio of the average load across the cluster by the average load of the machine.  It turns out a very simple linear formula.  Thus, we try to bring such a signal into the system that would bring it to a steady state, i.e.  reduced the difference.  It is clear that when there is no difference, the coefficient will be one, and the weights will not change. <br><br>  Let me remind you how the graph looked like (albeit 3-month, we, unfortunately, do not have more accurate data to give daily charts) before we implemented this system: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d2/f2b/f15/0d2f2bf152facf1a722a1b4b2317ea74.png"><br><br>  And this is how the graph began to look after: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/1bc/c0c/9471bcc0c43a8c270646cdac12c13ba4.png"><br><br>  This is a daily schedule. <br><br>  You can see that, with the exception of a couple of servers, the load on which is more like a sine than something else, almost all servers (and there are about 200 of them) have merged into one line.  In principle, this was observed gradually - as soon as we switched on this system, it began to converge in a very thin gap, and the difference between the most loaded and most unloaded server is very difficult to see on the graph. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b67/3a3/ddf/b673a3ddfabd412c707e76d80d2078c8.png"><br><br>  This approach, in fact, has a lot of problems, i.e.  Despite the fact that it gives good results, it would be strange to finish the report on this and not tell you what is ‚Äúwrong‚Äù with this system. <br><br>  First, it is clear that since you adjust the weight dynamically, you can accidentally set the weight on the machine such that the machine does not cope with the load, and it will be turned off from the cluster.  If there are any problems in this algorithm, then you can cut down the cluster, despite the fact that it is able to handle the load. <br><br>  Then, there is an interesting problem - the fact that this algorithm is quite problematic to embed Nginx itself into LTM, i.e.  probably, in Nginx it is possible, and LTM is just a closed ‚Äúpiece of hardware‚Äù, which can be used to communicate new weights in some external way. <br><br>  And there is such a problem - these weights can, in principle, not be applied, i.e.  you give the system some new weights, but it continues to work with the old ones, you continue to apply your formula, but nothing happens. <br><br>  Then a separate problem - how to remove cars?  It is, in principle, not directly related to even balancing, it‚Äôs just a problem that cannot be solved here. <br><br>  Also, LTM has restrictions on a maximum weight of 100, and perhaps this also has some problems. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/87e/e74/cae/87ee74cae4eed31df6713332de8116de.png"><br><br>  First, how to make something more stable from such a very simple formula that is not subject to overloads, i.e.  If your server had a 50% load 15 minutes ago, you gave it twice the load, then this most likely means that it has 100% load, but not the fact that it will serve all requests correctly at that. <br><br>  The idea is very simple: do not change the weight too much per unit of time.  In our case, we get a more or less flat line of server load, if we build one point in 15 minutes.  Those.  Weights should be updated no more than in 15 minutes in our conditions, otherwise there are very large temporary errors due to uneven user load.  Accordingly, we impose restrictions on the coefficient by which we multiply the weight.  This, again, is chosen empirically - we add no more than 5% to the weight each time, and since this is an integer, it means that the minimum weight should be 20, i.e.  5% of it is one.  And also, to avoid situations where the cluster is not loaded, for example, servers temporarily make mistakes in requests or some other problems, do not drop the load from those servers that are able to service something that is too fast ... <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8be/1f4/483/8be1f4483910f1c8ec07483dae7b1360.png"><br><br>  What to do if your feedback is broken, i.e.  weights do not apply?  It's pretty easy to understand that the formula I give will increase the difference between the processor load the more, the more time has passed.  The point is that if the weights do not apply, you will see a difference, which is not there, and you will further and further increase the load on weak servers and, on the contrary, not enough load on the strong ones.  This is not what is needed. <br><br>  In our case, we solved the problems by the fact that we put restrictions on the minimum weight, which falls on one core of the machine, and on the maximum.  Those.  we believe that the difference between the cores ‚Äî the most powerful machine and the weakest ‚Äî will be no more than three times.  It seems that this is quite logical, i.e.  Why keep servers that are three times different in performance?  And so we limit the problems that will arise in case of violation of feedback.  Those.  This does not solve the problem, but if you have, for example, less than 30% load, then this approach will work. <br><br>  Also on the total weight and on the number of cores - simply because they should not be too large. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d25/86e/0ff/d2586e0ff5b92f8f8c186e09e4d64bc2.png"><br><br>  Another question: what to do if you need to remove a machine from a cluster, i.e.  the machine no longer responds to requests, but this is possible in two cases - if the machine is overloaded, i.e.  there are too many requests for it, and the second problem is that the car really ‚Äúdied‚Äù.  The fact is that when you reach the peak of traffic, and if you suddenly at this moment have any problems on the cluster, then most likely they will be on all servers.  And simply, because the servers do not respond by heartbeat, you should not delete the server, because  You can cascade off the entire cluster in this way. <br><br>  In our case, we decided to use just the information that we have about the CPU load at the peak.  We are looking to see if the system will cope if this server is removed from the balancer and if it can handle the traffic peak load.  If not, then we leave the server.  In principle, this logic should be enough so that you do not have problems with processor overload. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ff/cb2/df0/4ffcb2df0b83e948ca19deb5a5ff240f.png"><br><br>  And finally, briefly about what I wanted to say. <br><br>  For web requests, weighted round-robin works very well.  At least for our requests, i.e.  when your requests are more or less the same, you don‚Äôt need to invent anything else, it works. <br><br>  Again, in our case, to pick up the weights statically, you need to put a lot of effort, and this approach does not always work well.  I did not give the figures, how much the spread actually amounted to after we did everything.  This is 2.5%.  For two hundred servers, I think this is a very good figure, i.e.  the difference between the maximum and minimum load is very small. <br><br>  We also solved the problem that admins have to edit configs manually.  And due to the number of servers that we have in order to serve at the peak of traffic, we now need about 50 servers less, which seems to be quite significant. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d1/c9c/bb8/6d1c9cbb80467dc4ac042371c51babce.png"><br><br>  This balancer will be posted on the address on the slide. <br><br>  We also have a very large number of other projects that you may have heard about.  These are PHP-FPM, Pinba and Blitz.  There are many small ones that you may not have heard about - for example, our code formatter, analytics tools on the client called Jinba.  A tool for running a lot of parallel through SSH called GoSSHa (written in the Go language, respectively).  And various other things, for example, a library for Android, which allows you to avoid memory leaks. <br><br><h3>  Contacts </h3><br>  <a href="">y.nasretdinov@corp.badoo.com</a> <br>  <a href="https://habrahabr.ru/users/yourock/" class="user_link">youROCK</a> <br>  <a href="https://habrahabr.ru/company/badoo/">Badoo company blog</a> <br><br><blockquote>  <font color="gray">This report is a transcript of one of the best speeches at the conference of developers of high-loaded <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad ++</a> systems.</font>  <font color="gray">Now we are actively preparing for the conference in 2016 - this year HighLoad ++ will be held in Skolkovo on November 7 and 8.</font> <font color="gray"><br><br></font>  <font color="gray">This year, Yuri will also speak at HighLoad ++ with the report " <a href="http://www.highload.ru/2016/abstracts/2264.html">5 ways of PHP code deployment in highload conditions</a> ".</font>  <font color="gray">In this report, he will talk about how Badoo has been deployed for 10 years, what new system for PHP code deployment has been developed and implemented in production, and will review solutions for large-scale PHP code deployment and <strong>analysis of their performance</strong> .</font> <font color="gray"><br><br></font>  <font color="gray">Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.</font>  <font color="gray">Already, in our textbook more than 30 unique materials.</font>  <font color="gray">Get connected!</font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/310366/">https://habr.com/ru/post/310366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../310354/index.html">The art of design opponents in the game Zelda: A Link to the Past</a></li>
<li><a href="../310356/index.html">The path of electricity in the data center</a></li>
<li><a href="../310358/index.html">Who, where and why they go: trends in mobile design 2016</a></li>
<li><a href="../310360/index.html">Screen Space Ambient Occlusion</a></li>
<li><a href="../310362/index.html">Simultaneous translation: how it works</a></li>
<li><a href="../310368/index.html">Jigsaw project in Java 9. A modular future that cannot be avoided</a></li>
<li><a href="../310370/index.html">TEST Labs 2016. Online conference for testers. September 24</a></li>
<li><a href="../310372/index.html">Examples of real patches in PostgreSQL: part 2 of N</a></li>
<li><a href="../310376/index.html">Review of the tasks of the final round of the RCC 2016</a></li>
<li><a href="../310378/index.html">Monetization OpenStack. From private cloud to ready-made business in 72 hours</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>