<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>IEnumerable interface in C # and LSP</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is a continuation of the C # article : read-only and LSP collections . Today, we look at the IEnumerable interface in terms of Barbara Li...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>IEnumerable interface in C # and LSP</h1><div class="post__text post__text-html js-mediator-article">  This article is a continuation of the <a href="http://habrahabr.ru/post/256605/">C #</a> article <a href="http://habrahabr.ru/post/256605/">: read-only and LSP collections</a> .  Today, we look at the IEnumerable interface in terms of <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8_%25D0%2591%25D0%25B0%25D1%2580%25D0%25B1%25D0%25B0%25D1%2580%25D1%258B_%25D0%259B%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B2">Barbara Liskov‚Äôs</a> (LSP) <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8_%25D0%2591%25D0%25B0%25D1%2580%25D0%25B1%25D0%25B0%25D1%2580%25D1%258B_%25D0%259B%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B2">substitution principle</a> , and we‚Äôll see if this principle is violated by the code implementing IEnumerable. <br><a name="habracut"></a><br><h2>  LSP and IEnumerable interface </h2><br>  To answer the question of whether the successor classes of the IEnumerable LSP violate the principle, let's see how this principle can be violated. <br><br>  We can claim that the LSP is broken if one of the following conditions is met: <br><ul><li>  A subclass of a class (or, in our case, an interface) does not preserve the parent invariants. </li><li>  The subclass weakens the parent's postconditions. </li><li>  The subclass enhances the preconditions of the parent. </li></ul><br>  The problem with the IEnumerable interface is that its preconditions and postconditions are not marked explicitly and are often interpreted incorrectly.  The official contracts for the IEnumerable and IEnumerator interfaces <a href="">do not</a> <a href="">really</a> help us in this.  Even more, the different implementations of the IEnumerable interface often contradict each other. <br><br><h2>  Implementing an IEnumerable Interface </h2><br>  Before we dive into the implementation, let's take a look at the interface itself.  Here is the code for the interfaces IEnumerable &lt;T&gt;, IEnumerator &lt;T&gt; and IEnumerator.  The IEnumerable interface is almost the same as IEnumerable &lt;T&gt;. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> T&gt; : IEnumerable { IEnumerator&lt;T&gt; GetEnumerator(); } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface IEnumerator&lt;<span class="hljs-keyword"><span class="hljs-keyword">out</span></span> T&gt; : IDisposable, IEnumerator { T <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> interface IEnumerator { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-type"><span class="hljs-type">bool</span></span> MoveNext(); <span class="hljs-type"><span class="hljs-type">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(); }</code> </pre> <br><br>  They are pretty simple.  However, different BCL classes implement them differently.  Perhaps the most illustrative example would be implementation in the List &lt;T&gt; class. <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">List</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct Enumerator : IEnumerator&lt;T&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;T&gt; list; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int index; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T current; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.current; } } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> IEnumerator.Current { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index == <span class="hljs-number"><span class="hljs-number">0</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.index == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.list._size + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new InvalidOperationException(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Current; } } } }</code> </pre><br><br>  The Current property with type T does not require a call to MoveNext (), while the Current property with type object requires: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Test() { List&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;.Enumerator enumerator = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> List&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().GetEnumerator(); <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> = enumerator.<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>; //  <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> current2 = ((IEnumerator)enumerator).<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>; //  <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span> }</code> </pre><br>  The reset () method is also implemented in different ways.  While List &lt;T&gt; .Enumerator.Reset () faithfully translates Enumerator to the top of the list, iterators do not implement them at all, so the following code will not work: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Test() { Test2().<span class="hljs-keyword"><span class="hljs-keyword">Reset</span></span>(); //  NotSupportedException } private IEnumerator&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt; Test2() { yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  It turns out that the only thing we can be sure of when working with IEnumerable is that the IEnumerable &lt;T&gt; .GetEnumerator () method returns a non-null enumerator object.  A class implementing IEnumerable can be as an empty set: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  So and the infinite sequence of elements: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerable&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Random random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> random.Next(); } }</code> </pre><br>  And this is not a made-up example.  The <a href="https://msdn.microsoft.com/en-us/library/dd267312(v%3Dvs.110).aspx">BlockingCollection</a> class implements IEnumerator in such a way that the calling thread is blocked on the MoveNext () method until some other thread adds an item to the collection: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { BlockingCollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; collection = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BlockingCollection&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); IEnumerator&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; enumerator = collection.GetConsumingEnumerable().GetEnumerator(); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> moveNext = enumerator.MoveNext(); <span class="hljs-comment"><span class="hljs-comment">// The calling thread is blocked }</span></span></code> </pre><br>  In other words, <b>the IEnumerable interface makes no guarantees about the underlying set of elements, it does not even guarantee that this set is finite</b> .  All that he tells us is that this set can be somehow iterated. <br><br><h2>  IEnumerable and LSP </h2><br>  So, do LSPs violate IEnumerable implementation classes?  Consider the following example: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Process(IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">Order</span></span>&gt; orders) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> orders) { // <span class="hljs-keyword"><span class="hljs-keyword">Do</span></span> something } }</code> </pre><br>  In the case if the underlying type of the orders - List &lt;Orders&gt; variable, everything is in order: list items can be easily iterated.  But what if orders really are an infinite generator that creates a new object every time you call MoveNext ()? <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> OrderCollection : IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">Order</span></span>&gt; { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> IEnumerator&lt;<span class="hljs-keyword"><span class="hljs-keyword">Order</span></span>&gt; GetEnumerator() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { yield <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Order</span></span>(); } } }</code> </pre><br>  Obviously, the Process method does not work as intended.  But will this be because the OrderCollection class violates the LSP?  Not.  OrderCollection meticulously follows the IEnumerable interface contract: it provides a new object every time it is asked for it. <br><br>  The problem is that <b>the Process method expects more from an object implementing IEnumerable than this interface promises</b> .  There is no guarantee that the underlying class for the orders variable is the final collection.  As I mentioned earlier, orders can be an instance of the BlockingCollection class, which makes it useless to try to iterate over all its elements. <br><br>  To avoid problems, we can simply change the type of the input parameter to ICollection &lt;T&gt;.  Unlike IEnumerable, ICollection provides the Count property, which ensures that the underlying collection is finite. <br><br><h2>  IEnumerable and read-only collections </h2><br>  Using ICollection has its drawbacks.  ICollection allows you to change your items, which is often undesirable if you want to use the collection as a read-only collection.  Prior to .Net 4.5, the IEnumerable interface was often used for this purpose. <br><br>  While this seems like a good solution, it imposes too big restrictions on the sub-interfaces. <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTheTenthElement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; collection</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection.Skip(<span class="hljs-number"><span class="hljs-number">9</span></span>).Take(<span class="hljs-number"><span class="hljs-number">1</span></span>).SingleOrDefault(); }</code> </pre><br>  This is one of the most commonly used approaches: using LINQ to bypass IEnumerable.  Despite the fact that such code is quite simple, it has one obvious disadvantage: it iterates the collection 10 times, while the same result can be achieved by simply reversing the index. <br><br>  The solution is obviously to use IReadOnlyList: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTheTenthElement</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IReadOnlyList&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; collection</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (collection.Count &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> collection[<span class="hljs-number"><span class="hljs-number">9</span></span>]; }</code> </pre><br>  There is no reason to continue using the IEnumerable interface in places where you expect the collection to be countable (and you expect it in most cases).  The IReadOnlyCollection &lt;T&gt; and IReadOnlyList &lt;T&gt; interfaces added in .Net 4.5 make this work much easier. <br><br><h2>  Implementing IEnumerable and LSP </h2><br>  What about IEnumerable implementations that violate the LSP?  Let's take a look at an example in which the underlying IEnumerable &lt;T&gt; type is DbQuery &lt;T&gt;.  We can get it as follows: <br><br><pre> <code class="hljs pgsql">private IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">Order</span></span>&gt; FindByName(string <span class="hljs-type"><span class="hljs-type">name</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (MyContext db = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> MyContext()) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db.Orders.<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(x =&gt; x.Name == <span class="hljs-type"><span class="hljs-type">name</span></span>); } }</code> </pre><br>  There is an obvious problem in this code: the access to the database is postponed until the client code starts to iterate the resulting set.  Since  At this point, the connection to the database is closed, the call will result in an exception: <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> Process(IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">Order</span></span>&gt; orders) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">Order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> orders) // <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span>: DB <span class="hljs-keyword"><span class="hljs-keyword">connection</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> closed { } }</code> </pre><br>  Such an implementation violates the LSP, because  IEnumerable in itself has no preconditions requiring an open connection to the database.  Following this interface, you should be able to iterate over IEnumerable, regardless of whether such a connection exists.  As we can see, the DbQuery class reinforces the IEnumerable preconditions and thus violates the LSP. <br><br>  In general, this is not necessarily a sign of poor design.  Lazy computing is a fairly common approach when working with a database.  It allows you to perform several queries in one call to the database and thus increases the overall system performance.  The price here is a violation of the LSP principle. <br><br>  Link to original article: <a href="http://enterprisecraftsmanship.com/2015/01/29/ienumerable-interface-in-net-and-lsp/">IEnumerable interface in .NET and LSP</a> </div><p>Source: <a href="https://habr.com/ru/post/257667/">https://habr.com/ru/post/257667/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../257657/index.html">Game Exhibitions 2015</a></li>
<li><a href="../257659/index.html">OLED watch on arduino</a></li>
<li><a href="../257661/index.html">The digest of interesting materials for the mobile developer # 102 (on May 5-11)</a></li>
<li><a href="../257663/index.html">LFS: The Dark Side of the Force. Part 1</a></li>
<li><a href="../257665/index.html">Classic notes for the new Opera</a></li>
<li><a href="../257669/index.html">Redesign and promotion. Chicken and Egg Challenge</a></li>
<li><a href="../257671/index.html">Deploy web application with Fabric</a></li>
<li><a href="../257673/index.html">How 3CX solves security problems (part 2)</a></li>
<li><a href="../257675/index.html">Laboratory penetration testing "Test lab v.7" eyes hackers</a></li>
<li><a href="../257677/index.html">Low Blood Application Architecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>