<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Work with cab-archives via IStream</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago I needed to compress the data directly in memory, and not to use anything third-party for this - that is, use built-in capabilities. The...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Work with cab-archives via IStream</h1><div class="post__text post__text-html js-mediator-article">  Some time ago I needed to compress the data directly in memory, and not to use anything third-party for this - that is,  use built-in capabilities.  The choice fell on <i>Cabinet.dll</i> as a means for data compression and on the <i>IStream</i> interface for working with data in memory.  I didn‚Äôt find anything like this on the Internet, so I decided to share my work. <a name="habracut"></a><br><br><h2>  Introduction </h2><br>  I didn‚Äôt want to use third-party solutions, because I‚Äôd have to carry libraries with me or include source codes into the project.  Windows does not provide such a large set of data compression / decompression tools: these are <i>Cabinet.dll</i> , <i>ZipFldr.dll</i> (compressed Zip folders), and <a href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff552127">RtlCompressBuffer</a> / <a href="http://msdn.microsoft.com/en-us/library/windows/hardware/ff552191">RtlDecompressBuffer</a> .  I couldn‚Äôt find any clear documentation on compressed Zip folders, RtlCompressBuffer / RtlDecompressBuffer in Windows 7 versions inclusive only supports LZ compression, but <i>Cabinet.dll is</i> present in the system right from <a href="http://msdn.microsoft.com/en-us/library/ms974336">Windows 95</a> to the present day. <br><br>  As functions for working with files and memory, the documentation suggests using the standard C library functions or Windows API functions, such as CreateFile / CloseHandle / ReadFile / WriteFile.  Since all operations on files were performed in memory, it was decided to use <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa380034">IStream</a> for these purposes. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  A little about Cabinet.dll </h2><br>  The library is functionally divided into 2 parts: FCI (file compression interface) and FDI (file decompression interface).  You can read about it <a href="http://msdn.microsoft.com/en-us/library/bb417343">here</a> .  Both interfaces use essentially the same functions for working with files and memory, but for some reason Microsoft decided to make different prototypes for FCI and FDI.  However, nothing prevents to describe one through another.  How to do this, see below. <br><br>  To use the library, you need to connect the files <i>FCI.h</i> and / or <i>FDI.h,</i> respectively, and indicate the linker on <i>Cabinet.lib</i> .  All of these files are included with the Windows SDK. <br><br><h2>  Implementation of the compression interface </h2><br>  The simplest code that implements compression looks like this: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  : IStream* pIStreamFile ‚Äî    ,      char* szFileName ‚Äî    .   ,        */</span></span> ERF erf; CCAB ccab = {MAXINT, MAXINT}; *(IStream**)ccab.szCabPath = SHCreateMemStream(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    HFCI hFCI = FCICreate(&amp;erf, fPlaced, fAlloc, fFree, fOpen, fRead, fWrite, fClose, fSeek, fDelete, fTemp, &amp;ccab, 0); if(hFCI){ FCIAddFile(hFCI, (PSZ)pIStreamFile, szFileName, 0, fGetNext, fStatus, fInfo, tcompTYPE_MSZIP); FCIFlushFolder(hFCI, fGetNext, fStatus); FCIFlushCabinet(hFCI, 0, fGetNext, fStatus); FCIDestroy(hFCI); } /*  : (IStream*)ccab.szCabPath ‚Äî ,  cab-.     Release()   ! */</span></span></code> </pre> <br>  Those.  the code itself is pretty simple.  The whole point is the functions that are passed when creating the FCI context and further along the run.  You can read about their parameters and return values <a href="http://msdn.microsoft.com/en-us/library/ff797922">here</a> , therefore only the basic information will be indicated below.  Below is an analysis of each function. <br><br>  Here it should be added that we will have non-standard file descriptors in this regard - these are pointers to <i>IStream</i> .  Because of this feature, you need to be careful with the transfer of this "descriptor".  For example, in the <i>CCAB</i> structure <i>there</i> are 2 fields: <i>szCabPath</i> and <i>szCab</i> , and it would seem logical to pass the address to the 2nd parameter, but not.  FCI performs string concatenation (or rather, he thinks that he concatenates strings, but we know ...), so the resulting ‚Äúname‚Äù of the file will be <i>szCabPath</i> , and it will also be the descriptor. <br><br><h3>  fPlaced </h3><br>  Called every time a new file is added to the archive. <br><br><pre> <code class="cpp hljs">FNFCIFILEPLACED(fPlaced){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Return -1 means an error, the other values ‚Äã‚Äãare determined by the application.  Can be used to indicate the addition of files, for example. <br><br><h3>  fGetNext </h3><br>  Called before creating a new archive volume. <br><br><pre> <code class="cpp hljs">FNFCIGETNEXTCABINET(fGetNext){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  If successful, returns <b>TRUE</b> ; otherwise, returns <b>FALSE</b> .  Nothing remarkable. <br><br><h3>  fStatus </h3><br>  It is called at several stages of file processing: block compression, adding a compressed block and recording an archive. <br><br><pre> <code class="cpp hljs">FNFCISTATUS(fStatus){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> typeStatus == statusCabinet ? cb2 : <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  In case of an error, you must return -1, otherwise - any value (except for <i>typeStatus == statusCabinet</i> - then you must return the size of the archive, which is passed through the parameter <i>cb2</i> ). <br><br><h3>  fInfo </h3><br>  Sets file attributes. <br><br><pre> <code class="cpp hljs">FNFCIGETOPENINFO(fInfo){ *pattribs = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (INT_PTR)pszName; }</code> </pre> <br>  <i>IStream</i> does not support date attributes, and indeed file attributes, so the value at pattribs should be set to 0, otherwise you risk getting files in the archive with strange attributes (or even not getting the archive at all). <br><br>  Return -1 means an error, otherwise you need to return a handle to the open file. <br><br><h3>  fTemp </h3><br>  Creating a temporary file. <br><br><pre> <code class="cpp hljs">FNFCIGETTEMPFILE(fTemp){ *(IStream**)pszTempName = SHCreateMemStream(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  If successful, returns <b>TRUE</b> , otherwise returns <b>FALSE</b> .  The file name (pointer to <i>IStream</i> in this case) is passed through the <i>pszTempName</i> parameter. <br><br><h3>  fDelete </h3><br>  Delete the file. <br><br><pre> <code class="cpp hljs">FNFCIDELETE(fDelete){ (*(IStream**)pszFile)-&gt;Release(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Returns 0 on success; -1 on failure.  Deleting a file in this case is the release of the resources occupied by the stream, so we simply <i>release ()</i> . <br><br><h3>  fAlloc, fFree </h3><br>  Allocation / release of memory. <br><br><pre> <code class="cpp hljs">FNFCIALLOC(fAlloc){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[cb]; } FNFCIFREE(fFree){ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> memory; }</code> </pre> <br>  It's all very simple, so I even combined these functions in one section. <br><br><h3>  fOpen </h3><br>  Opening file (stream). <br><br><pre> <code class="cpp hljs">FNFCIOPEN(fOpen){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(INT_PTR*)pszFile; }</code> </pre> <br>  Since  the file name in our case is equivalent to the file descriptor, which is why we return the name as a descriptor (well, or -1, if some kind of error has occurred). <br><br><h3>  fClose </h3><br>  Close the file descriptor. <br><br><pre> <code class="cpp hljs">FNFCICLOSE(fClose){ LARGE_INTEGER li = {}; ((IStream*)hf)-&gt;Seek(li, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Returns 0 on success; -1 on failure.  Why not <i>release ()</i> ?  Because it "deletes the file", i.e.  destroys the flow, while you only need to close it.  So just reset the pointer to the beginning. <br><br><h3>  fRead, fWrite </h3><br>  Read / write data from file / to file. <br><br><pre> <code class="cpp hljs">FNFCIREAD(fRead){ ULONG ul; HRESULT hr = ((IStream*)hf)-&gt;Read(memory, cb, &amp;ul); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (hr &amp;&amp; hr != S_FALSE) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : ul; } FNFCIWRITE(fWrite){ ULONG ul; HRESULT hr = ((IStream*)hf)-&gt;Write(memory, cb, &amp;ul); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (hr &amp;&amp; hr != S_FALSE) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : ul; }</code> </pre> <br>  Returns the number of bytes read / written or -1 in case of an error (0 - end of file reached). <br><br><h3>  fSeek </h3><br>  Positioning the pointer in the file. <br><br><pre> <code class="cpp hljs">FNFCISEEK(fSeek){ LARGE_INTEGER liDist = {dist}; HRESULT hr =((IStream*)hf)-&gt;Seek(liDist, seektype, (ULARGE_INTEGER*)&amp;liDist); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hr ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : liDist.LowPart; }</code> </pre> <br>  Returns -1 on error; otherwise, a new pointer position. <br><br><h2>  Unpacking interface implementation </h2><br>  The unpacking code looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  : IStream* pIStrCab ‚Äî    */</span></span> ERF erf; HFDI hFDI = FDICreate(fAlloc, fFree, fnOpen, fnRead, fnWrite, fnClose, fnSeek, cpuUNKNOWN, &amp;erf); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(hFDI){ IStream *pIStrSrc = SHCreateMemStream(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(FDICopy(hFDI, (PSZ)&amp;pIStrCab, (PSZ)&amp;pIStrCab, <span class="hljs-number"><span class="hljs-number">0</span></span>, fnNotify, <span class="hljs-number"><span class="hljs-number">0</span></span>, &amp;pIStrSrc)){ <span class="hljs-comment"><span class="hljs-comment">//    pIStrSrc } pIStrSrc-&gt;Release(); FDIDestroy(hFDI); } pIStrCab-&gt;Release(); /*  : IStream* pIStrSrc ‚Äî     */</span></span></code> </pre> <br>  Here is not so simple.  The fact is that the extraction of <b>all</b> files from the archive is initiated by a single function <i>FDICopy</i> , which in the course of its work calls <i>fnNotify</i> , where all the magic happens.  But more on that later. <br><br>  In general, the process is similar: we create an FDI context, a stream for the output data, extract the file from the archive into this stream (in my example, it was necessary to extract a single file) and destroy the context.  <i>(PSZ) &amp; pIStrCab</i> must be specified twice, because during its operation the function concatenates both parameters, and if you omit one of them, there will be an error (yes, I also stumbled upon such a rake). <br><br>  Now a little about the functions.  In general, they are similar to FCI functions, except that they do not have 2 parameters;  memory allocation / release functions are generally identical, so it makes no sense to re-describe them.  To reduce the amount of code, you can rewrite the FCI functions through the FDI functions in order not to specify extra zero parameters. <br><br><h3>  fnOpen, fnClose </h3><br>  Open / close file (stream). <br><br><pre> <code class="cpp hljs">FNOPEN(fnOpen){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(INT_PTR*)pszFile; } FNCLOSE(fnClose){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fClose(hf, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  <i>fnOpen is</i> easier to duplicate than calling <i>fOpen</i> , and in <i>fnClose</i> the FCI <i>fClose</i> function is <i>called</i> with 2 zero last parameters, because they are not used in this implementation. <br><br><h3>  fnRead, fnWrite, fnSeek </h3><br>  Reading / writing data and positioning the pointer. <br><br><pre> <code class="cpp hljs">FNREAD(fnRead){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fRead(hf, pv, cb, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } FNWRITE(fnWrite){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fWrite(hf, pv, cb, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); } FNSEEK(fnSeek){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fSeek(hf, dist, seektype, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br>  Returned values ‚Äã‚Äãare the same as for FCI. <br><br><h3>  fnNotify </h3><br>  The most important function. <br><br><pre> <code class="cpp hljs">FNFDINOTIFY(fnNotify){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(fdint == fdintCOPY_FILE) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!lstrcmp(pfdin-&gt;psz1, <span class="hljs-string"><span class="hljs-string">"Data"</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//   ,    return (INT_PTR)*(int*)pfdin-&gt;pv; return fdint == fdintCLOSE_FILE_INFO; }</span></span></code> </pre> <br>  All information on the function can be found <a href="http://msdn.microsoft.com/en-us/library/ff797944">here</a> .  Here you need a few explanations. <br>  In most cases, the function returns 0 as an indicator of success (except <i>fdintCLOSE_FILE_INFO</i> , then return <b>TRUE</b> ).  When <i>fdint == fdintCOPY_FILE, the</i> behavior is as follows: 0 means the file is skipped, -1 is an error ( <i>FDICopy</i> completion), another value is the stream descriptor to which data should be extracted. <br><br>  Now the fun begins, because if we create threads in this function, we will not get access to them from the outside.  Therefore, there are at least 2 solutions, and both of them affect the hitherto unused and therefore inconspicuous last parameter <i>pvUser of the FDICopy</i> function.  Through it, you can transfer user data, and it is he who returns to <i>pfdin-&gt; pv</i> .  The first way is if you have a fixed list of file names that you need to extract from the archive, then you can transfer it as an array of structures containing the required file name and a pointer to <i>IStream</i> to extract to it.  The second way is when the number of files is unknown, and you need to extract them all;  In this case, through <i>pvUser,</i> you can pass the address of the container (for example, <i>std :: vector</i> ), in which the names and descriptors of the extracted files will be stored. <br><br><h2>  Afterword </h2><br>  This method is suitable for cases where the resulting data size is not particularly large - about a hundred megabytes.  Of course, in the presence of 8+ GB of memory, it is not such a big expense, but remember that the operation of re-allocating memory is not the fastest operation, which also leads to memory fragmentation, as a result of which a sudden enough continuous you will not have a memory block. <br><br>  As some alternative, you can use <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa380369">structured storage</a> (there is the same <i>IStream</i> ) or file streams created with <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb759864">SHCreateStreamOnFile</a> / <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/bb759866">SHCreateStreamOnFileEx</a> .  Thus, it is possible to combine input / output operations in memory with similar operations in files, since  The <i>iStream</i> interface can be used in both cases without any additional manipulations. <br><br>  If you have any questions about the implementation, I am ready to answer them in the comments. </div><p>Source: <a href="https://habr.com/ru/post/314832/">https://habr.com/ru/post/314832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../314820/index.html">Tricks for taking complex integrals</a></li>
<li><a href="../314822/index.html">Manage identity verification with Windows Hello for Business</a></li>
<li><a href="../314824/index.html">5 lessons of a seven-month stay in a start-up hell</a></li>
<li><a href="../314826/index.html">JetBrains Night in Moscow. Video. Kotlin as the first step to JVM</a></li>
<li><a href="../314830/index.html">How ABBYY technologies help improve data leak detection systems</a></li>
<li><a href="../314834/index.html">Go programming language - seven years</a></li>
<li><a href="../314838/index.html">Cicerone - simple navigation in Android application</a></li>
<li><a href="../314840/index.html">Symfony - upload files to MongoDB GridFS</a></li>
<li><a href="../314842/index.html">Laboratory penetration testing "Test lab v.10" - beyond the hacker capabilities</a></li>
<li><a href="../314848/index.html">How to build RidgeRun SDK</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>