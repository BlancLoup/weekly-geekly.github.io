<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The book Security in PHP (part 4). The lack of security at the transport level (HTTPS, TLS and SSL)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The book "Security in PHP" (part 1) 
 The book "Security in PHP" (part 2) 
 The book "Security in PHP" (part 3) 


 Communication over the Internet be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The book Security in PHP (part 4). The lack of security at the transport level (HTTPS, TLS and SSL)</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/t6/ms/ko/t6mskoexiw-nbrlrjfop4wdqixm.png"></p><br><p>  <a href="https://habrahabr.ru/company/mailru/blog/310726/">The book "Security in PHP" (part 1)</a> <br>  <a href="https://habrahabr.ru/company/mailru/blog/352440/">The book "Security in PHP" (part 2)</a> <br>  <a href="https://habrahabr.ru/company/mailru/blog/352442/">The book "Security in PHP" (part 3)</a> </p><br><p>  Communication over the Internet between participants in the process carries risks.  When you send a payment order to the store using an online service, you definitely do not want an attacker to intercept, read, change or re-repeat the HTTP request to the online application.  Just imagine the consequences of what the attacker considers the cookie of your session or will change the payee, product, billing address.  Or embed in markup sent by the store in response to a user request, your HTML or JavaScript. </p><a name="habracut"></a><br><p>  Protecting sensitive and personal data is a serious business.  Browser and application users have extremely high expectations regarding security.  Of particular importance are the integrity of transactions with bank cards, privacy and identification information.  Solving these problems when it comes to protecting the data transfer between two participants in the process requires security at the transport level, which usually includes HTTPS, TLS and SSL. </p><br><p>  The main objectives of protection measures: </p><br><ul><li>  Secure encryption of data sent. </li><li>  Guaranteed identification of one or both sides of information exchange. </li><li>  Protection against data corruption. </li><li>  Protection against replay attacks. </li></ul><br><p>  The most important point: for successful protection at the transport level, it is necessary to solve all four tasks.  If at least we do not succeed in something, then serious problems await us. </p><br><p>  Many people mistakenly believe that encryption is a key task, and all others are optional.  This is completely wrong.  When encrypting the transmitted data, the recipient must be able to decrypt them.  This is possible when the client and server agree on an encryption key (among other things) during the negotiation phase when the client attempts to establish a secure connection.  However, an attacker is able to penetrate between the client and the server using simple methods.  It can force the client machine to consider it a server, this is called a man-in-the-middle attack (MitM, Man-in-the-Middle).  And then the negotiations on the encryption key will be conducted not with the real server, but with a fake one.  This will allow the attacker to decrypt all the data sent by the client.  Obviously, to protect against this scenario, we need to meet the second requirement: the ability to verify the identity of the server with which the client communicates.  Without this check, we will not distinguish the target server from the dummy. </p><br><p>  So for safe communication, you must comply with all four conditions.  Each of them perfectly complements the other three, and only together they provide reliable and sustainable security at the transport level (Transport Layer Security (TLS)). </p><br><p>  In addition to the technical aspects of TLS, there is another side to quality security.  For example, if we allow the user to enter HTTP data into the application authorization form, then we must accept the possibility of a MitM attack, during which authorization data will be intercepted and later used.  Or if we allow pages that load over HTTPS to load non-HTTPS resources, we must accept that the MitM attacker has a transport with which it can conduct cross-site scripting attacks and turn the user‚Äôs browser into a pre-programmed weapon capable of act transparently through a browser-based HTTPS connection. </p><br><p>  The obvious criteria based on the four main tasks described above will help us assess the quality of any security measures: </p><br><ul><li>  Encryption: Are strong encryption standards and cipher suites used? </li><li>  Identification: Is the correctness and completeness of server identification checked? </li><li>  Data corruption: is user data fully protected during a session? </li><li>  Replay attacks: are there methods to protect against an intruder who records requests so that they can be sent to the server again and repeatedly reproduce known actions or effects? </li></ul><br><p>  These are key questions for the entire fourth part of the book.  We will go into some particular details, but everything will somehow revolve around these questions and defining vulnerabilities, when we cannot give affirmative answers. </p><br><p>  Another important point is what data should be protected.  Obviously, these are details of bank cards, personal identification information, and passwords.  What about the user session ID?  If we protect passwords, but not IDs, then an attacker can still steal transmitted cookies and perform a session hijacking attack, impersonating the user on his own computer.  Protecting authorization forms alone is NEVER enough to preserve authorization data.  The best protection is achieved if the user session is performed only within HTTPS from the moment data is entered into the form until the end of the session. </p><br><p>  Now you need to understand why the word "not enough" appeared.  The problem of implementing SSL / TLS is not only in their non-use, but also in the use of inadequate for maximum security measure. </p><br><p>  We will consider the lack of security at the transport level from three points of view: </p><br><ul><li>  Between the server application and the third-party server. </li><li>  Between the client and the server application. </li><li>  Between the client and the server application using custom security policies. </li></ul><br><p>  The first point is to confirm that our web application is safely connected to other participants in the process.  TLS is typically used for web services APIs and many other input sources necessary for the operation of the application. </p><br><p>  The second point is the interaction of users with a web application via browsers or other client applications.  In this case, we reveal a secure URL, and we need to make sure that security measures are implemented correctly so that there is no risk of circumventing them. </p><br><p>  The third point is all sorts of fancy solutions (curious oddity).  Since SSL / TLS have a reputation for incorrectly implemented standards by programmers, there are many ways to ensure a secure connection without their participation.  As an example, the use of signed requests by the OAuth protocol, which do not require SSL / TLS, but offer a number of security measures provided by those (in particular, the encryption of the request data is omitted).  So this is not an ideal solution, but it is still better than an incorrectly configured SSL / TLS library. </p><br><p>  Before we get into the details, let's first look at TLS as a whole and get some basic knowledge, and then dive into the guts of PHP. </p><br><h3 id="opredeleniya-i-bazovye-uyazvimosti">  Definitions and baseline vulnerabilities </h3><br><p>  TLS is a generic name that describes measures to create a secure connection between two participants using encryption, identity verification, etc. Most of you are already familiar with three abbreviations: HTTPS, SSL, TLS.  Let's take a quick look at them and their relationships. </p><br><h3 id="ssltls-iz-php-server-server">  SSL / TLS from PHP (server-to-server) </h3><br><p> No matter how much I love PHP as a programming language, even the most cursory overview of popular open source libraries makes it clear: they have security vulnerabilities at every step.  And the PHP community tolerates these vulnerabilities for no good reason only because it is easier to put users at risk than to solve problems.  The situation is aggravated by the fact that PHP itself suffers from a very bad implementation of SSL / TLS in PHP streams used everywhere - from HTTP clients based on sockets to <code>file_get_contents()</code> and other functions of the file system.  Add to this the fact that the authors of PHP libraries do not even try to discuss the possible security implications of SSL / TLS failures. </p><br><p>  If you do not do anything described in this chapter, then at least perform all HTTPS requests using the cURL extension for PHP.  Its default configuration provides security, and the extension relies on the expert judgment of a large number of users outside the PHP domain.  So take this simple step to improve security and you will not regret it.  The ideal solution would be if the PHP authors finally wake up and implement the Secure By Default principle in the built-in support for SSL / TLS. </p><br><p>  My introduction to SSL / TLS in PHP was very rude.  TLS vulnerabilities are much simpler than most security problems, and we all know how important this is for browsers.  But our server application is an equally important link in the security chain of user data.  So let's take a closer look at SSL / TLS in PHP, in turn, looking at PHP streams and the excellent cURL extension. </p><br><h4 id="php-potoki">  PHP streams </h4><br><p>  For those who are not familiar with streams: they are needed to generalize (generalize) files, networks, and other operations that share common functionality.  In order for a stream to know how to work with a specific protocol, ‚Äúwrappers‚Äù are used to allow the stream to represent a file, an HTTP request, a PHAR archive, data URIs (RFC 2397), etc. file function) with the corresponding URL, which denote the wrapper and the target resource. </p><br><pre> <code class="hljs lisp">file_get_contents('file<span class="hljs-symbol"><span class="hljs-symbol">:///tmp/file</span></span>.ext')<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  By default, threads use a file wrapper (File Wrapper), so usually you don‚Äôt need a URL, even a relative path to the files is sufficient.  This is obvious because most file system functions like <code>file()</code> , <code>include()</code> , <code>require_once</code> and <code>file_get_contents()</code> accept stream references.  So rewrite the previous example: </p><br><pre> <code class="hljs lisp">file_get_contents('/tmp/file.ext')<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Given the topic under discussion, you can do this: </p><br><pre> <code class="hljs lisp">file_get_contents('http<span class="hljs-symbol"><span class="hljs-symbol">://www</span></span>.example.com')<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><p>  Since file system functions ‚Äî for example, <code>file_get_contents()</code> ‚Äî support HTTP wrapped streams (HTTP wrapped streams), they form an HTTP client in PHP that is very easy to access.  You can use them if you do not feel the need to use dedicated libraries to create HTTP clients like Guzzle, Buzz, or classes from the Zend <code>\Zend\Http\Client</code> framework.  In order for your simple client to work, you need to enable the <code>allow_url_fopen</code> option in the <code>php.ini</code> .  By default, it is enabled. </p><br><p>  Of course, the inclusion of <code>allow_url_fopen</code> entails the risk of attacks with remote execution of files, bypassing access control or information disclosure.  If an attacker can, at his choice, inject a remote URI into the file function, he will easily force the application to execute, store or display the downloaded file, including from a remote unreliable source. </p><br><p>  Do not forget that the files will be uploaded from <code>localhost</code> , which means they will be able to bypass access control based on restrictions imposed on the local server.  And if the option <code>allow_url_fopen</code> enabled by default, then for the greatest security it will have to be disabled. </p><br><p>  Let's get back to using PHP streams as a simple HTTP client (and now you know that this is <strong>not recommended</strong> ).  Everything becomes more interesting if you try to do this: </p><br><pre> <code class="hljs perl">$url = <span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/1/statuses/public_timeline.json'</span></span>; $result = file_get_contents($url);</code> </pre> <br><p>  This is a simple unauthenticated request via HTTPS to (former) Twitter API 1.0.  There is a serious leak.  For requests performed using HTTPS- (https: //) and FTPS- (ftps: //) wrappers, PHP uses the <code>SSL Context</code> .  There are many settings for SSL / TLS, as well as their default values, which are completely unsafe.  We will rewrite the example to illustrate how you can insert the original set of <code>SSL Context</code> as a parameter in the <code>file_get_contents()</code> : </p><br><pre> <code class="hljs php">$url = <span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/1/statuses/public_timeline.json'</span></span>; $contextOptions = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'ssl'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>() ); $sslContext = stream_context_create($contextOptions); $result = file_get_contents($url, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, $sslContext);</code> </pre> <br><p>  As mentioned above, if you incorrectly configure SSL / TLS, then the application will be defenseless against man-in-the-middle attacks.  PHP streams by default are completely insecure when working over SSL / TLS.  So let's fix our example so that it becomes completely safe. </p><br><pre> <code class="hljs php">$url = <span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/1/statuses/public_timeline.json'</span></span>; $contextOptions = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'ssl'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-string"><span class="hljs-string">'verify_peer'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'cafile'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'/etc/ssl/certs/ca-certificates.crt'</span></span>, <span class="hljs-string"><span class="hljs-string">'verify_depth'</span></span> =&gt; <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-string"><span class="hljs-string">'CN_match'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'api.twitter.com'</span></span>, <span class="hljs-string"><span class="hljs-string">'disable_compression'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'SNI_enabled'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-string"><span class="hljs-string">'ciphers'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'ALL!EXPORT!EXPORT40!EXPORT56!aNULL!LOW!RC4'</span></span> ) ); $sslContext = stream_context_create($contextOptions); $result = file_get_contents($url, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, $sslContext);</code> </pre> <br><p>  Now everything is all right!  If you compare with the previous version, you will notice that we configured four options that were not originally configured or disabled by PHP.  Let's see what they do. </p><br><ul><li>  verify_peer </li></ul><br><p>  Peer Verification ‚Äî validates the SSL certificate provided by the host to which we sent the HTTPS request.  The correct certificate is signed with the private key of a trusted Certificate Authority (CA).  The verification can be performed using the CA public key, which is included in the file set as a <code>cafile</code> option for the SSL Context used by us.  In addition, the certificate should not be expired. </p><br><ul><li>  cafile </li></ul><br><p>  The <code>cafile</code> should point to a valid file containing the public key of the trusted CA.  In PHP, this is not done automatically, so keep the keys in a related file in a special format (usually PEM or CRT).  If you can not find a copy, then download and spars from <a href="">Mozilla VCS</a> .  Without this file, it is impossible to check the peer, and the request will not be executed. </p><br><ul><li>  verify_depth </li></ul><br><p>  This setting specifies the maximum number of intermediate certificate issuers, that is, the number of CA certificates that can be used when verifying the original client certificate. </p><br><ul><li>  CN_match </li></ul><br><p>  The three previous options relate to verifying the certificate provided by the server.  However, they do not help us understand whether the domain name or IP requested by us is valid, that is, the part of the URL associated with the host.  To find out if the certificate is bound to the current domain / IP, let's perform a host verification (Host Verification).  In PHP, you need to set the <code>CN_match</code> host value (in the SSL Context), including the subdomain, if any.  While this option is set, PHP will perform an internal check.  If you do not do this, then during the man-in-the-middle attack, an attacker can provide a valid certificate signed by a trusted CA.  But the certificate will be valid for the domain under the control of the attacker, and not for the domain to which you want to connect.  Configuring the <code>CN_match</code> option will help identify the mismatch of certificates and will result in a non- <code>CN_match</code> HTTPS request. </p><br><p>  Since a valid certificate used by an attacker will contain the attacker's identification information (this is the condition for receiving it!), Keep in mind that a savvy attacker has access to any number of valid, CA-signed certificates, complete with corresponding private keys.  They could have been stolen from other companies or slipped through checking reliable CAs.  This happened in 2011 when DigiNotor issued a certificate for an unknown party to <code>google.com</code> .  She used him to attack "man in the middle", mainly against Iranian users. </p><br><ul><li>  disable_compression </li></ul><br><p>  This option appeared in PHP 5.4.13.  It is needed to protect against CRIME and other attacks with the addition of blocks like BEAST.  At the time of this writing, the option has been available for 10 months.  It took a lot of patience to find almost the only example of its use in open source PHP. </p><br><ul><li>  SNI_enabled </li></ul><br><p>  Includes support for specifying the server name (Server Name Indication) when any single IP can be configured to operate multiple SSL certificates, so as not to be limited to one certificate for all sites or non-HTTP services hosted on this IP. </p><br><ul><li>  ciphers </li></ul><br><p>  This setting helps to show which ciphers should or should not be chosen when establishing SSL / TLS connections.  The default list is provided by the openssl extension.  It contains insecure ciphers that should be disabled unless you are forced to use them.  The following list, using the openssl syntax, was implemented by cURL in January 2014.  The alternative list offered by Mozilla may be better, because it focuses on perfect forwarding security (Perfect Forward Secrecy), this is the best practical approach.  Mozilla longer list: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">ECDHE-RSA-AES128-GCM-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-ECDSA-AES128-GCM-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-RSA-AES256-GCM-SHA384</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-ECDSA-AES256-GCM-SHA384</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:DHE-RSA-AES128-GCM-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:DHE-DSS-AES128-GCM-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:kEDH+AESGCM</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-RSA-AES128-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-ECDSA-AES128-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-RSA-AES128-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-ECDSA-AES128-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-RSA-AES256-SHA384</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-ECDSA-AES256-SHA384</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-RSA-AES256-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-ECDSA-AES256-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:DHE-RSA-AES128-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:DHE-RSA-AES128-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:DHE-DSS-AES128-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:DHE-RSA-AES256-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:DHE-DSS-AES256-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:DHE-RSA-AES256-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:AES128-GCM-SHA256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:AES256-GCM-SHA384</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-RSA-RC4-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:ECDHE-ECDSA-RC4-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:AES128</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:AES256</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:RC4-SHA</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:HIGH</span></span>:!<span class="hljs-selector-tag"><span class="hljs-selector-tag">aNULL</span></span>:!<span class="hljs-selector-tag"><span class="hljs-selector-tag">eNULL</span></span>:!<span class="hljs-selector-tag"><span class="hljs-selector-tag">EXPORT</span></span>:!<span class="hljs-selector-tag"><span class="hljs-selector-tag">DES</span></span>:!3<span class="hljs-selector-tag"><span class="hljs-selector-tag">DES</span></span>:!<span class="hljs-selector-tag"><span class="hljs-selector-tag">MD5</span></span>:!<span class="hljs-selector-tag"><span class="hljs-selector-tag">PSK</span></span></code> </pre> <br><h3 id="ogranicheniya">  <em>Restrictions</em> </h3><br><p>  As described above, checking the certificate provided by the server for validity for the host specified in the URL you are using during the man-in-the-middle attack does not allow you to simply slip any valid certificate purchased or received illegally.  This is one of the four essential steps to make your connection completely secure. </p><br><p>  The system performs the validation due to the <code>CN_match</code> parameter, declared by the <code>SSL Context</code> in the PHP HTTPS wrapper.  But he has a flaw.  At the time of writing the book, only the common name (Common Name, CN) of the SSL certificate was checked, and the validity of the Subject Alternative Name, SAN field defined by the certificate was not checked.  SAN allows you to protect multiple domain names with a single SSL certificate, so it is extremely important and supported by all modern browsers.  And since PHP does not yet support SAN verification, SSL / TLS connections to a domain protected by such a certificate will not be installed.  SAN support will appear in PHP from version 5.6. </p><br><p>  On the other hand, the out-of-box cURL extension supports SAN, so its use is much more reliable and preferable compared to PHP-embedded HTTPS / FTPS wrappers.  In this regard, the use of PHP streams is likely to lead to erroneous behavior, and impatient programmers simply disable the check on the host as a whole, which is highly undesirable to do. </p><br><h3 id="ssl-context-v-php-soketah">  <em>SSL Context in PHP Sockets</em> </h3><br><p>  Many HTTP clients in PHP offer both a cURL adapter and the default PHP socket adapter.  Using the latter by default means that cURL is an optional extension, in practice it can be disabled. </p><br><p>  PHP sockets use the same <code>SSL Context</code> resource as PHP streams, so there are the same problems and limitations as described above.  A side effect: many major HTTP clients are likely to be a priori unreliable and less secure than they should be.  Such client libraries, when possible, need to be configured so that they use a cURL adapter.  Also, make sure that customers do not forget to use the right approach to SSL / TLS security. </p><br><h3 id="dopolnitelnye-riski">  <em>Additional risks</em> </h3><br><h3 id="rasshirenie-curl">  CURL extension </h3><br><p>  Unlike PHP streams, the cURL extension only transfers data, including HTTP requests.  Also, unlike <code>SSL Context</code> streams, cURL by default safely performs requests via SSL / TLS.  You do not need to do anything for this, unless it was compiled without the CA certificates package repository (for example, without the cert.pem file or the ca-bundle.crt file with certificates of trusted CAs). </p><br><p>  Since this does not require a special approach, you can call the Twitter API - in the same way as we did before for SSL / TLS using a PHP stream.  A minimum of hassle, and do not worry about the fact that you forget about some options that will open you to attack the "man in the middle." </p><br><pre> <code class="hljs php">$url = <span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/1/statuses/public_timeline.json'</span></span>; $req = curl_init($url); curl_setopt($req, CURLOPT_RETURNTRANSFER, <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>); $result = curl_exec($req);</code> </pre> <br><p>  Therefore, for HTTPS requests, I recommend cURL.  By default, this is safe, and PHP streams are most certainly not.  Otherwise, just use cURL, it will save you from a headache.  Ultimately, cURL is safer, requires less code, and less likely to fail SSL / TLS security errors due to human error. </p><br><p>  At the time of this writing, PHP 5.6 has reached alpha1.  In the final release, more secure defaults will appear for PHP streams and socket connections over SSL / TLS.  These innovations will not be ported to PHP 5.3, 5.4 or 5.5.  Therefore, programmers will have to consciously implement secure default settings until PHP 5.6 is turned into the required minimum. </p><br><p>  Of course, if the cURL extension was enabled without configuring the placement of a package of trusted certificates, then the above example will not work.  For publicly distributed libraries, you need to force safe behavior: </p><br><pre> <code class="hljs php">$url = <span class="hljs-string"><span class="hljs-string">'https://api.twitter.com/1/statuses/public_timeline.json'</span></span>; $req = curl_init($url); curl_setopt($req, CURLOPT_RETURNTRANSFER, <span class="hljs-keyword"><span class="hljs-keyword">TRUE</span></span>); $result = curl_exec($req); <span class="hljs-comment"><span class="hljs-comment">/** * ,     SSL,      * CA-, ,      *  ext/curl.  77   CURLE_SSL_CACERT_BADFILE,  *  -         PHP. */</span></span> $error = curl_errno($req); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($error == CURLE_SSL_PEER_CERTIFICATE || $error == CURLE_SSL_CACERT || $error == <span class="hljs-number"><span class="hljs-number">77</span></span>) { curl_setopt($req, CURLOPT_CAINFO, <span class="hljs-keyword"><span class="hljs-keyword">__DIR__</span></span> . <span class="hljs-string"><span class="hljs-string">'/cert-bundle.crt'</span></span>); $result = curl_exec($req); } <span class="hljs-comment"><span class="hljs-comment">/** *        . *     SSL    ;). */</span></span></code> </pre> <br><p>  The most difficult part is obviously distributing the file with the certificate package <code>cert-bundle.crt</code> or <code>cafile.pem</code> (the file name varies depending on the source!).  The certificate of any CA can be revoked at any time by most browsers in the event of a breach of their security or peer review processes, so not updating the certificate file for a long time is not a good idea.  However, the most obvious solution is to distribute a copy of the file with the library or application for which it is required. </p><br><p>  If you cannot strictly control the renewal of the distributed certificate package, or you need a tool that can periodically perform this verification for you, use <a href="https://github.com/EvanDotPro/Sslurp">Sslurp</a> . </p><br><h2 id="ssltls-soedineniya-so-storony-klienta-klientbrauzer-server">  Client-side SSL / TLS connections (client / browser-server) </h2><br><p>  Most of what we talked about before was related to SSL / TLS connections established with another server initiated by PHP web applications.  Of course, there are still a number of security issues when an application provides SSL / TLS support to client browsers and other applications.  Here there is a risk of attacks related to transport vulnerabilities. </p><br><p>  If you think about it, then all this is quite simple.  Let's say I create an online application that provides protection while entering a user password.  The authorization form is served via HTTPS, and data from it is also transmitted via HTTPS.  Mission Complete.  To get started in your account, the user has been redirected to an HTTP URL.  Notice the problem? </p><br><p>  When there is a threat of a ‚Äúman in the middle‚Äù attack, we should not just protect the authorization form, and then close it.  Cookies of user sessions and all input data, as well as all user-generated HTML code will not be safe when working via HTTP.  An attacker can steal cookies and impersonate a user, can embed XSS-code in the pages received by users to perform tasks on behalf of users or control their actions.  And for all this, no user passwords are needed. </p><br><p>  Protecting the authentication process using HTTPS alone will prevent direct password theft, but will not protect against session hijacking, other forms of data theft, or the introduction of code for XSS attacks.  By protecting only one user with HTTPS, we provide insufficient protection at the transport level.  Our users remain vulnerable to man-in-the-middle attacks. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/352444/">https://habr.com/ru/post/352444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352434/index.html">Ransomware is gaining strength</a></li>
<li><a href="../352436/index.html">Blondes, monsters and artificial intelligence addictions</a></li>
<li><a href="../352438/index.html">Java Puzzlers NG S02: Wonderful and Wonderful</a></li>
<li><a href="../352440/index.html">The book "Security in PHP" (part 2). Code injection attacks</a></li>
<li><a href="../352442/index.html">The book "Security in PHP" (part 3). Cross-site scripting (XSS)</a></li>
<li><a href="../352446/index.html">The book "Security in PHP" (Part 5). Lack of entropy for random values</a></li>
<li><a href="../352448/index.html">Manual cipher LS47</a></li>
<li><a href="../352450/index.html">The history of the mobile Internet: 1991 - our days</a></li>
<li><a href="../352452/index.html">How to become a frontend developer in 2018</a></li>
<li><a href="../352454/index.html">Issue # 16: IT training - current issues and challenges from leading companies</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>