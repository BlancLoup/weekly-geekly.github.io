<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write the FPGA loader in LabVIEW. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most "normal" programmers, to put it mildly, have an ambiguous attitude towards LabVIEW technology. Here you can argue long and to no avail. The situa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write the FPGA loader in LabVIEW. Part 1</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/2m/nu/6l/2mnu6ljkhtj-pydr_chsebgpp_i.jpeg"><br><p><br>  Most "normal" programmers, to put it mildly, have an ambiguous attitude towards <strong>LabVIEW</strong> technology.  Here you can argue long and to no avail.  The situation is aggravated by the fact that there are a lot of examples of LabVIEW programs on the network, but all of them are focused on the beginner and come down to "oh, look how simple it is, connect the twist with the indicator, twist the handle, change the dial", or at best, the graph in the cycle a random number or a sine is displayed, all this is accompanied by a furious interface in the form of giant toggle switches, twists, and dial gauges.  Personally, this conscious simplification annoys me.  In a small series of articles I will try to acquaint the reader with the process of developing application software on LabVIEW.  In order not to spend a lot of time on the subject area, we will use the described in detail algorithm for downloading the configuration file to FPGA via FTDI in MPSSE mode ( <a href="https://habr.com/post/426131/">Downloading the configuration to FPGA via USB or parsing FTDI MPSSE</a> ).  In this article I will show how to implement the same FPGA loader, but in the LabVIEW language. </p><a name="habracut"></a><br><p>  As mentioned above, the algorithm for loading the FPGA in the Serial Passive (SP) mode and the principle of operation of FTDI are well described in the previous article.  I will not repeat.  We believe that the algorithm has been tested and found valid.  And yes, suppose the reader is at least superficially familiar with the concept of LabVIEW and is well versed in classical programming. </p><br><p>  Although the process of creating a loader does not take much time, the description of the process could not fit in the volume of one article, so there will be a small series.  Since the stage of experiments has already been completed, and I‚Äôm sure that the algorithm will work, I‚Äôll allow myself to start development from the user interface.  In the first article we will create the user interface of the loader, we will implement the structure of the program.  In the second - through the dll of the FTDI driver we implement the loading of the * .rbf file into the FPGA. </p><br><p>  For the productivity of the conversation is not superfluous to recall the terminology adopted in LabVIEW.  In LabVIEW, an application program is called a Virtual Device, also known as a VP, or Virtual Instrument or abbreviated VI.  The VI has two "sides": the front panel (Front Panel), where the controls and indicators are located, and the block diagram (Block Diagram), where these elements are interconnected and the functions and processing flows are implemented.  As a rule, the VP has a hierarchical structure; all VPs in the composition of the top-level VIs are usually called a sub-instrument or SubVI. </p><br><h2 id="interfeys-polzovatelya">  User interface </h2><br><p>  Our application must load the configuration file into the FPGA.  In this case, we assume that several FTDI can be simultaneously connected to the computer, and some of them can potentially be used to configure the FPGA.  I suggest choosing a device from a drop-down list, selecting a file through a button with a path output.  To start the download, add the "program" button.  A virtual LED indicator will display the status of the operation.  Launch LabVIEW. </p><br><p>  Add the required elements to the front panel (Front Panel).  For decoration I will use the style "Silver".  The figure below shows the result, all elements are in their original state.  By name, if necessary, they are quite easy to find in the palette. </p><br><img src="https://habrastorage.org/webt/qq/os/bt/qqosbtkepb8n5fe2l3_qnz309q8.png"><br><p><br>  We edit elements: we transfer, we stretch, we add inscriptions - we bring in a necessary type.  Here, in fact, requires the hand of a designer, but as I could: </p><br><img src="https://habrastorage.org/webt/wd/sp/iz/wdspizcngovsuygvcmkofpnepjw.png"><br><p><br>  And block diagram: </p><br><img src="https://habrastorage.org/webt/l0/g_/hi/l0g_hij_xwkzm3n-sfrqe6pfypg.png"><br><p><br>  Paying attention.  Each element has two properties that define the name - this is Label and Caption. </p><br><img src="https://habrastorage.org/webt/pi/xi/r9/pixir9kcyslk2iscflmbtfxtpmq.png"><br><p><br>  The first property specifies the name of the element; under this name it will be displayed on the block diagram.  Label, unlike Caption, cannot be changed during the execution of a VI.  In connection with this feature, I recommend to hide Label in my IDs on the front panel and display Caption.  For Label to come up with a meaningful name as a variable in a classical programming language, preferably in the Latin layout.  For Caption, enter the already human-oriented name, it can be quite long, include spaces and, if necessary, in Russian.  Using LabVIEW, you can customize the Caption display font.  I must say that no one forces us to tinker with Caption: any inscription can be made directly on the <abbr title="Front panel">FP</abbr> in any free space. </p><br><p> The VP is implemented according to the classical scheme: While loop and event handler.  Add a <code>While</code> loop to the block diagram (Programming -&gt; Structures -&gt; While Loop) and an event handler structure (Programming -&gt; Structures -&gt; Event Structure). </p><br><div class="spoiler">  <b class="spoiler_title">Concise Help for Event Structure</b> <div class="spoiler_text"><p>  The structure waits for an event to occur, then executes the appropriate handler.  The event structure has one or several subdiagrams ‚Äî event handlers, so-called cases, one of which is executed when an event occurs.  Using the terminal in the upper left corner, you can set the number of milliseconds during which the structure waits for an event.  If during this time no event has occurred, then the "Timeout" subdiagram will be executed.  The default value is minus 1, which means that the wait time never expires. </p><br><img src="https://habrastorage.org/webt/ol/qj/uo/olqjuooy0reae8un_fyw5bs2l78.png"><br><br><ol><li>  The event selector label indicates which events trigger the execution of the current case.  To view other handlers, you can click the down arrow next to the event name. </li><li>  The <code>timeout</code> terminal sets the number of milliseconds to wait for an event.  If the value is different from -1, then the Timeout subdiagram must be implemented. </li><li>  Terminal for entering dynamic events.  This terminal is not displayed by default.  To display it, select the item "Show Dynamic Event Terminals" in the context menu. </li><li>  Event data node  When an event occurs LabVIEW generates data associated with this event.  This node provides this data to the handler.  Using the mouse, you can resize the node vertically and select the necessary elements.  Some data, such as <code>Type</code> and <code>Time</code> , are common to all events, others, such as <code>Char</code> and <code>VKey</code> , depend on the type of event configured. </li><li>  The event filter node defines event data that can be modified before the user interface processes this data.  This node is displayed only in those handlers where filtering is available.  You can connect and modify items from the event data node to the event filter node.  You can also change these events by connecting new values ‚Äã‚Äãto the node terminals.  Can you completely cancel the interface's reaction to an event if you submit <code>true</code> to the <code>Discard?</code> terminal <code>Discard?</code>  .  If you do not connect the value to the filter element, then this data element remains unchanged. </li><li>  Like the <code>Case</code> structure, the event structure supports tunnels.  If you add a tunnel in one case, it will automatically be created for each handler.  However, by default there is no need to connect the output tunnels of the event structure in each handler.  All unconnected tunnels use the default for the tunnel data type.  This can potentially lead to hard-to-find errors.  You can return the mode in which the tunnel should be wired in all handlers, to do this, select "Use Default If Unwired" in the context menu. </li></ol></div></div><br><p>  First of all, we will take care of how the cycle will end and exit the program.  The easiest way is to add a stop button, which will stop the cycle, but, in my opinion, the program is usually completed with a red cross in the upper corner of the window. <br>  In the structure of the <code>Event Structure</code> add the appropriate handler.  In the context menu, select "Add Event Case".  As the source of the event, select "This VI", specify the event "Panel Close?" </p><br><div class="spoiler">  <b class="spoiler_title">Edit Events</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/bt/xo/qv/btxoqvdb2l67eohk78xrvwnhgcg.png"></a> <br>  <em>Clickable image</em> </p></div></div><br><p>  I draw your attention, if you select "Panel Close" (without a question), then this event without a filter can not be canceled.  And if with a question, when you click on the cross, we can take control and correctly complete the program on our own.  In the handler "Panel Close?"  through the tunnel, we connect the <code>true</code> Boolean constant to the terminal of the stop of the <code>while</code> .  At the entrance "Discard?"  also served <code>true</code> . </p><br><p>  Now it‚Äôs not an obvious nuance: if the current VI is launched not in the LabVIEW environment, but as a compiled application, pressing the cross will not close the window, but will stop the application, which we do not need.  To solve this problem after the completion of the main cycle, let's check whether we are in the development environment or in the program mode, if we are still in the program mode, then we will terminate the application.  In order to understand where the current VI is running, we use the properties node (Programming -&gt; Application Control -&gt; Property Node).  This node provides access to the properties of an object by reference to this object.  In this case, we should get a link to the entire application as a whole.  We select the <code>VI Server Reference</code> constant from the same palette.  After the constant is set on the block diagram, you need to change its type to <code>This Application</code> (left mouse button).  We connect the resulting link with the properties node.  Select the <code>Application:Kind Property</code> property <code>Application:Kind Property</code> - returns the type of LabVIEW system in which the current VI is running.  The output of the property is connected to the selection structure (Case Structure), we add the case "Run Time System", where we complete the application ( <code>Quit LabVIEW</code> ).  In order for this block to be executed after the cycle, and not before, the <code>error in</code> input terminal is connected to the cycle through the tunnel. </p><br><p> <a href=""><img width="720" src="https://habrastorage.org/webt/il/nm/ty/ilnmtyv89c3yv-nogcksavitbnu.png"></a> <br>  <em>Clickable image</em> </p><br><p>  Now when you start the program, you can stop it by clicking on the cross of the window.  The running program looks like this: </p><br><img src="https://habrastorage.org/webt/pv/9e/za/pv9ezax9jrro78shza6coogtu_4.png"><br><p><br>  In my opinion, a lot of excess.  Go to the properties VI (menu File -&gt; VI Properties), select the category "Window Appearance", set Custom. </p><br><p>  Turning off the menu display (in the edit mode the menu remains), turn off the scroll bar, hide the toolbar when the application is running (Show toolbar when running).  We forbid to change the window size, we allow to minimize and minimize the window.  That's much better: </p><br><img src="https://habrastorage.org/webt/a9/mg/u-/a9mgu-7km4wqkzj_rgdmc4mgfse.png"><br><p><br>  Of course, it would be worthwhile to remove the inscription "National Instruments. LabVIEW Evaluation Software", but for the home computer I still don‚Äôt want to buy a license, accept the inscription and do a 45-day trial period. </p><br><p>  Naturally, you can adjust the background color and each element, select fonts, but I'm not a designer, but something tells me that I will only make it worse. </p><br><h2 id="spisok-priborov">  Instrument List </h2><br><p>  The VP must offer the user a list of devices connected to the computer suitable for the FPGA firmware in order for the user to select the right one.  In the FTD2XX library, the functions <code>FT_CreateDeviceInfoList</code> and <code>FT_GetDeviceInfoDetail</code> are intended for this.  As already discussed in a <a href="https://habr.com/post/426131/">previous article</a> , driver libraries can be used to use the FTD2XX API.  LabVIEW has a convenient mechanism for interacting with dynamic libraries - the Call Library Function Node; you can find it in the "Connectivity -&gt; Libraries &amp; Executables" palette.  The function call node should be configured: first, specify the path to the dll (the "Function" tab), after which the system scans the library and in the "Function Name" list will offer to choose the name of the function - select <code>FT_CreateDeviceInfoList</code> , calling convention (Calling convention) - select <strong>stdcall (winapi)</strong> .  Secondly, on the "Parameters" tab, you need to enter a list of function parameters, where the first element of the list is the return value.  Here before my eyes it would be nice to keep the documentation on the API, or the header file.  When setting parameters, the prototype of the function being imported is displayed in the "Function prototype" area.  When the signature from the documentation matches the configured prototype, click OK. </p><br><p>  Suppose that the scan should be performed once per second.  The call node is located in the structure of the event handler on the "Timeout" tab, the waiting time is set to 1000 ms.  We add indicators to the node outputs, and if everything is done correctly, then when the VI is started, the number of connected devices with FTDI should be displayed: </p><br><div class="spoiler">  <b class="spoiler_title">Front panel and block diagram</b> <div class="spoiler_text"><p> <a href=""><img width="720" src="https://habrastorage.org/webt/sc/pg/fr/scpgfrpwkg3gi5hepnez6b8l_nc.png"></a> <br>  <em>The picture is clickable</em> </p><br><img src="https://habrastorage.org/webt/v7/cy/fu/v7cyfuon36rdj3wxlwoaotzt_2c.png"></div></div><br><p>  Similarly, create a node for the function <code>FT_GetDeviceInfoDetail</code> .  The function prototype is: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">FTD2XX_API FT_STATUS WINAPI </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FT_GetDeviceInfoDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD dwIndex, LPDWORD lpdwFlags, LPDWORD lpdwType, LPDWORD lpdwID, LPDWORD lpdwLocId, LPVOID lpSerialNumber, LPVOID lpDescription, FT_HAN</span></span></span></span></code> </pre> <br><p>  When describing parameters, you should note that <code>lpdwFlags</code> , <code>lpdwType</code> , <code>lpdwID</code> , <code>lpdwLocId</code> are passed as pointers to <code>uint32</code> .  The <code>lpSerialNumber</code> and <code>lpDescription</code> are the essence of byte strings (arrays of type <code>char</code> with a null terminator).  Parameters of this type in the call node can be styled in various ways, you can enter them into an array of 8-bit words, but I think it is most convenient to immediately indicate that this is a string and set the expected size.  In this case, the output will immediately be a valid lably string and no additional transformations will be required. </p><br><img src="https://habrastorage.org/webt/zi/n8/8t/zin88t8hl5je5csuxcq7l_bbk9c.png"><br><p>  Call Library Function </p><br><p>  This function returns information on the <code>dwIndex</code> sequence number.  If several FTDI are connected to the computer, in order to read the information for each converter, the function must be called in a loop.  The number of loop iterations will be given to us by the previous function <code>FT_CreateDeviceInfoList</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Front panel and block diagram</b> <div class="spoiler_text"><p> <a href=""><img width="720" src="https://habrastorage.org/webt/sr/2a/gq/sr2agqtusiwcn3tcttwqbncllgk.png"></a> <br>  <em>The picture is clickable</em> </p><br><img src="https://habrastorage.org/webt/t9/dg/tl/t9dgtlw3lapeklhbi4y3tzca0lm.png"></div></div><br><p>  There is an unpleasant feature: all ports of the call site must be connected on at least one side.  Therefore, a tunnel is made in the loop for those output terminals that we are not going to use. </p><br><p>  The <code>Types</code> array contains the types of FTDI chips, we need them in order to limit the choice only to those that support MPSSE and can potentially be used to program the FPGA.  However, it is inconvenient to operate with ‚Äúmagic numbers‚Äù - I suggest arranging the FTDI types in the form of <code>enum</code> .  Moreover, such an <code>enum</code> already in the ftd2xx.h header file.  In LabVIEW, you can use two controls to create an enumeration: the ‚ÄúText Ring‚Äù and the ‚ÄúEnum‚Äù itself.  Both contain lists of strings with numeric values ‚Äã‚Äãbetween which you can switch.  The main difference is that Enum requires that numeric values ‚Äã‚Äãbe consecutive integers, while there is more freedom in the Text Ring ‚Äî you can specify any values. </p><br><div class="spoiler">  <b class="spoiler_title">Enum.</b>  <b class="spoiler_title">Creature</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/v9/ye/ik/v9yeik6iwgvetbpoa2wcf9b0kn8.png"><br><p>  <em>We manually enter the values, it is a pity that there is no function to import <code>enum</code> from C</em> </p><br><img src="https://habrastorage.org/webt/en/jd/4r/enjd4rvd8snxw6fhtstrinlcvey.png"><br><p>  <em>This type of indicator looks like this on the front panel.</em> </p><br><img src="https://habrastorage.org/webt/yc/t6/er/yct6erqkpta8o-a4mnp7vfbty7w.png"><br><p>  <em>The choice of value is carried out by the left mouse button</em> </p></div></div><br><p>  In order to link and synchronize all future instances of the created list, it is convenient to use the function "Make Type Def."  (selection through the context menu of the element).  This will create a custom data type.  The new type is placed in a separate file with the extension * .ctl.  Editing this file will change all instances of this item.  I think you should not explain how it can be convenient.  Access to the definition file can be obtained from the context menu of the instance by selecting "Open Type Def", in the same menu you should pay attention to the items "Auto-Update from Type Def."  and "Disconnect from Type Def". </p><br><p>  We change the <code>Types</code> indicator to the array of the <code>FTDI Type</code> indicators and as a result, when the VI is started, the type of the connected converter is displayed: </p><br><img src="https://habrastorage.org/webt/zy/07/zy/zy07zy2phqs7mc_q8a4hur1hunw.png"><br><p>  <em>Three devices found</em> </p><br><p>  It is easy to see that the functionality of the resulting code in the Timeout case is complete, therefore it can be transferred to a separate SubVI.  Select the elements that we want to transfer to the sub-device and in the main menu Edit select the item "Create SubVI". </p><br><div class="spoiler">  <b class="spoiler_title">block diagram with sub-instrument created</b> <div class="spoiler_text"><p>  All indicators remained, and in place of the call nodes, a new VI was formed with a standard icon. <br> <a href=""><img src="https://habrastorage.org/webt/wz/oo/ba/wzoobavcvisx9kmmntke3m_2pxe.png"></a> <br>  <em>The picture is clickable</em> </p></div></div><br><p>  Double click on the new subVI will launch its edit window.  First of all we save it and give a meaningful name, for example "FT_GetDeviceInfo".  Configure the I / O terminals.  To do this, use the Connections Pane: </p><br><img src="https://habrastorage.org/webt/1e/fs/gw/1efsgw6lcoaoauj-qguyus4fbn4.png"><br><p>  A panel is a set of terminals corresponding to controls and indicators VI. </p><br><p>  If you select the terminal on the connections panel, the corresponding element on the front panel will be highlighted.  If you select an empty terminal, and then click on the element on the front panel, the element will bind to the terminal, but before that it should not be assigned to some other terminal.  In the context menu, you can individually or for all disconnect the terminals from the elements at once, you can change the pattern of the panel as a whole. </p><br><p>  I don‚Äôt like how the terminals were assigned when creating the current subVI, so I select the "Disconnect All Terminals" option and mark it manually.  I recommend the input terminals to be placed on the left, and the weekend on the right, optional input can be placed on top, and optional output below.  This will ensure good code readability and visual order on the block diagram. </p><br><p>  To control errors, create two additional elements <code>Error in</code> and <code>Error out</code> .  The topic of error control in LabVIEW is very extensive and is beyond the scope of this article, therefore we limit ourselves to a minimum of explanations and will adhere to the principle ‚Äúdo as I do‚Äù.  So, we create two terminals for errors - input and output. </p><br><div class="spoiler">  <b class="spoiler_title">It is convenient to create them using the context menu.</b> <div class="spoiler_text"><p>  Right mouse button on the terminal errors of any node: </p><br><img src="https://habrastorage.org/webt/ul/ew/re/ulewre7rct2swn34bhqejv3kg24.png"></div></div><br><p>  In LabVIEW, the input terminal accepted errors on the connection panel to be placed on the left below, and the output one on the right below. </p><br><p>  It will be more convenient to combine the output into a structure.  For output, we will make two arrays: the first array will contain all the FTDI devices found, the second array - only those that can MPSSE and can theoretically be used to configure the FPGA. </p><br><p>  The final touch when creating a sub-device is setting up an icon.  Double click on the icon in the upper right corner of the window launches the editor.  We try to create some kind of meaningful image that allows us to unambiguously interpret the purpose of the device on the block diagram. </p><br><div class="spoiler">  <b class="spoiler_title">FT_GetDeviceInfo.vi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/l1/hy/sd/l1hysdhgshztti7xczw7tjmbex0.png"><br><p>  <em>Front Panel</em> </p><br><img src="https://habrastorage.org/webt/a4/ba/5w/a4ba5wwquuv-coxuxpxzjo8xwio.png"><br><p>  <em>Block diagram</em> </p><br><p>  And this is how the case "Timeout" looks after putting things in order: <br> <a href=""><img src="https://habrastorage.org/webt/ea/yu/6d/eayu6ddx32eq_easysclsqqp7pg.png"></a> <br>  <em>The picture is clickable</em> </p></div></div><br><p>  Up to this point, the drop-down list with the name "Select device" was empty, we now have the data to fill it.  Create a property node for the list with the property "Strings []" (context menu -&gt; Create -&gt; Property Node -&gt; Strings []).  Any property is available for writing and reading, the current mode is selected in the context menu of the Property Node.  When creating a default node, properties are configured to be read.  Change to write: "Change To Write". </p><br><p>  From the array of structures, select the array with the description and feed it to the <code>Strings[]</code> .  You can select an array using the <code>For Loop</code> . </p><br><p>  After starting the VI, pressing the left button on the element "Select device", you can specify the device to configure.  At the same time, the list of devices is updated twice a second.  Of course, it would be possible to update the property only if the list was updated, but for the time being this will result in unnecessary blocking of the block diagram. </p><br><div class="spoiler">  <b class="spoiler_title">What happened?</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/_t/gh/i7/_tghi7fjgo0hhb6thtdcosvfp1m.png"><br><p>  <em>Front Panel</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/x6/wo/3v/x6wo3v0sqbdvwzhksbg4kghoeho.png"></a> <br>  <em>The picture is clickable</em> </p><br><p>  Earlier, I forgot to mention such an interesting feature; the For loop does not have to specify the number of iterations in an explicit form; it is enough to create an input tunnel of the array and the loop is executed for each element, this behavior resembles a <strong><code>foreach</code></strong> in C ++ 11.  However, one must be careful when more than one array enters the loop input. </p></div></div><br><p>  In the event structure, add the handler for pressing the "program" button.  As long as we do not have a VI responsible for loading the file into the FPGA, we will make a sub-device "stub".  Suppose that it takes as input the path to the configuration file and the FTDI descriptor, and returns the status of the firmware as a result of the work: successful or not.  And in order to make it more interesting to test the interface of the program, we will make this status random. </p><br><div class="spoiler">  <b class="spoiler_title">Plug FT_MPSSE_SP_FPGA.vi</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/gy/xl/qf/gyxlqf-hzbjik3667nmzga5bf6g.png"><br><p>  <em>Front Panel</em> </p><br><img src="https://habrastorage.org/webt/f_/qz/kw/f_qzkwjrp7nqvo9yfgl0o9ovidw.png"><br><p>  <em>Block diagram</em> </p></div></div><br><p>  The FTDI descriptor is passed to the input of the stub through the list property (context menu -&gt; Create -&gt; Property Node -&gt; Ring Text -&gt; Text). To transfer the file path to the "File Path" element, create a local variable (context menu -&gt; Create -&gt; Local Variable) and configure it to read (Change To Read).  And we will connect the status output directly to the <code>Status</code> indicator.  The <code>Programm</code> button is dragged to the event handler.  It is a good practice to place elements on which the event is configured in the handlers - now double clicking on this element on the front panel will show not only the corresponding element on the block diagram, but also the event handler associated with this element. </p><br><p>  Now, by pressing the "Program" button, the indicator becomes either green (success) or dark green (not success).  Not too visually.  In the properties of the indicator, change the color "Off" to red.  That's better.  If the indicator is green, then we can state that the FPGA on the selected device is configured by the file, the path to which is specified in the window: </p><br><img src="https://habrastorage.org/webt/wl/le/re/wllerexz4zkxjzemfyspv_3yyoo.png"><br><p>  <em>Front Panel</em> </p><br><p>  But this statement becomes false if we change the file or choose another device.  At the same time, we cannot dye the indicator red, as programming errors did not occur.  A convenient solution would be to change the file or device, emphasizing that the indicator value is not relevant - to darken it.  For this, you can use the <code>Disabled</code> property of the indicator.  This property can have three values. <code>Enabled</code> - normal display; the user can control the object;  <code>Disabled</code> - the object is displayed on the front panel as usual, but the user cannot control the object;  <code>Disabled and Grayed Out</code> - the object displayed on the front panel is darkened, and the user cannot control the object. </p><br><p>  We create event handlers for the <code>Devices list</code> and <code>File Path</code> , and we dim the status indicator in them, and in the handler of the "Program" button we assign it to the <code>Enabled</code> property. </p><br><div class="spoiler">  <b class="spoiler_title">What happened</b> <div class="spoiler_text"><p> <a href=""><img src="https://habrastorage.org/webt/59/xl/da/59xldabidafiphelnavil1h3iue.png"></a> <br>  <em>Programm handler: Value Change.</em> </p><br><p> <a href=""><img src="https://habrastorage.org/webt/i4/xm/sx/i4xmsxdxklfiusfqfamtyqxpoog.png"></a> <br>  <em>Devices list handler: Value Change</em> </p><br><img src="https://habrastorage.org/webt/w3/58/dn/w358dn13xtxn61o6o5frte7-gsk.png"><br><p>  <em>Here is the darkened indicator.</em> </p></div></div><br><p>  We will make it easy for the user to search for the configuration file - we will configure the file viewing window  Go to the properties of the <code>File Path</code> element, on the "Browse Options" tab, fill in the Prompt, Pattern Label, specify the filter of the file type (Pattern) and the name for the button (Button Text). </p><br><div class="spoiler">  <b class="spoiler_title">File selection window</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/vf/i2/yc/vfi2ycpuj_lhydbcp1jebbjb0ni.png"><br><p>  <em>Only rbf files are displayed.</em> </p><br><img src="https://habrastorage.org/webt/1-/w3/e8/1-w3e8dg3uauxccfq8-buzrs75y.png"></div></div><br><p>  Creating a user interface can be considered complete. </p><br><img src="https://habrastorage.org/webt/tm/5w/oq/tm5woq3kwnfgmo38klp_5qxenug.png"><br><p>  <em>Running bootloader</em> </p><br><h2 id="s-chem-poznakomilis-segodnya">  What did you meet today? </h2><br><p>  In this article, using the example of creating a functionally complete application with a minimalist interface, I tried to show different approaches to working in LabVIEW. </p><br><p>  As a result, we touched on: </p><br><ul><li>  Setting the properties of the virtual device.       . </li><li>   :   . </li><li>    . </li><li>  . </li><li>    dll. </li><li>    . </li></ul><br><p>         API FTD2XX   MPSSE.     . </p><br><h2 id="materialy-po-teme">  Materials on the topic </h2><br><ol><li>  <a href="https://habr.com/post/426131/">Download configuration to FPGA via USB or disassemble FTDI MPSSE</a> </li><li> <a href="https://bitbucket.org/Shamrel/labview_mpsse">labview_mpsse</a> .   . </li><li> <a href="http://www.labfor.ru/devices/leso7">   </a> .    </li><li> <a href="http://www.ftdichip.com/Support/Documents/ProgramGuides/D2XX_Programmer%27s_Guide(FT_000071).pdf">Software Application Development D2XX Programmer's Guide</a> .   API D2XX. </li></ol></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/427529/">https://habr.com/ru/post/427529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427519/index.html">@Kubernetes Meetup in Mail.Ru Group: October 29th and always</a></li>
<li><a href="../427521/index.html">Breakthrough Prize 2019. Winners of the Milner, Brin and Zuckerberg Science Award announced</a></li>
<li><a href="../427523/index.html">Success hedge</a></li>
<li><a href="../427525/index.html">Intel Core 9th Gen in numbers and benchmarks</a></li>
<li><a href="../427527/index.html">10 tricks for advanced dashboarding in Splunk. Part 2</a></li>
<li><a href="../427531/index.html">From Siberia to Cyprus and back - the story of the failed immigrant</a></li>
<li><a href="../427533/index.html">Smart watches that do not require charging. How many are there?</a></li>
<li><a href="../427535/index.html">We launch a collective choice of solutions.</a></li>
<li><a href="../427537/index.html">How to become a successful product manager: courses that are being taught right now</a></li>
<li><a href="../427539/index.html">Europe last sets the clock to winter time</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>