<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Manual Application Testing Guide: Benefits, Milestones, and Methodologies</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We analyze in detail how to conduct manual testing, when it is better automated, what a tester needs and how he can build his career from junior to te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Manual Application Testing Guide: Benefits, Milestones, and Methodologies</h1><div class="post__text post__text-html js-mediator-article">  We analyze in detail how to conduct manual testing, when it is better automated, what a tester needs and how he can build his career from junior to test lead.  The guide was prepared jointly with the head of the testing department of Agima Darina Gordeeva. <br><br><img src="https://habrastorage.org/webt/im/mu/rs/immursqehrccpx9lm36avqtpd7w.gif"><br><br>  Hello!  My name is Darina Gordeeva.  I have been working at AGIMA as a department head for almost 3 years.  In the field of testing and quality assurance over 6 years.  During this time, I went from junior to head of the department, doing hardware testing, as well as mobile and web applications, automating and setting up QA processes.  Today I will tell you about the features, capabilities and hidden problems of manual testing. <br><a name="habracut"></a><br>  <i>Recall that any reader who uses the Habr promise can receive a discount of 10,000 rubles for the course they like, while the most diligent and attentive can collect a 25,000 rubles discount for themselves, solving puzzles from materials prepared in conjunction with Agima:</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <a href="https://habr.com/company/skillbox/blog/415203/">How to get into the AppStore from the first time: step by step guide</a> ; </li><li>  <a href="https://habr.com/company/skillbox/blog/416641/">8 stages of the development process of a mobile application interface</a> ; </li><li>  <a href="https://habr.com/company/skillbox/blog/417607/">A / V tests do not work.</a>  <a href="https://habr.com/company/skillbox/blog/417607/">Check what you are doing wrong</a> . </li></ul><br><br> <a href="https://skillbox.ru/agima/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DAGIMA%26utm_content%3Darticles%26utm_term%3Dultimatemanualtestguide-banner"><img src="https://habrastorage.org/getpro/habr/post_images/5cb/4d5/7a9/5cb4d57a9ec4c7922f07a4936905952a.jpg"></a> <br><br><h3>  Efficiency, flexibility, the possibility of improvisation and other advantages </h3><br>  Today there are many testing frameworks that support almost all existing languages.  It would seem - you can take and automate.  But even now, manual tests are important. <br><br>  One of the explanations for their need is that with manual testing of the functionality, we can get information about the state of the product that we are analyzing, about the quality of development, much faster.  In addition, during automation, previously developed cases often have to be changed and updated, and it takes some time to write autotests. <br><br>  In the development process, feedback from the customer may come when he sees some function in the finished product that he decides to change before the release - and if you have already prepared software tests for it, they will have to be rewritten.  Updating cases, autotests and checking them will take up valuable time that could be used to update this feature itself. <br><br>  All this means that the main purpose of the manual tests is to first verify that the claimed functionality is functional, has no errors, and gives the expected, planned results.  Without them, one cannot be sure that one can continue working.  This is especially true for the functions for which the subsequent development is tied.  In this case, fussing with the creation of autotests for these features becomes a blocking factor for the entire product development, shifting the deadlines and breaking deadlines.  The moment when the cases will come to automate, anyway, sooner or later comes - but you should not strive to bring it artificially in pursuit of the total exception of manual labor. <br><br>  In addition to this, in the early stages of developing an application, automation can be quite expensive.  You will need a specialist with specific qualifications (and, possibly, not one).  Constant maintenance of tests up to date requires resource expenditures up to the release of features.  And the months of inactivity devoted to licking the autotest will hit the motivation of the team. <br><br><blockquote>  If you want to regularly add new features and keep up with the actions of competitors, then before creating autotests always check the capabilities of the product manually.  Just because manual testing speeds up your processes. </blockquote><br>  This is especially true for mobile development.  Most of these projects today are being developed in short sprints, which means that features are being introduced at an accelerated pace.  In such conditions, manual testing allows the team to give feedback to the team as quickly as possible: to report the presence of bugs - or to please her with the fact that everything is OK and you can move on.  You can carry out a series of autotests later, covering with them large arrays of code.  Manual testing will help prepare cases for this test. <br><br>  Self-tests do not allow to check whether it is convenient to use the new features of the application - usability testing is always carried out manually. <br><br><blockquote>  <b>Skillbox recommends:</b> Online course <a href="https://skillbox.ru/agima/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DAGIMA%26utm_content%3Darticles%26utm_term%3Dultimatemanualtestguide-link">Fullstack-mobile developer</a> . <br></blockquote><br>  In manual tests, you can improvise, creating insane combinations of actions that never occur to the user, but can be committed by him randomly.  This allows you to create new cases. <br><br>  New cases appear also because the tester constantly asks himself the question ‚Äúwhat if?‚Äù.  So he finds original ways to interact with the application - even if they were not in the baseline scenarios. <br><br><img src="https://habrastorage.org/webt/ys/96/m2/ys96m2ovf75_ezs5ji75cr2fgpo.jpeg"><br><br><h3>  Manual testing problems and their solutions </h3><br>  The biggest disadvantage of manual testing is the human factor.  He, of course, influences everything that happens in a team - both on the work of the participants, and on the events taking place on the client side.  In the case of QA, the reason that the tester will be poorly immersed in the process and miss a potential error can be anything - a lack of experience, family problems or a headache. <br><br>  Two testers can test the same scenario in different ways.  What to do with it?  It is important that each unintended or different from the expected result is recorded in the form of a case.  So that any tester could test it by performing the same set of actions.  But this may not be enough - if the case is not detailed enough, and the tester does not figure it out.  Of course, it is impossible to guarantee 100% exclusion of the human factor - but you can try to minimize the likelihood of the problems it causes. <br><br>  This also negatively affects the delivery time of features in production and labor costs: after all, now ‚Äúcunning‚Äù cases, invented by testers in the process, are added to periodically held basic cases and regressions. <br><br>  The situation is aggravated by the likelihood that some of the bugs encountered will not yet have a strict description because their causes are not yet clear.  How to deal with such repeated testing?  Either find the source of the error and eliminate it, or - all the same to automate the passage of problem cases - in this case, the transition to software tests will be fully justified both in terms of time and financially.  (No, this does not contradict the above - because such situations arise already in the course of active development and by this time you will, in any case, launch the auto-testing process). <br><br>  In any case, the appearance of the first cases needing regression tests or the release of the second version of the application and the scale of the command corresponding to these events is the moment when the automation becomes relevant (but does not exclude manual testing of new features).  At this stage, the automation will start saving time: the developer will be able to start the regression tests of the new feature even before the transfer to the QA department to make sure that it does not break the existing functionality, and the tester will not have to go through the cracks of basic cases once again.  Another advantage of introducing autotests at this stage is that they can be launched according to a specific schedule - every night, on the days when sprints are over or when new application assemblies are published. <br><br>  In this case, we must not forget a few things: <br><ul><li>  Creating cases and writing autotests will take time - lay it in sprints; </li><li>  make sure that the autotest test case is registered well and in detail and describes the possible problem or the existing scenario in its entirety; </li><li>  check whether the autotest works correctly and whether it really checks what you need and does it qualitatively. </li></ul><br><blockquote>  We summarize: manual testing gives a great advantage in speed and labor costs in the early stages, and as the application grows and a large number of regression tests appear, it goes into the category of ‚Äúoperational testing‚Äù of new features in a separate sprint.  It will be relevant and, if necessary, urgently check how the application will react to a change in the operating system or an update of the environment. </blockquote><br><h3>  Test stages: what, when and how </h3><br>  If you look at the development process as a whole and at testing as one of its parts, then with proper planning you will always understand what and when it will be ready.  This will allow you to better plan the time of certain actions - since some events logically follow others and you have the opportunity to arrange them in chains based on your expectations. <br><br>  <b>The tester appears in the process of creating an application at an early stage.</b>  A client has a certain idea, business analysts collect from this requirement - and testers start working at this moment, checking these requirements. <br><br>  How does this happen?  They ask questions about the intended functionality.  Trying to imagine what the application will look like when it is implemented.  If we are talking about a new feature in an already existing product, they understand how it will interact with the existing functionality.  After the developers conducted an assessment of the workload of the client‚Äôs ideas and determined how long it would take to implement them. <br><br>  <b>After this, the design phase begins.</b>  Here it becomes necessary to understand how the transitions between screens will be carried out, certain fields validated, how an application or its individual function will generally interact with the end user.  In the case of features, it is important to understand how they will fit into the architecture of an existing application. <br><br>  <b>At the design stage</b> , when a transition map is created between the screens, the tester refines the behavior of the individual elements of which they are composed and what visual effects will be followed by those or other user actions.  In addition, the tester validates the layouts for completeness, confirming that they reflect everything that is needed to implement the conceived functionality.  Self-checking of layouts for compliance with guidelines will also be useful. <br><blockquote>  <b>Skillbox recommends:</b> online course <a href="https://skillbox.ru/rmr/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3Drmrmds%26utm_content%3Darticles%26utm_term%3Dultimatemanualtestguide">Mobile Application Design</a> <br></blockquote><br>  <b>With the start of development, QA specialists immediately begin writing test cases.</b>  At different stages of development, they may have different levels of detail, but by its completion it is desirable to ensure maximum coverage of the entire product with cases so that, upon receiving the assembly, you can start testing immediately. <br><br><img src="https://habrastorage.org/webt/ww/cl/42/wwcl42lzqzf2vp40x_v0qhnlyt4.jpeg"><br><br>  <b>The first step of direct testing is the Smoke test:</b> assessment that the application or its new part is generally ready for testing.  A smoke test is a test of whether an application or a particular function is running in principle. <br><br>  Smoke test is a quick way to see if we can even begin a functional test.  The term came from the creators of boards and microcircuits, which, for a start, had to make sure that the new circuit would not burn - hence the name: smoked / not smoked. <br>  This is a quick way to make sure that we really have the task and we can take it to work, and not send it back to programmers. <br><blockquote>  On the example of the authorization form, a smook is an assessment of whether it is possible to log in at all, without specifying whether the data entered in the fields is valid, whether the additional features work, such as a password reminder and other things.  If we were able to log in in principle, we can proceed to further, in-depth testing of this module: take negative cases, boundary values, assess compliance with the established validation rules. </blockquote><br>  <b>The next stage is to conduct regression tests.</b>  In manual or automatic mode, the main pre-planned array of tests is conducted. <br><br>  Regression testing is good because it allows you to find errors even in those places where everything was in order.  This is due to the fact that regression is an assessment of the functional on a standard set of cases when implementing each new module and each application change.  After all, when developers add a new functionality, the current version may be damaged or a new feature may conflict with existing ones. <br><br>  For example, adding new screens, and thus changing navigation can disrupt the menu or at least display it.  On the other hand, the global refactoring of the application code can also cause unpleasant surprises - after it, it is also necessary to carry out regression tests. <br><br>  Problems can cause and update the library used by the application and change the environment in which it works.  The more often you update the application, the more important is the role of regression tests.  You should not limit yourself to a one-time check carried out when the feature is already in place - check all changes.  Automating regression testing will help you here - simply because manual regression testing of a new feature created in just a week can take two, or even more, and the testing department will simply get bogged down with it. <br><br>  A full check, of course, is carried out when a release candidate with one or several features is ready to roll out in production, but it is still necessary to use one or another relevant cases at separate stages of development. <br><br>  <b>Everything ends with testing the final build</b> - release candidate.  It includes beta testing by internal testers, business testing ‚Äî evaluating the resulting product by the customer and receiving feedback from him, as well as proposing to a certain group of users to get acquainted with the pre-release alpha version of the application or its new features.  After this, the application is ready to be rolled out to production. <br><br>  <b>But this does not end the work of a QA-specialist</b> - he will have to test the application updates and their compatibility with earlier versions, create cases for testing innovations and, if necessary, automate the passage of these scenarios. <br><br>  <b>In parallel with this, testers participate in further analysis of statistics</b> collected by analysts, monitoring application behavior and how users interact with it.  This allows not only to see the living use of the results of their work, but also, at times, to discover new scenarios and unknown bugs causing the application to crash. <br><br>  <i>Rebus time: guess it and a 10% discount on any of the Skillbox courses is waiting for you right now or be diligent and collect answers to all the puzzles - these discounts are added together (but with no other discounts on Skillbox courses).</i> <i><br><br></i>  <i>However, it is not necessary to delay too much - the promo works until August 30, 2018.</i>  <i>Recall that the subject of riddles is mobile, and English words can interfere with the Russians here, so be careful!</i>  <i>Send a request for the course, and when the manager contacts you - call him a pretense encrypted in the rebus (or - a few!).</i> <br><br><img src="https://habrastorage.org/webt/-x/si/ye/-xsiyeg11t1huls-yjr18qcikd8.png"><br><br><h3>  Testing formalization: test plan, bug reports format, reporting </h3><br>  In order to prepare for functional testing, a QA engineer prepares a test plan.  This is the documentation that he will need when testing the product, a list of actions that he will need to perform.  The test plan indicates the time of testing, describes the product or a specific task - in order to determine exactly what needs to be checked.  All main test cases are described in detail.  Lists the types of testing that are needed: functional and, for example, load.  Describes how to automate certain cases and then at what stages they will be automated. <br><br>  The test plan concludes with a description of the report format: you need to explain in advance how the result will be presented.  The most common report format is a list of test cases with the status of their passage.  Knowing how much the cases cover the entire volume of requirements and reading the report, it will be possible to draw a conclusion about the current state of application development.  To do this, it will be enough to see how many of them have been successfully completed in one or another assembly. <br><br>  The final sign that the product is ready is the status ‚Äúall requirements are covered with cases, all cases are passed successfully‚Äù. <br><br>  In addition, the error report format is formalized in the test plan.  This may be a bug list, a list of tasks in the tracker. <br><blockquote>  The task of the tester is to provide the most complete information about the quality of the product to all team members. </blockquote><br><h3>  What you need to know and be able to become a tester </h3><br>  First of all, the tester should be able to think and be attentive and diligent.  Experience is important - it allows you to accumulate certain achievements and consolidate the knowledge of testing processes, turning them into skills. <br><br>  A manual test specialist doesn‚Äôt have to be able to write code and have a deep understanding of architecture.  This does not prevent him from checking the functionality and at the application level to understand the principles of interaction between the application and the server. <br><br>  Automated testing specialist is a separate profession, with a completely different set of knowledge.  High-quality auto-testing is not just scripts, but also an understanding of how an application is built from within, and specific skills, such as knowing how to parallelize tests or how to run them in a cloud or on multiple servers.  Only such a pool of skills allows you to proudly call yourself an "automaton with a capital letter."  So, without knowledge of languages, their frameworks, principles of OOP and attentive surveillance of the development of technologies, this auto tester is indispensable. <br><br><img src="https://habrastorage.org/webt/xr/p8/4k/xrp84k5gd9xgykkd1i-8xgiqake.jpeg"><br><br>  The path of each tester begins with mastering the theoretical basis of testing, obtaining primary ideas about how an application interacts with the server and with the environment.  If this knowledge is there, and with it a person also has a very serious intention to learn, he can already be considered a junior tester.  A group of such newcomers with burning eyes is assigned to a senior specialist - either a leading tester, or, if the company can afford it, a coach who purposefully pumps his charges.  They explain incomprehensible moments to the juniors and give painful tasks like running the features on test cases.  In the process, a person learns to read test cases and masters the practical basics of functional testing.  At this stage, after the juniors, it is still necessary to check the quality of the tests they carried out, passing them after them. <br><br>  The next step is the creation of an individual (or collective, depending on the size of the company) development plan, according to which the novice tester should develop, mastering new knowledge and achieving certain results within the time allotted to it.  This is the way to become a middle-level specialist. <br><br>  A middle tester is a person who is already able to independently carry out the tasks assigned to him, to find solutions and generally to do his work consciously, and not blindly following the established algorithms. <br><br>  With the development of skills in test design, knowledge in the functional and applied areas, as well as the development of new testing methods - which now need to be developed independently - there is a gradual transformation into a leading specialist.  Now he can be charged with the maintenance and support of the same juniors as he himself was before. <br><br>  The next level is a test lead.  He can already manage a team that includes representatives of all three previous categories, the processes of which he manages and the time of which he manages, including participating in planning global development processes, estimating labor costs and budgeting for his teams. <br><br>  Further vertical growth of team lead is the management of the department or the transition to product management.  If, however, a person is seeking new knowledge, and not new administrative positions, then he can choose to develop, analyze, or such a direction as DevOps, which combines the duties of a system administrator, tester and programmer. <br><br>  Testing is just one of the many areas of mobile development that we look at as part of the ‚ÄúFullstack Mobile Developer‚Äù course.  The industry professionals working with us will share their experience with you and test your homework, and the result of the training may be an internship for a large company.  Come to us to study! <br><br> <a href="https://skillbox.ru/agima/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3DAGIMA%26utm_content%3Darticles%26utm_term%3Dultimatemanualtestguide-banner"><img src="https://habrastorage.org/getpro/habr/post_images/5cb/4d5/7a9/5cb4d57a9ec4c7922f07a4936905952a.jpg"></a> <br><br>  <b>Skillbox recommends:</b> <br><br><ul><li>  <a href="https://skillbox.ru/sibirix/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3Dpmsbrx%26utm_content%3Darticles%26utm_term%3Dultimatemanualtestguide-link">Management of digital projects</a> ; </li><li>  <a href="https://skillbox.ru/motion/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3Dmotdes%26utm_content%3Darticles%26utm_term%3Dultimatemanualtestguide-link">Interface animation</a> ; </li><li>  <a href="https://skillbox.ru/aic/%3Futm_source%3Dskillbox.media%26utm_medium%3Dhabr.com%26utm_campaign%3Duxdes%26utm_content%3Darticles%26utm_term%3Dultimatemanualtestguide-link">UX design</a> . </li></ul></div><p>Source: <a href="https://habr.com/ru/post/418889/">https://habr.com/ru/post/418889/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418877/index.html">The role of customer support in game development and its interaction with other departments</a></li>
<li><a href="../418879/index.html">Testing Methods for Crypto Exchanges and Crypto Wallets</a></li>
<li><a href="../418883/index.html">GitLab to NAS</a></li>
<li><a href="../418885/index.html">Crispr can accelerate natural processes and change the way food is grown.</a></li>
<li><a href="../418887/index.html">How fast is the universe expanding?</a></li>
<li><a href="../418891/index.html">Checked with the help of PVS-Studio Android source codes, or no one is perfect</a></li>
<li><a href="../418895/index.html">Learning Artificial Intelligence to play the game</a></li>
<li><a href="../418897/index.html">CRDT: Conflict-free Replicated Data Types</a></li>
<li><a href="../418899/index.html">First impressions and actions after upgrading MySQL from version 5.7 to 8.0.11</a></li>
<li><a href="../418901/index.html">The Russians won the most gold medals of the European Olympiad in Informatics eJOI 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>