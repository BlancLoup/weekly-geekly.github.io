<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test Driven Design - the first implementation experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Numerous articles on TDD in general and Unit tests in particular, as a rule, operate with rather artificial examples. For example, let's write a funct...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test Driven Design - the first implementation experience</h1><div class="post__text post__text-html js-mediator-article">  Numerous articles on TDD in general and Unit tests in particular, as a rule, operate with rather artificial examples.  For example, let's write a function that adds two numbers and write a test for it.  Frankly speaking, it is difficult to evaluate the advantages of using automated tests on such examples. <br><br>  Some time ago, I turned up a tiny proektik who seemed to be specially created in order to test on it a design methodology based on tests.  The result of the application struck me!  I invite under kat all who still doubt that it is necessary to apply automated tests in daily development. <br><a name="habracut"></a><br><br><h4>  Lyrical digression.  On the role of tests </h4><br>  Many articles have been written about the usefulness of using Unit tests, but many copies are broken in disputes about their necessity.  And, despite the fact that I have been practicing the writing and regular running of Unit-tests for a long time, for a long time I was unable to clearly formulate the motives for their use. <br>  The main argument against ambient automated testing is the additional time spent writing tests.  Indeed, automated testing does not replace other types of testing.  The approach is widespread: ‚ÄúWe write the program and send it to testers (or even to the customer immediately!).  <s>If</s> When errors are found, we will correct them and send the corrected version, and so on. ‚Äù  And this approach can be justified in the situation of ‚Äúmade and forgotten‚Äù - when the created program will never have to be finished-redone. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Modern flexible development methods offer a completely different approach to creating software.  Making changes to the program is considered not as a kind of hypothetical and unlikely possibility, but a completely ordinary part of the work.  This encourages developers to create code that is easier to change.  To simplify code changes, it is recommended to make the application architecture loosely coupled.  And automated tests are designed to reduce the hidden effects of changes.  They allow you to detect the deviation of the program from the expected behavior at the earliest stage of making changes. <br>  Some time ago I realized a very simple truth that put everything in its place.  No need to consider tests as a kind of addition to the code.  Tests are the same part of the code as its architecture.  Tests are the part of the code that makes it adapted to make changes with minimal consequences.  The better the architecture is, the easier it is to create tests.  The better the tests are organized, the fewer the hidden consequences will be after making the changes.  And the more reliable and better will be the resulting code. <br><br>  Every time a question arises to write or not to write a test - repeat the mantra to yourself: <br>  <b>"The test is not an addition to the code, but an important part of it</b> . <b>"</b> <br><br><h4>  Formulation of the problem </h4><br>  So, the task has been set: to organize automatic transfer of files between two computers over a network. <br>  Specification: Files that appear in a folder on one computer must in some magical way be transferred to a folder on another computer. <br><blockquote>  - Yes, it's DropBox!  - you say. <br>  Yes, cloud storage could be used for these purposes, if not for a few but: <br>  1. Files are slightly confidential, the client does not want to shy to upload them to the cloud <br>  2. File transfer must be logged in detail, so that later the receiving party could not say ‚Äúwas there a <s>boy a</s> file?‚Äù <br></blockquote><br>  As magic, it is supposed to use a service that tracks changes in a folder on a disk and sends all new files to a web service that is running on the recipient computer.  Every successful and unsuccessful transfer attempt must be logged.  Moreover, the logging is carried out both by the sender and by the recipient. <br>  As additional requirements, there is the use of WCF and IIS, but this is not so interesting. <br><br><h4>  We design architecture </h4><br><h5>  Solve the forehead </h5><br>  At first glance, the program architecture is extremely simple.  We start the cycle of waiting for a file in the incoming folder, and each new file is read and sent to the service on another computer, which receives data and writes to a certain folder. <br><br><img src="https://habrastorage.org/storage2/a58/d63/bb9/a58d63bb9fef3cf9d45340016f9fe996.png"><br><br>  The components of the record in the protocol can be reused - which is very good.  Everything is simple and clear, we take the keyboard, quickly create a project ... <br><br>  Stop stop stop.  What about TDD?  Well, let's think about how we will test such a program.  And, in fact, the only way is to write, run and see what happens.  And clean up errors as they are detected.  Those.  A quick and easy way to write a program leads us to the ‚Äúclassic‚Äù way of development. <br><br><h5>  And now let's not hurry </h5><br>  and look at the task a little more carefully. <br>  If you look a little closer, you can see that, despite the apparent difference between the services, they have a lot in common.  Indeed, each of them solves the problem of transferring a file from the source to the receiver, simultaneously recording the progress of the transfer.  Only source / receiver types are changed. <br><br><img src="https://habrastorage.org/storage2/639/ed3/ba1/639ed3ba1131691d7c6b5dc1e935b468.png"><br><br>  Moreover, classes that implement the interfaces of the source, receiver and transmitter are very simple and easily amenable to automated testing.  And from these classes it is easy, as from a constructor, to send and receive services. <br><img src="https://habrastorage.org/storage2/d51/e40/aaf/d51e40aafa11df1ae31ef3ce9fd0fd3b.png"><img src="https://habrastorage.org/storage2/9e5/15f/b2f/9e515fb2f6267a1bd9657c4bdaee595e.png"><br><br><h4>  We write tests and the program </h4><br>  TDD classics require you to write tests first - then classes.  Honestly, I don‚Äôt always succeed - apparently, you need to continue meditating.  :-) However, it was surprisingly easy to write working and testing code at the same time.  Most often, I first wrote a draft of the working code, then tests for the corresponding class or method, and then brought the code to a working state. <br><br>  In the process of writing tests, I discovered the beauty of using mock-objects (on the advice of <a href="http://habrahabr.ru/users/dorofeevilya/" class="user_link">dorofeevilya,</a> I used <a href="http://www.hibernatingrhinos.com/open-source/rhino-mocks">Rhino Mocks</a> ) to test the behavior of classes that depend on abstract interfaces.  Here, for example, a test that verifies that in case of an error, the transmitter will write a corresponding message to the protocol. <br><pre><code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">TestMethod</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_that_failed_transfer_logs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  var mock = new MockRepository(); var writerMock = mock.StrictMock&lt;IFileReceiver&gt;(); var logMock = mock.StrictMock&lt;INoDateLogger&gt;(); //   var exception = new InvalidOperationException("transfer failed"); Expect.Call(() =&gt; writerMock.Receive(fileName, fileData)).Throw(exception); Expect.Call(() =&gt; logMock.WriteEvent(FileTransferEvent.Send, fileName, FileTransferStatus.Failed, MessageFormatter.AttemptFailed(1, exception))); mock.ReplayAll(); //  var sender = new FileSender (writerMock, logMock); sender.SendFile(fileName, fileData); //   mock.VerifyAll(); }</span></span></code> </pre> <br><br><h4>  Run the program </h4><br>  So, all classes are written, all tests are successfully passed.  I do the first run without using a web service, in order not to introduce additional difficulties - you first need to check the overall performance.  I can easily do this by replacing the receiver-service with the receiver-folder.  It turns out a program that transfers files from one folder to another.  The result is impressive - the program has earned on the first launch! <br><br>  Complicate the task - connect the web service.  It takes a couple of hours to deploy IIS, configure and configure the service.  Another 25 minutes to write and connect a class that implements the receiver interface for the web service.  And, as soon as all infrastructure problems were solved - the program earned!  Those.  I had no problems with the unexpected behavior of the written classes in real conditions. <br><br><h4>  And draw conclusions </h4><br>  Frankly, the result impressed me greatly.  Yes, development took more time than I usually take to develop applications of this level of complexity.  But the debugging stage, which usually takes a considerable amount of time, was practically absent!  Increasing development time, I, first of all, associate with my lack of experience in writing tests using mock-s.  Now I am doing the next project, using the same principles, and writing tests no longer takes me so much time. <br><br>  It is safe to say that at the initial stage, the introduction of TDD will require some rebuilding of the worldview and is guaranteed to lead to an increase in development time.  This should be considered simply as an investment in the development of a new technology.  Programs created using the principles of TDD, are not only better, but also much better suited to make changes and additions.  And when writing tests becomes a habit, it doesn‚Äôt take as much time as it did at first, but automatically. </div><p>Source: <a href="https://habr.com/ru/post/144412/">https://habr.com/ru/post/144412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../144407/index.html">How do we find the inaccessible model</a></li>
<li><a href="../144408/index.html">Release LLVM 3.1</a></li>
<li><a href="../144409/index.html">Create a web form to send faxes through Asterisk</a></li>
<li><a href="../144410/index.html">What old games do you think are old school?</a></li>
<li><a href="../144411/index.html">QScintilla: highlight syntax in application</a></li>
<li><a href="../144414/index.html">OutWiker. Open Source program for storing notes</a></li>
<li><a href="../144416/index.html">Argparse - Parsing arguments and command line parameters with ease</a></li>
<li><a href="../144417/index.html">CISCO ACE. Part 2: balancing remote servers and applications</a></li>
<li><a href="../144418/index.html">Data exchange between a web application and MantisBT</a></li>
<li><a href="../144419/index.html">Python binding for libsass. Exclusively for Habr</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>