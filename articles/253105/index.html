<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Age of JIT compiling. Part II. CLR is watching you</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the theme of the .NET JIT compilation , today we will look at the dispatching of methods around interfaces, generics (both classes and indi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Age of JIT compiling. Part II. CLR is watching you</h1><div class="post__text post__text-html js-mediator-article">  Continuing the <a href="http://habrahabr.ru/post/248775/">theme of the</a> .NET <a href="http://habrahabr.ru/post/248775/">JIT compilation</a> , today we will look at the dispatching of methods around interfaces, generics (both classes and individual methods, along with real signatures);  debug release releases with optimizations;  let's deal with the true purpose of the System .__ Canon type (this is not what you thought). <br><a name="habracut"></a><br><h3>  <font color="#2E74B5">Environment setup</font> </h3><br>  Before proceeding further, we need to prepare Visual Studio for debugging release builds. <br><br>  We‚Äôll use VS 2013, so to use SOS.dll you‚Äôll have to enable compatibility mode: <br><div class="spoiler">  <b class="spoiler_title">Tools -&gt; Options -&gt; Debugging -&gt; General</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/8a3/9e4/0fe/8a39e40fe4104fe7845bc2707fa2f89c.png"><br></div></div><br>  Next, <u>remove the</u> checkboxes here with: <br><ul><li>  Suppress JIT optimization on module load </li><li>  Enable Just My Code </li></ul><br>  You also need to enable Native Debugging support: <br> <code>Project Settings -&gt; Debug -&gt; Enable native code debugging</code> <br>  Now we proceed to our research. <br><br><h3>  <font color="#2E74B5">Interface dispatch stubs (Virtual Stub Dispatch)</font> </h3><br>  The CLR constantly monitors all parts of the code.  It has several strategies for updating native method code.  Exactly - not only HotSpot in Java has such functionality, or modern JS engines. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This functionality appeared in CLR 2.0 back in 2006.  And ... remained in much the same way + new heuristics. <br><br>  Especially the ‚Äúvigilant‚Äù environment monitors the interfaces. <br>  I hope you have already set up a studio for debug release code. <br><div class="spoiler">  <b class="spoiler_title">Consider an example:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { ICallable target = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FirstCallableImpl(); CallInterface(target); ICallable target2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SecondCallableImpl(); CallInterface(target2); } [MethodImpl(MethodImplOptions.NoInlining)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallInterface</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ICallable callable</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">1000000</span></span>; i++) { callable.DoSomething(); <span class="hljs-comment"><span class="hljs-comment">// place breakpoint } } } interface ICallable { void DoSomething(); } class FirstCallableImpl : ICallable { public void DoSomething() { } } class SecondCallableImpl : ICallable { public void DoSomething() { } }</span></span></code> </pre><br></div></div><br>  Let's start debugging.  Next, open the Disassembly window (Debug -&gt; Windows -&gt; Disassembly). <br><img src="https://habrastorage.org/files/1e2/bec/ef1/1e2becef17d344e68688e5d7fdba4ab0.png"><br><br>  Consider the instruction <code>call dword ptr ds:[00450010h]</code> . <br>  To find out the value at 0x00450010, open the memory window (Debug -&gt; Windows-&gt; Memory-&gt; Memory1). <br><img src="https://habrastorage.org/files/329/c79/81d/329c7981d3384160b03acdd61036dbb7.png"><br><br>  At this stage, the JIT has not yet created the necessary call node, so far the environment itself performs an ‚Äúinterpretation‚Äù of calling the interface method (this means, a linear search for the required method occurs in runtime). <br><br>  However, let's allow this code to be executed 2 more times and see that the value of the address <u>0x0450010</u> has changed: <br><img src="https://habrastorage.org/files/2a2/997/8f7/2a29978f70ab4b66a92bf9adfe4ccf47.png"><br><br>  To inspect the value 00457012, load the SOS.dll: <br> <code>Immediate window -&gt; .load sos</code> <br> <pre> <code class="markdown hljs">!u 00457012 Unmanaged code 00457012 813908314400 cmp dword ptr [ecx],443108h 00457018 0F85F32F0000 jne 0045A011 0045701E E9BD901D00 jmp 006300E0</code> </pre><br>  The <code>jmp 006300E0</code> is a call to the required interface method.  Check: <br><pre> <code class="markdown hljs">!u 006300E0 Normal JIT generated code ConsoleApplication1.FirstCallableImpl.DoSomething() Begin 006300e0, size 1 &gt;&gt;&gt; 006300E0 C3 ret</code> </pre><br>  So ... With a method it is clear, but what for comparison happens in the instruction <code>cmp dword ptr [ecx],443108h</code> ? <br><pre> <code class="markdown hljs">!DumpMT 443108 EEClass: 00441378 Module: 00442c5c Name: ConsoleApplication1.FirstCallableImpl mdToken: 02000004 (C:\<span class="hljs-emphasis"><span class="hljs-emphasis">*path to project*</span></span>\InterfaceStubsTest.exe) BaseSize: 0xc ComponentSize: 0x0 Number of IFaces in IFaceMap: 1 Slots in VTable: 6</code> </pre><br>  Aha  We compare <b>this</b> to a type <i>matching FirstCallableImpl</i> (i.e. MethodTable) and, if <b>true,</b> call <i>FirstCallableImpl.DoSomething</i> (). <br>  The <code>jne 0045A011</code> is a fallback to a linear search, as it was before caching. <br><br>  When it comes to calling the following type - <i>SecondCallableImpl</i> , it will still be checked in the call node of FirstCallableImpl, and not SecondCallableImpl. <br><br>  But this is ineffective!  That is why, upon reaching a certain number of code call iterations, the environment will simply replace the given call node with the cache with (you guessed it) linear search. <br><blockquote>  Caching is very efficient if we call methods on collections, for example. </blockquote><br><h3>  <font color="#2E74B5">Generic types stubs</font> </h3><br>  The release of CLR 2.0 along with generics marked significant changes in the execution environment.  If before this only the <b>EEClass</b> structure was enough to describe a specific type, now the bundle <b>EEClass + MethodTable</b> structure is the current type. <br><br>  Moreover, for List &lt;string&gt; and List &lt;int&gt;, even EEClass will be different (about code-sharing will be slightly lower). <br><div class="spoiler">  <b class="spoiler_title">Consider an example:</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refTypeHolder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HolderOf&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intTypeHolder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HolderOf&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-comment"><span class="hljs-comment">// call JIT refTypeHolder.GetPointer(); intTypeHolder.GetPointer(); Console.Read(); // place breakpoint } } class HolderOf&lt;T&gt; { private readonly T _pointer; public HolderOf(T pointer) { _pointer = pointer; } public T GetPointer() { return _pointer; } }</span></span></code> </pre><br></div></div><br>  For inspection, use the command <code>!dumpheap</code> : <br><pre> <code class="markdown hljs">.load sos.dll !dumpheap -type HolderOf PDB symbol for mscorwks.dll not loaded Address MT Size 02d332c8 00f531e0 12 02d332d4 00f53268 12 total 2 objects Statistics: MT Count TotalSize Class Name 00f53268 1 12 ConsoleApplication1.HolderOf<span class="hljs-code"><span class="hljs-code">`1[[System.Int32, mscorlib]] 00f531e0 1 12 ConsoleApplication1.HolderOf`</span></span>1[[System.Object, mscorlib]] Total 2 objects</code> </pre><br>  As we can see, the environment has created two different specializations of the <code>HolderOf&lt;T&gt;</code> class <br><div class="spoiler">  <b class="spoiler_title">! dumpmt -md 00f53268 (HolderOf &lt;int&gt;)</b> <div class="spoiler_text"><pre> <code class="markdown hljs">!dumpmt -md 00f53268 EEClass: 00f514cc Module: 00f52c5c Name: ConsoleApplication1.HolderOf<span class="hljs-code"><span class="hljs-code">`1[[System.Int32, mscorlib]] mdToken: 02000006 (C:\*path to samples*\InterfaceStubsTest.exe) BaseSize: 0xc ComponentSize: 0x0 Number of IFaces in IFaceMap: 0 Slots in VTable: 6 -------------------------------------- MethodDesc Table Entry MethodDesc JIT Name 66ae6a30 66964968 PreJIT System.Object.ToString() 66ae6a50 66964970 PreJIT System.Object.Equals(System.Object) 66ae6ac0 669649a0 PreJIT System.Object.GetHashCode() 66b57940 669649c4 PreJIT System.Object.Finalize() 00f5c088 00f53250 JIT ConsoleApplication1.HolderOf`</span></span>1[[System.Int32, mscorlib]]..ctor(Int32) 00f5c090 00f5325c NONE ConsoleApplication1.HolderOf`1[[System.Int32, mscorlib]].GetPointer()</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">! dumpmt -md 00f531e0 (HolderOf &lt;object&gt;)</b> <div class="spoiler_text"><pre> <code class="markdown hljs">!dumpmt -md 00f531e0 EEClass: 00f51438 Module: 00f52c5c Name: ConsoleApplication1.HolderOf<span class="hljs-code"><span class="hljs-code">`1[[System.Object, mscorlib]] mdToken: 02000006 (C:\*path to samples*\InterfaceStubsTest.exe) BaseSize: 0xc ComponentSize: 0x0 Number of IFaces in IFaceMap: 0 Slots in VTable: 6 -------------------------------------- MethodDesc Table Entry MethodDesc JIT Name 66ae6a30 66964968 PreJIT System.Object.ToString() 66ae6a50 66964970 PreJIT System.Object.Equals(System.Object) 66ae6ac0 669649a0 PreJIT System.Object.GetHashCode() 66b57940 669649c4 PreJIT System.Object.Finalize() 00f5c068 00f53154 JIT ConsoleApplication1.HolderOf`</span></span>1[[System.<span class="hljs-strong"><span class="hljs-strong">__Canon, mscorlib]]..ctor(System.__</span></span>Canon) 00f5c070 00f53160 NONE ConsoleApplication1.HolderOf`1[[System.__Canon, mscorlib]].GetPointer()</code> </pre><br></div></div><br><br>  In the above dump, we are interested in <b><code>HolderOf&lt;T&gt;.GetPointer()</code></b> .  Consider: <br><div class="spoiler">  <b class="spoiler_title">! dumpmd 00f5325c (HolderOf &lt;int&gt; .GetPointer ())</b> <div class="spoiler_text"><pre> <code class="markdown hljs">!dumpmd 00f5325c Method Name: ConsoleApplication1.HolderOf`1[[System.Int32, mscorlib]].GetPointer() Class: 00f514cc MethodTable: 00f53268 mdToken: 0600000b Module: 00f52c5c IsJitted: yes CodeAddr: 01090318</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">! dumpmd 00f53160 (HolderOf &lt;object&gt; .GetPointer ())</b> <div class="spoiler_text"><pre> <code class="markdown hljs">!dumpmd 00f53160 Method Name: ConsoleApplication1.HolderOf`1[[System.__Canon, mscorlib]].GetPointer() Class: 00f51438 MethodTable: 00f53178 mdToken: 0600000b Module: 00f52c5c IsJitted: yes CodeAddr: 010902b8</code> </pre><br></div></div><br><table><tbody><tr><th></th><th>  HolderOf &lt;object&gt; </th><th>  HolderOf &lt;int&gt; </th></tr><tr><td>  MethodDesc </td><td>  00f53160 </td><td>  00f5325c </td></tr><tr><td>  CodeAddr </td><td>  01090318 </td><td>  010902b8 </td></tr><tr><td>  Initiation type </td><td>  HolderOf`1 [[System .__ Canon, mscorlib]] </td><td>  HolderOf`1 [[System.Int32, mscorlib]] </td></tr></tbody></table><br>  So, we see that not only Methodtable differs, but also native code (CodeAddr). <br><br>  And now the most interesting - where did <b>System.Object</b> go for Holderof &lt;object&gt; ?!  What is the <b>System .__ Canon</b> ? <br>  Meet: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Serializable()</span></span>] [ClassInterface(ClassInterfaceType.AutoDual)] [ComVisible(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> __<span class="hljs-title"><span class="hljs-title">Canon</span></span> { }</code> </pre><br><blockquote>  In short, it is usually said that for reference types the medium uses the Canon System .__ type to share the code. <br>  <b><u>But that's not the point.</u></b>  <b><u>Seriously.</u></b> </blockquote><br>  The fact is that generic types can contain cyclical dependencies on other types, which is fraught with the endless creation of specializations for code.  For example: <br><div class="spoiler">  <b class="spoiler_title">Generics cyclomatic dependencies</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GenericClassOne</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T field; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GenericClassTwo</span></span>&lt;<span class="hljs-title"><span class="hljs-title">U</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GenericClassThree&lt;GenericClassOne&lt;U&gt;&gt; field } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GenericClassThree</span></span>&lt;<span class="hljs-title"><span class="hljs-title">S</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GenericClassTwo&lt;GenericClassOne&lt;S&gt;&gt; field } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine((<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> GenericClassTwo&lt;<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;()).ToString()); Console.Read(); } }</code> </pre><br></div></div><br>  However, this code will not fall and will output <b>GenericClassTwo`1 [System.Object]</b> . <br><br>  <i>- So what was there about addiction?</i>  <i>(note: thoughts out loud).</i> <br><br>  <b>A type loader</b> (also known as a type loader) scans each generic type for the presence of a circular dependency and assigns a priority (the so-called LoadLevel for a class).  Although all specializations for ref-types have System .__ Canon as a type argument - this is a consequence, not a reason. <br><br>  Loading phases (they are also ClassLoadLevel): <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> ClassLoadLevel { CLASS_LOAD_BEGIN, CLASS_LOAD_UNRESTOREDTYPEKEY, CLASS_LOAD_UNRESTORED, CLASS_LOAD_APPROXPARENTS, CLASS_LOAD_EXACTPARENTS, CLASS_DEPENDENCIES_LOADED, CLASS_LOADED, CLASS_LOAD_LEVEL_FINAL = CLASS_LOADED, };</code> </pre><br>  For SSLCI (Rotor), the code responsible for scanning is in the <code>sscli20/clr/src/vm/Generics.cpp</code> file: <br><div class="spoiler">  <b class="spoiler_title">Generics.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">BOOL Generics::CheckInstantiationForRecursion(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nGenericClassArgs, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TypeHandle pGenericArgs[]) { CONTRACTL { NOTHROW; GC_NOTRIGGER; } CONTRACTL_END; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nGenericClassArgs == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TRUE; _ASSERTE(pGenericArgs); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PerIterationData</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TypeHandle * genArgs; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> index; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numGenArgs; }; PerIterationData <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[MAX_GENERIC_INSTANTIATION_DEPTH]; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>].genArgs = pGenericArgs; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>].numGenArgs = nGenericClassArgs; <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>].index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curDepth = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Walk over each instantiation, doing a depth-first search looking for any // instantiation with a depth of over 100, in an attempt at flagging // recursive type definitions. We're doing this to help avoid a stack // overflow in the loader. // Avoid recursion here, to avoid a stack overflow. Also, this code // doesn't allocate memory. while(curDepth &gt;= 0) { PerIterationData * cur = &amp;stack[curDepth]; if (cur-&gt;index == cur-&gt;numGenArgs) { // Pop curDepth--; if (curDepth &gt;= 0) stack[curDepth].index++; continue; } if (cur-&gt;genArgs[cur-&gt;index].HasInstantiation()) { // Push curDepth++; if (curDepth &gt;= MAX_GENERIC_INSTANTIATION_DEPTH) return FALSE; stack[curDepth].genArgs = cur-&gt;genArgs[cur-&gt;index].GetInstantiation(); stack[curDepth].numGenArgs = cur-&gt;genArgs[cur-&gt;index].GetNumGenericArgs(); stack[curDepth].index = 0; continue; } // Continue to the next item cur-&gt;index++; } return TRUE; }</span></span></code> </pre><br></div></div><br>  For CoreCLR, the code <a href="">has changed</a> towards OOP :) <br><br>  So, you figured out: reference types have a sharing code, meaningful ones don't ... And why? <br>  If it all comes down to the size of a type (ref is the word size; In32 is 4 bytes, double is 8 bytes, etc.), then it is possible to share it for DateTime and long. <br><br>  First, it is wrong in terms of semantics.  Second, the CLR developers decided not to. <br><br><h3>  <font color="#2E74B5">Generic method stubs</font> </h3><br>  We looked at code specialization for generic types, but what about the methods?  How to find individual methods outside the class? <br>  Consider an example: <br><div class="spoiler">  <b class="spoiler_title">Generic methods</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> refTypeHolder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HolderOf(); Test(refTypeHolder); Test2(refTypeHolder); Console.Read(); } [MethodImpl(MethodImplOptions.NoInlining)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HolderOf typeHolder</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { typeHolder.GetPointer&lt;Program&gt;(); } } <span class="hljs-comment"><span class="hljs-comment">// place breakpoint [MethodImpl(MethodImplOptions.NoInlining)] static void Test2(HolderOf typeHolder) { for (int i = 0; i &lt; 10; i++) { typeHolder.GetPointer&lt;object&gt;(); } } // place breakpoint } class HolderOf { [MethodImpl(MethodImplOptions.NoInlining)] public void GetPointer&lt;T&gt;() { Console.WriteLine(typeof(T)); } }</span></span></code> </pre><br></div></div><br>  At the breakpoint in the Disassembly window for the Test () method, you can see the following: <br><pre> <code class="markdown hljs">00000045 mov ecx,dword ptr [ebp-3Ch] 00000048 mov edx,10031B8h 0000004d cmp dword ptr [ecx],ecx 0000004f call FFE8BF40</code> </pre><br>  And for Test2 () - the following: <br><pre> <code class="markdown hljs">00000045 mov ecx,dword ptr [ebp-3Ch] 00000048 mov edx,1003574h 0000004d cmp dword ptr [ecx],ecx 0000004f call FFE8BE40</code> </pre><br><blockquote>  The <b>ECX</b> register contains a pointer to this (calling convention - FastCall), but after all, GetPointer () has zero arguments, what then is written to the <b>EDX</b> ?! </blockquote><br>  We investigate: <br><div class="spoiler">  <b class="spoiler_title">! dumpmd 10031B8 (from Test ())</b> <div class="spoiler_text"><pre> <code class="markdown hljs">!dumpmd 10031B8 Method Name: ConsoleApplication1.HolderOf.GetPointer[<span class="hljs-string"><span class="hljs-string">[ConsoleApplication1.Program, InterfaceStubsTest</span></span>]]() Class: 01001444 MethodTable: 01003118 mdToken: 0600000e Module: 01002c5c IsJitted: no CodeAddr: ffffffffffffffff</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">! dumpmd 1003574 (from Test2 ())</b> <div class="spoiler_text"><pre> <code class="markdown hljs">!dumpmd 1003574 Method Name: ConsoleApplication1.HolderOf.GetPointer[<span class="hljs-string"><span class="hljs-string">[System.Object, mscorlib</span></span>]]() Class: 01001444 MethodTable: 01003118 mdToken: 0600000e Module: 01002c5c IsJitted: no CodeAddr: ffffffffffffffff</code> </pre><br></div></div><br>  Aha  The <b>MethodDesc</b> structure is <b>passed</b> , which contains a pointer to MethodTable (I want to note that both descriptors point to the same MethodTable <u>0x01003118</u> ) and serves as a source of metadata. <br><br>  Thus, when calling generic methods, an additional parameter is passed with MethodDesc. <br>  The addresses <u>FFE8BF40</u> and <u>FFE8BE40</u> are the springboard, which gives (forward) the real specialized (for int, object, etc.) native code. <br><br>  Since  the descriptor itself also stores generic parameters in itself; this also results in saving on the number of arguments passed in the case of, for example, several generic parameters <u>Some &lt;T, TU, TResult&gt; ()</u> . <br><br></div><p>Source: <a href="https://habr.com/ru/post/253105/">https://habr.com/ru/post/253105/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253095/index.html">Lectures Technopark. 1 semester C / C ++</a></li>
<li><a href="../253097/index.html">AMI UEFI firmware features</a></li>
<li><a href="../253099/index.html">The digest of interesting materials for mobile developer # 94 (March 10-15)</a></li>
<li><a href="../253101/index.html">Translation of the book "Expressive Javascript" in pdf</a></li>
<li><a href="../253103/index.html">Top10 mistakes made when developing on AngularJS</a></li>
<li><a href="../253107/index.html">Yboard - Yii bulletin board engine</a></li>
<li><a href="../253111/index.html">Create effective styles for carousels</a></li>
<li><a href="../253115/index.html">Review of the most interesting materials on data analysis and machine learning ‚Ññ39 (March 9 - 15, 2015)</a></li>
<li><a href="../253119/index.html">Random and phantom domains (random subdomain, phantom domain), DDoS attack on caching DNS</a></li>
<li><a href="../253121/index.html">Beginner's HTTP caching headers guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>