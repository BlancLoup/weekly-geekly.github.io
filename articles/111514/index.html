<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Mt: C language for heavily loaded servers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Greetings, habrovchane! 

 I want to propose to discuss the idea of ‚Äã‚Äãhow to simplify the writing of server programs in C by introducing additional la...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Mt: C language for heavily loaded servers</h1><div class="post__text post__text-html js-mediator-article">  Greetings, habrovchane! <br><br>  I want to propose to discuss the idea of ‚Äã‚Äãhow to simplify the writing of server programs in C by introducing additional language tools.  I believe that this topic may be of interest to all developers who have had to deal with writing multithreaded or asynchronous code. <br><br>  At the moment I have almost completed writing the tools - parser generator, C parser and partially C ++ parser - which allows you to start writing a translator that supports language extensions, which I will talk about here.  But before continuing to work, I would like to consult with colleagues and find like-minded people. <br><a name="habracut"></a><br>  It's about multi-threaded asynchronous servers.  Asynchronous - that is, using customer-based event-based service logic (epoll / kqueue), in which multiple clients are served simultaneously by a single thread.  Multi-threaded means ready to take advantage of modern multi-core processors, performing parallel servicing of connections by several threads in a single process. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Asynchronous service model allows you to create servers that are most prepared for work with a really high load.  But asynchronous (non-blocking) code is harder to write than synchronous, blocking.  In addition, it is much more difficult to write asynchronous multithreaded code: it is too easy to make a mistake when synchronizing access to shared data, and it is too difficult to detect such errors.  This leads to the fact that in practice it is often wiser to completely abandon support for multithreading. <br><br>  Having accumulated some experience in writing such programs, I began to notice that the solution of the main problems of synchronization of streams is solved using typical methods, the use of which could be automated at the language level, greatly simplifying the task for the developer.  Then I saw that using a similar approach, it is possible to simplify the writing of asynchronous event handling code.  It is because of the apparent commonality of solutions that I propose a single set of language additions for these unrelated tasks. <br><br>  The ideas are quite simple, therefore, in order not to create a sense of complexity, I will list the main points on the additions to C. I will call these additions the ‚ÄúMt language‚Äù. <br><br>  So Mt is: <ul><li>  Automatic management of mutexes to synchronize access to objects; </li><li>  Asynchronous processing chains, written as regular sequential functions; </li><li>  Annotation - additional descriptions of program elements for static analysis of source texts; </li><li>  Built-in link counting mechanism; </li><li>  Borrowing the most useful features from C ++; </li><li>  Compatible with C, hard reference to C ABI.  The initial implementation is a translator from Mt to C. </li></ul>  Let me explain why C is selected as the base, not C ++.  The main reason is the significantly higher complexity of C ++ from the point of view of the semantic analysis of source texts.  Over the past year I have attempted to write a C ++ parser and a static analysis system for C ++ code.  The result is that the C parser and semantics analysis in the C style were fairly easy, and the C ++ parsing is far from complete: the workload is too large.  Therefore, I decided that good practical results can be achieved by relying on pure C and adding it to C ++ features that are fairly simple to implement. <br><br>  Further I will tell about each addition in more detail.  I cite some code examples in C ++, because in this way they are easier to relate to the equivalent code on Mt. <br><br><h4>  1. Automatic Mutex Management </h4><br>  Consider the common query processing scheme.  Let we have some object of class MyFrontend, representing the implementation of our server.  After receiving and decoding a request from a client, we call the processRequest () server object method.  This method performs some operations that cause a change in the internal state of the server.  Let us assume, for example, that as a result of processing a request, the count of requests for num_requests is increased: <br><br> <code><font color="black"><font color="#0000ff">class</font> MyFrontend <br> <font color="#008000">{</font> <br> <font color="#0000ff">private</font> <font color="#008080">:</font> <br> Mutex state_mutex <font color="#008080">;</font> <br> <font color="#0000ff">unsigned</font> num_requests <font color="#008080">;</font> <br> <br> <font color="#0000ff">public</font> <font color="#008080">:</font> <br> <font color="#0000ff">void</font> processRequest <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> state_mutex. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#000040">++</font> num_requests <font color="#008080">;</font> <br> state_mutex. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <font color="#008080">;</font></font></code> <br> <br>  Mt frees us from the need for manual synchronization: <br><br> <code><font color="black">async object MyFrontend <br> <font color="#008000">{</font> <br> <font color="#0000ff">private</font> <font color="#008080">:</font> <br> <font color="#0000ff">unsigned</font> num_requests <font color="#008080">;</font> <br> <br> <font color="#0000ff">public</font> <font color="#008080">:</font> <br> async <font color="#0000ff">void</font> processRequest <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#000040">++</font> num_requests <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <font color="#008080">;</font></font></code> <br> <br>  async object declares a class of thread safe objects.  Such objects will be called asynchronous.  The given code example on Mt is translated into code equivalent to the given C ++ example. <br><br>  Now suppose that in order to process a request, MyFrontend should call the doSomething () method of the MyBackend object, passing the num_back backend access counter as a parameter.  In addition, we do not want to think about the possibility of deadlocks and want everything to work with non-recursive mutexes.  To do this, we need to free state_mutex before calling MyBackend: <br><br> <code><font color="black"><font color="#0000ff">class</font> MyFrontend <br> <font color="#008000">{</font> <br> <font color="#0000ff">private</font> <font color="#008080">:</font> <br> Mutex state_mutex <font color="#008080">;</font> <br> <font color="#0000ff">unsigned</font> num_requests <font color="#008080">;</font> <br> <font color="#0000ff">unsigned</font> num_back <font color="#008080">;</font> <br> MyBackend <font color="#000040">*</font> backend <font color="#008080">;</font> <br> <br> <font color="#0000ff">public</font> <font color="#008080">:</font> <br> <font color="#0000ff">void</font> processRequest <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> state_mutex. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#000040">++</font> num_back <font color="#008080">;</font> <br> <font color="#0000ff">unsigned</font> tmp_num_back <font color="#000080">=</font> tmp_num_back <font color="#008080">;</font> <br> state_mutex. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> backend <font color="#000040">-</font> <font color="#000080">&gt;</font> doSomething <font color="#008000">(</font> tmp_num_back <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> state_mutex. <font color="#007788">lock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#000040">++</font> num_requests <font color="#008080">;</font> <br> state_mutex. <font color="#007788">unlock</font> <font color="#008000">(</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <font color="#008080">;</font></font></code> <br> <br>  The same on Mt: <br><br> <code><font color="black">async object MyFrontend <br> <font color="#008000">{</font> <br> <font color="#0000ff">private</font> <font color="#008080">:</font> <br> <font color="#0000ff">unsigned</font> num_requests <font color="#008080">;</font> <br> <font color="#0000ff">unsigned</font> num_back <font color="#008080">;</font> <br> MyBackend <font color="#000040">*</font> backend <font color="#008080">;</font> <br> <br> <font color="#0000ff">public</font> <font color="#008080">:</font> <br> async <font color="#0000ff">void</font> processRequest <font color="#008000">(</font> <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> call backend <font color="#000040">-</font> <font color="#000080">&gt;</font> doSomething <font color="#008000">(</font> <font color="#000040">++</font> num_back <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#000040">++</font> num_requests <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <font color="#008080">;</font></font></code> <br> <br>  The Mt translator independently inserts operations with state_mutex and enters a temporary variable to pass the parameter.  The call operator is introduced in order to emphasize that at the time of calling the asynchronous method of another object, we release the state_mutex lock.  In addition, it allows us to explicitly prohibit the call to asynchronous methods in expressions. <br><br>  In addition to the examples given, a number of other use cases of locks are automated: waiting for events (events are usually used in conjunction with a mutex protecting the wait completion condition), calling an asynchronous method of an object from another method of the same object. <br><br>  Thus, we minimize the risk of making a mistake while managing a simple lock on the state of an object.  According to my observations, if the access to the object is synchronized using not one but several locks, then most likely the design fails: either divide the object into several independent objects, or merge the locks into one.  Therefore, automating the simplest case with one mutex, we solve most of the synchronization problems.  Ability to perform synchronization in manual mode and using other primitives while <br>  persists. <br><br><h4>  2. Asynchronous processing chains </h4><br>  In my opinion, this is the most interesting and unusual idea.  I will explain with an example illustrating the operation of a real service. <br><br>  Suppose our server is a frontend photohost.  We want to realize the return to customers of HTML-pages with photos of users.  The page displays information from the photo owner‚Äôs profile and the photo itself.  Photos can be watched only by friends of photo owners.  Thus, in order to respond to an HTTP request, you need to collect the necessary information by polling a number of internal services. <br><br>  Request processing algorithm: <ol><li>  Send the user‚Äôs cookie authorization check server to identify it (check_auth); </li><li>  After checking the authorization, send a request to the server serving the social graph to check whether users are friends (check_friends); </li><li>  Send a request to the owner of the photo (get_userinfo); </li><li>  After receiving responses from check_friends and get_userinfo, generate an HTML page and send it to the client. </li></ol>  Operation 2 can be performed only after receiving a response to request 1. Request 3 does not depend on requests 1 and 2 and we want it to run in parallel with them. <br><br>  Let's make a sketch of the implementation in C. This example can be disregarded.  His task is to show how cumbersome the manual implementation of even such a simple asynchronous processing chain is: <br><br> <code><font color="black"><font color="#666666">//    .</font> <br> <font color="#0000ff">typedef</font> <font color="#0000ff">struct</font> <font color="#008000">{</font> <br> <font color="#666666">// "" ,   .</font> <br> MReferenced parent_referenced <font color="#008080">;</font> <br> <font color="#666666">//      .</font> <br> MMutex state_mutex <font color="#008080">;</font> <br> <br> uint64_t owner_id <font color="#008080">;</font> <br> uint32_t photo_id <font color="#008080">;</font> <br> <br> <font color="#666666">//  'true',   .</font> <br> <font color="#0000ff">bool</font> cancel <font color="#008080">;</font> <br> <br> <font color="#666666">//    get_userinfo?</font> <br> <font color="#0000ff">bool</font> got_userinfo <font color="#008080">;</font> <br> <font color="#666666">//    ( ).</font> <br> uint32_t owner_carma <font color="#008080">;</font> <br> <br> <font color="#666666">//    check_friends?</font> <br> <font color="#0000ff">bool</font> got_friends <font color="#008080">;</font> <br> <font color="#008000">}</font> HttpPhotoData <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">void</font> http_photo_data_init <font color="#008000">(</font> HttpPhotoData <font color="#000040">*</font> data <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> m_referenced_init <font color="#008000">(</font> <font color="#008000">(</font> MReferenced <font color="#000040">*</font> <font color="#008000">)</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> m_mutex_init <font color="#008000">(</font> <font color="#000040">&amp;</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> state_mutex <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> cancel <font color="#000080">=</font> <font color="#0000ff">false</font> <font color="#008080">;</font> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> got_userinfo <font color="#000080">=</font> <font color="#0000ff">false</font> <font color="#008080">;</font> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> got_friends <font color="#000080">=</font> <font color="#0000ff">false</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">void</font> http_photo__get_userinfo_ret <font color="#008000">(</font> uin32_t owner_carma, <br> <font color="#0000ff">void</font> <font color="#000040">*</font> _data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">void</font> http_photo__check_auth_ret <font color="#008000">(</font> uint64_t client_id, <br> <font color="#0000ff">void</font> <font color="#000040">*</font> _data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">static</font> <font color="#0000ff">void</font> http_photo__end <font color="#008000">(</font> HttpPhotoData <font color="#000040">*</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#666666">//     .</font> <br> <font color="#0000ff">void</font> http_photo <font color="#008000">(</font> <font color="#0000ff">char</font> <font color="#000040">*</font> cookie_str, <br> uint64_t owner_id, <br> uint32_t photo_id <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> HttpPhotoData <font color="#000040">*</font> data <font color="#000080">=</font> m_malloc <font color="#008000">(</font> <font color="#0000dd">sizeof</font> <font color="#008000">(</font> HttpPhotoData <font color="#008000">)</font> <font color="#008000">)</font> <font color="#008080">;</font> <br> http_photo_data_init <font color="#008000">(</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> owner_id <font color="#000080">=</font> owner_id <font color="#008080">;</font> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> photo_id <font color="#000080">=</font> photo_id <font color="#008080">;</font> <br> <br> <font color="#008000">{</font> <br> m_referenced_ref <font color="#008000">(</font> <font color="#008000">(</font> MReferenced <font color="#000040">*</font> <font color="#008000">)</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> MCallbackDesc cb <font color="#008080">;</font> <br> m_callback_desc_init_refdata <font color="#008000">(</font> <font color="#000040">&amp;</font> cb, http_photod__get_userinfo_ret, data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> get_userinfo <font color="#008000">(</font> <font color="#000040">&amp;</font> cb, owner_id <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#008000">{</font> <br> m_referenced_ref <font color="#008000">(</font> <font color="#008000">(</font> MReferenced <font color="#000040">*</font> <font color="#008000">)</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> MCallbackDesc cb <font color="#008080">;</font> <br> m_callback_desc_init_refdata <font color="#008000">(</font> <font color="#000040">&amp;</font> cb, http_photod__check_auth_ret, data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> check_auth <font color="#008000">(</font> <font color="#000040">&amp;</font> cb, cookie_str <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> m_referenced_unref <font color="#008000">(</font> <font color="#008000">(</font> MReferenced <font color="#000040">*</font> <font color="#008000">)</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#666666">//   get_userinfo.</font> <br> <font color="#0000ff">static</font> <font color="#0000ff">void</font> http_photo__get_userinfo_ret <font color="#008000">(</font> uint32_t owner_carma, <br> <font color="#0000ff">void</font> <font color="#000040">*</font> _data <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> HttpPhotoData <font color="#000040">*</font> data <font color="#000080">=</font> <font color="#008000">(</font> HttpPhotoData <font color="#000040">*</font> <font color="#008000">)</font> _data <font color="#008080">;</font> <br> <br> m_mutex_lock <font color="#008000">(</font> <font color="#000040">&amp;</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> state_mutex <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> cancel <font color="#008000">)</font> <font color="#008000">{</font> <br> m_mutex_unlock <font color="#008000">(</font> <font color="#000040">&amp;</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> state_mutex <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> owner_carma <font color="#000080">=</font> owner_carma <font color="#008080">;</font> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> got_userinfo <font color="#000080">=</font> <font color="#0000ff">true</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> got_friends <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#666666">//     ,  .</font> <br> http_photo_end <font color="#008000">(</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> m_mutex_unlock <font color="#008000">(</font> <font color="#000040">&amp;</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> state_mutex <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#666666">//   check_auth.</font> <br> <font color="#0000ff">static</font> <font color="#0000ff">void</font> http_photo__check_auth_ret <font color="#008000">(</font> uint64_t client_id, <br> <font color="#0000ff">void</font> <font color="#000040">*</font> _data <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> HttpPhotoData <font color="#000040">*</font> data <font color="#000080">=</font> <font color="#008000">(</font> HttpPhotoData <font color="#000040">*</font> <font color="#008000">)</font> _data <font color="#008080">;</font> <br> <br> m_referenced_ref <font color="#008000">(</font> <font color="#008000">(</font> MReferenced <font color="#000040">*</font> <font color="#008000">)</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> MCallbackDesc cb <font color="#008080">;</font> <br> m_callback_desc_init_refdata <font color="#008000">(</font> <font color="#000040">&amp;</font> cb, http_photo__check_friends_ret, data <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> check_friends <font color="#008000">(</font> <font color="#000040">&amp;</font> cb, client_id, data <font color="#000040">-</font> <font color="#000080">&gt;</font> owner_id <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#666666">//   check_friends.</font> <br> <font color="#0000ff">static</font> <font color="#0000ff">void</font> http_photo__check_friends_ret <font color="#008000">(</font> <font color="#0000ff">bool</font> friends, <br> <font color="#0000ff">void</font> <font color="#000040">*</font> _data <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> HttpPhotoData <font color="#000040">*</font> data <font color="#000080">=</font> <font color="#008000">(</font> HttpPhotoData <font color="#000040">*</font> <font color="#008000">)</font> _data <font color="#008080">;</font> <br> <br> m_mutex_lock <font color="#008000">(</font> <font color="#000040">&amp;</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> state_mutex <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> cancel <font color="#008000">)</font> <font color="#008000">{</font> <br> m_mutex_unlock <font color="#008000">(</font> <font color="#000040">&amp;</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> state_mutex <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> got_friends <font color="#000080">=</font> <font color="#0000ff">true</font> <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> <font color="#000040">!</font> friends <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#666666">//   .  .</font> <br> data <font color="#000040">-</font> <font color="#000080">&gt;</font> cancel <font color="#000080">=</font> <font color="#0000ff">true</font> <font color="#008080">;</font> <br> m_mutex_unlock <font color="#008000">(</font> <font color="#000040">&amp;</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> state_mutex <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">return</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> got_userinfo <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#666666">//     ,  .</font> <br> http_photo_end <font color="#008000">(</font> data <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> m_mutex_unlock <font color="#008000">(</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> state_mutex <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> <font color="#666666">//   .</font> <br> <font color="#0000ff">static</font> <font color="#0000ff">void</font> http_photo_end <font color="#008000">(</font> HttpPhotoData <font color="#000040">*</font> data <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> photo_send_page <font color="#008000">(</font> data <font color="#000040">-</font> <font color="#000080">&gt;</font> owner_id, data <font color="#000040">-</font> <font color="#000080">&gt;</font> photo_id, data <font color="#000040">-</font> <font color="#000080">&gt;</font> owner_carma <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></font></code> <br> <br>  The resulting code is complex, it is difficult to read.  Most of the time while writing it was spent on routinely providing the necessary order of operations. <br><br>  Equivalent implementation on Mt: <br><br> <code><font color="black">async chain <font color="#0000ff">void</font> http_photo <font color="#008000">(</font> <font color="#0000ff">char</font> <font color="#000040">*</font> cookie_str, <br> uint64_t owner_id, <br> uint32_t photo_id <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> async call GetUserinfoCall get_userinfo <font color="#008000">(</font> owner_id <font color="#008000">)</font> <font color="#008080">;</font> <br> <br> async call check_auth <font color="#008000">(</font> cookie <font color="#008000">)</font> <font color="#008080">;</font> <br> gives uint64_t client_id <font color="#008080">;</font> <br> <br> async call check_friends <font color="#008000">(</font> client_id, owner_id <font color="#008000">)</font> <br> gives <font color="#0000ff">bool</font> friends <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> <font color="#000040">!</font> friends <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#666666">//  </font> <br> <font color="#0000ff">return</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <br> GetUserinfoCall gives uint32_t owner_carma <font color="#008080">;</font> <br> <br> <font color="#666666">//  HTTP-   .</font> <br> photo_send_page <font color="#008000">(</font> owner_id, photo_id, owner_carma <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#008000">}</font></font></code> <br> <br>  Please note that we have almost completely freed ourselves from the routine work of organizing the necessary order of execution.  In addition, the generated C-code can be used in multi-threaded programs. <br><br>  In the given example, two new operators are used: <ul><li>  The async call operator describes an asynchronous call.  Functions that can be used with this operator must have a special signature: the first parameter is the callback that will be called upon completion of the call.  A completion callback must necessarily be called for any outcome, be it a successful call, an internal error or a timeout. </li><li>  The operator gives sets the point at which you want to wait until the specified asynchronous call is completed.  gives gives to the scope a list of values ‚Äã‚Äãreturned by the call.  If the async call and gives operators are to be separated, then the async call call is called and the name of the call is given in the give (see GetUserinfoCall in the given example). </li></ul>  In addition to the demonstrated operators, the possibility of early processing of the results of asynchronous calls is provided so that you can break the chain if an error occurs before we reach the gives operator that corresponds to the failed call.  You can also specify an additional destructor for the data included in the chain state structure. <br><br>  The main work that Mt performs when translating asynchronous chains to C is as follows: <ul><li>  Defines a set of variables to be stored in the chain state structure (HttpPhotoData); </li><li>  It crushes the function into smaller ones.  Break points are async call statements; </li><li>  Provides the necessary order of execution, converting C operators violated by async call and gives operators to equivalent asynchronous constructions according to fixed rules. </li></ul>  It can be shown that each of these operations lends itself well to automation. <br><br>  Parallel execution of complex chains of operations that cannot be represented by a single function in Mt can be implemented using several different asynchronous chains.  That is, if the branches in the chain are so complex that they cannot be described by a single function, then a description can be constructed as a composition of several functions. <br><br>  With the help of Mt, we can describe cycles and conditional transitions, broken by waiting for answers from asynchronous calls, in the same simple and familiar form as when writing ordinary code.  Suppose we want to look for a value in three independent caches in turn: <br><br> <code><font color="black">async chain <font color="#0000ff">void</font> search <font color="#008000">(</font> <font color="#0000ff">int</font> key <font color="#008000">)</font> <br> <font color="#008000">{</font> <br> <font color="#0000ff">for</font> <font color="#008000">(</font> <font color="#0000ff">int</font> i <font color="#000080">=</font> <font color="#0000dd">0</font> <font color="#008080">;</font> i <font color="#000080">&lt;</font> <font color="#0000dd">3</font> <font color="#008080">;</font> i <font color="#000040">++</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> async call search_cache <font color="#008000">(</font> key, i <font color="#ff0000"><i>/* cache id */</i></font> <font color="#008000">)</font> <br> gives <font color="#0000ff">int</font> value <font color="#008080">;</font> <br> <br> <font color="#0000ff">if</font> <font color="#008000">(</font> value <font color="#000080">&gt;</font> <font color="#0000dd">0</font> <font color="#008000">)</font> <font color="#008000">{</font> <br> <font color="#0000dd">printf</font> <font color="#008000">(</font> <font color="#FF0000">"VALUE: %d <font color="#000099"><b>\n</b></font> "</font> , value <font color="#008000">)</font> <font color="#008080">;</font> <br> <font color="#0000ff">break</font> <font color="#008080">;</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font> <br> <font color="#008000">}</font></font></code> <br> <br>  Thus, for asynchronous processing chains, Mt can provide a qualitative leap in expressiveness and usability compared to C. <br><br><h4>  3. Annotation </h4><br>  Annotation is the introduction to the code of additional supporting information using annotation words.  Annotated words can stand anywhere where const and volatile qualifiers can stand.  All annotating words begin with a '$' character.  Examples: <br> <code><font color="black"><font color="#0000ff">int</font> <font color="#000040">*</font> $nonnull ptr <font color="#008080">;</font> <font color="#666666">//      NULL</font> <br> MyObject <font color="#000040">*</font> $heap myobj <font color="#008080">;</font> <font color="#666666">//       </font></font></code> <br> <br>  The Mt translator is also the basis for a static code review system that uses annotation for additional checks. <br><br><h4>  4. Borrowing C ++ Features </h4><br>  From the point of view of translator implementation, the most difficult feature of C ++ compared to C is the dependence of the semantic meaning of language constructs on the data types of the arguments.  This concerns, first of all, the rules for overloading function names (including operator overloading) and the rules for choosing templates with regard to partial specializations.  Such dependence means that in order to determine which particular function or template is used in the expression, you need to deduce the data types of all the arguments of the function or template.  This, in turn, requires a complete and accurate implementation of the type conversion rules.  All this is a fairly significant amount of work. <br><br>  At the same time, name overloading is a controversial property of the language.  For example, the creators of the Go language refused it, as there is a <a href="http://golang.org/doc/go_faq.html">meaningful entry in the FAQ</a> . <br><br>  In Mt, there will be no overloading of function names and operator overloading, multiple inheritance, exceptions, RTTI.  Templates without partial specialization are not so difficult to implement, and this is enough so that you can create generic container classes, so it is advisable to include templates in the language.  In the absence of name overloading, templates will become a much simpler and more concise tool: there will not be such opportunities for metaprogramming as in C ++. <br><br><h4>  5. Links and weak links </h4><br>  The absence of operator overloading does not make it possible to implement convenient analogs of smart pointers in Mt, such as std :: auto_ptr and boost :: shared_ptr.  Instead, at the language level, a link counting mechanism is proposed: <br> <code><font color="black"><font color="#0000ff">int</font> @a <font color="#008080">;</font> <font color="#666666">// </font> <br> <font color="#0000ff">int</font> @@b <font color="#008080">;</font> <font color="#666666">//  </font></font></code> <br> <br>  The basic version uses a simple reference counting.  Link counters embedded <br>  into each synchronous or asynchronous Mt object (object and async object).  With this approach to managing links, the programmer should avoid creating circular references that lead to memory leaks.  Weak links are used to break cycles.  In the future, it is possible to envisage the possibility of using a more sophisticated garbage collector, but now I do not see any need for this. <br><br>  In the absence of operator overloading, there is no need to support C ++ references in Mt (of the int &amp; a type). <br><br>  I note that the implementation of links at the language level allows you to get a more complete and convenient mechanism than you can build on C ++ templates. <br><br><h4>  Conclusion </h4><br>  I have outlined the main features that I am going to include in the Mt.  In addition to them, there are other ideas in the study aimed at simplifying development and reducing the expected number of errors in programs. <br><br>  Mt Translator is an open source project.  Currently, it exists as a parser of a subset of the C ++ language and lives in the svn repository <a href="https://mync.svn.sourceforge.net/svnroot/mync/trunk">mync.svn.sourceforge.net/svnroot/mync/trunk</a> under the working name ‚Äúscruffy‚Äù. <br><br>  If you have thoughts and ideas on adding or changing certain properties of C / C ++ languages, then I suggest to voice them: perhaps it is time for their practical testing. <br><br>  I invite you to participate in the project.  If you are looking for a topic for independent work that could provide new knowledge and experience, and if successful, turn into a high-quality and successful product, then a new language compiler can be an excellent choice.  If the problems targeted by Mt are not very relevant to you, then you may be interested in developing a C ++ parser and a system for static analysis of C / C ++ programs. <br><br>  Together we can do more! <br><br>  Thank you for attention. </div><p>Source: <a href="https://habr.com/ru/post/111514/">https://habr.com/ru/post/111514/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../111509/index.html">Role information modeling in programming</a></li>
<li><a href="../111510/index.html">A simple implementation of RC4 in C #</a></li>
<li><a href="../111511/index.html">Android PC Game Controller</a></li>
<li><a href="../111512/index.html">Threats Inside: we initialize channels of leakage of corporate information</a></li>
<li><a href="../111513/index.html">Reverse engineering android applications</a></li>
<li><a href="../111515/index.html">Corporate colors of sites and companies</a></li>
<li><a href="../111518/index.html">Where startups are hosted</a></li>
<li><a href="../111523/index.html">Note of a lazy typesetter on SCSS and Compass Framework</a></li>
<li><a href="../111524/index.html">Code Quality Assessment Tool in MS Visual Studio</a></li>
<li><a href="../111525/index.html">Debugging Flash Applications Under Linux</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>