<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Event Aggregator for Unity3d (Event Aggregator)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The idea to write your own advanced event aggregator for Unity3d is long overdue. After reading several articles on this topic, I realized that there ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Event Aggregator for Unity3d (Event Aggregator)</h1><div class="post__text post__text-html js-mediator-article">  The idea to write your own advanced event aggregator for Unity3d is long overdue.  After reading several articles on this topic, I realized that there is not enough ‚Äúcorrect‚Äù (within Unity3d) and aggregator that I need, all solutions are trimmed and do not have the necessary functionality. <br><br><h3>  Required functionality: </h3><br><ol><li>  Any class can subscribe to any event (often aggregators in a unit make subscribers a specific Gameobject) </li><li>  The possibility of double subscription of a specific instance to a specific event should be excluded (in standard tools, you should follow this yourself) </li><li>  Must be functional as a manual unsubscribe, as well as automatic, in case of deletion of an instance / disconnection of a mono-tech (I want to subscribe and not to steam, that the subscriber suddenly throws off his hoof) </li><li>  Events should be able to transfer data / links of any complexity (I want to subscribe to one line and get the entire data set without problems) </li></ol><a name="habracut"></a><br><h3>  Where to apply it </h3><br><ol><li>  This is ideal for a UI when there is a need to flush data from any object without any connection. </li><li>  Data change messages, a kind of reactive code analog. </li><li>  For injection dependencies </li><li>  Global Callbacks </li></ol><br><h3>  Weak spots </h3><br><ol><li>  Because of checks for dead subscribers and duplicates (cut out later), the code is slower than similar solutions </li><li>  The class / struct is used as the core of the event, so as not to allocate memory + upper problem, spamming is not recommended with events in the update) </li></ol><br><h3>  General ideology </h3><br>  The general ideology is that for us an event is a specific and relevant data package.  Suppose we pressed a button on the interface / joystick.  And we want to send an event with signs of pressing a specific button for further processing.  The result of pressing the processing is visual changes to the interface and some kind of action in logic.  Accordingly, there may be processing / subscription in two different places. <br><br>  <b>What the event body / data packet looks like in my case:</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Sample Event Body</b> <div class="spoiler_text"><pre><code class="javascript hljs">public struct ClickOnButtonEvent   {     public int ButtonID; <span class="hljs-comment"><span class="hljs-comment">//     enum    }</span></span></code> </pre> <br></div></div><br>  <b>Subscription to the event looks like:</b> <br><br><pre> <code class="javascript hljs">public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AddListener&lt;T&gt;(object listener, Action&lt;T&gt; action)</code> </pre><br>  To subscribe, we need to specify: <br>  An object that is a subscriber (usually it is the class itself in which the subscription is, but not necessary, you can specify the subscriber one of the instances of the classes from the class fields. <br>  Type / Event for which we subscribe.  This is the key essence of this aggregator, for us a certain type of class is an event that we listen to and process. <br>  Subscribe best in Awake and OnEnable; <br><br>  <b>Example</b> <br><br><pre> <code class="javascript hljs">public <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Example</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MonoBehaviour</span></span></span><span class="hljs-class"> </span></span>{ private <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Awake() { EventAggregator.AddListener&lt;ClickOnButtonEvent&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, ClickButtonListener); } private <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ClickButtonListener(ClickOnButtonEvent obj) { Debug.Log(<span class="hljs-string"><span class="hljs-string">"  "</span></span> + obj.ButtonID); } }</code> </pre><br><h3>  To make it clear what the chip is, consider a more difficult case. </h3><br>  <b>We have character icons that:</b> <br><ol><li>  Know which character they are attached to. </li><li>  Reflect the amount of mana, HP, exp, as well as statuses (stunning, blindness, fear, insanity) </li></ol><br>  <b>And here you can make several events.</b> <br><br>  To change indicators: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct CharacterStateChanges { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Character Character; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Hp; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Mp; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Xp; }</code> </pre> <br>  To change negative statuses: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> struct CharacterNegativeStatusEvent { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Character Character; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statuses Statuses; <span class="hljs-comment"><span class="hljs-comment">//enum  }</span></span></code> </pre><br>  Why do we pass the character class in both cases?  Here is the event subscriber and its handler: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ EventAggregator.AddListener&lt;CharacterNegativeStatusEvent&gt; (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, CharacterNegativeStatusListener); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CharacterNegativeStatusListener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(CharacterNegativeStatusEvent obj)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (obj.Character != _character) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; _currentStatus = obj.Statuses; }</code> </pre><br>  This is the marker by which we process the event and we understand that we need it. <br>  <b>Why not let us subscribe directly to the Character class?</b>  <b>And spam them?</b> <br>  This will be difficult to debug, better for a group of classes / events to create your own separate event. <br><br>  <b>Why, again, inside the event just do not put the Character and take everything from it?</b> <br>  So by the way, it is possible, but often in the classes there are visibility limitations, and the necessary data for the event may not be visible from the outside. <br><br>  <b>if the class is too heavy to use as a marker?</b> <br>  In fact, in most cases, the marker is not needed, the group of updated classes is rather a rarity.  Usually, an event needs one specific entity - the controller / model of the view, which usually displays the state of the 1st character.  And so there is always a banal solution - ID of different types (from inam, to complex hash, etc.). <br><br><h3>  What is under the hood and how does it work? </h3><br><div class="spoiler">  <b class="spoiler_title">Directly aggregator code</b> <div class="spoiler_text"><pre> <code class="java hljs">namespace GlobalEventAggregator <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> delegate <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> EventHandler&lt;T&gt;(T e); { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDebugable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> event EventHandler&lt;T&gt; _eventKeeper; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly Dictionary&lt;WeakReference, EventHandler&lt;T&gt;&gt; _activeListenersOfThisType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;WeakReference, EventHandler&lt;T&gt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> string Error = <span class="hljs-string"><span class="hljs-string">"null"</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HasDuplicates</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object listener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _activeListenersOfThisType.Keys.Any(k =&gt; k.Target == listener); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddToEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object listener, EventHandler&lt;T&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newAction = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference(listener); _activeListenersOfThisType.Add(newAction, action); _eventKeeper += _activeListenersOfThisType[newAction]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RemoveFromEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object listener)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentEvent = _activeListenersOfThisType.Keys.FirstOrDefault(k =&gt; k.Target == listener); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentEvent != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { _eventKeeper -= _activeListenersOfThisType[currentEvent]; _activeListenersOfThisType.Remove(currentEvent); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventContainer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object listener, EventHandler&lt;T&gt; action)</span></span></span><span class="hljs-function"> </span></span>{ _eventKeeper += action; _activeListenersOfThisType.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WeakReference(listener), action); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_activeListenersOfThisType.Keys.Any(k =&gt; k.Target.ToString() == Error)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> failObjList = _activeListenersOfThisType.Keys.Where(k =&gt; k.Target.ToString() == Error).ToList(); foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fail in failObjList) { _eventKeeper -= _activeListenersOfThisType[fail]; _activeListenersOfThisType.Remove(fail); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_eventKeeper != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) _eventKeeper(t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> string </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ string info = string.Empty; foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c in _activeListenersOfThisType.Keys) { info += c.Target.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventAggregator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;Type, object&gt; GlobalListeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, object&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EventAggregator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SceneManager.sceneUnloaded += ClearGlobalListeners; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClearGlobalListeners</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Scene scene)</span></span></span><span class="hljs-function"> </span></span>{ GlobalListeners.Clear(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> AddListener&lt;T&gt;(object listener, Action&lt;T&gt; action) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = typeof(T); EventHandler&lt;T&gt; handler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler&lt;T&gt;(action); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalListeners.ContainsKey(key)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lr = (EventContainer&lt;T&gt;)GlobalListeners[key]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lr.HasDuplicates(listener)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; lr.AddToEvent(listener, handler); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } GlobalListeners.Add(key, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventContainer&lt;T&gt;(listener, handler)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Invoke&lt;T&gt;(T data) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = typeof(T); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!GlobalListeners.ContainsKey(key)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventContainer = (EventContainer&lt;T&gt;)GlobalListeners[key]; eventContainer.Invoke(data); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> RemoveListener&lt;T&gt;(object listener) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key = typeof(T); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GlobalListeners.ContainsKey(key)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> eventContainer = (EventContainer&lt;T&gt;)GlobalListeners[key]; eventContainer.RemoveFromEvent(listener); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> string </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ string info = string.Empty; foreach (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> listener in GlobalListeners) { info += <span class="hljs-string"><span class="hljs-string">"     "</span></span> + listener.Key.ToString() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = (IDebugable)listener.Value; info += t.DebugInfo() + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> info; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDebugable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">string </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DebugInfo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } }</code> </pre> <br></div></div><br>  <b>Let's start with the main</b> <br><br>  This is a dictionary in which the key is the type and the value is the container. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventContainer</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IDebugable</span></span></span></span></code> </pre> <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Dictionary&lt;Type, object&gt; GlobalListeners = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;Type, object&gt;();</code> </pre> <br>  Why do we store the container as an object?  The dictionary does not know how to store generics.  But at the expense of the key, we are able to quickly bring the object to the type we need. <br><br>  <b>What does the container contain?</b> <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> event EventHandler&lt;T&gt; _eventKeeper; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> readonly Dictionary&lt;WeakReference, EventHandler&lt;T&gt;&gt; _activeListenersOfThisType = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;WeakReference, EventHandler&lt;T&gt;&gt;();</code> </pre> <br>  It contains a generic multidelegate and a collection where the key is the object of the subscriber, and the value is the same handler method.  In fact, this dictionary contains all objects and methods that belong to this type.  As a result, we call a multidelegate, and it calls all subscribers, this is an ‚Äúhonest‚Äù event system, in which there are no restrictions on the subscriber, in most other aggregators under the hood, a collection of classes is iterated, which are generalized either by a special interface, or inherited from a class that implements the system posts. <br><br>  When you call a multidelegate, it checks whether dead keys are present, the collection is cleaned of corpses, and then a multidelegate is inserted with current subscribers.  It takes time, but again, in fact, if the event functional is separated, then one event will have 3-5 subscribers, so the check is not so terrible, the benefit from comfort is more obvious.  For network stories where subscribers can be a thousand or more - it is better not to use this aggregator.  Although there remains an open question - if you remove the test for corpses, which is faster - iterate over an array of subscribers from 1k or call a multi-delegate from 1k subscribers. <br><br><h3>  Features of use </h3><br>  Subscription is best to push in Awake. <br><br>  If the object is actively turned on / off, it is better to subscribe to both Awake and OnEnable, it will not subscribe twice, but the possibility that an inactive GameObject will be considered dead is excluded. <br><br>  Invoicing events is better not earlier than the start, when all subscribers will be created and registered. <br><br>  The aggregator cleans the list at unloading the scene.  Some aggregators offer to clean the scene loading - this is the file, the scene loading event comes after Awake / OnEnable, the added subscribers will be deleted. <br><br>  The aggregator has - public static string DebugInfo (), you can see which classes are subscribed to which events. <br><br>  <a href="https://github.com/Brightori/CodeExamples"><b>GitHub Repository</b></a> </div><p>Source: <a href="https://habr.com/ru/post/446130/">https://habr.com/ru/post/446130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../446118/index.html">Open Rack v3: what to expect from the new standard of architecture of server racks</a></li>
<li><a href="../446120/index.html">American telecoms will fight phone spam</a></li>
<li><a href="../446124/index.html">Digital events in Moscow from April 1 to April 7</a></li>
<li><a href="../446126/index.html">Leisure thoughts of cryptography and data protection</a></li>
<li><a href="../446128/index.html">X-ray phonograms return: Massive attack, Jonsi and others. Released records ‚Äúon the bones‚Äù</a></li>
<li><a href="../446132/index.html">92.7% make backups, data loss increased by 30%. What's wrong?</a></li>
<li><a href="../446136/index.html">My Marble Machine, printed on a 3D printer</a></li>
<li><a href="../446138/index.html">How easy it is to legally organize your startup in the form of a simple partnership</a></li>
<li><a href="../446142/index.html">Flat Earth: Experiments and Evidence</a></li>
<li><a href="../446144/index.html">The digest of interesting materials for the mobile developer # 292 (March 25 - March 31)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>