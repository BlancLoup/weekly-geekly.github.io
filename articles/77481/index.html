<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Screwdriver for expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The scope of the analysis of mathematical expressions is not difficult to imagine - these are all sorts of SQL query parsers, and handlers for formula...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Screwdriver for expressions</h1><div class="post__text post__text-html js-mediator-article">  The scope of the analysis of mathematical expressions is not difficult to imagine - these are all sorts of SQL query parsers, and handlers for formulas entered by the user (the same construction of graphs or filters to the database) - up to the creation of your own languages ‚Äã‚Äã(I do not intentionally write the word ‚Äúprogramming‚Äù, k. often these are data description languages ‚Äã‚Äãand their ilk). <br><br>  Perhaps I‚Äôm wrong, but I couldn‚Äôt find a more or less usable expression parser for PHP on the network‚Äôs open spaces ‚Äî and, as those who read my articles periodically, I‚Äôm used to doing it myself, that‚Äôs  to invent a bicycle.  : ^) <br><br>  The result of my attempts you can find <a href="">here</a> .  In the archive you will find the scripts necessary for the functioning of the library, and an example of its work (sample.php).  The library is compiled as standalone. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But, I believe, it would be interesting to find out what is what. <br><br><a name="habracut"></a>  As it is easy to guess, the library is built on the basis of <a href="http://ru.wikipedia.org/wiki/%25D0%259E%25D0%25B1%25D1%2580%25D0%25B0%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25BB%25D1%258C%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D0%25B7%25D0%25B0%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">HMOs</a> (reverse Polish notation, or notation, if you are so familiar).  However, the HMO made sense to modify to the necessary condition, because in its description only the basic functionality for parsing expressions is given.  So, here is the library operating scheme: <br><br>  The description of expression parsing rules is performed in a class inherited from the CIpr class.  Grammars and classes are defined in the protected p_build method. <br><br>  First you need to define grammatical classes (or <a href="http://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">grammars</a> ), on the basis of which the parser will divide the string passed to it into lexemes.  Each lexeme consists of a token (the actual word) and a class identifier (the one that caused the selection of this lexeme).  The class identifier is the array index, i.e.  it can be a string or an integer (I used strings for clarity).  I defined the following possible grammar types: <br><br>  <b>grammar_char (characters [, combinations])</b> <br>  These grammars are defined by a character set (a string in which these characters are listed) and, possibly, combinations of characters (an array of strings). <br>  The definition looks like this: <i>grammar_char ("+ - * / =", array ("+ =", "++"))</i> .  This grammar defines single characters +, -, *, / and = and their combinations + = and ++. <br><br>  <b>grammar_list (tokens [, case sensitivity = true])</b> <br>  This type of grammar is defined by predefined sets of tokens.  You can also determine whether to take a case into account when defining a token (by default, yes). <br>  You can use it like this: <i>grammar_list (array (‚Äúprefix1‚Äù, ‚Äúprefix2‚Äù), false)</i> .  This grammar defines case-insensitive prefix1 and prefix2 tokens.  It is important that it will be easy to search for one token from the list at the beginning of the line, <u>without taking into account separators</u> , i.e.  the prefix1 lexeme will be selected from the prefix1something expression. <br><br>  <b>grammar_preg (nachlo [, extract])</b> <br>  This type of grammar, along with character, I think will be most useful.  These are grammars based on regular expressions.  They are described by a regular start and, possibly, a regular one for extraction.  If no extract is specified, then the beginning is used instead.  Here is a regular expression, for example, selects comments like <i>// comment</i> : /^\/\/.*/ <br><br>  <b>grammar_quot (quotation mark [, escape mode = C_ESCAPE_CHAR])</b> <br>  Grammars of this type are quoted strings.  The screening mode can take the following values: <br>  C_ESCAPE_NONE - characters are not escaped in the string.  (The string "10" "will be recognized as 10 \). <br>  C_ESCAPE_CHAR - only escape characters can be escaped.  (The string "10 \ '- \" "will be recognized as 10 \' -"). <br>  C_ESCAPE_ALL - the escape character \ can be put in front of all the characters.  (The string "1 \ 0 \ '- \" "will be recognized as 10'-"). <br><br>  <b>grammar_brac (brackets characters [, shielding mode = C_ESCAPE_ALL [, &lt;allow nesting = true&gt;]])</b> <br>  These are bracket grammars (i.e., highlighting expressions like &lt;anfg&gt;).  Their use is personally doubtful to me in this context - they are intended for other purposes (this library is only part of the platform).  But you can use them if you need them.  : ^) <br><br>  <b>grammar_user (start, extract)</b> <br>  This is a custom grammar defined by the start and extraction functions. <br><br>  Grammar analysis takes place as follows: The input string is checked in turn by all grammars, and if the beginning of one of them is detected (as a rule, coinciding with the beginning of the line), then it is extracted.  As a result of grammatical analysis, you get an array of tokens. <br><br>  Further, what is more interesting, the classes of possible commands are defined in the expression code.  You can define the following types of commands: <br><br>  <b>ipr_lexeme (token)</b> <br>  Specifies that the specified token should be processed as a command of the type "token".  In the role of a token, it can act as a full-fledged token, defined through the functions lexeme and ilexeme, or simply a string defining the token of a token. <br><br>  <b>ipr_operator (lexeme, priority [, arity = 2 [, associativity = not (which is now equivalent to the left, which is not quite right)]])</b> <br>  Defines an operator. <br>  You can also use functions: <br>  ipr_perfix - prefix unary operator; <br>  ipr_postfix - postfix unary operator; <br>  ipr_binary is a binary operator. <br><br>  <b>ipr_compound (array of tokens, priority [, arity = 3 [, associativity = right [, automatically calculate = no]]])</b> <br>  Defines a complex statement.  What is the difference from the simple?  The operands of a simple operator are calculated by the engine itself, which, let's say, for the operator?: Is not entirely correct, because  you only need to calculate one of its second and third operands.  For this, a complex operator is needed - only the first operand is automatically calculated for it, and all subsequent ones are passed to the user method for processing.  Thus, it makes sense to define complex operators with a degree of at least 2. <br>  You can also use functions: <br>  ipr_access - binary operator of access to the object field; <br>  ipr_ternary is a ternary operator. <br><br>  <b>ipr_brackets (opening token, closing token, comma [, can be used without operand = no [, arity = not defined [, calculate automatically = yes]]])</b> <br>  Defines brackets.  The brackets can be used without an operand (for example (a + b)) or with an operand (for example, arr [10]).  The arity of brackets can also be defined when they need to specify a strictly defined number of operands.  Pro automatic can be read above. <br>  You can also use functions: <br>  ipr_default - definition of brackets used to set priority (i.e. default brackets). <br><br>  <b>ipr_instruction (lexeme, opening lexeme, closing lexeme, comma [, arity = not defined [, calculate automatically = no]])</b> <br>  Specifies the instruction.  In fact, the same as brackets with the prohibition of auto-use, only instead of the operand in front of the brackets, the instruction token is used. <br><br>  <b>ipr_end (token)</b> <br>  Defines a token on which the expression is considered to have ended. <br><br>  <b>ipr_until (token)</b> <br>  Defines a token on which the expression is considered to have ended.  In this case, the lexeme remains at the beginning of the remainder of the expression. <br><br>  Now you need to define handlers for all types of commands, of which 5 are an operand, a token, an operator, a complex operator, brackets, and an instruction.  These are the following protected methods: <br><br>  p_run_operand (command) <br>  p_run_lexeme (command) <br>  p_run_operator (command, operands) <br>  p_run_compound (command, operand, operands) <br>  p_run_brackets (command, operand, operands) <br>  p_run_instruction (command, operands) <br><br>  The command contains the type of command (not important, since it defines the handler, that is, the situation when the operator‚Äôs command comes to the operand handler is impossible), the command class and the token that was defined as a command.  The operand contains the computed operand, and the operands contain the operands, either computed or pending processing via the p_run method (depending on the type of command and the "calculate automatically" flag). <br><br>  Now, to create an expression handler, you need to create an instance of the handler class, to which an expression is passed to the constructor for processing.  The constructor will parse and compile the expression.  To run an expression, use the run method. <br><br>  Well, that seems to be all.  Error handling and non-associative operators are on the way now - I hope I‚Äôll finish all this in the near future.  As usual, I ask you not to be too strict for those to whom this is no longer newly - I publish my developments for those to whom they may come in handy, because the developments, it seems to me, are not entirely useless. <br><br>  Thank you for your attention!  I would be very happy to hear your feedback and comments in the comments, regardless of their positivity.  : ^) </div><p>Source: <a href="https://habr.com/ru/post/77481/">https://habr.com/ru/post/77481/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../77471/index.html">Steve mcconnell</a></li>
<li><a href="../77475/index.html">App Engine SDK 1.2.8 plus new admin console</a></li>
<li><a href="../77477/index.html">Many new androids from HTC ...</a></li>
<li><a href="../77479/index.html">You have left N votes for comments</a></li>
<li><a href="../77480/index.html">Mozilla Test Pilot: New Test</a></li>
<li><a href="../77483/index.html">Algorithmatic - social resource of algorithms</a></li>
<li><a href="../77486/index.html">Apple laptops from the USA under the order</a></li>
<li><a href="../77487/index.html">Little unimportant chip sevens</a></li>
<li><a href="../77490/index.html">I want to censor2.0</a></li>
<li><a href="../77491/index.html">Do not shmogla ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>