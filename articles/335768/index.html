<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As we struggle with dynamic libraries in Swift. Yandex experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Honestly, when we started to work on restarting Yandex.Map, I couldn‚Äôt imagine how many problems we would end up with in Swift. If you started writing...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As we struggle with dynamic libraries in Swift. Yandex experience</h1><div class="post__text post__text-html js-mediator-article">  Honestly, when we started to work on restarting Yandex.Map, I couldn‚Äôt imagine how many problems we would end up with in Swift.  If you started writing on Swift quite recently, then believe me, you missed all the fun.  Some two years ago there was no incremental compilation in principle (even a space in any file led to a complete reassembly), the compiler itself constantly crashed with Segmentation Fault on quite harmless things like triple nesting of types or inheritance from Generic, the project indexation lasted an unimaginably long time, autocompletion worked once and so on and so forth, all misfortunes do not count.  Such moments undoubtedly complicate the life of programmers, but are gradually solved with each Xcode update.  However, there are more significant problems affecting not only the development, but also the quality of the application: the prohibition of compiling static libraries from SWIFT code, and the lack of Swift support at the iOS level. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/web/ec4/920/cd7/ec4920cd7a784ce5ae8e12126af02a36.jpg"></div><br>  Initially, it was not obvious that the use of Swift and dynamic libraries leads to an increase in launch time.  We did not compare the launch time with the previous version and took the long load as a given.  Yes, and diagnostic tools that actually happens at the stage of loading the application, in general, was not.  But one day, Apple developers added the ability to profile the work of the system loader.  It turned out that loading dynamic libraries takes a very long time compared to other stages.  Of course, with our code, not everything was perfect either, but perhaps these are particular features of a separate application and not everyone will be interested in reading about them.  But the struggle with dynamic libraries is a common theme for all developers using Swift.  It is about this issue that will be discussed. <br><br><a name="habracut"></a><h2>  Pre-main </h2><br>  The application is loaded in two stages.  Prior to launching main, the system loader does the job of preparing the application image in memory: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. loads dynamic libraries, <br>  2. puts addresses to external pointers (bind) and base addresses to internal pointers (rebase), <br>  3. creates an Objective-C context, <br>  4. calls constructors of global C ++ variables and + load methods in Objective-C classes. <br><br>  Only after that the application code starts to run. <br><br>  Measuring pre-main is not a trivial task, since this stage is performed by the system and cannot be pledged as user code.  Fortunately, at <a href="https://developer.apple.com/videos/play/wwdc2016/406/">WWDC 2016: Optimizing App Startup Time</a> talked about the <a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/dyld.1.html">DYLD_PRINT_STATISTICS</a> environment <a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/dyld.1.html">variable</a> , which, when turned on, displays the loader operation statistics in stages.  For example, for an empty Swift application when running on iPhone 5, the statistics are as follows: <br><blockquote><code>Total pre-main time: 1.0 seconds (100.0%) <br> dylib loading time: 975.17 milliseconds (95.8%) <br> rebase/binding time: 14.39 milliseconds (1.4%) <br> ObjC setup time: 12.46 milliseconds (1.2%) <br> initializer time: 15.27 milliseconds (1.6%)</code> </blockquote>  It can be seen that a huge part of the pre-main is the loading of dynamic libraries.  Their list can be obtained using the environment variable <a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man1/dyld.1.html">DYLD_PRINT_LIBRARIES</a> .  Libraries are divided into system and user ones loaded from the Frameworks folder of the application bundle. <br><br>  The loading of system libraries is optimized - just make sure of this by creating an empty project on Objective-C and running it with DYLD_PRINT_LIBRARIES &amp; DYLD_PRINT_STATISTICS: <br><blockquote> <code>dyld: loaded: /var/containers/Bundle/Application/6232DEDA-1E38-44B9-8CE8-01E244711306/Test.app/Test <br> ... <br> dyld: loaded: /System/Library/Frameworks/JavaScriptCore.framework/JavaScriptCore <br> dyld: loaded: /System/Library/Frameworks/AudioToolbox.framework/AudioToolbox <br> dyld: loaded: /System/Library/PrivateFrameworks/TCC.framework/TCC <br> <br> Total pre-main time: 19.65 milliseconds (100.0%) <br> dylib loading time: 1.32 milliseconds (6.7%) <br> rebase/binding time: 1.30 milliseconds (6.6%) <br> ObjC setup time: 5.11 milliseconds (26.0%) <br> initializer time: 11.90 milliseconds (60.5%)</code> </blockquote>  The load stage of dynamic libraries is performed almost instantly, although in reality there are 147 of them, and all of them are system ones.  Therefore, you need to focus on user libraries. <br><br><h2>  Minimum set of dynamic libraries </h2><br>  Before you start working on reducing the number of dynamic libraries, you need to determine their minimum set in the application using Swift.  Obviously, these will be dynamic libraries linked to an empty project.  To see them, you need to go to the assembled bundle after the build (via ‚ÄúShow in Finder‚Äù in the context menu) and go to the Frameworks folder: <br><br><img src="https://habrastorage.org/web/330/544/633/33054463365d4e06ad6cacfdc9991593.jpg" width="200"><img src="https://habrastorage.org/web/453/ad4/679/453ad4679d3d473392b520d59ade3faa.jpg" width="500"><br><br>  These are the so-called Swift standard libraries (swift runtime).  If at least one * .swift file is added to the project, Xcode copies them to a bundle and links to the binary file.  What are they needed for?  It's all about the youth of the language.  Swift continues to evolve and <a href="https://developer.apple.com/swift/blog/%3Fid%3D2">does not support binary compatibility</a> .  If the swift runtime had been made part of the system (as it had long been done for Objective-C), then with the next iOS update, the old programs could not work on the new version of the system and vice versa.  Therefore, applications contain a copy of the swift runtime in the Frameworks folder, and the system treats them as custom, hence the long load.  Such is the charge for using a dynamically developing language. <br><br><h2>  Fighting dynamic libraries </h2><br>  Let us turn to a more complex example.  Let some application: <br>  - uses CocoaPods to connect dependencies, with some dependencies coming in ready-made dynamic libraries, <br>  - divided into several targets, <br>  - uses CoreLocation, MapKit, AVFoundation. <br><br>  Inside his bundle, in the Frameworks folder, are the following libraries: <br><br><img src="https://habrastorage.org/web/5b5/75e/973/5b575e97370043efa8f342939943119f.png" width="600"><br><br>  Download statistics for this application on iPhone 5 looks like this: <br><blockquote> <code>Total pre-main time: 3.6 seconds (100.0%) <br> dylib loading time: 3.5 seconds (95.3%) <br> rebase/binding time: 50.04 milliseconds (1.3%) <br> ObjC setup time: 59.78 milliseconds (1.6%) <br> initializer time: 60.02 milliseconds (1.8%)</code> </blockquote> <h4>  Reducing Swift standard libraries </h4><br>  As you can see, in this example, five swift runtime libraries are larger than in an empty project.  If there is an import CoreLocation in any * .swift file, or #import &lt;CoreLocation / CoreLocation.h&gt; is in the bridging header, then Xcode adds libswiftCoreLocation.dylib to the bundle.  However, using #import &lt;CoreLocation / CoreLocation.h&gt; in Objective-C code does not add this library.  This suggests a solution - to make Objective-C wrappers over the necessary parts of CoreLocation and use only them in the application.  An example of wrappers <a href="https://github.com/likhogrud/dynamic-libs/tree/master/Optimized/Test/SDKObjCWrapping">can be found here</a> . <br><br>  Unfortunately, this may not be enough due to transitive dependencies.  Using import MapKit in any * .swift file results in adding libswiftmapkit.dylib and libswiftCoreLocation.dylib, using import AVFoundation to adding libswiftAVFoundation.dylib, libswiftCoreAudio.dylib, libswiftCoreMedia.dylib.  Therefore, the necessary parts of MapKit and AVFoundation also have to wrap.  And libswiftCoreLocation.dylib is added if there is #import &lt;CoreLocation / CoreLocation.h&gt; in any header file on which the bridging header transitively depends.  If this #import is in a library, then it will also need to be wrapped.  All this sounds unpleasant, but the result is justified - you can achieve the same set of Swift standard libraries as in an empty application. <br><br><h4>  Static linking of source files </h4><br>  The next mass source of dynamic libraries is scams collected into dynamic frameworks when specifying! Use_frameworks in a Podfile.  The! Use_frameworks flag is required for connecting dependencies written in Swift, since Xcode does not allow using Swift in static frameworks - throws out the error "Swift is not supported for static libraries". <br><br>  In fact, this does not mean that you cannot create and use static libraries with Swift code, since a static library is just an archive of object files.  The Swift compiler for each source file generates the usual Mach-O object files.  With <a href="https://en.wikipedia.org/wiki/Ar_(Unix)">ar</a> or <a href="https://en.wikipedia.org/wiki/GNU_Libtool">libtool,</a> you can archive them into a static library and substitute the result in a link command: <br><br>  - Let SomeLib module consist of two files: SomeClass.swift and SomeOtherClass.swift.  SomeLib can be built with Xcode 8.3.1 into a static library and linked to main.swift with the following commands: <br><blockquote> <code>DEVELOPER_DIR=/Applications/Xcode8.3.1.app/Contents/Developer/ <br> SWIFTC=$DEVELOPER_DIR/Toolchains/XcodeDefault.xctoolchain/usr/bin/swiftc <br> SDK=$DEVELOPER_DIR/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS10.3.sdk <br> <br> #    <br> $SWIFTC -target armv7-apple-ios8.0 -sdk $SDK -module-name SomeLib \ <br> SomeClass.swift SomeOtherClass.swift -c <br> <br> #  swiftmodule,     main.swift <br> $SWIFTC -target armv7-apple-ios8.0 -sdk $SDK -module-name SomeLib \ <br> SomeClass.swift SomeOtherClass.swift -emit-module <br> <br> #       <br> $libtool -static -o libSomeLib.a SomeClass.o SomeOtherClass.o <br> <br> #     main.swift  libSomeLib.a <br> $SWIFTC -target armv7-apple-ios8.0 -sdk $SDK -I . -L . main.swift -lSomeLib</code> </blockquote>  - The first two commands can be combined using OutputFileMap.json, as Xcode does.  Specific parameters with which the swiftc compilation driver calls the swift compiler can be viewed by adding the -v option. <br><br>  Fortunately, in <a href="https://download.developer.apple.com/Developer_Tools/Xcode_9_beta_4/Xcode_9_beta_4_Release_Notes.pdf">Xcode 9 beta 4, the</a> ban on using Swift in static frameworks has been removed.  You can wait for the release of Xcode and the corresponding <a href="https://github.com/CocoaPods/CocoaPods/issues/6899">edits in cocoapods</a> (so that static frameworks are compiled), and the problem will disappear by itself.  But for those who do not plan or can not switch to Xcode 9, it is worth mentioning the existing rather simple solution - <a href="https://github.com/Ruenzuo/cocoapods-amimono">cocoapods-amimono</a> .  The idea is simple - after building each subteam in a separate build folder, build artifacts, including object files, remain.  Instead of linking to dynamic libraries, you can link directly to the object files from which they were collected.  Cocoapods-amimono: <br>  - adds a build phase that executes the script that makes up the LinkFileList from the object files in the build folders, <br>  - linking with the framework framework replaces linking with LinkFileList, <br>  - removes embedding frameworks in the application bundle. <br><br>  The solution works: the framework frameworks disappear from the Frameworks folder, and you can use module import, that is, the application code does not change. <br><br><h4>  Static linking of own targets </h4><br>  In the same way, you can get rid of dynamic frameworks collected from user targets: either wait for Xcode 9 (and use static frameworks), or link object books directly into a binary application file, as cocoapods-amimono does.  For this you need: <br><br>  - leave the target in the dependencies of the main target, <br>  - do not embed the framework in the bundle and do not link with it, <br>  - add build phase, component LinkFileList, by analogy with cocoapods-amimono: <br><blockquote> <code># ,     <br> DEPENDENCIES=('SomeTarget' 'SomeOtherTarget'); <br> ARCHS_LIST=($ARCHS) <br> <br> #   ,     <br> for ARCH in ${ARCHS[@]}; do <br> DIR=$OBJECT_FILE_DIR_normal/$ARCH <br> <br> #     LinkFileList <br> FILE_PATH=$DIR/$TARGET_NAME.Dependencies.LinkFileList <br> FILE_LIST="" <br> <br> #    <br> for DEPENDENCY in "${DEPENDENCIES[@]}"; do <br> <br> #   ,  -  <br> PATH=$CONFIGURATION_TEMP_DIR/${DEPENDENCY}.build/Objects-normal/$ARCH <br> <br> #    <br> SEARCH_EXP="$PATH/*.o" <br> <br> #    ,  SEARCH_EXP <br> for OBJ_FILE in $SEARCH_EXP; do <br> #    FILE_LIST <br> FILE_LIST+="${OBJ_FILE}\n" <br> done <br> done <br> FILE_LIST=${FILE_LIST%$'\n'} <br> <br> #  FILE_LIST     FILE_PATH <br> echo -n -e $FILE_LIST &gt; $FILE_PATH <br> done</code> </blockquote>  - link the main target with LinkFileList.  To do this in OTHER_LDFLAGS add: <br><br> <code>-filelist "${OBJECT_FILE_DIR_normal}/${CURRENT_ARCH}/${TARGET_NAME}.Dependencies.LinkFileList"</code> <br> <br><h4>  Lazy loading of dynamic libraries </h4><br>  With ready-made dynamic frameworks, it is more difficult, since a dynamic library cannot be converted into a static library - this is essentially an executable file that allows only dynamic linking.  If these are the core-framework of the application and its symbols are needed right at the start - nothing can be done, its use will inevitably increase the launch time.  But if the framework is not used when starting the program, then you can load it lazily through dlopen.  And it is lazy to load via dlopen + dlsym only an Objective-C compatible part of the interface, since the module import into Swift links the library automatically.  If everything you need is available from Objective-C, then you need: <br><br>  1. Remove the linking of the library with the main target.  If the dependency is connected via cocoapods, then the linking can be removed by adding a fake target (to which the problem file will be attached) or via post_install in the Podfile: <br><blockquote> <code>post_install do | installer | <br> <br> #  Amimono::Patcher.patch!(installer),   amimono <br> <br> #   ,     <br> installer.aggregate_targets.each do |aggregate_target| <br> <br> # xcconfig-,        <br> target_xcconfigs = aggregate_target.xcconfigs <br> #    -  xcconfig <br> aggregate_target.user_build_configurations.each do |config_name,_| <br> <br> #   xcconfig    <br> path = aggregate_target.xcconfig_path(config_name) <br> <br> #    <br> xcconfig = Xcodeproj::Config.new(path) <br> <br> #    <br> xcconfig.frameworks.delete("SomeFramework") <br> <br> #  <br> xcconfig.save_as(path) <br> end <br> end <br> end</code> </blockquote>  2. To write on Objective-C a wrapper over the framework that implements the lazy loading of the library and the required characters. <br><br>  - Download library. <br><blockquote> <code>#import &lt;dlfcn.h&gt; <br> <br> NSString *frameworksPath = [[NSBundle mainBundle] privateFrameworksPath]; <br> NSString *dyLib = @"DynamicLib.framework/DynamicLib"; <br> <br> //      <br> NSString *path = [NSString stringWithFormat:@"%@/%@", frameworksPath, dyLib]; <br> const char *pathPtr = [path cStringUsingEncoding:NSASCIIStringEncoding] <br> <br> //   <br> void *handle = dlopen(pathPtr, RTLD_LAZY);</code> </blockquote>  - Getting the names of characters in the library DynamicLib, by which they need to be further loaded via <a href="https://developer.apple.com/legacy/library/documentation/Darwin/Reference/ManPages/man3/dlsym.3.html">dlsym</a> . <br><blockquote> <code>$nm -gU $BUNDLE_PATH/Frameworks/DynamicLib.framework/DynamicLib <br> <br> DynamicLib (for architecture armv7): <br> 00007ef0 S _DynamicLibVersionNumber <br> 00007ec8 S _DynamicLibVersionString <br> 0000837c S _OBJC_CLASS_$__TtC10DynamicLib16SomeClass <br> 00008408 D _OBJC_METACLASS_$__TtC10DynamicLib16SomeClass <br> ... <br> 00004b98 T _someGlobalFunc <br> 000083f8 D _someGlobalStringVar <br> 000083f4 D _someGlobalVar <br> ...</code> </blockquote>  - Download and use global symbols. <br><blockquote> <code>// dlsym     . <br> <br> //     <br> int (*someGlobalFuncPtr)(int) = dlsym(handle, "someGlobalFunc"); <br> <br> //      <br> someGlobalFuncPtr(5); <br> <br> //      <br> int *someGlobalVarPtr = (int *)dlsym(handle, "someGlobalVar"); <br> NSLog(@"%@", *someGlobalVarPtr); <br> <br> //       <br> NSString *__autoreleasing *someGlobalStringVarPtr = <br> (NSString *__autoreleasing *)dlsym(handle, "someGlobalStringVar"); <br> <br> NSLog(@"%@", *someGlobalStringVarPtr); <br> *someGlobalStringVar = @"newValue";</code> </blockquote>  - Loading and using classes.  Objective-C allows you to call an instance method in an object of type id, and any object declared in a class of type Class - any declared method.  Moreover, you can use header files with the interface declaration of the desired class, this does not cause the library to automatically load, as is the case with Swift. <br><blockquote> <code>#import &lt;DynamicLib/SomeClass.h&gt; <br> <br> //dlsym    Class <br> Class class = (__bridge Class)dlsym(handle, <br> "OBJC_CLASS_$__TtC10DynamicLib16SomeClass") <br> <br> //  class- <br> [class someClassFunc]; <br> <br> //   <br> SomeClass *obj = [(Somelass *)[class alloc] init]; <br> <br> //  <br> NSLog(@"%@", obj.someVar) <br> [obj someMethod];</code> </blockquote>  An example can be <a href="">found here</a> .  Standard actions for downloading the library and symbols can be made into macros, as is <a href="">done in the Facebook SDK</a> . <br><br><h2>  Optimization result </h2><br>  As a result, only the swift runtime libraries and vendored frameworks remain, loaded as lazily as possible.  Moreover, the swift runtime library set is the same as for an empty application.  Statistics pre-main now looks like this: <br><blockquote> <code>Total pre-main time: 1.0 seconds (100.0%) <br> dylib loading time: 963.68 milliseconds (90.0%) <br> rebase/binding time: 35.65 milliseconds (3.3%) <br> ObjC setup time: 29.08 milliseconds (2.7%) <br> initializer time: 41.35 milliseconds (4.0%)</code> </blockquote>  The load time of dynamic libraries was reduced from 3.5 to 1 second. <br><br><h2>  Saving result </h2><br>  There are a couple of simple suggestions how not to spoil the achieved results with the next update.  The first is to add the execution of the script to the build-phases, which checks after building a list of libraries and frameworks in the Frameworks folder of the application bundle - whether something new has appeared. <br><blockquote> <code>FRAMEWORKS_DIR="${BUILT_PRODUCTS_DIR}/${FRAMEWORKS_FOLDER_PATH}" <br> FRAMEWORKS_SEARCH_PATTERN="${FRAMEWORKS_DIR}/*" <br> <br> #     ,  FRAMEWORKS_SEARCH_PATTERN <br> FRAMEWORKS=($FRAMEWORKS_SEARCH_PATTERN) <br> <br> #       Frameworks <br> ALLOWED_FRAMEWORKS=(libswiftFoundation.dylib SomeFramework.framework) <br> <br> for FRAMEWORK in ${ALLOWED_FRAMEWORKS[@]} <br> do <br> PATTERN="*${FRAMEWORK}" <br> #   ,  PATTERN <br> FRAMEWORKS=(${FRAMEWORKS[@]/${PATTERN}/}) <br> done <br> <br> echo ${FRAMEWORKS[@]} <br> <br> #      FRAMEWORKS <br> #         <br> exit ${#FRAMEWORKS[@]}</code> </blockquote>  If there are any new files, this is definitely a reason for the proceedings.  But there may be libraries that need to be loaded lazily, and it is important to check that they did not start loading at the start.  Therefore, the second sentence is to get the list of loaded libraries via objc_copyImageNames and check the list of libraries loaded from Frameworks: <br><blockquote> <code>var count: UInt32 = 0 <br> <br> //     <br> let imagesPathsPointer: UnsafeMutablePointer&lt;UnsafePointer?&gt;! = <br> objc_copyImageNames(&amp;count) <br> <br> //     <br> let expectedImages: Set = ["libswiftCore.dylib"] <br> <br> //         <br> let frameworksPath = Bundle.main.privateFrameworksPath ?? "none" <br> <br> for i in 0..&lt;count { <br> let pathPointer = imagesPathsPointer.advanced(by: Int(i)).pointee <br> let path = pathPointer.flatMap { String(cString: $0) } ?? "" <br> <br> //     <br> guard path.contains(frameworksPath) else { continue } <br> <br> let name = (path as NSString).lastPathComponent <br> assert(expectedImages.contains(name)) <br> }</code> </blockquote>  The list should not be changed.  These two points are quite enough for an increase in the pre-main time due to an increase in the load time of the dynamic libraries not to pass unnoticed. <br><br><h2>  Conclusion </h2><br>  The listed problems are entirely generated by the youth of Swift.  Some of them will disappear with the release of Xcode 9, which allowed static libraries on Swift, which will get rid of crutches like cocoapods-amimono.  But finally, the problem of increasing the size of the bundle and the application launch time will be solved only when the swift runtime becomes part of iOS.  Moreover, for some time after this, applications will have to carry it with them in order to maintain previous versions of the system.  The development of Swift 5 is aimed at stabilizing the Swift standard library binary interface.  The binary interface was planned to stabilize in Swift 4, but Xcode 9 still copies the swift runtime into the application bundle with the deployment target iOS 11, which means that Swift is still not part of iOS. </div><p>Source: <a href="https://habr.com/ru/post/335768/">https://habr.com/ru/post/335768/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../335754/index.html">Design and Mathematics of Clicker Games</a></li>
<li><a href="../335756/index.html">Concurrency in Swift 3 and 4. Operation and OperationQueue</a></li>
<li><a href="../335758/index.html">Five JavaScript debugging tools that are useful to know</a></li>
<li><a href="../335760/index.html">Automate my testing completely, cheaply, forever: QA-mitap announcement in Avito on August 26</a></li>
<li><a href="../335762/index.html">Determining the blocking mode of a TCP socket under Windows</a></li>
<li><a href="../335770/index.html">Webcam, Node.js and OpenCV: make a face recognition system</a></li>
<li><a href="../335772/index.html">Installing and configuring MongoDB on Debian, as well as ReplicaSet and a couple of other little things</a></li>
<li><a href="../335776/index.html">UI tests - are they always needed?</a></li>
<li><a href="../335778/index.html">Report on the hackathon of the Navalny team</a></li>
<li><a href="../335780/index.html">Rethinking PID 1. Part 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>