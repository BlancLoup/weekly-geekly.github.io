<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Master-master replication and scaling of applications between all IoT devices and the cloud</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The photo shows the devices used for prototyping. As you can see, the x86 processor (Intel Edison) is taken as the basis 

 Hello. In this article, I ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Master-master replication and scaling of applications between all IoT devices and the cloud</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/d94/c70/f6f/d94c70f6fe71492a8bad91364d20c6e0.png"><br>  <i>The photo shows the devices used for prototyping.</i>  <i>As you can see, the x86 processor (Intel Edison) is taken as the basis</i> <br><br>  Hello.  In this article, I would like to share the experience of solving one interesting problem related to data synchronization between IoT devices and a cloud application.  First, I will talk about the main idea and goals of my project, and then I will describe in detail its technical side and implementation: I will discuss Contiki OS, databases, protocols, and similar aspects.  In conclusion, I will briefly list the technologies used to build the system. <br><a name="habracut"></a><br><h2>  Briefly about the project </h2><br>  To begin, let's talk about the main idea of ‚Äã‚Äãthe project.  Below is a schematic representation of the principle of the finished system: <br><br><img src="https://habrastorage.org/files/97d/29e/74d/97d29e74dff84cf7a45ef55198a5a98d.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There is a user who via a cloud service or directly (via Wi-Fi) connects to an IoT device.  Also somewhere on the Internet there is a cloud application server.  Anything can serve as a cloud: say, an AWS or Azure instance or a dedicated server.  For data exchange between the application server and IoT devices, a connection is established by some protocol.  IoT devices are somehow connected to each other (for example, via Ethernet or Wi-Fi).  In addition, there is a separate group of IoT devices that generate telemetry data (such as illuminance or temperature). <br><br>  In total, it can gain more than 100 or even more than 1000 devices.  My main task was to provide data exchange between the cloud and these IoT devices.  Before proceeding further, it is worth mentioning what requirements were placed on the system: <br><br><ul><li>  <i>It must synchronize data between IoT devices.</i> </li><li>  <i>It should collect data from IoT devices.</i> </li><li>  <i>It must synchronize data between IoT devices and the cloud.</i> </li></ul><br><h2>  Technical implementation </h2><br><img src="https://habrastorage.org/files/d1a/314/03e/d1a31403ef684e72a9b5ddceff001d43.png"><br><br>  Everything is quite simple here: the user connects to the application server via HTTP (S), WebSocket, or a similar protocol.  A small task for readers: what do you think can be used to connect between the application server and the IoT device? <br><br><img src="https://habrastorage.org/files/fc1/f8c/07a/fc1f8c07a6354540ad11654551e9ec5f.png"><br><br>  If you thought about MQTT, you are definitely right!  As well as those who chose HTTP (S).  In fact, any protocol will do - choose to your taste!  My choice fell on - drum roll - asynchronous replication!  I mean the usual database replication. <br><br><img src="https://habrastorage.org/files/a11/1ad/038/a111ad038a9841bd97b8885e28ee466f.png"><br><br>  You may ask why I need replication.  The answer is simple: replication is used to synchronize data, so I can ‚Äî everywhere ‚Äî including the cloud and IoT devices ‚Äî maintain one version of the database.  However, replication is quite difficult to implement.  If you want replication, get a database that supports it, because - I repeat - replication is naturally inherent in databases. <br><br>  Here I would like to say a few words about those databases that I considered when working on a project: <a href="https://en.wikipedia.org/wiki/SQLite">SQLite</a> , <a href="https://en.wikipedia.org/wiki/Redis">Redis</a> , <a href="https://en.wikipedia.org/wiki/MySQL">MySQL</a> , <a href="https://en.wikipedia.org/wiki/PostgreSQL">PostgreSQL</a> and <a href="https://en.wikipedia.org/wiki/Tarantool">Tarantool</a> . <br><br>  I compared their characteristics and tried to run a few pieces - with the exception of MySQL and PostgreSQL - right on the IoT device.  Below I will tell what came of it. <br><br>  SQLite is definitely a good solution for storing data directly on an IoT device, but it does not have replication, and it does not support concurrent access from different processes. <br>  Redis does not support master-master replication and therefore cannot solve my problem, since I need two-way replication. <br><br>  MySQL and PostgreSQL are too heavy for an IoT device, so I didn‚Äôt even try to install them.  But if you do decide to do it, feel free to share your experience in the comments. <br><br>  Last on my list was the Tarantool database.  I‚Äôll say right away that I am a committer in the Tarantool project, so I know the project itself and the people who develop it.  In addition, there is master-master replication in Tarantool.  In general, for me it was definitely the best option.  You can use another database in your project.  The basic idea that I am trying to convey is that IoT devices can use databases with master-master replication to exchange data. <br><br>  Until now, I only superficially introduced you to the project.  Now let's dive a bit into its technical aspects. <br><br>  I'll start with the problems that I encountered while using Tarantool.  First, Tarantool did not run on the ARMv7 architecture.  Secondly, Tarantool did not start in a 32-bit environment, which only aggravated the situation.  In the end, I was able to solve these problems.  Below are the development rules that helped me in this. <br><br><ol><li>  <i>Use toolchain files for CMake.</i>  <i>Otherwise, you, like me, will spend a lot of time correcting CMake files.</i> </li><li>  <i>Do not use the unsigned type and other types for which no size is specified.</i>  <i>In libc, there are special types for this, such as uint32_t.</i>  <i>Otherwise, you can get undefined behavior.</i>  <i>This rule applies only to C / C ++.</i> </li><li>  <i>Port your autotests.</i> </li></ol><br>  It is expected that your autotests can be run on the IoT device.  If this is not the case, there is a risk of killing a lot of time for debugging. <br><br>  So, I have a working database with master-master replication.  Wonderful!  The next step is to connect the devices on which this database is installed, according to <a href="https://en.wikipedia.org/wiki/6LoWPAN">6LoWPAN</a> .  Let me remind you, I have a network of many IoT devices connected to each other via 6LoWPAN, from which I need to collect all telemetry data. <br><br><img src="https://habrastorage.org/files/e24/bde/eb7/e24bdeeb75a24a1da75e66000a1e224c.png"><br>  <i>Brief scheme of the finished system</i> <br><br>  Devices with sensors transmit telemetry data via radio waves.  This standard is called 6LoWPAN (IPv6 over low-power wireless personal area networks).  I note that I did not use in the <a href="https://en.wikipedia.org/wiki/LPWAN">LoRaWAN</a> project.  Perhaps I will find the use of this technology in the future, but in this article I will focus on 6LoWPAN.  So, to collect telemetry data, I will use the gateway, which is an important part of the system.  A gateway is a MIPS device (MIPS is a processor family) with a WAN antenna for collecting data transmitted via radio waves.  In addition, a 6LBR application is installed on the gateway, which converts the received data into IPv6 packets. <br><br><h2>  Appendix 6LBR </h2><br><img src="https://habrastorage.org/files/74d/054/962/74d054962684467abf0170097c3304d3.png"><br><br>  The image above illustrates the principle of operation of the 6LBR.  A gateway with a 6LBR installed on it serves as a converter between the wireless sensor network and any other.  The picture shows the conversion from a wireless sensor network to an IP network only because 6LBR works by default.  A little later, I will explain how to change this behavior. <br><br>  More information can be found on <a href="https://github.com/cetic/6lbr">page 6LBR on GitHub</a> . <br><br>  You may ask what gives me the use of 6LBR.  First, I get an IP stack, so I can use the TCP and UDP stack functionality in my 6LBR applications.  Secondly, I can use any I / O device with 6LBR.  Let's say you can write raw data directly to bash.  =) Unfortunately, 6LBR does not write directly to the MQTT.  MQTT brokers know nothing about raw data, and we have to put up with it. <br><br>  Why do I need a direct entry to the MQTT broker?  The answer is simple: it's in the legacy code. <br>  Here I would like to say a few words about the 6LBR applications.  In general, a 6LBR application is a code written in C with an API that allows you to use the IP stack and do some other things.  Developing such an application involves at least two difficulties: a complex threading model and a complex memory model.  Therefore, be patient and prepare for frequent crashes of your program.  Below is a small piece of the 6LBR application that I developed (I apologize in advance: I can upload only a picture with a deliberately confusing code, because the source code is closed): <br><br><img src="https://habrastorage.org/files/8b2/057/643/8b205764393c4743b7bb7dda7291280f.png"><br><br>  Pay attention to one interesting thing - PROCESS_YIELD ().  In 6LBR there is cooperative multitasking, which means that 6LBR applications must return control in each iteration of the loop.  The code should not run too long. <br><br>  So let's look at what stage our project is at.  Using the gateway and the 6LBR application installed on it, I created a mesh network to read and write data inside it.  I also managed to wrap IP packets in MQTT messages, each of which contains information about the device, including telemetry data.  In addition, I had the opportunity to manipulate I / O devices: for example, I can record MQTT messages on the UART.  But then I ran into a new problem: Tarantool does not work with MQTT brokers.  Below I will tell you how I managed to get around this limitation. <br><br>  I decided to use <a href="https://mosquitto.org/man/libmosquitto-3.html">libmosquitto</a> , written on a pure C MQTT library, because it makes it quite easy to integrate MQTT into my application.  Below is an example of using this library to work with MQTT messages ( <a href="https://github.com/tarantool/mqtt">link</a> ): <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mosq_poll_one_ctx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mosq_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ctx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> revents, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> timeout, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max_packets)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** XXX * I'm confused: socket &lt; 0 means MOSQ_ERR_NO_CONN */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> rc = MOSQ_ERR_NO_CONN; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> fd = mosquitto_socket(ctx-&gt;mosq); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fd &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/** Wait until event */</span></span> revents = coio_wait(fd, revents, timeout); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (revents != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (revents &amp; COIO_READ) rc = mosquitto_loop_read(ctx-&gt;mosq, max_packets); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (revents &amp; COIO_WRITE) rc = mosquitto_loop_write(ctx-&gt;mosq, max_packets); } <span class="hljs-comment"><span class="hljs-comment">/** * mosquitto_loop_miss * This function deals with handling PINGs and checking * whether messages need to be retried, * so should be called fairly _frequently_(!). * */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx-&gt;next_misc_timeout &lt; fiber_time64()) { rc = mosquitto_loop_misc(ctx-&gt;mosq); ctx-&gt;next_misc_timeout = fiber_time64() + <span class="hljs-number"><span class="hljs-number">1200</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rc; }</code> </pre> <br>  I can take a reference to the socket descriptor and use my own event loop to handle some events.  And this is great!  I would like to draw your attention to the fact that in Tarantool, as well as in 6LBR, there is cooperative multitasking.  To return control, Tarantool uses <code>coio_wait()</code> . <br><br>  Oh yeah, I forgot to mention that <a href="https://github.com/tarantool/tarantool">Tarantool</a> is also a Lua application server.  Surprise!  Therefore, I ported libmosquitto to Lua.  Below is a piece of code in which the function that you already saw in the previous example is called: <br><br><pre> <code class="lua hljs">__poll_forever = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> mq = self.mqtt <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> self.connected, _ = mq:poll_one() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.connected <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.auto_reconect <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self:__try_reconnect() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">error</span></span>( <span class="hljs-string"><span class="hljs-string">"mqtt: the client is not currently connected, error %s"</span></span>, emsg) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> fiber.sleep(self.POLL_INTERVAL) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>,</code> </pre> <br>  I also ported all the functions from the libmosquitto API.  Look at the result <a href="https://github.com/tarantool/mqtt">here</a> .  The <a href="">link is</a> an example of use.  All you need to do to collect data from all devices within the mesh network is to call the <code>subscribe()</code> function from a specific place and publish the <code>get()</code> method! <br><br><h2>  Conclusion </h2><br>  Let's look at what we did: <br><br><img src="https://habrastorage.org/files/b21/bbf/03d/b21bbf03dcc3487d99b8049ccd687eb4.png"><br><br>  The connection to the application server is established through the replication provided by Tarantool master-master.  Two useful properties follow from this: <br><br><ol><li>  If the application server changes any data, this updated data is delivered to all IoT devices on the network. </li><li>  If the IoT device changes any data, this updated data is delivered to the application server. </li></ol><br>  These properties are the solution to my problems. <br><br>  I can also connect my IoT devices through master-master replication.  Thus, devices and the cloud are combined into a cluster, which can be used to synchronize all data.  All IoT devices and the cloud are synchronized most of the time, except when the connection between them disappears.  As soon as the connection is restored, all data is synchronized again.  Just great! <br><br>  The gateway with the 6LBR application installed on it allows you to exchange data between my IoT devices and other IoT devices.  It wraps each message in an MQTT message and sends it to the UART channel. <br><br>  IoT-device #N with MQTT-broker installed on it reads these messages from the UART channel.  The MQTT broker forwards messages to Tarantool over an MQTT connection.  Tarantool reads them, then for each message the Tarantool application server executes some code. <br><br>  The #N IoT device is connected to all other devices through the replication provided by the Tarantool master-master.  The same replication is used to connect all devices with the cloud. <br><br>  That's all!  I solved the task and really hope that my experience will help you in your own projects in the future.  To summarize: I used Tarantool and as the main frontend on my dedicated servers, and as an application server.  If you are interested in this topic, I recommend to look at my other <a href="https://hackernoon.com/shrink-the-number-of-tiers-in-a-multitier-architecture-from-5-to-2-c59b7bf46c86">article</a> in English.  Stay in touch and stay tuned! </div><p>Source: <a href="https://habr.com/ru/post/320878/">https://habr.com/ru/post/320878/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../320866/index.html">The logic of consciousness. Part 10. The task of generalization</a></li>
<li><a href="../320868/index.html">PR for a startup: which sites must write about your company</a></li>
<li><a href="../320870/index.html">XELTEK Adapter Cloning Protection Mechanism</a></li>
<li><a href="../320872/index.html">Docker implementation for a small project in Production, part 3</a></li>
<li><a href="../320874/index.html">Visualization of data in the browser using D3.js</a></li>
<li><a href="../320880/index.html">VPS hosting and cloud hosting: what to choose and what is the difference?</a></li>
<li><a href="../320882/index.html">Off splinters from the brain. 15 stereotypes about CRM-systems</a></li>
<li><a href="../320884/index.html">We set up a private Docker repository</a></li>
<li><a href="../320886/index.html">FlexPod - from theory to practice: the word to engineers (webinar)</a></li>
<li><a href="../320888/index.html">Cloudless mobile app - life without Google Play</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>