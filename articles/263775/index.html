<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Algorithm for parsing arithmetic expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="General information 
 The article describes one of the possible algorithms for the software implementation of the parser of arithmetic expressions, wi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Algorithm for parsing arithmetic expressions</h1><div class="post__text post__text-html js-mediator-article"><h4>  General information </h4><br>  The article describes one of the possible algorithms for the software implementation of the parser of arithmetic expressions, with the possibility of subsequent calculation of their values. <br><br>  <b>A parser</b> is a program that analyzes an input arithmetic expression.  Programs of this class are sometimes also called ‚Äúrecognizers‚Äù. <br><br>  <b>Parsing</b> is the process of parsing the input arithmetic expression into simpler components. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The result of the parser is a formed tree of tokens.  By lexemes, we mean fragments of an input arithmetic expression that are not subject to further splitting into component parts. <br><br>  The description of the recognition algorithm is given without reference to any programming language.  The article concludes with an example of implementing this algorithm in PHP.  The implementation of the algorithm is possible in almost any programming language (even without OOP support). <br><a name="habracut"></a><br><h4>  Formulation of the problem </h4><br>  Suppose that the parser takes an arithmetic expression as an input, which is a regular string of the form: <i>(x + 10.2) ^ 2 + 5 * yz</i> .  The input expression is correct in terms of the grammar of arithmetic expressions: <br><ul><li>  The number of opening brackets is equal to the number of closing brackets. </li><li>  The integer part of the number is separated from the fractional by a point. </li><li>  The string contains only valid characters: the digits <i>0 ... 9</i> , the operators <i>+ - * / ^</i> , the brackets, the point and the parameters <i>x, y, z</i> . </li></ul><br>  The parser must build a tree of tokens suitable for calculating the numerical value of the input expression.  The values ‚Äã‚Äãof the parameters will be passed to the method that implements the calculation of the numerical value. <br><br>  For each specific expression, the tree of objects is built once.  Then, using the obtained tree of objects, we calculate the final value of the output expression taking into account the values ‚Äã‚Äãof the parameters.  You can repeat the calculations unlimited number of times. <br><br>  The algorithm should allow processing of input expressions of unlimited length (within reasonable limits) without restrictions on the level of nesting of parentheses. <br><br><h4>  Lexical analysis of the input expression </h4><br>  Before proceeding directly to parsing the input expression, it is advisable to remove insignificant characters (such as a space, etc.) and form solid lexemes.  This procedure is not mandatory within the framework of the algorithm, however, it allows to significantly simplify the understanding of the algorithm itself and its software implementation. <br><br>  For example, let us return to the consideration of the line of the arithmetic expression given above: <i>(x + 10.2) ^ 2 + 5 * yz</i> .  In the process of lexical analysis, the specified string will be converted into an array of strings of the following structure: <i>[0] =&gt; ‚Äù(‚Äù, [1] =&gt; ‚Äùx‚Äù, [2] =&gt; ‚Äù+‚Äù, [3] =&gt; ‚Äù10.2‚Äù, [4] =&gt; ‚Äù)‚Äù, [5] =&gt; ‚Äù^‚Äù, [6] =&gt; ‚Äù2‚Äù, [7] =&gt; ‚Äù+‚Äù, [8] =&gt; ‚Äù5‚Äù, [9] =&gt; ‚Äù*‚Äù, [10] =&gt; ‚Äùy‚Äù, [11] =&gt; ‚Äù-‚Äù, [12] =&gt; ‚Äùz‚Äù</i> . <br><br>  Thus, a solid lexeme is either an operator (arithmetic operation), or an operand (a number consisting of one or several digits), or a parameter ( <i>x, y, z</i> ) or a bracket (as an element that changes the priority of performing arithmetic operations in ). <br><br><h4>  Token as an object </h4><br>  Each integral lexeme in the tree structure is described by an object.  Any object "tree" has a set of properties (fields) and a specific behavior.  We list the estimated set of data fields for each object that models the token: <br><ol><li>  <i>Name</i> field - defines the unique name of the object. </li><li>  The <i>lec</i> field is an array of tokens, for storing information about that part of the input expression whose vertex is this node of the "tree" of objects. </li><li>  <i>Const</i> field - if this object is a parameter, then the variable stores its name. </li><li>  <i>Var</i> field - if this object is a number or a parameter, then the variable stores its value. </li></ol><br>  The behavior of each object is characterized by a combination of methods.  For this case, one method is enough, for example: calc ().  If an object describes the behavior of an operand (number) or parameter, then it is necessary that it return this number or parameter value.  If an object describes a token that is one of the operators (arithmetic operations), then the method should return the result of applying this operator to two numbers. <br><br>  All objects of a tree structure may belong to the same class; it is enough just to override one method when creating an object.  Or, alternatively, we can describe an abstract class with one abstract function <i>calc ()</i> .  Next, for each type of lexeme, we describe our class, which inherits the abstract class and determines the specific behavior of the <i>calc ()</i> method.  In the example of the software implementation, the last method is chosen, which requires a significantly smaller amount of code. <br><br>  Some fields may remain blank - it depends on which lexeme is modeled by this particular object. <br><br><h4>  Token as a node of the tree structure </h4><br>  The configuration of objects that simulate lexemes is in general clear.  But this raises the question of how to form a tree structure from these objects? <br><br>  This problem is quite typical for software projects.  The essence of the solution can be obtained from the design pattern with the name: "Linker".  Blind copying of all the subtleties of this design pattern (pattern) is not included in our plans, so we are trying to highlight the most important and necessary for a particular case. <br><br>  To arrange objects in the tree structure, add three more fields to each object: <br><ol><li>  The <i>childrenLeft</i> field is the left "heir" of this object. </li><li>  The <i>childrenRight</i> field is the right "heir" of this object. </li><li>  The <i>parent</i> field is the ‚Äúparent‚Äù of this object. </li></ol><br>  Hereinafter, the terms ‚Äúparent‚Äù and ‚Äúheir‚Äù are used without being tied to one of the key OOP principles, and in the context of indicating the relative location of other objects relative to a given one in a formed tree structure. <br>  To clarify the above, we present an image of a tree structure for the expression ‚Äú(x + 10.2) ^ 2 + 5 * yz‚Äù, indicating the values ‚Äã‚Äãof all fields of the objects. <br><br><img src="https://habrastorage.org/files/aa6/c73/9c8/aa6c739c8b064511ae695b563a213bf8.png"><br><br>  From the above scheme, it becomes extremely clear why each node can have only two ‚Äúheirs‚Äù, or not have them at all. <br><br>  The resulting structure of objects is quite acceptable for calculating the values ‚Äã‚Äãof arithmetic expressions by calling the <i>calc ()</i> method of the highest on the object scheme. <br><br><h4>  Search for the inflection point of an arithmetic expression </h4><br>  The ‚Äúinflection point‚Äù of an arithmetic expression is understood to be one of the elements of the array of tokens, which is an operator (an arithmetic operation) and has a maximum priority value relative to other operators. <br><br>  To enter the ability to estimate the priority values ‚Äã‚Äãof arithmetic operations in the program, it is enough to define an array with the structure: <i>[+] =&gt; 3, [-] =&gt; 3, [*] =&gt; 2, [/] =&gt; 2, [^] =&gt; 1</i> . <br><br>  If the priority value is maximum for several operators, the last of them should be chosen, this will allow forming a tree structure that correctly calculates the numerical values. <br><br>  Next, in the array of lexemes, the elements standing to the left of the ‚Äúinflection point‚Äù are highlighted and are recorded in the <i>lec</i> field of the object that is the left ‚Äúheir‚Äù.  The elements located to the right of the ‚Äúinflection point‚Äù are entered into a similar field of the right ‚Äúheir‚Äù.  It should also be mentioned that when searching for the ‚Äúinflection point‚Äù one should take into account the level of nesting of brackets in the array of whole lexemes. <br><br><h4>  Construction of a tree structure </h4><br>  In this section, we analyze in detail the sequence of formation of the ‚Äútree‚Äù of objects within the framework of the proposed algorithm. <br>  Consider the procedure for building the first three objects of the "tree", including the root object and its two "heirs".  Having received at the input an array of solid tokens of the entire arithmetic expression, we find in it the ‚Äúinflection point‚Äù.  Let me remind you that this is always an operator (arithmetic action).  The value of the ‚Äúinflection point‚Äù found makes it possible to uniquely determine the class of an object located at the top of the structure.  Next, we divide the array of tokens into two parts, as described above.  In each of both parts, we also find points of "inflection", which indicate the class of objects of the left and right "heirs."  Now you can create all three objects and specify the links between them.  <i>Finally, the</i> objects are placed into the <i>arNode</i> array for subsequent actions on them. <br><br>  For our input expression: <i>(x + 10.2) ^ 2 + 5 * yz, the</i> described procedure is as follows.  The definition of the "inflection point" includes two operators: "+" (between the numbers "2" and "5") and "-".  Select the last operator in the list: "-".  The value of this operator allows you to select the desired class of the root object and its name.  In particular, a <i>Minus</i> class object with the name <i>Minus1 is formed</i> .  After dividing the initial array of lexemes into two parts, we obtain two arrays of elements: <i>(x + 10.2) ^ 2 + 5 * y</i> and <i>z</i> .  For the first lexeme, the inflection point is ‚Äú+‚Äù, and the second consists of only one element <i>z</i> .  This means that as the "heirs" of the root object, you should create objects of the classes <i>Plus</i> and <i>Constant</i> with the names <i>Plus1</i> and <i>Constant1,</i> respectively.  It remains to fill the fields of the newly created objects: <i>childrenLeft</i> , <i>childrenRight</i> and <i>parent</i> to form a tree structure and add objects to the <i>arNode</i> array. <br><br>  Further formation of the "tree" is very similar to the procedure for creating the first three, but has its own subtleties.  In the <i>arNode</i> array, <i>we</i> simply search the array elements for an object with a <i>lec</i> field containing more than one element in the array and at the same time with the empty <i>childrenLeft</i> and <i>childrenRight</i> fields.  We read the value of the <i>lec</i> field for the selected object, divide it into two parts at the ‚Äúinflection point‚Äù.  Next, we find the ‚Äúinflection points‚Äù of the resulting two parts and form two heir objects for the selected object, in accordance with the logic outlined above.  Do not forget to form links between objects and add the objects themselves to the <i>arNode</i> array. <br><br>  We repeat the specified sequence of actions until none of the objects of the tree structure corresponds to the specified conditions.  Now we can assume that the "tree" for our input expression is built and ready to calculate the values. <br><br><h4>  Calculating values </h4><br>  The process of calculating the values ‚Äã‚Äãof the input arithmetic expression becomes very clear when viewing the listing of the software implementation of the algorithm.  Let us dwell on some significant points. <br><br>  The calculation occurs after calling the <i>calc ()</i> method of the object of the class <i>Main</i> .  The program provides the ability to use no more than three parameters when calling this method: <i>x</i> , <i>y</i> , <i>z</i> .  It is easy to change this number to meet the needs of a specific application of the described algorithm. <br><br>  Previously, the method searches the array for objects describing the parameter tokens, then in the <i>var</i> fields of the found objects, the numeric values ‚Äã‚Äãspecified when calling the <i>calc ()</i> method are entered.  Now you can start searching in the <i>arNode</i> array of <i>an</i> object with an empty <i>parent</i> field (this will be the root object of the tree structure) and call its <i>calc ()</i> method.  The method returns the value of an arithmetic expression. <br><br><h4>  Sample software implementation </h4><br>  Listing of software implementation decided to lay out entirely.  This allows you to copy the entire program when you need to experiment with it or refine it. <br><br><pre><code class="php hljs">&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; <span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    var $arNode = Array(); //      public function calc($x, $y, $z){ if($x){ foreach ($this-&gt;arNode as $obj){ if($obj-&gt;const == "x"){ $obj-&gt;var = $x; break; } } } if($y){ foreach ($this-&gt;arNode as $obj){ if($obj-&gt;const == "y"){ $obj-&gt;var = $y; break; } } } if($z){ foreach ($this-&gt;arNode as $obj){ if($obj-&gt;const == "z"){ $obj-&gt;var = $z; break; } } } foreach ($this-&gt;arNode as $obj){ if(!$obj-&gt;parent){ return $obj-&gt;calc(); } } } //     public function builder ($str) { //    $arNode = Array(); //      function parse ($str){ //      $str = mb_strtolower($str, 'UTF-8'); $str = str_replace(" ", "", $str); $n = mb_strlen($str, 'UTF-8'); $arStr = preg_split('/(?!^)(?=.)/u', $str); echo '&lt;pre&gt;'; echo print_r($arStr); echo '&lt;/pre&gt;'; //       $j=0; $accum = $arStr[0]; for($i=1; $i&lt;$n+1; ++$i){ if ($i==$n+1){ $arLec[$j] = $accum; break; } if($accum=="-" &amp;&amp; $i==1){ if(preg_match("/\d/", $arStr[$i])){ $accum = $accum.$arStr[$i]; } if($arStr[$i]=="("){ $arLec[$j] = "0"; $arLec[++$j] = "-"; ++$j; $accum = $arStr[$i]; } continue; } if($accum=="-" &amp;&amp; $arLec[$j-1]=="("){ $accum = $accum.$arStr[$i]; continue; } if (preg_match("/^[\d.]/", $accum) &amp;&amp; preg_match("/^[\d.]/", $arStr[$i])){ $accum = $accum.$arStr[$i]; }else{ $arLec[$j] = $accum; ++$j; $accum = $arStr[$i]; } } /* $j = 0; if($arStr[0]=="-"){ $accum = $arStr[0]; }else{ $accum = $arStr[0]; } for ($i=1; $i&lt;$n+1; ++$i){ if ($i==$n+1){ $arLec[$j] = $accum; continue; } if (preg_match("/^[\d.]/", $accum)&amp;&amp;preg_match("/^[\d.]/", $arStr[$i])){ $accum = $accum.$arStr[$i]; }else{ $arLec[$j] = $accum; ++$j; $accum = $arStr[$i]; } } * */ echo '&lt;pre&gt;'; echo print_r($arLec); echo '&lt;/pre&gt;'; return $arLec; } //    function objBuilder($point){ static $arNumNode = Array( "addition" =&gt; 1, "subtraction" =&gt; 1, "exponentiation" =&gt;1, "multiplication" =&gt; 1, "division" =&gt; 1, "number" =&gt; 1, "constant" =&gt; 1); switch ($point){ case "+": $name = "Plus".$arNumNode["addition"]; $node = new Plus($name); ++$arNumNode["addition"]; break; case "-": $name = "Minus".$arNumNode["subtraction"]; $node = new Minus($name); ++$arNumNode["subtraction"]; break; case "*": $name = "Multiply".$arNumNode["multiplication"]; $node = new Multiply($name); ++$arNumNode["multiplication"]; break; case "/": $name = "Fission".$arNumNode["division"]; $node = new Fission($name); ++$arNumNode["division"]; break; case "^": $name = "Exponent".$arNumNode["exponentiation"]; $node = new Exponent($name); ++$arNumNode["exponentiation"]; break; case "x": $name = "Constant".$arNumNode["constant"]; $node = new Constant($name); $node-&gt;const = "x"; $node-&gt;var = 0; ++$arNumNode["constant"]; break; case "y": $name = "Constant".$arNumNode["constant"]; $node = new Constant($name); $node-&gt;const = "y"; $node-&gt;var = 0; ++$arNumNode["constant"]; break; case "z": $name = "Constant".$arNumNode["constant"]; $node = new Constant($name); $node-&gt;const = "z"; $node-&gt;var = 0; ++$arNumNode["constant"]; break; default: $name = "Variable".$arNumNode["number"]; $node = new Variable($name); $node-&gt;var = $point; ++$arNumNode["number"]; } return $node; } //     function trioBuilder($topLec, $leftLec, $rightLec, $topP, $leftP, $rightP, $topObj){ //   if(!$topObj){ $topTrio = objBuilder($topP); $topTrio-&gt;lec = $topLec; } else { $topTrio = $topObj; } //    $leftTrio = objBuilder($leftP); $leftTrio-&gt;lec = $leftLec; //    $rightTrio = objBuilder($rightP); $rightTrio-&gt;lec = $rightLec; //     $topTrio-&gt;childrenLeft = $leftTrio; $topTrio-&gt;childrenRight = $rightTrio; $leftTrio-&gt;parent = $topTrio; $rightTrio-&gt;parent = $topTrio; if(!$topObj){ $trio = Array($topTrio, $leftTrio, $rightTrio); return $trio; } else { $duo = Array($leftTrio, $rightTrio); return $duo; } } //      function stopBuild($arNode){ foreach ($arNode as $obj){ if($obj-&gt;lec[1] &amp;&amp; !$obj-&gt;childrenLeft &amp;&amp; !$obj-&gt;childrenRight){ return FALSE; } } return TRUE; } //      function searchObj($arNode){ foreach ($arNode as $obj){ if($obj-&gt;lec[1] &amp;&amp; !$obj-&gt;childrenLeft &amp;&amp; !$obj-&gt;childrenRight){ return $obj; } } } //     function inflPoint($lec){ $infl=0; $max=0; static $br = 0; static $arPrioritet = Array( "+" =&gt; 3, "-" =&gt; 3, "*" =&gt; 2, "/" =&gt; 2, "^" =&gt; 1); foreach ($lec as $key=&gt;$value){ if(preg_match("/^[\d.]/", $value)){ continue; } if($value=="("){ ++$br; continue; } if($value==")"){ --$br; continue; } if($arPrioritet[$value]-3*$br &gt;= $max){ $max=$arPrioritet[$value]-3*$br; $infl=$key; } } return $infl; } $arLec = parse($str); //    $topN = inflPoint($arLec); $topP = $arLec[$topN]; $leftLec = array_slice($arLec, 0, $topN); if($leftLec[0]=="(" &amp;&amp; $leftLec[count($leftLec)-1]==")"){ array_shift($leftLec); array_pop($leftLec); } $rightLec = array_slice($arLec, $topN+1); if($rightLec[0]=="(" &amp;&amp; $rightLec[count($rightLec)-1]==")"){ array_shift($rightLec); array_pop($rightLec); } $leftN = inflPoint($leftLec); $leftP = $leftLec[$leftN]; $rightN = inflPoint($rightLec); $rightP = $rightLec[$rightN]; $trio = trioBuilder($arLec, $leftLec, $rightLec, $topP, $leftP, $rightP, NULL); $arNode = $trio; //     while (!stopBuild($arNode)){ $topTrio = searchObj($arNode); $arLec = $topTrio-&gt;lec; $topN = inflPoint($arLec); $leftLec = array_slice($arLec, 0, $topN); if($leftLec[0]=="(" &amp;&amp; $leftLec[count($leftLec)-1]==")"){ array_shift($leftLec); array_pop($leftLec); } $rightLec = array_slice($arLec, $topN+1); if($rightLec[0]=="(" &amp;&amp; $rightLec[count($rightLec)-1]==")"){ array_shift($rightLec); array_pop($rightLec); } $leftN = inflPoint($leftLec); $leftP = $leftLec[$leftN]; $rightN = inflPoint($rightLec); $rightP = $rightLec[$rightN]; $duo = trioBuilder(NULL, $leftLec, $rightLec, NULL, $leftP, $rightP, $topTrio); $arNode = array_merge($arNode, $duo); } $this-&gt;arNode = $arNode; } } abstract class Term { public $name; public $childrenLeft; public $childrenRight; public $parent; public $lec; public $const; public $var; public function __construct($name) { $this-&gt;name = $name; } abstract function calc(); } class Plus extends Term { public function calc() { return $this-&gt;childrenLeft-&gt;calc()+$this-&gt;childrenRight-&gt;calc(); } } class Minus extends Term { public function calc() { return $this-&gt;childrenLeft-&gt;calc()-$this-&gt;childrenRight-&gt;calc(); } } class Multiply extends Term { public function calc() { return $this-&gt;childrenLeft-&gt;calc()*$this-&gt;childrenRight-&gt;calc(); } } class Fission extends Term { public function calc() { return $this-&gt;childrenLeft-&gt;calc()/$this-&gt;childrenRight-&gt;calc(); } } class Exponent extends Term { public function calc() { return pow ($this-&gt;childrenLeft-&gt;calc(), $this-&gt;childrenRight-&gt;calc()); } } class Constant extends Term { public function calc() { return $this-&gt;var; } } class Variable extends Term { public function calc() { return $this-&gt;var; } } //     $str = "(x+10.2)^2+5*yz"; $x = 2; $y = 1; $z = 3; $parse = new Main(); //    $parse-&gt;builder($str); //echo '&lt;pre&gt;'; //echo print_r($parse-&gt;arNode); //echo '&lt;/pre&gt;'; echo $str." = ".$parse-&gt;calc($x, $y, $z); echo " : x=".$x."; y=".$y."; z=".$z; </span><span class="hljs-meta"><span class="hljs-comment"><span class="hljs-meta">?&gt;</span></span></span><span class="hljs-comment"> &lt;/body&gt; &lt;/html&gt;</span></span></code> </pre> <br>  If you remove the comments from the three consecutive <i>echo</i> statements at the end of the program, you can analyze the correctness of the formation of the tree structure and see the field values ‚Äã‚Äãof all objects. <br><br><h4>  Conclusion </h4><br>  I tried to describe the algorithm in as much detail as possible, but if you have any questions, write, I will try to answer everyone.  I would also be grateful for reports of errors and inaccuracies in the text. </div><p>Source: <a href="https://habr.com/ru/post/263775/">https://habr.com/ru/post/263775/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263763/index.html">How does this mysterious HTC Dot View work?</a></li>
<li><a href="../263765/index.html">Data structures Informal guide</a></li>
<li><a href="../263769/index.html">A brief history of the evolution of proof-of-work in cryptocurrencies. Part 1</a></li>
<li><a href="../263771/index.html">How to set up directory synchronization in IP PBX - search by ODBC</a></li>
<li><a href="../263773/index.html">How ITSM-System ServiceNow appeared in our cloud</a></li>
<li><a href="../263777/index.html">VMware vSphere 5.5 and 6.0 performance - settings, considerations. Performance best practices</a></li>
<li><a href="../263779/index.html">Fujitsu PRIMEQUEST: standard platform with mainframe reliability</a></li>
<li><a href="../263781/index.html">Choosing a plugin for caching WordPress: benchmarking 18 plugins</a></li>
<li><a href="../263783/index.html">Spy stuff in Wolfram Language, or how to hide anything in the picture</a></li>
<li><a href="../263785/index.html">Antivirus fight</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>