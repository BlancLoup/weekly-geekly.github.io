<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Counts for the smallest: Dijkstra or how I did not go on an interview on Twitter</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago, I came across an article about how Michael Kozakov could not solve an algorithmic problem during an interview on Twitter. The solutio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Counts for the smallest: Dijkstra or how I did not go on an interview on Twitter</h1><div class="post__text post__text-html js-mediator-article">  Not so long ago, I came across an <a href="http://habrahabr.ru/post/200190/">article</a> about how Michael Kozakov could not solve an algorithmic problem during an interview on Twitter.  The solution of this problem is almost purely one of the most standard algorithms on graphs, namely, the Dijkstra algorithm. <br>  In this article I will try to tell Dijkstra's algorithm on the example of solving this problem in a somewhat complicated form.  All who are interested, please under the cat. <a name="habracut"></a><br><br><h4>  Previous Cycle Articles </h4>  In previous articles, <a href="http://habrahabr.ru/post/200074/">DFS</a> , <a href="http://habrahabr.ru/post/200252/">BFS</a> and <a href="http://habrahabr.ru/post/201588/">Ford-Bellman</a> algorithms were considered. <br><br><h4>  Formulation of the problem </h4>  The formulation of the problem is very similar to the problem solved by the Ford-Bellman algorithm: it is required to find the shortest path from the selected vertex of the weighted graph (initial) to all the others.  The only difference is that now the weights of all edges are non-negative. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Algorithm Description </h4><img src="https://habrastorage.org/getpro/habr/post_images/868/13a/f1d/86813af1dcf4208c8d9fedbf72293f3a.gif" align="right">  We divide all vertices into two sets: already processed and not yet.  Initially, all vertices are raw, and the distances to all vertices, except the initial one, are equal to infinity, the distance to the initial vertex is 0. <br>  At each iteration, a vertex with a minimum distance is taken from the set of raw vertices and processed: all edges emanating from it are relaxed, after which the vertex is placed into the set of already processed vertices. <br>  I recall that the relaxation of the edge (u, v), as in the Ford-Bellman algorithm, consists in assigning dist [v] = min (dist [v], dist [u] + w [u, v]), where dist [ v] is the distance from the initial vertex to the vertex v, and w [u, v] is the weight of the edge from u to v. <br><br><h4>  Implementation </h4>  In the simplest implementation of Dijkstra's algorithm, at the beginning of each iteration, you need to walk through all the vertices in order to select a vertex with the minimum distance.  This is quite a long time, although it can be justified in dense graphs, so usually some kind of data structure is used to store the distances to the vertices.  I will use std :: set, simply because I don‚Äôt know how to change the element in std :: priority_queue =) <br>  I also assume that the graph is represented as vector &lt;vector &lt;pair &lt;int, int&gt;&gt;&gt; edges, where edges [v] is the vector of all edges emanating from the vertex v, the first edge field is the number of the final vertex, and the second weight. <br><div class="spoiler">  <b class="spoiler_title">Dijkstra</b> <div class="spoiler_text"><pre><code class="hljs markdown">void Dijkstra(int v) { //  int n = (int)edges.size(); dist.assign(n, INF); dist[<span class="hljs-string"><span class="hljs-string">v</span></span>] = 0; set<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">pair</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &gt; q; for (int i = 0; i <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">n</span></span></span></span><span class="xml"><span class="hljs-tag">; ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">) { </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">q.insert</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">make_pair</span></span></span></span><span class="xml"><span class="hljs-tag">(</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dist</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">], </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">)); } //   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">-</span></span></span></span><span class="xml"><span class="hljs-tag">     </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">while</span></span></span></span><span class="xml"><span class="hljs-tag"> (!</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">q.empty</span></span></span></span><span class="xml"><span class="hljs-tag">()) { //      </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">pair</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> cur = *q.begin(); q.erase(q.begin()); //     for (int i = 0; i <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt; (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag">)</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">edges</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cur.second</span></span></span></span><span class="xml"><span class="hljs-tag">]</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.size</span></span></span></span><span class="xml"><span class="hljs-tag">(); ++</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">) { //   </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">if</span></span></span></span><span class="xml"><span class="hljs-tag"> (</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">dist</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">edges</span></span></span></span><span class="xml"><span class="hljs-tag">[</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">cur.second</span></span></span></span><span class="xml"><span class="hljs-tag">][</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">i</span></span></span></span><span class="xml"><span class="hljs-tag">]</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">.first</span></span></span></span><span class="xml"><span class="hljs-tag">] &gt;</span></span></span></span> cur.first + edges[<span class="hljs-string"><span class="hljs-string">cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].second) { q.erase(make<span class="hljs-emphasis"><span class="hljs-emphasis">_pair(dist[edges[cur.second][i].first], edges[cur.second][i].first)); dist[edges[cur.second][i].first] = cur.first + edges[cur.second][i].second; q.insert(make_</span></span>pair(dist[<span class="hljs-string"><span class="hljs-string">edges[cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].first], edges[<span class="hljs-string"><span class="hljs-string">cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].first)); } } } }</code> </pre> <br></div></div><br><h4>  Proof of correctness </h4>  Suppose the algorithm was launched on some graph from the vertex u and gave the wrong distance value for some vertices, and v is the first of these vertices (the first in the sense of the order in which the algorithm spat out the vertices).  Let w be its ancestor in the shortest path from u to v. <br>  Note that the distance to w is calculated correctly by assumption <ul><li>  Let the algorithm found dist '[w] &lt;dist [v].  Then consider the last relaxation of the edge leading to v: (s, v).  The distance to s was calculated correctly, so there is a path from u to v of weight dist [s] + w [s, v] = dist '[v] &lt;dist [v].  Contradiction </li><li>  Let the algorithm found dist '[w]&gt; dist [v].  Then consider the moment of processing the vertex w.  At this moment, the edge (w, v) was relaxed, and, accordingly, the current estimate of the distance to the vertex v became equal to dist [v], and during the subsequent relaxations it could not decrease.  Contradiction </li></ul>  Thus, the algorithm works correctly. <br>  Note that if the graph had negative weight edges, then the vertex w could be spat out later than the vertex v, respectively, the relaxation of the edge (w, v) was not performed.  Dijkstra's algorithm only works for graphs without negative weight edges! <br><br><h4>  Algorithm complexity </h4>  Vertices are stored in some data structure that supports the operations of changing an arbitrary element and extracting the minimum. <br>  Each vertex is extracted exactly once, that is, O (V) extraction is required. <br>  In the worst case, each edge leads to a change in one element of the structure, that is, O (E) changes. <br>  If the vertices are stored in a simple array and a linear search algorithm is used to search for the minimum, the time complexity of the Dijkstra algorithm is O (V * V + E) = O (V¬≤). <br>  If a priority queue is used, implemented on the basis of a binary heap (or based on a set), then we get O (V log V + E log E) = O (E log V). <br>  If the priority queue was implemented on the basis of the Fibonacci heap, the best O (V log V + E) complexity score is obtained. <br><br><h4>  But what is the problem with the interview on Twitter? </h4>  The task from the interview itself is not very interesting to solve, so I suggest complicating it.  Before further reading the article, I recommend reading the <a href="http://habrahabr.ru/post/200190/">original formulation of the problem.</a> <br><br><h4>  New problem statement with the interview </h4><ul><li>  Let's name the task from the one-dimensional interview.  Then in the k-dimensional analogue there will be columns numbered k by numbers, for each of which the height is known.  Water can flow down from a column to a neighboring column of lesser height, or beyond the edge. </li><li>  What are ‚Äúadjacent posts‚Äù?  Let each column have its own list of neighbors, whatever.  It can be connected by a pipe with another column through the entire map, or fenced off by fences from "intuitively adjacent" </li><li>  What is the "edge"?  For each column, we define a separate field indicating whether it is extreme.  Maybe we have a hole in the middle of the field? </li></ul><br><h4>  Now we will solve this problem, and the complexity of the solution will be O (N log N) </h4>  We construct the graph in this problem as follows: <ul><li>  The vertices will be columns (and plus another fictitious vertex located ‚Äúbeyond the edge‚Äù). </li><li>  Two vertices will be connected by an edge if they are adjacent in our system (or if one of these vertices is an ‚Äúedge‚Äù, the other is an extreme bar) </li><li>  The weight of the edge will be equal to the maximum of the heights of the two columns that it connects </li></ul><br>  Even on such a ‚Äútricky‚Äù graph, by running the Dijkstra algorithm, we will not get anything useful, so we modify the concept of ‚Äúweight of the path in the graph‚Äù - now it will not be the sum of the weights of all edges, but their maximum.  I recall that the distance from the vertex u to the vertex v is the minimum of the weights of all the paths connecting u and v. <br>  Now everything falls into place: in order to get beyond the edge from a certain central column, one has to follow a certain path (along which water will flow), and the maximum height of the columns of this path will at best coincide with the ‚Äúdistance‚Äù from the initial column to the "edge" (or, since the graph is not oriented, from the "edge" to the initial column).  It remains only to apply the algorithm Dijkstra. <br><div class="spoiler">  <b class="spoiler_title">Implementation</b> <div class="spoiler_text"><pre> <code class="hljs markdown">void Dijkstra(int v) { //  int n = (int)edges.size(); dist.assign(n, INF); dist[<span class="hljs-string"><span class="hljs-string">v</span></span>] = 0; set<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">pair</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag">, </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">int</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &gt; q; for (int i = 0; i &gt; n; ++i) { q.insert(make<span class="hljs-emphasis"><span class="hljs-emphasis">_pair(dist[i], i)); } //   -     while (!q.empty()) { //      pair&lt;int, int&gt; cur = *q.begin(); q.erase(q.begin()); //     for (int i = 0; i &lt; (int)edges[cur.second].size(); ++i) { //   if (dist[edges[cur.second][i].first] &gt; max(cur.first, edges[cur.second][i].second)) { q.erase(make_</span></span>pair(dist[<span class="hljs-string"><span class="hljs-string">edges[cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].first], edges[<span class="hljs-string"><span class="hljs-string">cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].first)); dist[<span class="hljs-string"><span class="hljs-string">edges[cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].first] = max(cur.first, edges[<span class="hljs-string"><span class="hljs-string">cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].second); q.insert(make_pair(dist[<span class="hljs-string"><span class="hljs-string">edges[cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].first], edges[<span class="hljs-string"><span class="hljs-string">cur.second</span></span>][<span class="hljs-symbol"><span class="hljs-symbol">i</span></span>].first)); } } } }</code> </pre><br></div></div><br><h4>  But it's harder and longer than the original solution!  Who needs it at all ?! </h4>  I draw your attention that we solved the problem in general.  If we consider exactly the formulation that was in the interview, it is worth noting that at each iteration there are no more than two raw vertices, the distance to which is not equal to infinity, and you need to choose only among them. <br>  It is easy to see that the algorithm completely coincides with the one proposed in the original article. <br><br><h4>  Was this task a good one? </h4>  I think this problem is well suited for explaining Dijkstra‚Äôs algorithm.  My personal opinion about whether it was worth giving it, is hidden under the spoiler.  If you do not want to see him - do not open. <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text">  If a person is at least a little versed in graphs, he knows exactly Dijkstra's algorithm ‚Äî he is one of the very first and simplest.  If a person knows Dijkstra's algorithm, it will take him five minutes to solve this problem, of which two are reading the condition and three are writing the code.  Of course, you should not give such a task at a job interview for a designer or a system administrator, but considering that Twitter is a social network (and it can easily solve problems on the graphs), and the applicant passed an interview for a developer job, I believe that after a wrong answer to this task was really worth politely saying goodbye to him. <br>  However, this task cannot be the only one at the interview: my wife, a 4th year student at the Economics Department of the National Academy of Sciences, decided it in ten minutes, but she is hardly a good programmer =) <br>  Once again: the task does not separate the clever from the stupid or the olympiads from the non-olympiadians.  It separates those who have ever heard of the counts (+ those who are lucky) from those who have not heard. <br>  And, of course, I believe that the interviewer should have paid the applicant‚Äôs attention to an error in the code. <br></div></div><br><h4>  PS </h4>  Recently, I wrote a small series of articles on algorithms.  In the next article it is planned to consider the Floyd algorithm, and then give a small summary table of path finding algorithms in the graph. </div><p>Source: <a href="https://habr.com/ru/post/202314/">https://habr.com/ru/post/202314/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202304/index.html">Tiny Excel in pure javascript (30 lines of code)</a></li>
<li><a href="../202306/index.html">ScienceHub # 06: Computational Linguistics</a></li>
<li><a href="../202308/index.html">Baytkod</a></li>
<li><a href="../202310/index.html">04 Collector: links for designers and developers</a></li>
<li><a href="../202312/index.html">Qt: template for correct work with threads</a></li>
<li><a href="../202318/index.html">About summer internship at JetBrains</a></li>
<li><a href="../202322/index.html">72-megapixel camera-ball shoots 360-degree panoramas in flight</a></li>
<li><a href="../202324/index.html">DDR4 will be available next month.</a></li>
<li><a href="../202328/index.html">Could there be too much automation on the plane?</a></li>
<li><a href="../202332/index.html">25th anniversary of the Buran flight</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>