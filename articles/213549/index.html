<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Box2d: Collision Anatomy</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="What are collisions? 
 In Box2D, it is assumed that bodies collide with each other, but in fact, fixtures are used in calculating collisions (fixtures...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Box2d: Collision Anatomy</h1><div class="post__text post__text-html js-mediator-article"><h5>  What are collisions? </h5><br>  In Box2D, it is assumed that bodies collide with each other, but in fact, fixtures are used in calculating collisions (fixtures, word translations <a href="">exist</a> , but I am not sure if there is an established one among them).  Objects can collide in different ways, so the library provides a large amount of clarifying information that can be used in the game logic.  For example, you might want to know the following: <br><br><ul><li>  When the collision begins and ends </li><li>  Point of contact fixtures </li><li>  Normal to the line of contact fixtures </li><li>  What energy was applied and the result of a collision </li></ul><br>  Usually the collision occurs very quickly, however, in this article we will try to take one specific collision and slow it down in order to have time to consider the details of what is happening and the information that can be extracted from the event. <br><a name="habracut"></a><br>  In our scenario, two polygonal fixtures in the world with zero gravity will collide (to better control the process).  The first fixture is a stationary square, the second is a triangle moving horizontally towards the square. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c46/b11/186/c46b11186e8901a142a8a58cc22df516.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Everything is set up so that the bottom of the triangle faces the top corner of the square.  The intricacies of the implementation of this process are beyond the scope of the article - we will focus on what information can be extracted at each stage of the collision.  If there is a desire to independently run the proposed example, the <a href="http://www.iforce2d.net/b2dtut/sourcecode">source code is</a> attached. <br><br><h5>  Collision information retrieval </h5><br>  Collision information is contained in a <b>b2Contact</b> type <b>object</b> .  From it you can find out exactly which fixtures collide, and determine their position and direction of the resulting pulses.  There are two ways to get <b>b2Contact</b> objects in Box2D.  The first is to loop through the current contact list of each object body, the second is to use the contact listener.  We will consider each of them in order to further understand what is being said. <br><br><h6>  Contact list check </h6><br>  At any time, you can sort through all the contacts of the world (meaning <b>b2World</b> ) <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (b2Contact* contact = world-&gt;GetContactList(); contact; contact = contact-&gt;GetNext()) contact-&gt;... <span class="hljs-comment"><span class="hljs-comment">//do something with the contact</span></span></code> </pre> <br>  or get body contacts of a certain object <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (b2ContactEdge* edge = body-&gt;GetContactList(); edge; edge = edge-&gt;next) edge-&gt;contact-&gt;... <span class="hljs-comment"><span class="hljs-comment">//do something with the contact</span></span></code> </pre><br>  If this approach is chosen, <u>it is very important to remember</u> that the <b>presence of a contact in these lists does not mean that the fixtures are in contact</b> - this only means that their <a href="http://ru.wikipedia.org/wiki/AABB">AABBs</a> intersect.  If you want to make sure that the fixtures themselves are in contact, use the <b>IsTouching ()</b> method.  To this question we will return. <br><br><h6>  Contact listeners </h6><br>  Checking the contact list becomes ineffective in situations where collisions occur frequently and in large quantities.  By establishing contact listeners, you instruct Box2D to report when something interesting happens, instead of manually watching for the start and end of collisions.  The contact listener is an object of the <b>b2ContactListener</b> class, some of the functions of which are replaced if necessary. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BeginContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b2Contact* contact)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EndContact</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b2Contact* contact)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PreSolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b2Contact* contact, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b2Manifold* oldManifold)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PostSolve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b2Contact* contact, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> b2ContactImpulse* impulse)</span></span></span></span>;</code> </pre><br>  I should note that, depending on the situation, some events give us not only the <b>b2Contact</b> object.  During the execution of the <b>Step</b> function, when Box2D determines that a contact has occurred, it calls back certain functions of the listener to notify you.  The practical use of " <a href="http://www.iforce2d.net/b2dtut/collision-callbacks">callbacks for collisions</a> " is discussed in a separate article.  Here we will focus all our attention on what can be learned by handling collision events. <br><br>  In general, I recommend the contact listener method.  At first glance, it may seem a little awkward, but it is more effective and useful in the long run.  Until now, I have not encountered a situation where checking the contact list would give a tangible gain. <br><br>  Regardless of the method of obtaining contacts, they contain the same information.  The most important data about intersecting fixtures can be obtained as follows. <br><br><pre> <code class="cpp hljs">b2Fixture* a = contact-&gt;GetFixtureA(); b2Fixture* b = contact-&gt;GetFixtureB();</code> </pre><br>  When the contact list of a particular object is traversed, perhaps one of the collision fixtures is known, but if you use the contact listener, you will have to fully rely on these functions to understand what you are facing.  A clearly defined order of the fixtures does not exist, so it is often necessary to set <a href="http://www.iforce2d.net/b2dtut/user-data">user data (user data)</a> in order to understand which particular object the fixture or body belongs to.  With the <b>fixture</b> object, you can use the <b>GetBody ()</b> method to get a reference to the body. <br><br><h5>  Clash step by step. </h5><br>  Now let's take a closer look at the sequence of events that occur during a collision.  I hope, pictures with the description of each step will be enough to understand the material.  You may want to download the <a href="http://www.iforce2d.net/b2dtut/sourcecode">source code</a> to the lesson in order to run it while reading.  The test program allows you to pause the simulation, restart and execute it step by step. <br><br>  Let's start with a situation where AABB fixtures do not intersect, so we can trace the story completely.  Click the ‚ÄúAABBs‚Äù box to see the purple rectangular areas around each fixture. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/839/03b/e36/83903be36e1f86d0d951bada663cad50.png"><br><br><h6>  AABB fixtures start to overlap </h6><br>  Despite the fact that the fixtures themselves have not yet intersected, at this stage an instance of <b>b2Contact</b> is already created and added to the contact list of the world and the lists of each body.  If you are viewing these lists, then by the presence of <b>b2Contact</b> objects <b>you</b> can judge that contact is possible in principle, although the fixtures are not necessarily intersected. <br><br>  Result: the contact exists, but <b>IsTouching ()</b> returns false <br><br>  We continue the simulation, until the fixtures directly cross ... <br><br><h6>  Fixtures begin to cross. </h6><br><img src="https://habrastorage.org/getpro/habr/post_images/ef0/1f4/762/ef01f47624922cfc91f66a863e1ff6d3.png"><br><br>  Approaching the top corner of the square, you can see the transition, as in the following images <br><br>  Step n <br><img src="https://habrastorage.org/getpro/habr/post_images/e28/7c9/1aa/e287c91aa4348cd20f352697b544c246.png"><br><br>  Step n + 1 (not bullet objects) <br><img src="https://habrastorage.org/getpro/habr/post_images/a64/9e6/f37/a649e6f372061a67a972ea4648c7438a.png"><br><br>  All this happens in one step of the simulation, which means that the real point of intersection (to which the dotted line in the figure above leads), we slipped.  This is because Box2D first displaces all the bodies and only then checks the intersection, at least this is its default behavior.  If you need a real point of contact, you need to do the following <br><br><pre> <code class="cpp hljs">bodyDef.bullet = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//before creating body, or body-&gt;SetBullet(true); //after creating body</span></span></code> </pre><br>  Step n + 1 (triangle - bullet-object) <br><img src="https://habrastorage.org/getpro/habr/post_images/238/df1/dd9/238df1dd95b14358be2d849432ff71e7.png"><br><br>  Bullet-bodies, spend more CPU time on calculations and are not required for most applications.  Just remember that at normal settings, sometimes collisions can be skipped - in our example, if the triangle moved fast enough, it could fly through the corner of a square without initiating a collision.  If you have very fast moving bodies whose contacts should not be skipped, for example, mmmm ... bullets :) then they should be declared as bullet-objects.  Further presentation will be carried out for non-bullet-tel. <br><br>  Result: <br><ul><li>  IsTouching () returns true </li><li>  BeginContact callback function </li></ul><br><h5>  Collision points and normal </h5><br>  At this point in our contact there is a real contact, which makes it possible to answer not some questions at the beginning of the article.  First, let's get the normal and touch point.  It is assumed that the following code is called either from the <b>BeginContact</b> method of the <b>contact</b> listener or from your method after first receiving the contact from the list. <br><br>  The contact object contains information about collisions in the local coordinates of the bodies of the colliding objects, and this is not exactly what we need.  However, you can ask the contact for a more useful <b>b2WorldManifold</b> structure, which contains the collision position in world coordinates. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> numPoints = contact-&gt;GetManifold()-&gt;pointCount; <span class="hljs-comment"><span class="hljs-comment">//...world manifold is helpful for getting locations b2WorldManifold worldManifold; contact-&gt;GetWorldManifold( &amp;worldManifold ); //draw collision points glBegin(GL_POINTS); for (int i = 0; i &lt; numPoints; i++) glVertex2f(worldManifold.points[i].x, worldManifold.points[i].y); glEnd();</span></span></code> </pre><br><img src="//habrastorage.org/files/046/ddf/9fb/046ddf9fb8454dc890218e335a48b7b2.png"><br><br>  The resulting points will be used by Box2D to calculate the response to a collision to calculate the momentum, which will direct the fixtures in opposite directions.  These will be inaccurate points of contact for fixtures (unless you have used bullet-objects), although in practice they are usually enough to calculate collisions in the game logic. <br><br>  Next, we consider the collision normal, which is directed from fixture A to B: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> normalLength = <span class="hljs-number"><span class="hljs-number">0.1f</span></span>; b2Vec2 normalStart = worldManifold.points[<span class="hljs-number"><span class="hljs-number">0</span></span>] - normalLength * worldManifold.normal; b2Vec2 normalEnd = worldManifold.points[<span class="hljs-number"><span class="hljs-number">0</span></span>] + normalLength * worldManifold.normal; glBegin(GL_LINES); glColor3f(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);<span class="hljs-comment"><span class="hljs-comment">//red glVertex2f( normalStart.x, normalStart.y ); glColor3f(0,1,0);//green glVertex2f( normalEnd.x, normalEnd.y ); glEnd();</span></span></code> </pre><br>  It seems that for this collision, the fastest way to get rid of overlapping objects is to push the angle of the triangle up and to the left, and the square - down and to the right.  I would like to draw your attention to the fact that the normal is just a direction, it is not tied to any point of contact - I have depicted it passing through points [0] for convenience. <br><br><img src="http://1450828516347682825606"><br><br>  It is also important to remember that the collision normal does not determine the angle between fixtures (the triangle moves generally horizontally) - it only sets the direction, following which the overlapping of objects is most quickly compensated.  For example, imagine that the triangle moves a little faster, and the overlap looks like this: <br><br><img src="//habrastorage.org/files/1a2/b01/55a/1a2b0155ad3a45eb8adaeab5fcf51e21.png"><br><br>  Then the fastest way to split fixtures is to push the triangle up and to the right.  So to use the normal to calculate the angle between objects is impractical.  If you want to know the directions in which the figures will be divided, you can use the following code: <br><br><pre> <code class="cpp hljs">b2Vec2 vel1 = triangleBody-&gt;GetLinearVelocityFromWorldPoint( worldManifold.points[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); b2Vec2 vel2 = squareBody-&gt;GetLinearVelocityFromWorldPoint( worldManifold.points[<span class="hljs-number"><span class="hljs-number">0</span></span>] ); b2Vec2 impactVelocity = vel1 - vel2;</code> </pre><br>  It will allow to obtain the relative reaction rate of all points of the colliding bodies.  In our simple case, it would be possible to limit ourselves to the linear velocity of the triangle, since it is known that the square is stationary and the triangle does not rotate.  But the above code will take into account the cases when both things move or rotate. <br><br>  It should also be noted that not every collision will have exactly two collision points.  I intend to stop at a rather complicated example, when two corners of polygons overlap, but more often there is only one such point.  Here are some examples of collisions for which one point is enough <br><br><img src="//habrastorage.org/files/6cc/3e0/387/6cc3e03870364f749355be2a5bcd5551.png"><br><br><img src="//habrastorage.org/files/22a/e41/4c0/22ae414c0dd549ab8e941a10cf0c20f5.png"><br><br><img src="//habrastorage.org/files/98e/354/534/98e35453424c439c9565a083f001f7a8.png"><br><br>  So, we have just considered how to determine the points and the normal of a collision, on the basis of which Box2D will calculate the reaction aimed at compensating the overlap.  Now back to the sequence of events. <br><br><h6>  Collision response </h6>  ((b2Contact :: Update, b2Island :: Report)) <br>  Collision pitch <br><img src="http://1450828516347682825606"><br><br>  Collision pitch + 1 <br><img src="//habrastorage.org/files/9a2/3cc/057/9a23cc05761a40298fced3fbcf933219.png"><br><br>  Collision pitch + 1 <br><img src="//habrastorage.org/files/02f/c76/87c/02fc7687c4ea42b390ac64da5c5b9267.png"><br><br>  When the fixtures overlap, the default Box2d reaction is to apply a pulse to each of them in order to direct them in different directions.  However, it is not always possible to do this in one step of the simulation.  As shown in the figures for our example, the two fixtures will overlap in three steps, until the rebound takes place and they finally separate. <br><br>  At this time, we can intervene and adjust the behavior of the model as we like.  If the contact listener approach is used, the <b>PreSolve</b> and <b>PostSolve methods</b> will be called <b>at each step while the fixtures overlap</b> , making it possible to modify the contact before it is processed by standard means of reaction to a collision (PreSolve), and find out which impulses were applied by Box2D ( PostSolve) <br><br>  For greater clarity, here is the output of printf, which is placed in the Step function and each method of the contact listener: <br><pre> <code class="bash hljs"> ... Step Step BeginContact PreSolve PostSolve Step PreSolve PostSolve Step PreSolve PostSolve Step EndContact Step Step ...</code> </pre><br>  Result: PreSolve and PostSolve are called several times. <br><br><h5>  PreSolve and PostSolve </h5><br>  Both of these methods receive a pointer to <b>b2Contact</b> as a parameter, so we have access to the same information about points and normals as in BeginContact.  <b>PreSolve</b> gives you the opportunity to change the characteristics of the contact before calculating the reaction to a collision, and even cancel the reaction completely.  <b>PostSolve</b> allows you to get information about the calculated reaction. <br><br>  In <b>PreSolve,</b> you can make the following settings for the contact object: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetEnabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flag)</span></span></span></span>;<span class="hljs-comment"><span class="hljs-comment">//non-persistent - need to set every time step //these available from v2.2.1 void SetFriction(float32 friction);//persists for duration of contact void SetRestitution(float32 restitution);//persists for duration of contact</span></span></code> </pre><br>  Calling <b>SetEnabled (false)</b> deactivates the contact, so the reaction to the collision will not be calculated.  This may be necessary when it is necessary to temporarily allow objects to fly through each other.  A classic example is a one-sided wall or platform where a player can pass through a usually impassable object under certain conditions that can only be checked at run time ‚Äî for example, the player‚Äôs position or direction of movement. <br><br>  It is important to remember that <b>at the next iteration the contact is activated again</b> , so if you need to turn it off for a long time, you will have to do it at each step. <br><br>  In addition to the contact reference, <b>PreSolve</b> contains a second parameter from which you can get the collision characteristics (points and normal) from the previous simulation step.  If someone knows why this might be useful - tell me: D <br><br>  <b>PostSolve</b> is called after the collision response has been calculated and applied.  The method has a second parameter containing information about the impulse applied as a result.  It is usually used to check whether a reaction has exceeded a certain threshold value, as a result of which an object can be destroyed, etc.  The article " <a href="http://www.iforce2d.net/b2dtut/sticky-projectiles">sticky projectiles</a> " contains an example of using the <b>PostSolve</b> function to determine if an arrow should get stuck in a target. <br><br>  Returning to the collision scenario. <br><br><h6>  Fixtures no longer overlap. </h6>  (b2Contact :: Update) <br>  AABBs still overlap, so contact remains in the respective lists of the world and body. <br><br><img src="//habrastorage.org/files/08a/97c/236/08a97c23649443329d6cafede0daddc9.png"><br><br>  (increased scale) <br><img src="//habrastorage.org/files/bb3/688/34c/bb368834c9f3446795e97acfd757d01e.png"><br><br>  Result: <br><ul><li>  Called EndContact </li><li>  IsTouching () returns false </li></ul><br>  This continues until the AABB ceases to overlap. <br><br><h6>  AABB fixtures do not overlap </h6>  (b2ContactManager :: Collide) <br><img src="//habrastorage.org/files/8e9/520/f1c/8e9520f1cbb44a81995a91b016a0d4b8.png"><br><br>  Result: the contact is removed from the contact list of the world and the body. <br><br>  The <b>EndContact</b> method receives a pointer to <b>b2Contact</b> when the fixtures are no longer in contact, so that it no longer contains relevant information.  However, <b>EndContact</b> is an integral element of the contact listener, as it allows you to control when game objects leave the contact area. <br><br><h5>  Total </h5><br>  I hope that the article gives a clear overview of what is happening in millisecond after millisecond in the depths of the Box2D collision calculation mechanism.  Perhaps it was not the most interesting reading, but after studying various issues on the forums, I didn‚Äôt have the feeling that some of the details were often missed, as a result, a lot of time was spent trying to figure out what was going on at all ... I also noticed a tendency when listener contacts are not solved, while it requires much less effort compared with the subsequent tasks.  Knowledge of the described parts should give a better understanding of things that can be implemented, improve the design and save time. </div><p>Source: <a href="https://habr.com/ru/post/213549/">https://habr.com/ru/post/213549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../213531/index.html">Vsem Pro Server or VPS Large-Scale Testing</a></li>
<li><a href="../213537/index.html">Encrypted communication tunnel via VK (RSA + GreaseMonkey)</a></li>
<li><a href="../213539/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ97 (February 16 - 22, 2014)</a></li>
<li><a href="../213541/index.html">NetBeans IDE 8.0 Beta released</a></li>
<li><a href="../213545/index.html">War Space</a></li>
<li><a href="../213551/index.html">[User experience] Audio-Technica ANC7b - full immersion</a></li>
<li><a href="../213553/index.html">Happy Defender of the Fatherland</a></li>
<li><a href="../213555/index.html">The history of game consoles in advertising. Part 2</a></li>
<li><a href="../213557/index.html">Shell - console Just for fun</a></li>
<li><a href="../213559/index.html">Network programming for game developers. Part 3: virtual connections over UDP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>