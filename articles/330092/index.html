<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monte Carlo and tic-tac-toe tree search</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So it turned out that to get a programming machine, poor first-timers were given one interesting task: to write a program that searches for a tree usi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monte Carlo and tic-tac-toe tree search</h1><div class="post__text post__text-html js-mediator-article"><p>  So it turned out that to get a programming machine, poor first-timers were given one interesting task: to write a program that searches for a tree using the Monte-Carlo method. </p><br><a name="habracut"></a><br><p>  Of course, it all started with searching for information on the Internet.  In the great and mighty Russian language there were only a couple of articles from Habr, verbally explaining the essence of the algorithm, and an article from Wikipedia that redirects to the problem of the game of Go and the computer.  For me, this is a good start.  Google in English for completeness and stumble on an English article from Wikipedia, in which the algorithm is also explained verbally. </p><br><h2 id="nemnogo-teorii">  Some theory </h2><br><p>  The Monte Carlo method for searching a tree has been used for a long time in games for artificial intelligence.  The task of the algorithm is to choose the most advantageous scenario.  A tree is a structure in which, in addition to the move and pointers, there is the number of games played and the number of games won.  Based on these two parameters, the method selects the next step.  The following image clearly demonstrates how the algorithm works: </p><br><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/MCTS_%28English%29.svg/808px-MCTS_%28English%29.svg.png" alt="image"></p><br><p>  <strong>Step 1: Select - Selection.</strong>  At this step, the algorithm chooses its opponent‚Äôs move.  If there is such a move, we will choose it, if not, we will add it. <br>  <strong>Step 2: Expansion - Expansion.</strong>  To the selected node with the opponent's move, we will add a node with its own move and with zero results. <br>  <strong>Step 3: Simulation - Simulation.</strong>  Play the game from the current state of the playing field to anyone's victory.  From here we take only the first move (i.e. your move) and the results. <br>  <strong>Step 4: Back Propagation - Back Propagation.</strong>  We will distribute the results from the simulation from the current to the root.  To all parent nodes we will add one to the number of games played, and if we run into the winner‚Äôs node, we‚Äôll add one to the number of games won in such a node. </p><br><p>  As a result, a bot with such an algorithm will make winning moves for it. </p><br><p>  Actually, the algorithm is not so complicated.  Rather, voluminous. </p><br><h2 id="realizaciya">  Implementation </h2><br><p>  I decided to implement the algorithm as a bot for the game Tic-tac-toe.  The game is simple and is an excellent example.  But the devil is in the details ... </p><br><p>  The problem is that we have to play the game on the simulation step without a real player.  It was possible, of course, to force the algorithm to do random moves in such simulations, but I wanted some meaningful behavior. </p><br><p>  Then the simplest bot was written that could only do two things - interfere with the player and make random moves.  To simulate this was more than enough. </p><br><p>  Like everyone else, the bot with the algorithm had information about the current state of the field, the state of the field from the last turn, its own move tree and the currently selected node in this tree.  To begin with, I will find a new opponent move. </p><br><pre><code class="hljs haskell">// <span class="hljs-number"><span class="hljs-number">0.</span></span> add node with new move. bool exist = false; int enemyx = <span class="hljs-number"><span class="hljs-number">-1</span></span>, enemyy = <span class="hljs-number"><span class="hljs-number">-1</span></span>; this-&gt;<span class="hljs-type"><span class="hljs-type">FindNewStep</span></span> ( __field, enemyx, enemyy ); for ( <span class="hljs-type"><span class="hljs-type">MCBTreeNode</span></span> * node : this-&gt;mCurrent-&gt;<span class="hljs-type"><span class="hljs-type">Nodes</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( node-&gt;<span class="hljs-type"><span class="hljs-type">MoveX</span></span> == enemyx &amp;&amp; node-&gt;<span class="hljs-type"><span class="hljs-type">MoveY</span></span> == enemyy ) { exist = true; this-&gt;mCurrent = node; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !exist ) { <span class="hljs-type"><span class="hljs-type">MCBTreeNode</span></span> * enemymove = new <span class="hljs-type"><span class="hljs-type">MCBTreeNode</span></span>; enemymove-&gt;<span class="hljs-type"><span class="hljs-type">Parent</span></span> = this-&gt;mCurrent; enemymove-&gt;<span class="hljs-type"><span class="hljs-type">MoveX</span></span> = enemyx; enemymove-&gt;<span class="hljs-type"><span class="hljs-type">MoveY</span></span> = enemyy; enemymove-&gt;<span class="hljs-type"><span class="hljs-type">Player</span></span> = (this-&gt;mFigure == <span class="hljs-type"><span class="hljs-type">TTT_CROSS</span></span>) ? <span class="hljs-type"><span class="hljs-type">TTT_CIRCLE</span></span> : <span class="hljs-type"><span class="hljs-type">TTT_CROSS</span></span>; this-&gt;mCurrent-&gt;<span class="hljs-type"><span class="hljs-type">Nodes</span></span>.push_back ( enemymove ); this-&gt;mCurrent = enemymove; }</code> </pre> <br><p>  As you can see, if there is such an opponent move in the tree, then we will select it.  If not, add. </p><br><pre> <code class="hljs haskell"> // <span class="hljs-number"><span class="hljs-number">1.</span></span> selection // select node with more wins. <span class="hljs-type"><span class="hljs-type">MCBTreeNode</span></span> * bestnode = this-&gt;mCurrent; for ( <span class="hljs-type"><span class="hljs-type">MCBTreeNode</span></span> * node : this-&gt;mCurrent-&gt;<span class="hljs-type"><span class="hljs-type">Nodes</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( node-&gt;<span class="hljs-type"><span class="hljs-type">Wins</span></span> &gt; bestnode-&gt;<span class="hljs-type"><span class="hljs-type">Wins</span></span> ) bestnode = node; }</code> </pre> <br><p>  Here we make a choice. </p><br><pre> <code class="hljs erlang-repl"> // <span class="hljs-number"><span class="hljs-number">2</span></span>. expanding // create new node. MCBTreeNode * newnode = new MCBTreeNode; newnode-&gt;Parent = bestnode; newnode-&gt;Player = this-&gt;mFigure; this-&gt;mCurrent-&gt;Nodes.push_back ( newnode );</code> </pre> <br><p>  Expand the tree. </p><br><pre> <code class="hljs pgsql"> // <span class="hljs-number"><span class="hljs-number">3.</span></span> simulation // simulate game. TTTGame::Field field; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-type"><span class="hljs-type">int</span></span> y = <span class="hljs-number"><span class="hljs-number">0</span></span>; y &lt; TTT_FIELDSIZE; y++ ) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ( <span class="hljs-type"><span class="hljs-type">int</span></span> x = <span class="hljs-number"><span class="hljs-number">0</span></span>; x &lt; TTT_FIELDSIZE; x++ ) field[y][x] = __field[y][x]; Player * bot1 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bot (); bot1-&gt;SetFigure ( (this-&gt;mFigure == TTT_CROSS) ? TTT_CIRCLE : TTT_CROSS ); Player * bot2 = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Bot (); bot2-&gt;SetFigure ( this-&gt;mFigure ); Player * <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> = bot2; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( TTTGame::IsPlayable ( field ) ) { <span class="hljs-keyword"><span class="hljs-keyword">current</span></span>-&gt;MakeMove ( field ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( newnode-&gt;MoveX == <span class="hljs-number"><span class="hljs-number">-1</span></span> &amp;&amp; newnode-&gt;MoveY == <span class="hljs-number"><span class="hljs-number">-1</span></span> ) this-&gt;FindNewStep ( field, newnode-&gt;MoveX, newnode-&gt;MoveY ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> == bot1 ) <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> = bot2; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">current</span></span> = bot1; }</code> </pre> <br><p>  Let's play the game between the bots.  I think here we need to explain a little: the field is copied to the current state and the bots play on this copy, the second bot goes first and we will remember its first move. </p><br><pre> <code class="hljs erlang-repl"> // <span class="hljs-number"><span class="hljs-number">4</span></span>. backpropagation. int winner = TTTGame::CheckWin ( field ); MCBTreeNode * currentnode = newnode; while ( currentnode != nullptr ) { currentnode-&gt;Attempts++; if ( currentnode-&gt;Player == winner ) currentnode-&gt;Wins++; currentnode = currentnode-&gt;Parent; }</code> </pre> <br><p>  And the last: we will receive result and we will extend it upwards on a tree. </p><br><pre> <code class="hljs erlang-repl"> // make move... this-&gt;mCurrent = newnode; TTTGame::MakeMove ( __field, this-&gt;mFigure, mCurrent-&gt;MoveX, mCurrent-&gt;MoveY );</code> </pre> <br><p>  And at the end we just make a move and set our new node from the second step as the current node. </p><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  As you can see, the algorithm is not so scary and complicated.  Of course, my implementation is far from ideal, but it shows the essence and some practical application. </p><br><p>  The full code is available on my <a href="https://github.com/NKozhevnikov/MonteCarloTreeSearch">GitHub</a> . </p><br><p>  All good. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/330092/">https://habr.com/ru/post/330092/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../330082/index.html">Rethinking JavaScript: break and functional approach</a></li>
<li><a href="../330084/index.html">How old are you? I'm 11</a></li>
<li><a href="../330086/index.html">Preview RamblerFront & # 1</a></li>
<li><a href="../330088/index.html">All Flash Isilon NAS: Scalable Storage for Unstructured Data</a></li>
<li><a href="../330090/index.html">How did the intro on 64k</a></li>
<li><a href="../330094/index.html">On the issue of numbers</a></li>
<li><a href="../330096/index.html">How to make money on the Yandex.Money API</a></li>
<li><a href="../330098/index.html">Text online from the festival RIT ++ 2017. Day One</a></li>
<li><a href="../330100/index.html">Text online from the festival RIT ++ 2017. Day two</a></li>
<li><a href="../330102/index.html">How to teach computational thinking?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>