<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Nginx-based online broadcast server</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Hello to all! A few months ago, an article ‚ÄúBroadcasting online video using nginx‚Äù was published on Habr√©, in which Aecktann spoke abou...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Nginx-based online broadcast server</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Hello to all!  A few months ago, an article <a href="http://habrahabr.ru/post/145867/">‚ÄúBroadcasting online video using nginx‚Äù</a> was published on Habr√©, in which <a href="http://habrahabr.ru/users/aecktann/" class="user_link">Aecktann</a> spoke about his experience of introducing the nginx module I‚Äôve been developing for broadcasting video - nginx-rtmp-module.  Since then, the product has been actively developed, and in this article I will talk about it in more detail. <br><br>  The broadcaster is needed to transfer the video stream to the client.  It is either a live stream, or broadcasting a recorded video (VOD, Video-on-demand).  There are a large number of video broadcasting technologies.  Among them are traditional protocols, such as RTMP or MPEG-TS, as well as the recently emerging technology of adaptive broadcasting over HTTP.  The latter include HLS (Apple), HDS (Adobe), Smooth Streaming (Microsoft), MPEG-DASH.  When choosing a technology, the main factor is its support on the client side.  That is why broadcasting in RTMP format is currently one of the most common.  HLS is supported by Apple devices, as well as some versions of Android. <br><a name="habracut"></a><br><h4>  Building and configuring nginx-rtmp </h4><br>  To add a nginx-rtmp module to nginx, you need to specify it in the --add-module option in the nginx configuration, like any other module. <br><br><pre><code class="bash hljs">./configure --add-module=/path/to/nginx-rtmp-module</code> </pre> <br>  After the build and installation, you need to add the rtmp {} section to the nginx.conf configuration file.  It should be added to the root of the config.  For example: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="nginx hljs"><span class="hljs-section"><span class="hljs-section">rtmp</span></span> { <span class="hljs-section"><span class="hljs-section">server</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">listen</span></span> <span class="hljs-number"><span class="hljs-number">1935</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">application</span></span> myapp { <span class="hljs-attribute"><span class="hljs-attribute">live</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; } } }</code> </pre><br>  For many cases, this simple configuration will suffice.  It sets the RTMP application with the name myapp.  In this application, we will later publish streams and play them from it.  Each thread will also have its own unique name.  It is worth noting one important nuance regarding the above configuration.  It is true for the case when the number of nginx workers is equal to one (as a rule, is specified at the beginning of nginx.conf). <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">worker_processes</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  To be able to use live broadcasts with a large number of workers, you need to specify the rtmp_auto_push on directive (see the section <a href="https://habr.com/ru/post/162237/">‚ÄúWorkers and local retransmission‚Äù</a> ). <br><br><h4>  Publish and play live stream </h4><br>  You can use Flash players (JWPlayer, FlowPlayer, Strobe, etc.) to publish and play videos.  However, ffmpeg (and ffplay) are often used to broadcast server streams and for testing.  Let's start broadcasting the test file test.mp4 with the following command: <br><br><pre> <code class="bash hljs">ffmpeg -re -i /var/videos/test.mp4 -c copy -f flv rtmp://localhost/myapp/mystream</code> </pre><br>  Here we must take into account that RTMP supports a limited set of codecs, however, such popular codecs like H264 and AAC are among their number.  If the codecs in the test file are not compatible with RTMP, recoding will be required: <br><br><pre> <code class="bash hljs">ffmpeg -re -i /var/videos/test.mp4 -c:v libx264 -c:a libfaac -ar 44100 -ac 2 -f flv rtmp://localhost/myapp/mystream</code> </pre><br>  You can broadcast as a stream from a file, and from another source.  For example, if we assume that some live MPEG-TS stream is <a href="">being</a> broadcast at <a href="">video.example.com/livechannel.ts</a> , it can also be wrapped in rtmp: <br><br><pre> <code class="bash hljs">ffmpeg -i http://video.example.com/livechannel.ts -c copy -f flv rtmp://localhost/myapp/mystream</code> </pre><br>  Example broadcast from a local webcam: <br><br><pre> <code class="bash hljs">ffmpeg -f video4linux2 -i /dev/video0 -c:v libx264 -an -f flv rtmp://localhost/myapp/mystream</code> </pre><br>  You can play a stream using ffplay with the following command: <br><br><pre> <code class="bash hljs">ffplay rtmp://localhost/myapp/mystream</code> </pre><br>  And finally, a simple example of using JWPlayer to play a stream from a browser (fully listed in the / test / www directory of the module): <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/jwplayer/jwplayer.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"container"</span></span></span><span class="hljs-tag">&gt;</span></span>Loading the player ...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text/javascript"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="actionscript"><span class="actionscript"> jwplayer(</span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"container"</span></span></span><span class="actionscript">).setup({ modes: [ { type: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"flash"</span></span></span><span class="actionscript">, src: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"/jwplayer/player.swf"</span></span></span><span class="actionscript">, config: { bufferlength: </span><span class="hljs-number"><span class="actionscript"><span class="hljs-number">1</span></span></span><span class="actionscript">, file: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"mystream"</span></span></span><span class="actionscript">, streamer: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"rtmp://localhost/myapp"</span></span></span><span class="actionscript">, provider: </span><span class="hljs-string"><span class="actionscript"><span class="hljs-string">"rtmp"</span></span></span><span class="actionscript">, } } ] }); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><h4>  Video on demand </h4><br>  The module supports broadcasting video files in mp4 and flv formats.  Setup Example: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">application</span></span> vod { <span class="hljs-attribute"><span class="hljs-attribute">play</span></span> /var/videos; }</code> </pre><br>  When playing, respectively, you must specify the names of the files, otherwise everything is the same as the live broadcast. <br><br><pre> <code class="bash hljs">ffplay rtmp://localhost/vod/movie1.mp4 ffplay rtmp://localhost/vod/movie2.flv</code> </pre><br><br><h4>  Retransmission </h4><br>  When building distributed systems, it is important to have the ability to relay flows for load balancing. <br>  by a large number of servers.  The module implements two types of relaying: push and pull.  The first type of relay <br>  consists in transmitting to the remote server a locally published stream, and the second is to transmit the remote <br>  flow to a local server.  Example push relay: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">application</span></span> myapp { <span class="hljs-attribute"><span class="hljs-attribute">live</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">push</span></span> rtmp://cdn.example.com; }</code> </pre><br>  At the moment when the publication starts at rtmp: // localhost / myapp / mystream, a connection is created with the remote server and the stream mystream is published further on rtmp: //cdn.example.com/myapp/mystream.  When local publishing is terminated, the connection with cdn.example.com is automatically terminated. <br><br>  Pull relays perform the opposite operation: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">application</span></span> myapp { <span class="hljs-attribute"><span class="hljs-attribute">live</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">pull</span></span> rtmp://cdn.example.com; }</code> </pre><br>  In this example, when a client appears to want to play the rtmp: // localhost / myapp / mystream stream locally, a connection will be made to rtmp: //cdn.example.com/myapp/mytstream and the remote stream will be relayed to the local server, after which it will available to all local clients.  At that moment, when there is no client left, the connection will be terminated. <br><br><h4>  Mobile Broadcasting (HLS) </h4><br>  For broadcasting on the iPhone / iPad device, as well as on new Android versions, the HLS protocol (HTTP Live Streaming) is used. <br>  The protocol was developed by Apple and is a ‚Äúsliced‚Äù stream of MPEG-TS / H264 / AAC stream sent over HTTP.  A playlist in m3u8 format is attached to the stream.  Give HTTP nginx can do fine.  So, you just need to create and update the playlist and fragments of the HLS-stream, as well as monitor the removal of old fragments.  For this there is a module nginx-rtmp-hls.  It is located in the hls directory, but is not built by default.  requires the libavformat library, included in the ffmpeg package.  To build nginx with HLS support, you need to add this module explicitly during configuration: <br><br><pre> <code class="bash hljs">./configure --add-module=/path/to/nginx-rtmp-module --add-module=/path/to/nginx-rtmp-module/hls</code> </pre><br>  So it turned out that some time ago the ffmpeg project was forknut.  And now we have two projects - ffmpeg and avconv, and therefore, compatibility problems (or rather, incompatibilities) of libraries immediately began to arise.  To build nginx-rtmp you need the original ffmpeg.  At the same time, some Linux distributions have switched to using avconv, which is not suitable for building.  In this case, I wrote a detailed <a href="https://github.com/arut/nginx-rtmp-module/wiki/Building-nginx-rtmp-with-HLS-support">instruction</a> . <br><br>  To generate HLS, it is enough to specify the following directives: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">application</span></span> myapp { <span class="hljs-attribute"><span class="hljs-attribute">live</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">hls</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">hls_path</span></span> /tmp/hls; <span class="hljs-attribute"><span class="hljs-attribute">hls_fragment</span></span> <span class="hljs-number"><span class="hljs-number">5s</span></span>; }</code> </pre><br>  And finally, in the http {} section, configure the return on everything related to HLS: <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /hls { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /tmp; }</code> </pre><br>  Now we publish the stream mystream to the application myapp, and in the iPhone browser we type in the address bar <a href="">example.com/hls/mystream.m3u8</a> .  In addition, the stream can be embedded in the html video tag: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">video</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"600"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"300"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">controls</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">autoplay</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://example.com/hls/mystream.m3u8"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">video</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  I note that to play on the iPhone stream must be encoded in H264 and AAC.  If the source stream does not meet these conditions, you need to configure transcoding. <br><br><h4>  Recoding </h4><br>  When broadcasting video, it is often necessary to transcode the incoming stream to another quality, or other codecs.  This task is fundamentally different from the distribution of RTMP and, unlike the latter, is associated with high CPU loads, large and active memory consumption, often relies on the use of multithreading and is potentially unstable.  For this reason, it should not be included in the main server process, and ideally should be carried out as a separate process.  It should be noted that a great tool for solving this problem already exists - this is all the same ffmpeg.  It supports a huge number of codecs, formats and filters, allows the use of many third-party libraries.  However, it is quite simple and actively supported by the community.  The nginx-rtmp module provides a simple interface for using ffmpeg.  The exec directive allows you to run an external application at the time of publication of the incoming stream.  When the publication is completed, the application is also forcibly terminated.  In addition, restarting the running application is supported if it suddenly terminated itself. <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">application</span></span> myapp { <span class="hljs-attribute"><span class="hljs-attribute">live</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">exec</span></span> ffmpeg -i rtmp://localhost/myapp/<span class="hljs-variable"><span class="hljs-variable">$name</span></span> -c:v flv -c:a -s 32x32 -f flv rtmp://localhost/myapp32x32/<span class="hljs-variable"><span class="hljs-variable">$name</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">application</span></span> myapp32x32 { <span class="hljs-attribute"><span class="hljs-attribute">live</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>; }</code> </pre><br>  In this example, ffmpeg is used to transcode the incoming video into Sorenson-H263, resize it to 32x32 and publish the result to the application myapp32x32.  You can simultaneously specify several exec directives that will perform any transformations with the stream and publish the result to other applications on both the local and remote servers.  The directive supports several variables, including $ app (application name) and $ name (stream name). <br><br><h4><a name="workers"></a>  Workers and local relay </h4><br>  As you know, nginx is a single-threaded server.  In order to effectively use all the cores of modern processors, it usually runs into several workers.  The processing of HTTP requests usually occurs independently of each other, and only in some cases (as, for example, in the case of a cache), access to common data is required.  Such data is stored in shared memory. <br><br>  With live broadcasting, the situation is different.  All client connections losing the stream obviously depend on the connection publishing this stream.  The use of shared memory in this case is inefficient, too time-consuming, would lead to synchronization and a large loss of performance.  Therefore, for the use of several workers, an internal relay mechanism was implemented via UNIX sockets.  Actually, such retransmissions are practically the same as ordinary external push retransmissions.  Local retransmissions are enabled by the following directive. <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">rtmp_auto_push</span></span> <span class="hljs-literal"><span class="hljs-literal">on</span></span>;</code> </pre><br>  It must be specified in the root section of the configuration file.  I note that local retransmissions are needed only for live broadcasts. <br><br><h4>  Record </h4><br>  Often there is a need to write to the disk published streams.  The module allows you to record both individual data from the stream (audio, video, key frames) and the stream entirely.  You can set a limit on the file size, as well as the number of recorded frames.  The following example includes recording the first 128K of each stream. <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">record</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">record_path</span></span> /tmp/rec; <span class="hljs-attribute"><span class="hljs-attribute">record_max_size</span></span> <span class="hljs-number"><span class="hljs-number">128K</span></span>;</code> </pre><br>  The recording takes place in flv format in the / tmp / rec directory. <br><br>  You can control the recording manually, by turning it on and off using an http request.  To do this, use the control module.  Information about it can be found on the project website. <br><br><h4>  Authorization and business logic </h4><br>  In many cases, it is required to introduce restrictions or accounting for the operations of publishing and playing videos.  This is due to the logic of the project in which it is used.  The most common case is the need to authorize a user before giving him access to watch a video.  In order to integrate the business logic of the project into the broadcaster, the module implements HTTP callbacks, such as on_publish and on_play.  The server code receives all the available customer information, including its address, stream name, page address, etc.  If HTTP status 2xx is returned, the callback is considered completed successfully and the client continues.  Otherwise, the connection is broken. <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">on_publish</span></span> http://example.com/check_publisher; <span class="hljs-attribute"><span class="hljs-attribute">on_play</span></span> http://example.com/check_player;</code> </pre><br><br><h4>  Statistics </h4><br>  At any given time, thousands of clients can be connected to your server.  Naturally, we need an interface to see their list, as well as all the main characteristics of the streams published or played by them.  Moreover, it is important that this information can be both analyzed visually and processed programmatically.  Such an interface for the nginx-rtmp module exists.  To use it, you need to set the following directives in the http-section of nginx.conf. <br><br><pre> <code class="nginx hljs"><span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /stat { <span class="hljs-attribute"><span class="hljs-attribute">rtmp_stat</span></span> all; <span class="hljs-attribute"><span class="hljs-attribute">rtmp_stat_stylesheet</span></span> stat.xsl; } <span class="hljs-attribute"><span class="hljs-attribute">location</span></span> /stat.xsl { <span class="hljs-attribute"><span class="hljs-attribute">root</span></span> /path/to/stat.xsl/dir/; }</code> </pre><br>  The rtmp_stat directive includes the return of an XML document with a complete description of live clients publishing or losing streams, a list of applications and servers.  This document is useful for software processing, but it is completely unsuitable for visual analysis.  To be able to view the list of clients in the browser, the rtmp_stat_stylesheet directive sets the relative path to the XML style sheet (stat.xsl).  This file is in the project root.  You need to configure nginx to distribute it at the specified url.  The result can be viewed in the browser. <br><br>  It is possible to explicitly break client connections.  To do this, use the control module, not described in the article. <br><br><h4>  Simple Internet Radio </h4><br>  From the very beginning of the article, I constantly used the word "video".  Of course, the module can broadcast not only video, but also audio streams.  Here is a simple example of an Internet radio station on bash that broadcasts mp3 files from / var / music.  This stream can play simple JWPlayer embedded in a web page. <br><br><pre> <code class="bash hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ffmpeg -re -i <span class="hljs-string"><span class="hljs-string">"`find /var/music -type f -name '*.mp3'|sort -R|head -n 1`"</span></span> -vn -c:a libfaac -ar 44100 -ac 2 -f flv rtmp://localhost/myapp/mystream; <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br><br><h4>  Compatibility </h4><br>  The module is compatible with all basic software that works with the RTMP protocol, including FMS / FMLE, Wowza, Wirecast, tested with the most common flash players JWPlayer, FlowPlayer, StrobeMediaPlayback, and also works fine with ffmpeg / avconv and rtmpdump. <br><br><h4>  Loads </h4><br>  The module uses an asynchronous single-threaded nginx server model.  This allows for high performance.  We use the module on Intel Xeon E5320 / E5645 machines in single worker mode.  In this mode, it is possible to achieve the maximum throughput of the existing network cards - 2Gbps.  The users of the module confirm the preservation of the same ratio (2Gbps per core) in local relay mode with several workers.  Practice shows that the broadcaster's performance usually rests on the network, and not on the CPU. <br><br>  I didn‚Äôt conduct direct comparisons with other products, however, the ‚Äúheavy‚Äù multi-threaded FMS, Wowza and Red5, being more functional, should, due to the implementation features, significantly lose to my decision on the number of simultaneously connected clients and CPU load.  This is confirmed by many users who have made such comparisons, including  in the <a href="http://habrahabr.ru/post/145867/">article</a> I already mentioned. <br><br><h4>  Conclusion </h4><br>  In conclusion, the module is distributed under the BSD license.  It builds and runs under Linux, FreeBSD and MacOS.  The article describes only a small part of the nginx-rtmp-module functionality.  Those interested can familiarize themselves with the project at the links below. <br><br><ul><li>  Project page on github <a href="http://github.com/arut/nginx-rtmp-module">github.com/arut/nginx-rtmp-module</a> . </li><li>  Full description of directives with examples <a href="http://github.com/arut/nginx-rtmp-module/wiki/Directives">github.com/arut/nginx-rtmp-module/wiki/Directives</a> . </li><li>  A blog where I write about new versions, bugfixes and new features <a href="http://rarut.wordpress.com/">rarut.wordpress.com</a> . </li><li>  Google groups, where I answer questions and discuss emerging problems with <a href="https://groups.google.com/group/nginx-rtmp">group</a> users <a href="https://groups.google.com/group/nginx-rtmp">groups.google.com/group/nginx-rtmp</a> and <a href="https://groups.google.com/group/nginx-rtmp-ru">groups.google.com/group/nginx-rtmp-ru</a> . </li></ul><br>  I would be glad if the project seems interesting to Habr's readers. <br><br>  Thanks to all! </div><p>Source: <a href="https://habr.com/ru/post/162237/">https://habr.com/ru/post/162237/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../162223/index.html">NetWrix Password Manager Self-Password Manager Review</a></li>
<li><a href="../162227/index.html">Copyright history. Part 5: Moral Rights</a></li>
<li><a href="../162229/index.html">MIPS system calls</a></li>
<li><a href="../162233/index.html">Video digest of the latest gaming industry news | Geek Week # 4</a></li>
<li><a href="../162235/index.html">Observer Pattern with strong typing or why do we need Objective-C ++</a></li>
<li><a href="../162245/index.html">New Yandex Search Platform with Personal Results: ‚ÄúKaliningrad‚Äù</a></li>
<li><a href="../162251/index.html">How to make a product from a mobile application</a></li>
<li><a href="../162253/index.html">Team goals. Moving towards a goal is easier</a></li>
<li><a href="../162255/index.html">Songo: Desktop-ny player Vkontakte</a></li>
<li><a href="../162259/index.html">Corona Malware Chips</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>