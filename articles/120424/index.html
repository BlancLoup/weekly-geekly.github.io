<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a programming language using LLVM. Part 3: LLVM IR Code Generation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welcome to Chapter 3 of the tutorial "Creating a programming language with LLVM." In this chapter, we will look at how to convert AST (Abstract Syntax...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a programming language using LLVM. Part 3: LLVM IR Code Generation</h1><div class="post__text post__text-html js-mediator-article">  Welcome to Chapter 3 of the tutorial "Creating a programming language with LLVM."  In this chapter, we will look at how to convert AST (Abstract Syntax Tree), built in <b><a href="http://habrahabr.ru/blogs/compilers/120005/">Chapter 2</a></b> , to LLVM IR.  She will tell you about some aspects of LLVM, as well as demonstrate how easy it is to use.  You will see that much more work was required on lexical and syntactic analysis than on the direct creation of the LLVM IR code. <br><br>  <b>Please note</b> : the code in this chapter requires LLVM 2.2 or later.  With versions for LLVM 2.1 inclusive, this code will not work.  Also worth noting is that you should use the version of this tutorial that corresponds to your LLVM release: you can use the documentation that comes with the official releases or visit the <a href="http://llvm.org/releases/">releases page at llvm.org</a> . <br><a name="habracut"></a><br><h1>  Configuring for code generation </h1><br>  To generate LLVM IR, we need some simple setup.  First, we define virtual code generation methods ( <code>Codegen</code> ) for each AST class: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// ExprAST -      . class ExprAST { public: virtual ~ExprAST() {}</span></span></code> </pre> <pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Codegen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <pre> <code class="cpp hljs">}; <span class="hljs-comment"><span class="hljs-comment">/// NumberExprAST -       "1.0". class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double val) : Val(val) {}</span></span></code> </pre> <pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Codegen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <pre> <code class="cpp hljs">}; ...</code> </pre></blockquote><br>  The <code>Codegen()</code> method will return the IR for this AST node along with all its dependencies, and they all return an <code>LLVM Value</code> object.  <code>"Value"</code> is the class used to represent the " <a href="http://ru.wikipedia.org/wiki/SSA">Static Single Assigment Register</a> ( <a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">SSA</a> )" or "SSA Values" in LLVM.  The most important point in SSA is that their value is calculated as the execution of the associated instruction and they cannot get a new value until (and if) the instruction is executed again.  In other words, there is no way to ‚Äúchange‚Äù the value of SSA.  For more information, <a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">read</a> about <a href="http://ru.wikipedia.org/wiki/SSA">Static Single Assignment</a> - these concepts really seem quite natural as soon as you pay attention to them. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Note that instead of adding virtual methods to the <code>ExprAST</code> class hierarchy, it may make sense to use the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2581%25D0%25B5%25D1%2582%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">Visitor design pattern</a> or some other method.  Again, in this tutorial, we will not dwell on good software development methods: our goal is simplicity ‚Äî and it's easier for us to add a virtual method. <br><br>  We also need a method for handling errors, similar to the one used for the parser.  We will use this method for error messages found during code generation (for example, using undeclared parameters): <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Value *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErrorV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *Str)</span></span></span><span class="hljs-function"> </span></span>{ Error(Str); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Module *TheModule; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IRBuilder&lt;&gt; Builder(getGlobalContext()); <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, Value*&gt; NamedValues;</code> </pre></blockquote><br>  These static variables will be used during code generation.  <code>TheModule</code> is an LLVM construct containing all functions and global variables in a piece of code.  In most cases, these are top-level structures that the LLVM IR uses for the contained code. <br><br>  The <code>Builder</code> object is an auxiliary object that makes it easy to generate LLVM instructions.  Class template instances <code><a href="http://llvm.org/doxygen/IRBuilder_8h-source.html"></a> IRBuilder</code>  <code><a href="http://llvm.org/doxygen/IRBuilder_8h-source.html"></a> IRBuilder</code> keeps track of the current place to insert instructions and contains methods for creating new instructions. <br><br>  The <code>NamedValues</code> map <code>NamedValues</code> track of which values ‚Äã‚Äãare defined in the current scope and what their LLVM representation is.  (In other words, this is the symbol table for the code).  In the current form in Kaleidoscope, the only thing that can be referenced is the parameters of the functions.  Thus, in this map, when generating the code for the function body, the parameters of this function will be located. <br><br>  Knowing all this, we can talk about code generation for any expressions.  Note, it is assumed that <code>Builder</code> has already been created to generate code in ‚Äúsomething‚Äù.  For now, we assume that this has already been done, and we will use it to save the code. <br><br><h1>  Expression code generation </h1><br>  Generating LLVM code for expression nodes is very simple: less than 45 lines of commented code for all our four types of expression nodes.  First, let's take numeric literals: <br><br><blockquote><pre> <code class="cpp hljs">Value *NumberExprAST::Codegen() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ConstantFP::get(getGlobalContext(), APFloat(Val)); }</code> </pre></blockquote><br>  In LLVM IR, numeric constants are represented by the class <code>ConstantFP</code> , which contains inside a numeric value in the form of <code>APFloat</code> ( <code>APFloat</code> has the ability to reduce real constants to arbitrary precision numbers).  This code creates and returns <code>ConstantFP</code> .  Note that in LLVM IR all constants are unique (uniqued) and shared (shared).  It is for this reason that the API uses the idiom <code>"foo::get(...)"</code> rather than <code>"new foo(..)"</code> or <code>"foo::Create(..)"</code> . <br><br><blockquote><pre> <code class="cpp hljs">Value *VariableExprAST::Codegen() { <span class="hljs-comment"><span class="hljs-comment">//      . Value *V = NamedValues[Name]; return V ? V : ErrorV("Unknown variable name"); }</span></span></code> </pre></blockquote><br>  References to variables are also quite simple when using LLVM.  In the simple version of Kaleidoscope, we assume that the variable is already set somewhere and its value is available.  In practice, the values ‚Äã‚Äãon the NamedValues ‚Äã‚Äãmap can only be function arguments.  This code simply checks that the specified name is defined on the map (if not, it is a link to an unknown variable) and returns a value for it.  In subsequent chapters, we will add support for local variables and loop counter variables. <br><br><blockquote><pre> <code class="cpp hljs">Value *BinaryExprAST::Codegen() { Value *L = LHS-&gt;Codegen(); Value *R = RHS-&gt;Codegen(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (L == <span class="hljs-number"><span class="hljs-number">0</span></span> || R == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (Op) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'+'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Builder.CreateFAdd(L, R, <span class="hljs-string"><span class="hljs-string">"addtmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'-'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Builder.CreateFSub(L, R, <span class="hljs-string"><span class="hljs-string">"subtmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'*'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Builder.CreateFMul(L, R, <span class="hljs-string"><span class="hljs-string">"multmp"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>: L = Builder.CreateFCmpULT(L, R, <span class="hljs-string"><span class="hljs-string">"cmptmp"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   0  1   0.0  1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(getGlobalContext()), "booltmp"); default: return ErrorV("invalid binary operator"); } }</span></span></code> </pre></blockquote><br>  With binary operators all the fun begins.  The basic idea here is that we recursively generate code for the left side of the expression, then for the right side, calculating the result of the binary expression.  In this code, we made a simple switch with respect to a binary operator to create an LLVM instruction. <br><br>  In the example above, the LLVM <code>Builder</code> class finally displays its value.  <code>IRBuilder</code> knows where to insert the newly created instructions, and all you need to do is specify which instructions to create (for example, <code>"CreateFAdd"</code> ), which operands to use (in this case L and R) and, if necessary, which one to use name for the generated instruction. <br><br>  Another great feature in LLVM is the assignment of names.  For example, if the above uses the variable <code>"addtmp"</code> several times, LLVM will automatically assign a unique numeric suffix each time.  Local value names for instructions are optional, but they make IR dumps much easier to read. <br><br>  <a href="http://llvm.org/docs/LangRef.html">LLVM instructions are</a> limited by strict rules: for example, the left and right operands of <a href="http://llvm.org/docs/LangRef.html">the addition instruction</a> must be of the same type and the type of the result of the addition will correspond to the type of the operands.  Since all values ‚Äã‚Äãin Kaleidoscope are real numbers, we get very simple code for addition, subtraction and multiplication. <br><br>  On the other hand, the LLVM specification says that <a href="http://llvm.org/docs/LangRef.html">the <code>fcmp</code> instruction</a> always returns the value "i1" (one-bit integer).  The problem is that we need a value of 0.0 or 1.0 in Kaleidoscope.  To do this, we combine the <code>fcmp</code> <a href="http://llvm.org/docs/LangRef.html">instruction</a> with <a href="http://llvm.org/docs/LangRef.html">the <code>uitofp</code> instruction</a> .  This instruction converts an unsigned integer to floating point.  In contrast, if we used <a href="http://llvm.org/docs/LangRef.html">the <code>sitofp</code></a> , the operator '&lt;' would return 0.0 and -1.0, depending on the input value. <br><br><blockquote><pre> <code class="cpp hljs">Value *CallExprAST::Codegen() { <span class="hljs-comment"><span class="hljs-comment">//      . Function *CalleeF = TheModule-&gt;getFunction(Callee); if (CalleeF == 0) return ErrorV("Unknown function referenced"); //    . if (CalleeF-&gt;arg_size() != Args.size()) return ErrorV("Incorrect # arguments passed"); std::vector&lt;Value*&gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-&gt;Codegen()); if (ArgsV.back() == 0) return 0; } return Builder.CreateCall(CalleeF, ArgsV.begin(), ArgsV.end(), "calltmp"); }</span></span></code> </pre></blockquote><br>  Generating an LLVM code to call a function is quite simple.  The above code first searches for the function name in the symbol table of the LLVM module.  Recall that the LLVM module is a container that contains all the functions that we can use for JIT compilation.  By giving each function a name, we can use the LLVM symbol table to allow the search for function names. <br><br>  After receiving the function to call, we recursively generate the code for each argument that must be passed and create the LLVM call instruction.  Note that by default LLVM uses function calling conventions as in C, which allows you to use these calls for standard library functions such as <code>"sin"</code> and <code>"cos"</code> without any extra effort. <br><br>  This completes the processing of the four main types of expression nodes of the Kaleidoscope language.  You can go ahead and add a few more types.  For example, when viewing the LLVM language, you will find several other interesting instructions that are really easy to connect to our existing development. <br><br><h1>  Function Code Generation </h1><br>  Code generation for prototypes and functions should handle a number of details that make their code less beautiful than generating code for expressions, but allows you to illustrate some important points.  First of all, let's talk about code generation for prototypes: it is used both for the body of functions and for the declaration of external (external) functions.  The code starts with: <br><br><blockquote><pre> <code class="cpp hljs">Function *PrototypeAST::Codegen() { <span class="hljs-comment"><span class="hljs-comment">//   : double(double,double)  ... std::vector&lt;const Type*&gt; Doubles(Args.size(), Type::getDoubleTy(getGlobalContext())); FunctionType *FT = FunctionType::get(Type::getDoubleTy(getGlobalContext()), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule);</span></span></code> </pre></blockquote><br>  This multi-line code actually shows true power.  First, note that this function returns <code>"Function*"</code> instead of <code>"Value*"</code> .  Since the ‚Äúprototype‚Äù actually speaks of the external interface for a function (and not a calculated expression), it makes sense for it to return the LLVM function corresponding to the code generated for the function. <br><br>  Calling <code>"FunctionType::get"</code> creates FunctionType, which should be used for this prototype.  Since all the function arguments in Kaleidoscope are real numbers, the first line creates an LLVM vector of ‚ÄúN‚Äù real numbers.  The <code>FunctionType::get</code> method is then used to create a functional type that takes "N" valid arguments and returns one valid argument as the result.  Note that the types in LLVM are unique, like constants, so you need not <code>"new"</code> , but <code>"get"</code> (in the original wordplay: "... so that you do not <code>"</code> create <code>"</code> it, but <code>"</code> get <code>"</code> .") . <br><br>  The last line actually creates a function corresponding to the prototype.  It indicates the type, link and name to use, and the module to insert.  ‚Äú <a href="http://llvm.org/docs/LangRef.html">External linkage</a> ‚Äù means that the function can be defined outside the current module and / or that it can be called outside the module.  <code>"Name"</code> defines the name specified by the user, <code>"TheModule"</code> indicates that the name is registered in the symbol table <code>"TheModule"</code> . <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (F)     ,     'Name'. //     ,      . if (F-&gt;getName() != Name) { //   ,      . F-&gt;eraseFromParent(); F = TheModule-&gt;getFunction(Name);</span></span></code> </pre></blockquote><br>  When it comes to name conflicts, the Module's symbol table works the same way as the symbol table. Functions: if a new function is created with a name that has already been added to the symbol table, then when added to a module, it will be implicitly renamed.  The above code uses this fact to determine if the same function was previously declared. <br><br>  In Kaleidoscope, redefinition of functions can be in two cases.  First, if we want to use <code>extern</code> -definition of functions more than once, as long as their prototypes are the same (since all arguments are of the same type, we just need to check the coincidence of the number of arguments).  Secondly, if we want to use <code>extern</code> - the definition of functions, and then the definition of the body for them.  This is necessary when defining mutually recursive functions. <br><br>  To implement this, the above code first checks if there is a conflict of function names.  If it does, it deletes the newly created function (by calling <code>"eraseFromParent"</code> ), and then calls <code>"getFunction"</code> to get an existing function with the given name.  It is worth noting that many APIs in LLVM have both the <code>"erase"</code> form and the <code>"remove"</code> form.  The <code>"remove"</code> method detaches (unlink) an object from its parent object (for example, a Function from a Module) and returns it.  The <code>"erase"</code> method detaches (unlink) an object and then deletes it. <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   (F)   , . if (!F-&gt;empty()) { ErrorF("redefinition of function"); return 0; } //   (F)    , . if (F-&gt;arg_size() != Args.size()) { ErrorF("redefinition of function with different # args"); return 0; } }</span></span></code> </pre></blockquote><br>  In order to confirm the above reasoning, we first check that the ‚Äúalready existing‚Äù function is ‚Äúempty‚Äù.  In this case, emptiness means that it does not contain basic blocks, that is, the body of the function.  If the function has a body, then this is a repeated declaration, so in this case we reject the code.  If the previous function is an <code>"extern"</code> function, we simply compare its number of arguments with the number of arguments of the current definition.  If they do not match, then we display an error. <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//     . unsigned Idx = 0; for (Function::arg_iterator AI = F-&gt;arg_begin(); Idx != Args.size(); ++AI, ++Idx) { AI-&gt;setName(Args[Idx]); //      . NamedValues[Args[Idx]] = AI; } return F; }</span></span></code> </pre></blockquote><br>  The last part of the code for processing prototype functions is a loop to the arguments in the function, specifying the names of LLVM objects, the corresponding arguments, and registering the arguments in the <code>NamedValues</code> map for later use by the AST node <code>VariableExprAST</code> .  It then returns the function object.  Note that we do not check conflicting argument names (for example, <code>"extern Foo (aba)"</code> ).  But this can be done quite simply and straightforwardly using the method we used above. <br><br><blockquote><pre> <code class="cpp hljs">Function *FunctionAST::Codegen() { NamedValues.clear(); Function *TheFunction = Proto-&gt;Codegen(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (TheFunction == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre></blockquote><br>  Generating code for defining functions begins quite simply: we simply call prototype code generation ( <code>Proto</code> ) and make sure that everything is normal.  We also clear the NamedValues ‚Äã‚Äãmap to make sure that nothing remains of the last function we process.  Generating a prototype code ensures that we have a ready-made functional object LLVM, so that we can move on. <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//      . BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "entry", TheFunction); Builder.SetInsertPoint(BB); if (Value *RetVal = Body-&gt;Codegen()) {</span></span></code> </pre></blockquote><br>  Now we are going to work with Builder.  The first line creates a new <a href="http://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B0%25D0%25B7%25D0%25BE%25D0%25B2%25D1%258B%25D0%25B9_%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BA">base unit</a> [ <a href="http://en.wikipedia.org/wiki/Basic_block">en</a> ] (named <code>"entry"</code> ), which is inserted into TheFunction.  The second line tells Builder that new instructions should be inserted at the end of the new base unit.  The basic blocks in LLVM are an important part of the function that defines <a href="http://ru.wikipedia.org/wiki/%25D0%2593%25D1%2580%25D0%25B0%25D1%2584_%25D0%25BF%25D0%25BE%25D1%2582%25D0%25BE%25D0%25BA%25D0%25B0_%25D1%2583%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F">the control flow graph</a> [ <a href="http://en.wikipedia.org/wiki/Control_flow_graph">en</a> ].  Since we don't have any control flow yet, our functions will contain only one block.  But we will fix this in chapter 5 :). <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Value *RetVal = Body-&gt;Codegen()) { <span class="hljs-comment"><span class="hljs-comment">//  . Builder.CreateRet(RetVal); //   ,    (). verifyFunction(*TheFunction); return TheFunction; }</span></span></code> </pre></blockquote><br>  Once the insertion point is set, we call code generation using <code>CodeGen()</code> for the root function expression.  If there is no error, then add the code for evaluating the expression to the input block and return the value to be calculated.  Then, in the absence of errors, we create an <a href="http://llvm.org/docs/LangRef.html">LLVM-instruction <code>"ret"</code></a> , which terminates the function.  After building the function, we call the <code>"verifyFunction"</code> procedure built into LLVM.  It performs various checks on the consistency of the generated code to determine that our compiler is doing everything correctly.  Using this procedure is very important: it can catch a lot of bugs.  When the function is completed and tested, we return it. <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  ,   . TheFunction-&gt;eraseFromParent(); return 0; }</span></span></code> </pre></blockquote><br>  This small part is for error handling.  For simplicity, we can handle this simple deletion of the created function using the <code>eraseFromParent</code> method.  This will allow the user to override a function that was incorrectly dialed earlier: if we did not delete it, it would be in the symbol table with the body, prohibiting future overrides. <br><br>  Actually, this code has a bug.  <code>"PrototypeAST:: Codegen"</code> can return previously defined declarations, our code can actually delete them.  There are several ways to fix this bug, think what you can think of!  Here is a small test case: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ab)</span></span></span></span>; <span class="hljs-meta"><span class="hljs-meta"># o,  </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo"</span></span></span><span class="hljs-meta">. def foo(ab) c; # ,   </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">'c'</span></span></span><span class="hljs-meta">. def bar() foo(1, 2); # ,   </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"foo"</span></span></span></span></code> </pre></blockquote><br><br><h1>  Changes in the main program and final thoughts </h1><br>  In fact, so far the code generation in LLVM has given us a little bit, except that we can look at interesting IR calls.  Our code will call code generation with <code>Codegen</code> in the functions ‚ÄúHandleDefinition‚Äù, ‚ÄúHandleExtern‚Äù, etc., and then dump the LLVM IR.  Because of this, we can look at LLVM IR for simple functions.  For example: <br><br><blockquote><pre>  ready&gt; <b>4 + 5;</b>
 Read top-level expression:
 define double @ "" () {
 entry:
         ret double 9.000000e + 00
 }
</pre></blockquote><br>  Notice how the parser returns the top-level expression as an anonymous function.  This will be useful when we add JIT support in the next chapter.  Also note that the code is translated ‚Äúvery literally,‚Äù ‚Äústraightforward,‚Äù there are no optimizations except for simply folding the constants made by <code>IRBuilder</code> .  We will add optimization explicitly in the next chapter. <br><br><blockquote><pre>  ready&gt; <b>def foo (ab) a * a + 2 * a * b + b * b;</b>
 Read function definition:
 define double @foo (double% a, double% b) {
 entry:
         % multmp = fmul double% a,% a
         % multmp1 = fmul double 2.000000e + 00,% a
         % multmp2 = fmul double% multmp1,% b
         % addtmp = fadd double% multmp,% multmp2
         % multmp3 = fmul double% b,% b
         % addtmp4 = fadd double% addtmp,% multmp3
         ret double% addtmp4
 }
</pre></blockquote><br>  Here are some simple arithmetic operations.  Notice the striking resemblance to the <code>Builder'</code> LLVM calls that we use to create instructions. <br><br><blockquote><pre>  ready&gt; <b>def bar (a) foo (a, 4.0) + bar (31337);</b>
 Read function definition:
 define double @bar (double% a) {
 entry:
         % calltmp = call double @foo (double% a, double 4.000000e + 00)
         % calltmp1 = call double @bar (double 3.133700e + 04)
         % addtmp = fadd double% calltmp,% calltmp1
         ret double% addtmp
 }
</pre></blockquote><br>  Here are a few function calls.  Note that this function will take a long time to execute if you call it.  In the future, we will add conditional flow control, making the recursion really useful :). <br><br><blockquote><pre>  ready&gt; <b>extern cos (x);</b>
 Read extern: 
 declare double @cos (double)
</pre><br>  ready&gt; <b>cos (1.234);</b> <pre> Read top-level expression:
 define double @ "" () {
 entry:
         % calltmp = call double @cos (double 1.234000e + 00)
         ret double% calltmp
 }
</pre></blockquote><br>  <code>extern</code> here is the <code>extern</code> for the library function <code>"cos"</code> and its call. <br><br><blockquote><pre>  ready&gt; <b>^ D</b>
 ;  ModuleID = 'my cool jit'<font></font>
<font></font>
 define double @ "" () {
 entry:
         % addtmp = fadd double 4.000000e + 00, 5.000000e + 00
         ret double% addtmp
 }<font></font>
<font></font>
 define double @foo (double% a, double% b) {
 entry:
         % multmp = fmul double% a,% a
         % multmp1 = fmul double 2.000000e + 00,% a
         % multmp2 = fmul double% multmp1,% b
         % addtmp = fadd double% multmp,% multmp2
         % multmp3 = fmul double% b,% b
         % addtmp4 = fadd double% addtmp,% multmp3
         ret double% addtmp4
 }<font></font>
<font></font>
 define double @bar (double% a) {
 entry:
         % calltmp = call double @foo (double% a, double 4.000000e + 00)
         % calltmp1 = call double @bar (double 3.133700e + 04)
         % addtmp = fadd double% calltmp,% calltmp1
         ret double% addtmp
 }<font></font>
<font></font>
 declare double @cos (double)<font></font>
<font></font>
 define double @ "" () {
 entry:
         % calltmp = call double @cos (double 1.234000e + 00)
         ret double% calltmp
 }
</pre></blockquote><br>  When exiting the current demo, an IR dump for the entire generated module will be returned.             . <br><br>         Kaleidoscope.        JIT  ,       ! <br><br><h1>    </h1><br>        , ,    LLVM.      LLVM,       .     <a href="http://llvm.org/cmds/llvm-config.html">llvm-config</a>  : <br><br><blockquote> <code>#  <br> <b>g++ -g -O3 toy.cpp `llvm-config --cppflags --ldflags --libs core` -o toy</b> <br> #  <br> <b>./toy</b> <br></code> </blockquote><br>  , ,  : <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/DerivedTypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/LLVMContext.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Module.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Analysis/Verifier.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/IRBuilder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;vector&gt; using namespace llvm; //===----------------------------------------------------------------------===// // Lexer ( ) //===----------------------------------------------------------------------===// //     [0-255],   , //       enum Token { tok_eof = -1, //  ( ) tok_def = -2, tok_extern = -3, //  ( : , ) tok_identifier = -4, tok_number = -5 }; static std::string IdentifierStr; // ,  tok_identifier static double NumVal; // ,  tok_number /// gettok -       . static int gettok() { static int LastChar = ' '; //  . while (isspace(LastChar)) LastChar = getchar(); if (isalpha(LastChar)) { // : [a-zA-Z][a-zA-Z0-9]* IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == "def") return tok_def; if (IdentifierStr == "extern") return tok_extern; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // : [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), 0); return tok_number; } if (LastChar == '#') { //     do LastChar = getchar(); while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r'); if (LastChar != EOF) return gettok(); } //   . if (LastChar == EOF) return tok_eof; //         ASCII int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (     ) //===----------------------------------------------------------------------===// /// ExprAST -      . class ExprAST { public: virtual ~ExprAST() {} virtual Value *Codegen() = 0; }; /// NumberExprAST -       (, "1.0"). class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double val) : Val(val) {} virtual Value *Codegen(); }; /// VariableExprAST -      (, "a"). class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string &amp;name) : Name(name) {} virtual Value *Codegen(); }; /// BinaryExprAST -      . class BinaryExprAST : public ExprAST { char Op; ExprAST *LHS, *RHS; public: BinaryExprAST(char op, ExprAST *lhs, ExprAST *rhs) : Op(op), LHS(lhs), RHS(rhs) {} virtual Value *Codegen(); }; /// CallExprAST -      . class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;ExprAST*&gt; Args; public: CallExprAST(const std::string &amp;callee, std::vector&lt;ExprAST*&gt; &amp;args) : Callee(callee), Args(args) {} virtual Value *Codegen(); }; /// PrototypeAST -    ""  , ///        (,  , ///    ). class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; public: PrototypeAST(const std::string &amp;name, const std::vector&lt;std::string&gt; &amp;args) : Name(name), Args(args) {} Function *Codegen(); }; /// FunctionAST -     class FunctionAST { PrototypeAST *Proto; ExprAST *Body; public: FunctionAST(PrototypeAST *proto, ExprAST *body) : Proto(proto), Body(body) {} Function *Codegen(); }; //===----------------------------------------------------------------------===// // Parser (   ) //===----------------------------------------------------------------------===// /// CurTok/getNextToken -    . CurTok -   /// ,  . getNextToken     ///     CurTok. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence -      static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -     . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     . int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } /// Error* -       . ExprAST *Error(const char *Str) { fprintf(stderr, "Error: %s\n", Str);return 0;} PrototypeAST *ErrorP(const char *Str) { Error(Str); return 0; } FunctionAST *ErrorF(const char *Str) { Error(Str); return 0; } static ExprAST *ParseExpression(); /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static ExprAST *ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '(') //  . return new VariableExprAST(IdName); //  . getNextToken(); //  ( std::vector&lt;ExprAST*&gt; Args; if (CurTok != ')') { while (1) { ExprAST *Arg = ParseExpression(); if (!Arg) return 0; Args.push_back(Arg); if (CurTok == ')') break; if (CurTok != ',') return Error("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return new CallExprAST(IdName, Args); } /// numberexpr ::= number static ExprAST *ParseNumberExpr() { ExprAST *Result = new NumberExprAST(NumVal); getNextToken(); //   return Result; } /// parenexpr ::= '(' expression ')' static ExprAST *ParseParenExpr() { getNextToken(); //  (. ExprAST *V = ParseExpression(); if (!V) return 0; if (CurTok != ')') return Error("expected ')'"); getNextToken(); //  ). return V; } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr static ExprAST *ParsePrimary() { switch (CurTok) { default: return Error("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); } } /// binoprhs /// ::= ('+' primary)* static ExprAST *ParseBinOpRHS(int ExprPrec, ExprAST *LHS) { //    ,    while (1) { int TokPrec = GetTokPrecedence(); //           , //  ,    if (TokPrec &lt; ExprPrec) return LHS; // ,  ,    . int BinOp = CurTok; getNextToken(); //    //       ExprAST *RHS = ParsePrimary(); if (!RHS) return 0; //  BinOp   RHS  ,    RHS, //      RHS  LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec+1, RHS); if (RHS == 0) return 0; } //  LHS/RHS. LHS = new BinaryExprAST(BinOp, LHS, RHS); } } /// expression /// ::= primary binoprhs /// static ExprAST *ParseExpression() { ExprAST *LHS = ParsePrimary(); if (!LHS) return 0; return ParseBinOpRHS(0, LHS); } /// prototype /// ::= id '(' id* ')' static PrototypeAST *ParsePrototype() { if (CurTok != tok_identifier) return ErrorP("Expected function name in prototype"); std::string FnName = IdentifierStr; getNextToken(); if (CurTok != '(') return ErrorP("Expected '(' in prototype"); //    . std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return ErrorP("Expected ')' in prototype"); //  . getNextToken(); //  ')'. return new PrototypeAST(FnName, ArgNames); } /// definition ::= 'def' prototype expression static FunctionAST *ParseDefinition() { getNextToken(); //  def. PrototypeAST *Proto = ParsePrototype(); if (Proto == 0) return 0; if (ExprAST *E = ParseExpression()) return new FunctionAST(Proto, E); return 0; } /// toplevelexpr ::= expression static FunctionAST *ParseTopLevelExpr() { if (ExprAST *E = ParseExpression()) { //   . PrototypeAST *Proto = new PrototypeAST("", std::vector&lt;std::string&gt;()); return new FunctionAST(Proto, E); } return 0; } /// external ::= 'extern' prototype static PrototypeAST *ParseExtern() { getNextToken(); //  extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Code Generation () //===----------------------------------------------------------------------===// static Module *TheModule; static IRBuilder&lt;&gt; Builder(getGlobalContext()); static std::map&lt;std::string, Value*&gt; NamedValues; Value *ErrorV(const char *Str) { Error(Str); return 0; } Value *NumberExprAST::Codegen() { return ConstantFP::get(getGlobalContext(), APFloat(Val)); } Value *VariableExprAST::Codegen() { //      . Value *V = NamedValues[Name]; return V ? V : ErrorV("Unknown variable name"); } Value *BinaryExprAST::Codegen() { Value *L = LHS-&gt;Codegen(); Value *R = RHS-&gt;Codegen(); if (L == 0 || R == 0) return 0; switch (Op) { case '+': return Builder.CreateFAdd(L, R, "addtmp"); case '-': return Builder.CreateFSub(L, R, "subtmp"); case '*': return Builder.CreateFMul(L, R, "multmp"); case '&lt;': L = Builder.CreateFCmpULT(L, R, "cmptmp"); //   0  1   0.0  1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(getGlobalContext()), "booltmp"); default: return ErrorV("invalid binary operator"); } } Value *CallExprAST::Codegen() { //      . Function *CalleeF = TheModule-&gt;getFunction(Callee); if (CalleeF == 0) return ErrorV("Unknown function referenced"); //    . if (CalleeF-&gt;arg_size() != Args.size()) return ErrorV("Incorrect # arguments passed"); std::vector&lt;Value*&gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-&gt;Codegen()); if (ArgsV.back() == 0) return 0; } return Builder.CreateCall(CalleeF, ArgsV.begin(), ArgsV.end(), "calltmp"); } Function *PrototypeAST::Codegen() { //   : double(double,double)  .. std::vector&lt;const Type*&gt; Doubles(Args.size(), Type::getDoubleTy(getGlobalContext())); FunctionType *FT = FunctionType::get(Type::getDoubleTy(getGlobalContext()), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule); //   (F)     ,     'Name'. //     ,      . if (F-&gt;getName() != Name) { //   ,      . F-&gt;eraseFromParent(); F = TheModule-&gt;getFunction(Name); //   (F)   , . if (!F-&gt;empty()) { ErrorF("redefinition of function"); return 0; } //   (F)    , . if (F-&gt;arg_size() != Args.size()) { ErrorF("redefinition of function with different # args"); return 0; } } //     . unsigned Idx = 0; for (Function::arg_iterator AI = F-&gt;arg_begin(); Idx != Args.size(); ++AI, ++Idx) { AI-&gt;setName(Args[Idx]); //      . NamedValues[Args[Idx]] = AI; } return F; } Function *FunctionAST::Codegen() { NamedValues.clear(); Function *TheFunction = Proto-&gt;Codegen(); if (TheFunction == 0) return 0; //      . BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "entry", TheFunction); Builder.SetInsertPoint(BB); if (Value *RetVal = Body-&gt;Codegen()) { //  . Builder.CreateRet(RetVal); //   ,    (). verifyFunction(*TheFunction); return TheFunction; } //  ,   . TheFunction-&gt;eraseFromParent(); return 0; } //===----------------------------------------------------------------------===// // Top-Level parsing (  )   JIT //===----------------------------------------------------------------------===// static void HandleDefinition() { if (FunctionAST *F = ParseDefinition()) { if (Function *LF = F-&gt;Codegen()) { fprintf(stderr, "Read function definition:"); LF-&gt;dump(); } } else { //      . getNextToken(); } } static void HandleExtern() { if (PrototypeAST *P = ParseExtern()) { if (Function *F = P-&gt;Codegen()) { fprintf(stderr, "Read extern: "); F-&gt;dump(); } } else { //      . getNextToken(); } } static void HandleTopLevelExpression() { // Evaluate a top-level expression into an anonymous function. if (FunctionAST *F = ParseTopLevelExpr()) { if (Function *LF = F-&gt;Codegen()) { fprintf(stderr, "Read top-level expression:"); LF-&gt;dump(); } } else { //      . getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (1) { fprintf(stderr, "ready&gt; "); switch (CurTok) { case tok_eof: return; case ';': getNextToken(); break; //     . case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // "" ,     //   ("extern")   . //===----------------------------------------------------------------------===// /// putchard -        0. extern "C" double putchard(double X) { putchar((char)X); return 0; } //===----------------------------------------------------------------------===// // Main driver code (  ) //===----------------------------------------------------------------------===// int main() { LLVMContext &amp;Context = getGlobalContext(); //    . // 1 -  . BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; //  . fprintf(stderr, "ready&gt; "); getNextToken(); //  ,     . TheModule = new Module("my cool jit", Context); //    " ". MainLoop(); //   . TheModule-&gt;dump(); return 0; }</span></span></span></span></code> </pre></blockquote></div><p>Source: <a href="https://habr.com/ru/post/120424/">https://habr.com/ru/post/120424/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120417/index.html">How to make a stylus for a capacitive touchscreen</a></li>
<li><a href="../120419/index.html">How to buy shares of IT-companies on foreign exchanges? (part 2)</a></li>
<li><a href="../120420/index.html">25 most popular web hosting sites</a></li>
<li><a href="../120421/index.html">Windows 8 interface</a></li>
<li><a href="../120423/index.html">The hosting version of BlackBerry Enterprise Server Express is available in Russia!</a></li>
<li><a href="../120425/index.html">Sberbank ATM interface 4 months later</a></li>
<li><a href="../120426/index.html">From the USA to Russia in a week ... Russian Post can!</a></li>
<li><a href="../120427/index.html">Will they play social games outside of social networks?</a></li>
<li><a href="../120428/index.html">Browser Strategy "Paths of History." Architecture and project evolution</a></li>
<li><a href="../120429/index.html">Creating real-time applications using Server-Sent Events</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>