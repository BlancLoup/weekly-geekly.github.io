<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing Unit Tests. Mocking objects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Who needs unit tests? Not for you - your code is perfect. But still, you just need to read this article, which should tell more about writing unit tes...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing Unit Tests. Mocking objects</h1><div class="post__text post__text-html js-mediator-article">  Who needs unit tests?  Not for you - your code is perfect.  But still, you just need to read this article, which should tell more about writing unit tests on Swift.  Suddenly it will come in handy later. <br><br>  Unit testing is a great way to write flawless code;  Testing will help you find the most mistakes at an early stage of writing a project.  As experience shows: if you have difficulties in testing the code, then you will have difficulties with its support or debugging. <br><br>  Unit testing works with isolated ‚Äúmicrocomponents‚Äù.  Often you need to ‚Äúmock‚Äù classes - that is, to provide a fake with a functional implementation to isolate a specific microcomponent, so that it can be tested.  In <b>Objective-C,</b> there are several third-party frameworks that help implement this.  But they are not yet available in <b>Swift</b> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this tutorial, you will learn how to write your own mock objects, fakes, and stubs to cover with a dowry a simple app that helps you remember the birthdays of your friends. <br><a name="habracut"></a><br>  <b>let's start</b> <br><br>  <a href="">Download the startup project</a> this is a contact storage application.  You will not work on the functionality of the base application;  rather, you will write several tests for it to make sure that the application is working properly. <br><br>  Compile and run the application, and then check how it works.  Click the <b>plus</b> button and then add <b>John Appleseed</b> to the general contact list: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/90d/d30/dfb/90dd30dfb9987340da107c98bfbfc226.png" alt="image"><br><br>  For storage of contacts, applications uses <b>Core Data</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c5/8bc/222/0c58bc222043dd71a52e92b7e91e6fa7.png" alt="image"><br><br>  Do not panic!  You do not need <b>Core Data</b> experience for this lesson;  for this you do not need to have any special skills. <br><br>  <b>Advantages and disadvantages of unit testing</b> <br><br>  When it comes to writing tests, you will come across both good and bad news.  The bad news is that unit testing has the following disadvantages: <br><br><ul><li>  <b>Large amount of code:</b> In projects with large test coverage, you may have more tests than functional code. </li><li>  <b>More support:</b> The more code, the more it needs to be supported. </li><li>  <b>No right decision:</b> Unit testing does not guarantee, and can not guarantee that your code will be error free. </li><li>  <b>Takes more time:</b> Writing tests takes some time - the time you could spend studying new information on <a href="http://habrahabr.ru/">habrahabr.ru</a> ! </li></ul><br><br>  Although there is no perfect solution, there is a bright side - writing tests has the following advantages: <br><br><ul><li>  <b>Confidence:</b> You can make sure your code works. </li><li>  <b>Quick reviews:</b> You can use unit testing to quickly verify code that is hidden under many layers of navigation ‚Äî too large components that need to be manually checked. </li><li>  <b>Modularity:</b> Unit testing helps you focus on writing more modular code. </li><li>  <b>Orientation:</b> Writing tests for micro-components will help you focus on small details. </li><li>  <b>Regression:</b> Ensure that the errors you fixed earlier remain corrected ‚Äî and are not disturbed by subsequent corrections. </li><li>  <b>Refactoring:</b> Until <b>Xcode</b> is smart enough to rewrite the code yourself, you will need unit testing to check for refactoring. </li><li>  <b>Documentation:</b> Unit testing describes what you think the code should do;  he is another way of writing code. </li></ul><br><br>  <b>Basic application structure</b> <br><br>  A large amount of code in applications is based on the <b>Master-Detail Application</b> template with <b>Core Data</b> enabled.  But there are some significant improvements to the code pattern.  Open the project in <b>Xcode</b> and look at the project navigator: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/845/cf9/623/845cf96237f2a82b2e3d9af60cfc7337.png" alt="image"><br><br>  Consider the following details: <br><br><ul><li>  You have a <b>Person.swift</b> file and a <b>PersonInfo.swift</b> file.  The <b>Person</b> class is a descendant of <b>NSManagedObject</b> , which contains some basic information about each person.  The <b>PersonInfo</b> structure contains the same information, but can be updated from the address book. </li><li>  The <b>PeopleList</b> folder has three files: a view controller, a data provider, and a data provider protocol. </li></ul><br>  A collection of files in <b>PeopleList</b> to avoid large view controllers.  In order to avoid large view controllers, you can shift some responsibilities to other classes that connect to view controllers using a simple protocol.  You can learn more about large view controllers and how to avoid them by reading this interesting, albeit <a href="http://www.objc.io/issues/1-view-controllers/lighter-view-controllers/">older, article</a> . <br><br>  In this case, the protocol is defined in <b>PeopleListDataProviderProtocol.swift</b> ;  open it and see.  The class that conforms to this protocol must have the properties <b>managedObjectContext</b> and <b>tableView</b> , and must define the <b>addPerson (_ :)</b> and <b>fetch ()</b> methods.  In addition, it must comply with the <b>UITableViewDataSource</b> protocol. <br><br>  The view controller <b>PeopleListViewController</b> has a <b>dataProvider</b> property, which corresponds to the <b>PeopleListDataProviderProtocol</b> protocol.  This property is set to the PeopleListDataProvider instance in the AppDelegate.swift file. <br><br>  Add new people to your contact list using <b>ABPeoplePickerNavigationController</b> .  This class allows you, as a developer, to have access to user contacts without needing permission. <br><br>  <b>PeopleListDataProvider is</b> responsible for filling out the table view and accessing <b>Core Data</b> . <br><br>  <i><b>Note:</b></i> Several classes and methods in the project are declared public;  so that the target for tests can access classes and methods.  Target for tests is outside the application module.  If you do not add an access modifier, classes and methods are defined as <b>internal</b> .  This means that they are only available in the same module.  To access them from outside the module (for example, from a test target), you must add a <b>public</b> access <b>modifier</b> . <br><br>  Well, it's time to write a few tests! <br><br>  <b>Writing mock objects</b> <br><br>  Mock objects allow you to check whether a method call is made or a property is set.  For example, on <b>viewDidLoad ()</b> from <b>PeopleListViewController</b> , the table view is set to the <b>tableView</b> property of the <b>dataProvider</b> . <br><br>  You write a test to check what is actually happening. <br><br>  <b>Preparation of the application for testing</b> <br><br>  First, you need to prepare a project for writing tests. <br><br>  Select a project in the project navigator, then select <b>Build Settings</b> in the Birthdays testing tag.  Find the <b>Defines Module</b> , and change the settings to <b>Yes</b> , as shown below: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/dd7/7dd/f36/dd77ddf36226d5f2bb08f38cd2cea727.png" alt="image"><br><br>  Then select the <b>BirthdaysTests</b> folder and go to <b>File \ New \ File ....</b>  Select <b>iOS \ Source \ Test Case Class</b> , then click Next, name it <b>PeopleListViewControllerTests</b> , make sure you create the <b>Swift</b> file, click <b>Next</b> again, then click <b>Create</b> . <br><br>  If <b>Xcode</b> prompts you to create a unifying header, select <b>No.</b>  This is an error in <b>Xcode</b> that occurs when there are no files in the target, and you add a new <b>Swift</b> file. <br><br>  Open the newly created <b>PeopleListViewControllerTests.swift</b> .  Import the module you just included by adding the <b>import Birthdays</b> statement right after the other import statements, as shown below: <br><br><pre><code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> import <span class="hljs-built_in"><span class="hljs-built_in">XCTest</span></span> import Birthdays</code> </pre> <br>  Remove the following two template methods: <br><br><pre> <code class="objectivec hljs">func testExample() { <span class="hljs-comment"><span class="hljs-comment">// This is an example of a functional test case. XCTAssert(true, "Pass") } func testPerformanceExample() { // This is an example of a performance test case. self.measureBlock() { // Put the code you want to measure the time of here. } }</span></span></code> </pre><br>  You now need a copy of <b>PeopleListViewController</b> , so you can use it in tests. <br><br>  Add the following line to the top of the <b>PeopleListViewControllerTests</b> <br><br><pre> <code class="objectivec hljs">var viewController: PeopleListViewController!</code> </pre><br>  Then replace the setUp () method with the following code: <br><br><pre> <code class="objectivec hljs">override func setUp() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.setUp() viewController = <span class="hljs-built_in"><span class="hljs-built_in">UIStoryboard</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Main"</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).instantiateViewControllerWithIdentifier(<span class="hljs-string"><span class="hljs-string">"PeopleListViewController"</span></span>) as! PeopleListViewController }</code> </pre><br>  It uses the <b>storyboard</b> to create an instance of <b>PeopleListViewController</b> , and assigns it to the <b>viewController</b> . <br><br>  Select <b>Product \ Test</b> ;  <b>Xcode</b> compiles the project and runs any existing tests.  Although you have no tests yet, this will allow you to make sure that everything is set up correctly.  After a few seconds, <b>Xcode</b> should report that all tests passed successfully. <br><br>  You are now on your way to creating your first mock object. <br><br>  <b>Writing the first mock object</b> <br><br>  Since you are going to work with <b>Core Data</b> , add the following import up <b>PeopleListViewControllerTests.swift</b> , immediately after the <b>import Birthdays line</b> : <br><br><pre> <code class="objectivec hljs">import CoreData</code> </pre><br>  Then add the following code to the definition of the <b>PeopleListViewControllerTests</b> class: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MockDataProvider: <span class="hljs-built_in"><span class="hljs-built_in">NSObject</span></span>, PeopleListDataProviderProtocol { var managedObjectContext: <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectContext</span></span>? <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> var tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>! func addPerson(personInfo: PersonInfo) { } func fetch() { } func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, numberOfRowsInSection section: Int) -&gt; Int { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> } func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, cellForRowAtIndexPath indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span>() } }</code> </pre><br>  This looks like a rather complicated mock object.  However, this is simply the required absolute minimum, since you are going to assign an instance of this mock class to the <b>PeopleListViewController</b> <b>dataProvider</b> property.  Your mock class must also comply with the <b>PeopleListDataProviderProtocol</b> , as well as the <b>UITableViewDataSource</b> protocol. <br><br>  Select <b>Product \ Test</b> ;  the project will be re-compiled, and your tests passed to ur.  But now you are all set for the first unit test using a mock object. <br><br>  It is necessary to divide unit testing into three parts, naming them, <b>given</b> , <b>when</b> , and <b>then</b> .  ' <b>Given</b> ' sets up the environment;  ' <b>when</b> ' executes the code you want to test;  and then checks the expected result. <br><br>  Your test will verify that the <b>tableView</b> property of the <b>data</b> provider is set after the <b>viewDidLoad ()</b> method <b>has</b> been executed. <br><br>  Add the following test to <b>PeopleListViewControllerTests:</b> <br><br><pre> <code class="objectivec hljs">func testDataProviderHasTableViewPropertySetAfterLoading() { <span class="hljs-comment"><span class="hljs-comment">// given // 1 let mockDataProvider = MockDataProvider() viewController.dataProvider = mockDataProvider // when // 2 XCTAssertNil(mockDataProvider.tableView, "Before loading the table view should be nil") // 3 let _ = viewController.view // then // 4 XCTAssertTrue(mockDataProvider.tableView != nil, "The table view should be set") XCTAssert(mockDataProvider.tableView === viewController.tableView, "The table view should be set to the table view of the data source") }</span></span></code> </pre><br>  Here is how the above test works: <br><ol><li>  Creates an instance of <b>MockDataProvider</b> and sets it to the view controller property for dataProvider. </li><li>  Confirms that the tableView property is nil before the test begins. </li><li>  Has access to the view to run <b>viewDidLoad ()</b> . </li><li>  Confirms that the property of the test class <b>tableView is</b> not nil and the property is set in the <b>tableView of the view</b> controller. </li></ol><br><br>  Then select <b>Product \ Test</b> again;  as soon as the tests are completed, open the navigator ( <b>Cmd + 5</b> - a convenient shortcut).  And you should see the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/47b/417/7a3/47b4177a39e2c9782dd790f6a133607c.png" alt="image"><br><br>  Your first testing with a mock object was successful! <br><br>  <b>Testing the addPerson (_ :) method</b> <br><br>  The next test is to make sure that choosing a contact from the list will call the <b>addPerson (_ :)</b> method <br><br>  Add the following property to the <b>MockDataProvider</b> class: <br><br><pre> <code class="objectivec hljs">var addPersonGotCalled = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br>  Then replace the <b>addPerson (_ :)</b> method with the following: <br><br><pre> <code class="objectivec hljs">func addPerson(personInfo: PersonInfo) { addPersonGotCalled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br>  Now, when you call <b>addPerson (_ :)</b> , you register it in the instance by setting the value to <b>true</b> for <b>MockDataProvider</b> . <br><br>  You will have to import the <b>AddressBookUI</b> framework before you can add a method to test this behavior. <br><br>  Add the following import to <b>PeopleListViewControllerTests.swift</b> : <br><br><pre> <code class="objectivec hljs">import AddressBookUI</code> </pre><br>  Now add the following test method to the rest of the test scripts: <br><br><pre> <code class="objectivec hljs">func testCallsAddPersonOfThePeopleDataSourceAfterAddingAPersion() { <span class="hljs-comment"><span class="hljs-comment">// given let mockDataSource = MockDataProvider() // 1 viewController.dataProvider = mockDataSource // when // 2 let record: ABRecord = ABPersonCreate().takeRetainedValue() ABRecordSetValue(record, kABPersonFirstNameProperty, "TestFirstname", nil) ABRecordSetValue(record, kABPersonLastNameProperty, "TestLastname", nil) ABRecordSetValue(record, kABPersonBirthdayProperty, NSDate(), nil) // 3 viewController.peoplePickerNavigationController(ABPeoplePickerNavigationController(), didSelectPerson: record) // then // 4 XCTAssert(mockDataSource.addPersonGotCalled, "addPerson should have been called") }</span></span></code> </pre><br>  So what happens here? <br><br><ol><li>  First you install the data provider of the view controller to an instance of your fake data provider. </li><li>  Then you create a contact using <b>ABPersonCreate ()</b> . </li><li>  Here you manually call the delegate method <b>peoplePickerNavigationController (_: didSelectPerson :)</b> .  Typically, manually calling delegate methods is a sign of bad code, but good for testing purposes. </li><li>  Finally, you confirm that <b>addPerson (_ :)</b> was called by checking that <b>addPersonGotCalled</b> is true. </li></ol><br><br>  Select <b>Product \ Test</b> to run the tests.  So it turns out, this is quite an easy task! <br><br>  But wait!  Do not hurry!  How do you know that tests actually test what you think they are testing? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2b/13e/2d4/f2b13e2d492f2b4a06421ec844a62c31.png" alt="image"><br><br>  <b>Test your tests</b> <br><br>  A quick way to verify that a test is actually checking something is to remove the object that the test is checking. <br><br>  Open <b>PeopleListViewController.swift</b> and comment out the following line <b>peoplePickerNavigationController (_: didSelectPerson :)</b> : <br><br><pre> <code class="objectivec hljs">dataProvider?.addPerson(person)</code> </pre><br>  Run the tests again;  The last test you just wrote should now fail.  Masterpiece - you know that your tests actually test something.  You should check your tests;  at the very least, you should check the most complex tests to make sure they work. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd4/431/593/bd44315939904c297bd8af76f95094d8.png" alt="image"><br><br>  Uncomment the line to get the code back into operation;  run the tests again to make sure everything works. <br><br>  <b>Mocking Apple Framework Classes</b> <br><br>  You could use singletons such as <b>NSUserDefaults.standardUserDefaults ()</b> and <b>NSNotificationCenter.defaultCenter ()</b> , but how would you test the default value?  <b>Apple</b> does not allow you to check the status of these classes. <br><br>  You could add a test class as an observer of the expected result.  But it can slow down your tests and make them unreliable, since they depend on the implementation of those classes.  Or the value could be set from another part of your code, and you did not check the isolated behavior. <br><br>  To get around these limitations, you can use mock objects instead of these singletons. <br><br>  <b><i>Note:</i></b> When replacing <b>Apple</b> classes with a mock object, it is very important to test the interaction with that class, and not with the behavior of that class, since implementation details may change at any time. <br><br>  Compile and run the application;  Add <b>John Appleseed</b> and <b>David Taylor</b> to the list of people and switch the sorting between <b>‚ÄúLast Name‚Äù</b> and <b>‚ÄúFirst Name‚Äù</b> .  You will see that the order of the contacts in the list depends on the sorting. <br><br>  The code that is responsible for sorting is in the <b>changeSort ()</b> method in <b>PeopleListViewController.swift</b> : <br><br><pre> <code class="objectivec hljs">@IBAction func changeSorting(sender: <span class="hljs-built_in"><span class="hljs-built_in">UISegmentedControl</span></span>) { userDefaults.setInteger(sender.selectedSegmentIndex, forKey: <span class="hljs-string"><span class="hljs-string">"sort"</span></span>) dataProvider?.fetch() }</code> </pre><br>  It adds the selected segment index for key sorting to <b>NSUserDefaults</b> and calls the <b>fetch ()</b> method.  The <b>fetch ()</b> method should read this new sort order with <b>NSUserDefaults</b> and update the contact list shown in <b>PeopleListDataProvider</b> : <br><br><pre> <code class="objectivec hljs">let sortKey = <span class="hljs-built_in"><span class="hljs-built_in">NSUserDefaults</span></span>.standardUserDefaults().integerForKey(<span class="hljs-string"><span class="hljs-string">"sort"</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span> ? <span class="hljs-string"><span class="hljs-string">"lastName"</span></span> : <span class="hljs-string"><span class="hljs-string">"firstName"</span></span> let sortDescriptor = <span class="hljs-built_in"><span class="hljs-built_in">NSSortDescriptor</span></span>(key: sortKey, ascending: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) let sortDescriptors = [sortDescriptor] fetchedResultsController.fetchRequest.sortDescriptors = sortDescriptors var error: <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !fetchedResultsController.performFetch(&amp;error) { println(<span class="hljs-string"><span class="hljs-string">"error: \(error)"</span></span>) } tableView.reloadData() }</code> </pre><br>  <b>PeopleListDataProvider</b> uses <b>NSFetchedResultsController</b> to fetch data from <b>Core Data</b> .  To replace the sorting of the list, <b>fetch ()</b> creates an array using sorting descriptors and sets it in the query query of the selected result controller.  It then performs a selection to update the list and call the <b>reloadData ()</b> method for the table. <br><br>  You will now add a test to make sure that the preferred sorting order of the user is correctly set to <b>NSUserDefaults</b> . <br><br>  Open <b>PeopleListViewControllerTests.swift</b> and add the following class definition below the <b>Mockdataprovider</b> class <b>definition</b> : <br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MockUserDefaults: <span class="hljs-built_in"><span class="hljs-built_in">NSUserDefaults</span></span> { var sortWasChanged = <span class="hljs-literal"><span class="hljs-literal">false</span></span> override func setInteger(value: Int, forKey defaultName: String) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> defaultName == <span class="hljs-string"><span class="hljs-string">"sort"</span></span> { sortWasChanged = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } } }</code> </pre><br>  <b>MockUserDefaults</b> is a subclass of <b>NSUserDefaults</b> ;  it has the sortWWCChanged boolean property with a default value of <b>false</b> .  It also overrides the <b>setInteger (_: forKey :) method</b> , which changes the value of <b>sortWasChanged</b> to <b>true</b> . <br><br>  Add the following test below the last test in the <b>PeopleListViewControllerTests</b> class: <br><br><pre> <code class="objectivec hljs">func testSortingCanBeChanged() { <span class="hljs-comment"><span class="hljs-comment">// given // 1 let mockUserDefaults = MockUserDefaults(suiteName: "testing")! viewController.userDefaults = mockUserDefaults // when // 2 let segmentedControl = UISegmentedControl() segmentedControl.selectedSegmentIndex = 0 segmentedControl.addTarget(viewController, action: "changeSorting:", forControlEvents: .ValueChanged) segmentedControl.sendActionsForControlEvents(.ValueChanged) // then // 3 XCTAssertTrue(mockUserDefaults.sortWasChanged, "Sort value in user defaults should be altered") }</span></span></code> </pre><br>  Here is the report of this verification: <br><ol><li>  You first assign an instance of <b>MockUserDefaults</b> to the <b>userDefaults of the view</b> controller;  This technique is known as dependency injection. </li><li>  Then create an instance of <b>UISegmentedControl</b> , add the view controller as a termset for <b>.ValueChanged</b> . </li><li>  Finally, you confirm that <b>setInteger (_: forKey :) the</b> default user mock object was invoked.  Notice that you check if the value was actually stored in <b>NSUserDefaults</b> . </li></ol><br><br>  Run your test suite ‚Äî they should all complete successfully. <br><br>  As for the case when you have a really complicated API or framework, but you really want to test a small component, don't ‚Äúdig in‚Äù deep into the framework! <br><br>  That's when you ‚Äúfake‚Äù it, not create it!  :] <br><br>  <b>Writing Fakes Objects</b> <br><br>  <b>Fakes</b> objects behave like the full implementation of the classes they fake.  You use them as substitutes for classes or structures that are too difficult to work with. <br><br>  In the case of an application, you do not need to add entries and select them from <b>Core Data</b> .  So instead you fake <b>Core Data</b> .  Sounds a little scary, doesn't it? <br><br>  Select the <b>BirthdaysTests</b> folder and go to <b>File \ New \ File ....</b>  Select the <b>iOS \ Source \ Test Case Class</b> template and click <b>Next</b> .  Name your class <b>PeopleListDataProviderTests</b> , click <b>Next</b> and then <b>Create</b> . <br><br>  Again, remove unnecessary tests in the test class you created: <br><br><pre> <code class="objectivec hljs">func testExample() { <span class="hljs-comment"><span class="hljs-comment">// ... } func testPerformanceExample() { // ... }</span></span></code> </pre><br>  Add the following two imports to the new class: <br><br><pre> <code class="objectivec hljs">import Birthdays import CoreData</code> </pre><br>  Then add the following properties: <br><br><pre> <code class="objectivec hljs">var storeCoordinator: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStoreCoordinator</span></span>! var managedObjectContext: <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectContext</span></span>! var managedObjectModel: <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObjectModel</span></span>! var store: <span class="hljs-built_in"><span class="hljs-built_in">NSPersistentStore</span></span>! var dataProvider: PeopleListDataProvider!</code> </pre><br>  Properties contain the main components that are used in the <b>Core Data</b> stack.  To get started with <b>Core Data</b> , see our <a href="http://www.raywenderlich.com/85578/first-core-data-app-using-swift">Core Data Tutorial: Getting Started.</a> <br><br>  Add the following code to the <b>setUp ()</b> method: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 managedObjectModel = NSManagedObjectModel.mergedModelFromBundles(nil) storeCoordinator = NSPersistentStoreCoordinator(managedObjectModel: managedObjectModel) store = storeCoordinator.addPersistentStoreWithType(NSInMemoryStoreType, configuration: nil, URL: nil, options: nil, error: nil) managedObjectContext = NSManagedObjectContext() managedObjectContext.persistentStoreCoordinator = storeCoordinator // 2 dataProvider = PeopleListDataProvider() dataProvider.managedObjectContext = managedObjectContext</span></span></code> </pre><br>  Here is what happens in the above code: <br><br><ol><li>  setUp () creates a managed object context using in-memory storage.  Typically, <b>Core Data</b> is a file in the device file system.  For these tests, you create a 'permanent' storage in the device's memory. </li><li>  Then you create an instance of PeopleListDataProvider and a managed object context with an in-memory store that is set as a managedObjectContext.  This means that your new data provider will work as real, but will not add or delete objects in Core Data. </li></ol><br><br>  Add the following two properties to <b>PeopleListDataProviderTests</b> : <br><br><pre> <code class="objectivec hljs">var tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>! var testRecord: PersonInfo!</code> </pre><br>  Now add the following code to the end of the <b>setUp ()</b> method: <br><pre> <code class="objectivec hljs">let viewController = <span class="hljs-built_in"><span class="hljs-built_in">UIStoryboard</span></span>(name: <span class="hljs-string"><span class="hljs-string">"Main"</span></span>, bundle: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).instantiateViewControllerWithIdentifier(<span class="hljs-string"><span class="hljs-string">"PeopleListViewController"</span></span>) as! PeopleListViewController viewController.dataProvider = dataProvider tableView = viewController.tableView testRecord = PersonInfo(firstName: <span class="hljs-string"><span class="hljs-string">"TestFirstName"</span></span>, lastName: <span class="hljs-string"><span class="hljs-string">"TestLastName"</span></span>, birthday: <span class="hljs-built_in"><span class="hljs-built_in">NSDate</span></span>())</code> </pre><br>  This configures the table view by instantiating the view controller from the storyboard and creates an instance of PersonInfo that will be used in the tests. <br><br>  When the test is completed, you will need to ‚Äúreset‚Äù the managed object context. <br><br>  Replace the <b>tearDown ()</b> method <b>with the</b> following code: <br><br><pre> <code class="objectivec hljs">override func tearDown() { managedObjectContext = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> var error: <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>? = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-built_in"><span class="hljs-built_in">XCTAssert</span></span>(storeCoordinator.removePersistentStore(store, error: &amp;error), <span class="hljs-string"><span class="hljs-string">"couldn't remove persistent store: \(error)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.tearDown() }</code> </pre><br>  This code sets the managedObjectContext to nil to free up memory and remove the persistent store from the store coordinator.  You can run each test with a new test repository. <br><br>  Now - you can write a test!  Add the following test to your test class: <br><br><pre> <code class="objectivec hljs">func testThatStoreIsSetUp() { <span class="hljs-built_in"><span class="hljs-built_in">XCTAssertNotNil</span></span>(store, <span class="hljs-string"><span class="hljs-string">"no persistent store"</span></span>) }</code> </pre><br>  This test verifies that the store is not nil.  Run a new test - everything should be successful. <br><br>  The following test will check if the data source provides the expected number of rows. <br><br>  Add the following test to the test class: <br><br><pre> <code class="objectivec hljs">func testOnePersonInThePersistantStoreResultsInOneRow() { dataProvider.addPerson(testRecord) <span class="hljs-built_in"><span class="hljs-built_in">XCTAssertEqual</span></span>(tableView.dataSource!.tableView(tableView, numberOfRowsInSection: <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"After adding one person number of rows is not 1"</span></span>) }</code> </pre><br>  First add the contact to the test repository, then confirm that the number of rows is 1. <br>  Run the tests - they should all succeed. <br><br>  By creating a fake ‚Äúpermanent‚Äù storage, you ensure fast testing and allow the disk to remain clean, so you can be sure that the application will run when you start, as expected. <br><br>  Written test You can also check the number of sections and lines after you have added two or more test contacts;  it all depends on the level of confidence you are trying to achieve in the project. <br><br>  If you have ever worked with several teams on a project at once, you know that not all parts of the project are ready at the same time, but you already need to test your code.  But how can you test part of your code for something that does not exist, for example a web service? <br><br>  Stub'y come to the rescue! <br><br>  <b>Writing Stubs</b> <br><br>  The stubs forge the response to the object's method calls.  You will use stubs to test your code calling a web service, which may be still in development. <br><br>  The web team for your project was tasked with creating a web service with the same functionality as the application.  The user creates an account on the service and can then synchronize data between the application and the service.  But the web team didn‚Äôt even start their part of the work, and you‚Äôve almost finished the development.  Looks like you should write a stub to replace the web server component. <br><br>  In this section, you will focus on writing tests of two methods: one for selecting contacts added to the site and one to add contacts from your application to the web service.  In the real scenario, you will need a login and account and error handling, but we will do this another time. <br><br>  Open <b>APICommunicatorProtocol.swift</b> ;  This protocol declares two methods for getting contacts from a web service and adding contacts. <br><br>  You could move instances of Person, but this would require a different managed object context.  Using structures has become much easier in this case. <br><br>  You will now create stubs to support the interaction of the view controller with the <b>APICommunicator</b> instance. <br><br>  Open <b>PeopleListViewControllerTests.swift</b> and add the following class definition within the <b>PeopleListViewControllerTests</b> class: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// 1 class MockAPICommunicator: APICommunicatorProtocol { var allPersonInfo = [PersonInfo]() var postPersonGotCalled = false // 2 func getPeople() -&gt; (NSError?, [PersonInfo]?) { return (nil, allPersonInfo) } // 3 func postPerson(personInfo: PersonInfo) -&gt; NSError? { postPersonGotCalled = true return nil } }</span></span></code> </pre><br>  Something needs to be noted: <br><ol><li>  Even if the APICommunicator is a structure, the simulated implementation is a class.  In this case, it will be more convenient to use the class, because your tests require you to modify the data.  This is a little easier to do in class than in structure. </li><li>  The getPeople () method returns what is stored in allPersonInfo.  Instead of downloading data from the network, you simply store the contact information in a simple array. </li><li>  The postPerson (_ :) method sets the postPersonGotCalled value to true. </li></ol><br><br>  Now it's time to test your Stub API to make sure all contacts returned from the API are added to the repository when you call the <b>addPerson ()</b> method <br><br>  Add the following test method to <b>PeopleListViewControllerTests</b> : <br><br><pre> <code class="objectivec hljs">func testFetchingPeopleFromAPICallsAddPeople() { <span class="hljs-comment"><span class="hljs-comment">// given // 1 let mockDataProvider = MockDataProvider() viewController.dataProvider = mockDataProvider // 2 let mockCommunicator = MockAPICommunicator() mockCommunicator.allPersonInfo = [PersonInfo(firstName: "firstname", lastName: "lastname", birthday: NSDate())] viewController.communicator = mockCommunicator // when viewController.fetchPeopleFromAPI() // then // 3 XCTAssert(mockDataProvider.addPersonGotCalled, "addPerson should have been called") }</span></span></code> </pre><br>  Here is what happens in the above code: <br><ol><li>  First, you configure the <b>mockDataProvider</b> and <b>mockCommunicator</b> imitation objects that you will use in the test. </li><li>  Then you set up some fake contacts and call the <b>fetchPeopleFromAPI ()</b> method to make a fake network call. </li><li>  Finally test the <b>addPerson (_ :)</b> method. </li></ol><br>  Compile and run the tests. <br><br>  <b>And what's next?</b> <br><br>  <a href="">Download the final version of the project</a> ; this version also includes some additional tests that were not covered in this article. <br><br>  You learned how to write mock objects, fakes and stubs for testing microcomponents in your application and figured out how <b>XCTest</b> works in <b>Swift</b> . <br><br>  This article presents only an initial understanding of the tests;  I'm sure you already have ideas for writing tests for your applications. <br><br>  For more unit testing information, see <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development (TDD)</a> and <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Behavior Driven Development (BDD)</a> .  These are application development methodologies (and, frankly, represent a completely new way of thinking) where you write tests before you write code. <br><br>  Unit testing is only one part of a complete test suite;  comprehensive testing is the next logical step.  A simple way to get started with integrated testing is to use <b>UIAutomation</b> .  If you are serious about testing your applications, then you need to use <b>UIAutomation</b> ! <br><br>  ps Since the article was written earlier 09/09/2015, Swift 1.2 was used to write the examples.  I made some changes to the examples due to the release of the new Swift language version.  Source code for projects can be found <a href="https://github.com/yarmolchuk/Birthdays_Starter">here</a> and <a href="https://github.com/yarmolchuk/Birthdays_Final">here</a> . </div><p>Source: <a href="https://habr.com/ru/post/267255/">https://habr.com/ru/post/267255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267241/index.html">Maintenance code. How to ‚Äúsell‚Äù refactoring to business</a></li>
<li><a href="../267243/index.html">RxJava. Fighting the challenges of harsh reality</a></li>
<li><a href="../267245/index.html">RailsClub 2015: Interview with Nikolai Ryzhikov</a></li>
<li><a href="../267247/index.html">How many tweets do you need to know your character?</a></li>
<li><a href="../267253/index.html">In the Chinese AppStore, 39 infected applications were detected due to a modified version of Xcode.</a></li>
<li><a href="../267257/index.html">New PHP, Part 1: Return types</a></li>
<li><a href="../26726/index.html">Business Prospects for Organizing Online Seminars</a></li>
<li><a href="../267265/index.html">The digest of interesting materials for the mobile developer # 121 (September 14-20)</a></li>
<li><a href="../267269/index.html">Monitoring delays during online video broadcasts and teleconferences</a></li>
<li><a href="../267271/index.html">It's harder for Chinese data center operators to use freecooling.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>