<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Operating systems from scratch; level 2 (younger half)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this part we will write a memory manager to unlock using Vec , String , HashMap and all that. Immediately after that, we will implement the FAT32 f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Operating systems from scratch; level 2 (younger half)</h1><div class="post__text post__text-html js-mediator-article"><p><img title="KDPV" align="left" width="300" src="https://habrastorage.org/webt/mi/cf/3x/micf3xhwy_zkodbd4cvpfymvnlu.gif">  In this part we will write a memory manager to unlock using <code>Vec</code> , <code>String</code> , <code>HashMap</code> and all that.  Immediately after that, we will implement the FAT32 file system and connect the driver for EMMC (such a thing for communicating with SD cards).  In the end, a couple of new commands will appear in our command shell: <code>cd</code> , <code>pwd</code> , <code>cat</code> , <code>ls</code> . </p><br><p>  <a href="https://habrahabr.ru/post/349248/">Null lab</a> </p><br><p>  First Laba: the <a href="https://habrahabr.ru/post/351082/">younger half</a> and the <a href="https://habrahabr.ru/post/351774/">older half</a> </p><a name="habracut"></a><br><h2 id="poleznosti">  Utility </h2><br><ul><li>  <a href="https://doc.rust-lang.org/book/second-edition/">The book is on Rust</a> version 2. <a href="https://github.com/ruRust/rust_book_2ed/tree/ru_version/second-edition/src">In Russian</a> translation is not completed until the end.  So just markdown. </li><li>  <a href="https://doc.rust-lang.org/nightly/std/">Reference</a> to the standard library Rust. </li><li>  <a href="https://web.stanford.edu/class/cs140e/docs/BCM2837-ARM-Peripherals.pdf">Manual</a> peripherals processor BCM2837. </li><li>  <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">ATAGS Help</a> </li><li>  <a href="https://web.stanford.edu/class/cs140e/notes/lec7/fat-structs.pdf">Brief description of FAT structures</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system">An article about FAT32</a> from the English Wikipedia. </li></ul><br><h2 id="faza-0-nachalo-rabot">  Phase 0: Getting Started </h2><br><p>  To begin with, we are convinced that from the very beginning nothing has changed in our environment: </p><br><ul><li>  Are there Linux, BSD or macOS </li><li>  It is 64-bit </li><li>  Do you have a USB port </li></ul><br><p>  In addition, this is installed: <code>git</code> , <code>wget</code> , <code>tar</code> , <code>screen</code> , <code>make</code> and all that was in the past series.  We are convinced of <em>stability</em> and we go further. </p><br><h3 id="poluchenie-neobhodimogo-koda">  Getting the necessary code </h3><br><p>  We clone into our daddy named <code>cs140e</code> (or <code>cs140e</code> you called it there) this repository: </p><br><pre> <code class="hljs ruby">git clone <span class="hljs-symbol"><span class="hljs-symbol">https:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/web.stanford.edu/class</span></span><span class="hljs-regexp"><span class="hljs-regexp">/cs140e/assignments</span></span><span class="hljs-regexp"><span class="hljs-regexp">/2-fs/skeleton</span></span>.git <span class="hljs-number"><span class="hljs-number">2</span></span>-fs</code> </pre> <br><p>  After all this, there should be something like this structure: </p><br><pre> <code class="hljs dos">cs140e ‚îú‚îÄ‚îÄ <span class="hljs-number"><span class="hljs-number">0</span></span>-blinky ‚îú‚îÄ‚îÄ <span class="hljs-number"><span class="hljs-number">1</span></span>-shell ‚îú‚îÄ‚îÄ <span class="hljs-number"><span class="hljs-number">2</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">fs</span></span> ‚îî‚îÄ‚îÄ os</code> </pre> <br><p>  Now you need to merge the <code>os</code> repository, in which there is some of your code, with that, the code that will be used in this part: </p><br><pre> <code class="hljs sql">cd os git fetch git checkout 2-fs git <span class="hljs-keyword"><span class="hljs-keyword">merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">master</span></span></code> </pre> <br><p>  You may have to resolve merge conflicts.  You can see something similar to: </p><br><pre> <code class="hljs pgsql">Auto-merging kernel/src/kmain.rs <span class="hljs-keyword"><span class="hljs-keyword">CONFLICT</span></span> (content): Merge <span class="hljs-keyword"><span class="hljs-keyword">conflict</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> kernel/src/kmain.rs Automatic merge failed; fix conflicts <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span> the result.</code> </pre> <br><p>  Automatically failed.  Will have to hands.  In order to resolve this, it will be necessary to manually change <code>kmain.rs</code> .  Be sure to save any changes from the previous series.  To resolve conflicts, you need to add fixed files with <code>git add</code> and <code>git commit</code> .  Any useful information about resolving merge conflicts and generally about <code>git</code> can be found in the <a href="https://githowto.com/ru/resolving_conflicts">githowto.com</a> guide.  This tutorial and can pass.  Anything will come in handy. </p><br><h3 id="obnovlenie-proshivki">  Firmware upgrade </h3><br><p>  You need to re-download the firmware using the command <code>make fetch</code> from turnip <code>2-fs</code> .  The team will download and unpack everything.  It remains for us to put the files from the <code>files/</code> subdirectory into the root of our MicroSD card.  Namely files <code>firmware/bootcode.bin</code> , <code>firmware/config.txt</code> , <code>firmware/fixup.dat</code> and <code>firmware/start.elf</code> .  Do not forget that if you use the bootloader from the last part as <code>kernel8.img</code> , then you need to add this line to the <code>config.txt</code> : </p><br><pre> <code class="hljs">kernel_address=0x4000000</code> </pre> <br><h3 id="ustanovka-ttywrite">  Ttywrite installation </h3><br><p>  Now the <code>Makefile</code> from <code>os/kernel</code> has an additional <code>install</code> target.  It collects the kernel and sends it directly to the <code>ttywrite</code> using <code>ttywrite</code> from the last part.  Accordingly, if the <code>kernel8.img</code> on the <code>kernel8.img</code> contains a bootloader written in the previous series, this same bootloader will accept and load our file with the kernel.  In order to run this, we need to do a <code>make install</code> in the folder with the kernel code. </p><br><p>  At the same time, this target from the <code>Makefile</code> calls <code>ttywrite</code> directly, simply by name.  Those.  <code>ttywrite</code> must be in one of the places pointed to by the <code>PATH</code> environment variable.  In order to <code>ttywrite</code> in one of these places, we can go into <code>1-shell/ttywrite</code> and perform a <code>cargo install</code> .  Our utility will be collected and copied to the right place.  If everything is correct, then we will be able to call <code>ttywrite --help</code> and it will display help for us. </p><br><p>  By default, <code>make install</code> uses <code>/dev/tty.SLAB_USBtoUART</code> for the device name.  Edit the <code>Makefile</code> so that it points to what you need.  Those.  What is your device for your adapter?  There is a variable named <code>PI_TTY</code> .  So give it another value. </p><br><blockquote>  <strong><code>ALLOCATOR.initialize()</code> causes panic!</strong> <br>  Our shell should have been operational.  However, if you try to test the <code>make install</code> target, you will find that the shell is not working.  Most likely it is a call to <code>ALLOCATOR.initialize()</code> .  There is no memory allocator.  Only a stub, which simply panics when executed without any warning about it.  A little later, we will correct this distressing fact.  For now, you can just comment out this line, so that everything more or less, but it worked. </blockquote><br><h2 id="faza-1-liniya-pamyati">  Phase 1: Memory Line </h2><br><img src="https://habrastorage.org/webt/js/r0/he/jsr0henn2uo_prw8-hyx-5fso20.jpeg"><br><p>  In this phase, we will implement two memory allocators.  The simplest <em>bump-</em> blocker and a slightly more complex <em>bin-</em> blocker.  This is almost all that we need in order to work memory allocation in the heap.  In other words, <code>Vec</code> , <code>Box</code> and <code>String</code> will earn.  In order to determine the amount of available memory, we will use ARM tags ( <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">ATAGS</a> ).  In addition, we need to implement the insides of the <code>panic_fmt</code> function, which is ultimately called when <code>panic!</code> called <code>panic!</code>  . </p><br><h3 id="subfaza-a-panika">  Subphase A: Panic! </h3><br><p>  Let's start with the implementation of <code>panic_fmt</code> .  We will work with the file <code>kernel/src/lang_items.rs</code> . </p><br><h4 id="yazykovye-elementy-language-items">  Language Items </h4><br><p>  When the Rust compiler is configured to compile programs for purposes without an operating system (like our Raspberry Pi), the compiler asks us for a couple of functions.  We need to write them with our own hands.  Such things are called language items.  These elements are functions whose calls the compiler substitutes under certain conditions.  We can define such functions for any elemental language.  To do this, we need to annotate such a function with the <code>#[lang_item]</code> attribute. </p><br><p>  At the moment, Rust requires us only two such functions: </p><br><ul><li> <code>panic_fmt: (fmt: ::std::fmt::Arguments, file: &amp;str, line: u32, col: u32) -&gt; !</code>  which is called when calling <code>panic!</code>  .  Arguments <code>panic!</code>  are passed as the <code>fmt</code> parameter.  In addition, the file name, line number and column of the place where <code>panic!</code> was called is <code>panic!</code>  .  This is appropriate for <code>file</code> , <code>line</code> and <code>col</code> . </li><li>  <code>eh_personality</code> : this function depends on the specific OS and ABI.  It is called during <a href="https://doc.rust-lang.org/beta/nomicon/unwinding.html">stack promotion</a> or after abort, if necessary.  Usually all this happens when <code>panic!</code>  or exit from the stream.  We will not implement this function. </li></ul><br><p>  Both of these functions are already declared in <code>kernel/src/lang_items.rs</code> .  We need to add the function <code>panic_fmt</code> , so that it displays something useful. </p><br><h4 id="realizaciya-panic_fmt">  Implementation <code>panic_fmt</code> </h4><br><p>  Now we will add this function.  Our implementation should output the transmitted information to our console, and then go to an endless loop <code>loop</code> .  By the way.  <code>fmt::Arguments</code> implements the <code>Display</code> treit.  Therefore, we can use <code>kprintln!("{}", fmt)</code> .  Make a conclusion as you personally like it.  For example, you can be inspired by the <a href="https://en.wikipedia.org/wiki/Linux_kernel_oops">panic of the Linux kernel</a> : </p><br><pre> <code class="hljs python"> ( ( ) ) ) ( ( ( ` .-<span class="hljs-string"><span class="hljs-string">""</span></span>^<span class="hljs-string"><span class="hljs-string">"""^""^"""</span></span>^<span class="hljs-string"><span class="hljs-string">""</span></span>-. (//\\//\\//\\//\\//\\//) ~\^^^^^^^^^^^^^^^^^^/~ `================` The pi <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> overdone. ---------- PANIC ---------- FILE: src/kmain.rs LINE: <span class="hljs-number"><span class="hljs-number">40</span></span> COL: <span class="hljs-number"><span class="hljs-number">5</span></span> index out of bounds: the len <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> but the index <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span></code> </pre> <br><p>  Then test the implementation of <code>panic_fmt</code> some kind of kernel panic.  I remind you that you can use <code>make install</code> to compile and then run through the bootloader.  And yes.  <code>ALLOCATOR.initialize()</code> calls <code>panic!</code>  somewhere inside.  So when doing it, you should also see an error message. </p><br><p>  In addition to this, try to cause panic in many ways.  With <code>panic!()</code> , With other similar macros.  And somehow.  When you are sure that your implementation is working perfectly for yourself, go to the next phase. </p><br><h3 id="subfaza-b-atags">  Subphase B: ATAGS </h3><br><p>  In this subphase, we will iterate over the ARM (ATAGS) tags that the Malinka firmware provides.  We will use an iterator to determine the amount of available memory.  The main work will be carried out in the <code>pi/src/atags</code> and in the <code>kernel/src/allocator/mod.rs</code> . </p><br><h4 id="tegi-arm">  ARM tags </h4><br><p>  <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">ATAGS</a> or ARM tags is the mechanism used by the ARM-based bootloader and firmware in order to transfer various information to the kernel of the operating system.  Linux can also be configured to use ATAGS. </p><br><p>  Malinka places an array of ATAG structures starting at address <code>0x100</code> .  In addition, each tag starts with an 8-bit header: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AtagHeader</span></span></span></span> { dwords: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, tag: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, }</code> </pre> <br><p>  The <code>dwords</code> field contains the size of the entire tag, including the title itself.  At the same time the size is in double words (double words, i.e. a 32-bit word).  The minimum size is <code>2</code> (in the size of the header).  The <code>tag</code> field contains the ATAG type.  There are about a dozen of these in the <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">ATAGS help</a> .  Malinka uses only four of them.  They are interesting to us: </p><br><table><thead><tr><th>  Name </th><th>  Type ( <code>tag</code> ) </th><th>  The size </th><th>  Description </th></tr></thead><tbody><tr><td>  <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">CORE</a> </td><td>  0x54410001 </td><td>  5 or 2 (if empty list) </td><td>  Used as a starter </td></tr><tr><td>  <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">None</a> </td><td>  0x00000000 </td><td>  2 </td><td>  Means the end </td></tr><tr><td>  <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">Mem</a> </td><td>  0x54410002 </td><td>  four </td><td>  Describes a piece of physical memory </td></tr><tr><td>  <a href="http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html">CMDLINE</a> </td><td>  0x54410009 </td><td>  different </td><td>  Passing arguments to the kernel </td></tr></tbody></table><br><p>  The tag type determines how we will interpret the data after the header.  Clicking on the links that are tied to the names, you can learn the details.  For example, the <code>MEM</code> tag contains something like the following: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mem</span></span></span></span> { size: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, start: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> }</code> </pre> <br><p>  Tags are stored in memory sequentially without any filling between them.  This list begins with a <code>CORE</code> tag.  And the last tag in this list is <code>NONE</code> .  Everything else can be in any order.  In order to find out where the next tag begins, you need to look at the contents of <code>dwords</code> .  Graphically, it all looks like this: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b65/e61/a48/b65e61a489bd893b23a36f953c0c7078.svg" alt="ATAGS"></p><br><h4 id="obedineniya-union-i-bezopasnost">  Union and Security </h4><br><img title="Someone thinks that all these pictures have a special deep meaning?" src="https://habrastorage.org/webt/nx/ts/h-/nxtsh-wclyrloacfkjxkzkk4nsu.jpeg"><br><p>  The raw structures for ATAG tags are declared in the file <code>pi/src/atags/raw.rs</code>  In this case, <code>union</code> used there.  The associations in Rust are almost identical to the associations in Nyashny Xi.  They define the structure in which some fields have a common memory. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Atag</span></span></span></span> { dwords: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, tag: <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>, kind: Kind } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">union</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kind</span></span></span></span> { core: Core, mem: Mem, cmd: Cmd }</code> </pre> <br><p>  In other words, associations allow storing arbitrary structures into memory without taking into account the correctness of the choice.  It turns out that access to specific fields of association is unsafe in Rust. </p><br><p>  There are already <code>unsafe</code> wrappers in many places.  At least you don‚Äôt need to worry about how to apply to associations yourself.  However, passing associations to library end users is a bad idea.  For this reason, there is another <code>Atag</code> structure in the <code>pi/src/atags/atag.rs</code> .  This structure is completely safe to access.  We will transfer it to the external code.  In the process of adding the <code>atag</code> module <code>atag</code> you will write a transformation between the internal representation and this structure. </p><br><blockquote>  <strong>Why is the transfer of associations to end users a bad idea?</strong>  [enduser-unsafe] <br><br>  We make a lot of efforts to create a secure interface for unsafe structures.  You will see more than once in Rust.  The standard library is also a good example of this.  What is the use of creating a safe interlayer?  Can we transfer a similar approach to languages ‚Äã‚Äãsuch as Nyashny Xi? </blockquote><br><h4 id="argumenty-komandnoy-stroki">  Command line arguments </h4><br><p>  The <code>CMDLINE</code> tag deserves additional attention.  This same tag is declared this way: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cmd</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/// The first byte of the command line string. cmd: u8 }</span></span></code> </pre> <br><p>  According to the comment, the <code>cmd</code> field contains the first byte of the string.  In other words, <code>&amp;cmd</code> is a pointer to a C-like string, which ultimately ends with a zero byte.  The safe version of this tag is <code>Cmd(&amp;'static str)</code> .  When you convert from a <code>raw</code> version to a safe version, you will need to determine the size of this string.  Those.  find a null terminator (character with code <code>0</code> ).  You can then use the address and size to convert it to a slice with <code>slice::from_raw_parts()</code> .  In turn, this slice can be converted to a string using <code>str::from_utf8()</code> or <code>str::from_utf8_unchecked()</code> .  You have already used them in lab 1. </p><br><h4 id="realizaciya-atags">  Implementation of <code>atags</code> </h4><br><p>  Well.  Now we have everything we need to implement the <code>atags</code> module, which lies in <code>pi/src/atags</code> .  Start by implementing <code>raw::Atag::next()</code> from <code>atags/raw.rs</code>  This method determines the address of the next ATAG, after the current one.  There will have to resort to <code>unsafe</code> code.  Then implement helper methods and properties to convert from <code>raw</code> to secure structures, which can be found in <code>atags/atag.rs</code>  When implementing <code>From&lt;&amp;'a raw::Cmd&gt; for Atag</code> will <code>From&lt;&amp;'a raw::Cmd&gt; for Atag</code> to use a little <code>unsafe</code> code.  At the end, implement Atags' <code>Iterator</code> <code>Atags</code> , which can be found in <code>atags/mod.rs</code>  Here, too, a bit of <code>unsafe</code> code may be required. </p><br><blockquote>  <strong>Tips:</strong> <br><br>  You can (at least try!) To implement the <code>Atags::next()</code> method in three lines of code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      You can convert from <code>x: &amp;T</code> to <code>*const u32</code> with <code>x as *const T as *const u32</code> . <br><br>  The inverse transform from <code>x: *const T</code> to <code>&amp;T</code> can be performed using <code>&amp;*x</code> . <br><br>  You can perform arithmetic operations on raw pointers with <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">add ()</a> <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">sub ()</a> or <a href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">offset</a> . </blockquote><br><h4 id="testirovanie-atags">  Testing <code>atags</code> </h4><br><p>  Test your own ATAGS implementation.  Try to get all the values ‚Äã‚Äãthrough an iterator and output the whole thing to the console.  Straight in <code>kernel/src/kmain.rs</code> .  You should see at least one of three tags other than <code>NONE</code> .  In this case, make sure that the implementation of each ATAG meets your expectations.  Once the implementation is completed, go to the next subphase. </p><br><blockquote>  <strong>Tip</strong> : Use `{: #?} For a more beautiful display of structures on the console. </blockquote><br><hr><br><blockquote>  <strong>What do <code>CMDLINE</code> tags contain?</strong>  [atag-cmdline] <br><br>  Is there any value in these tags?  What arguments did the firmware give you?  Where do you think this all came from and how can it be used? </blockquote><br><hr><br><blockquote>  <strong>How much memory is available according to the <code>MEM</code> tag?</strong>  [atag-mem] <br><br>  What is the exact starting address and size of the available memory that is reported in the <code>MEM</code> tag?  How close is all this to 1 gigabyte of memory that Malinka has? </blockquote><br><h3 id="subfaza-c-warming-up-razogrev">  Subphase C: Warming Up (warming up) </h3><br><p>  In this subphase, we will prepare everything necessary for the subsequent writing of two memory allocators.  We implement the <code>align_up</code> and <code>align_down</code> functions that align addresses to powers of two.  In addition, we implement the <code>memory_map</code> function, which returns the starting and ending addresses from system memory.  This function will be used by both allocators to determine how much memory is available for allocation. </p><br><h4 id="vyravnivanie">  Alignment </h4><br><p>  An address in memory is called <em>N-byte-aligned</em> when it is completely divided by <code>N</code>  In other words, for the address <code>k</code> <code>k % n == 0</code> is true.  Usually we do not need to worry about leveling our memory.  However, now we are system programmers.  Our heightened attention to this topic is due to the fact that the hardware, protocols, and all that, prescribe quite certain properties from the point of view of alignment.  For example, for a 32-bit ARM architecture, it is required that the stack pointer be aligned to 8 bytes.  The AArch64 architecture (our case) requires alignment for a stack pointer of 16 bytes.  x86-64 requires about the same.  Memory page addresses must be aligned to 4 kilobytes.  There are many more different examples, but we already see that without this we can not do. </p><br><p>  In Nyashny C, the memory addresses that the allocator returns from libC will be guaranteed to be aligned by 8 bytes on a 32-bit system and 16 bytes on a 64-bit system.  In addition, the caller cannot specifically control the alignment of the returned memory address and must take care of itself.  For this there is, for example, the <code>posix_memalign</code> function from the POSIX standard. </p><br><blockquote>  <strong>Why were such alignment properties chosen for Nyashny S?</strong>  [libc-align] <br><br>  The choice of a guarantee of 8 or 16 bytes for alignment for the malloc function <code>malloc</code> incompetent.  Why were such guarantees guaranteed in the standard C library? </blockquote><p>  In Nyashny C, the declarations <code>malloc()</code> and <code>free()</code> look like this: </p><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">malloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> size)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">free</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pointer)</span></span></span></span>;</code> </pre> <br><p>  In Rust, at a low unsafe level, <code>alloc</code> and <code>dealloc</code> , which look like this: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// `layout.size()` is the requested size, `layout.align()` the requested alignment unsafe fn alloc(&amp;mut self, layout: Layout) -&gt; Result&lt;*mut u8, AllocErr&gt;; // `layout` should be the same as was used for the call that returned `ptr` unsafe fn dealloc(&amp;mut self, ptr: *mut u8, layout: Layout);</span></span></code> </pre> <br><p>  Note that the calling code may indicate alignment.  As a result, the allocator, rather than the calling code, must take care to return the aligned pointer.  When you implement the memory allocators in the following sub-phases, you should make sure that the return address is properly aligned. </p><br><p>  In addition, it is worth canceling that <code>dealloc</code> , unlike <code>free</code> from Nyashny, requires that the caller transfer the <code>Layout</code> exactly the same as for <code>alloc</code> .  Thus, the external code must take care of storing the size and alignment for a particular allocated memory. </p><br><blockquote>  <strong>Why do you think Rust divides the responsibilities between the allocator and the calling code in this way?</strong>  [onus] <br><br>  In Nyashny, the allocator has fewer restrictions on the alignment of memory addresses that it can return.  But at the same time, he himself must keep the size of the allocated space.  Rust is exactly the opposite.  Why do you think Rust chose the opposite path?  What advantages does this provide for the allocator and for the calling code? </blockquote><br><h4 id="poleznosti-align_up-i-align_down">  <code>align_up</code> : <code>align_up</code> and <code>align_down</code> </h4><br><p>  When you implement allocators in the following sub-phases, it will be useful for you to determine the next or previous aligned address.  Those.  for the address <code>u</code> following is <code>&gt;=</code> or <code>&lt;=</code> <code>u</code> , which will be aligned in powers of two.  There already is (unrealized, of course) <code>align_up</code> and <code>align_down</code> .  You can find them in the file <code>kernel/src/allocator/util.rs</code>  They are announced something like this: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Align `addr` downwards to the nearest multiple of `align`. /// Panics if `align` is not a power of 2. fn align_down(addr: usize, align: usize) -&gt; usize; /// Align `addr` upwards to the nearest multiple of `align`. /// Panics if `align` is not a power of 2. fn align_up(addr: usize, align: usize) -&gt; usize;</span></span></code> </pre> <br><p>  Release these features right now.  You can verify the correctness of this process by calling <code>make test</code> or <code>cargo test</code> from the <code>kernel</code> directory.  The tests themselves can be found in the file <code>kernel/src/allocator/tests.rs</code> .  If everything is correct in this part, then all the tests from <code>align_util</code> must pass. </p><br><blockquote>  <strong>Attention</strong> : in the process of testing <code>kprint{ln}!</code>  turn into <code>print{ln}!</code> calls <code>print{ln}!</code>  so everything should work. <br><br>  Tips: <br><br>  The implementation will take one or two lines. <br><br>  The <code>align_up</code> and <code>align_down</code> will be very similar to each other. </blockquote><br><h4 id="potokobezopasnost">  Thread safety </h4><br><p>  Memory allocators like <code>malloc()</code> from libC and our two, which we will implement, are <em>global</em> .  Those.  they can be called anywhere and anytime.  Including in any stream.  Thus, allocators must be thread-safe.  Rust is very serious about thread safety.  For this reason, it is difficult to implement an allocator, which will not be such, even if our system still does not have a mechanism for servicing parallelism (for example, threads). </p><br><p>  The topic of thread safe memory allocators is quite extensive.  On this topic, you can find a lot of research.  At the moment, this topic, we will not touch.  Just wrap our Mutex memory <code>Mutex</code> .  This wrapper is already in <code>kernel/src/allocator/mod.rs</code>  Read all this code now.  Please note that there is an implementation of <a href="https://doc.rust-lang.org/nightly/alloc/allocator/trait.Alloc.html">Alloc treit</a> .  It is precisely because of this that Rust will know that this is quite a valid allocator.  The implementation of this trait is required for such things as <code>#[global_allocator]</code> (in <code>kmain.rs</code> ).  <code>#[global_allocator]</code> ‚Äî ,      ,   Rust-      <code>Vec</code> , <code>String</code>   <code>Box</code> .  Those.   <code>alloc()</code>  <code>dealloc()</code> ,   . </p><br><h4 id="pereklyuchenie-mezhdu-realizaciyami-allokatorov">     </h4><br><p>  <code>Alloc</code>  <code>Allocator</code>  <code>kernel/src/allocator/mod.rs</code>      <code>imp::Allocator</code>  ,     <code>mutex</code> .    <code>imp</code> <em></em> .           .       <code>#[path = "bump.rs"]</code>  ,   Rust-,      .             <code>#[path]</code> .     bump-   <code>bump.rs</code> .     bin-   <code>bin.rs</code> . </p><br><h4 id="poleznosti-memory_map"> : <code>memory_map</code> </h4><br><p>     <code>kernel/src/allocator/mod.rs</code> ‚Äî   <code>memory_map</code> .     <code>Allocator::initialize()</code> ,      <code>kmain()</code> .   <code>initialize()</code>    <code>imp::Allocator</code>      . </p><br><p>  <code>memory_map</code>      <em></em>   .  ,  <em></em>   <em> </em>      .  Those.     ,  ATAGS.            ,    .       <code>binary_end</code> .     ,   <code>_end</code> (  <code>layout.ld</code> ). </p><br><p>  <code>memory_map</code> ,  <code>Atags</code>   B   <code>binary_end</code> . ,      .     -  <code>String::from("Hi!")</code> .           . ,      <code>panic!()</code>  bump-.  <code>memory_map</code>  ,         bump- ‚Äî     .   ,      . </p><br><h3 id="subfaza-d-bump-allokator">  D: Bump- </h3><br><img src="https://habrastorage.org/webt/pt/te/xq/pttexqgl51uoeokoyprtr9_pco4.jpeg"><br><p>         . Bump-.      <code>kernel/src/allocator/bump.rs</code> . </p><br><p> Bump-   .  <code>alloc</code>   <code>current</code>  .      .      <code>current</code>    (    ).   ,   .  <code>dealloc</code>   . </p><br><p>    ,  ,    ,   1  ,    512 .  ,        . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fae/d4a/e09/faed4ae0995c8a0cc40ba36eb44ad92d.svg" alt="BUMP"></p><br><p>    ,      <code>kernel/src/allocator/bump.rs</code> .  Those.  <code>new()</code> , <code>alloc()</code>  <code>dealloc()</code>  <code>bump::Allocator</code> .  <code>align_up</code>  <code>align_down</code>  ,     .    -.      <code>make test</code>  <code>cargo test</code>   <code>kernel</code> .        <code>allocator::bump_*</code> . </p><br><blockquote> <strong></strong> . ,       ,    ! <br><br>   <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">saturating_add</a>  <a href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">saturating_sub</a>   . </blockquote><p>    -  ,       <code>kmain()</code> .    : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> v = <span class="hljs-built_in"><span class="hljs-built_in">vec!</span></span>[]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">1000</span></span> { v.push(i); kprintln!(<span class="hljs-string"><span class="hljs-string">"{:?}"</span></span>, v); }</code> </pre> <br><p>      ‚Äî    . </p><br><blockquote> <strong>    <code>alloc</code> ?</strong> [bump-chain] <br><br>        <code>bump::Allocator::alloc()</code> .        ?  :  ,   <code>v.push(i)</code>    <code>bump::Allocator::alloc()</code> . </blockquote><br><h3 id="subfaza-e-bin-allokator">  E: Bin- </h3><br><img title="        " src="https://habrastorage.org/webt/vy/6s/ww/vy6swwf8mtuca8ar902zm-n71-g.gif"><br><p>         : bin-.     <code>kernel/src/allocator/bin.rs</code> . </p><br><p> Bin-    ,    .     (   )          ,   .        .        ‚Äî    .      ,       .        . </p><br><p>        ,     ,   .        <code>k - 2</code>    <code>2^n</code>   <code>n</code> ,    <code>3</code>   <code>k</code> ( <code>2^3</code> , <code>2^4</code> ‚Ä¶ <code>2^k</code> ).       ,  <code>2^3</code> ,    <code>2^3</code> .   <code>2^3</code>  <code>2^4</code>    <code>2^4</code>   : </p><br><ul><li> bin 0 ( <code>2^3</code> )      <code>(0, 2^3]</code> </li><li> bin 1 ( <code>2^4</code> )      <code>(2^3, 2^4]</code> </li><li> bin 2 ( <code>2^5</code> )      <code>(2^4, 2^5]</code> </li><li> bin k ( <code>2^k</code> )      <code>(2^(k - 1), 2^k]</code> </li><li>    ... </li></ul><br><h4 id="svyazannyy-spisok">   </h4><br><p>   <em></em> (intrusive)    .      <code>kernel/src/allocator/linked_list.rs</code> .     <code>kernel/src/allocator/bin.rs</code>    <code>LinkedList</code> ,       . </p><br><blockquote> <strong>     ?</strong> <br><br>      <code>next</code> ( <code>previous</code>  )     .            .          . </blockquote><p>        <code>LinkedList::new()</code> .      <code>push()</code> .   (  ),        <code>pop()</code> .        <code>peek()</code> .    : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> list = LinkedList::new(); <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { list.push(address_1); list.push(address_2); } <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(list.peek(), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(address_2)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(list.pop(), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(address_2)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(list.pop(), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(address_1)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(list.pop(), <span class="hljs-literal"><span class="hljs-literal">None</span></span>);</code> </pre> <br><p>   <code>LinkedList</code>   .     <code>iter()</code> .   .     <code>iter_mut()</code> .   <code>Node</code> ,       .  <code>value()</code>  <code>pop()</code>          . </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> list = LinkedList::new(); <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { list.push(address_1); list.push(address_2); list.push(address_3); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> list.iter_mut() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node.value() == address_2 { node.pop(); } } <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(list.pop(), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(address_3)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(list.pop(), <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(address_1)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(list.pop(), <span class="hljs-literal"><span class="hljs-literal">None</span></span>);</code> </pre> <br><p>   <code>LinkedList</code>  .      ,     <code>push()</code> .        <code>LinkedList</code>       . </p><br><blockquote> <strong>       ?</strong> [ll-alloc] <br><br>     ‚Äî     .    ,         ,    ? </blockquote><br><h4 id="fragmentaciya">  Fragmentation </h4><br><p>  <em></em>     ,   ,      .    ,    <em>  </em>    .        .        ,      .             .             .          . </p><br><p>     : </p><br><ul><li> <strong> </strong> .   ,         (    ).   bin-             . </li><li> <strong> </strong> .  ,   -       .   bin-        ,            .            . </li></ul><br><p>         ,   . </p><br><h4 id="realizaciya">  Implementation </h4><br><p>  bin-   <code>kernel/src/allocator/bin.rs</code> .    ( ,   bin- )    .          .           .  -    .      <code>make test</code>  <code>cargo test</code> .     <code>bump.rs</code>  <code>bin.rs</code>   <code>#[path]</code>   <code>kernel/src/allocator/mod.rs</code> .  Well, that is   bump-,   bin,    . </p><br><p>         bin-    ‚Äî     . </p><br><blockquote> <strong>   ?</strong> [bin-about] <br><br>       .        : <br><ul><li>      ()    ? </li><li>      ? </li><li>            ? </li></ul><br></blockquote><br><hr><br><blockquote> <strong>    ?</strong> [bin-frag] <br><br>            !        ,  ?    (  )      . </blockquote><br><hr><br><img src="https://habrastorage.org/webt/fl/oh/fw/flohfwk8cuzaimelvqlqorkrd9a.jpeg"><br><p> <strong>UPD</strong> : <a href="https://habrahabr.ru/post/353024/">  </a> </p></div><p>Source: <a href="https://habr.com/ru/post/352414/">https://habr.com/ru/post/352414/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352402/index.html">CLOUD At: a new US bill provides access to personal data abroad</a></li>
<li><a href="../352404/index.html">Changing the main stack from .NET to Java</a></li>
<li><a href="../352408/index.html">PHP 5.x - old people here (wrong) place</a></li>
<li><a href="../352410/index.html">QA in mobile game development or how to build a process in an indie company</a></li>
<li><a href="../352412/index.html">Tomorrow is March 31st. Please back up</a></li>
<li><a href="../352416/index.html">How I spent SberSeasons: four stories about different specialties</a></li>
<li><a href="../352418/index.html">Overview of KPI automation software</a></li>
<li><a href="../352420/index.html">New Intel microarchitecture: fast, but not free</a></li>
<li><a href="../352422/index.html">Payloads for testing web applications</a></li>
<li><a href="../352424/index.html">Analysis of the results of the presidential election of 2018. At the federal and regional level</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>