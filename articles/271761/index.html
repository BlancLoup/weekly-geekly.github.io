<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of fast mobile applications on Android. Part one</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In Edison, we often encounter optimization of mobile applications and want to share material that we consider extremely useful if you solve one of two...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of fast mobile applications on Android. Part one</h1><div class="post__text post__text-html js-mediator-article">  In <a href="http://www.edsd.ru/">Edison,</a> we often encounter optimization of mobile applications and want to share material that we consider extremely useful if you solve one of two tasks: a) you want the application to slow down less;  b) want to make a beautiful, soft and smooth interface for the mass user. <br>  We bring to your attention the first part of the translation of the article Udi Cohen, which we used as a tool for teaching young colleagues to optimize for Android. <br><br><img src="https://habrastorage.org/files/5ad/e29/9c0/5ade299c03474986904ddcb40a4553ca.jpg"><br><br>  A few weeks ago, I gave a talk on optimizing Android‚Äôs performance on Droidcon in New York. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I spent a lot of time on the presentation, because I wanted to show real examples of performance problems, and how they can be identified using the available tools.  I had to remove half of the slides, because I did not have enough time to show everything.  In this article I collected everything that I was talking about, as well as examples that I did not have time to show. <br><br>  My basic rules that I follow when working with optimization. <br><br><h4>  <b>My rules</b> </h4><br>  Every time I encounter performance problems or seek solutions to these problems, I follow these rules. <br><br>  <b>Always measure</b> - eye optimization is always a bad idea.  After you look at the same animations several times, it will start to seem to you that they go faster.  Numbers don't lie.  Use the tools we‚Äôll get to soon, and measure a few times how your application works before and after the changes. <br><br>  <b>Use slow devices</b> - if you really want to find all the weak points, slow devices will help you more.  With newer and more powerful devices, you may not be so worried about performance issues, but not all users use the latest and better models. <br><br>  <b>Tradeoffs</b> - performance optimization is built on tradeoffs.  You are optimizing one thing, but at the cost of something else.  In many cases, this other thing may be your time spent searching for and correcting, or the quality of your bitmap images, or the amount of data you need to store in certain structures.  Get ready for such sacrifices. <br><a name="habracut"></a><br><h4>  <b>Systrace</b> </h4><br>  Systrace is one of the greatest tools that you probably don't use.  This is because the developers were not sure what to do with the information received. <br><br>  Systrace makes an overview of the applications that are currently running on the phone.  This tool reminds us that the phone that we hold in our hands is a powerful computer that can perform many operations at one time.  In one of the latest updates of the SDK Tools, this tool has been supplemented with data-based assumptions that help us find the problem.  Let's see what the result of the trace looks like: <br><br>  <i>(pictures are clickable)</i> <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/380/194/493/3801944934f627ae1fae1af004a5ddcb.png" alt="image"></a> <br><br>  You can get the trace result using Android Device Monitor or using the command line.  More information you can find <a href="http://developer.android.com/tools/help/systrace.html">here</a> . <br><br>  In the video, I talked about the components of the report.  Particularly interesting of them are Alerts and Frames, representing to us assumptions generated from the collected data.  Let's take a look at the trace I took and choose one of the warnings above. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b1e/124/10e/b1e12410eb6a6ecc0bc49dc4c59a3839.png" alt="image"></a> <br><br>  The Alert indicates that there was a long call to View # draw ().  We also get descriptions, links to documentation, and even links to videos with discussions on this topic.  Looking below at the Frames line, we see the labels corresponding to each frame drawn, they are colored in green, yellow or red to reflect the performance problems arising in the process of frame rendering.  Let's select one of the frames marked in red. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/afd/1fd/9cb/afd1fd9cb1ae71edc06229324278239d.png" alt="image"></a> <br><br>  Below we will see all relevant notifications for this frame.  In this case, we have 3 messages, we have already seen one of them.  Let's zoom in on this frame and expand the ‚ÄúInflation during ListView recycling‚Äù notification: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/537/1aa/744/5371aa74412b8a73de0dea19730e7173.png" alt="image"></a> <br><br>  We see that in total for this part it took 32ms, because of which the frame drawing lasts longer than 16ms, required to reach 60fps.  Here you can find more detailed information on each constituent element in the ListView for this frame - about 6ms were spent on 5 of them.  Their description will help us understand the problem and even find a solution.  The diagram above shows all the calls, we can enlarge or stretch it to see which parts of the drawing take more time. <br><br>  Another example of slow frame rendering: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/a7f/235/c0a/a7f235c0a6fc5af9f7872c3203335c34.png" alt="image"></a> <br><br>  After selecting a frame, we can press the ‚Äúm‚Äù key to select it and see how long this part takes.  Looking above, we see that it takes 19ms to render the frame.  Having opened the notification for this frame, we see the message ‚ÄúScheduling delay‚Äù. <br><br>  This means that the thread processing this particular frame was not scheduled on the processor for a long time.  Thus, it took more time to finish his work.  After selecting the longest part, more detailed information is displayed. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c1c/1be/ea7/c1c1beea7a9bb149ce7331366adccef9.png" alt="image"></a> <br><br>  <i>Wall duration</i> is the time taken from the start to the end of the item.  It is called ‚ÄúWall duration‚Äù because it‚Äôs like tracking a wall clock from the moment the flow started. <br><br>  <i>CPU duration</i> is the actual time that the processor spent on this part. <br>  There is a big difference between the two dimensions.  While the total work takes 18ms, the CPU spends only 4ms to work with the stream.  This is a bit strange, so it would be nice to see what the processor is doing the remaining time: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/fb7/707/8eb/fb77078eb38b23a41880db8064ef688a.png" alt="image"></a> <br><br>  All 4 cores are very busy. <br><br>  Selecting one of the streams shows us where it appeared, the application is called com.udinic.keepbusyapp.  In this case, another application was the reason that the processor was loaded, not paying some time to your application. <br><br>  While such a scenario is usually temporary, since other applications usually do not steal the processor in the background (... right?), But such threads may come from different processes in your application or even from the main process.  Thus, Systrace is a review tool, but there is a limit to how deep it can look.  To find what takes our CPU time, we will use another tool called Traceview. <br><br><h4>  <b>Traceview</b> </h4><br>  Traceview is a profiling tool that shows how long each running method lasts.  Let's see what the result of the trace looks like: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1ba/076/671/1ba076671b65a2dd2d3d85e409d86a1c.png" alt="image"></a> <br><br>  This tool can be run from Android Device Monitor or from code.  More information is <a href="http://developer.android.com/tools/debugging/debugging-tracing.html">here</a> . <br><br>  Let's look at the following columns. <br><br><ul><li>  <b>Name</b> - the name of the method and the corresponding color on the chart. </li><li>  <b>Inclusive CPU Time</b> - the time it took the processor to process the process and its descendants (i.e. all the methods it called). </li><li>  <b>Exclusive CPU Time</b> - the time it took the processor to process only the method itself. </li><li>  <b>Inclusive / Exclusive Real Time</b> - the time that has passed since the launch of the method to the moment of completion.  Same as "Wall duration" in Systrace. </li><li>  <b>Calls + Recursion</b> - how many times this method has been called, including the number of recursive calls. </li><li>  <b>CPU / Real time per Call</b> - how much on average it took the processor / real time to call this method.  The remaining fields show the cumulative time of all method calls. </li></ul><br>  I opened an app that had scrolling smoothness issues.  I started tracing, flipped through a bit and stopped on one line.  I stumbled upon the getView () method and opened it, and here is what I saw: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6a0/b9c/754/6a0b9c754a1af75e0fe9bee1ed72a073.png" alt="image"></a> <br><br>  This method was called 12 times, the processor spent about 3 ms for each call, but the real time required for each call is 162 ms!  Definitely a problem ... <br><br>  Looking at the calls from this method, we can see how the total time is divided between different methods.  Thread.join () takes about 98% of real time.  This method is used when we want to wait for the end of another process.  One of the other descendants is Thread.start (), which allows me to assume that getView () opens the stream and waits for it to end. <br><br>  But where is the flow? <br><br>  We cannot see what this thread is doing, since getView () itself does not do this work.  To find it, I searched for the Thread.run () method, which is called when a new thread appears.  I followed him until I found the culprit: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/e86/a74/484/e86a7448454efe95e237a25255a485e9.png" alt="image"></a> <br><br>  I found that BgService.doWork () requires about 14 ms per call, and we have about 40 such calls!  There is also a chance that each getView () will call it more than once, and this explains why each getView () call takes so much time.  This method takes the processor for a long time.  Looking at the Exclusive CPU time, we see that it uses 80% of the CPU time! <br><br>  Sorting by Exclusive CPU time is also a good way to find the most loaded methods that can contribute to the performance problems you experience. <br><br>  Tracking critical methods such as getView (), View # onDraw () and others will help us find the reason why our application is slow.  But sometimes there is something that loads our processor, taking away the precious work cycles of the processor, which can be spent on a smoother drawing of our UI.  The garbage collector works occasionally, removing unused objects, and usually has little impact on the application running in the foreground.  If the garbage collector works too often, it can slow down our application, and it is quite possible that we ourselves are to blame for this ... <br><br><h4>  <b>Memory profiling</b> </h4><br>  Android Studio has been improved lately, with more and more tools added to help us find and analyze performance issues.  The Memory tab in the Android window will show us the change in the amount of data in the heap over time.  Here's what it looks like: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d1b/47a/f38/d1b47af38f629ed832a4993a052dc7c5.png" alt="image"></a> <br><br>  Where we see small drops in the graph, the garbage collector collects and deletes unused objects and frees up memory on the heap. <br><br>  There are 2 tools available on the left side of the chart: Heap dump and Allocation Tracker. <br><br><h5>  <b>Heap dump</b> </h5><br>  To investigate what is currently in our heap, we can use the button on the left Heap dump.  This tool will take a snapshot of what is currently on the heap and show it in a special report screen inside Android Studio: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/1ad/c84/5c1/1adc845c10c70398406af93af2847e70.png" alt="image"></a> <br><br>  On the left, we can see a histogram of instances of objects on the heap, grouped by class name.  For each of them, the total number of objects for which memory is allocated, the size of these objects (Schallow size) and the size of objects stored in memory are indicated.  The latter tells us how much memory can be freed if instances of objects are destroyed.  This gives us an important insight into the memory footprint of our application, helping to define large data structures and relationships between objects.  This information can help us build more efficient data structures, remove connections between objects in order to reduce memory consumption and ultimately reduce memory as much as possible. <br><br>  Looking at the histogram, we see that MemoryActivity has 39 instances of objects, which seems strange to activate.  Selecting one of its instances on the right, expand the list of all references of this object in the base tree below. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/527/c9a/d63/527c9ad633e18900205f34a3ce74e921.png" alt="image"></a> <br><br>  One of these is part of an array inside the ListenersManager object.  Looking at other instances of activations, it turns out that all of them are stored in this object.  This explains why an object of this class uses so much memory. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/6bd/01a/a5a/6bd01aa5a3a6d4d1e3f053a92489c6bf.png" alt="image"></a> <br><br>  Such situations are known to be called ‚Äúmemory leaks,‚Äù since the activites were clearly destroyed, but unused memory cannot be cleared by the garbage collector due to this link.  We can avoid such situations if we are sure that our objects do not refer to other objects that have survived.  In this case, the ListenersManager does not need to save this link after the activation has been destroyed.  The solution is to remove the link before the class instance is destroyed in the onDestory () method. <br><br>  The memory leaks of other large objects take up a lot of space on the heap, reducing the amount of available memory and causing frequent calls to the garbage collector in an attempt to free up more space.  These calls will be occupied by the processor, causing the performance degradation of your application.  If the amount of available memory is not enough for the application, and the heap size cannot be slightly increased, a more dramatic outcome will occur - OutOfMemoryException, which will cause the application to crash. <br><br>  A more advanced tool is the Eclipse Memory Analyzer Tool (Eclipse MAT): <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/52d/d1b/165/52dd1b165532ef317b0e4e5635f74e3c.png" alt="image"></a> <br><br>  This tool can do the same thing as Android Studio, in addition it can detect possible memory leaks and provide a more advanced search for objects, such as the search for all Bitmap sizes larger than 2 MB or all <a href="http://kohlerm.blogspot.com/2009/04/analyzing-memory-usage-off-your-android.html">empty Rect objects</a> . <br><br>  Another great tool is the <a href="https://corner.squareup.com/2015/05/leak-canary.html">LeakCanary</a> library, which keeps <a href="https://corner.squareup.com/2015/05/leak-canary.html">track of</a> all your objects and makes sure that there is no memory leak due to them.  If this happens, you will receive a notification to know where and what happened. <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/d3b/0a3/bbb/d3b0a3bbbffc152f56adf9e5e3782a46.png" alt="image"></a> <br><br><h5>  <b>Allocation tracker</b> </h5><br>  Allocation Tracker can be opened / closed using the button to the left of the memory graph.  He will compile a report on all instances of the class allocated in memory for this period of time, grouped into classes: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/b27/3ca/863/b273ca8637751c26cc93b4cf9c4d2f3c.png" alt="image"></a> <br><br>  or by methods: <br><br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/39b/5d0/5b5/39b5d05b562d252207994ada07e24f4b.png" alt="image"></a> <br><br>  There is also a good visualization, showing us the largest specimens. <br><br>  Using this information, we can find methods that take up too much memory and can spawn many calls to the garbage collector.  We can also find many examples of objects of the same class with a short life cycle, in which we can use the <a href="https://en.wikipedia.org/wiki/Object_pool_pattern">Object Pool</a> to reduce memory allocation. <br><br>  Continued in the <a href="http://habrahabr.ru/company/edison/blog/271811/">second part</a> . <br><br>  <b>PS</b> <br>  The report was recorded on video and you can watch it here: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/v3DlGOQAIbw%3Ffeature%3Doembed&amp;xid=17259,15700019,15700186,15700191,15700248,15700253&amp;usg=ALkJrhizwnPLiN5Z4wvS6HgJNX7tY3Lu5g" frameborder="0" allowfullscreen=""></iframe><br><br>  <a href="https://speakerdeck.com/player/596740dd42254419935aa604d098f2d3">Slides</a> are also available. </div><p>Source: <a href="https://habr.com/ru/post/271761/">https://habr.com/ru/post/271761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271749/index.html">DotNext - Conference on .NET-technologies, Moscow, December 11</a></li>
<li><a href="../271751/index.html">Deploy Drupal 8 with Docker</a></li>
<li><a href="../271755/index.html">MultiSim: technological SIM-phony for several operators and one subscriber</a></li>
<li><a href="../271757/index.html">Comparative analysis of shopping carts</a></li>
<li><a href="../271759/index.html">Creating The Blacksmith: Staging, Shading and Lighting</a></li>
<li><a href="../271763/index.html">Give us a flash revolution! How to quickly and safely go to flash drives</a></li>
<li><a href="../271765/index.html">AngularJs, a short tutorial on creating PhoneCat Application</a></li>
<li><a href="../271767/index.html">Computational intelligence in creating procedurally-generated content for video games</a></li>
<li><a href="../271769/index.html">WifiOTP: Convenient two-factor authentication using Wi-Fi SSID</a></li>
<li><a href="../271771/index.html">Automatic summarization system for three languages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>