<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unit tests. The first step to quality</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once I was asked to talk about unit testing in javascript, but before talking about testing in the front-end world, I had to do a little review of uni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unit tests. The first step to quality</h1><div class="post__text post__text-html js-mediator-article">  Once I was asked to talk about unit testing in javascript, but before talking about testing in the front-end world, I had to do a little review of unit testing as such.  As a result, this article came into being, in which I tried to talk about the most important points in unit testing. <br><br><img src="https://habrastorage.org/web/c0e/bc5/910/c0ebc5910e3c4298964d700014803880.png"><br><a name="habracut"></a><br>  Despite the different interpretations of unit testing, there are several things that unite this term. <br><br>  But there are moments in the definition of unit testing, which are still controversial.  In particular, what is considered a unit (unit of testing)?  The OOP approach considers a class as a unit, a procedural (or functional) approach, treats one function as a unit.  Some developers take several classes and consider it a unit, or take a set of methods as a unit.  But in reality this is a situational thing, the team decides for itself what should be the unit of testing in their system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The advantages of unit testing are obvious: <br><br><ul><li>  They are low-level and focuses on a small piece of software. </li><li>  Tests are written by the developers themselves. </li><li>  Tests are performed very quickly, you can run tests several times a minute. </li><li>  When developing, you can perform not all tests, but only those that are necessary for you </li></ul><br>  Thus, when using unit testing, the development speed is not significantly reduced, but the quality of the product itself increases. <br><br>  The important difference in unit testing is what type of testing you choose: Solitary (lonely) and Sociable (sociable) test.  The terms were first introduced by Jay Fields. <br>  A sociable (outgoing) test is a test that uses real methods (or classes) that are included in the unit under test.  For example, you are testing the ‚Äúprice‚Äù method from an order class.  The price method needs to call methods from the client and product class.  In this type of test, these methods will be called, and an error in these methods will lead to a test error.  Methods from the client and product classes are called collaborators. <br><img src="https://habrastorage.org/web/95d/acb/ab6/95dacbab67e84f5288521b91a55d892c.png"><br>  A solitary test is a test that uses duplicates ( <a href="https://martinfowler.com/bliki/TestDouble.html">TestDouble</a> ) as partners.  Test duplicates are a generic term for any case in which you replace a real object, solely for testing purposes. <br><img src="https://habrastorage.org/web/bde/9d8/010/bde9d8010689404d9559023a411cd1a5.png"><br>  Gerard Meszaros (Gerard Meszaros) made a good classification of doubles. You can read more about this <a href="http://xunitpatterns.com/Test%2520Double.html">here.</a> <br><br>  Each of these testing methods has its advantages and disadvantages, and there are heated debates between supporters of these two methods.  Supporters of Solitary (lonely) tests are also conventionally called Mock-ists (Mock is fake), and supporters of Sociable (sociable) tests are conventionally called Classicists ( <i>could not find analogues in Russian</i> ).  It should be noted that supporters of Sociable (outgoing) testing also use double tests to access external resources, for example, to the database.  In part, this is done because of the access speed.  But using duplicates to access external resources is not an absolute rule, if access to them is stable and fast enough, then you can do without duplicates.  In any case, the developer himself decides when it is better for him to use doubles. <br><br>  One of the advantages of the Solitary testing technique (lonely) is that developers focus on the behavior of the application, and not on the state.  The disadvantage is that the fakes can mask the error that is present in the partner method.  Therefore, when using test duplicates, it is necessary to perform integration testing.  The advantage of Sociable testing is that this is essentially the initial integration testing, but the disadvantage is that if one method falls, it will lead to a drop in all tests related to this method, which makes debugging difficult. <br><br>  I will not dwell on the advantages and disadvantages of this or that approach in testing, you can read about it in Fowler in the article <a href="https://martinfowler.com/articles/mocksArentStubs.html">Mocks Aren't Stubs</a> <br><br>  The basic properties of unit testing are a small amount made by the programmer himself, and speed ‚Äî which means that they can be performed frequently during programming. <br><br>  Developers can execute them after any change in the code.  But it is not necessary to always run all the tests, it is enough to run only those tests that interact with the code you are currently working on. <br><br>  In the late 1990s, Kent Beck developed the Test-Driven Development (TDD) technique as part of extreme programming.  This technique for building software that manages the development process through writing tests.  In essence, repeats three simple rules: <br><br><ul><li>  First a test is written. </li><li>  Then the code is written for this test. </li><li>  Refactoring new and old code to improve code quality </li></ul><br>  The process begins anew until you get the desired result. <br><img src="https://habrastorage.org/web/ba6/dfa/f99/ba6dfaf99d4c4c67921d3f13c95ca915.png"><br><br>  Writing a test first gives you two advantages: <br><br>  1. This is a way to get self-testing code. <br>  2. Thinking first about the test, you force yourself to think about the interface of the code itself.  This focus on the interface and how you use the class helps you separate the interface from the implementation. <br><br>  The biggest mistake when using this methodology is the neglect of the third step, refactoring.  This causes the code to be ‚Äúdirty‚Äù (but at least there will be tests). <br><br>  BDD (Behavior Driven Development) or behavior-based development, appeared in the process of unit-testing evolution and was developed by Dan North (Dan North) in 2006.  According to the author himself, the methodology should help people learn TDD.  It came from an agile practice and is designed to make them more accessible and effective for newcomer teams in Agile. <br>  Over time, BDD began to embrace a wider picture of agile analysis and automated acceptance testing. <br><br>  This led to the fact that the tests themselves began to rename the behavior (specifications), which allowed focusing on what the object needs to do.  Thus, developers began to create documentation for themselves and write down the names of tests in the form of sentences.  They found that the created documentation became available to business, developers and testers. <br><br>  Behavioral development is considered to be one of the branches of the Mock-style (or Solitary-test), i.e.  Tests are mainly built using duplicates. <br><br>  Later, the writing style of the Given-When-Then tests, or, as it came to be called, the specification of system behavior, appeared.  The style was developed by Dan North (Dan North), together with Chris Mattis (Chris Matts).  The idea is to break test case writing into three sections: <br><br><ol><li>  <i>Given</i> (Given) - state, before you begin to describe the behavior.  can be considered as a prerequisite test. </li><li>  <i>When</i> (When) - the behavior that you describe. </li><li>  <i>Then</i> (Then) - the changes you expect from the behavior </li></ol><br>  Example: <br><br>  <i>Description: The user sells the stock.</i> <i><br></i>  <i>Scenario: User asks for sale before closing</i> <i><br></i>  <i><i>Given</i> (Given): I have 100 MSFT shares and 150 APPL shares and the time until the close of the auction.</i> <i><br></i>  <i><i>When</i> (When): I ask to sell 20 shares of MSFT</i> <i><br></i>  <i><i>Then</i> (Then): I must have 80 MSFT shares and 150 APPL shares, and the application for the sale of 20 shares must be completed.</i> <br><br>  Despite the fact that since the advent of TDD and BDD methodologies, a lot of time has passed, many developers still argue with each other about the feasibility of their use.  Someone argues that there is no need to write tests before the code, others say that writing tests after the code is meaningless.  But both sides agree on one thing: tests should be written!  Methodology of BDD from the point of view of programmers, as its author claims ( <a href="https://dannorth.net/2012/05/31/bdd-is-like-tdd-if/">BDD IS LIKE TDD IF ...</a> ), does not differ from TDD.  It uses all the same rules as in TDD: test, code, refactoring.  The difference is that BDD covers a wider audience.  Specifications are available not only to programmers, but also to people who do not understand the code, but are related to software development.  Thus, the whole team is involved in the process of creating tests: analysts, testers, managers. <br><br>  One obvious advantage of unit tests is that they can drastically reduce the number of errors that get into the product.  At the core of this is a <b>culture</b> , as a result of which developers think about writing code and tests together. <br><br>  But the biggest advantage is not just to avoid errors in the product, but to make sure that you can make changes to the system.  Old code is often a terrible picture where developers are afraid to change it.  Even fixing one mistake can be dangerous, because  You can create more bugs than correct.  In such cases, adding new features is very slow, you are also afraid of refactoring the system, thereby increasing technical debt ( <a href="https://martinfowler.com/bliki/TechnicalDebt.html">TechnicalDebt</a> ) and you find yourself in a bad spiral, where every change causes people to fear even greater change. <br>  With tests another picture.  Here, people are sure that fixing errors can be done safely, because if you make a mistake, the error detector will work, and you can quickly recover and continue.  With this security system, you can always keep the code in good shape and no longer find yourself in a bad spiral. <br><br>  The error detector (self-testing system) is the process of executing a series of automatic tests (not just a unit), and you are sure that the tests will pass and your code does not contain significant defects.  If someone on the team accidentally makes a mistake, the detector will trigger.  By performing tests often, several times a day, you can detect errors immediately after they appear, so you can just look at the latest changes, which makes it much easier to find errors.  No program episode is completed without a working code, and tests that support its work. <br><img src="https://habrastorage.org/web/843/6f6/4c6/8436f64c63b942c7ac208144af07a7b7.png"><br>  The system under test is part of <a href="https://martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a> (Continuous Integration) and Continuous Delivery (Continuous Delivery), but this topic is already beyond the scope of this article. <br><br>  One of the important actions of a team that practices various tests is a reaction to a product error.  The usual reaction of the team is to <b>first write a test to expose the error</b> , and only then try to correct it.  Often the writing of this test will be a series of tests that gradually narrows the scope until you reach a unit test that emulates an error.  This technique ensures that after correcting the error, it will remain fixed.  The position should be that any mistake is not just a failure in the code, it is also a failure in the protection of testing. <br><br>  Not only unit tests, but also integration tests, and other automatic tests act as a detector of errors or automatic tests.  But unit tests here play the basis, because  writing them is easy and they are very fast. <br><br>  High-level tests are the second line of defense.  If you get an error in high-level testing, it is not just an error in the code, <b>it is a missing or incorrect unit test!</b> <br><br>  List of sources: <br><br><ol><li>  Martin Fowler <a href="https://martinfowler.com/bliki/UnitTest.html">UnitTest</a> </li><li>  Martin Fowler <a href="https://martinfowler.com/bliki/TestPyramid.html">TestPyramid</a> </li><li>  Martin Fowler <a href="https://martinfowler.com/bliki/SelfTestingCode.html">SelfTestingCode</a> </li><li>  Martin Fowler <a href="https://martinfowler.com/bliki/TestDrivenDevelopment.html">TestDrivenDevelopment</a> </li><li>  James Shore <a href="http://www.jamesshore.com/Agile-Book/test_driven_development.html">The Art of Agile Development: Test-Driven Development</a> </li><li>  <a href="https://habrahabr.ru/post/216923/">Introduction to Behavior Programming (BDD)</a> </li><li>  Martin Fowler <a href="https://martinfowler.com/bliki/GivenWhenThen.html">GivenWhenThen</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/336030/">https://habr.com/ru/post/336030/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../336020/index.html">30+ tools for professional development of Android applications</a></li>
<li><a href="../336022/index.html">Say no to solidity: how we made the CPA platform</a></li>
<li><a href="../336024/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ276 (August 14 - 20, 2017)</a></li>
<li><a href="../336026/index.html">On the quality of requirements in IT projects, to be honest (from the standpoint of the development team). Part 3</a></li>
<li><a href="../336028/index.html">Parsing: can hackers actually hack the stock exchange</a></li>
<li><a href="../336034/index.html">Retrofit on Android with Kotlin</a></li>
<li><a href="../336036/index.html">Six myths about the blockchain and Bitcoin, or Why it is not such an effective technology</a></li>
<li><a href="../336038/index.html">We could not resist and also made an SDK for messengers: Web, Android and iOS</a></li>
<li><a href="../336040/index.html">Southbridge: we develop the useful and remove the unnecessary</a></li>
<li><a href="../336042/index.html">About the availability of Samsung Gear s 3 smart watches for visually impaired users</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>