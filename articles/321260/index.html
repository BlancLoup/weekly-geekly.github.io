<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Procedural level generation for MERC in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Part one 
 Procedural level generation is a great way to add more content and unexpected scenarios to the game. For the MERC story missions, we wanted...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Procedural level generation for MERC in Unity</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/2dd/a38/c62/2dda38c62a103ab1d8c9507a08fb17b8.png" alt="image"><br><br><h2>  Part one </h2><br>  Procedural level generation is a great way to add more content and unexpected scenarios to the game.  For the MERC story missions, we wanted to create a large set of hand-made levels, but realized that our small indie team didn‚Äôt have enough time or resources to produce content for such a big game.  In addition, we sought to add randomness and increase the replay value of the game.  Procedural level generation allowed us to create a large, infinitely changeable world that we could not get by building individual levels manually.  Using procedural generation allows you to add more content and improve the gameplay. <br><br>  What is <a href="http://store.steampowered.com/app/555010/">MERC</a> ?  MERC is a squad tactical simulator in real time with a top view.  The player simultaneously controls a squad of four mercenaries in the dystopian world of Neotopia, gives orders and activates special skills.  Each mercenary unit has its own special combat, technical and hacking skills that must be used in missions.  Visually, MERC is reminiscent of the Blade Runner style: dark rainy slums and rooftops of the city with many winding streets and neon lighting.  The plot is the war of powerful corporations for control of Neotopy.  The detachment is hired to perform various tasks of corporations, such as the abduction of competitors' scientists or the killing of deserters.  Each mission received affects relationships with different corporations and as a result changes the game world.  Given all this, let's consider the requirements for procedural level generation. <br><a name="habracut"></a><br><img src="https://habrastorage.org/getpro/habr/post_images/e0e/b7d/f26/e0eb7df2633689e4a325307d2578b707.png" alt="image">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Level Requirements </h2><br>  Levels are a maze of urban slums and rooftops, but in order for them to be fun to play, they must have a special structure.  To create large levels of missions, we decided to collect them from small fragments.  Thanks to this, we could manually make interesting and ‚Äúreusable‚Äù fragments, add procedural randomness and give each level a hand-made feeling.  To do this, we have determined that the procedural level must: <br><br><ul><li>  contain one main route </li><li>  contain 1-3 dead-end paths for mining purposes </li><li>  contain 1-3 short cuts used as alternative routes </li><li>  generate random objects of design and shelters in each level fragment </li><li>  generate enemies based on ‚Äútempo graphics‚Äù </li><li>  generate different types and levels of enemies based on mission complexity </li><li>  work with the NavMesh Unity system </li><li>  be deterministic and generate exactly the same levels for playing together over a network </li></ul><br>  These requirements are tailored to our gameplay, the world and the planned duration of the missions.  Other games will have their own system requirements for procedural levels.  We wanted the mission to take place in just ten minutes and two times slower with a careful study of the level.  This meant that a small parameter in path lengths became an important parameter. <br><br>  The most difficult was to comply with all the conditions, while creating holistic and interesting levels.  How did we manage to achieve this?  If you imagine the finished level with its structure, caches, pace and mission objectives, it is difficult to understand how to create all this procedurally.  I decided that it would be easier to break the level into layers.  It is necessary to perceive the procedural level as created in several passes, each of which adds a new layer of complexity to the level.  It is logical that you can start the process from a basic level.  In our case, this is the structure (route) level. <br><br><h2>  Level route generation </h2><br>  The first problem of the procedural level system is to generate an interesting main route containing dead ends and short paths.  We found a solution in the Zach Aikman report from Unite 2014 on the generation of Galak-Z game levels by 17-BIT studio (the full report can be viewed <a href="https://www.youtube.com/watch%3Fv%3DySTpjT6JYFU">here</a> ). <br><br>  Zack's report is very interesting, and I advise you to look at it.  I'll tell you about it briefly: to generate the main 2D route, we used the modified Hilbert curve algorithm.  It creates an interesting and unique winding route, ideally suited as a basis for our levels.  The developers of Galak-Z used it for the route in a two-dimensional side view, we used it to create a two-dimensional view from above.  Imagine that the illustration below shows the street map of our game in a top view. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/809/e58/583/809e58583a953a3337db664204b43d83.png" alt="image"><br>  <i>(illustration from the report on Galak-Z)</i> <br><br>  After generating the main route, you need to evaluate all possible map cells to create short paths, and randomly select a part of them.  A short path does not allow reducing movement throughout the map, but simply cuts off part of the main route, for example, in order to avoid some enemies.  We added restrictions to the code so that short paths are not too long and frequent.  When adding these short cuts to fragments of levels, we often blocked them with doors that could be ‚Äúhacked‚Äù or other obstacles that required some kind of player action.  This adds more variation to the main level route and provides another way to test player skills. <br><br><img src="https://habrastorage.org/files/09d/dc2/b63/09ddc2b63b2b45e98a822d1d18af6c01.png"><br><br>  Then we randomly add side paths with dead ends in places where there are no map cells.  They create alternative paths that interrupt gameplay, and are ideal for locating loot, hidden caches, and special mission objectives, such as finding and eliminating a character.  Depending on the goals of the mission, we randomly generate from one to three dead-end paths for each level.  All mission specific objectives are located at the end of the dead ends. <br><br><img src="https://habrastorage.org/files/9bb/f22/257/9bbf22257ad840e1b4fc255fc31caddf.png"><br><br>  The idea is that the detachment arrives on a transport vessel in the starting cell of the map, from which the main route begins.  Then the player, managing the mercenaries, leads them through the level and fulfills the goals, reaches the end of the main route and is evacuated.  At each level, you must fulfill the mission objectives.  The objectives of the mission are located outside the main route, which forces the player to explore the level.  Other dead ends are not necessary to explore, they are caches and additional mining.  This gives the player a choice: break through the level and quickly go through a mission, or spend more time on research. <br><br>  After completing the generation of the complete route with short paths and dead ends, we will convert it into a list of loaded level fragments.  Each level fragment is a Unity scene, so we gave each scene a name after the template that defines its configuration.  After generating the level, we transform each cell of the map into a scene name corresponding to a pattern.  The template contains the theme of the fragment, the connection and the notation for variation.  For example, using the pattern <i>&lt;theme&gt; _ &lt;junction of the main route&gt; _ &lt;junction of the short path&gt; _ &lt;junction of the dead end&gt; ‚Äã‚Äã_ &lt;variation&gt; the</i> level fragment may have the name of the scene <i>‚Äúslums_03_-1_-1_A‚Äù</i> . <br><br>  <b>A theme</b> is a visual style of level fragments.  All level fragments of one theme should be seamlessly connected to any other fragment of the same theme.  For example, all fragments of the theme level <i>‚Äúslums‚Äù</i> (slums) should be logically and graphically combined with each other at connection points.  We also created the theme <i>‚Äúrooftops‚Äù</i> , in which, instead of streets connected to each other, roofs of buildings are connected by slopes and floorings.  Usually, all fragments of the same theme are the same size.  Our fragments have an average size of 40x40 units. <br><br>  In accordance with the structure of the Hilbert curves and paths generated by us, each level fragment will have two connections of the <b>main route</b> , zero or one connection of the <b>short path,</b> and zero or one connection of the <b>dead end</b> .  The level fragment never contains both shortcut and deadlock connections, because they are never used.  Each connection corresponds to a face of a level fragment, and each face is marked with a number from zero to three, as shown in the figure below (to mark a non-existent connection, "-1" is used, for example, there is no short path connection in the figure). <br><br><img src="https://habrastorage.org/files/097/8a3/186/0978a31868fd44b38d6524158db1f761.png"><br><br>  For example, a fragment of the level with the designation of the connection of the main route ‚Äú03‚Äù has connections below (0) and to the right (3).  The mark of the connection of the main path is always in order of magnification (i.e., ‚Äú03‚Äù, not ‚Äú30‚Äù).  It is important to remember that when assembling fragments of connection levels it is not necessary to line up absolutely exactly.  By adding irregularities to some compounds, we will increase the variability and reduce the smoothness of the connection of fragments.  However, the connections should still be aligned relative to each other, so that the paths must necessarily join. <br><br>  Variations allow the level designer to create different versions of a single level fragment.  For example, look at two variations ‚ÄúA‚Äù and ‚ÄúB‚Äù of connecting the main route ‚Äú01‚Äù without a short path.  When generating a level, the system randomly selects one of the variations of each level fragment, providing greater visual diversity. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c6b/43c/b8c/c6b43cb8cd0ca177d1402be84a1bd1a7.png" alt="image"><br><br>  When loading each level fragment, we move it to the desired displacement in the world based on its position on the route.  This means that the fragments cannot contain meshes (meshes) marked for static batching in Unity (because the system will break when they are moved).  However, Unity's dynamic batching works fine on the system.  Below are examples of randomly generated level structures (red areas ‚Äî short paths through buildings, blue areas ‚Äî building variations).  This is only a concept check without final clearance. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2dd/a38/c62/2dda38c62a103ab1d8c9507a08fb17b8.png" alt="image"><br><br>  I would be happy to discuss this topic in more detail and will gladly accept any suggestions.  You can contact me on <a href="https://twitter.com/velvetycouch">Twitter</a> . <br><br>  In the <a href="https://habrahabr.ru/post/321602/">second part of the</a> article ‚ÄúProcedural Generation of Levels for MERC in Unity‚Äù, we will discuss the lighting and NavMesh problems we solved, as well as the process of character generation in the mission based on tempo. </div><p>Source: <a href="https://habr.com/ru/post/321260/">https://habr.com/ru/post/321260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321250/index.html">We write the easiest and fastest input type file</a></li>
<li><a href="../321252/index.html">Tarantool: Good, Bad, Angry</a></li>
<li><a href="../321254/index.html">Pass to the ground - how Apple Pay and Samsung Pay were launched in Yandex.Money</a></li>
<li><a href="../321256/index.html">The logic of consciousness. Part 11. Natural coding of visual and sound information</a></li>
<li><a href="../321258/index.html">ReactOS at FOSDEM 2017</a></li>
<li><a href="../321262/index.html">Logging with rsyslog, file names in tags, multi-line messages and fault tolerance</a></li>
<li><a href="../321266/index.html">Standard exchange 1C-Bitrix on BASH: Detailed parsing of the script of incremental unloading</a></li>
<li><a href="../321268/index.html">Let's Encrypt and Express. To each server - on the green lock</a></li>
<li><a href="../321270/index.html">How to evaluate big tasks</a></li>
<li><a href="../321274/index.html">Features of the distributed storage architecture in Dropbox</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>