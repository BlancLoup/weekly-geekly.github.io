<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We build DSL on C # using parser combinators</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article by Nicholas Blumhardt, the well-known .NET developer, author of Autofac IoC / DI container. In this article, Nicholas shows...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We build DSL on C # using parser combinators</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/storage1/94a4c0a7/ec6ad46d/2b7f90d0/dd55d2d2.jpg"><br>  <i>Translation of the article by Nicholas Blumhardt, the well-known .NET developer, author of Autofac IoC / DI container.</i>  <i>In this article, Nicholas shows with a real-life example how to write a parser of a domain-specific programming language with the least effort using Sprache, a parser-combinator library.</i> <i><br></i> <br><br>  Our current project includes a small process for submitting and approving applications for creating user accounts.  This is a good example for discussing domain-specific languages ‚Äã‚Äãand <a href="http://sprache.googlecode.com/">Sprache</a> .  Now I will describe some requirements. <br><br>  The set of user account types is unlimited;  currently it is ‚Äúemployee‚Äù, ‚Äúcontractor‚Äù, ‚Äútemporary employee‚Äù and so on.  To obtain an account, the user must fill out the appropriate form. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When collecting and saving the questionnaire data, its content does not matter unless the relevant information is presented to the administrator, who will eventually approve or reject the application. <br><br><a name="habracut"></a><br>  <a href="">Link to an example in the form of a solution for VS2010.</a> <br><br><h4>  Difficulties </h4><br>  In many ways, the design of the system is due to the fact that the set of possible types of accounts (and, therefore, various questionnaires) is unlimited.  Creating new profiles should be possible without redeploying the application.  In addition, the composition of the questionnaires should be easily changed, perhaps by the end users themselves. <br><br>  There are many possible ways to submit questionnaires: <br><ul><li>  Map the domain model of questionnaires to relational database tables </li><li>  Create an XML-based questionnaire format </li><li>  Use Windows Workflow Foundation with its too general XAML files. </li><li>  Read profiles from CSV files or other tables </li></ul><br>  Each of these methods has its advantages and disadvantages associated with ease of implementation, maintainability, convenience and flexibility. <br><br>  In this article we will consider another attractive option: the creation of a convenient mini-language of the description of the questionnaires. <br><br><h4>  Profile Description Language </h4><br>  You may have read some discussions of the differences between internal and external DSL. <br><br>  <i>Internal</i> DSL is a purpose-built API in a general purpose language (such as C #), which when used reads <a href="http://stateless.googlecode.com/">more like a description of a problem</a> than a program that solves it. <br><br>  <i>External</i> DSL is a separate language that needs to be parsed from the source text before the program can work with it.  Also, which is especially important for our task, external DSL minimizes syntax noise and can be read without recompiling the program. <br><br>  An example of a DSL form looks like this: <br><br><pre><code class="hljs pgsql">identification "Personal Details" [ <span class="hljs-type"><span class="hljs-type">name</span></span> "Full Name" department "Department" ] employment "Current Employer" [ <span class="hljs-type"><span class="hljs-type">name</span></span> "Your Employer" contact "Contact Number" #months "Total Months Employed" ]</code> </pre> <br>  This is a two-step questionnaire that collects personal data and employment details. <br><ul><li>  Each section has its own identifier, name and list of questions. </li><li>  Each question has an identifier and some query text. </li><li>  A question identifier declaration (for example, #months) may have a prefix of a character that indicates the type of data being collected ‚Äî the pound symbol in this case denotes a natural number. </li></ul><br>  The application will read the description of the questionnaire associated with the appropriate type of account, and provide the user with a step-by-step interface. <br><br><h4>  Approaches to the analysis of questionnaire descriptions </h4><br>  Debriefing is the process of adopting text in a source language, such as the questionnaire above and transforming it into some kind of representation, usually into some kind of object model with which the program can work.  For a C # programmer, there are several ways to achieve this goal. <br><br><h5>  Handwritten parsers </h5><br>  Both the simplest and the most complex parsers are often written by hand.  Simple ones are written when the solution is obvious (for example, ‚Äúbreak a string by finding commas in a loop‚Äù).  The most complex parsers are written when the programmer needs an extraordinary level of control (for example, the C # compiler).  Parsing anything intermediate by hand is usually not worth the effort, unless of course you are a professional in this field, knowing exactly what he is doing (this is definitely not about me!) <br><br><h5>  Regular expressions </h5><br>  This is a convenient way to match and extract patterns from text.  .NET includes the built-in <b>System.Text.Regex</b> class for efficiently working with regular expressions, so they are usually the first option to consider when someone is faced with the task of parsing.  Despite the fairly simple grammar, regular expressions quickly become difficult to read and maintain.  This is perhaps their biggest drawback.  In addition, there are many grammars that regular expressions are not able to analyze (starting with those that allow nesting). <br><br><h5>  Parser Generators </h5><br>  Parser generators, ‚Äúlanguage toolkits,‚Äù allow you to specify grammar in a declarative format.  Tulkit includes tools that work during project building, which generate classes in a target language (such as C #) that can parse grammar.  Using such tools takes time to study their work and integrate them into the project building process.  For small parsing tasks this may be unnecessary, but for something much more complex or requiring high parsing speed, learning and using such tools is strongly recommended. <br><br><h5>  Parser Combiners </h5><br>  This feature-based technique is often used by default in functional languages ‚Äã‚Äãsuch as Haskell and F #, both of which have high-quality parser combinator libraries.  C # also has a young <a href="http://sprache.googlecode.com/">Sprache</a> combinator library developed by your humble servant and used later in the article.  Sprache makes it very easy to write and maintain simple parsers without a steep learning curve or embedding into the build process.  It goes well with the development process through testing.  The current drawbacks include performance and, sometimes, the quality of error messages - none of them is a big problem for parsing small DSLs.  [ <i><b>Update:</b> since this article was written, the speed of parsing and error handling in Sprache has been greatly improved.</i>  ] <br><br><h4>  Getting started </h4><br>  To get started, <a href="http://sprache.googlecode.com/">download Sprache.dll</a> .  This article is organized in such a way that you can follow the text, creating and testing parsers in Visual Studio with <a href="http://nunit.org/">NUnit</a> . <br><br>  Grammar are built from the bottom up.  First, parsers are created for low-level syntax elements, such as identifiers, strings, and numbers.  Then we gradually rise above, combining these simple parts into more complex ones, until we get a complete language. <br><br><h4>  Parsing id </h4><br>  In our questionnaire description language, the most nested meaningful element is the question: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> "Full Name"</code> </pre> <br><br>  The main parts here are an identifier and some text in quotes.  The first task for our parser is to parse the identifier, in this case 'name'. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnIdentifierIsASequenceOfCharacters</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = <span class="hljs-string"><span class="hljs-string">"name"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = QuestionnaireGrammar.Identifier.Parse(input); Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, id); }</code> </pre><br>  Sprache parsers are static class methods representing grammars.  <b>QuestionnaireGrammar.Identifier of</b> type <b>Parser &lt;string&gt;</b> , i.e.  it returns <b>string</b> values. <br><br>  Parser definition: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Parser&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; Identifier = Parse.Letter.AtLeastOnce().Text().Token();</code> </pre><br>  This code reads quite well - we are going to analyze a non-empty sequence of letters and return their textual representation.  Here are the elements of the parser: <br><br>  <b>Parse.Letter</b> - in Sparche, the Parse class contains helper methods and properties for performing common parsing tasks.  Letter is a simple parser of type <b>Parser &lt;char&gt;</b> that reads a letter from the input and returns it as a <b>char</b> .  If the input character is not a letter, this parser will not match it. <br><br>  <b>AtLeastOnce ()</b> - all created with Sprache parsers support repetition.  AtLeastOnce () takes a parser of a single element of type <b>T</b> and returns a new parser that will parse the sequence of such elements, returning an <b>IEnumerable &lt;T&gt;</b> . <br><br>  <b>Text ()</b> - the AtLeastOnce () modifier takes our <b>Parser &lt;char&gt;</b> and turns it into a parser of type <b>Parser &lt;IEnumerable &lt;char &gt;&gt;</b> .  The auxiliary function <b>Text ()</b> takes a parser of type <b>Parser &lt;IEnumerable &lt;char &gt;&gt;</b> and converts it to <b>Parser &lt;string&gt;</b> , for more convenient work. <br><br>  <b>Token ()</b> is a modifier that accepts and then discards initial and final whitespace characters. <br><br>  Simply? <br><br>  There are some more interesting tests on the parser id. <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnIdentifierDoesNotIncludeSpace</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = <span class="hljs-string"><span class="hljs-string">"a b"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parsed = QuestionnaireGrammar.Identifier.Parse(input); Assert.AreEqual(‚Äúa‚Äù, parsed); }</code> </pre><br>  Each parser in Sprache will parse as much input as it can.  In this test, parsing will end successfully, but will not absorb the entire input string.  (Later we will see how to require the end of input.) <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AnIdentifierCannotStartWithQuote</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = <span class="hljs-string"><span class="hljs-string">"\"name"</span></span>; Assert.Throws&lt;ParseException&gt;(() =&gt; QuestionnaireGrammar.Identifier.Parse(input)); }</code> </pre><br>  The <b>Parse ()</b> extension method throws a <b>ParseException</b> if the parser does not fit.  You can also use non-throwing exceptions <b>TryParse ()</b> . <br><br>  After we were delighted to correctly parry identifier, we can move on. <br><br><h4>  Parsing text in quotes </h4><br>  Parsing text in quotes is not much more complicated than parsing an identifier - our simple version does not support escaped characters or anything intricate. <br><br>  Look again at the input line: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">name</span></span> "Full Name"</code> </pre><br>  To parse the quoted text, we need to map: <br><ol><li>  Opening quotes </li><li>  Everything except for the other quotes </li><li>  Closing quotes </li></ol><br>  Quotes by themselves are not particularly interesting to us, so we will only return text between them. <br><br>  The test for the parser will look like this: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">QuotedTextReturnsAValueBetweenQuotes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = <span class="hljs-string"><span class="hljs-string">"\"this is text\""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> content = QuestionnaireGrammar.QuotedText.Parse(input); Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">"this is text"</span></span>, content); }</code> </pre><br>  Let's go straight to the analyzer: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Parser&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; QuotedText = (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> open <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.Char(<span class="hljs-string"><span class="hljs-string">'"'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> content <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.CharExcept(<span class="hljs-string"><span class="hljs-string">'"'</span></span>).Many().Text() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> close <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.Char(<span class="hljs-string"><span class="hljs-string">'"'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> content).Token();</code> </pre><br><br>  Such a convenient reuse of LINQ query syntax was first described (to my knowledge) by <a href="http://blogs.msdn.com/lukeh">Luke Hoban</a> from the F # command.  The from operations split individual syntax units, and select transforms them into the return value of the entire parser. <br><br><h4>  Parsim question </h4><br>  You may have already noticed that the parsers are strongly typed: the parser for the character returns <b>char</b> , and the parser for the text returns <b>string</b> .  The parser for the question will return a <b>Question</b> ! <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Question</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Question</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> prompt</span></span></span><span class="hljs-function">)</span></span> { Id = id; Prompt = prompt; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Prompt { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  This is a big advantage of combinator based analysis.  Once the <a href="http://martinfowler.com/dslCatalog/semanticModel.html">semantic</a> task <a href="http://martinfowler.com/dslCatalog/semanticModel.html">model is</a> built, the parser can translate input data directly into it. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Parser&lt;Question&gt; Question = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">from</span></span></span><span class="hljs-function"> id </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> Identifier </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">from</span></span></span><span class="hljs-function"> prompt </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> QuotedText </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">select</span></span></span><span class="hljs-function"> new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Question</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id, prompt</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  The unit test for the question now passes: <br><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AQuestionIsAnIdentifierFollowedByAPrompt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> input = <span class="hljs-string"><span class="hljs-string">"name \"Full Name\""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> question = QuestionnaireGrammar.Parse(input); Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, question.Id); Assert.AreEqual(<span class="hljs-string"><span class="hljs-string">"Full Name"</span></span>, question.Prompt); }</code> </pre><br><h4>  Parsing section </h4><br>  The analysis of the section is the same as the analysis of the question: first we build a semantic model, and then, using existing parsers, we translate the source text into it. <br><br>  Let me remind you that the section looks like this: <br><br><pre> <code class="hljs pgsql">identification "Personal Details" [ <span class="hljs-type"><span class="hljs-type">name</span></span> "Full Name" department "Department" ]</code> </pre><br>  We can present it in the object model as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Section</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Section</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> title, IEnumerable&lt;Question&gt; questions</span></span></span><span class="hljs-function">)</span></span> { Id = id; Title = title; Questions = questions; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Prompt { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;Question&gt; Questions { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Parser development is as simple as developing an object model: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Parser&lt;Section&gt; Section = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> id <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Identifier <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> QuotedText <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> lbracket <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.Char(<span class="hljs-string"><span class="hljs-string">'['</span></span>).Token() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> questions <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Question.Many() <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> rbracket <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Parse.Char(<span class="hljs-string"><span class="hljs-string">']'</span></span>).Token() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">select</span></span></span><span class="hljs-function"> new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Section</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id, title, questions</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  To complete the example, we have another model class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Questionnaire</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Questionnaire</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IEnumerable&lt;Section&gt; sections</span></span></span><span class="hljs-function">)</span></span> { Sections = sections; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;Section&gt; Sections { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  The corresponding parser (this time without syntax parsing): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Parser&lt;Questionnaire&gt; Questionnaire = Section.Many().Select(sections =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Questionnaire(sections)).End();</code> </pre><br><br>  The <b>.End ()</b> modifier requires that all input data be parsed (i.e. no trash is left at the end). <br><br>  That's all we need for an example, without data type qualifiers. <br><br><h4>  Support for response data types </h4><br>  The final touch to our grammar will be support for type qualifiers of the answer. <br><br><pre> <code class="hljs objectivec"><span class="hljs-meta"><span class="hljs-meta">#months </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Total Months Employed"</span></span></span></span></code> </pre><br>  For their presentation, we can use an enumeration of all possible types. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> AnswerType { Natural, Number, Date, YesNo }</code> </pre><br>  This is a rather limited set, so using brute force we will check every possible qualifier. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Parser&lt;AnswerType&gt; AnswerTypeIndicator = Parse.Char(<span class="hljs-string"><span class="hljs-string">'#'</span></span>).Return(AnswerType.Natural) .Or(Parse.Char(<span class="hljs-string"><span class="hljs-string">'$'</span></span>).Return(AnswerType.Number)) .Or(Parse.Char(<span class="hljs-string"><span class="hljs-string">'%'</span></span>).Return(AnswerType.Date)) .Or(Parse.Char(<span class="hljs-string"><span class="hljs-string">'?'</span></span>).Return(AnswerType.YesNo));</code> </pre><br><br>  The <b>Question</b> class is changed to accept <b>AnswerType</b> as a constructor parameter.  A simple modification of the question parser completes our work. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Parser&lt;Question&gt; Question = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> at <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> AnswerTypeIndicator.Or(Parse.Return(AnswerType.Text)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">from</span></span></span><span class="hljs-function"> id </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> Identifier </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">from</span></span></span><span class="hljs-function"> prompt </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">in</span></span></span><span class="hljs-function"> QuotedText </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">select</span></span></span><span class="hljs-function"> new </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Question</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">id, prompt, at</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br><h4>  Summary </h4><br>  The complete parser is just six rules in 25 well-formed lines of code. <br><br>  Although in the real world, reliable parsing is a non-trivial task, I hope this article has shown that there are simple options that fill in the gaps between regular expressions and language tools. </div><p>Source: <a href="https://habr.com/ru/post/127642/">https://habr.com/ru/post/127642/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../127635/index.html">Portrait of noob</a></li>
<li><a href="../127637/index.html">Learning to count in hex, or reverse engineering of an alarm clock</a></li>
<li><a href="../127639/index.html">Using Dummynet to emulate a narrow channel under Windows</a></li>
<li><a href="../127640/index.html">IFA 2011, day 3: Acer Aspire 3951</a></li>
<li><a href="../127641/index.html">Game Prototyping with JavaScript and CSS3</a></li>
<li><a href="../127643/index.html">We get a free SSL certificate</a></li>
<li><a href="../127645/index.html">Android player and Philips wireless acoustics [video]</a></li>
<li><a href="../127646/index.html">Opening of the fall semester 2011 at –°omputer Science club</a></li>
<li><a href="../127650/index.html">Design applications for WP7. Metro approach</a></li>
<li><a href="../127652/index.html">London Philharmonic Orchestra played music from computer games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>