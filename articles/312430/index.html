<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write less code for MR, or why the world needs another query language? History of Yandex Query Language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Historically, many parts of Yandex have developed their own systems for storing and processing large amounts of data, taking into account the specific...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write less code for MR, or why the world needs another query language? History of Yandex Query Language</h1><div class="post__text post__text-html js-mediator-article">  Historically, many parts of Yandex have developed their own systems for storing and processing large amounts of data, taking into account the specifics of specific projects.  With such a development, efficiency, scalability and reliability have always been a priority, therefore, as a rule, there was no time left for convenient interfaces for using such systems.  A year and a half ago, the development of large infrastructure components was separated from product teams into a separate area.  The goals were as follows: start moving faster, reduce duplication among similar systems, and lower the entry threshold for new internal users. <br><br> <a href="https://habrahabr.ru/company/yandex/blog/312430/"><img src="https://habrastorage.org/files/2a9/e86/211/2a9e862113944adcbfee24e09b96af48.jpg"></a> <br><br>  Very soon, we realized that a common high-level query language could help here, which would provide uniform access to existing systems, as well as eliminate the need to re-implement typical abstractions on low-level primitives adopted in these systems.  Thus began the development of Yandex Query Language (YQL) - a universal declarative query language for data storage and processing systems.  (I‚Äôll say right away that we know that this is not the first thing in the world, which is called YQL, but we decided that this does not interfere with business, and left the name.) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      On the eve of our <a href="https://events.yandex.ru/events/meetings/15-oct-2016/%3Futm_source%3Dhabr%26utm_medium%3Darticles%26utm_campaign%3DInfr">meeting</a> , which will be devoted to the Yandex infrastructure, we decided to tell the readers of Habrahabr about YQL. <br><br><a name="habracut"></a><h3>  Architecture </h3><br>  Of course, we could look towards the popular in the world of open source ecosystems - such as Hadoop or Spark.  But they were not even seriously considered.  The fact is that support was required for the data warehouses and computing systems already distributed in Yandex.  Largely because of this, YQL was designed and implemented extensible at any level.  All the levels, we take turns below. <br><br><img src="https://habrastorage.org/files/805/575/253/8055752537bd488785e6f71d23980379.png"><br><br>  In the diagram, user requests are moved from top to bottom, but we will discuss the affected elements in reverse order, from bottom to top, so that the story is more coherent.  First, a few words about currently supported backends or, as we call them, data providers: <br><br><ul><li>  It so happened that in Yandex, for more than five years, <b>two</b> implementations of the MapReduce paradigm, YaMR and YT, have been developed, which you can read more about in a <a href="https://habrahabr.ru/company/yandex/blog/311104/">recent post</a> .  Technically, they have almost nothing to do with each other, nor with Hadoop.  Since the development of systems of this class is quite expensive, a year ago it was decided to hold a ‚ÄúMapReduce-tender‚Äù.  YT won, and now the YaMR users are finishing up on it.  The development of YQL began almost simultaneously with the start of the tender, so one of the main requirements was the support of both YT and YaMR, which needed to be implemented to facilitate the lives of users during the transition period. <br></li><li>  About RTMR (Real Time MapReduce) also once <a href="https://habrahabr.ru/company/yandex/blog/189362/">was a separate post</a> .  His support is now at an early stage of development.  First, this integration project will allow new users to implement RTMR without special training.  Secondly, they will be able to consistently analyze both the fresh data stream and the archive collected over a long period and located in the YT distributed file system. <br></li><li>  In Yandex, data storage systems with an OLTP pattern use even more than those based on the MapReduce paradigm.  KiKiMR was chosen as a pilot project for integration with YQL.  In many ways, this choice was made because the need for a friendly interface KiKiMR was formed at the same time with the active growth of the popularity of YQL.  Another reason was that KiKiMR had resources for this project.  A detailed story about KiKiMR does not fit here, but if in brief, it is a distributed, fault-tolerant strict consistent-data warehouse, including distributed between data centers.  It can be used in installations consisting of several machines and thousands of nodes.  A distinctive feature of KiKiMR is the built-in ability to perform operations efficiently and transactionally with an isolation level of serializable both on individual objects (single-row transactions) and on groups of distributed objects of storage (cross-row / cross-table transactions). <br></li><li>  This list contains only what is already implemented or is under construction.  The plans are to expand the range of systems supported in YQL and beyond.  For example, a very logical development of events will be support for <a href="https://habrahabr.ru/company/yandex/blog/303282/">ClickHouse</a> , which is now somewhat delayed only due to limited resources and the lack of urgent need. </li></ul><br><br><h3>  Core </h3><br>  Technically, YQL, although it consists of relatively isolated components and libraries, is primarily provided to internal users as a service.  This allows, from their point of view, to look like a ‚Äúone-stop service‚Äù and minimize labor costs for organizational issues such as issuing accesses or firewall settings for each of the backends.  In addition, both implementations of the classic MapReduce in Yandex require the presence of a client process synchronously awaiting the completion of a transaction, and the YQL service takes it on itself and allows users to work in the ‚Äúlaunched and <s>forgotten</s> mode came after the results later.  But if you compare the model of service with the distribution in the form of a library, there are also disadvantages.  For example, you should be much more careful about incompatible changes and releases - otherwise you can break user processes at the most inappropriate moment. <br><br>  The main entry point to the YQL service is the HTTP REST API, which is implemented as a Java-based application on <a href="http://netty.io/">Netty</a> and not only runs incoming computation requests, but also has a wide range of supporting duties: <br><ul><li>  Multiple authentication options. </li><li>  View a list of available clusters with backends, as well as lists of tables and charts, navigate through them. </li><li>  The repository of user-saved queries, as well as the history of all launches (historically lives in MongoDB, but this may change in the future). </li><li>  Notifications of completed requests: <br><ul><li>  Next to the REST API, there is a WebSocket endpoint, with which user interfaces (we‚Äôll talk about them a little later) are able to show pop-up messages in real time; </li><li>  Integration with internal services for sending letters, SMS and messages in Jabber; </li><li>  Alerts via bot in Telegram. </li></ul></li></ul><br>  Using Java made it possible to quite quickly implement all this business logic due to the presence of ready-made asynchronous clients for all the necessary systems.  Since there are no too strict requirements on latency, there were few problems with garbage collection, and after switching to <a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/G1.html">G1,</a> they almost disappeared.  In addition to the above, <a href="http://zookeeper.apache.org/">ZooKeeper is</a> used for synchronization between nodes, including the publisher-subscriber pattern when sending notifications. <br><br>  The execution of user requests for computation is orchestrated by separate processes in C ++ called yqlworker.  They can be run either on the same machines as the REST API or remotely.  The fact is that there is a network communication between them using the MessageBus protocol developed and widely used in Yandex.  A copy of yqlworker is created for each request using the fork system call (without exec).  This scheme allows you to achieve sufficient isolation between the requests of different users and at the same time - thanks to the mechanism of <a href="https://en.wikipedia.org/wiki/Copy-on-write">copy-on-write</a> - not to waste time on initialization. <br><br>  As can be seen from the diagram with high-level architecture, Yandex Query Language has two views: <br><ul><li>  The basic syntax is based on SQL and is intended for people to write. </li><li>  The s-expressions syntax, in turn, is more convenient for code generation. </li></ul><br>  From the query, regardless of the selected syntax, a calculation graph (Expression Graph) is created, which logically describes the necessary data processing using primitives that are popular in functional programming.  Such primitives include: Œª-functions, mapping (Map and FlatMap), filtering (Filter), folding (Fold), sorting (Sort), applying (Apply) and many others.  For SQL syntax, the lexer and parser based on <a href="http://www.antlr3.org/">ANTLR v3</a> build the Abstract Syntax Tree, which is then used to build the calculation graph.  For the s-expression syntax, the parser is almost trivial, since the grammar is extremely simple, and programs operate on these abstractions anyway. <br><br>  Further, to obtain the desired result, the request goes through several stages, returning to the already passed if necessary: <br><ul><li>  <b>Typification</b> .  YQL is a fundamentally strongly typed language.  There were many arguments in favor of this, starting from the roots in SQL, where schematization is implied, and ending with a wider scope for acceleration - for example, by generating native code on the fly.  In addition to simple data types, several types of containers (Optional, List, Dict, Tuple, and Struct) and special types are supported, for example, an opaque pointer (Resource). </li><li>  <b>Optimization</b> .  At this stage, not only equivalent transformations occur, designed to shorten the execution time.  In addition to them, the action plan is brought to the form that the backend is able to execute.  In particular, logical operations that the backend can natively perform are replaced by physical ones.  Thus, YQL has its own framework for optimizers, which can be divided into three categories: <br><ol><li>  general rules for logical optimization; </li><li>  general rules specific to specific backends; </li><li>  optimization, choosing one or another execution strategy in runtime (we'll return to them). </li></ol></li><li> <b>Fulfillment</b> .  If there are no errors left after optimization, the graph takes the form that can be performed using the backend API.  Most of the time, yqlworker does just that.  The logical operations remaining in the graph of calculations are performed using a highly specialized interpreter, and, if possible, on the computing power of the backends. </li></ul><br>  At any stage of the request life, it can be serialized back into the s-expressions syntax, which is extremely convenient for diagnosing and understanding what is happening. <br><br><h3>  Interfaces </h3><br>  As mentioned in the introduction, one of the key requirements for YQL was usability.  Therefore, special attention is paid to public interfaces and they are developing very actively. <br><br><h5>  <b>Console client</b> </h5><br><br><img src="https://habrastorage.org/files/ffd/f00/bef/ffdf00bef47d42aeb9cae7582a68e80e.gif"><br><br>  The picture shows an interactive mode with autocompletion, syntax highlighting, color themes, notifications and other decorations.  But the console client can be launched in the input-output mode from files or standard streams, which allows integrating it into arbitrary scripts and regular processes.  There are both synchronous and asynchronous running of operations, viewing a query plan, attaching local files, navigating through clusters and other basic features. <br><br>  Such rich functionality appeared for two reasons.  On the one hand, in Yandex there is a noticeable layer of people who prefer to work mainly in the console.  On the other hand, this was done in order to gain time to develop a full-featured web interface, which we will talk about later. <br><br>  A curious technical nuance: the console client is implemented in Python, but is distributed as a statically linked native application without dependencies with a built-in interpreter that compiles for Linux, OS X, and Windows.  In addition, it is able to automatically update itself automatically - just like modern browsers.  All this was just enough to organize thanks to the internal infrastructure of Yandex for building code and preparing releases. <br><br><h5>  <b>Python library</b> </h5><br><br><img src="https://habrastorage.org/files/2a0/4ec/be6/2a04ecbe6bbb4c9bbba95ddec51a49c6.gif"><br><br>  Python is the second most common programming language in Yandex after C ++, <s>so the YQL client library is implemented on it</s> .  In fact, it was originally developed as part of a console client, and then was allocated to an independent product, in order to be able to use it in other Python environments, without reinventing similar code. <br><br>  For example, many analysts like to work in the <a href="http://jupyter.org/">Jupyter</a> environment, for which the so-called% yql magic was created on the basis of this client library: <br><br><img src="https://habrastorage.org/files/1d6/0f2/348/1d60f234812740f4ab7fe8ef463c806d.jpeg"><br><br>  Together with the console client, two special subroutines are delivered that launch pre-configured Jupyter or <a href="http://ipython.org/">IPython</a> with an already available client library.  It is onii shown above. <br><br><h5>  <b>Web interface</b> </h5><br><br><img src="https://habrastorage.org/files/a22/f98/04a/a22f9804ad1e4423b12206e06e89ca5d.png"><br><br>  We left the main tool for learning the language YQL, developing queries and analytics for a snack.  In the web interface, due to the lack of technical limitations of the console, all YQL functions are available in a more visual form and are always at hand.  Some of the interface features are shown on examples of other screens: <br><br><ul><li>  Autocompletion and view table schema <br><br><img src="https://habrastorage.org/files/b29/dc3/882/b29dc3882bc147d8aaf7e7f3dfed1fce.png"><br><br>  The logic of autocompletion of requests from the console client and the web interface is common.  It can accurately take into account the context in which the input takes place.  This allows it to prompt only relevant keywords or the names of tables, columns, and functions, and not everything. <br></li><li>  Work with Saved Queries <br><br><img src="https://habrastorage.org/files/cb1/ddf/7e7/cb1ddf7e79884962b88eae38e178f823.gif"><br><br>  When you save the query under the name, they fall into the mini-analogue of the code repository with the ability to view the history and return to previous versions. <br></li><li>  Query execution plan <br><br><img src="https://habrastorage.org/files/d64/5e1/609/d645e16092bc4830a243fd77a1b28dcf.png"><br><br>  Here is shown the most simple and universal implementation of JOIN in terms of MapReduce. <br></li></ul><br><h5>  <b>‚Ä¶ and not only</b> </h5><br>  All pens in the REST API itself are annotated by code, and based on these annotations, detailed online documentation is automatically generated using Swagger.  From it you can try pozadavat requests without a single line of code.  This makes it easy to use YQL, even if the options listed above for some reason did not fit.  For example - if you like Perl. <br><br><h3>  Opportunities </h3><br>  It is time to talk about which plan the tasks can be solved with the help of Yandex Query Language and what opportunities are provided to users.  This part will be rather abstract, in order not to lengthen the already long post. <br><br><h5>  <b>SQL</b> </h5><br><ul><li>  The main dialect of YQL is based on the SQL: 1992 standard interspersed with newer versions.  All basic designs are supported, but full compatibility in subtleties that were not very much in demand is still in development.  Thanks to this, many new users who have previously worked with any databases with a SQL interface have to learn a language far from scratch. </li><li> On backends working in the MapReduce paradigm, target tables (for simplicity) are created automatically.  Requests most often consist of a <code>SELECT</code> an arbitrary level of complexity and optionally contain an <code>INSERT INTO</code> . </li><li>  Full-featured DDL ( <code>CREATE TABLE</code> ) and CRUD (plus <code>UPDATE</code> , <code>REPLACE</code> , <code>UPSERT</code> and <code>DELETE</code> ) are available in OLTP scripts. </li><li>  For many situations that are either not supported in standard SQL, or would be too cumbersome, various syntax extensions have been added to YQL, for example: <br><br><ul><li>  <b>Named Expressions</b> <br><br><img src="https://habrastorage.org/files/19d/da2/999/19dda29997b04f68b81bef1268142d52.png"><br><br>  Allowing a large number of levels of nesting subqueries to write them in turn, and not in each other according to the standard.  They also make it possible to not copy-paste frequently used expressions. <br></li><li>  <b>Work with container types</b> <br><br><img src="https://habrastorage.org/files/3f4/34c/b54/3f434cb54c2e427bb605c477a6b3b033.png"><br><br>  Available as a syntax for getting items by key or index, and a set of specialized built-in functions. <br><br></li><li> <code><b>FLATTEN BY</b></code> <br> <br><img src="https://habrastorage.org/files/63c/714/bb4/63c714bb47b64f949e832b0bc272a3ca.png"><br><br>  This keyword is used to multiply the rows of the source table with vertical unfolding of containers (lists or dictionaries) of variable length from a column with the corresponding data type. <br><br>  It sounds a bit confusing - it's easier to show with an example.  Take a table of the following form: <br><table><tbody><tr><td width="100">  [a, b, c] </td><td width="100">  one </td></tr><tr><td>  [d] </td><td>  2 </td></tr><tr><td>  [] </td><td>  3 </td></tr></tbody></table>  Applying <code>FLATTEN BY</code> to the left column, we get the following table: <br><table><tbody><tr><td>  a </td><td>  one </td></tr><tr><td>  b </td><td>  one </td></tr><tr><td>  c </td><td>  one </td></tr><tr><td>  d </td><td>  2 </td></tr></tbody></table>  Such a conversion can be handy when you need to calculate some statistics for cells from a container column (say, through <code>GROUP BY</code> ) or when cells contain identifiers from another table with which you need to make a <code>JOIN</code> . <br><br>  The funniest thing about <code>FLATTEN BY</code> is this: it is called differently in all systems that can do this.  From what we found, there is not a single repetition: <br><ul><li>  <code>ARRAY JOIN</code> - ClickHouse, </li><li>  <code>unnest</code> - PostgreSQL, </li><li>  <code>$unwind</code> - MongoDB, </li><li>  <code>LATERAL VIEW</code> - Hive, </li><li>  <code>FLATTEN</code> - Google BigQuery. </li></ul><br></li><li>  <b>Explicit <code>PROCESS</code> (Map) and <code>REDUCE</code> (Reduce).</b> <br><br><img src="https://habrastorage.org/files/80c/810/a21/80c810a21cf048b994a09cecc5aa2689.png"><br><br>  They allow embedding into existing queries in YQL the existing code written in the MapReduce paradigm in conjunction with the user function mechanism, which will be discussed below. </li></ul></li></ul><br><br><h5>  <b>User Defined Functions</b> </h5><br>  Not all types of data transformations are conveniently expressed declaratively.  Sometimes it's easier to write a loop or use some kind of ready-made library.  For such situations, YQL provides the mechanism of user-defined functions, they are also User Defined Functions, they are also UDF: <br><br><ul><li>  C ++ UDF <br><ul><li>  "Out of the box" is available more than 100 functions in C ++, divided into more than 15 modules.  Examples of modules: String, DateTime, Pire, Re2, Protobuf, Json, etc. </li><li>  Physically, C ++ UDF are dynamically loaded libraries (.so) with an ABI-safe protocol for calling and registering functions. </li><li>  It is possible to write your own C ++ UDF, compile it locally (the build system has a ready-made set of build settings for UDF), load it in the standard way into the repository and immediately start using it in requests by attaching it by URL. </li><li>  For simple UDFs, it is convenient to use ready-made C ++ macros that hide parts, and, if necessary, you can use flexible interfaces created for various needs. </li></ul><br></li><li>  Python UDF <br><ul><li>  When performance is not so important, and to solve the problem, you need to quickly make an insert with imperative business logic, it is very convenient to dilute the declarative query with Python code.  Most of Yandex employees know Python, and if someone does not know, at the basic level it is studied in units of days. </li><li>  You can either write the Python script as inline mixed with SQL or s-expressions, or attach it to the request as a separate file.  In general, the mechanism for delivering files to the place of computation from a client or via a URL is universal and can be used for everything necessary, for example, for dictionary files. </li><li>  Since Python uses dynamic typing, and YQL uses static typing, the user is required to declare the signature of the function on the border.  Now it is described outside with the help of an additional mini-language: the fact is that at the typing stage I do not want to run the interpreter.  In the future, perhaps we will add support for <a href="https://docs.python.org/3/library/typing.html">Python 3 type hints</a> . </li><li>  Technically, Python support in YQL is implemented via C ++ UDF with a built-in Python interpreter and a small syntactic sugar in the SQL parser to call it. </li></ul><br></li><li>  Streaming UDF.  So that you can smoothly switch from other technologies, and for some special cases there is a way to run an arbitrary script or executable file in streaming mode.  As a result, we obtain a UDF that converts one list of strings to another. </li></ul><br><br><h5>  <b>Aggregation functions</b> </h5><br>  Internally, the aggregation functions use a common framework with support for <code>DISTINCT</code> and execution both at the top level and in <code>GROUP BY</code> (including with <code>ROLLUP/CUBE/GROUPING SETS</code> from the SQL standard: 1999).  And these functions differ only in business logic.  Here are some examples: <br><ul><li>  Standard: <code>COUNT</code> , <code>SUM</code> , <code>MIN</code> , <code>MAX</code> , <code>AVG</code> , <code>VARIANCE</code> , <code>VARIANCE</code> ; </li><li>  Additional: <code>COUNT_IF</code> , <code>SOME</code> , <code>LIST</code> , <code>MIN_BY/MAX_BY</code> , <code>BIT_AND/OR/XOR</code> , <code>BOOL_AND/OR</code> ; </li><li>  Statistics: <br><ul><li>  <code>MEDIAN</code> and <code>PERCENTILE</code> (according to the <a href="https://github.com/tdunning/t-digest">TDigest</a> algorithm); </li><li>  <code>HISTOGRAM</code> - adaptive histograms for numerical values ‚Äã‚Äãthat do not require any knowledge of their distribution (according to an algorithm based on the <a href="http://jmlr.org/papers/volume11/ben-haim10a/ben-haim10a.pdf">Streaming Parallel Decision Tree</a> ). </li></ul></li><li>  User Defined Aggregation Functions: for very specific tasks, you can transfer your business logic to the aggregation functions framework by creating several callable values ‚Äã‚Äãwith a specific signature using the UDF mechanism described above, for example, in Python. </li></ul><br><br>  For performance reasons, a Map-side Combiner is automatically created in terms of MapReduce for aggregation functions with the combination of intermediate aggregation results in Reduce.  <code>DISTINCT</code> now always works exactly (without approximate calculations), so it requires an additional Reduce for marking up unique values. <br><br><h5>  <b>JOIN tables</b> </h5><br>  The fusion of tables by keys is one of the most popular operations, which is often needed to solve problems, but to implement it correctly in terms of MapReduce is almost a science.  Logically, all standard modes are available in Yandex Query Language, plus several additional ones: <br><br><img src="https://habrastorage.org/files/426/f18/d3c/426f18d3c47148afba633ab7c391804d.png"><br><br>  To hide details from users, for MapReduce-based backends, the JOIN execution strategy is selected on the fly depending on the required logical type and physical properties of the participating tables (this is the so-called cost based optimization): <br><br><table><tbody><tr><td>  <b>Strategy</b> </td><td>  <b>Short description</b> </td><td>  <b>Available for logical types</b> </td></tr><tr><td>  Common join </td><td>  1-2 Map + Reduce </td><td>  Everything </td></tr><tr><td>  Map-side join </td><td>  1 Map </td><td>  Inner, Left, Left only, Left semi, Cross </td></tr><tr><td>  Sharded Map-Join </td><td>  k parallel maps (k &lt;= 4 by default) </td><td>  Inner, Left semi with unique right, Cross </td></tr><tr><td>  Reduce Without Sort </td><td>  1 Reduce, but requires pre-properly sorted input </td><td>  <i>in developing</i> </td></tr></tbody></table><br><br><h3>  Development directions </h3><br>  Among our immediate and medium-term plans for Yandex Query Language: <br><ul><li>  More backends in production status. </li><li>  Native code generation and vectorization instead of a specialized interpreter. </li><li>  Continue optimizing I / O and choosing execution strategies on the fly depending on the physical properties of the tables. </li><li>  Window functions based on the SQL: 2003 standard. </li><li>  SQL support: 1992 in full, creating ODBC / JDBC drivers with subsequent integration with popular ORM and business intelligence tools. </li><li>  A clear demonstration of the progress of operations. </li><li>  Extended range of available programming languages ‚Äã‚Äãfor UDF - we are looking at JavaScript ( <a href="https://developers.google.com/v8/">V8</a> ), Lua ( <a href="https://luajit.org/">LuaJIT</a> ) and Python 3. </li><li>  Integration with: <br><ul><li>  distributed fault-tolerant service to start tasks on a schedule (a la cron) or the occurrence of events </li><li>  visualization tools (internal analogue of <a href="https://stat.yandex.ru/">Yandex.Statistics</a> ). </li></ul></li></ul><br><br><img src="https://habrastorage.org/files/bca/2d9/873/bca2d9873d344e79a3def1599ffdc8da.png"><br><br><h3>  Summing up </h3><br><ul><li>  As the figures show (see statistics), YQL has become a product that is in high demand among Yandex employees.  However, the volume of data processed with its help is not so large.  This is due to the fact that historically all production processes run on low-level interfaces that are suitable for the requirements of the respective systems.  That is, their gradual translation to YQL is just beginning. </li><li>  Inside Yandex, we initially encountered the following type of resistance: working in the MapReduce paradigm for many years, many are already so used to it that they do not want to relearn.  In Arcadia, the main monolithic repository of the Yandex code, each employee has his own corner.  There historically are literally hundreds of C ++ programs written exclusively to filter out some specific log or just a table in MapReduce for a specific task.            . </li><li>   , ¬´  <a href="http://hive.apache.org/">Hive</a> , <a href="http://spark.apache.org/sql">Spark SQL</a>    <code>SQL over ***</code> ¬ª:            .    ,               / .         open source-.  ,     ,  Java-      ,  C++-,        open source- ‚Äî    .      ,      . YQL    -      10 ,      full time. </li><li>    SQL-,        ,       -      .         Python   Nile:      runtime  (   API)    YQL-  s-expressions.            .   ,      ,     ,         , , Java. </li><li>       YQL  -    open source ‚Äî       Apache Software Foundation: Hadoop  Spark.  ,           : ,            .         . </li></ul><br><br>  ‚Äî     <a href="https://events.yandex.ru/events/meetings/15-oct-2016/%3Futm_source%3Dhabr%26utm_medium%3Darticles%26utm_campaign%3DInfr">   </a>   , 15 ,         . <br><br><img src="https://habrastorage.org/files/779/6a4/27f/7796a427f21a4037adc1a5e226824d54.png"></div><p>Source: <a href="https://habr.com/ru/post/312430/">https://habr.com/ru/post/312430/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312420/index.html">Factor modeling using neural network</a></li>
<li><a href="../312422/index.html">Create good tables</a></li>
<li><a href="../312424/index.html">Multi-Tech Base Stations let you deploy a LoRaWAN network in a couple of clicks</a></li>
<li><a href="../312426/index.html">Software-defined modular collocation - why is it needed?</a></li>
<li><a href="../312428/index.html">Microsoft fixed vulnerabilities in their products</a></li>
<li><a href="../312432/index.html">Internet provider fined ¬£ 400,000 after hacker attack with client data leakage</a></li>
<li><a href="../312442/index.html">Elixir: making code extensible with Behavior</a></li>
<li><a href="../312448/index.html">Personal experience of implementing the GLPI system. Part 1</a></li>
<li><a href="../312450/index.html">Neural networks for beginners. Part 1</a></li>
<li><a href="../312456/index.html">1C in the clouds</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>