<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Prolog - examples of use (Part 2)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The first part of an article about Prolog described the structure, syntax, and interpretation of a language. Of course, non-fiction literature is inte...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Prolog - examples of use (Part 2)</h1><div class="post__text post__text-html js-mediator-article">  The first part of an <a href="http://habrahabr.ru/blogs/programming/124636/">article</a> about Prolog described the structure, syntax, and interpretation of a language.  Of course, non-fiction literature is interesting for a programmer, but something interactive, live, and launching is much more interesting.  Therefore, in this article I propose to arm <a href="http://www.swi-prolog.org/download/stable">SWI-Prolog</a> and consider solving the simplest problems on the Prolog. <br><br>  Before starting, I would like to briefly answer topical questions from harabchiteli: <br>  - Where is Prolog really used? <br>  - Such projects exist, some were cited in the comments to the 1st article.  It is important that most programmers write in Prolog not from hopelessness, but from the fact that they like Prolog.  After all, Prolog cannot be used for any task, such as creating a UI or manipulating files. <br><br>  - Why are there few such projects? <br>  ‚ÄúBecause there are very few programmers who own Prolog, not only because people did not study it, but because they did not study to write full programs.‚Äù  The main reason is that people do not clearly understand in what situations it is best to use it.  You can often see that the ardent supporters of the Prologue write everything on it, including handlers for the keyboard and mouse, which makes the code worse than C. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      - Why is there no Prolog community? <br>  - It is.  Such is the specificity of the language that it is very fond of in the academic environment (most of the Prolog systems are written in various universities and vice versa almost any university writes its own Prolog), because of this, the applicability of the language also suffers.  It is worth noting that the community is small, but very loyal: almost all known languages ‚Äã‚Äãare reflected in modern languages ‚Äã‚Äã(Lisp, ML -&gt; F #, Scala; Smalltalk -&gt; Java, Scala (agents), scripted -&gt; Ruby), unlike Prologue. <br><br>  I think this is enough philosophical reasoning and you can start with real examples :) <br><br>  In the end, as usual, the task for the prize awaits <br><a name="habracut"></a><br><hr><br><h4>  Example # 1 - search for perfect numbers </h4><br>  For this example, we need the predicate is / 2.  <i>X is 3 + 1 * 2</i> - calculates the expression on the right and puts in the variable on the left, it is not an assignment (!), But the statement that X = 7. Simply put, the phrase X = 7, X = 3 - has no solution because X cannot be simultaneously 7 and 3. <br>  We also need a solution to the problem from the previous topic.  The task was to write a predicate that would generate all natural numbers in a row, here‚Äôs the solution: <br><pre><code class="hljs swift">ints(<span class="hljs-number"><span class="hljs-number">0</span></span>). ints(<span class="hljs-type"><span class="hljs-type">X</span></span>) :- ints(<span class="hljs-type"><span class="hljs-type">Y</span></span>), <span class="hljs-type"><span class="hljs-type">X</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">Y</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>.</code> </pre> <br>  In fact, this is a declarative version of the standard integer / 1 predicate, which checks that the argument is an integer.  The problem of the standard predicate is that it works correctly for the query: - integer (1) and does not work for the query integer (X). <br><br>  <u>The task</u> : to write a program that would find all the perfect numbers. <br>  The solution is obvious, we run over all integers and check whether they are perfect, this strategy is very well applicable to imperative languages, we ourselves do not notice how we immediately look for a solution search algorithm, rather than analyzing the problem.  In Prolog, we should not try to describe the search for a solution to a problem, but try to describe the formulation of the problem, to do this, follow the rule: <br><br>  <b>Do not try to describe the instructions for finding a solution, assume that you have already found a solution, and your task is only to verify that a solution has been found.</b> <br><br>  Oddly enough, but this strategy works great. <br><pre> <code class="hljs vhdl"> %%     ints(<span class="hljs-number"><span class="hljs-number">0</span></span>). ints(X) :- ints(Y), X <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Y + <span class="hljs-number"><span class="hljs-number">1</span></span>. %%   -  <span class="hljs-number"><span class="hljs-number">1</span></span>)   <span class="hljs-number"><span class="hljs-number">2</span></span>)     perfect_number(X) :- ints(X), Y <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> X - <span class="hljs-number"><span class="hljs-number">1</span></span>, calculatesum_divisors_till(Sum, X, Y), Sum = X. %%    <span class="hljs-number"><span class="hljs-number">1</span></span>-  , <span class="hljs-number"><span class="hljs-number">2</span></span>- -     , %% <span class="hljs-number"><span class="hljs-number">3</span></span>- -      calculatesum_divisors_till(<span class="hljs-number"><span class="hljs-number">0</span></span>, _NumberToDivide, <span class="hljs-number"><span class="hljs-number">0</span></span>). calculatesum_divisors_till(Sum, NumberToDivide, Till) :- Till &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Rem</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NumberToDivide <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> Till, <span class="hljs-keyword"><span class="hljs-keyword">Rem</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>, Ts <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Till - <span class="hljs-number"><span class="hljs-number">1</span></span>, calculatesum_divisors_till(SumPrev, NumberToDivide, Ts), Sum <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> SumPrev + Till. calculatesum_divisors_till(Sum, NumberToDivide, Till) :- Till &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Rem</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NumberToDivide <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> Till, <span class="hljs-keyword"><span class="hljs-keyword">Rem</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, Ts <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Till - <span class="hljs-number"><span class="hljs-number">1</span></span>, calculatesum_divisors_till(Sum, NumberToDivide, Ts).</code> </pre><br><br>  We paste the source text into the file, run the interpreter and compile it (via the query: -compile ('path_to_file / perfect_numbers.pl'). Write the query <i>: - perfect_number (X).</i> And the interpreter gives the answer, when you press ';' produces the following. Pay Attention request may be <i>: - perfect_number (X), X&gt; 6.</i> Then all the answers will be more than 6. Of course the program does not work optimally, the check itself can be simplified using simple dividers, try. <br><br><hr><br><h4>  Example # 2 - generation of permutations. </h4><br>  For the formulation and solution of this problem we need the concept of lists.  Lists are not basic language concepts; between lists, you can draw a direct analogy with linked lists in C. We return to the definition of a term as a recursive data structure. <br><pre> <code class="hljs mel"> %%      nil list(nil). %%      <span class="hljs-number"><span class="hljs-number">1</span></span> list(t(<span class="hljs-number"><span class="hljs-number">1</span></span>, nil)). %%     <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> list(t(<span class="hljs-number"><span class="hljs-number">1</span></span>, t(<span class="hljs-number"><span class="hljs-number">2</span></span>, t(<span class="hljs-number"><span class="hljs-number">3</span></span>, nil) ) ) ). %%        %% <span class="hljs-number"><span class="hljs-number">1.</span></span>      (<span class="hljs-number"><span class="hljs-number">1</span></span>- ) %% _ -      member(X, t(Y, _)) :- X = Y. %% <span class="hljs-number"><span class="hljs-number">2.</span></span>    ,         member(X, t(_, Tail)) :- member(X, Tail).</code> </pre><br><br>  As many would say, the usual recursion and that the lists do not look like something especially in the Prologue there is syntactic sugar for them: nil can be written [], t (1, nil) - [1], t (1, t (2, nil) ) - [1, 2], t (1, Sublist) - [1 |  Sublist], t (1, t (2, Sublist)) - [1, 2 |  Sublist].  It is recommended to use syntactic sugar for lists, because the internal name of terms may differ (most often the term is called '.'). <br><pre> <code class="hljs css"> %% 1.      (1<span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span> ) <span class="hljs-selector-tag"><span class="hljs-selector-tag">member</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[X|_]</span></span>). %% 2.    ,         <span class="hljs-selector-tag"><span class="hljs-selector-tag">member</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[_| Tail]</span></span>) <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">member</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Tail</span></span>).</code> </pre><br>  Let us return to the original problem of generating permutations.  Everyone remembers perfectly well that the number of permutations is n !, but now give this task to most programmers and everyone will start to frantically recall and say that they wrote this in school and forgot how the search is done.  On average, the algorithm appears after trying and tormenting after 20 minutes. With the knowledge of Prolog, this algorithm is written in 2 minutes or not written at all :) <br><br>  How to solve on the prolog?  We use the rule of not finding a solution, but checking that a solution has been found.  Predicate <i>perm (Source, Permutation)</i> - where Source is source list, Permutation is permutation. <br><br><pre> <code class="hljs mel"> %%           perm([], []). %% <span class="hljs-number"><span class="hljs-number">1</span></span>-       , %%         , %%       %%    perm(Source, [Element|Tail]) :- member_list_exclude(Element, Source, SourceExcluded), perm(SourceExcluded, Tail). %%  ,     ,  <span class="hljs-number"><span class="hljs-number">2</span></span>-      %%   member_list_exclude    %% <span class="hljs-number"><span class="hljs-number">1</span></span>- - , <span class="hljs-number"><span class="hljs-number">2</span></span>- - , <span class="hljs-number"><span class="hljs-number">3</span></span>- -    member_list_exclude(X, [X|L], L). member_list_exclude(X, [Y|L], [Y|Ls]) :- member_list_exclude(X, L, Ls).</code> </pre><br>  Query <i>: -perm ([1, 2, 3], X)</i> generates all permutations.  Interestingly, the queries are symmetrical <i>: -perm (X, [1, 2, 3])</i> with respect to the arguments, although this query hangs and in order for it to work it is necessary to change member_list_exclude and perm places in perm. <br><br><hr><br><h4>  Example # 3 - generation of combinations. </h4><br>  The generation of combinations in terms of ease of implementation is similar to the generation of permutations.  We will need the predicate member / 2 - the element belonging to the list.  Suppose we have 2 lists: the 1st source list, the 2nd one ‚Äî the intended combination, you need to check the correctness of the combination.  Elements of the combination are arranged in the order of the original list. <br><br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">member</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[X|_]</span></span>). <span class="hljs-selector-tag"><span class="hljs-selector-tag">member</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[_|L]</span></span>) <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">member</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">L</span></span>). <span class="hljs-selector-tag"><span class="hljs-selector-tag">comb</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span>). %%  1 : 1<span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>       <span class="hljs-selector-tag"><span class="hljs-selector-tag">comb</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[X|List]</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[X|Tail]</span></span>) <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">comb</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">List</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Tail</span></span>). %%  2 :      , %%   1<span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>        <span class="hljs-selector-tag"><span class="hljs-selector-tag">comb</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[_|List]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Tail</span></span>) <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">comb</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">List</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Tail</span></span>).</code> </pre><br><br><hr><br><h4>  Example # 4 - sorting. </h4><br>  This example will be considered in sufficient detail and we will try to optimize the primary solution.  The process of writing on Prolog is as follows: 1) the primary description of the problem and obtaining the overkill solution 2) logical optimization by rearranging the predicates on the right 3) logical optimization of introducing simplified checks or removing unnecessary conditions 4) introducing heuristics and optimizing individual cases by cutting off. <br><br>  <b>Option 1. Sorting naive</b> : the first element of the sorted array should be minimal, the remaining elements should be sorted.  The first array is source, the second array is sorted source. <br><br><pre> <code class="hljs pgsql"> sort([], []). sort(List, [Min|SortRest]) :- min_list_exclude(Min, List, <span class="hljs-keyword"><span class="hljs-keyword">Exclude</span></span>), sort(<span class="hljs-keyword"><span class="hljs-keyword">Exclude</span></span>, SortRest). %%    ,        min_list_exclude(M, [M], []). min_list_exclude(Min, [M|L], ExcludeRes) :- min_list_exclude(Ms, L, <span class="hljs-keyword"><span class="hljs-keyword">Exclude</span></span>), find_result(result(M, L), result(Ms, [M|<span class="hljs-keyword"><span class="hljs-keyword">Exclude</span></span>]), result(Min, ExcludeRes)). %%         find_result(result(M, L), result(Ms, _), result(M, L)):- M &lt; Ms. find_result(result(M, _), result(Ms, <span class="hljs-keyword"><span class="hljs-keyword">Exclude</span></span>), result(Ms, <span class="hljs-keyword"><span class="hljs-keyword">Exclude</span></span>)):- Ms =&lt; M.</code> </pre><br>  It can be noted that the complexity of this algorithm is quadratic and the main problem is that every time we look for the minimum element without saving any useful information. <br>  Note also that we are trying to determine what the 1st element of a sorted array is. <br><br>  <b>Option 2. Quick sort.</b>  Let's look at the problem from the second side and try to determine the location of the 1st list item in the sorted array (apply recursion to the original array). <br><br><pre> <code class="hljs vbscript"> sort_b([], []). sort_b([T|R], List) :- <span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(T, R, Less, Great), sort_b(Less, LessSort), sort_b(Great, GreatSort), append(LessSort, [T|GreatSort], List). %%    <span class="hljs-number"><span class="hljs-number">2</span></span>     <span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(_, [],[], []). <span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(T, [M|R],[M|Less], Great) :- M &lt; T, <span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(T,R, Less,Great). <span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(T, [M|R],Less, [M|Great]) :- M &gt;= T, <span class="hljs-built_in"><span class="hljs-built_in">split</span></span>(T,R, Less,Great). %%  <span class="hljs-number"><span class="hljs-number">2</span></span>  append([], M, M). append([L|<span class="hljs-built_in"><span class="hljs-built_in">Left</span></span>], <span class="hljs-built_in"><span class="hljs-built_in">Right</span></span>, [L|Res]) :- append(<span class="hljs-built_in"><span class="hljs-built_in">Left</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">Right</span></span>, Res).</code> </pre><br>  You may notice that we have improved the results of sorting, since the quick sort is obviously faster than the bubble one.  In order to further improve the results, we can recall the merge sort, which in any case gives O (n lg n), but unfortunately this sorting is applicable only to arrays, and not to the connected lists with which we work.  The only option is to use an additional data structure for storage - a tree. <br><br>  <b>Option 3. Sort using a binary tree.</b> <br><br>  For this type of sorting, we translate the source list into a binary tree, and then, using the tree traversal on the left, we get a sorted array.  The tree will be represented by the recursive term <i>tree (Object, LeftSubTree, RightSubTree)</i> . <br><pre> <code class="hljs dos"> sort_tree([], nil). sort_tree([X|L], <span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>) :- sort_tree(L, LTree), plus(X, LTree, <span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>). %%      plus(X, nil, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(X, nil, nil)). plus(X, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(O, L, R), <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(O, ResL, R)) :- O &gt;= X, plus(X, L, ResL). plus(X, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(O, L, R), <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(O, L, ResR)) :- O &lt; X, plus(X, R, ResR). sort_t(X, Y) :- sort_tree(X, <span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>), tree_list(<span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>, Y). append_list([], L, L). append_list([X|L], R, [X|T]) :- append_list(L, R, T). tree_list(nil, []). tree_list(<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(X, L, R), List) :- tree_list(L, ListL), tree_list(R, ListR), append_list(ListL, [X|ListR], List).</code> </pre><br><br>  <b>Option 4. Sort using a balanced binary tree.</b> <br><br>  The problem of using a binary tree is the same as using quick sort.  The method does not guarantee optimal performance.  In the case of a binary tree, the tree can be unbalanced and the procedure for adding an element to it can be linear rather than logarithmic.  Especially for this, the tree balancing procedures are carried out, the algorithm with the use of the <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%2592%25D0%259B-%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">AVL-tree</a> will be shown below. <br><br><pre> <code class="hljs dos"> sort_btree(X, Y) :- sort_tree(X, <span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>), tree_list(<span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>, Y). tree_list(nil, []). tree_list(<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(X, L, R, _), List) :- tree_list(L, ListL), tree_list(R, ListR), <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(ListL, [X|ListR], List). sort_tree([], nil). sort_tree([X|L], <span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>) :- sort_tree(L, LTree), plus_tree(X, LTree, <span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>). construct_tree(A, AL, AR, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(A, AL, AR, ADepth)) :- diff(AL, AR, _, ADepth). diff(AL, AR, ADiff, ADepth) :- depth_tree(ALs, AL), depth_tree(ARs, AR), ADiff is ALs - ARs, max_int(ALs, ARs, AD), ADepth is AD + <span class="hljs-number"><span class="hljs-number">1</span></span>. max_int(A, B, A) :- A &gt; B. max_int(A, B, B) :- A =&lt; B. <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>([], L, L). <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>([X|L], R, [X|T]) :- <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(L, R, T). depth_tree(<span class="hljs-number"><span class="hljs-number">0</span></span>, nil). depth_tree(X, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(_, _, _, X)). plus_tree(X, nil, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(X, nil, nil, <span class="hljs-number"><span class="hljs-number">1</span></span>)). plus_tree(X, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(O, L, R, _), Res) :- O &gt;= X, plus_tree(X, L, ResL), diff(ResL, R, Diff, Dep), balance_tree(<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(O, ResL, R, Dep), Diff, Res). plus_tree(X, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(O, L, R, _), Res) :- O &lt; X, plus_tree(X, R, ResR), diff(L, ResR, Diff, Dep), balance_tree(<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(O, L, ResR, Dep), Diff, Res). %% No rotations balance_tree(<span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>, ADiff, <span class="hljs-built_in"><span class="hljs-built_in">Tree</span></span>) :- ADiff &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, ADiff &gt; -<span class="hljs-number"><span class="hljs-number">2</span></span>. %% Small right rotation balance_tree(<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(A, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(B, BL, BR, _), AR, _), ADiff, Result) :- ADiff &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, diff(BL, BR, BDiff, _), BDiff &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>, construct_tree(A, BR, AR, ASubTree), construct_tree(B, BL, ASubTree, Result). %% Big right rotation balance_tree(<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(A, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(B, BL, BR, _), AR, _), ADiff, Result) :- ADiff &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>, diff(BL, BR, BDiff, _), BDiff &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, BR = <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(C, CL, CR, _), construct_tree(B, BL, CL, BSubTree), construct_tree(A, CR, AR, ASubTree), construct_tree(C, BSubTree, ASubTree, Result). %% Small left rotation balance_tree(<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(A, AL, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(B, BL, BR, _), _), ADiff, Result) :- ADiff &lt; -<span class="hljs-number"><span class="hljs-number">1</span></span>, diff(BL, BR, BDiff, _), BDiff =&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, construct_tree(A, AL, BL, ASubTree), construct_tree(B, ASubTree, BR, Result). %% Big left rotation balance_tree(<span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(A, AL, <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(B, BL, BR, _), _), ADiff, Result) :- ADiff &lt; -<span class="hljs-number"><span class="hljs-number">1</span></span>, diff(BL, BR, BDiff, _), BDiff &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, BL = <span class="hljs-built_in"><span class="hljs-built_in">tree</span></span>(C, CL, CR, _), construct_tree(B, CR, BR, BSubTree), construct_tree(A, AL, CL, ASubTree), construct_tree(C, ASubTree, BSubTree, Result).</code> </pre><br>  This example is not sufficiently expressive for implementation on Prolog, although it gives an idea of ‚Äã‚Äãthe programs of average size.  For training, you can implement bubble sorting or sorting inserts, we leave it at the discretion of the reader. <br><br><hr><br><h4>  Example 5 - The task of transfusions. </h4><br>  As the next task, we consider the classical problem of states; this problem reflects the advantages of using Prolog much better.  The general formulation of the problem: some containers with water are given, it is necessary to obtain a certain amount of water in a container by means of transfusions.  For example, take 3 jugs with a capacity of 12 liters, 8 liters, 5 liters, fill the 1st completely, that is, 12 liters and set the task to get <b>6 liters</b> .  <i>First, try to solve this school problem with a pen and a piece of paper</i> :) <br><br>  Before generating the various algorithms and trying to apply them to the task, let's first rewrite the terms in terms of the Prolog.  We describe the capacity as a term <i>sosud (Id, MaximumCapacity, CurrentCapacity)</i> , and describe the state of the system as a list of capacities.  Example <i>[sosud (1, 12, 12), sosud (2, 8, 0), sosud (3, 5, 0)]</i> .  Now we will describe the query: <br><br><pre> <code class="hljs css"> %% <span class="hljs-selector-tag"><span class="hljs-selector-tag">solve_pr_wo</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">InitialState</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Goal</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Steps</span></span>). <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">solve_pr_wo</span></span>(<span class="hljs-selector-attr"><span class="hljs-selector-attr">[sosud(1, 12, 12), sosud(2, 8, 0), sosud(3, 5, 0)]</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">sosud</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>, _, 6), <span class="hljs-selector-tag"><span class="hljs-selector-tag">Steps</span></span>).</code> </pre><br><br>  <i>Please note that Goal = sosud (_, _, 6), that is, it does not matter to us which capacity the vessel is important for it to have exactly 6 liters.</i> <br><br>  Now that we all know, we will describe the way to <b>verify the</b> solution, assuming that the steps are set in the variable Steps. <br><br><pre> <code class="hljs mel"> %%        , %%        solve_pr_wo(State, Goal, []) :- member(Goal, State). %%      Sosud  Sosud2    %%   ResSosud,   ResSosud2. %%    : %% mv(sosud(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>) -&gt; sosud(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), sosud(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) -&gt; sosud(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>)). solve_pr_wo(State, Goal, [mv(Sosud -&gt; Sosud2 , ResSosud -&gt; ResSosud2)| Steps]) :- %%     ,    %%           member(Sosud, State), member(Sosud2, State), not(Sosud = Sosud2), %%   ,  %%   <span class="hljs-number"><span class="hljs-number">4</span></span>   mv(Sosud, Sosud2, ResSosud, ResSosud2), %%         replace(Sosud, State, ResSosud, State2), replace(Sosud2, State2, ResSosud2, StateX), %%       solve_pr_wo(StateX, Goal, Steps). %%         %% replace(ElementToReplace, InList, ElementToReplaceWith, OutList). replace(S, [S|L], X, [X|L]). replace(S, [T|L], X, [T|Ls]) :- replace(S, L, X, Ls). %%   - <span class="hljs-number"><span class="hljs-number">2</span></span>  %%        %%      mv(sosud(Id1, Max1, Current), sosud(Id2, Max2, Current2), sosud(Id1, Max1, <span class="hljs-number"><span class="hljs-number">0</span></span>), sosud(Id2, Max2, Current3)) :- Current &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, Current3 is Current2 + Current, Current3 =&lt; Max2. %%        mv(sosud(Id1, Max1, Current), sosud(Id2, Max2, Current2), sosud(Id1, Max1, Current3), sosud(Id2, Max2, Max2)) :- Current &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, Current3 is Current2 + Current - Max2, Current3 &gt;= <span class="hljs-number"><span class="hljs-number">0.</span></span></code> </pre><br><br>  Additions, it may seem that the verification of the domain is not necessary, because if the steps for transfusion are correct, then you can not verify what they describe.  In fact, the completeness of verification seriously improves the chances of the program to earn correctly.  It is more correct to even say so, with excessive verification, the program will work, sometimes even more optimized than without, but with insufficient verification, the program with some input data will produce absolutely wrong results or hang. <br><br>  Well, the description of the program is written - you can run.  No wonder the program will not work, it just hangs :) It's not as bad as it may seem, because if the program did not freeze, then it would give the correct answer.  We need to figure out why it is stuck, and here we will come to the aid of an understanding of how the Prologue unfolds the rules in order to find a solution.  In fact, you don‚Äôt need to have a head that can memorize up to 10 cusps to understand that every next time solve_pr_wo -&gt; calls solve_pr_wo by recursion, it causes 2 predicates of member / 2, which always return the same 1st and 2nd vessel (the predicate does not cause backtracking and does not allow the member to select the 1st and 1st vessel).  That is, the algorithm constantly pours from 1st to 2nd and back. <br><br>  In order to resolve this absurdity, it immediately comes to mind to prohibit doing the same action 2 times, that is, to have a history of states, and if a state has already been encountered, then to prohibit its repeated hit.  It turns out that we are narrowing the set of permissible transfusion strategies, excluding repetition.  In fact, narrowing the set of strategies, we do not narrow the set of admissible states of the system, that is, solutions, which is not difficult to prove. <br><br>  The full version of the program with a listing of states and the only predicate for calling a solution: <br><br><pre> <code class="hljs sql"> write_list([]). write_list([X|L]) :- writeln(X), write_list(L). solution :- solve_pr([sosud(1, 12, 12), sosud(2, 8, 0), sosud(3, 5, 0)], sosud(_, _, 6), [], Steps), write_list(Steps). <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(S, [S|L], X, [X|L]). <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(S, [T|L], X, [T|Ls]) :- <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(S, L, X, Ls). %%       ,     %%     ,   ,     solve_pr(State, Goal, _, [State]) :- <span class="hljs-keyword"><span class="hljs-keyword">member</span></span>(Goal, State). solve_pr(State, Goal, History, [State|Steps]) :- <span class="hljs-keyword"><span class="hljs-keyword">member</span></span>(Sosud, State), <span class="hljs-keyword"><span class="hljs-keyword">member</span></span>(Sosud2, State), <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(Sosud = Sosud2), mv(Sosud, Sosud2, ResSosud, ResSosud2), <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(Sosud, State, ResSosud, State2), <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span>(Sosud2, State2, ResSosud2, StateX), %%%      <span class="hljs-keyword"><span class="hljs-keyword">not</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">member</span></span>(StateX, [State|History])), solve_pr(StateX, Goal, [State|History], Steps). %% mv(sosud(_Id, <span class="hljs-keyword"><span class="hljs-keyword">Max</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>), sosud(_Id2, Max2, Current2), ...,...). %%      mv(sosud(Id1, Max1, <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>), sosud(Id2, Max2, Current2), sosud(Id1, Max1, <span class="hljs-number"><span class="hljs-number">0</span></span>), sosud(Id2, Max2, Current3)) :- <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, Current3 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Current2 + <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>, Current3 =&lt; Max2. %%        mv(sosud(Id1, Max1, <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>), sosud(Id2, Max2, Current2), sosud(Id1, Max1, Current3), sosud(Id2, Max2, Max2)) :- <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, Current3 <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Current2 + <span class="hljs-keyword"><span class="hljs-keyword">Current</span></span> - Max2, Current3 &gt;= <span class="hljs-number"><span class="hljs-number">0.</span></span></code> </pre><br><br>  Everything works now!  As an exercise, you can modify the program so that it finds transfusions in the optimal number of steps.  You can experiment here on these <a href="http://www.smekalka.pp.ru/weight.html">puzzles</a> . <br><br>  <b>Note</b> : ardent supporters of imperative programming will notice that all we have done is going through all the states with returns (pass into depth), and without using heuristics, they will be absolutely right.  The fact is that you need to think in Prolog not just by searching, but by describing the problem and describing the solution check, and you should always return to the imperativeness of the calculations for optimization, if you need it!  The duality of nature is not a minus, but a plus.  It is also worth noting that large Prolog systems are very well adapted for searching states with returns. <br><br><hr><br><h4>  Conclusion </h4><br><br>  I would like to note that the tasks discussed in this article are sketches for programming in Prolog.  Since most of them occupy about 10-15 lines, the Prolog programmer is able to reproduce them from memory with sufficiently frequent cutting of them.  And returning to them is definitely worth it, as it reminds of the art of programming (just like a quick sort on C).  More complex and more applied tasks for everyday use will be discussed later. <br><br>  <b>At the end there are 2 tasks for the prize</b> : <br><ol><li>  As is well known in the functional and logical in every way they try to avoid programs with side effects, wrap them in monads, invent special concepts.  The standard problem is the problem of the outside world, for example, writing data to a file, it is impossible to roll back the record to the file or to cancel sending several bytes on the socket, and therefore backtracking will not work completely correctly.  Council one - do not use the Prologue for these purposes.  But there are predicates that are very good and specific to Prolog, but have a side effect.  Example assert (asserta, assertz): it adds a simple rule (fact) to the rule (fact) base.  Example <i>assert (prime (3))</i> : adds the fact that 3 is a prime number and the query <i>: -prime (X)</i> will now issue 3, even with an empty source program. <br><br>  <b>The task</b> : to write a declarative version of <b>assert</b> , that is, when the backtracking program is returned, the fact should not remain in memory, but should work as a logical assumption. <br><br>  <b>Example of operation</b> : the query c (X) should output one number 4 for the next program! <br><pre> <code class="hljs swift"> a(<span class="hljs-type"><span class="hljs-type">X</span></span>) :- b(<span class="hljs-type"><span class="hljs-type">Y</span></span>), <span class="hljs-type"><span class="hljs-type">X</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-type"><span class="hljs-type">Y</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span> . <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>(<span class="hljs-type"><span class="hljs-type">X</span></span>) :- my_assert(b(<span class="hljs-number"><span class="hljs-number">3</span></span>)), a(<span class="hljs-type"><span class="hljs-type">X</span></span>). <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>(<span class="hljs-type"><span class="hljs-type">X</span></span>) :- b(<span class="hljs-type"><span class="hljs-type">X</span></span>).</code> </pre><br></li><li>  In classical mathematical logic 2, theories are given much more attention than all the rest ‚Äî this is the <b>theory of sets</b> and the <b>theory of predicates</b> .  There is a definite connection between them, one is expressed through the other and vice versa.  For example, a predicate is a set of values ‚Äã‚Äãon which it is true, and vice versa a set is a membership predicate.  The traditional relational database theory operates on sets, and Prolog operates on predicates.  In general, the task is to express an absolutely traditional operation for set theory an operation ‚Äî the <b>operation of taking the set of all subsets</b> . <br><br> <b></b> :     a/1 (      ,   ),   subset_a/1,    ,     a. <br><br> <b></b> :  subset_a(X)  X = [], X = [1], X = [2], X = [1, 2] (  ): <br><pre> <code class="hljs css"> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>(1). <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span>(2). <span class="hljs-selector-tag"><span class="hljs-selector-tag">subset_a</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">X</span></span>) <span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:-</span></span> ....?</code> </pre><br></li></ol><br><br>  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/124820/">https://habr.com/ru/post/124820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../124810/index.html">AnonPlus social network from Anonymous hacked</a></li>
<li><a href="../124811/index.html">Google is going to open an office in Indonesia</a></li>
<li><a href="../124812/index.html">Mixcloud - mixes in the cloud</a></li>
<li><a href="../124814/index.html">Brakes iPhone 3G and consolidated.db</a></li>
<li><a href="../124819/index.html">VKontakte contacts with e-mail</a></li>
<li><a href="../124822/index.html">Mind is waiting</a></li>
<li><a href="../124826/index.html">How much does the lobby</a></li>
<li><a href="../124833/index.html">Microsoft Introduces Windows Azure Accelerator for Web Roles</a></li>
<li><a href="../124834/index.html">Nerd-o-meter - how to write tweets</a></li>
<li><a href="../124838/index.html">Outdated Kohana 3.2.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>