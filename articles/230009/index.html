<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hedgehog in fractal fog</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article is the last of my fractal series. In Habrastier "Drawing pictures with the Hilbert Curve," it was told about a kitten named Gav, in Habra...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hedgehog in fractal fog</h1><div class="post__text post__text-html js-mediator-article">  This article is the last of my fractal series.  In Habrastier <a href="http://habrahabr.ru/post/135344/">"Drawing pictures with the Hilbert Curve," it was</a> told about a kitten named Gav, in Habrastier <a href="http://habrahabr.ru/post/126869/">"Kosh on a complex plane"</a> - about the flow of fractals into the horizon, in Habrastier <a href="http://habrahabr.ru/post/240417/">"</a> Fractals <a href="http://habrahabr.ru/post/240417/">Night"</a> about the escape time algorithm.  In this article we will talk about a hedgehog in the fog and, of course, about the cat. <br><br><img src="https://habrastorage.org/files/60d/b86/6b9/60db866b931b48489e392bc3f2b445bb.png"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Anyone who has ever experienced a bit of fractals has seen beautiful pictures of Julia sets, which are defined by a square polynomial;  but it is interesting to solve the inverse problem: let there be some picture, and we go over it to come up with such a polynomial, which will give some approximation of the original picture.  A picture with a hedgehog above demonstrates this idea. <br><br>  So, consider the cat <i>K.</i> <br><br><img src="https://habrastorage.org/files/a87/3f8/df9/a873f8df96264a2fa6e38d197f2453c1.png"><br><br>  We need to come up with a polynomial <i>f</i> such that inside a cat the sequence <i>f</i> ( <i>z</i> ), <i>f</i> ( <i>f</i> ( <i>z</i> )), <i>f</i> ( <i>f</i> ( <i>f</i> ( <i>z</i> ))), ... is bounded, and outside the cat it tends to infinity.  For a long time I did not think about this question, but immediately looked on the Internet and found a wonderful article by <i>Kathryn A. Lindsey</i> , <i>‚ÄúShapes of polynomial Julia sets‚Äù</i> , 2013, <a href="">arXiv: 1209.0143</a> .  This article proves that for a <i>‚Äúgood‚Äù</i> cat and for a given accuracy Œ¥, such a polynomial can be invented, and the proof is constructive. <br><br>  Consider this design.  Let œÜ 'be a conformal mapping that the exterior of the unit circle translates into the exterior of a cat.  Let œÜ ( <i>z</i> ) = œÜ '((1 + Œµ) <i>z</i> ) be the original map corrected to some small Œµ. <br><br><img src="https://habrastorage.org/files/d18/545/85c/d1854585c55548ef9be45deed068a222.png"><br><br>  Further, let œâ ( <i>z</i> ) = <i>c</i> <sup>- <i>n</i></sup> ( <i>z</i> - <i>r</i> <sub>0</sub> ) ( <i>z</i> - <i>r</i> <sub>1</sub> ) ‚ãÖ‚Ä¶ ‚ãÖ ( <i>z</i> - <i>r</i> <sub><i>n</i> ‚àí1</sub> ), where <i>c</i> is the coefficient at <i>z</i> in the expansion of the map œÜ in the Laurent series, and <i>r</i> <sub><i>k</i></sub> = œÜ (e <sup>2œÄ <i>ik</i> / <i>n</i></sup> ) are images of roots of unit nth degree.  It is proved that the polynomial <i>f</i> ( <i>z</i> ) = <i>z</i> (œâ ( <i>z</i> ) + 1) is the desired one for sufficiently large <i>n</i> . <br><br>  Therefore, to solve our problem, it is necessary to learn how to generate the corresponding conformal mapping.  As a result of a small search on the Internet, the <a href="http://www.math.washington.edu/~marshall/zipper.html">zipper</a> package was found.  This package allows you to find a conformal mapping of the interior of the unit circle to the area bounded by the polyline.  Although this package was written twenty years ago <abbr title="on FORTRAN">in an ancient dialect</abbr> , it was not difficult to assemble it and use it. <br><br><div class="spoiler">  <b class="spoiler_title">A piece of ancient dialect</b> <div class="spoiler_text"><pre><code class="hljs delphi">call invers <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>,*)z1,z2,z3,zrot1,zto0,zto1,angler,zrot2 <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-number"><span class="hljs-number">981</span></span> j=<span class="hljs-number"><span class="hljs-number">4</span></span>,n-<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">981</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">999</span></span>)a(j),b(j),c(j) zm=dcmplx(<span class="hljs-number"><span class="hljs-number">0</span></span>.d0,<span class="hljs-number"><span class="hljs-number">0</span></span>.d0) ierr=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-number"><span class="hljs-number">982</span></span> j=<span class="hljs-number"><span class="hljs-number">1</span></span>,n <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(cdabs(zm-z(j)).lt.<span class="hljs-number"><span class="hljs-number">1</span></span>.d-<span class="hljs-number"><span class="hljs-number">16</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ierr=<span class="hljs-number"><span class="hljs-number">1</span></span> jm=j-<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span><span class="hljs-comment"><span class="hljs-comment">(*,*)</span></span><span class="hljs-string"><span class="hljs-string">' WARNING: prevertices'</span></span>,j,<span class="hljs-string"><span class="hljs-string">' and'</span></span>,jm,<span class="hljs-string"><span class="hljs-string">' are equal'</span></span> endif zm=z(j) x=dreal(z(j)) y=dimag(z(j)) <span class="hljs-number"><span class="hljs-number">982</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">999</span></span>)x,y <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ierr.eq.<span class="hljs-number"><span class="hljs-number">1</span></span>)<span class="hljs-keyword"><span class="hljs-keyword">then</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Coat the zipper with python glue</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calc_phi</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(points)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"init.dat"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> output_file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> points: output_file.write(str(point.real) + <span class="hljs-string"><span class="hljs-string">" "</span></span> + str(point.imag) + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) output_file.write(<span class="hljs-string"><span class="hljs-string">"\n0.0 0.0\n"</span></span>) os.system(<span class="hljs-string"><span class="hljs-string">"echo \"init.dat\n200\npoly.dat\" | ./polygon"</span></span>) os.system(<span class="hljs-string"><span class="hljs-string">"./zipper"</span></span>) os.system(<span class="hljs-string"><span class="hljs-string">"rm init.dat"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform_points</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(points)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"fftpts.dat"</span></span>, <span class="hljs-string"><span class="hljs-string">"w"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> output_file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> points: output_file.write(str(point.real) + <span class="hljs-string"><span class="hljs-string">" "</span></span> + str(point.imag) + <span class="hljs-string"><span class="hljs-string">"\n"</span></span>) os.system(<span class="hljs-string"><span class="hljs-string">"echo \"0\nfftpts.dat\nfftpts.img\n0\" | ./forward"</span></span>) transformed_points = [] <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(<span class="hljs-string"><span class="hljs-string">"fftpts.img"</span></span>, <span class="hljs-string"><span class="hljs-string">"r"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> input_file: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> input_file.readlines(): x, y = float(line[<span class="hljs-number"><span class="hljs-number">0</span></span>:<span class="hljs-number"><span class="hljs-number">25</span></span>]), float(line[<span class="hljs-number"><span class="hljs-number">25</span></span>:]) transformed_points.append(complex(x, y)) os.system(<span class="hljs-string"><span class="hljs-string">"rm fftpts.dat"</span></span>) os.system(<span class="hljs-string"><span class="hljs-string">"rm fftpts.img"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> transformed_points</code> </pre></div></div><br>  To use this package, you need to build a broken line in the image.  I didn‚Äôt do some kind of automatic solution, but loaded the image into Inkscape editor and circled it, and parsing the SVG format is simple.  This is convenient in that it allows you to experiment with a polyline. <br><br><div class="spoiler">  <b class="spoiler_title">Parsim paths in SVG file</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read_points_from_svg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file_name, path_n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> open(file_name, <span class="hljs-string"><span class="hljs-string">"r"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> input_file: content = input_file.read() soup = BeautifulSoup.BeautifulSoup(content) path = soup.findAll(<span class="hljs-string"><span class="hljs-string">"path"</span></span>)[path_n] data = path.get(<span class="hljs-string"><span class="hljs-string">"d"</span></span>).split(<span class="hljs-string"><span class="hljs-string">" "</span></span>) x, y = <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span> is_move_to = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> is_relative = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> points = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> d == <span class="hljs-string"><span class="hljs-string">"m"</span></span>: is_move_to = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> is_relative = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> d == <span class="hljs-string"><span class="hljs-string">"M"</span></span>: is_move_to = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> is_relative = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> d == <span class="hljs-string"><span class="hljs-string">"z"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> d == <span class="hljs-string"><span class="hljs-string">"Z"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> d == <span class="hljs-string"><span class="hljs-string">"l"</span></span>: is_move_to = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> is_relative = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> d == <span class="hljs-string"><span class="hljs-string">"L"</span></span>: is_move_to = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> is_relative = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: dx, dy = d.split(<span class="hljs-string"><span class="hljs-string">","</span></span>) dx = float(dx) dy = float(dy) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_move_to: x = dx y = dy is_move_to = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_relative: x += dx y += dy <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: x = dx y = dy points.append(complex(x, y)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> points</code> </pre></div></div><br><img src="https://habrastorage.org/files/edc/660/b11/edc660b117ac4c859df166c93d01ddff.png" width="640" height="485"><br><br>  Next, we need a mapping from the exterior to the exterior, and the package finds the mapping from the inside to the inside.  Here you just need to pair the generated map with the inverse.  That is, œÜ '( <i>z</i> ) = 1 / (1 / <i>z</i> ), where œà is the map that generates the packet.  And it is necessary to feed the already inverted broken line to the input of the packet. <br><br><div class="spoiler">  <b class="spoiler_title">We mate</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert_points_1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(points, epsilon)</span></span></span><span class="hljs-function">:</span></span> inverted_points = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> points: inverted_points.append(<span class="hljs-number"><span class="hljs-number">1</span></span> / ((<span class="hljs-number"><span class="hljs-number">1</span></span> + epsilon)*point)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inverted_points <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invert_points_2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(points, shift)</span></span></span><span class="hljs-function">:</span></span> inverted_points = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> points: inverted_points.append(<span class="hljs-number"><span class="hljs-number">1</span></span> / point + shift) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inverted_points <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: ... inverted_points = invert_points_1(points, epsilon) transformed_points = transform_points(inverted_points) inverted_transformed_points = invert_points_2(transformed_points, shift)</code> </pre></div></div><br><img src="https://habrastorage.org/files/2f0/4f6/1ee/2f04f61eeee140b488291b1b43a59580.png"><br><br>  In the definition of the polynomial <i>f</i> , the coefficient <i>c is</i> also involved.  For an approximate calculation of its value, we use the following technique.  Let be <br><br>  <i>f</i> ( <i>z</i> ) = <i>c</i> <i>z</i> + <i>a</i> + <i>a</i> <sub>1</sub> / <i>z</i> + <i>a</i> <sub>2</sub> / <i>z</i> <sup>2</sup> + <i>a</i> <sub>3</sub> / <i>z</i> <sup>3</sup> + ... <br><br>  Consider some finite, but rather large, part of this series.  Substitute in a series of values ‚Äã‚Äãof the roots of units of <i>n</i> -th degree, where <i>n is</i> greater than the number of members of this piece. <br><br>  <i>f</i> (e <sup>2œÄ <i>ik</i> / <i>n</i></sup> ) = <i>c</i> e <sup>2œÄ <i>ik</i> / <i>n</i></sup> + <i>a</i> + <i>a</i> <sub>1</sub> e <sup>‚àí2œÄ <i>ik</i> / <i>n</i></sup> + <i>a</i> <sub>2</sub> e <sup>‚àí4œÄ <i>ik</i> / <i>n</i></sup> + <i>a</i> <sub>3</sub> e ‚àí <sup>6œÄ <i>ik</i> / <i>n</i></sup> + ..., <i>k</i> = 0, ..., <i>n</i> - 1. <br><br>  Now multiply each line by e <sup>‚àí2œÄ <i>ik</i> / <i>n</i></sup> and add all the lines.  Since the sum of all roots of a unit is 0, only <i>n</i> <i>c</i> will remain on the right.  Therefore, we can put <br><br>  c = ( <i>f</i> (1) ‚ãÖ 1 + <i>f</i> (e <sup>2œÄ <i>i</i> / <i>n</i></sup> ) e <sup>‚àí2œÄ <i>i</i> / <i>n</i></sup> +‚Ä¶ + <i>f</i> (e <sup>2œÄ <i>i</i> ( <i>n</i> - 1) / <i>n</i></sup> ) e <sup>‚àí2œÄ <i>i</i> ( <i>n</i> - 1) / <i>n</i></sup> )) / <i>n</i> . <br><br>  Putting it all together and check what happened.  The figure below shows the ‚Äúthermal‚Äù graph of the logarithm of the module <i>f</i> ( <i>z</i> ) (the redder, the greater the value).  As you can see, inside the cat the values ‚Äã‚Äãof the polynomial are small, and outside the cat the polynomial increases, so it should be.  Notice also how the values ‚Äã‚Äãof f (e <sup>2œÄ <i>ik</i> / <i>n</i></sup> ) are distributed (green dots), because of this effect I had to draw a cat whose legs are far enough apart from each other. <br><br><img src="https://habrastorage.org/files/7cf/b9e/503/7cfb9e5037a24493be829193836cb35f.png"><br><br>  Now we simply use some kind of algorithm to draw the Julia set and get a cat whose boundary is fractal. <br><br><div class="spoiler">  <b class="spoiler_title">For example, the escape time algorithm</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(points, z, radius)</span></span></span><span class="hljs-function">:</span></span> result = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> point <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> points: result *= (z - point) / radius <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> z * (<span class="hljs-number"><span class="hljs-number">1</span></span> + result) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_radius</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(points)</span></span></span><span class="hljs-function">:</span></span> n = len(points) result = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): result += points[k] * cmath.exp(<span class="hljs-number"><span class="hljs-number">-2j</span></span>*math.pi*k/n) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result / n <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">draw_fractal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(image, points, scale, shift, bound, max_num_iter, radius)</span></span></span><span class="hljs-function">:</span></span> width, height = image.size draw = ImageDraw.Draw(image) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, height): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">0</span></span>, width): z = (complex(x, y) - shift) * scale n = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> abs(z) &lt; bound <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> n &lt; max_num_iter: z = get_value(points, z, radius) n += <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; max_num_iter: color = ((<span class="hljs-number"><span class="hljs-number">100</span></span> * n) % <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span> + (<span class="hljs-number"><span class="hljs-number">50</span></span> * n) % <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span> + (<span class="hljs-number"><span class="hljs-number">75</span></span> * n) % <span class="hljs-number"><span class="hljs-number">255</span></span>) draw.point((x, y), color)</code> </pre></div></div><br><img src="https://habrastorage.org/files/3c5/d02/fff/3c5d02fff5c4465db886c8a3173b3d4f.png"><br><br>  If our image consists of several areas <i>A</i> <sub>1</sub> , <i>A</i> <sub>2</sub> , ..., <i>A</i> <sub><i>q</i></sub> , then in the above article it is proposed to use instead of a polynomial a rational map <i>f</i> ( <i>z</i> ) defined as follows.  For each region <sub><i>Ar</i></sub> , we write the product œâ <sub><i>r</i></sub> ( <i>z</i> ) as above.  Then the desired rational function <i>f</i> ( <i>z</i> ) is defined by the formula <i>f</i> ( <i>z</i> ) = <i>z</i> / (1 / œâ <sub>1</sub> ( <i>z</i> ) +‚Ä¶ + 1 / œâ <sub><i>q</i></sub> ( <i>z</i> )). <br><br>  For example, suppose we have a hedgehog in the fog <i>E.</i> <br><br><img src="https://habrastorage.org/files/f1f/a5f/d59/f1fa5fd5932c437b9e37ee9660a70d2f.png"><br><br>  We will circle the hedgehog and the hill (the lower border of the hill is outside the picture). <br><br><img src="https://habrastorage.org/files/6b9/2a7/49d/6b92a749d7fe4728925e1bf350343c0b.png"><br><br>  Hedgehog in a vacuum. <br><br><img src="https://habrastorage.org/files/813/b57/30f/813b5730f3b3461a8b62cb4cad5e71f7.png"><br><br>  A hill without a hedgehog. <br><br><img src="https://habrastorage.org/files/8cb/67f/331/8cb67f331bc742658fadf5cea7bad356.png"><br><br>  Together. <br><br><img src="https://habrastorage.org/files/271/41b/548/27141b54811a4fd5bee95a48d8c65c0b.png"><br><br>  Enlarged belly of a hedgehog with fleas, hedgehogs. <br><br><img src="https://habrastorage.org/files/5d0/0b2/65c/5d00b265c19a43f197f76f82d18eaaff.png"><br><br>  As always, the source code can be found on a <a href="https://github.com/mkotov/CheshireCat">githaba</a> . <br><br>  I repeat the link to the article with the help of which everything turned out: <i>Kathryn A. Lindsey</i> , <i>‚ÄúShapes of polynomial Julia sets‚Äù</i> , 2013, <a href="">arXiv: 1209.0143</a> .  I note, the article is easy to read, so you can pick up the evidence for a cup of tea. <br><br>  I hope it was fun. <br><br><div class="spoiler">  <b class="spoiler_title">Failed doubles</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/689/4ad/c6e/6894adc6eee44915a32eb0b1784fed3f.png"><br><br><img src="https://habrastorage.org/files/ee4/68b/e87/ee468be87d5341039aed310621a00870.png"><br><br><img src="https://habrastorage.org/files/e99/516/e21/e99516e216684128bc78617ad6268d4d.png"><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/230009/">https://habr.com/ru/post/230009/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../229997/index.html">Project Management Books</a></li>
<li><a href="../229999/index.html">Google Play Books in Ukraine</a></li>
<li><a href="../230001/index.html">Attracting investment in a startup - the book of Feld and Mendelssohn</a></li>
<li><a href="../230003/index.html">Syndrome of a step and a cut of attendance of Habr</a></li>
<li><a href="../230007/index.html">Hackathon @ JetBrains 2014</a></li>
<li><a href="../230011/index.html">Mobile phone-based air pollution detector: developed from Germany</a></li>
<li><a href="../230015/index.html">Updating Windows Phone Silverlight 8.0 application to Windows Phone Silverlight 8.1</a></li>
<li><a href="../230019/index.html">How to prepare for a technical report</a></li>
<li><a href="../230021/index.html">InfoboxCloud - a public Russian ‚Äúcloud‚Äù in a data center that has received TIER III Facility & Design certification</a></li>
<li><a href="../230023/index.html">Effective personalized access to network infrastructure. An example implementation from HP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>