<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>GPU Particles using Compute and Geometry Shaders</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello dear reader! 

 Today we will continue to study the graphics pipeline, and I will talk about such wonderful things as Compute Shader and Geometr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>GPU Particles using Compute and Geometry Shaders</h1><div class="post__text post__text-html js-mediator-article">  Hello dear reader! <br><br>  Today we will continue to study the graphics pipeline, and I will talk about such wonderful things as <b>Compute Shader</b> and <b>Geometry Shader</b> using the example of creating a system for <b>1000000+</b> particles, which in turn are not points, but squares ( <i>billboard quads</i> ) and have their own texture.  In other words, we will derive <b>2000000+</b> textured triangles with <b>FPS&gt; 100</b> (on a budget <i>GeForce 550 Ti</i> video <i>card</i> ). <br><br><img src="https://habrastorage.org/files/740/6a1/afc/7406a1afcd474664b90678520b39ae41.png"><br><a name="habracut"></a><br><h1>  Introduction </h1><br>  I wrote a lot about shaders among my articles, but we always operated on only two types: <b>Vertex Shader</b> , <b>Pixel Shader</b> .  However, with the advent of <i>DX10 +</i> , new types of shaders have appeared: <i>Geometry Shader, Domain Shader, Hull Shader, Compute Shader</i> .  Just in case, let me remind you what the graphics pipeline looks like now: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/f54/d16/0e9/f54d160e949342b4bf938e41bdf39619.png"><br><br>  At once I will make a reservation that in this article we will not touch on <i>Domain Shader</i> and <i>Hull Shader</i> , I will write about tessellation in the following articles. <br><br>  Only <i>Geometry Shader</i> remains unexplored.  What is a <i>Geometry Shader</i> ? <br><br><h1>  Chapter 1: Geometry Shader </h1><br>  <i>Vertex Shader</i> is engaged in processing vertices, <i>Pixel Shader</i> is engaged in processing pixels, and as you can guess, <i>Geometry Shader</i> is engaged in processing primitives. <br><br>  This shader is an optional part of the pipeline, i.e.  it may not be at all: verteks directly go to the <i>Primitive Assembly Stage</i> and the rasterization of the primitive goes on. <br>  Geometry Shader is located between the <i>Primitive Assembly Stage</i> and the <i>Rasterizer Stage</i> . <br><br>  At the entrance, he can get information both about the assembled primitive and about neighboring primitives: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f2b/c7f/3c3/f2bc7f3c370f3786da4a62fbf4484cf8.png" alt="image"><br><br>  At the exit we have a stream of primitives, where we in turn add a primitive.  Moreover, the type of the returned primitive may differ from the input.  For example - we receive <b>Point</b> , we return <b>Line</b> .  An example of a simple geometric shader that does nothing and simply connects the input to the output: <br><br><pre><code class="hljs pgsql">struct PixelInput { <span class="hljs-type"><span class="hljs-type">float4</span></span> Position : SV_POSITION; //  <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>   }; [maxvertexcount(<span class="hljs-number"><span class="hljs-number">1</span></span>)] //  - ,     <span class="hljs-type"><span class="hljs-type">void</span></span> SimpleGS( <span class="hljs-type"><span class="hljs-type">point</span></span> PixelInput <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">inout</span></span> PointStream&lt;PixelInput&gt; stream ) { PixelInput pointOut = <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; //   stream.Append(pointOut); //   stream.RestartStrip(); //   ( <span class="hljs-type"><span class="hljs-type">Point</span></span> ‚Äì   ) }</code> </pre> <br><h1>  Chapter 2: StructuredBuffer </h1><br>  <i>DirectX10 +</i> has such a type of buffers as <i>Structured Buffer</i> , such a buffer can be described by a programmer as he pleases, i.e.  in the very classical sense, it is a homogeneous array of structures of a certain type, which is stored in the memory of the <i>GPU</i> . <br><br>  Let's try to create a similar buffer for our particle system.  Let's describe what properties a particle has ( <i>on the C # side</i> ): <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GPUParticleData</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Vector3</span></span> <span class="hljs-type"><span class="hljs-type">Position</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-type"><span class="hljs-type">Vector3</span></span> <span class="hljs-type"><span class="hljs-type">Velocity</span></span>; };</code> </pre> <br>  And create the buffer itself ( <i>using the SharpDX.Toolkit helper</i> ): <br><br><pre> <code class="hljs vhdl">_particlesBuffer = <span class="hljs-keyword"><span class="hljs-keyword">Buffer</span></span>.Structured.<span class="hljs-keyword"><span class="hljs-keyword">New</span></span>&lt;GPUParticleData&gt;(graphics, initialParticles, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Where <b>initialParticles</b> is an array of <b>GPUParticleData</b> with the size of the desired number of particles. <br><br>  It is worth noting that the flags when creating the buffer are set as follows: <br><br>  <i>BufferFlags.ShaderResource</i> - to be able to access the buffer from the shader <br>  <i>BufferFlags.StructuredBuffer</i> - indicates the buffer belongs <br>  <i>BufferFlags.UnorderedAccess</i> - for the ability to change the buffer from the shader <br><br>  Create a buffer with a size of <b>1,000,000</b> elements and fill it with random elements: <br><br><pre> <code class="hljs go">GPUParticleData[] initialParticles = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> GPUParticleData[PARTICLES_COUNT]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; PARTICLES_COUNT; i++) { initialParticles[i].Position = random.NextVector3(<span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-30f</span></span>, <span class="hljs-number"><span class="hljs-number">-30f</span></span>, <span class="hljs-number"><span class="hljs-number">-30f</span></span>), <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">30f</span></span>, <span class="hljs-number"><span class="hljs-number">30f</span></span>, <span class="hljs-number"><span class="hljs-number">30f</span></span>)); }</code> </pre> <br>  After that, we will store a buffer of <b>1,000,000</b> elements with random values ‚Äã‚Äãin the memory of the <i>GPU</i> . <br><br><h1>  Chapter 3. Render Point-Particles </h1><br>  Now we need to figure out how to draw this buffer?  After all, we do not even have vertices!  We will generate vertexes on the go, based on the values ‚Äã‚Äãof our structural buffer. <br><br>  Create two shaders - <i>Vertex Shader</i> and <i>Pixel Shader</i> . <br>  First, let's describe the input data for shaders: <br><br><pre> <code class="hljs ruby">struct Particle /<span class="hljs-regexp"><span class="hljs-regexp">/    GPU { float3 Position; float3 Velocity; }; StructuredBuffer&lt;Particle&gt; Particles : register(t0); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   cbuffer Params : register(b0) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     { float4x4 View; float4x4 Projection; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ..    ,     ID      Vertex Buffer struct VertexInput { uint VertexID : SV_VertexID; }; struct PixelInput /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      Vertex Shader { float4 Position : SV_POSITION; }; struct PixelOutput /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    { float4 Color : SV_TARGET0; };</span></span></code> </pre> <br>  Well, let's take a closer look at shaders, for starters, vertex: <br><br><pre> <code class="hljs pgsql">PixelInput DefaultVS(VertexInput <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) { PixelInput output = (PixelInput)<span class="hljs-number"><span class="hljs-number">0</span></span>; Particle particle = Particles[<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.VertexID]; <span class="hljs-type"><span class="hljs-type">float4</span></span> worldPosition = <span class="hljs-type"><span class="hljs-type">float4</span></span>(particle.Position, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> viewPosition = mul(worldPosition, <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>); output.Position = mul(viewPosition, Projection); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre> <br>  In this country of magic, we simply read a particular particle from the particle buffer according to the current <i>VertexID</i> (and we have it in the range from 0 to 999999) and using the position of the particle, we project it into the screen space. <br><br>  Well, with <i>Pixel Shader</i> easier than ever: <br><br><pre> <code class="hljs lua">PixelOutput DefaultPS(PixelInput <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>) { PixelOutput <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> = (PixelOutput)<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.Color = float4((float3)<span class="hljs-number"><span class="hljs-number">0.1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>; }</code> </pre> <br>  Set the color of the particle as <i>float4 (0.1, 0.1, 0.1, 1)</i> .  Why <i>0.1</i> ?  Because we have a million particles, and we will use <i>Additive Blending</i> . <br><br>  Set the buffers and draw the geometry: <br><br><pre> <code class="hljs ruby">graphics.ResetVertexBuffers(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      graphics.SetBlendState(_additiveBlendState); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  Additive Blend State /<span class="hljs-regexp"><span class="hljs-regexp">/       SRV ( ). _particlesRender.Parameters["Particles"].SetResource&lt;SharpDX.Direct3D11.ShaderResourceView&gt;(0, _particlesBuffer); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  _particlesRender.Parameters["View"].SetValue(camera.View); _particlesRender.Parameters["Projection"].SetValue(camera.Projection); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   _particlesRender.CurrentTechnique.Passes[0].Apply(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   1000000     graphics.Draw(PrimitiveType.PointList, PARTICLES_COUNT);</span></span></code> </pre> <br>  Well, and admire the first victory: <br><br><img src="http://habrastorage.org/files/eeb/450/c99/eeb450c9945c4b74826e330be50799d4.png"><br><br><h1>  Chapter 4: Render of QuadBillboard Particles </h1><br>  If you have not forgotten the first chapter, you can safely turn our set of points into full-fledged <i>Billboard</i> consisting of two triangles. <br><br>  I‚Äôll talk a little bit about what <i>QuadBillboard is</i> : this is a square made of two triangles and this square is always turned towards the camera. <br><br>  How to create this square?  We need to come up with an algorithm for quickly generating such squares.  Let's take a look at something in the <i>Vertex Shader</i> .  There we have three spaces when building the <i>SV_Position</i> : <br><br><ol><li>  <i>World Space</i> - vertex position in world coordinates </li><li>  <i>View Space</i> - vertex position in view coordinates </li><li>  <i>Projection Space</i> - vertex position in screen coordinates </li></ol><br><br>  <i>View Space</i> is just what we need, because these coordinates are just relative to the camera and the plane (-1 + px, -1 + py, pz) -&gt; (1 + px, 1 + py, pz) created in this space will always have a normal, which is aimed at the camera. <br><br>  Therefore, we‚Äôll change something in the shader: <br><br><pre> <code class="hljs pgsql">PixelInput TriangleVS(VertexInput <span class="hljs-keyword"><span class="hljs-keyword">input</span></span>) { PixelInput output = (PixelInput)<span class="hljs-number"><span class="hljs-number">0</span></span>; Particle particle = Particles[<span class="hljs-keyword"><span class="hljs-keyword">input</span></span>.VertexID]; <span class="hljs-type"><span class="hljs-type">float4</span></span> worldPosition = <span class="hljs-type"><span class="hljs-type">float4</span></span>(particle.Position, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-type"><span class="hljs-type">float4</span></span> viewPosition = mul(worldPosition, <span class="hljs-keyword"><span class="hljs-keyword">View</span></span>); output.Position = viewPosition; output.UV = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre> <br>  At the output of <i>SV_Position,</i> we will transmit not a <i>ProjectionSpace-position</i> , but a <i>ViewSpace-position</i> , in order to create new primitives in the <i>Geometry Shader</i> in the <i>ViewSpace</i> . <br><br>  Add a new stage: <br><br><pre> <code class="hljs haskell">//         <span class="hljs-type"><span class="hljs-type">Projection</span></span> <span class="hljs-type"><span class="hljs-type">Space</span></span> <span class="hljs-type"><span class="hljs-type">PixelInput</span></span> _offsetNprojected(<span class="hljs-type"><span class="hljs-type">PixelInput</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">, float2 offset, float2 uv) { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Position</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xy</span></span></span><span class="hljs-class"> += </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">offset</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Position</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mul</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Position</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Projection</span></span></span><span class="hljs-class">); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UV</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uv</span></span></span><span class="hljs-class">; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">return</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">; } [maxvertexcount(4)] //   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">GS</span></span></span><span class="hljs-class"> ‚Äì 4 ,   </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TriangleStrip</span></span></span><span class="hljs-class"> void </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TriangleGS</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PixelInput</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">[1], </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">inout</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TriangleStream</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PixelInput</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream</span></span></span><span class="hljs-class"> ) { </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PixelInput</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pointOut</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">input</span></span></span><span class="hljs-class">[0]; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class"> = 0.1</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class">; //    //   </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Append</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_offsetNprojected</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pointOut</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float2</span></span></span><span class="hljs-class">(-1,-1) * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float2</span></span></span><span class="hljs-class">(0, 0)) ); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Append</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_offsetNprojected</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pointOut</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float2</span></span></span><span class="hljs-class">(-1, 1) * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float2</span></span></span><span class="hljs-class">(0, 1)) ); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Append</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_offsetNprojected</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pointOut</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float2</span></span></span><span class="hljs-class">( 1,-1) * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float2</span></span></span><span class="hljs-class">(1, 0)) ); </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Append</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">_offsetNprojected</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pointOut</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float2</span></span></span><span class="hljs-class">( 1, 1) * </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">float2</span></span></span><span class="hljs-class">(1, 1)) ); //  </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TriangleStrip</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stream</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">RestartStrip</span></span></span><span class="hljs-class">(); }</span></span></code> </pre> <br>  Well, as we have now <i>UV</i> - we can read the texture in the pixel shader: <br><pre> <code class="hljs lua">PixelOutput TrianglePS(PixelInput <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>) { PixelOutput <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> = (PixelOutput)<span class="hljs-number"><span class="hljs-number">0</span></span>; float particle = ParticleTexture.Sample(ParticleSampler, <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>.UV).x * <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>.Color = float4((float3)particle, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>; }</code> </pre> <br>  Additionally, set the sampler and particle texture for the render: <br><br><pre> <code class="hljs css">_<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesRender</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Parameters</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">["ParticleSampler"]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetResource</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">SamplerState</span></span>&gt;(_<span class="hljs-selector-tag"><span class="hljs-selector-tag">particleSampler</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesRender</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Parameters</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">["ParticleTexture"]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetResource</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">Texture2D</span></span>&gt;(_<span class="hljs-selector-tag"><span class="hljs-selector-tag">particleTexture</span></span>);</code> </pre> <br>  Check, test: <br><br><img src="http://habrastorage.org/files/1d5/768/f7a/1d5768f7aa734f84a114375fa01b7f4e.png"><br><br><h1>  Chapter 5: Particle Movement </h1><br>  Now, everything is ready, we have a special buffer in the memory of the <i>GPU</i> and there is a particle render, built using the <i>Geometry Shader</i> , but such a system is static.  You can, of course, change the position on the <i>CPU</i> , just read the buffer data from the <i>GPU</i> every time, change it, and then load it back, but what kind of GPU Power can we talk about?  Such a system will not survive and 100,000 particles. <br><br>  And to work on the <i>GPU</i> with such buffers, you can use a special shader - <b>Compute Shader</b> .  It is outside the traditional <i>render-pipeline</i> and can be used separately. <br><br>  What is a <i>Compute Shader</i> ? <br><br>  In its own words, the <i>Compute Shader</i> is a special stage of the pipeline that replaces all the traditional ones (but can still be used with it), allows you to execute arbitrary code using the <i>GPU</i> , read / write data into buffers (including texture ).  Moreover, the execution of this code occurs as parallel as the developer sets up. <br><br>  Let's look at the execution of the simplest code: <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">numthreads(1, 1, 1)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DefaultCS</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> uint3 DTiD: SV_DispatchThreadID </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// DTiD.xyz -   // ...   } technique ComputeShader { pass DefaultPass { Profile = 10.0; ComputeShader = DefaultCS; } }</span></span></code> </pre> <br>  At the very beginning of the code is the <b>numthreads</b> field, which indicates the number of threads in the group.  For now, we will not use group streams and make sure that there is one stream per group. <br>  <i>uint3 DTiD.xyz</i> points to the current thread. <br><br>  The next step is to launch such a shader, it is performed as follows: <br><br><pre> <code class="hljs css">_<span class="hljs-selector-tag"><span class="hljs-selector-tag">effect</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CurrentTechnique</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Passes</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Apply</span></span>(); <span class="hljs-selector-tag"><span class="hljs-selector-tag">graphics</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>(1, 1, 1);</code> </pre> <br>  In the <i>Dispatch</i> method, we indicate how many groups of threads we should have, and the maximum number of each dimension is limited to <u>65536</u> .  And if we execute such a code, the shader code on the GPU will be executed once, because  we have 1 group of threads, in each group 1 stream.  If you put, for example, <i>Dispatch (5, 1, 1)</i> - the shader code on the <i>GPU</i> will be executed five times, 5 groups of streams, 1 stream in each group.  If at the same time change also <i>numthreads -&gt; (5, 1, 1)</i> , then the code will be executed 25 times, and in 5 groups of threads, in each group there are 5 threads.  More detail can be considered if you look at the picture: <br><br><img src="http://habrastorage.org/files/bc9/dab/3b9/bc9dab3b953e4ff49f74f7f47975e0ec.png"><br><br>  Now, back to the particle system, what do we have?  We have a one-dimensional array of 1,000,000 elements and the task is to process the positions of the particles.  Since  Since particles move independently of each other, this task can be very well parallelized. <br><br>  In <i>DX10</i> (we use this version of <i>CS</i> , to support <i>DX10</i> cards) the maximum number of flows per group of flows is <u>768</u> , and in all three dimensions.  I create <i>32 * 24 * 1 = 768</i> threads in total for each group of threads, i.e.  our one group is able to process <i>768</i> particles (1 stream - 1 particle).  Further, it is necessary to calculate how many flow groups one needs (taking into account the fact that one group will process 768 particles) in order to process the <i>N</i> -th number of particles. <br>  You can calculate it by the formula: <br><br><pre> <code class="hljs pgsql"><span class="hljs-type"><span class="hljs-type">int</span></span> numGroups = (PARTICLES_COUNT % <span class="hljs-number"><span class="hljs-number">768</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>) ? ((PARTICLES_COUNT / <span class="hljs-number"><span class="hljs-number">768</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>) : (PARTICLES_COUNT / <span class="hljs-number"><span class="hljs-number">768</span></span>); <span class="hljs-type"><span class="hljs-type">double</span></span> secondRoot= <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Math.Pow((<span class="hljs-type"><span class="hljs-type">double</span></span>)numGroups, (<span class="hljs-type"><span class="hljs-type">double</span></span>)(<span class="hljs-number"><span class="hljs-number">1.0</span></span> / <span class="hljs-number"><span class="hljs-number">2.0</span></span>)); secondRoot= <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Math.Ceiling(secondRoot); _groupSizeX = _groupSizeY = (<span class="hljs-type"><span class="hljs-type">int</span></span>)secondRoot;</code> </pre> <br>  After that, we can call <b>Dispatch (_groupSizeX, _groupSizeY, 1)</b> , and the shader will be able to process in parallel the Nth number of elements. <br><br>  To access a specific element use the formula: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> index = groupID.x * THREAD_IN_GROUP_TOTAL + groupID.y * GROUP_COUNT_Y * THREAD_IN_GROUP_TOTAL + groupIndex;</code> </pre> <br>  Below is the updated shader code: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Particle</span></span></span><span class="hljs-class"> {</span></span> float3 Position; float3 Velocity; }; cbuffer Handler : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(c0) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> GroupDim; uint MaxParticles; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DeltaTime; }; RWStructuredBuffer&lt;Particle&gt; Particles : <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>(u0); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> THREAD_GROUP_X 32 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> THREAD_GROUP_Y 24 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> THREAD_GROUP_TOTAL 768 [numthreads(THREAD_GROUP_X, THREAD_GROUP_Y, 1)] void DefaultCS( uint3 groupID : SV_GroupID, uint groupIndex : SV_GroupIndex ) { uint index = groupID.x * THREAD_GROUP_TOTAL + groupID.y * GroupDim * THREAD_GROUP_TOTAL + groupIndex; [flatten] </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(index &gt;= MaxParticles) return; Particle particle = Particles[index]; float3 position = particle.Position; float3 velocity = particle.Velocity; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// payload particle.Position = position + velocity * DeltaTime; particle.Velocity = velocity; Particles[index] = particle; } technique ParticleSolver { pass DefaultPass { Profile = 10.0; ComputeShader = DefaultCS; } }</span></span></span></span></code> </pre> <br>  Another magic happens here, we use our particle buffer as a special resource: <i>RWStructuredBuffer</i> , this means that we can read and write to this buffer. <br>  <b>(!)</b> Prerequisite for writing - this buffer must be marked with the <i>UnorderedAccess</i> flag <i>when created</i> . <br><br>  Well, the final stage, we set the resource for the shader as <i>UnorderedAccessView to</i> our buffer and call <i>Dispatch</i> : <br><br><pre> <code class="hljs css"><span class="hljs-comment"><span class="hljs-comment">/* SOLVE PARTICLES */</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesSolver</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Parameters</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">["GroupDim"]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetValue</span></span>(_<span class="hljs-selector-tag"><span class="hljs-selector-tag">threadGroupSize</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesSolver</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Parameters</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">["MaxParticles"]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetValue</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">PARTICLES_COUNT</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesSolver</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Parameters</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">["DeltaTime"]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetValue</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">deltaTime</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesSolver</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Parameters</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">["Particles"]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.SetResource</span></span>&lt;<span class="hljs-selector-tag"><span class="hljs-selector-tag">SharpDX</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Direct3D11</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UnorderedAccessView</span></span>&gt;(0, _<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesBuffer</span></span>); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesSolver</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CurrentTechnique</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Passes</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Apply</span></span>(); <span class="hljs-selector-tag"><span class="hljs-selector-tag">graphics</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Dispatch</span></span>( _<span class="hljs-selector-tag"><span class="hljs-selector-tag">threadSize</span></span>, _<span class="hljs-selector-tag"><span class="hljs-selector-tag">threadSize</span></span>, 1); _<span class="hljs-selector-tag"><span class="hljs-selector-tag">particlesSolver</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.CurrentTechnique</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Passes</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[0]</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.UnApply</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">false</span></span>);</code> </pre> <br>  <u>After completing the execution of the code, it is necessary to remove the <i>UnorderedAccessView</i> from the shader, otherwise we will not be able to use it!</u> <br><br>  Let's do something with particles, we will write the simplest solver: <br><br><pre> <code class="hljs swift">float3 _calculate(float3 anchor, float3 position) { float3 direction = anchor - position; float <span class="hljs-built_in"><span class="hljs-built_in">distance</span></span> = length(direction); direction /= <span class="hljs-built_in"><span class="hljs-built_in">distance</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> direction * <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>(<span class="hljs-number"><span class="hljs-number">0.01</span></span>, (<span class="hljs-number"><span class="hljs-number">1</span></span> / (<span class="hljs-built_in"><span class="hljs-built_in">distance</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">distance</span></span>))); } <span class="hljs-comment"><span class="hljs-comment">// main { ... velocity += _calculate(Attractor, position); velocity += _calculate(-Attractor, position); ... }</span></span></code> </pre> <br>  <i>Attractor</i> we will set in the constant buffer. <br><br>  Compile, run and admire: <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/S-2HoaLT1E8%3Ffeature%3Doembed&amp;xid=17259,15700021,15700186,15700191,15700253&amp;usg=ALkJrhgra1K-bwkL63g42nFxf4kuGZDPLw" frameborder="0" allowfullscreen=""></iframe><br><br><h1>  Conclusion 1 </h1><br>  If we talk about particles, then nothing prevents you from creating a full-fledged and powerful system of particles: the points are easy enough to sort (to ensure transparency), to apply the <i>soft particles</i> technique when drawing, and also to take into account the lighting of ‚Äúnon-luminous‚Äù particles.  Computational shaders are mainly used to create the <b>Bokeh Blur</b> effect (we also need geometric ones), to create a <b>Tiled Deferred Renderer</b> , etc.  Geometric shaders, for example, can be used when you need to generate a lot of geometry.  The most striking example is grass and particles.  By the way, the use of <i>GS</i> and <i>CS are</i> endless and limited only by the imagination of the developer. <br><br><h1>  Conclusion 2 </h1><br>  Traditionally, I attach the full <a href="">source code</a> and <a href="">demo</a> to the post. <br>  PS to run the demo - you need a video card with support for DX10 and Compute Shader. <br><br><h1>  Conclusion 3 </h1><br>  <i>I am very pleased when people show interest in what I write.</i>  <i>And the reaction to the article is very important for me, be it in the form of a plus or a minus with a constructive comment.</i>  <i>So I can determine which topics are more interesting for the habrasoobshchestvo, and which are not.</i> </div><p>Source: <a href="https://habr.com/ru/post/248755/">https://habr.com/ru/post/248755/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../248737/index.html">Horizontal websocket scaling in Ruby</a></li>
<li><a href="../248741/index.html">Data tidying: Preparing Data Sets for Case-Based Analysis</a></li>
<li><a href="../248745/index.html">Lectures Technopark. 1 semester Web technologies</a></li>
<li><a href="../248747/index.html">Testing with Microsoft tools - field experience</a></li>
<li><a href="../248753/index.html">How to bypass the main difficulties in porting CAD applications to nanoCAD?</a></li>
<li><a href="../248761/index.html">Browser-in-browser will make the site much safer.</a></li>
<li><a href="../248765/index.html">Microsoft has joined the Student Developer Pack and some other GitHub Education news.</a></li>
<li><a href="../248767/index.html">The digest of interesting materials for the mobile developer # 87 (on January 19-25)</a></li>
<li><a href="../248769/index.html">Wordpress</a></li>
<li><a href="../248775/index.html">Age of JIT compiling. Part I. Genesis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>