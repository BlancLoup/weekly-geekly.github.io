<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Very large postgres</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It just so happened that recently I had to deal with optimization and scaling of various systems. One of the tasks was scaling PostgreSQL. How does DB...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Very large postgres</h1><div class="post__text post__text-html js-mediator-article">  It just so happened that recently I had to deal with optimization and scaling of various systems.  One of the tasks was scaling PostgreSQL.  How does DB optimization usually occur?  Probably, first of all, they look at how to choose the optimal settings for work and what indices can be created.  If we didn‚Äôt do a little with blood, we‚Äôve transferred to increasing server capacity, moving log files to a separate disk, load balancing, partitioning tables into partitions, and all kinds of refactoring and model redesign.  And now everything is perfectly tuned, but there comes a time when all these movements are not enough.  What to do next?  Horizontal scaling and sharding data. <br><br><img src="https://habrastorage.org/files/fa9/f33/091/fa9f330913c0462c8f576393f4135ec6.jpg"><br><a name="habracut"></a><br>  I want to share my experience in deploying a horizontally scalable cluster on a Postgres-XL database. <br><br>  <b>Postgres-XL</b> is an excellent tool that allows you to combine several PostgreSQL clusters in such a way that they work as a single instance DB.  For a client that connects to the database, there is no difference whether it works with a single PostgreSQL instance or with a Postgres-XL cluster.  Postgres-XL offers 2 modes of spreading tables across a cluster: replication and sharding.  During replication, all nodes contain the same copy of the table, and when sharding, data is evenly distributed among the cluster members.  The current implementation is based on PostgreSQL-9.2.  So almost all features of version 9.2 will be available to you. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Terminology </h4><br>  Postgres-XL consists of three types of components: global transaction monitor ( <abbr title="Global Transaction Manager">GTM</abbr> ), coordinator (coordinator) and data node (datanode). <br><br>  <abbr title="Global Transaction Manager"><b>GTM</b></abbr> is responsible for enforcing ACID requirements.  Responsible for issuing identifiers.  Since it is a single point of failure, it is recommended to prop up using GTM Standby.  Dedicating a separate server for GTM is a good idea.  To merge multiple requests and responses from coordinators and data nodes running on the same server, it makes sense to configure GTM-Proxy.  This reduces the load on GTM as the total number of interactions with it decreases. <br><br>  <b>The coordinator</b> is the central part of the cluster.  It is with him that the client application interacts.  Manages user sessions and interacts with GTM and data nodes.  Parse requests, builds a query execution plan and sends it to each of the components involved in the request, collects the results and sends them back to the client. The coordinator does not store any user data.  It stores only the service data to determine how to handle queries, where the data nodes are located.  If one of the coordinators fails, you can simply switch to another. <br><br>  <b>The data node</b> is the place where user data and indexes are stored.  Communication with data nodes is carried out only through coordinators.  For high availability, you can back up each stanby node with a server. <br><br><img src="https://habrastorage.org/files/53f/a77/c46/53fa77c4683c4f08837eeb944a84ff56.jpg"><br><br>  <a href="http://www.pgpool.net/">Pgpool-II</a> can be used as a load balancer.  It has already been discussed a lot on its configuration, for example, <a href="http://habrahabr.ru/post/188096/">here</a> and <a href="http://habrahabr.ru/post/213409/">here It‚Äôs</a> good practice to install a coordinator and a data node on one machine, since we don‚Äôt need to worry about load balancing and data from replicated tables can be obtained on site without sending an additional request over the network. <br><br><h4>  Test cluster layout </h4><br><img src="https://habrastorage.org/files/4ae/376/a10/4ae376a10a144adb84408975d5201861.png"><br><br>  Each node is a virtual machine with modest hardware: MemTotal: 501284 kB, cpu MHz: 2604. <br><br><h4>  Installation </h4><br>  Everything is standard here: download the source from <a href="http://www.postgres-xl.org/download/">offsite</a> , deliver dependencies, compile.  Collected on Ubuntu server 14.10. <br><br><pre><code class="bash hljs">$ sudo apt-get install flex bison docbook-dsssl jade iso8879 docbook libreadline-dev zlib1g-dev $ ./configure --prefix=/home/<span class="hljs-variable"><span class="hljs-variable">${USER}</span></span>/Develop/utils/postgres-xl --<span class="hljs-built_in"><span class="hljs-built_in">disable</span></span>-rpath $ make world</code> </pre> <br>  After the package is assembled, we upload it to the cluster nodes and proceed to setting up the components. <br><br><h4>  GTM customization </h4><br>  To ensure fault tolerance, consider an example with setting up two GTM servers.  On both servers we create a working directory for GTM and initialize it. <br><br><pre> <code class="bash hljs">$ mkdir ~/gtm $ initgtm -Z gtm -D ~/gtm/</code> </pre><br>  Then go to configuring configs: <br><br>  <b>gtm1</b> <br><div class="spoiler">  <b class="spoiler_title">gtm.conf</b> <div class="spoiler_text">  ... <br>  nodename = 'gtm_master' <br>  listen_addresses = '*' <br>  port = 6666 <br>  startup = ACT <br>  log_file = 'gtm.log' <br>  ... <br></div></div><br>  <b>gtm2</b> <br><div class="spoiler">  <b class="spoiler_title">gtm.conf</b> <div class="spoiler_text">  ... <br>  nodename = 'gtm_slave' <br>  listen_addresses = '*' <br>  port = 6666 <br>  startup = STANDBY <br>  active_host = 'gtm1' <br>  active_port = 6666 <br>  log_file = 'gtm.log' <br>  ... <br></div></div><br>  Save, start: <br><br><pre> <code class="bash hljs">$ gtm_ctl start -Z gtm -D ~/gtm/</code> </pre><br>  In the logs we observe records: <br>  <i>LOG: Started to run as GTM-Active.</i> <i><br></i>  <i>LOG: Started to run as GTM-Standby.</i> <br><br><h4>  GTM-Proxy Setup </h4><br><pre> <code class="bash hljs">$ mkdir gtm_proxy $ initgtm -Z gtm_proxy -D ~/gtm_proxy/ $ nano gtm_proxy/gtm_proxy.conf</code> </pre><br><div class="spoiler">  <b class="spoiler_title">gtm_proxy.conf</b> <div class="spoiler_text">  ... <br>  nodename = 'gtmproxy1' # the name must be unique <br>  listen_addresses = '*' <br>  port = 6666 <br>  gtm_host = 'gtm1' # specify the ip or host name on which the GTM master is deployed <br>  gtm_port = 6666 <br>  log_file = 'gtm_proxy.log' <br>  ... <br></div></div><br>  After editing the config, you can run: <br><br><pre> <code class="bash hljs">$ gtm_ctl start -Z gtm_proxy -D ~/gtm_proxy/</code> </pre><br><br><h4>  Setting up coordinators </h4><br><pre> <code class="bash hljs">$ mkdir coordinator $ initdb -D ~/coordinator/ -E UTF8 --locale=C -U postgres -W --nodename coordinator1 $ nano ~/coordinator/postgresql.conf</code> </pre><br><div class="spoiler">  <b class="spoiler_title">coordinator / postgresql.conf</b> <div class="spoiler_text">  ... <br>  listen_addresses = '*' <br>  port = 15432 <br>  pooler_port = 16667 <br>  gtm_host = '127.0.0.1' <br>  pgxc_node_name = 'coordinator1' <br>  ... <br></div></div><br><h4>  Data node setup </h4><br><pre> <code class="bash hljs">$ mkdir ~/datanode $ initdb -D ~/datanode/ -E UTF8 --locale=C -U postgres -W --nodename datanode1 $ nano ~/datanode/postgresql.conf</code> </pre><br><div class="spoiler">  <b class="spoiler_title">datanode / postgresql.conf</b> <div class="spoiler_text">  ... <br>  listen_addresses = '*' <br>  port = 25432 <br>  pooler_port = 26667 <br>  gtm_host = '127.0.0.1' <br>  pgxc_node_name = 'datanode1' <br>  ... <br></div></div><br>  For the remaining nodes, the setting is different only by specifying a different name. <br>  Now rule pg_hba.conf: <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"host all all 192.168.1.0/24 trust"</span></span> &gt;&gt; ~/datanode/pg_hba.conf <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"host all all 192.168.1.0/24 trust"</span></span> &gt;&gt; ~/coordinator/pg_hba.conf</code> </pre><br><h4>  Run and Tune-up </h4><br>  Everything is ready and can be run. <br><br><pre> <code class="bash hljs">$ pg_ctl start -Z datanode -D ~/datanode/ -l ~/datanode/datanode.log $ pg_ctl start -Z coordinator -D ~/coordinator/ -l ~/coordinator/coordinator.log</code> </pre><br>  We go to the coordinator: <br><br><pre> <code class="bash hljs">psql -p15432</code> </pre><br>  Execute the query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgxc_node;</code> </pre><br>  The request shows how the current server sees our cluster. <br>  Example output: <br><br><pre> <code class="sql hljs"> node_name | node_type | node_port | node_host | nodeis_primary | nodeis_preferred | node_id <span class="hljs-comment"><span class="hljs-comment">-------------+-----------+-----------+-----------+----------------+------------------+------------ coordinator1 | C | 5432 | localhost | f | f | 1938253334</span></span></code> </pre><br>  These settings are incorrect and can be safely removed. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgxc_node;</code> </pre><br>  Create a new display of our cluster: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> node coordinator1 <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=coordinator, host=<span class="hljs-string"><span class="hljs-string">'192.168.1.151'</span></span>, port=<span class="hljs-number"><span class="hljs-number">15432</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> node coordinator2 <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=coordinator, host=<span class="hljs-string"><span class="hljs-string">'192.168.1.152'</span></span>, port=<span class="hljs-number"><span class="hljs-number">15432</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> node coordinator3 <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=coordinator, host=<span class="hljs-string"><span class="hljs-string">'192.168.1.161'</span></span>, port=<span class="hljs-number"><span class="hljs-number">15432</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> node datanode1 <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=datanode, host=<span class="hljs-string"><span class="hljs-string">'192.168.1.151'</span></span>, primary=<span class="hljs-literal"><span class="hljs-literal">true</span></span>, port=<span class="hljs-number"><span class="hljs-number">25432</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> node datanode2 <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=datanode, host=<span class="hljs-string"><span class="hljs-string">'192.168.1.152'</span></span>, primary=<span class="hljs-literal"><span class="hljs-literal">false</span></span>, port=<span class="hljs-number"><span class="hljs-number">25432</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> node datanode3 <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>=datanode, host=<span class="hljs-string"><span class="hljs-string">'192.168.1.161'</span></span>, primary=<span class="hljs-literal"><span class="hljs-literal">false</span></span>, port=<span class="hljs-number"><span class="hljs-number">25432</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pgxc_pool_reload(); <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> pgxc_node; node_name | node_type | node_port | node_host | nodeis_primary | nodeis_preferred | node_id <span class="hljs-comment"><span class="hljs-comment">--------------+-----------+-----------+---------------+----------------+------------------+------------- datanode1 | D | 25432 | 192.168.1.151 | t | f | 888802358 coordinator1 | C | 15432 | 192.168.1.151 | f | f | 1938253334 coordinator2 | C | 15432 | 192.168.1.152 | f | f | -2089598990 coordinator3 | C | 15432 | 192.168.1.161 | f | f | -1483147149 datanode2 | D | 25432 | 192.168.1.152 | f | f | -905831925 datanode3 | D | 25432 | 192.168.1.161 | f | f | -1894792127</span></span></code> </pre><br>  On the remaining nodes you need to do the same. <br>  The data node will not completely clear the information, but you can overwrite it: <br><br><pre> <code class="bash hljs">psql -p 25432 -c <span class="hljs-string"><span class="hljs-string">"alter node datanode1 WITH ( TYPE=datanode, HOST ='192.168.1.151', PORT=25432, PRIMARY=true);"</span></span></code> </pre><br><h4>  Cluster testing </h4><br>  Now everything is set up and working.  Create several test tables. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test1 ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, profile <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, switch_date <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> test1_id_pkey PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> node (datanode1, datanode2); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test2 ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, profile <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, switch_date <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> test2_id_pkey PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">distribute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLICATION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test3 ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, profile <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, switch_date <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> test3_id_pkey PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">distribute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">HASH</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> test4 ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, profile <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span> <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, switch_date <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-keyword"><span class="hljs-keyword">without</span></span> <span class="hljs-built_in"><span class="hljs-built_in">time</span></span> zone <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">distribute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> MODULO(<span class="hljs-keyword"><span class="hljs-keyword">status</span></span>);</code> </pre><br>  It was created 4 tables with the same structure, but different distribution logic across the cluster. <br><br>  The data from the <i>test1</i> table will be stored only on 2x data nodes - <i>datanode1</i> and <i>datanode2</i> , and they will be distributed using the roundrobin algorithm.  The remaining tables involve all nodes.  Table <i>test2</i> works in replication mode.  To determine on which server the data of the <i>test3</i> table will be stored, the hash function is used by the <i>id</i> field, and to determine the distribution logic of <i>test4, the</i> module is taken by the <i>status</i> field.  Now let's try to fill them: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> test1 (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>, profile, <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>, switch_date) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">10000</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'1 year'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>) a; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> test2 (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> , profile,<span class="hljs-keyword"><span class="hljs-keyword">status</span></span>, switch_date) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">10000</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'1 year'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>) a; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> test3 (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> , profile,<span class="hljs-keyword"><span class="hljs-keyword">status</span></span>, switch_date) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">10000</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'1 year'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>) a; <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> test4 (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> , profile,<span class="hljs-keyword"><span class="hljs-keyword">status</span></span>, switch_date) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">10000</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'1 year'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>) a;</code> </pre><br>  Now we will request this data and see how the scheduler works. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test1; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------------------------------------------------------------------- Aggregate (cost=27.50..27.51 rows=1 width=0) (actual time=0.649..0.649 rows=1 loops=1) -&gt; Remote Subquery Scan on all (datanode1,datanode2) (cost=0.00..24.00 rows=1400 width=0) (actual time=0.248..0.635 rows=2 loops=1) Total runtime: 3.177 ms explain analyze select count(*) from test2; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------------------- Remote Subquery Scan on all (datanode2) (cost=27.50..27.51 rows=1 width=0) (actual time=0.711..0.711 rows=1 loops=1) Total runtime: 2.833 ms explain analyze select count(*) from test3; QUERY PLAN ------------------------------------------------------------------------------------------------------------------------------------- Aggregate (cost=27.50..27.51 rows=1 width=0) (actual time=1.453..1.453 rows=1 loops=1) -&gt; Remote Subquery Scan on all (datanode1,datanode2,datanode3) (cost=0.00..24.00 rows=1400 width=0) (actual time=0.465..1.430 rows=3 loops=1) Total runtime: 3.014 ms</span></span></code> </pre><br><br>  The scheduler tells us how many nodes will participate in the request.  Since <i>table2</i> replicates to all nodes, only 1 node will be scanned.  By the way, it is unclear by what logic it is selected.  It would be logical for him to request data from the same node on which the coordinator is. <br><br>  By connecting to the data node (on port 25432) you can see how the data was distributed. <br><br>  Now let's try to fill the tables with large amounts of data and compare query performance with standalone PostgreSQL. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> test3 (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> , profile,<span class="hljs-keyword"><span class="hljs-keyword">status</span></span>, switch_date) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">10000</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random()*<span class="hljs-number"><span class="hljs-number">4</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">now</span></span>() - <span class="hljs-string"><span class="hljs-string">'1 year'</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">round</span></span>(random() * <span class="hljs-number"><span class="hljs-number">40</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1000000</span></span>) a;</code> </pre><br>  Query in a Postgres-XL cluster: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> profile, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">status</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test3 <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>&lt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> switch_date <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'1970-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2015-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> profile; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------------------------- HashAggregate (cost=34.53..34.54 rows=1 width=12) (actual time=266.319..268.246 rows=10001 loops=1) -&gt; Remote Subquery Scan on all (datanode1,datanode2,datanode3) (cost=0.00..34.50 rows=7 width=12) (actual time=172.894..217.644 rows=30003 loops=1) Total runtime: 276.690 ms</span></span></code> </pre><br>  The same request on the server with PostgreSQL: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> profile, <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">status</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">status</span></span>&lt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> switch_date <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> <span class="hljs-string"><span class="hljs-string">'1970-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-string"><span class="hljs-string">'2015-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">group</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> profile; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------------------------- HashAggregate (cost=28556.44..28630.53 rows=7409 width=12) (actual time=598.448..600.495 rows=10001 loops=1) -&gt; Seq Scan on test (cost=0.00..24853.00 rows=740688 width=12) (actual time=0.418..329.145 rows=740579 loops=1) Filter: ((status &lt;&gt; 2) AND (switch_date &gt;= '1970-01-01 00:00:00'::timestamp without time zone) AND (switch_date &lt;= '2015-01-01 00:00:00'::timestamp without time zone)) Rows Removed by Filter: 259421 Total runtime: 601.572 ms</span></span></code> </pre><br>  Observe a twofold increase in speed.  Not so bad, if you have a sufficient number of machines, then such scaling looks quite promising. <br><br>  As noted in the comments, it would be interesting to look at the join tables distributed over several nodes.  Let's try: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> test3_1 (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">text</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> test3_1_id_pkey PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">distribute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-keyword"><span class="hljs-keyword">HASH</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> test3_1 (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> , <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">md5</span></span>(random()::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span>) a; <span class="hljs-keyword"><span class="hljs-keyword">explain</span></span> <span class="hljs-keyword"><span class="hljs-keyword">analyze</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> test3.*,test3_1.name <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test3 <span class="hljs-keyword"><span class="hljs-keyword">join</span></span> test3_1 <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test3.profile=test3_1.id; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------------------------- Remote Subquery Scan on all (datanode1,datanode2,datanode3) (cost=35.88..79.12 rows=1400 width=61) (actual time=26.500..17491.685 rows=999948 loops=1) Total runtime: 17830.984 ms</span></span></code> </pre><br>  Request for the same amounts of data, but on a standalone server: <br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------------------------------------------------------------------------------- Hash Join (cost=319.00..42670.00 rows=999800 width=69) (actual time=99.697..19806.038 rows=999940 loops=1) Hash Cond: (test.profile = test_1.id) -&gt; Seq Scan on test (cost=0.00..17353.00 rows=1000000 width=28) (actual time=0.031..6417.221 rows=1000000 loops=1) -&gt; Hash (cost=194.00..194.00 rows=10000 width=41) (actual time=99.631..99.631 rows=10000 loops=1) Buckets: 1024 Batches: 1 Memory Usage: 713kB -&gt; Seq Scan on test_1 (cost=0.00..194.00 rows=10000 width=41) (actual time=0.011..46.190 rows=10000 loops=1) Total runtime: 25834.613 ms</span></span></code> </pre><br>  Here the gain is only 1.5 times. <br><br>  PS I hope this post will help someone.  Comments and additions are welcome!  Thank you for attention. </div><p>Source: <a href="https://habr.com/ru/post/253017/">https://habr.com/ru/post/253017/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253005/index.html">Safety rules for online store users</a></li>
<li><a href="../253009/index.html">Open database of defects in closed software</a></li>
<li><a href="../253011/index.html">Tweaking Spark IM Client</a></li>
<li><a href="../253013/index.html">We exploit root-vulnerability in Asus routers</a></li>
<li><a href="../253015/index.html">How to manipulate SIP messages on AudioCodes hardware</a></li>
<li><a href="../253025/index.html">Magnetic tape - the old horse does not spoil the furrow</a></li>
<li><a href="../253027/index.html">7th IT Jam Meet & Mix News 2015</a></li>
<li><a href="../253029/index.html">About Git Beginners and Git Starter Articles</a></li>
<li><a href="../253031/index.html">Hybrid implementation of the MST algorithm using CPU and GPU</a></li>
<li><a href="../253033/index.html">Questions at the javascript interview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>