<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Kill all humans with a cat, or state machines on Akka.FSM</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As I wrote in my first article , not so long ago I switched from C ++ to Scala. And at the same time I began to study the model of actors performed by...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Kill all humans with a cat, or state machines on Akka.FSM</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/8f2/c56/9a4/8f2c569a46934cad9d8a96169e85268f.jpg" width="500"></div>  As I wrote in my <a href="https://habrahabr.ru/post/237427/">first article</a> , not so long ago I switched from C ++ to Scala.  And at the same time I began to study the model of actors performed by Akka.  The most vivid impression on me was the easy implementation and testing of finite state machines (finite-state machines, FSM), which this library provides.  I don‚Äôt know why this happened, given the abundance of other beautiful and useful things in Akka.  But now in my first Scala project I use finite automata for each drop-down opportunity supported by expediency (as I sincerely hope).  And so I decided that I was ready to share with the community the knowledge about Akka.FSM, as well as some tricks and personal insights that I had time to accumulate.  I did not find a similar topic on the Habr√© (and indeed with articles about Scala and Akka here somehow was not thick), and decided, without delay, to rectify the situation and speak out, until someone said everything before me.  And so that it is not boring - I propose to realize together the behavior of the real electronic cat.  I would like to believe that some kind of lonely romantic soul, inspired by my article, will modify the functionality offered in it to a full-fledged ‚ÄúTamakotchi‚Äù, as homework.  The main thing is that such a soul does not forget to share its results with the community in the comments.  Ideally, it would be possible to create a project on a shared access github so that everyone could contribute their personal contribution to the development of transhumanism ideas.  And now - in the direction of jokes and fantasies, roll up our sleeves.  We will start from scratch, and I, for the hell of 7D and the effect of presence, I will do every step with you.  TDD is attached: with untested robokotom certainly will not be a joke. <br><br>  The information in the article is intended for those who are already at least a little bit with Scala, and have at least a superficial idea of ‚Äã‚Äãthe model of actors.  For those who would like to meet, but do not know where to start, as a bonus, I wrote a small starting instruction and hid it under the spoiler so that the rest did not interfere.  It tells how to create a clean Scala project with all the necessary libraries without any extra effort. <br><a name="habracut"></a><br><br>  So, as you already understood, first we need a clean project with fresh versions of akka-actor, akka-testkit and scalatest libraries (at the time of writing this article is akka 2.3.4 and scalatest 2.1.6. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">'' Eeee ... And what's all this garbage? '', Or for those who are not in the subject</b> <div class="spoiler_text">  Warning number 1: if you never felt Scala with your bare hands at all, and didn‚Äôt even spy on it through the keyhole, then you most likely will not understand any particular part of everything written later in this article.  But for the most stubborn (I approve, he himself), I will explain exactly how you can create a new project on Scala with no hardship using the trendy and brilliant such Typesafe Activator bun. <br><br>  Warning number 2: the following actions in the command line are valid for OS Linux and Mac OS X. The actions required for Windows are similar to those described, but differ from them (at least, the lack of a tilde before the name of the Projects directory, backslash slash, the word "folder" instead of the words ‚Äúdirectory‚Äù or ‚Äúdirectory‚Äù, and the presence in the archive of a special file activator.bat, designed for Windows). <br><br><h3>  Create a project </h3><br>  So let's go.  The easiest way for me to create a new project is to download the mentioned typesafe activator from the official site.  Library versions announced on the site at the time of writing this article: Activator 1.2.10, Akka 2.3.4, Scala 2.11.1.  All is downloaded in the form of a ZIP archive.  While it is being downloaded, we need to preheat the oven to 230 degrees Celsius.  For now you think: ‚ÄúWhy do we need an oven?  o_0 "- 352MB archive has already been downloaded.  Unpack all this stuff somewhere on the disk.  I will do all the manipulations in the ~ / Projects directory.  So: <br><br><pre><code class="bash hljs">$ mkdir ~/Projects $ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ~/Projects $ unzip ~/Downloads/typesafe-activator-1.2.10.zip</code> </pre> <br>  After the archive is unpacked, do not forget to lubricate the pan with oil.  Everything, I promise, then everything will be extremely serious.  Now we have two ways to create a project: through a graphical interface and through the command line.  As a labor Jedi, we, of course, choose the path of strength (especially since the terminal is already open - not to close it because of some UI): <br><br><pre> <code class="bash hljs">$ activator-1.2.10/activator new kote hello-akka</code> </pre><br>  <i>With</i> this straightforward string, we tell the activator to create ( <i>new</i> ) a <i>kote</i> project in the current folder (and we, as we remember, stayed in ~ / Projects) from a template called <i>hello-akka</i> .  This template already includes the <i>build.sbt</i> file configured for the necessary libraries.  The possibilities of the dark side, as always, are lighter and more tempting, so if someone does not work on the command line, you can type <code>./activator ui</code> (or just <i>ui</i> , if you are already in the activator console), and do everything in the opened browser .  Everything is very beautiful there, look at least just for the sake of interest - I promise you will like it.  After the project is created - go to its directory: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> kote</code> </pre><br><h3>  IDE or not IDE </h3><br>  Then every Jedi decides for himself what his strength is: use ed, vi, vim, emacs, Sublime, TextMate, Atom, something else, or a full IDE.  Personally, with the transition to Scala, I started using IntelliJ IDEA, so I will immediately generate project files for this environment.  For everything to work out, add the line <code>addSbtPlugin("com.github.mpeltonen" % "sbt-idea" % "1.5.2")</code> to the project / plugins.sbt file: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">"addSbtPlugin(\"com.github.mpeltonen\" % \"sbt-idea\" % \"1.5.2\")"</span></span> &gt; project/plugins.sbt</code> </pre><br>  Then we launch the activator, and then it will do everything that is necessary, according to our team: <br><br><pre> <code class="bash hljs">$ $ ./activator &gt; gen-idea sbt-classifiers</code> </pre><br>  Now you can open a project in IDEA. <br><br><h3>  Or is it not an IDE? </h3><br>  If you think that IDE is the dark side of power (or vice versa), and it is not worthy of a Jedi - this is your complete right.  In this case, you can stay in the command line of the activator, and edit the files in any convenient way.  And then only two teams of activator will decide the whole fate of our cat: <br><ol><li>  <i>compile</i> - compile the project. </li><li>  <i>test</i> - run all tests.  Call compile if necessary, so I lied, you can get by with this command alone. </li></ol><br>  I will not run kote in production in this article, but a potential developer of the final version of Tamagotchi will be able to do this with the help of the <i>run</i> command. <br><br><h3>  We clean the place for kote </h3><br>  All cats, as you know, are pedantic cleaners.  Therefore, we will start with the preparation of a clean and neat home for our future pet.  That is, we remove all the extra files that come with the newly created project in the framework of the hello-akka template.  Personally, I personally consider unnecessary directories src / main / java, src / test / java with all the content, as well as all the .scala files, we will not need them either: src / main / scala / HelloAkkaScala.scala and src / test / scala /HelloAkkaSpec.scala.  Well, now we are ready to proceed. <br></div></div><br><br><h3>  First step </h3><br>  In the beginning was the test.  And the test did not compile.  It is this statement, as is known, that is the fundamental postulate of TDD, of which I am a supporter at the moment.  Therefore, I‚Äôll start my description not from the automaton itself, but from the creation of the first test for it, in order to demonstrate the testing capabilities provided by the Akka TestKit library.  Included with the activator, which I use, already has a framework for testing - the scalatest.  He suits me perfectly, and I see no reason not to use it in our project.  In general, Akka TestKit can be used with spec2 or something else, as it is <a href="http://doc.akka.io/docs/akka/snapshot/scala/testing.html">framework independent</a> .  In order not to bother with the names of test packages, I will put the file directly in src / test / scala / KoteSpec.scala <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.actor.<span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.testkit.{<span class="hljs-type"><span class="hljs-type">ImplicitSender</span></span>, <span class="hljs-type"><span class="hljs-type">TestFSMRef</span></span>, <span class="hljs-type"><span class="hljs-type">TestKit</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> org.scalatest.{<span class="hljs-type"><span class="hljs-type">BeforeAndAfterAll</span></span>, <span class="hljs-type"><span class="hljs-type">FreeSpecLike</span></span>, <span class="hljs-type"><span class="hljs-type">Matchers</span></span>} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KoteSpec</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">_system: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">ActorSystem</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestKit</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">_system</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplicitSender</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Matchers</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FreeSpecLike</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BeforeAndAfterAll</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-type"><span class="hljs-type">ActorSystem</span></span>(<span class="hljs-string"><span class="hljs-string">"KoteSpec"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> kote.<span class="hljs-type"><span class="hljs-type">Kote</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">afterAll</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { system.shutdown() system.awaitTermination(<span class="hljs-number"><span class="hljs-number">10.</span></span>seconds) } <span class="hljs-string"><span class="hljs-string">"A Kote actor"</span></span> - { <span class="hljs-comment"><span class="hljs-comment">// All future tests go here } }</span></span></code> </pre><br>  Further it is assumed that all the tests I will add to the body of this class, immediately under the comment.  I use FreeSpecLike, and not, say, FlatSpecLike, because it is much more convenient for me to visually structure a lot of tests for various states and automaton transitions on it.  Since we are ready to start creating our first test, I propose to start with the fact that cats love to do more than anything else - sleep.  So, adopting the principles of TDD, we will create a test that will check that the newly ‚Äúborn‚Äù cat initially sleeps: <br><br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"should sleep at birth"</span></span> in { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kote = <span class="hljs-type"><span class="hljs-type">TestFSMRef</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>) kote.stateName should be(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>) kote.stateData should be(<span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) }</code> </pre><br><br>  Now try to sort things out in order.  TestFSMRef is a class that offers us the Akka TestKit framework to simplify the testing of finite automata implemented using the FSM class.  To be more precise, TestFSMRef is a class with an auxiliary object (companion object), the apply method of which we call.  And this method returns us an instance of the class TestFSMRef, which is the successor of the most ordinary ActorRef, that is, we can send messages to our automaton as a simple actor.  However, the functionality of TestFSMRef is somewhat extended compared to the simple ActorRef, and these extensions are designed specifically for testing.  One of these extensions are the two functions we used: stateName and stateData, which provide access to the current state of our test kitten.  Why are there two functions, one state?  After all, in the usual sense, the state is a combination of the current values ‚Äã‚Äãof the internal parameters of the machine.  Where are the two variables here, and why two?  The fact is that in order to describe the current state of the Akka.FSM automaton (based on the principles of the design of automata in Erlang), it separates the concepts of state ‚Äúnames‚Äù and ‚Äúdata‚Äù associated with it.  In addition, Akka <a href="http://doc.akka.io/docs/akka/2.3.6/scala/fsm.html">recommends avoiding the</a> use of mutable properties (var) in the class of the automaton, justifying this with the advantage that in this way the state of the automaton in the program code can be changed only in a few predetermined and well-known places and avoid unobvious and implicit changes .  Moreover, there is no direct access from inside our future class to these two variables: they are declared as private in the base class FSM.  However, TestFSMRef provides access to them for testing.  And how to reach them from the class of the machine itself - it will become clear further. <br><br>  So, our sleep state I called Sleeping.  And I put it in the auxiliary State object, which will now store all the names of our states for clarity of the code and to avoid confusion.  As for the data, at this stage we do not yet know what they will be.  But something "feed" the machine as data still have to, otherwise it will not work.  Therefore, I decided to call the variable name Empty, this is my personal choice, and does not oblige you to anything.  You can call it another way: Nothing, Undefined.  As for me, Empty is rather short and informative.  I also used to store data in a specially selected object, which I called Data.  In my ‚Äúcombat‚Äù automata of various types of data, sometimes it is not less, or even more, than the names of the states, so I always keep them in a dedicated place: cutlets separately, flies separately. <br><br>  Well, compile?  It is clear that the compilation will not work, in the absence of those types and variables that we refer to in the test.  This means that we are ready to proceed to the next stage of the TDD cycle. <br><br>  In order to declare the class of our automaton, we need two basic types from which all classes and objects will be inherited, describing the names of the states and their data.  In order not to litter the environment, we will create an auxiliary object (companion object) that will store all the definitions necessary for the kitten‚Äôs life.  This is the generally accepted standard of behavior in the world of Scala, and no one will blame us for this.  If for tests with the name of the package we did not bother, then for the project itself, I still create it.  Let's call it kote.  And we will put the implementation file of our pet, respectively, in src / main / scala / kote / Kote.scala.  So, let's begin: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> kote <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> akka.actor.<span class="hljs-type"><span class="hljs-type">FSM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> scala.concurrent.duration._ <span class="hljs-comment"><span class="hljs-comment">/** Kote companion object */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kote</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> }</span></span></code> </pre><br>  These definitions are enough to declare a kitty class: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">/** Kote Tamakotchi mimimi njawka! */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kote</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSM</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Kote</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Kote</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Data</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>._ }</code> </pre><br>  Inside the class, I added an import of everything that will be further declared in the auxiliary object, to simplify further access.  We can only declare the value of the name and data for our original "sleepy" state: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">/** Kote companion object */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kote</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sealed</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Sleeping</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Empty</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> } }</span></span></code> </pre><br>  Before compiling the test, the last step remains.  Since from the tests we refer (and want to refer henceforth) to the insides of the Kote object as easily and simply as from the class itself, it will be convenient for us to add import into the body of the KoteSpec class.  It is possible immediately after the alternative constructor declaration: <br><br><pre> <code class="scala hljs">... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span></span>() = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>(<span class="hljs-type"><span class="hljs-type">ActorSystem</span></span>(<span class="hljs-string"><span class="hljs-string">"KoteSpec"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>._ ...</code> </pre><br>  Don't forget to add import kote.Kote to the import section in the KoteSpec.scala file.  Now the project has successfully compiled, and you can run the test.  What?  Red?  NullPointerException?  And you thought - just create a new kitten?  The nature of millions of years of evolution on it is portable!  Well, okay, do not panic.  Probably, the problem is that we did not tell our animal what to do immediately after birth.  This is very easy to do: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kote</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSM</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Kote</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Kote</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Data</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>._ startWith(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) }</code> </pre><br>  We start the test, and - voa!  Green as I love!  The kitten seems to have come to life, but something is kind of boring: stupidly sleeps for itself - that's all.  This is not fun.  Let's wake him up. <br><br><h3>  "Sleep, my joy!", Or how to implement the behavior in the initial state </h3><br>  How would we do this?  Do not slow down the monitor while the test works?  Let's be constructive and think: if our kitten is an actor, then the only way to communicate with him is to send messages.  Such an important kote-bureaucrat, all that remained was a sissy secretary to hire him to sort out the correspondence.  What message should he send to wake him up?  We could write to him simply: kote!  ‚ÄúProsnis'!  Wake up! ".  But personally, I consider sending messages as strings as a mauve, because you can always make a mistake in some kind of character, and the compiler won't even notice it, and it will be very difficult to debug it later.  Yes, and our newborn kote, if to fantasize, should not yet understand human language.  I propose to develop a special cat language commands, which he seemed to begin to learn from birth.  Well, instinctively, or something.  And we will contribute to the development of his instincts.  The first team we will teach him will be called WakeUp.  And we pop it into our helper object, in the Commands sub-object: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kote</span></span></span><span class="hljs-class"> </span></span>{ ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Commands</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WakeUp</span></span></span><span class="hljs-class"> } }</span></span></code> </pre><br>  Now proceed to the test: <br><br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"should wake up on command"</span></span> in { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kote = <span class="hljs-type"><span class="hljs-type">TestFSMRef</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>) kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">WakeUp</span></span> kote.stateName should be (<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) }</code> </pre><br>  Of course, the test will not compile.  We forgot to announce the name of our state: <br><br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Awake</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span></span></code> </pre><br>  Now the test has been compiled, but, as it seems, we were destined to <i>crash</i> with another exception: <i>NoSuchElementException: key not found: Sleeping</i> .  What do all these barbaric letters mean?  Only one thing: we told our young lover of quantum experiments that he should sleep, and he really sleeps obediently, but at the same time what <i>sleep is</i> and <u>how</u> to do it - he still does not know.  And we, in addition, are trying to send him a message in this state of uncertainty.  Let's not be encouraged by the well-known torturers and poisoners of the cats and keep the poor animal in desperate ignorance, and just describe its behavior: <br><br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) { <span class="hljs-type"><span class="hljs-type">FSM</span></span>.<span class="hljs-type"><span class="hljs-type">NullFunction</span></span> }</code> </pre><br>  Not bad for a start.  when is the most common scala function with two pairs of parentheses.  That is, when () ().  In the first we specify the name of the state for which we want to describe the behavior, and secondly (here the second brackets are not visible, as scala allows them not to be specified in this case) - a partial function (partial function), which characterizes the behavior of our animal in this state.  So let's call it - behavior.  And the behavior is in response to various external stimuli.  Simply - on incoming messages.  Normal reaction can be of three types - either the machine remains in the current state (stay), or goes into the new (goto), or stops the work (stop).  The fourth option, the ‚Äúabnormal‚Äù reaction, is when the machine cannot cope with the problem that has come over and throws an exception (and then, as is the case with a regular actor, his supervisor decides what to do with it, in accordance with the <a href="http://doc.akka.io/docs/akka/2.3.6/general/supervision.html">current supervision strategy</a> ).  I will touch on the topic of exceptions a little later. <br><br>  FSM.NullFunction is helpfully provided by the Akka library function, which tells us that the cat in this state does absolutely nothing and does not react to anything, and skips all incoming messages past the ears.  We could write <i>{case _ =&gt;}</i> , but it would not be exactly the same, and I‚Äôll also mention this later.  It is convenient to use NullFunction as a ‚Äúgag‚Äù to describe future states, the details of the implementation of which are not yet important at this stage, but the transition to which we already need to be tested. <br><br><h3>  ‚ÄúWake up, lazy brute!‚Äù, Or how to respond to an event by switching to a new state </h3><br>  So, let's run the test now - and now the cause of the fall is completely different: Sleeping was not equal to Awake.  Of course, because our cat learned to sleep, but we have not yet taught him to respond to the WakeUp command.  Let's try to stir it up a bit: <br><br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">WakeUp</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) =&gt; goto(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) }</code> </pre><br>  As I said, we do not have direct access to variables with the state name and data.  We get access to them only when our machine receives a message.  The FSM wraps this message in the case class Event, and adds the current state data to the same place.  Now we can apply pattern matching and isolate from the "flown" event all that we need.  In this case, we are convinced that being in the state called Sleeping, we received the WakeUp command, and our data were Data.Empty.  And we react to all this vinaigrette transition to a new state: Awake.  This approach to the description of behavior allows us to handle various options for combining the names of the state with the current data to it.  That is, to find in the same state, we can react differently to the same message depending on the current data. <br><br>  Now I would like to note the features of the mentioned state transition functions: goto and stay.  By themselves, these are ‚Äúpure‚Äù functions that do not have any side effects.  Which means that the very fact of calling them to change the current state does not lead.  They only return the state value we need (specified by the user in the case of goto, or current in the case of a stay), reduced to the type understood by the FSM.  In order for a change to occur, it must be returned from our function of behavior. <br><br>  With this sorted out.  Now we run the test - but again the failure: Next state Awake does not exist.  I intentionally wanted to show what happens if the next state is not declared using when: the transition simply does not occur, and the machine remains in the same state.  Exceptions, as it happened with our starting state, are also not discarded.  Often in the impulse of development I forgot about it, and spent time trying to figure out why the transition did not occur and the test drops.  The message ‚ÄúNext state Awake does not not exist‚Äù in non-trivial tests in the log can simply not be noticed among others.  But over time you begin to get used to this feature. <br><br>  So, we declare the zero function as our next state, and the test will turn green: <br><br><pre> <code class="scala hljs"> when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>)(<span class="hljs-type"><span class="hljs-type">FSM</span></span>.<span class="hljs-type"><span class="hljs-type">NullFunction</span></span>)</code> </pre><br><br><h3>  ‚ÄúStroke the cat!‚Äù, Or how to react to the event, while maintaining steadfastness </h3><br>  Well, now you can pet our kitten, taking advantage of the fact that he woke up.  I hope what and where to add - already figured out? <br><br>  Team: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Stroke</span></span></span></span></code> </pre><br>  Test: <br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"should purr on stroke"</span></span> in { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kote = <span class="hljs-type"><span class="hljs-type">TestFSMRef</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>) kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">WakeUp</span></span> kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span> expectMsg(<span class="hljs-string"><span class="hljs-string">"purrr"</span></span>) kote.stateName should be (<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) }</code> </pre><br>  Kote: <br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) =&gt; sender() ! <span class="hljs-string"><span class="hljs-string">"purrr"</span></span> stay() }</code> </pre><br><br>  The same can be written more succinctly: <br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) =&gt; stay() replying <span class="hljs-string"><span class="hljs-string">"purrr"</span></span> }</code> </pre><br><h3>  "Do not wake the cat twice!", Or how to test without repeating without repeating </h3><br>  Stop stop!  Well, it turns out, to stroke the cat in the dough, we wake him up first, and then stroke it?  Great, that is, if we have another 10-15 intermediate (and if 100-150?) Up to the tested state, then we will have to pass through everything correctly, not allowing a single error to get to the right one?  What if all the same mistake, and we were not where we think?  Or did something change over time in transitions between intermediate states?  In this case, the TestFSMRef provides us with the ability to set the required state and data with the help of the setState function, without having to go through all intermediate steps.  So, we change our test: <br><br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"should purr on stroke"</span></span> in { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kote = <span class="hljs-type"><span class="hljs-type">TestFSMRef</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>) kote.setState(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span> expectMsg(<span class="hljs-string"><span class="hljs-string">"purrr"</span></span>) kote.stateName should be (<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) }</code> </pre><br>  Well, for tests of the same state for several different stimuli, I personally invented for myself this method of getting rid of duplicate code: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestedKote</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> kote = <span class="hljs-type"><span class="hljs-type">TestFSMRef</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>) }</code> </pre><br>  And now I can replace all our tests with: <br><br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"should sleep at birth"</span></span> in <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">TestedKote</span></span> { kote.stateName should be (<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>) kote.stateData should be (<span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) } <span class="hljs-string"><span class="hljs-string">"should wake up on command"</span></span> in <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">TestedKote</span></span> { kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">WakeUp</span></span> kote.stateName should be (<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) } <span class="hljs-string"><span class="hljs-string">"should purr on stroke"</span></span> in <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">TestedKote</span></span> { kote.setState(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span> expectMsg(<span class="hljs-string"><span class="hljs-string">"purrr"</span></span>) kote.stateName should be (<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) }</code> </pre><br>  As for testing the same <u>non-starting</u> state several times, I brought out the following simple technique for myself: <br><br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"while in Awake state"</span></span> - { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AwakeKoteState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestedKote</span></span></span><span class="hljs-class"> </span></span>{ kote.setState(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">Empty</span></span>) } <span class="hljs-string"><span class="hljs-string">"should purr on stroke"</span></span> in <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AwakeKoteState</span></span> { kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span> expectMsg(<span class="hljs-string"><span class="hljs-string">"purrr"</span></span>) kote.stateName should be(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) } }</code> </pre><br>  As you can see, I created a framing with the subtitle ‚Äúwhile in Awake state‚Äù for all the ‚Äúawake‚Äù tests, and put trait AwakeKoteState (it can be a class, not the essence) that, when initialized, immediately puts the cat in a waking state without unnecessary gestures.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now all the tests in this state, I will announce with it. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Breathe more life", or how to add meaningful data to the state </font></font></h3><br> ,     . ,    ‚Äî   .    ,  ,   !    !   , .              !          ?  ,         ,    ,    ,       ,   .   :       . ,     .     ‚Äî    ,  , .   , ,   ‚Äî  /  . ,       Empty     ,     .   ,      ,     .   ,   ,       . ,      hunger: Int,  ,   100 ‚Äî     ,  0   ‚Äî   (         ).      , , 60 ‚Äî  ,   ,   .      case class VitalSigns,  case object Empty .    -     Data.  So: <br><br><pre> <code class="scala hljs">... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VitalSigns</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">hunger: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Data</span></span></span><span class="hljs-class"> } ...</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Naturally, now in the whole project you need to change Data.Empty to Data.VitalSigns. </font><font style="vertical-align: inherit;">Starting with the startWith line:</font></font><br><br><pre> <code class="scala hljs"> startWith(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">VitalSigns</span></span>(hunger = <span class="hljs-number"><span class="hljs-number">60</span></span>))</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In fact, in the existing behavior of a kitten in the states already described, we (he, of course) does not care about his vital signs, so we can safely replace the Data.Empty here with an underscore, and not with VitalSigns: </font></font><br><br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">WakeUp</span></span>, _) =&gt; goto(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) } when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span>, _) =&gt; stay() replying <span class="hljs-string"><span class="hljs-string">"purrr"</span></span> }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now our kitten has evolved even more, and can complicate its behavior, and rumble when stroking only if it is full enough: </font></font><br><br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">VitalSigns</span></span>(hunger)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> hunger &lt; <span class="hljs-number"><span class="hljs-number">30</span></span> =&gt; stay() replying <span class="hljs-string"><span class="hljs-string">"purrr"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">VitalSigns</span></span>(hunger)) =&gt; stay() replying <span class="hljs-string"><span class="hljs-string">"miaw!!11"</span></span> }</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And tests: </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"while in Awake state"</span></span> - { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AwakeKoteState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TestedKote</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialHunger</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> kote.setState(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">VitalSigns</span></span>(initialHunger)) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FullUp</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialHunger</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">15</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Hungry</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialHunger</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-number"><span class="hljs-number">75</span></span> } <span class="hljs-string"><span class="hljs-string">"should purr on stroke if not hungry"</span></span> in <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AwakeKoteState</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">FullUp</span></span> { kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span> expectMsg(<span class="hljs-string"><span class="hljs-string">"purrr"</span></span>) kote.stateName should be(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) } <span class="hljs-string"><span class="hljs-string">"should miaw on stroke if hungry"</span></span> in <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AwakeKoteState</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">Hungry</span></span> { kote ! <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">Stroke</span></span> expectMsg(<span class="hljs-string"><span class="hljs-string">"miaw!!11"</span></span>) kote.stateName should be(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) } }</code> </pre><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "The animal is starving!", Or how to plan events </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The kitten must ‚Äúgain‚Äù the level of hunger over time (What? ‚ÄúTo pry‚Äù? There is no such word in the Russian language!) To do this, we will plan a GrowHungry message for every 5 minutes immediately after the ‚Äúbirth‚Äù of the cat, and it will stay with him until his death. </font><font style="vertical-align: inherit;">Cruel? </font><font style="vertical-align: inherit;">That's life!</font></font><br><br>  Message: <br><pre> <code class="scala hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GrowHungry</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">by: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kote: </font></font><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Kote</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSM</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Kote</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">State</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Kote</span></span></span><span class="hljs-class">.</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Data</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-type"><span class="hljs-type">Kote</span></span>._ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> context.dispatcher startWith(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>, <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">VitalSigns</span></span>(hunger = <span class="hljs-number"><span class="hljs-number">60</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> hungerControl = context.system.scheduler.schedule(<span class="hljs-number"><span class="hljs-number">5.</span></span>minutes, <span class="hljs-number"><span class="hljs-number">5.</span></span>minutes, self, <span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">GrowHungry</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postStop</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { hungerControl.cancel() } ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I made the level of ‚Äúrecruited‚Äù feeling of hunger variable, because along with the natural process of ‚Äústarvation‚Äù (adding a kitten +3 to hunger every 5 minutes), an animal can engage in mobile activity, in which case its appetite will grow much faster. </font><font style="vertical-align: inherit;">hungerControl is a Cancellable instance, and before stopping a kitten's heart, it must be canceled in a postStop to avoid leaks, since the </font></font><a href="http://stackoverflow.com/questions/16299692/using-the-default-scheduler-in-akka-do-i-need-to-manually-cancel-events-when-th"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dispatcher does not follow the stopping of actors</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and will send further messages to the dead kitten directly to the next world, and the dead, even if they are kittens, disturb worthless </font><font style="vertical-align: inherit;">Well, one more thing: to call the scheduler, you need to specify implicit ExecutionContext, so the import context.dispatcher line appeared.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "And let's just kill him!", Or how to handle events common to all states </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In order not to delay the article, I immediately realize the death of a cat from starvation (hunger&gt; = 100), and the transition to a particularly hungry state (hunger&gt; 85), where the kitten should be busy only by regularly meowing and begging for food. Let's believe that Akka has tested her planners, and the message will arrive on time, and let's write how the cat will react to it. It is worth noting that ‚Äúnatural fat burning‚Äù will occur in all states: whether the cat sleeps, wakes up, asks for food, eats, or plays with the mouse. How to be in this case? Describe the same behavior for all possible states? Together with the tests? And if at some point we forget to write a test, and the cat, having found such a ball, will hang in one state and enjoy eternal satiety? Yes, to hell with him, and let him be enjoyed, do not mind,but this bastard mustached, according to the old habit, will eat regular, and fats will not be burned - and in the end he will die from an overdose of food in the body! In this case, the FSM, sincerely caring for your kitten, suggests using the whenUnhandled function, which works in any state for messages that do not coincide with any of the options in the function and behavior for the current state. Remember, I wrote that</font></font><i>FSM.NullFunction</i>    <i>{ _ =&gt; }</i> ? ,   ,  .           ,  ,       whenUnhandled,       ‚Äî    ¬´¬ª  ,   whenUnhandled  . <br><br><pre> <code class="scala hljs">whenUnhandled { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">GrowHungry</span></span>(by), <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">VitalSigns</span></span>(hunger)) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newHunger = hunger + by <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newHunger &lt; <span class="hljs-number"><span class="hljs-number">85</span></span>) stay() using <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">VitalSigns</span></span>(newHunger) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newHunger &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>) goto(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">VeryHungry</span></span>) using <span class="hljs-type"><span class="hljs-type">Data</span></span>.<span class="hljs-type"><span class="hljs-type">VitalSigns</span></span>(newHunger) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">RuntimeException</span></span>(<span class="hljs-string"><span class="hljs-string">"They killed the kitty! Bastards!"</span></span>) }</code> </pre><br>         ‚Äî using.   ,          , ,     stay,    goto.  ,   using      ,    ,       .  using  ,       , ‚Äî       . <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚ÄúVivifying Pathology‚Äù, or how to test exceptions </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will not describe all the tests, to save time and space. </font><font style="vertical-align: inherit;">They are not much different from previous ones. </font><font style="vertical-align: inherit;">From the interesting, I consider it necessary to mention the method of testing the thrown out exception. </font><font style="vertical-align: inherit;">Actually, for FSM it is no different from the method applicable to ordinary actors:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-string"><span class="hljs-string">"should die of hunger"</span></span> in <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">AwakeKoteState</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">Hungry</span></span> { intercept[<span class="hljs-type"><span class="hljs-type">RuntimeException</span></span>] { kote.receive(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">GrowHungry</span></span>(<span class="hljs-number"><span class="hljs-number">1000</span></span>)) <span class="hljs-comment"><span class="hljs-comment">// headshot } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of sending a message (which would have caused the delivery of the exection not to the test, but to the supervisor actor, which in this case is a user guardian, and the test would simply not pass), we use the actor's receive method call directly. </font><font style="vertical-align: inherit;">This is necessary in order to make sure that the automaton throws out the correct exception in a particular situation. </font><font style="vertical-align: inherit;">After all, it will depend on this further, whether the almighty supervisor will reanimate our poor animal, finding the appropriate mark for his strategy in the ejected exception. </font><font style="vertical-align: inherit;">It was for the demonstration of this test that I used the exception as the cause of the cat's death. </font><font style="vertical-align: inherit;">And it would be possible to simply return stop () - but so normal cats die from old age, and not from hunger.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> "Stop sleeping already, sonya!", Or how to limit the length of time in the state </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So that we ourselves no longer fall asleep, I will tell you about the last feature that I would not like to bypass. </font><font style="vertical-align: inherit;">This is the ability to set the maximum timeout for a state. </font><font style="vertical-align: inherit;">It is set simply: it is indicated after the comma in the when function, immediately after the state name. </font><font style="vertical-align: inherit;">For example, after 3 hours of sleep, the cat wakes up on its own, and you do not need to wake it up:</font></font><br><br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>hours) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">WakeUp</span></span>, _) =&gt; goto(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> What do you think will wake up? </font></font> Nah<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By itself, the timeout neither the state nor the data does not change. This can only be done by the cat itself, by its own volitional decision (well, still Neo, but I heard he will not return again, and old Chuck is no longer a cake). And in the only place - in the function of behavior (this does not apply to Neo, he could anywhere, just like Chuck in his youth). But now, after a specified period of time, if no one is awakened by a cat, he will receive a StateTimeout message. And how to react to it is already for him to decide:</font></font><br><br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>hours) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">WakeUp</span></span> | <span class="hljs-type"><span class="hljs-type">StateTimeout</span></span>, _) =&gt; goto(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now he can wake up for two reasons: if he slept long enough and slept, or if he was woken up forcibly. You can separate these two events, and respond to them in different ways: in one case, be active and playful, and in the other - be an evil stinker, constantly meow and annoy and upset everyone. In any case, if the cat is out of sleep, then the timeout will automatically be canceled (unlike the stupid scheduler, which you need to cancel yourself) and nothing supernatural will happen. By the way, if the cat gets a timeout, but continues to sleep (returning stay ()), he will receive it again after 3 hours, as expected. That is, the time-out, without being explicitly canceled or reassigned (using stay (). ForMax (20.hours), what's next), but being caught in the behavioral function and accompanied by the stay () response,"Shoot" again after a specified period of time.</font></font><br><br>  ,  state timeout     when (           ),          goto     stay      forMax (, <i>stay().forMax(1.minute)</i> ,  <i>goto(State.Sleeping).using(Data.Something).forMax(1.minute)</i> ),            (    when,      ): <br><br><pre> <code class="scala hljs">when(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span>, <span class="hljs-number"><span class="hljs-number">3.</span></span>hours) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">Commands</span></span>.<span class="hljs-type"><span class="hljs-type">WakeUp</span></span>, _) =&gt; goto(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>).forMax(<span class="hljs-number"><span class="hljs-number">3.</span></span>hours) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Event</span></span>(<span class="hljs-type"><span class="hljs-type">StateTimeout</span></span>, _) =&gt; goto(<span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span>).forMax(<span class="hljs-number"><span class="hljs-number">5.</span></span>hours) }</code> </pre><br>   ,   ,   3 ,    ‚Äî 5 .  ,  ,     StateTimeout   Awake. <br><br><h3> ¬´?!    ?!!¬ª,          </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And finally, the very last thing, I promise. </font><font style="vertical-align: inherit;">There is another useful feature in Akka FSM: the onTransition method. </font><font style="vertical-align: inherit;">It allows you to set some actions in the transition from state to state. </font><font style="vertical-align: inherit;">Use it like this:</font></font><br><br><pre> <code class="scala hljs">onTransition { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Awake</span></span> =&gt; log.warning(<span class="hljs-string"><span class="hljs-string">"Meow!"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ -&gt; <span class="hljs-type"><span class="hljs-type">State</span></span>.<span class="hljs-type"><span class="hljs-type">Sleeping</span></span> =&gt; log.info(<span class="hljs-string"><span class="hljs-string">"Zzzzz..."</span></span>) }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It seems to be obvious, but just in case I will explain: at the moment of transition from a sleeping state to a waking state, the kitten meows in a special way exactly once. </font><font style="vertical-align: inherit;">When going from </font></font><u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">any</font></font></u><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> state to a state of sleep, a single snore publishes (this is how it sounds in English. From this we conclude that our kote is British). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These actions work even when you set a state in the test using the </font><i><font style="vertical-align: inherit;">FSMActorRef.setState</font></i><font style="vertical-align: inherit;"> function</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(if the transition from the current to the target state coincides with one of those described in onTransition, of course). Thus, respectively, they can be tested. Well, remember that here the use of the goto function will be meaningless. I am telling you this as a person who once stubbornly tried to change the data during a change of states, and for a long time could not understand why it did not work. One more thing that I discovered: the transition trigger will work even if you remain in the current state by returning stay () from the behavioral function. This was promised to be fixed in the next versions of Akka, but for the time being it would mean that if you return stay () when reacting to any of the Sleeping states, then onTransition will work and your kitten will snore.</font></font><br><br><h3>  the end </h3><br>  ,      .           :  ,    when          ?       whenUnhandled.  Thank you all for your attention. <br><br> PS   ,  ,  ,          . </div><p>Source: <a href="https://habr.com/ru/post/237657/">https://habr.com/ru/post/237657/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237641/index.html">What to do an IT specialist in the army or how I wrote games on a VBA</a></li>
<li><a href="../237643/index.html">Using SQLite in Windows and Windows Phone JavaScript applications</a></li>
<li><a href="../237645/index.html">How to write a game in 1 day or Another snotty post-half manual on how to quickly learn C #</a></li>
<li><a href="../237651/index.html">Maven spacecraft successfully arrived at Mars orbit</a></li>
<li><a href="../237653/index.html">Double afterburner. The first success story of Russian crowdinvesting</a></li>
<li><a href="../237659/index.html">Principles of building management reports based on data from existing accounting databases</a></li>
<li><a href="../237663/index.html">Battle for the minimum rating</a></li>
<li><a href="../237665/index.html">Oculus Announces Oculus Platform Application Catalog</a></li>
<li><a href="../237669/index.html">Game Designer: Build Model</a></li>
<li><a href="../237671/index.html">Blind set - paper mode</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>