<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to topological spaces. Java finite topology programming. Part 2: Base topology. Continuous display</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parts list: 



- Part 1: Topology Definition. Open and closed sets. 
- Part 2: Base topology. Continuous mappings. 

 Introduction 
 Last time we met...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to topological spaces. Java finite topology programming. Part 2: Base topology. Continuous display</h1><div class="post__text post__text-html js-mediator-article"><h1>  Parts list: </h1><br><br><ul><li>  <a href="http://habrahabr.ru/post/248659/">Part 1: Topology Definition.</a>  <a href="http://habrahabr.ru/post/248659/">Open and closed sets.</a> </li><li>  Part 2: Base topology.  Continuous mappings. </li></ul><br><br><h1>  Introduction </h1><br>  Last time we met with the basic concepts of the theory of topological spaces, and also considered a class for representing finite topological spaces, written in the Java language.  Today we will move on, examine the concept of a base of topology and get an idea of ‚Äã‚Äãwhat it is needed for, and also define the concept of a continuous mapping of topological spaces.  The main interest is caused by the fact that in the topological space there is no concept of <i>distance between objects</i> , but nevertheless, we can describe in formal language the sufficient proximity of objects in terms ... Well, by the way, you will find out later. <br><a name="habracut"></a><br><h1>  Base topology </h1><br>  Before we go further, I would like to ask you the following simple question. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Exercise 0. Let X be a set of n elements.</i>  <i>How many elements does the discrete topology of t contain, which contains all the subsets of the set X?</i> <br><br>  Obviously, the answer will be 2 <sup>n</sup> . <br>  If we used the class described in the previous article to create a discrete topology on a set of 10 elements, then we would need to add 1024 sets to the topology: quite a lot of routine work, don't you find? <br><br>  But with the help of the base, you only need to set only 10 sets instead of 1024. And if your topology is not discrete, then even less. <br><br>  So, we proceed to the definition.  There are several equivalent definitions of the base topology.  I will give the basic definition used in the Kolmogorov school, and then I will prove the equivalence of another definition. <br><br>  <i>Definition 1. A collection J of open subsets of a set X is called a base of topology if any open subset G of the space (X, t) can be represented as the union of a certain set of sets from J.</i> <br><br>  From the mathematical point of view, this definition is quite understandable, but to program it is a fairly non-trivial task.  The situation is complicated by the fact that the set G does not have to be the union of two sets of a base, it can be the union of three, and four, and so on. <br><br>  Fortunately, the following theorem will help simplify the matter. <br>  <i>Theorem 1. In order for system J to be a base of topology, it is necessary and sufficient that for each open set G and for each point x from G there exists a set G (x) belonging to J and containing x such that G (x) is subset of G.</i> <br><br>  The proof of the theorem is also rather simple.  First we prove the sufficiency of the condition.  This means that if the written condition is satisfied, then J will be the base of the topology. <br>  But if it is satisfied, then G can be represented as a union over all x from G of the sets G (x), that is, the condition from the definition is satisfied, and J is the base of the topology. <br>  The necessity of the condition means that if J is a base, then our condition is true.  But if J is a base, then any open set is representable as a union of sets from J, whence the condition immediately follows. <br><br>  This theorem is already better at helping to program the algorithm for determining whether a given system of subsets is a base, however, the difficulty here is that the first quantifier of a condition is a universal quantifier. <br><br>  And this means that when designing the algorithm, we have to go from the opposite: first, we believe that our system is a base, and we change the solution if the opposite is true. <br><br>  In mathematics, such conditions are reversed as follows: the quantifier of universality is replaced by the quantifier of existence and vice versa, and the predicate is replaced by the reverse. <br><br>  Therefore, the algorithm written in natural language will be as follows: <br><br>  <i>1. We consider that the argument of the method is the base of the topology.</i> <i><br></i>  <i>2. <b>If there exists an open set G and such a point x from G that any set G from the method argument containing x is NOT a subset of G, then return FALSE, otherwise return TRUE.</b></i> <br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isBase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FSet&lt;FSet&lt;Integer&gt;&gt; mbbase)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; Node t = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; flag) { FSet&lt;Integer&gt; open = t.elem; FSet&lt;Integer&gt;.Node openNode = open.first; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isSubsetOpen = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (openNode != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; isSubsetOpen) { Integer x = openNode.elem; Node baseNode = mbbase.first; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> forall = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (baseNode != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; forall) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (baseNode.elem.contains(x) &amp;&amp; baseNode.elem.subset(open)) forall = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; baseNode = baseNode.next; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (forall) { flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; isSubsetOpen = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } openNode = openNode.next; } t = t.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; }</code> </pre> <br><br>  Now create a small class for the base. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSet</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSet</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Integer</span></span></span><span class="hljs-class">&gt;&gt;</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Base</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(); } }</code> </pre><br><br>  This is necessary in order to be able to write a topology constructor on the base. <br><br>  If we just wrote FSet &lt;FSet&gt;, we would get the following error from the compiler: we already have a constructor with FSet parameters.  This is a feature of the Java language. <br><br>  And to supplement the system to the topology is quite easy, just add a few private methods.  But before, simple puzzles. <br><br>  <i>Problem 1. Let X be the set of cardinality n, and m the discrete topology defined on this set.</i>  <i>Find the base topology.</i> <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uniteAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node p = first; p != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; p = p.next) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node q = first; q != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; q = q.next) add(p.elem.union(q.elem)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">intersectAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node p = first; p != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; p = p.next) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node q = first; q != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; q = q.next) add(p.elem.intersection(q.elem)); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Topology</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base base)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (Node p = base.first; p != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; p = p.next) add(p.elem); <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isTpl = isTopology(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (!isTpl) { uniteAll(); intersectAll(); isTpl = isTopology(); } }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Answer to the problem</b> <div class="spoiler_text">  The base of the topology consists of all singleton subsets: {{1}, {2}, ..., {n}} <br></div></div><br><br>  If we talk about general topology, then a rather important class of topological spaces are spaces with a countable base.  They are also called <i>spaces with the second axiom of countability.</i> <br><br>  It is easy to see that finite topological spaces, namely, we program them, form a subset of all spaces with the second axiom of countability. <br><br>  But if this is the second axiom of countability, then there must be the first one, right?  We are going to do it now and then plunge into continuous mappings. <br><br><h1>  Determining neighborhood systems </h1><br><br>  <i>Definition 2.</i> Let for a point x of a topological space X there exists <b>no more than a countable</b> system of neighborhoods {O <sub>n</sub> (x)} such that for every open set G containing x there is a neighborhood O <sub>n (x)</sub> contained in G. This The system is called the defining system of neighborhoods of the point x. <br><br>  <i>Definition 3.</i> If for each point x there exists its defining system of neighborhoods, then the space satisfies the first axiom of countability. <br><br>  This definition is of greater interest in the framework of the general topology than in the finite topologies considered now, since it is possible to simply take the system of all neighborhoods of a given point as such a system.  However, even here you can put one interesting question, which I will kindly give you. <br><br>  <i>Task 3.</i> Give an example of a finite topological space in which the defining system of neighborhoods of a point lies strictly inside the system of all neighborhoods of a given point. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isFundamentalSystem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, ArrayList&lt;FSet&lt;Integer&gt;&gt; neighbourhoods)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; Node t = first; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (t != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; flag) { FSet&lt;Integer&gt; open = t.elem; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (open.contains(x)) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isSubset = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; neighbourhoods.size() &amp;&amp; !isSubset) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbourhoods.get(i).subset(open)) isSubset = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; i++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!isSubset) flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } t = t.next; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; }</code> </pre><br><br><div class="spoiler">  <b class="spoiler_title">Answer to the problem</b> <div class="spoiler_text">  Let X = {1,2,3,4}, m = {√ò, {1}, {3}, {2,4}, {1,3}, {1,2,4}, {2,3 , 4}, {1,2,3,4}}. <br><br>  The system {{3}} is the defining system of the neighborhood of point 3. <br></div></div><br><br><h1>  Continuous display </h1><br>  Here we come to the most interesting place of our lecture today.  To continuous mappings. <br><br>  In principle, Java already has an interface for mappings: <a href="http://download.java.net/lambda/b61/docs/api/java/util/functions/Mapper.html">Mapper</a> , but due to the fact that it contains two methods, it cannot be used as a functional interface. <br><br>  I use Java 8, and I would like to write mappings in a more convenient way than to create a class, an implementation interface, and so on.  If your development environment does not support Java 8, the method code will still work, but the call code will have to be changed. <br><br>  So, I will create the following simple interface. <br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@FunctionalInterface</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mapping</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-function">Integer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Integer x)</span></span></span></span>; }</code> </pre><br><br>  The summary above is optional, but it will give an error if you add another abstract method to the interface. <br><br>  We now turn to the mathematical side of the question and give the concept of continuity in terms of neighborhoods of a point. <br><br>  <i>Definition 4.</i> Let (X, 1) and (Y, 2) be two topological spaces.  A mapping f of a space X to a space Y is called continuous at the point x <sub>0</sub> , if for any neighborhood U <sub>y <sub>0 of the</sub></sub> point y <sub>0</sub> = f (x <sub>0</sub> ) there is a neighborhood V <sub>x <sub>0 of the</sub></sub> point x <sub>0</sub> such that f (V <sub>x <sub>0</sub></sub> ) is contained inside U <sub>y <sub>0</sub></sub> .  A mapping f is called continuous if it is continuous at each point. <br><br>  If this is translated into Russian, then the definition of continuity at a point would sound something like this: <i>Whatever neighborhood of the image of a given point we take, there is a neighborhood of this point that the image of this neighborhood lies within the neighborhood of the image of a point.</i> <br><br>  Just a minute ... If we recall the beginning of the analysis, then we get exactly the definition of the continuity of the function according to Cauchy, with the only difference that we left the epsilon-delta of the language and replaced the partial order ratio in the definition of proximity. <br><br>  But not everything is so simple here.  Therefore, I offer you an interesting puzzle. <br>  <i>Problem 4.</i> Let X be a topological space with a base {{1}, {2,4}, {1,2,3,4}}, Y with a base {{1}, {3}, {1,2, 3.4}}. <br>  Consider the identity mapping f from X to Y, acting by the rule f (x) = x.  Is it continuous?  If so, prove it.  If not, show where it breaks. <br>  The same question applies to the mapping f from Y to X, acting by the rule f (x) = x. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isContinuous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Mapping f, Integer x0, Topology Y)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> flag = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y0 = ff(x0); ArrayList&lt;FSet&lt;Integer&gt;&gt; Uy0 = Y.getNeighbourhoods(y0); ArrayList&lt;FSet&lt;Integer&gt;&gt; Vx0 = getNeighbourhoods(x0); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i &lt; Uy0.size() &amp;&amp; flag) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> subset = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (j &lt; Vx0.size() &amp;&amp; !subset) { FSet&lt;Integer&gt; image = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (FSet&lt;Integer&gt;.Node p = Vx0.get(j).first; p != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; p = p.next) { image.add(ff(p.elem)); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (image.subset(Uy0.get(i))) subset = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; j++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!subset) flag = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; i++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> flag; }</code> </pre><br><br>  This time I will give you the execution code: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> generaltopology; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> java.util.*; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FSetDemo</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Base baseX = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Base(); FSet&lt;Integer&gt; x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); x.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); x.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); x.add(<span class="hljs-number"><span class="hljs-number">3</span></span>); x.add(<span class="hljs-number"><span class="hljs-number">4</span></span>); FSet&lt;Integer&gt; a = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); a.add(<span class="hljs-number"><span class="hljs-number">1</span></span>); FSet&lt;Integer&gt; b = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); b.add(<span class="hljs-number"><span class="hljs-number">2</span></span>); b.add(<span class="hljs-number"><span class="hljs-number">4</span></span>); FSet&lt;Integer&gt; c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FSet&lt;&gt;(); c.add(<span class="hljs-number"><span class="hljs-number">3</span></span>); baseX.add(a); baseX.add(b); baseX.add(x); Base baseY = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Base(); baseY.add(a); baseY.add(c); baseY.add(x); Topology tau = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Topology(baseX); System.out.println(tau); Topology tau2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Topology(baseY); System.out.println(tau2); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { System.out.print(tau.isContinuous(u -&gt; u, i, tau2) + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } System.out.println(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { System.out.print(tau2.isContinuous(u -&gt; u, i, tau) + <span class="hljs-string"><span class="hljs-string">" "</span></span>); } } }</code> </pre><br><br>  As you can see, the use of lambda expressions is quite justified here, since it allows you to accurately set the rule for mapping one space to another. <br><br>  And, as I promised, the answer is: <br><br><div class="spoiler">  <b class="spoiler_title">Answer</b> <div class="spoiler_text">  Neither mapping is continuous. <br>  The mapping of X to Y is discontinuous at point 3. <br>  The mapping of Y to X is discontinuous at points 2 and 4. <br></div></div><br><br>  <i>Conclusion</i> <br>  Today we got acquainted with the important concept of the <i>base of topology</i> and learned how to build the whole topology of space on it.  We learned about the axioms of countability and the fact that finite topologies satisfy both axioms of countability. <br><br>  In the next part, I plan to talk a little more about the mappings of topological spaces, introduce the notion of open and closed mappings, and also give a sign of the continuity of the mapping, which will be simpler than stated in the definition and move on to a new topic: separability axioms. <br><br>  At the end of this series of articles, I also plan to give some practical example of the application of the final topology.  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/249163/">https://habr.com/ru/post/249163/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../249143/index.html">Automate and speed up the process of setting up cloud servers with Ansible. Part 1: Introduction</a></li>
<li><a href="../249145/index.html">2014 dotGo conference in Paris</a></li>
<li><a href="../249151/index.html">Free internet for tablet from Beeline and MTS</a></li>
<li><a href="../249155/index.html">Analytics for December, plans for a new iPhone, Roskomnadzor measures - and other news of the week for a mobile developer</a></li>
<li><a href="../249159/index.html">Apple fixed important OS X vulnerabilities</a></li>
<li><a href="../249165/index.html">Features of domain modeling using OOP</a></li>
<li><a href="../249167/index.html">Pebble: an example of using an Android companion</a></li>
<li><a href="../249169/index.html">AdBlock Plus and Adguard + Anti-Adblock banner blocking bypass</a></li>
<li><a href="../249173/index.html">We continue to watch Moscow‚Äôs public video surveillance cameras</a></li>
<li><a href="../249175/index.html">Conveyor - time delayed data element processing</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>