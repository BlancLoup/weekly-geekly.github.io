<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating 3D Chess in Unity</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not every successful game must be dedicated to shooting aliens or saving the world. The history of board games, and in particular chess, dates back th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating 3D Chess in Unity</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/525/a28/2da/525a282da93c7c161363b33ad39d143a.gif" alt="image"></div><br>  Not every successful game must be dedicated to shooting aliens or saving the world.  The history of board games, and in particular chess, dates back thousands of years.  It is not only interesting to play in them - the very idea of ‚Äã‚Äãporting a board game from the real world to a video game is fascinating. <br><br>  In this tutorial, we will create a 3D chess game on Unity.  In the process, you will learn.  how to implement the following: <br><br><ul><li>  How to choose a moving shape </li><li>  How to determine allowed moves </li><li>  How to change players </li><li>  How to recognize the state of victory </li></ul><br>  By the end of this tutorial, we will create a multipurpose chess game that can be used as a basis for developing other board games. <br><a name="habracut"></a><br><blockquote>  <em>Note:</em> you need to know Unity and the C # language.  If you want to increase your skill in C #, then you can start with a series of video courses <a href="https://videos.raywenderlich.com/courses/47-beginning-c/lessons/1" rel="noopener">Beginning C # with Unity Screencast</a> . </blockquote><h2>  Getting Started </h2><br>  Download <a href="">project materials</a> for this tutorial.  To get started, open a project stub in Unity. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Chess is often realized as a simple 2D game.  However, in our 3D version we will imitate a player sitting at a table and playing with his friend.  In addition, 3D is awesome. <br><br>  Open the <em>Main</em> scene from the <em>Scenes</em> folder.  You will see the <em>Board</em> object, which is the game board, and the object for the <em>GameManager</em> .  Scripts are already attached to these objects. <br><br><ul><li>  <em>Prefabs</em> : it contains a board, individual figures and indicator squares for selecting cells, which we will use in the process of choosing a turn. </li><li>  <em>Materials</em> : here are materials for chessboard, figures and cells. </li><li>  <em>Scripts</em> : contains components that are already attached to objects in the hierarchy. </li><li>  <em>Board</em> : controls the visual display of shapes.  This component is also responsible for the selection of individual shapes. </li><li> <em>Geometry.cs</em> : A helper class that manages the transformations between row / column recording and <code>Vector3</code> points. </li><li>  <em>Player.cs</em> : controls the player‚Äôs pieces as well as the pieces taken by the player.  In addition, it contains the direction of movement of pieces for which direction is important, for example, for pawns. </li><li>  <em>Piece.cs</em> : base class that defines enumerations for all figure instances.  Also contains the logic for determining the allowable moves in the game. </li><li>  <em>GameManager.cs</em> : stores game logic, such as allowable moves, the initial arrangement of the pieces at the beginning of the game, and more.  This is a singleton, so it is convenient for other classes to call it. </li></ul><br>  <code>GameManager</code> contains a 2D array of <code>pieces</code> that stores the positions of pieces on the board.  Explore <code>AddPiece</code> , <code>PieceAtGrid</code> and <code>GridForPiece</code> to understand how it works. <br><br>  Turn on Play mode to look at the board and see the figures ready for the game. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/731/8b7/f44/7318b7f44668f2185b87718144046fb5.png"></div><br><h2>  Moving shapes </h2><br>  First of all, we need to determine which piece to move. <br><br>  You can determine which cell the player hoisted the mouse by using <em>raycasting / raycasting</em> .  If you do not know how ray tracking in Unity works, then read our tutorial <a href="https://www.raywenderlich.com/127672/introduction-unity-scripting" rel="noopener">Introduction to Unity scripting</a> or a popular tomial about the game <a href="https://www.raywenderlich.com/167052/bomberman-tutorial-fun-blowing-friends" rel="noopener">Bomberman</a> . <br><br>  After the player chooses a figure, we must generate admissible cells to which the figure can move.  Then you need to choose one of them.  To handle this functionality, we will add two new scripts.  <code>TileSelector</code> will help you choose a moving shape, and <code>MoveSelector</code> will allow you to choose a place to move. <br><br>  Both components have the same basic methods: <br><br><ul><li>  <em><code>Start</code></em> : for initial setup. </li><li>  <em><code>EnterState</code></em> : performs customization for the <i>current</i> shape activation. </li><li>  <em><code>Update</code></em> : performs ray tracking as you move the mouse. </li><li>  <em><code>ExitState</code></em> : resets the current state and calls <code>EnterState</code> next state. </li></ul><br>  This is the simplest implementation of the <a href="https://blog.markshead.com/869/state-machines-computer-science/" rel="noopener"><i>state machine</i></a> pattern.  If you need more states, you can make it more formal.  However, this will add complexity. <br><br><h2>  Cell selection </h2><br>  Select <em>Board</em> from the hierarchy.  Then click on the <em>Add Component</em> button in the Inspector window.  Type <em>TileSelector</em> in the field and click <em>New Script</em> .  Finally, click <em>Create and Add</em> to attach the script. <br><br><blockquote>  <em>Note:</em> when creating new scripts, take time to move them to the appropriate folder to maintain order in the <em>Assets</em> folder. </blockquote><br><h3>  Select the selected cell </h3><br>  Double-click <em>TileSelector.cs</em> to open it, and add the following variables inside the class definition: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject tileHighlightPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject tileHighlight;</code> </pre> <br>  In these variables is stored a transparent overlay pointing to the cell under the mouse cursor.  The prefab is assigned in edit mode and the component tracks the selection and moves with it. <br><br>  Next, add the following lines to <code>Start</code> : <br><br><pre> <code class="cs hljs">Vector2Int gridPoint = Geometry.GridPoint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Vector3 point = Geometry.PointFromGrid(gridPoint); tileHighlight = Instantiate(tileHighlightPrefab, point, Quaternion.identity, gameObject.transform); tileHighlight.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  <code>Start</code> gets the source row and column for the selected cell, turns them to a point and creates a game object from the prefab.  This object is initially deactivated, so it will not be visible until it is needed. <br><br>  <em>Note: It</em> is useful to refer to the coordinates for the row and column, which take the form <code>Vector2Int</code> and are <code>Vector2Int</code> to as <code>GridPoint</code> .  <code>Vector2Int</code> has two integer values: x and y.  When we need to place an object in a scene, we need a <code>Vector3</code> point.  <code>Vector3</code> has three floating point values: x, y, and z. <br><br>  <em>Geometry.cs</em> are helper methods for the following transformations: <br><br><ul><li>  <em><code>GridPoint(int col, int row)</code></em> : gives us a <code>GridPoint</code> for a given column and row. </li><li>  <em><code>PointFromGrid(Vector2Int gridPoint)</code></em> : converts a <code>GridPoint</code> to a real point of the <code>Vector3</code> scene. </li><li>  <em><code>GridFromPoint(Vector3 point)</code></em> : gives us a <code>GridPoint</code> for the x and z values ‚Äã‚Äãof this 3D point, and the y value is ignored. </li></ul><br>  Next we will add <code>EnterState</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  This allows you to re-enable the component when it is time to select another shape. <br><br>  Next, add the following to <code>Update</code> : <br><br><pre> <code class="cs hljs">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { Vector3 point = hit.point; Vector2Int gridPoint = Geometry.GridFromPoint(point); tileHighlight.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); tileHighlight.transform.position = Geometry.PointFromGrid(gridPoint); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { tileHighlight.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }</code> </pre> <br>  Here we create a ray of <code>Ray</code> from the camera, passing through the mouse pointer and on, to infinity. <br><br>  <code>Physics.Raycast</code> checks if this ray intersects with any <em>physical colliders of the</em> system.  Since the board is the only object with a collider, we do not need to worry that the figures will overlap each other. <br><br>  If the beam intersects the collider, then <code>RaycastHit</code> recorded in <code>RaycastHit</code> , including the intersection point.  Using an auxiliary method, we turn this intersection point into a <code>GridPoint</code> , and then use this method to set the position of the selected cell. <br><br>  Since the mouse pointer is over the board, we also turn on the selected cell so that it is displayed. <br><br>  Finally, select <em>Board</em> from the hierarchy and in the Project window click on <em>Prefabs</em> .  Then drag the <em>Selection-Yellow</em> prefab into the <em>Tile Highlight</em> slot of the <em>Prefab</em> component of the <em>Tile Selector</em> board. <br><br>  Now if you start the Play mode, you will see a yellow selection box that follows the mouse pointer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0dc/a4f/70b/0dca4f70b8d7cf4afcff932b866d7364.gif"></div><br><h3>  Figure selection </h3><br>  To select a shape, we need to check if the mouse button is down.  Add this check to the <code>if</code> block, right after the place where we turn on the cell selection: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { GameObject selectedPiece = GameManager.instance.PieceAtGrid(gridPoint); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(GameManager.instance.DoesPieceBelongToCurrentPlayer(selectedPiece)) { GameManager.instance.SelectPiece(selectedPiece); <span class="hljs-comment"><span class="hljs-comment">//   1:      ExitState } }</span></span></code> </pre> <br>  If the mouse button is pressed, the <code>GameManager</code> sends us a figure in the current position.  We need to check whether this piece belongs to the current player, because players should not be able to move the opponent‚Äôs pieces. <br><br><blockquote>  <em>Note:</em> in such complex games, it is useful to clearly define the limits of responsibility of the components.  <code>Board</code> deals only with the display and selection of figures.  <code>GameManager</code> tracks the values ‚Äã‚Äãof the <code>GridPoint</code> positions of the shapes.  It also contains helper methods that answer questions about where the pieces are and to which player they belong. </blockquote><br>  Launch Play mode and select a shape. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d8d/d84/bd7/d8dd84bd792e88bc3bd88e84c8214772.png"></div><br>  Having chosen a figure, we must learn to move it to a new cell. <br><br><h2>  Selection point </h2><br>  At this point, <code>TileSelector</code> did all its work.  It is time for another component: <code>MoveSelector</code> . <br><br>  This component is similar to <code>TileSelector</code> .  As before, select the <code>Board</code> object in the hierarchy, add a new component to it and name it <code>MoveSelector</code> . <br><br><h3>  Transfer of control </h3><br>  The first thing we need to achieve is to learn how to transfer control from <code>TileSelector</code> to the <code>TileSelector</code> component.  To do this, you can use <code>ExitState</code> .  Add the following method to <em>TileSelector.cs</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExitState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject movingPiece</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tileHighlight.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); MoveSelector move = GetComponent&lt;MoveSelector&gt;(); move.EnterState(movingPiece); }</code> </pre> <br>  It hides the cell overlay and disables the <code>TileSelector</code> component.  In Unity, you cannot call the <code>Update</code> method of disabled components.  Since we now want to call the <code>Update</code> method of the new component, then by disabling the old component, it will not disturb us. <br><br>  Call this method by adding the following line to <code>Update</code> immediately after <code>  1</code> : <br><br><pre> <code class="cs hljs">ExitState(selectedPiece);</code> </pre> <br>  Now open the <code>MoveSelector</code> and add these instance variables at the top of the class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject moveLocationPrefab; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject tileHighlightPrefab; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameObject attackLocationPrefab; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject tileHighlight; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameObject movingPiece;</code> </pre> <br>  They contain mouse selection, cell overlays for movement and attack, as well as an instance of the selection cell and the shape selected in the previous step. <br><br>  Then add the following setup code to <em>Start</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tileHighlight = Instantiate(tileHighlightPrefab, Geometry.PointFromGrid(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)), Quaternion.identity, gameObject.transform); tileHighlight.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>);</code> </pre> <br>  This component must initially be in a disabled state, because we first need to run a <code>TileSelector</code> .  Then we load the selection overlay just as we did before. <br><br><h3>  Move the shape </h3><br>  Next, add the <code>EnterState</code> method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EnterState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject piece</span></span></span><span class="hljs-function">)</span></span> { movingPiece = piece; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  When calling this method, it saves the moving shape and includes itself. <br><br>  Add the following lines to the <code>Update</code> method of the <code>MoveSelector</code> component: <br><br><pre> <code class="cs hljs">Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hit; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Physics.Raycast(ray, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> hit)) { Vector3 point = hit.point; Vector2Int gridPoint = Geometry.GridFromPoint(point); tileHighlight.SetActive(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); tileHighlight.transform.position = Geometry.PointFromGrid(gridPoint); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetMouseButtonDown(<span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-comment"><span class="hljs-comment">//   2:     if (GameManager.instance.PieceAtGrid(gridPoint) == null) { GameManager.instance.Move(movingPiece, gridPoint); } //   3:        ExitState(); } } else { tileHighlight.SetActive(false); }</span></span></code> </pre> <br>  In this case, <code>Update</code> similar to the method from <code>TileSelector</code> and uses the same <code>Raycast</code> check to find out which cell a mouse is on.  However, this time, when you click the mouse button, we call <code>GameManager</code> to move the shape to a new square. <br><br>  Finally, add an <code>ExitState</code> method to reset everything and prepare for the next move: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExitState</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.enabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tileHighlight.SetActive(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); GameManager.instance.DeselectPiece(movingPiece); movingPiece = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; TileSelector selector = GetComponent&lt;TileSelector&gt;(); selector.EnterState(); }</code> </pre> <br>  We disable this component and hide the cell selection overlay.  As the shape is moved, we can clear this value and ask the <code>GameManager</code> to remove the selection from the shape.  Then we call <code>EnterState</code> from <code>TileSelector</code> to start the process from the beginning. <br><br>  Select in the <em>Board</em> editor and drag the prefabs overlay the cells from the prefabs folder into the <code>MoveSelector</code> slots: <br><br><ul><li>  <em>Move Location Prefab</em> should be <code>Selection-Blue</code> </li><li>  <em>Tile Highlight Prefab</em> should be <code>Selection-Yellow</code> . </li><li>  <em>Attack Location Prefab</em> must be <code>Selection-Red</code> . </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c12/4aa/319/c124aa319f84abc033536e688dd91dc5.png"></div><br>  Colors can be changed by setting the materials. <br><br>  Start the Play mode and try to move the shapes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cd4/260/855/cd426085563d1e0795363f9262969aed.png"></div><br>  You will notice that you can move the shapes to any empty cell.  It would be a very strange chess game!  In the next step, we will make the pieces move according to the rules of the game. <br><br><h2>  Determine the allowed moves </h2><br>  In chess, each piece has its own permissible moves.  Some can move in any direction, others can move to a certain number of cells, and others can only move in one direction.  How do we keep track of all these options? <br><br>  One way is to create an abstract base class that describes all the shapes, followed by creating separate subclasses that override the cell generation method for the turn. <br><br>  We need to answer one more question: where should we generate a list of moves? <br><br>  It would be logical to generate them in the <code>EnterState</code> component of the <code>MoveSelector</code> .  Here we generate overlay cells showing where the player can go, so this is the most reasonable. <br><br><h3>  We generate the list of admissible cells </h3><br>  The overall strategy is to take the selected shape and request from <code>GameManager</code> list of allowable cells (i.e. moves).  <code>GameManager</code> will use a shape subclass to generate a list of possible cells.  It will then filter out positions that are occupied or outside the board. <br><br>  This filtered list is passed back to the <code>MoveSelector</code> , which highlights the allowed moves and waits for the player to choose. <br><br>  The pawn has the simplest move, so it‚Äôs more logical to start with it. <br><br>  Open <em>Pawn.cs</em> in <em>Pieces</em> , and modify <code>MoveLocations</code> to look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveLocations</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int gridPoint</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> locations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector2Int&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> forwardDirection = GameManager.instance.currentPlayer.forward; Vector2Int forward = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(gridPoint.x, gridPoint.y + forwardDirection); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameManager.instance.PieceAtGrid(forward) == <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { locations.Add(forward); } Vector2Int forwardRight = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(gridPoint.x + <span class="hljs-number"><span class="hljs-number">1</span></span>, gridPoint.y + forwardDirection); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameManager.instance.PieceAtGrid(forwardRight)) { locations.Add(forwardRight); } Vector2Int forwardLeft = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(gridPoint.x - <span class="hljs-number"><span class="hljs-number">1</span></span>, gridPoint.y + forwardDirection); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameManager.instance.PieceAtGrid(forwardLeft)) { locations.Add(forwardLeft); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> locations; }</code> </pre> <br>  Here we perform several actions: <br><br>  First, this code creates an empty list for recording positions.  Then he creates a position that represents a cell one step forward. <br><br>  Since the white and black pawns move in different directions, the <code>Player</code> object contains a value that determines the direction of the pawn's movement.  For the first player this value is +1, for the opponent it is -1. <br><br>  Pawns move in a special way and have several special rules.  Although they can move one cell forward, they are not able to take on an opponent figure on that cell;  they take the figures only diagonally forward.  Before adding the front cell as a valid position, we need to check whether another piece takes this place.  If not, we can add the front cell to the list. <br><br>  In the case of taking cells, we also need to check if there is a figure in this position.  If there is, then we can take it. <br><br>  For the time being we will not check whether it belongs to the player or his opponent, but we will deal with it later. <br><br>  In the <em>GameManager.cs</em> script <em>,</em> add this method immediately after the <code>Move</code> method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> List </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MovesForPiece</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameObject pieceObject</span></span></span><span class="hljs-function">)</span></span> { Piece piece = pieceObject.GetComponent(); Vector2Int gridPoint = GridForPiece(pieceObject); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> locations = piece.MoveLocations(gridPoint); <span class="hljs-comment"><span class="hljs-comment">//      locations.RemoveAll(tile =&gt; tile.x &lt; 0 || tile.x &gt; 7 || tile.y &lt; 0 || tile.y &gt; 7); //      locations.RemoveAll(tile =&gt; FriendlyPieceAt(tile)); return locations; }</span></span></code> </pre> <br>  Here we get the <code>Piece</code> component of the game piece, as well as its current position. <br><br>  Next, we ask <code>GameManager</code> list of positions for this shape and filter out invalid values. <br><br>  <code>RemoveAll</code> is a useful function that uses a <i>callback</i> expression <i>(callback mechanism)</i> .  This method looks at each value in the list, passing it to the expression as a <code>tile</code> .  If this expression is <code>true</code> , then the value is removed from the list. <br><br>  This first expression removes positions with x or y values ‚Äã‚Äãthat would place the piece outside the board.  The second filter is similar, but removes all positions in which there are player pieces. <br><br>  At the top of the <em>MoveSelector.cs</em> script <em>class,</em> add the following instance variables: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Vector2Int&gt; moveLocations; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;GameObject&gt; locationHighlights;</code> </pre> <br>  The first stores a list of <code>GridPoint</code> values ‚Äã‚Äãfor move positions;  the second contains a list of overlay cells indicating whether the player can move to this position. <br><br>  Add the following lines to the end of the <code>EnterState</code> method: <br><br><pre> <code class="cs hljs">moveLocations = GameManager.instance.MovesForPiece(movingPiece); locationHighlights = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameObject&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Vector2Int loc <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> moveLocations) { GameObject highlight; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameManager.instance.PieceAtGrid(loc)) { highlight = Instantiate(attackLocationPrefab, Geometry.PointFromGrid(loc), Quaternion.identity, gameObject.transform); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { highlight = Instantiate(moveLocationPrefab, Geometry.PointFromGrid(loc), Quaternion.identity, gameObject.transform); } locationHighlights.Add(highlight); }</code> </pre> <br>  This part performs several actions: <br><br>  First, it receives a list of allowable positions from <code>GameManager</code> and creates an empty list for storing overlay cell objects.  It then loops through each position in the list.  If there is already a figure in the current position, then it must be an opponent figure, because the player‚Äôs figures have already been filtered. <br><br>  The enemy positions are assigned the overlay of the attack, and the remaining positions the overlay of the course. <br><br><h3>  Performing a turn </h3><br>  Add this code under <code>  2</code> , inside the <code>if</code> construct that checks the mouse button: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!moveLocations.Contains(gridPoint)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; }</code> </pre> <br>  If a player clicks on a cell that is not a valid move, then exit the function. <br><br>  Finally, add the code to the end of <code>ExitState</code> in <code>ExitState</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (GameObject highlight <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> locationHighlights) { Destroy(highlight); }</code> </pre> <br>  At this stage, the player chose a move, so we can delete all the overlay objects. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c35/54c/e7b/c3554ce7bb3b1bcdd3672d905a468144.png"></div><br>  Wow!  I had to write a lot of code just to make the pawn move.  Having finished with all the difficult work, it will be easier for us to learn how to move other figures. <br><br><h2>  Next player </h2><br>  If only one side can move, this is not very similar to the game.  Until we fix it! <br><br>  In order for both players to play, we need to decide how to switch between players and where to add the code. <br><br>  Since <code>GameManager</code> is responsible for all the rules of the game, it is most reasonable to insert the switching code into it. <br><br>  Switching itself is quite simple to implement.  <code>GameManager</code> has variables for current and other players, so we just need to swap these values. <br><br>  The difficulty is where do we call for a replacement? <br><br>  The player‚Äôs turn ends when he finishes moving the piece.  <code>ExitState</code> in <code>MoveSelector</code> is called after moving the selected shape, so it seems that it is best to perform a switch here. <br><br>  Add the following method to the end of the <em>GameManager.cs</em> script <em>class</em> : <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextPlayer</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Player tempPlayer = currentPlayer; currentPlayer = otherPlayer; otherPlayer = tempPlayer; }</code> </pre> <br>  To reverse the two values, a third variable is needed, used as an intermediary;  otherwise, we will overwrite one of the values ‚Äã‚Äãbefore it is copied. <br><br>  Let's <em>go</em> to <em>MoveSelector.cs</em> and add the following code to <code>ExitState</code> , just before the <code>EnterState</code> call: <br><br><pre> <code class="cs hljs">GameManager.instance.NextPlayer();</code> </pre> <br>  That's all!  <code>ExitState</code> and <code>EnterState</code> already take care of their own cleaning. <br><br>  Start the Play mode and you will see that now the figures are moving on both sides.  We are already getting closer to the real game. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55c/b21/ced/55cb21ced578c9d3a5ce0dbf939893a5.gif"></div><br><h2>  Taking figures </h2><br>  Taking pieces is an important part of chess.  Since all the rules of the game are in <code>GameManager</code> , open it and add the following method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CapturePieceAt</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int gridPoint</span></span></span><span class="hljs-function">)</span></span> { GameObject pieceToCapture = PieceAtGrid(gridPoint); currentPlayer.capturedPieces.Add(pieceToCapture); pieces[gridPoint.x, gridPoint.y] = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Destroy(pieceToCapture); }</code> </pre> <br>  Here, <code>GameManager</code> checks which piece is in the target position.  This figure is added to the list of taken pieces for the current player.  Then it is removed from the cell record of the <code>GameManager</code> board, and the <code>GameObject</code> destroyed, which removes it from the scene. <br><br>  To take a figure, you need to stand on top of it.  Therefore, the code for calling this action must be in <em>MoveSelector.cs</em> . <br><br>  In the <code>Update</code> method, locate the comment <code>  3</code> and replace it with the following construction: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { GameManager.instance.CapturePieceAt(gridPoint); GameManager.instance.Move(movingPiece, gridPoint); }</code> </pre> <br>  The previous <code>if</code> construct checks <code>if</code> there is a figure in the target position.  Since at the stage of generating moves, the player‚Äôs figures were filtered, then the opponent‚Äôs figure should be on the cage containing the figure. <br><br>  After removing the opponent's piece, the selected piece can make a move. <br><br>  Click on Play and move the pawns until you can take one of them. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/240/e78/8e7/240e788e7e92611d6e970589bb8202a3.gif"></div><br>  I am the queen, you took my pawn - get ready for death! <br><br><h2>  Game completion </h2><br>  The chess game ends when a player takes the opponent's king.  When taking a piece, we check whether it is king.  If yes, then the game is over. <br><br>  But how do we stop the game?  One way is to remove <code>TileSelector</code> and <code>MoveSelector</code> from the board. <br><br>  In the <code>CapturePieceAt</code> method of the <code>CapturePieceAt</code> script <em>,</em> add the following lines before deleting the taken shape: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pieceToCapture.GetComponent&lt;Piece&gt;().type == PieceType.King) { Debug.Log(currentPlayer.name + <span class="hljs-string"><span class="hljs-string">" wins!"</span></span>); Destroy(board.GetComponent&lt;TileSelector&gt;()); Destroy(board.GetComponent&lt;MoveSelector&gt;()); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Disabling these components will not be enough. </font><font style="vertical-align: inherit;">The following challenges </font></font><code>ExitState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>EnterState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">turn on one of them, so the game will continue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Destroy is not only used for classes </font></font><code>GameObject</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; </font><font style="vertical-align: inherit;">You can also use it to remove a component attached to an object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click on Play. </font><font style="vertical-align: inherit;">Move the pawn and take the opponent's king. </font><font style="vertical-align: inherit;">You will see that a victory message will be displayed in the Unity console. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an additional task, you can add UI elements to display the ‚ÄúGame Over‚Äù message or go to the menu screen.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74f/db9/b82/74fdb9b82772e8b5025201265dddc382.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now it is time to get a serious weapon and set in motion more powerful figures! </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Special moves </font></font></h2><br> <code>Piece</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and its individual subclasses are a great tool for encapsulating special relocation rules. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To add moves to some other pieces, you can use tricks from </font></font><code>Pawn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Figures moving one cell in different directions, such as the king and knight, are configured in the same way. </font><font style="vertical-align: inherit;">Try to implement these rules of moves independently. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Look at the finished project code if you need a hint.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cell moves </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A more difficult case are the pieces that can move several cells in the same direction, namely the bishop, rook and queen. It's easier to show an elephant, so let's start with it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There </font></font><code>Piece</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">are pre-prepared lists of directions in which the bishop and the rook can move from the starting point. These are all directions from the current position of the shape. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bishop.cs</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and replace with the </font></font><code>MoveLocations</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">following code:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> List&lt;Vector2Int&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveLocations</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int gridPoint</span></span></span><span class="hljs-function">)</span></span> { List&lt;Vector2Int&gt; locations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector2Int&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Vector2Int dir <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> BishopDirections) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { Vector2Int nextGridPoint = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(gridPoint.x + i * dir.x, gridPoint.y + i * dir.y); locations.Add(nextGridPoint); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameManager.instance.PieceAtGrid(nextGridPoint)) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> locations; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The cycle </font></font><code>foreach</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">goes around each direction. For each direction, there is a second cycle that generates a sufficient number of new positions to move the piece off the board. Since the position list will filter out positions outside the board, we just need so many of them so that we don‚Äôt miss any cells. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At each stage, we will generate </font></font><code>GridPoint</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">for the position and add it to the list. Then check if there is a figure in this position. If so, stop the inner loop to go in the next direction. </font></font><br><br> <code>break</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">added because the standing figure will block further movement. Again, down the chain, we remove the filter position with the player's figures, so that we no longer interfere with their presence.</font></font><br><br><blockquote> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Note:</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if you need to distinguish the direction forward from the direction backwards, or left from the right, then you need to take into account that the black and white pieces move in opposite directions.</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In chess, this is important only for pawns, but in other games such distinction may be necessary. </font></font><br><br>  That's all!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Start the Play mode and try to play. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85b/ebe/e2a/85bebee2a3152455c6f880f25c411415.png"></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Move the queen </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The queen is the strongest piece, so it is best to finish on him. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The queen move is a combination of the bishop and the rook; </font><font style="vertical-align: inherit;">The base class contains an array of directions for each shape. </font><font style="vertical-align: inherit;">It will be useful if you can combine these two figures. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Queen.cs,</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> replace with the </font></font><code>MoveLocations</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">following code:</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> List&lt;Vector2Int&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveLocations</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector2Int gridPoint</span></span></span><span class="hljs-function">)</span></span> { List&lt;Vector2Int&gt; locations = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector2Int&gt;(); List&lt;Vector2Int&gt; directions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Vector2Int&gt;(BishopDirections); directions.AddRange(RookDirections); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (Vector2Int dir <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> directions) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { Vector2Int nextGridPoint = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector2Int(gridPoint.x + i * dir.x, gridPoint.y + i * dir.y); locations.Add(nextGridPoint); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (GameManager.instance.PieceAtGrid(nextGridPoint)) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> locations; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only thing that is different here is the transformation of an array of directions into </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The advantage </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is that we can add directions from another array, creating one </font></font><code>List</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with all directions. </font><font style="vertical-align: inherit;">The rest of the method is the same as in the elephant code. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Click on Play again and take the pawns out of the way to make sure everything works correctly.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/525/a28/2da/525a282da93c7c161363b33ad39d143a.gif"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Where to go next? </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this stage we can do several things, for example, to complete the movements of the king, the knight and the rook. </font><font style="vertical-align: inherit;">If you have problems at any of the stages, then study the finished project in the project </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">materials</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There are special rules that we did not implement here, for example, the first move of a pawn to two cells instead of one, castling and some others. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The general pattern is to add to the </font></font><code>GameManager</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">variables and methods that track these situations and their possibility when moving the figure. </font><font style="vertical-align: inherit;">If they are possible, then you need to add corresponding positions in this figure </font></font><code>MoveLocations</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can also make visual improvements to the game. </font><font style="vertical-align: inherit;">For example, the pieces can move to a new position smoothly, and the camera rotates to show the board from the point of view of the second player in his turn.</font></font></div><p>Source: <a href="https://habr.com/ru/post/359356/">https://habr.com/ru/post/359356/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../359344/index.html">Designing software platform protected NAS</a></li>
<li><a href="../359346/index.html">A series of articles: building a secure NAS, or a home mini-server</a></li>
<li><a href="../359348/index.html">Telegram MTPROTO Proxy - everything we know about him</a></li>
<li><a href="../359350/index.html">Data storage: a brief overview of this year‚Äôs trends</a></li>
<li><a href="../359352/index.html">"Finishing line": 5G networks to be, but not before 2020</a></li>
<li><a href="../359358/index.html">ICANN again updated WHOIS policies - again dissatisfied</a></li>
<li><a href="../359362/index.html">Microsoft 365 and its chips</a></li>
<li><a href="../359364/index.html">Making Money From Another's Mistakes: Bug Bounty Story</a></li>
<li><a href="../359366/index.html">3CX CRM integration with Google Contacts</a></li>
<li><a href="../359368/index.html">Depla webpack applications on github.io using Travis CI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>