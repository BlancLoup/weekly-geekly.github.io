<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ZeroMQ. Chapter 1: Getting Started</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 
 I want to start a free translation of the book ‚ÄúZeroMQ.Use ZeroMQ‚Äù. I am sure that many will want to deal with this interesting library. 

 C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ZeroMQ. Chapter 1: Getting Started</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br>  I want to start a <b>free</b> translation of the book ‚ÄúZeroMQ.Use ZeroMQ‚Äù.  I am sure that many will want to deal with this interesting library. <br><br>  Content <br><ul><li>  <b>Chapter 1: Getting Started</b> </li><li>  <a href="http://habrahabr.ru/post/216957/">Chapter 2: Introduction to Sockets</a> </li><li>  Chapter 3: Using Socket Topology </li><li>  Chapter 4: Additional Patterns </li></ul><br><br>  Welcome to ZeroMQ!  This chapter is an introduction to ZeroMQ and gives the reader a general idea of ‚Äã‚Äãwhat the message queue system is and, most importantly, what ZeroMQ is.  In this chapter we will talk about the following topics: <br><ul><li>  An overview of what a message queue is </li><li>  Why use ZeroMQ and what makes it different from other message queue technologies </li><li>  Basics of client / server architecture </li><li>  Consider the first pattern: request-response </li><li>  How can we handle strings in C </li><li>  Checking installed ZeroMQ versions </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br><h4>  Start </h4><br>  People throughout their lives socially interact with each other.  Programs behave in this way.  The program must communicate with another program, since we live in the world of the Internet.  We have UDP, TCP, HTTP, IPX, WebSocket and other protocols for connecting applications. <br>  Nevertheless, approaches of such a low level complicate our lives, we need something simpler and faster.  High-level abstractions sacrifice speed and flexibility, while dealing directly with low-level details is not easy.  ZeroMQ shows what the output is, giving us the convenience of using high-level methods at the speed of a low-level approach. <br>  Before we begin to deal with ZeroMQ, let's first look at the general concept of message queuing. <br><br><h4>  Message queue </h4><br>  The message queue, or technically, FIFO (First In First Out), is one of the main and well-studied data structures.  There are various queue implementations, such as a priority queue or a two-way queue, which have different properties, but the general idea is that data is added to the queue when it arrives or the caller is ready. <br>  However, the message queue provides guarantees that the message will be delivered no matter what happens.  A message queue allows asynchronous communication between loosely coupled components, and also provides a strict queue sequence.  In the event of a shortage of resources, which prevents you from immediately processing the sent data, you can put them in a message queue on the server that will store the data until the client is ready. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/005/1e8/048/0051e8048273ae3433134652447ecf55.png"><br><br>  Message queue plays an important role in scaling distributed systems, as it supports asynchronous communications.  We give a brief information about the difference between synchronous and asynchronous systems. <br>  In conventional synchronous systems, tasks are processed one at a time.  A task is considered not processed until its processing is completed.  This is the easiest way to organize work. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/710/74d/454/71074d45409d362ed0d4777e5e432e81.png"><br><br>  We can also inject threads into this system.  In this case, the processing of each task would be performed in parallel. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3c/594/0d7/b3c5940d7527413e70c847cff63904b2.png"><br><br>  In a multi-threaded model, threads are controlled by the operating system itself on a single processor or multiple processors / cores. <br>  Asynchronous I / O (AIO) allows the program to continue execution when processing I / O requests.  AIO is required in real-time applications.  With AIO, we can handle several tasks in one thread. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b07/6bc/305/b076bc3054c47421513e7140b1fcecfe.png"><br><br>  This is a traditional way of programming, after the process begins, we wait for it to complete.  The disadvantage of this approach is that it blocks the execution of the program while the task is being processed.  But there is another AIO approach.  In AIO, a task that is independent of the process is still ongoing.  In the second chapter, we will take a closer look at AIO and use it in ZeroMQ. <br>  You may wonder why you should use a message queue instead of processing all threads for a single-thread or multi-thread approach.  Let's look at a situation where you have a web application similar to Google Images, in which you allow users to enter some URLs.  Once they submit the form, your application displays all the images for this URL.  However: <br><ul><li>  If you use a single-line queue, in the case of a large number of users, the program will not be able to process data for all URLs. </li><li>  If you are using a multi-thread approach for a queue, then your application may be subject to a DDoS attack. </li><li>  You lose data for all URLs in case of a hardware failure. </li></ul><br>  In this case, you know that you need to add these URLs to the queue and process them.  So, you need a message queuing system. <br><br><h4>  Introduction to ZeroMQ </h4><br>  Up to this point we have considered what a message queue is, which led us to the goal of this book, that is, to ZeroMQ.  Society ZeroMQ is defined as "sockets on steroids."  Formally, ZeroMQ is defined as a message library that helps developers create distributed and parallel applications. <br>  The first thing we need to learn about ZeroMQ is that it is not a traditional message queuing system, such as ActiveMQ, WebSphereMQ, or RabbitMQ.  ZeroMQ is different.  She gives us the tools to create your own message queuing system.  This is a library. <br>  It works on various architectures from ARM to Itanium and is supported in more than 20 programming languages. <br><br><h5>  Simplicity </h5><br>  ZeroMQ is simple.  We can do some asynchronous I / O operations; ZeroMQ can also queue messages from an I / O stream into a message queue.  I / O streams in ZeroMQ work asynchronously when communicating with network traffic, so they can do the rest for you.  If you have previously worked with sockets, then you should know that this is not very easy.  However, ZeroMQ makes it much easier to work with them. <br><br><h5>  Performance </h5><br>  ZeroMQ is fast.  The Second Life website managed to get 13.4 microseconds of continuous latency and up to 4,100,000 messages per second.  ZeroMQ can use a multicast transport protocol, which is an effective method for transmitting data in different directions. <br><br><h4>  Hello world </h4><br>  So, it's time to start writing code, after we have analyzed what the message queue is and what ZeroMQ is.  And of course, we will start with the famous ‚ÄúHello World‚Äù program. <br>  Let's consider the situation when we have a server and a client.  The server responds with <code>world</code> whenever it receives a <code>hello</code> message from the client.  The server works on port 4040, and the client, accordingly, sends messages to the same port. <br>  Below is the server code that sends the <code>world</code> message to the client: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); void* respond = zmq_socket(context, ZMQ_REP); zmq_bind(respond, "tcp://*:4040"); printf("Starting‚Ä¶\n"); for(;;) { zmq_msg_t request; zmq_msg_init(&amp;request); zmq_msg_recv(&amp;request, respond, 0); printf("Received: hello\n"); zmq_msg_close(&amp;request); sleep(1); // sleep one second zmq_msg_t reply; zmq_msg_init_size(&amp;reply, strlen("world")); memcpy(zmq_msg_data(&amp;reply), "world", 5); zmq_msg_send(&amp;reply, respond, 0); zmq_msg_close(&amp;reply); } zmq_close(respond); zmq_ctx_destroy(context); return 0; }</span></span></span></span></code> </pre><br>  Below is the client code that sends a <code>hello</code> message to the server: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; #include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { void* context = zmq_ctx_new(); printf("Client Starting‚Ä¶.\n"); void* request = zmq_socket(context, ZMQ_REQ); zmq_connect(request, "tcp://localhost:4040"); int count = 0; for(;;) { zmq_msg_t req; zmq_msg_init_size(&amp;req, strlen("hello")); memcpy(zmq_msg_data(&amp;req), "hello", 5); printf("Sending: hello - %d\n", count); zmq_msg_send(&amp;req, request, 0); zmq_msg_close(&amp;req); zmq_msg_t reply; zmq_msg_init(&amp;reply); zmq_msg_recv(&amp;reply, request, 0); printf("Received: hello - %d\n", count); zmq_msg_close(&amp;reply); count++; } // We never get here though. zmq_close(request); zmq_ctx_destroy(context); return 0; }</span></span></span></span></code> </pre><br>  We have the first basic architecture: request-response, as shown in the following diagram: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb8/b22/7b4/fb8b227b4f1437135350310eb7618749.png"><br><br>  Let's take a closer look at the code in order to understand how it works. <br>  First we create the context and socket.  The <code>zmq_ctx_new()</code> method creates a new context.  It is thread safe, so the context can be used in multiple threads. <br>  <code>zmq_socket(2)</code> creates a new socket in a specific context.  ZeroMQ sockets are not thread-safe, so they should only be used in the thread in which they were created.  Traditional sockets are synchronous, while ZeroMQ sockets have the ability to create one queue on the client side, and another on the server side, asynchronously controlling the request-response pattern.  ZeroMQ automatically organizes connection setup, reconnection, disconnection and content delivery.  In Chapter 3, we will examine in more detail the difference between traditional sockets and ZeroMQ sockets. <br>  The server connects the <code>ZMQ_REP</code> socket and port 4040 and starts to wait for requests and responds every time it receives a message. <br>  This simple program ‚Äúhello world‚Äù shows us an example of using the first request-response pattern. <br><br><h5>  Request-response pattern </h5><br>  We use a request-response pattern (pattern) to send a message from a client to one or more servers and get a response to each sent message.  Most likely, this is the easiest way to use ZeroMQ.  Requests for answers must be strictly in order. <br><br><h5>  Answer </h5><br>  Below is the response of the request-response pattern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* context = zmq_ctx_new(); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* respond = zmq_socket(context, ZMQ_REP); zmq_bind(respond, <span class="hljs-string"><span class="hljs-string">"tcp://*:4040"</span></span>);</code> </pre><br>  The server uses the <code>ZMQ_REP</code> socket to receive messages from the Internet and send responses to clients.  For routing incoming messages from <code>ZMQ_REP</code> , the <code>fair-queue</code> strategy is valid, and for outgoing messages - <code>last-peer</code> . <br><br><h5>  Fair queue strategy </h5><br>  This book is completely devoted to queues.  You may be surprised when you find out what we mean when we talk about <code>fair-queue</code> strategy.  This algorithm for planning and allocating resources is fair by definition. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ee2/ed9/081/ee2ed9081e872262dd354367acf71b99.png"><br><br>  To understand how it works, let's say that the flows in the previous figure send 16, 2, 6 and 8 packets per second, respectively, but only 12 packets per second can be processed at the output.  In this case, we could transmit 4 packets per second, but Stream 2 only transmits 2 packets per second.  The fair-queue rules are that there can be no free exits unless all exits are free at the same time.  Thus, it is possible to allow Thread 2 to transmit its 2 packets per second and divide the remaining 10 between the remaining flows. <br>  This incoming message routing strategy uses <code>ZMQ_REP</code> .  Cyclic planning is the easiest way to implement a fair queue strategy, which is also used in ZeroMQ. <br><br><h5>  Request </h5><br>  Below is the request part of the request-response pattern: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* context = zmq_ctx_new(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Client Starting‚Ä¶.\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* request = zmq_socket(context, ZMQ_REQ); zmq_connect(request, <span class="hljs-string"><span class="hljs-string">"tcp://localhost:4040"</span></span>);</code> </pre><br>  The client uses <code>ZMQ_REQ</code> to send messages and receive responses from the server.  All messages are sent using a <code>round-robin</code> routing strategy.  Inbound routing strategy is <code>last-peer</code> . <br>  <code>ZMQ_REQ</code> does not throw out any messages.  If there are no services available to send a message or all services are busy, then everything is sent to the <code>zmq_send(3)</code> operation, which will be blocked until one of the servers becomes available to send the message.  <code>ZMQ_REQ</code> compatible with <code>ZMQ_REP</code> and <code>ZMQ_ROUTER</code> .  In chapter 4, we look at <code>ZMQ_ROUTER</code> . <br><br><h4>  Posting a message </h4><br>  This part combines the request and response sections and shows how the answer to someone‚Äôs request is and how it is answered. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Sending: hello - %d\n"</span></span>, count); zmq_msg_send(&amp;req, request, <span class="hljs-number"><span class="hljs-number">0</span></span>); zmq_msg_close(&amp;req);</code> </pre><br>  The client sends a message to the server using <code>zmq_msg_send(3)</code> .  This is the next message and sends it to the socket. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zmq_send_msg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">zmq_msg_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *socket, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span></span></code> </pre><br>  <code>zmq_msg_send</code> takes three parameters, namely the message, the socket and the flag: <br><ul><li>  The message parameter is reset to zero at the time of the request, so if you want to send a message to several sockets, you must copy it. </li><li>  A successful <code>zmq_msg_send()</code> request does not indicate if the message was sent over the network. </li><li>  The flag parameter can be either <code>ZMQ_DONTWAIT</code> or <code>ZMQ_SNDMORE. ZMQ_DONTWAIT</code>  <code>ZMQ_SNDMORE. ZMQ_DONTWAIT</code> indicates that the message should be sent asynchronously.  <code>ZMQ_SNDMORE</code> indicates that the message is composite and the rest of the message is in transit. </li></ul><br>  After sending the message, the client waits to receive a response.  This is done with <code>zmq_msg_recv(3)</code> . <br><br><pre> <code class="cpp hljs">zmq_msg_recv(&amp;reply, request, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Received: hello - %d\n"</span></span>, count); zmq_msg_close(&amp;reply);</code> </pre><br>  <code>zmq_msg_recv(3)</code> receives part of the message from the socket, as specified in the <code>socket</code> parameter, and saves the response in the <code>message</code> parameter. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zmq_msg_recv</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">zmq_msg_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *msg, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *socket, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> flags)</span></span></span></span></code> </pre><br>  <code>zmq_msg_recv</code> takes three parameters, namely the message, the socket, and the flags. <br><ul><li>  Previously received messages (if any) are considered invalid. </li><li>  The flag parameter can be <code>ZMQ_DONTWAIT</code> , which indicates that the operation should be performed asynchronously </li></ul><br><br><h4>  Working with strings in C </h4><br>  Each programming language has its own approach to handling strings.  In Erlang, there are no strings at all (there they are represented as lists of characters).  In the C programming language, lines with a zero at the end.  Strings in C are basically character arrays, where '\ 0' means the end of the string.  Errors with strings are common and the result of many vulnerabilities. <br>  According to Miller et al. (1995), 65 percent of Unix vulnerabilities are due to errors when working with strings, such as zero bytes or buffer overflows, so string handling in C must be done carefully. <br>  When using ZeroMQ, it falls on your shoulders so that the message is reliably formatted, so that other applications can read it.  ZeroMQ knows only the size of the message and only. <br>  Using different programming languages ‚Äã‚Äãin one application is usually the case.  If applications written in a programming language that does not add a zero byte at the end of the line should somehow communicate with applications written in C, then you will get strange results. <br>  You can send a message, such as world, as in our zero byte example, as follows: <br><br><pre> <code class="cpp hljs">zmq_msg_init_data_(&amp;request, <span class="hljs-string"><span class="hljs-string">"world"</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  But in Erlang you would send the same message as follows: <br><br><pre> <code class="cpp hljs">erlzmq:send(Request, &lt;&lt;<span class="hljs-string"><span class="hljs-string">"world"</span></span>&gt;&gt;)</code> </pre><br>  Suppose that our client, written in C, connects to the ZeroMQ service, written in Erlang, and we send the message <code>world</code> this service.  In this case, Erlang will display the <code>world</code> .  If we send a message with zero byte, then Erlang will print the following <code>[119,111,114,108,100,0]</code> .  Instead of the desired string, we got a list containing some numbers, these are ASCII codes.  However, it is no longer interpreted as a string. <br>  Lines in ZeroMQ are fixed in length and sent without a null byte.  Thus, the ZeroMQ string is transmitted as several bytes (the string itself in this example), as well as the length. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/335/f0e/6c8/335f0e6c8fed0a138f31f5da5a9357f3.png"><br><br><h4>  Check ZeroMQ version </h4><br>  It is very useful to know which version of ZeroMQ you are using.  In some cases, to avoid unwanted surprises, you need to know the exact version.  For example, there are some differences between ZeroMQ 2.x and ZeroMQ 3.x, such as using obsolete methods;  therefore, if you know the exact version of ZeroMQ that is installed on your computer, then you can avoid using outdated methods. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdio.h&gt; #include "zmq.h" int main (int argc, char const *argv[]) { int major, minor, patch; zmq_version(&amp;major, &amp;minor, &amp;patch); printf("Installed ZeroMQ version: %d.%d.%d\n", major, minor, patch); return 0; }</span></span></span></span></code> </pre><br><br><h4>  Summary </h4><br>  In this chapter, we looked at what a message queue is and also made a small introduction to ZeroMQ.  We considered how ZeroMQ processes strings and the first pattern (request-response).  And also wrote the first application ‚Äúhello world‚Äù. <br><br>  Resources for this article you can download <a href="https://github.com/Vasilui/habrahabr/tree/master/ZeroMQ/chapter01">link</a> <br><br>  Thank you all for your attention! </div><p>Source: <a href="https://habr.com/ru/post/198578/">https://habr.com/ru/post/198578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../198568/index.html">Type safe identifiers and phantom types</a></li>
<li><a href="../198570/index.html">bb-mobile MicrON-3 - pocket Bluetooth-headset for the "shovels"</a></li>
<li><a href="../198572/index.html">Non-player use of Unity3D and Oculus Rift</a></li>
<li><a href="../198574/index.html">Nintendo Discontinued Original Wii Game Consoles</a></li>
<li><a href="../198576/index.html">Today, Apple‚Äôs stream can be viewed online.</a></li>
<li><a href="../198580/index.html">American sues Apple for iOS 7: "This is banditry"</a></li>
<li><a href="../198584/index.html">Cygnus commercial cargo spacecraft successfully undocked from the ISS</a></li>
<li><a href="../198588/index.html">What is faster while (true) or for (;;)?</a></li>
<li><a href="../198592/index.html">Loc Kit Conference Report</a></li>
<li><a href="../198594/index.html">Running the game under Windows Phone 8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>