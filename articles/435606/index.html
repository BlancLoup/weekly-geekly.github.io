<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to write unit tests for actors? SObjectizer approach</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Actors simplify multi-threaded programming by avoiding the common shared variable state. Each actor has its own data that is not visible to anyone. In...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to write unit tests for actors? SObjectizer approach</h1><div class="post__text post__text-html js-mediator-article">  Actors simplify multi-threaded programming by avoiding the common shared variable state.  Each actor has its own data that is not visible to anyone.  Interact actors only through asynchronous messages.  Therefore, the most nightmarish horrors of multithreading in the form of races and deadlocks when using actors are not terrible (although actors have their own troubles, but this is not about that now). <br><br>  In general, writing multi-threaded applications using actors is easy and pleasant.  This is also because the actors themselves are written easily and naturally.  You could even say that writing the actor code is the easiest part of the job.  But when the actor is written, a very good question arises: ‚ÄúHow to check the correctness of his work?‚Äù <br><br>  The question is really very good.  We regularly ask it when we talk about actors in general and about <a href="https://habr.com/post/304386/">SObjectizer</a> in particular.  And until recently, we could only answer this question in general terms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But <a href="https://sourceforge.net/p/sobjectizer/news/2019/01/sobjectizer-5524-and-so5extra-122-released/">version 5.5.24 was released</a> , in which experimental support for unit-testing capabilities of actors appeared.  And in this article we will try to tell about what it is, how to use it and with the help of what it was implemented. <br><a name="habracut"></a><br><h1>  What are the tests for the actors? </h1><br>  We will look at the new features of SObjectizer in a couple of examples, along the way telling what's what.  Source codes for the examples discussed can be found <a href="https://bitbucket.org/sobjectizerteam/so5_testing_demo">in this repository</a> . <br><br>  In the course of the story, the terms "actor" and "agent" will be used interchangeably.  They denote the same thing, but in SObjectizer, the term ‚Äúagent‚Äù is historically used, so the term ‚Äúagent‚Äù will be used more often. <br><br><h2>  The simplest example with Pinger and Ponger </h2><br>  The example with the actors Pinger and Ponger is probably the most common example for actor frameworks.  You can say a classic.  Well, if so, then let's start with the classics. <br><br>  So, we have a Pinger agent who, at the beginning of his work, sends a Ping message to a Ponger agent.  Agent Ponger sends back a Pong message.  This is how it looks in C ++ code: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Types of signals to be used. struct ping final : so_5::signal_t {}; struct pong final : so_5::signal_t {}; // Pinger agent. class pinger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : pinger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;pong&gt;) { so_deregister_agent_coop_normally(); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } void so_evt_start() override { so_5::send&lt; ping &gt;( m_target ); } }; // Ponger agent. class ponger_t final : public so_5::agent_t { so_5::mbox_t m_target; public : ponger_t( context_t ctx ) : so_5::agent_t{ std::move(ctx) } { so_subscribe_self().event( [this](mhood_t&lt;ping&gt;) { so_5::send&lt; pong &gt;( m_target ); } ); } void set_target( const so_5::mbox_t &amp; to ) { m_target = to; } };</span></span></code> </pre> <br>  Our task is to write a test that checks that when registering these agents in SObjectizer, Ponger will receive a Ping message, and Pinger will receive a Pong message in response. <br><br>  OK  We write such a test using the <a href="https://github.com/onqtam/doctest">doctest</a> unit test framework and get: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DOCTEST_CONFIG_IMPLEMENT_WITH_MAIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;doctest/doctest.h&gt; #include &lt;ping_pong/agents.hpp&gt; #include &lt;so_5/experimental/testing.hpp&gt; namespace tests = so_5::experimental::testing; TEST_CASE( "ping_pong" ) { tests::testing_env_t sobj; pinger_t * pinger{}; ponger_t * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::coop_t &amp; coop) { pinger = coop.make_agent&lt; pinger_t &gt;(); ponger = coop.make_agent&lt; ponger_t &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); }); sobj.scenario().define_step("ping") .when(*ponger &amp; tests::reacts_to&lt;ping&gt;()); sobj.scenario().define_step("pong") .when(*pinger &amp; tests::reacts_to&lt;pong&gt;()); sobj.scenario().run_for(std::chrono::milliseconds(100)); REQUIRE(tests::completed() == sobj.scenario().result()); }</span></span></span></span></code> </pre> <br>  It seems to be easy.  Let's see what happens here. <br><br>  First of all, we download descriptions of agent support test tools: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/experimental/testing.hpp&gt;</span></span></span></span></code> </pre> <br>  All these tools are described in the so_5 :: experimental :: testing namespace, but in order not to repeat such a long name, we introduce a shorter and more convenient alias: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> tests = so_5::experimental::testing;</code> </pre> <br>  Next comes the description of a single test case (and more we don‚Äôt need here). <br><br>  Inside the test case, there are several key points. <br><br>  First, this is the creation and launch of a special test environment for SObjectizer: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj;</code> </pre> <br>  Without this environment, the ‚Äútest run‚Äù for agents will not work, but we'll talk about this a little bit below. <br><br>  The testing_env_t class is very similar to the wrapped_env_t class in SObjectizer.  Similarly, the SObjectizer is started in the constructor, and it stops in the destructor.  So when writing tests, you don‚Äôt have to worry about starting and stopping SObjectizer. <br><br>  Next, we need to create and register the Pinger and Ponger agents.  In this case, we need to use these agents in determining the so-called.  "Test script".  Therefore, we separately save pointers to agents: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  And then we begin to work with the "test script." <br><br>  A test script is a straightforward piece of steps that must be run from start to finish.  The phrase ‚Äúout of direct sequence‚Äù means that in SObjectizer-5.5.24, the steps of the script ‚Äúwork‚Äù in a strictly sequential manner, without any branches and cycles. <br><br>  Writing a test for agents is the definition of a test script that must be executed.  Those.  All steps of the test script should work, starting from the very first and ending with the most recent. <br><br>  Therefore, in our test case, we define a scenario in two steps.  The first step verifies that the Ponger agent will receive and process the Ping message: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"ping"</span></span>) .when(*ponger &amp; tests::reacts_to&lt;ping&gt;());</code> </pre> <br>  The second step verifies that the Pinger agent will receive a Pong message: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"pong"</span></span>) .when(*pinger &amp; tests::reacts_to&lt;pong&gt;());</code> </pre> <br>  These two steps are quite enough for our test case, so after their definition we proceed to the execution of the script.  Run the script and allow it to work no longer than 100ms: <br><br><pre> <code class="cpp hljs">sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>));</code> </pre> <br>  One hundred milliseconds should be more than enough for two agents to exchange messages (even if the test is run inside a very deceptive virtual machine, as is sometimes the case on Travis CI).  Well, if we make a mistake in writing agents or incorrectly describe a test script, then it makes no sense to wait for the completion of an erroneous script for more than 100ms. <br><br>  So, after returning from run_for (), our script can either be successfully completed or not.  Therefore, we simply check the result of the script: <br><br><pre> <code class="cpp hljs">REQUIRE(tests::completed() == sobj.scenario().result());</code> </pre> <br>  If the script was not successfully completed, it will lead to the failure of our test case. <br><br><h3>  Some explanations and additions </h3><br>  If we run this code inside a normal SObjectizer: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> * pinger{}; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> * ponger{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { pinger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">pinger_t</span></span> &gt;(); ponger = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">ponger_t</span></span> &gt;(); pinger-&gt;set_target( ponger-&gt;so_direct_mbox() ); ponger-&gt;set_target( pinger-&gt;so_direct_mbox() ); });</code> </pre> <br>  then, most likely, the agents Pinger and Ponger would have exchanged messages and would have completed their work before returning from introduce_coop (the wonders of multithreading are such).  But inside the test environment, which is created thanks to testing_env_t, this does not happen, agents Pinger and Ponger wait patiently until we run our test script.  How does this happen? <br><br>  The fact is that inside the test environment, the agents appear to be in a frozen state.  Those.  after registration, they are present in SObjectizer, but they cannot process any of their messages.  Therefore, even so_evt_start () is not called for agents before the test script is run. <br><br>  When we run the test script with the run_for () method, the test script first defrosts all frozen agents.  And then the script begins to receive notifications from SObjectizer about what happens with the agents.  For example, that Agent Ponger received a Ping message and that Agent Ponger processed this message, but did not reject it. <br><br>  When such notifications begin to arrive at the test scenario, the script tries to ‚Äútry on‚Äù them to the very first step.  So, we have a notice that Ponger received and processed Ping - are we curious or not?  It turns out that it is interesting, because in the description of the step that‚Äôs what it says: it works when Ponger reacts to Ping.  What we see in the code: <br><br><pre> <code class="cpp hljs">.when(*ponger &amp; tests::reacts_to&lt;ping&gt;())</code> </pre> <br>  OK  So the first step worked, go to the next step. <br><br>  A notification arrives next that Agent Pinger has reacted to Pong.  And this is exactly what is needed for the second step to work: <br><br><pre> <code class="cpp hljs">.when(*pinger &amp; tests::reacts_to&lt;pong&gt;())</code> </pre> <br>  OK  So the second step worked, do we have something else?  Not.  This means that the entire test script is complete and you can return control from run_for (). <br><br>  Here, in principle, how the test script works.  In fact, everything is somewhat more complicated, but we will touch upon more complex aspects when we consider a more complex example. <br><br><h2>  Example "Dining Philosophers" </h2><br>  More sophisticated examples of testing agents can be seen in solving the well-known problem ‚ÄúDining Philosophers‚Äù  On the actors, this problem can be solved in several ways.  Next, we will consider the most trivial solution: in the form of actors are presented both the philosophers themselves, and forks, for which the philosophers have to fight.  Every philosopher thinks for a while, then tries to take the plug to the left.  If it succeeds, he tries to take the plug to the right.  If this succeeds, the philosopher eats for some time, then puts down the forks and begins to think.  If it was not possible to take the plug on the right (i.e., it was taken by another philosopher), then the philosopher returns the plug on the left and thinks for some time.  Those.  this is not a good decision in the sense that some philosopher can starve for too long.  But it is very simple.  And it has room for demonstrating agent testing capabilities. <br><br>  Source codes with the implementation of the agents Fork and Philosopher can be found <a href="">here</a> , in the article we will not consider them to save volume. <br><br><h3>  Test for Fork </h3><br>  The first test for agents from The Dining Philosophers is for agent Fork. <br><br>  This agent works according to a simple scheme.  He has two states: Free and Taken.  When the agent is in the Free state, it responds to the Take message.  In this case, the agent enters the Taken state and responds with a Taken response message. <br><br>  When the agent is in the Taken state, it reacts to the Take message in a different way: the state of the agent does not change, and Busy is sent as a response message.  Also in the Taken state, the agent responds to the Put message: the agent returns to the Free state. <br><br>  In the Free state, the Put message is ignored. <br><br>  This is what we will try to test with the following test case: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"fork"</span></span> ) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } }; tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>&gt;(); }); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_taken"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;(), *philosopher &amp; tests::reacts_to&lt;msg_busy&gt;()); sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>) .impact&lt;msg_put&gt;(*fork) .when( *fork &amp; tests::reacts_to&lt;msg_put&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); sobj.scenario().run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">100</span></span>)); REQUIRE(tests::completed() == sobj.scenario().result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"free"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"put_when_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>)); }</code> </pre> <br>  There is a lot of code, so we will deal with it in parts, skipping those fragments that should already be understood. <br><br>  The first thing we need here is to replace the real agent Philosopher.  Agent Fork should receive messages from someone and reply to someone.  But we cannot use the real Philosopher in this test case, because the real agent Philosopher has his own logic of behavior, he sends messages and this independence will hinder us here. <br><br>  Therefore, we do <a href="https://en.wikipedia.org/wiki/Mock_object">mocking</a> , i.e.  we introduce instead of the real Philosopher its substitute: an empty agent who does not send anything himself, but only receives sent messages without any useful processing.  This is the pseudo-philosopher implemented in the code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pseudo_philosopher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">pseudo_philosopher_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx)} { so_subscribe_self() .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_taken&gt;) {}) .event([](<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;msg_busy&gt;) {}); } };</code> </pre> <br>  Next, we create cooperation from the Fork agent and the PseudoPhilospher agent and begin to determine the contents of our test scenario. <br><br>  The first step of the script is to verify that Fork, being in the Free state (and this is its initial state), does not respond to the Put message.  Here is how this check is recorded: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"put_when_free"</span></span>) .impact&lt;msg_put&gt;(*fork) .when(*fork &amp; tests::ignores&lt;msg_put&gt;());</code> </pre> <br>  The first thing that attracts attention is the impact construction. <br><br>  It is needed because our agent Fork does nothing, he only reacts to incoming messages.  Therefore, someone must send the message to the agent.  But who? <br><br>  But the very step of the script and sends through impact.  In fact, impact is an analog of the usual function send (and the format is the same). <br><br>  Great, the script step itself will send the message via impact.  But when will he do it? <br><br>  And he will do it when the turn comes to him.  Those.  if the first step in the script is, then the impact will be executed immediately after entering run_for.  If the step in the script is not the first, then the impact will be executed as soon as the previous step is triggered and the script proceeds to process the next step. <br><br>  The second thing we need to discuss here is the ignores call.  This helper function says that the step is triggered when the agent is rendered from processing the message.  Those.  in this case, the Fork agent must refuse to process the Put message. <br><br>  Consider another step of the test scenario in more detail: <br><br><pre> <code class="cpp hljs">sobj.scenario().define_step(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>) .impact&lt;msg_take&gt;(*fork, philosopher-&gt;so_direct_mbox()) .when_all( *fork &amp; tests::reacts_to&lt;msg_take&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>), *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;());</code> </pre><br>  First, we see here when_all instead of when.  This is because to trigger a step, we need to fulfill several conditions at once.  It is necessary for the fork to handle Take.  And you need Philosopher to process the response Taken.  Therefore, we write when_all, not when.  By the way, there is also when_any, but we will not see him in the examples considered today. <br><br>  Secondly, we also need to check the fact that after processing the Take agent, the agent Fork will be in the state of Taken.  We do the check as follows: we first indicate that as soon as the Fork agent finishes processing the Take, its current state name should be saved using the ‚Äúfork‚Äù tag.  This is the construction that instructs to save the name of the agent state: <br><br><pre> <code class="cpp hljs">&amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"fork"</span></span>)</code> </pre> <br>  And then, when the script is completed successfully, we check this saved name: <br><pre> <code class="cpp hljs">REQUIRE(<span class="hljs-string"><span class="hljs-string">"taken"</span></span> == sobj.scenario().stored_state_name(<span class="hljs-string"><span class="hljs-string">"take_when_free"</span></span>, <span class="hljs-string"><span class="hljs-string">"fork"</span></span>));</code> </pre> <br>  Those.  we ask the script: give us the name that was saved with the ‚Äúfork‚Äù tag for the step named ‚Äútake_when_free‚Äù, then compare the name with the expected value. <br><br>  Here, perhaps, all that could be noted in the test case for the agent Fork.  If readers have any questions, ask in the comments, we will be happy to answer. <br><br><h3>  Philosopher Successful Script Test </h3><br>  For the Philosopher agent, we will consider only one test case - for the case when Philosopher can take both forks and eat. <br><br>  This test case will look like this: <br><br><pre> <code class="cpp hljs">TEST_CASE( <span class="hljs-string"><span class="hljs-string">"philosopher (takes both forks)"</span></span> ) { tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } }; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * philosopher{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * left_fork{}; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * right_fork{}; sobj.environment().introduce_coop([&amp;](so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop) { left_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); right_fork = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>&gt;(); philosopher = coop.make_agent&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>&gt;( <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>, left_fork-&gt;so_direct_mbox(), right_fork-&gt;so_direct_mbox()); }); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scenario = sobj.scenario(); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_left"</span></span>) .when( *left_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"take_right"</span></span>) .when( *right_fork &amp; tests::reacts_to&lt;msg_take&gt;() ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;msg_taken&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_eating&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) ); scenario.define_step(<span class="hljs-string"><span class="hljs-string">"return_forks"</span></span>) .when_all( *left_fork &amp; tests::reacts_to&lt;msg_put&gt;(), *right_fork &amp; tests::reacts_to&lt;msg_put&gt;() ); scenario.run_for(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds(<span class="hljs-number"><span class="hljs-number">1</span></span>)); REQUIRE(tests::completed() == scenario.result()); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"left_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"eating"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"right_taken"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); REQUIRE(<span class="hljs-string"><span class="hljs-string">"thinking"</span></span> == scenario.stored_state_name(<span class="hljs-string"><span class="hljs-string">"stop_eating"</span></span>, <span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>)); }</code> </pre> <br>  Quite voluminous, but trivial.  First we check that Philosopher has finished thinking and started preparing for food.  Then we check that he tried to take the left fork.  Next, he should try to take the right fork.  Then he must eat and stop this activity.  After which he must put both plugs taken. <br><br>  In general, everything is simple.  But it should focus on two things. <br><br>  First, the testing_env_t class, like its prototype, wrapped_env_t, allows you to configure the SObjectizer Environment.  We will use this to enable the message delivery tracing mechanism: <br><br><pre> <code class="cpp hljs">tests::<span class="hljs-keyword"><span class="hljs-keyword">testing_env_t</span></span> sobj{ [](so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params) { params.message_delivery_tracer( so_5::msg_tracing::std_cout_tracer()); } };</code> </pre> <br>  This mechanism allows you to "visualize" the message delivery process, which helps in the process of handling the behavior of agents (we have already <a href="https://habr.com/post/352176/">talked</a> about this in <a href="https://habr.com/post/352176/">more detail</a> ). <br><br>  Secondly, the agent Philosopher does not perform a series of actions immediately, but after some time.  So, starting to work, the agent should send itself a pending StopThinking message.  This message should come to the agent after a few milliseconds.  What we specify when setting for a particular step the desired restriction: <br><br><pre> <code class="cpp hljs">scenario.define_step(<span class="hljs-string"><span class="hljs-string">"stop_thinking"</span></span>) .when( *philosopher &amp; tests::reacts_to&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>::msg_stop_thinking&gt;() &amp; tests::store_state_name(<span class="hljs-string"><span class="hljs-string">"philosopher"</span></span>) ) .constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)) );</code> </pre> <br>  Those.  here we say that we are not interested in any reaction of the Philosopher agent to StopThinking, but only that which occurred no earlier than 250ms after the start of the processing of this step. <br><br>  The restriction of the form not_before instructs the script that all events that occur before the expiration of the specified timeout should be ignored. <br><br>  There is also a limitation of the form not_after, it works the other way around: only those events that occur before the specified timeout has expired. <br><br>  Restrictions not_before and not_after can be combined, for example: <br><br><pre> <code class="cpp hljs">.constraints( tests::not_before(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">250</span></span>)), tests::not_after(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds(<span class="hljs-number"><span class="hljs-number">1250</span></span>)))</code> </pre> <br>  but in this case the SObjectizer does not check the consistency of the given values. <br><br><h1>  How did you manage to implement it? </h1><br>  I would like to say a few words about how it all turned out to make work.  After all, by and large, we had one big ideological question "How to test agents in principle?" And one smaller question, already technical: "How to implement it?" <br><br>  And if, regarding the ideology of testing, it was possible to get out somehow, then here about the implementation the situation was more complicated.  It was necessary to find such a solution, which, firstly, would not require a cardinal alteration of the insides of SObjectizer.  And, secondly, it should have been a solution that could be implemented in the foreseeable and, highly desirable, short time. <br><br>  As a result of the difficult process of bamboo smoking, a solution was found.  To do this, it took, in fact, to make only one small innovation in the regular behavior of SObjectizer.  And the basis of the solution is <a href="https://habr.com/post/426983/">the envelope mechanism for messages, which was added in version 5.5.23 and which we already talked about</a> . <br><br>  Inside the test environment, each message sent is wrapped in a special envelope.  When the envelope with the message is given to the agent for processing (or, on the contrary, is rejected by the agent), the test script becomes aware of this.  It is thanks to the envelopes that the test script knows what is happening and can determine the moments when the steps of the script ‚Äúwork‚Äù. <br><br>  But how to make SObjectizer wrap each message in a special envelope? <br><br>  That was an interesting question.  He decided as follows: it was invented such a thing as <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5.24%2520event_queue_hook/">event_queue_hook</a> .  This is a special object with two methods - on_bind and on_unbind. <br><br>  When an agent binds to a specific dispatcher, the dispatcher issues a personal event_queue to the agent.  Through this event_queue, requests for the agent are placed in the required queue and become available to the dispatcher for processing.  When an agent is working inside a SObjectizer, it has a pointer to an event_queue.  When an agent is removed from SObjectizer, its pointer to event_queue is reset. <br><br>  So, starting from version 5.5.24, when receiving event_queue, the agent must call the on_bind method of event_queue_hook.  Where the agent should send the received pointer to event_queue.  And the event_queue_hook in response can return either the same pointer, or another pointer.  And the agent must use the returned value. <br><br>  When an agent is removed from SObjectizer, it must call on_unbind on event_queue_hook.  In on_unbind, the agent passes the value that was returned by the on_bind method. <br><br>  This whole kitchen runs inside the SObjectizer, and the user doesn‚Äôt see anything of this.  And, in principle, you may not know about it at all.  But the test environment of SObjectizer, the same testing_env_t, is used by the event_queue_hook.  Inside testing_env_t, a special implementation of event_queue_hook is created.    on_bind   event_queue   -.    -       . <br><br>     .  ,          .      -.     , -      .    , -          . <br><br><h1>  Conclusion </h1><br>       . <br><br> -,    SObjectizer-    ,    .   ,           .     <a href="https://doc.akka.io/docs/akka/current/testing.html">Akka.Testing</a> .  Akka  SObjectizer <a href="https://eao197.blogspot.com/2018/09/progflame-akka-sobjectizer.html">  </a>    SObjectizer ,    Akka.   C++  Scala/Java,   - ,   ,     .     ,     SObjectizer. <br><br>   5.5.24    ,  .    .   ,   ,    ?  , .    , ,    . <br><br>      ,     .       : ,       .   ,   ?  -  ? <br><br> -,         <a href="https://habr.com/post/324978/">  2017- </a> : <br><blockquote> ‚Ä¶       ,   ,   ,    .      -      ‚Äî      .             .      . :  ,   . <br><br>    ,  ,   ,       ‚Äî    ,           . <br><br>    ,     :          .      ,    ,      : , ,     ,     ,      ,    ‚Ä¶   -  ,     .   ,       . <br></blockquote>           . ,          ,    ,   .   , ,        :) </div><p>Source: <a href="https://habr.com/ru/post/435606/">https://habr.com/ru/post/435606/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435594/index.html">Route graph for apache camel</a></li>
<li><a href="../435596/index.html">Conversations and traffic Russians offer to store only on Russian equipment</a></li>
<li><a href="../435600/index.html">How to migrate to another mobile operator and not go bankrupt (for iOS owners)</a></li>
<li><a href="../435602/index.html">Azure Exam Preparation</a></li>
<li><a href="../435604/index.html">BlaBlaCar became what was not intended</a></li>
<li><a href="../435608/index.html">HF screens do it yourself</a></li>
<li><a href="../435610/index.html">Easter eggs for ZX Spectrum - in the music album and movie</a></li>
<li><a href="../435612/index.html">Trust Codda or your objects?</a></li>
<li><a href="../435614/index.html">Rust news # 4 (December 2018)</a></li>
<li><a href="../435616/index.html">How Peer Zoning simplified our lives and helped balance the load of EMC VPLEX</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>