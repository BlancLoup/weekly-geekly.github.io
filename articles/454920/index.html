<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Frontend performance: parse important metrics</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Usually, productivity is understood as the number of operations for a certain time interval and the more, the better. But such a definition, and the a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Frontend performance: parse important metrics</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ou/4k/ny/ou4knymbtseyhgwt9_zcalajm4s.png"></div>  Usually, productivity is understood as the number of operations for a certain time interval and the more, the better.  But such a definition, and the approach as a whole, is of little use to the frontend, because each user will have his own frontend.  That's what I want to talk about, what happens ‚Äúthere‚Äù, from the user, on the other side, in reality, and not on your top MacBook. <br><br>  In addition to this, I will try to briefly consider the general rules of code optimization and some errors that should be noted.  I'll also tell you about a <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">tool</a> that helps not only in profiling, but also out of the box collects a bunch of basic metrics about the performance of your application (and I hope you finish this post to the end). <br><a name="habracut"></a><br>  First of all, we define what the frontend performance is, and then proceed to how to measure it.  So, as I said, we will not measure certain ops / sec, we need real data that could answer the question of what exactly is happening with our project at each stage of its work.  For this we need the following set of metrics: <br><br><ul><li>  download speed; </li><li>  the time of the first drawing and interactivity (Time To Interactive); </li><li>  speed of reaction to user actions; </li><li>  FPS scrolling and animations; </li><li>  application initialization; </li><li>  if you have a SPA, then you need to measure the time spent on the transition between routes; </li><li>  memory and traffic consumption; </li><li>  and ... that's enough for now. </li></ul><br>  All these are basic metrics, without which it is impossible to understand exactly what is happening at the frontend.  And not just at the front end, but in reality, at the end user.  But to start collecting these metrics, you first need to learn how to measure them, so let's remember what ways there are for performance analytics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The first thing to start with is, of course, the Performance API.  Namely <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming">performance.timing</a> , through which you can find out how long it took the user to open your project.  But the Performance API covers only part of the metric, the rest will need to be measured by ourselves, and for this we have the following tools: <br><div class="scrollable-table"><table><tbody><tr><th></th><th>  pros </th><th>  Minuses </th></tr><tr><td>  console.time ('label') </td><td>  Works out of the box. <br><br>  Output to console. <br><br>  Displayed in DevTools -&gt; Performance -&gt; User Timing. </td><td> The output is only in DevTools, not sent to the server (i.e. there is no possibility to get the value for the subsequent analytics). <br><br>  Requires <code>console.timeEnd</code> with the original <code>label</code> . <br><br>  No color coding. <br><br>  No grouping (something like <code>console.group</code> / <code>groupEnd</code> ). </td></tr><tr><td>  performance.now () </td><td>  Full control over the beginning and end. <br><br>  You can send to the server. <br><br></td><td>  No display in console. <br><br>  No display in DevTools -&gt; Performance -&gt; User Timing. <br><br>  It is necessary to drag the variable "start". <br><br>  No grouping. </td></tr><tr><td>  performance.mark / measure </td><td>  Full control over the beginning and end. <br><br>  You can send to the server. <br><br>  Displayed in DevTools -&gt; Performance -&gt; User Timing. </td><td>  No display in console. <br><br>  In order to measure something, you need to set three unique labels and call two methods, and in a good way, you also need <code>performance.clearMarks</code> and <code>performance.clearMeasures</code> , which makes use extremely inconvenient. <br><br>  No grouping. </td></tr></tbody></table></div>  It was at that moment that I realized that I needed to cut a tool that would combine the advantages of the above and, if possible, not have minuses.  So <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">PerfKeeper</a> appeared. <br><br><br><h2>  Perfkeeper </h2><ul><li>  Full control over the beginning and end. </li><li>  You can send to the server. </li><li>  Output to console. </li><li>  Supports DevTools -&gt; Performance -&gt; User Timing. </li><li>  There is a grouping. </li><li>  There is color coding (as well as units of measurement, i.e. it is possible to measure not only time). </li><li>  Supports extensions. </li></ul><br>  Now I will not paint the API here, I did not write <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">documentation</a> for this, and the article is not about that, but I will continue to learn how to collect metrics. <br><br><br><h2>  Page loading speed </h2>  As I already said, you can learn the download speed from <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceNavigationTiming">performance.timing</a> , which will allow you to find out the full cycle from the start of page loading (DNS rezolv time, HTTP Handshake installation, request processing) to full page load (DomReady and OnLoad): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eaf/320/48c/eaf32048c515e0a77ebeaa63e862def4.png"><br><br>  The result should be the following set of metrics: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/051/23d/b6a/05123db6af6359cc9f364b939f22fbcf.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/0d7/297/cdb/0d7297cdbd0c28f16849706a72bc54b5.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/6c0/ddc/21b/6c0ddc21b01640151d9e48b0018f2190.png"></td></tr></tbody></table></div>  <i>An example of how the <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper/ext/navigation">navigation</a> extension works for <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">@ perf-tools / keeper</a> .</i> <br><br>  But this is not enough, we received only basic values ‚Äã‚Äãand still do not know what exactly took so much time.  And to find out, you need to nashpigovat and HTML metrics. <br><br>  As I said before, I‚Äôll show examples using <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">PerfKeeper</a> , so first of all PerfKeeper (2.5 Kb) inline in <code>&lt;hed/&gt;</code> and further: <img src="https://habrastorage.org/getpro/habr/post_images/dc8/a62/0b1/dc8a620b1d143b6fd2d328fed332e6ee.png"><br><br>  As a result, you will see such beauty in the console: <br><img src="https://habrastorage.org/getpro/habr/post_images/463/655/c0c/463655c0c0b6d5c23f0edb0828a4040b.png" width="350"><br><br>  This is a classic old-fashioned way of measuring, 100% working.  But the world does not stand still, and for more accurate measurements, we now have a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API">Resource Timing API</a> (and if resources are on a separate domain, <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin">Timing-Allow-Origin,</a> to help you). <br><br>  And here it is worth talking about classic mistakes when initially loading the page, namely: <br><br><ul><li>  the absence of GZip and HTTP / 2 (yes, this still occurs); </li><li>  unreasonable use of fonts (sometimes a font is connected only for the sake of one title or even a phone number in the footer 0_o); </li><li>  too common / big CSS / JS bundles. </li></ul><br>  Ways to optimize page load: <br><br><ul><li>  use Brotli (or even SDCH) instead of GZip, enable HTTP / 2; </li><li>  collect only the necessary CSS (critical) and do not forget about <a href="https://github.com/css/csso">CSSO</a> ; </li><li>  Minimize the size of the JS bundle by separating the minimum CORE bundle and load the rest on demand, i.e.  asynchronously; </li><li>  load JS and CSS in a non-blocking mode, dynamically creating <code>/&gt;  &lt;sript src="..."/&gt;</code> , ideally load JS after the main content; </li><li>  use SVG instead of PNG, and if you combine it with JS, then this will get rid of redundant XML (for example, like <a href="https://www.npmjs.com/package/font-awesome">font-awesome</a> ); </li><li>  <a href="https://css-tricks.com/a-deep-dive-into-native-lazy-loading-for-images-and-frames/">use lazy loading</a> both for images and iframe (besides, <a href="https://chromestatus.com/feature/5645767347798016">native support will</a> appear in the near future). </li></ul><br><br><h2>  Time of the first drawing and interactivity (TTI) </h2>  The next stage after the download is the moment when the user saw the result, and the interface went online.  For this we need <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformancePaintTiming">Performance Paint Timing</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver">PerformanceObserver</a> . <br><br>  With the first one, everything is simple, call <code>performance.getEntriesByType('paint')</code> and get two metrics: <br><br><ul><li>  first-paint - the first draw; </li><li>  first-contentful-paint - and full first render. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/ef7/230/acb/ef7230acbfdcace32596ce157bb00706.png" width="350"><br>  <i>An example of how the <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper/ext/paint">paint</a> extension for <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">@ perf-tools / keeper</a> works.</i> <br><br>  But with the following metric, Time To Interactive, everything is a little more interesting.  There is no exact way to determine when your application has become interactive, i.e.  accessible to the user, but this can be indirectly understood by the absence of <a href="https://www.w3.org/TR/longtasks/">longtasks</a> : <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// TTI let ttiLastEntry: PerformanceEntry | undefined; let ttiPerfObserver: PerformanceObserver; try { ttiPerfObserver = new PerformanceObserver((list) =&gt; { ttiLastEntry = list.getEntries().pop(); }); ttiPerfObserver.observe({ entryTypes: ['longtask'], }); } catch (_) {} domReady(() =&gt; { // TTI Check if (ttiPerfObserver) { let tti: number; const check = () =&gt; { if (ttiLastEntry) { tti = ttiLastEntry.startTime + ttiLastEntry.duration; if (now() - tti &gt;= options.ttiDelay) { //  logntask  ,  , //     ;] send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { setTimeout(check, options.ttiDelay); } } else if (tti) { send('tti', 'value', 0, tti); ttiPerfObserver.disconnect(); } else { //   logntask,         , //  ,       DOMReady! tti = now(); setTimeout(check, 500); } } //   check(); } });</span></span></code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/a03/dcb/6e1/a03dcb6e138ee982ab4cd90a2c1b7f09.png" width="350"><br>  <i>An example of the performance extension for <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">@ perf-tools / keeper</a> .</i> <br><br>  In addition to these basic metrics, your application readiness metric is still needed, i.e.  somewhere in your code should be like: <pre> <code class="javascript hljs">Import { system } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@perf-tools/keeper'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">applicationBoot</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">el, data</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Application(el, data); <span class="hljs-comment"><span class="hljs-comment">//     app.ready(() =&gt; { system.add('application-ready', 0, system.perf.now()); // Ô∏èapplication-ready: 3074.000ms }); return app; }</span></span></code> </pre> <br><br><h2>  The speed of reaction to user actions </h2>  There is a huge field for metrics and they are very individual, so I‚Äôll tell you about two basic ones that are suitable for any project, namely: <br><br>  <b>first-event</b> - the time of the first event, for example, the first click (with the division where the user poked), this metric is especially relevant for all sorts of search results, a list of goods, news feeds, etc.  With it, you can control how the reaction time and user flow from your actions change (changes in: design / new features / optimization, etc.) <img src="https://habrastorage.org/getpro/habr/post_images/31a/f2c/e7e/31af2ce7e1ed48f7bfc4cacc6a6ddb0e.png" width="350"><br>  <i>An example of the performance extension for <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">@ perf-tools / keeper</a> .</i> <br><br>  <b>latency</b> - the delay in processing some events, for example: <code>click</code> , <code>input</code> , <code>submit</code> , <code>scroll</code> , etc. <br><br>  To measure the delay, it is enough to hang up the event handler on the <code>window</code> with <code>capture = true</code> and through the <code>requestAnimationFrame</code> calculate the difference, this will be the delay: <pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(eventType, ({target}) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = now(); requestAnimationFrame(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latency = now() - start; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (latency &gt;= minLatency) { <span class="hljs-comment"><span class="hljs-comment">// ‚Ä¶. } }); }, true);</span></span></code> </pre><br><br><img src="https://habrastorage.org/getpro/habr/post_images/e68/e3e/07d/e68e3e07d64825c3f07175625d477283.png" width="350"><br>  <i>An example of the performance extension for <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">@ perf-tools / keeper</a> when the Fibonnachi Number is calculated per click.</i> <br><br><br><h2>  FPS scrolling and animations </h2>  This is the most interesting metric, it is usually measured through <code>requestAnimationFrame</code> , and if you need to do a constant FPS measurement, then the classic <a href="http://darsa.in/fpsmeter/">FPSMeter</a> will do (although it is overly optimistic).  But it is not good at all if you need to measure the smoothness of the page scrolling, because  he needs a "warm up".  And then I came across a very <a href="http://www.kaizou.org/2011/06/effectively-measuring-browser-framerate-using-css/">interesting way</a> . <br><br>  Ingeniously, in fact, we simply create a transparent div (1x1px), add a <code>transition: left 300ms linear</code> and start it from one corner to another, and while it is animating, we check its real left through <code>requestAnimationFrame</code> , and if the new length is different from the previous one, then we increase the number of rendered frames (otherwise we have FPS drawdown). <br><br>  And that's not all, if you use FF, then there simply is a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/mozPaintCount">mozPaintCount</a> , which is responsible for the number of rendered frames, i.e.  remember ‚ÄúBEFORE‚Äù, and on <code>transitionend</code> we calculate the difference. <br><br>  So, without any warm-up, we know for sure whether the browser redrawn the frame or not. <br><br>  Even in the near future they promise a normal API: <a href="http://wicg.github.io/frame-timing/">http://wicg.github.io/frame-timing/</a> <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/5c9/17b/d15/5c917bd15c349dd2101e10ce687294c5.png" width="350"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/964/4cc/6bb/9644cc6bb9c21671b5c7c7e34b596ff8.png" width="350"></td></tr></tbody></table></div>  <i>An example of the work of the <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper/ext/fps">fps</a> extension for <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">@ perf-tools / keeper</a> .</i> <br><br>  Scrolling optimization: <br><br><ul><li>  the simplest thing is to do nothing on the scroll, or to postpone execution via <code>requestAnimationFrame</code> , or even <code>requestIdleCallback</code> ; </li><li>  very carefully use <code>pointer-events: none</code> , turning it on and off may have the opposite effect, so it is better to conduct an A / B experiment using <code>pointer-events</code> and without; </li><li>  Do not forget about virtualized lists, almost all View engines now have such components, but again, be careful, the elements of such a list should be as simple as possible, or use ‚Äúdummies‚Äù that will be replaced with real elements after the scrolling is completed.  If you write a virtualized list yourself, then no inner HTML and do not forget about DOM Recycling (this is when you do not create DOM elements for each sneeze, but reuse them). </li></ul><br><br><h2>  Application Initialization </h2>  There is only one rule: detail so that you can exactly answer what exactly eaten up the time from the initialization of the application to the final launch.  As a result, you should get at least the following metrics: <br><br><ul><li>  how much time was spent on resolving each addiction; </li><li>  time to receive and prepare data for the application; </li><li>  Render of the application with detail in blocks. </li></ul><br>  Those.  at the output, you should have such metrics that you can track exactly on which phase you have a drawdown. <br><br><div class="spoiler">  <b class="spoiler_title">Work example</b> <div class="spoiler_text">  <b>Console</b> <img src="https://habrastorage.org/getpro/habr/post_images/678/c35/91f/678c3591fc9c9d1b46481a67be2d4551.png"><br><br>  <b>User Timing</b> <img src="https://habrastorage.org/getpro/habr/post_images/b1e/67e/8c4/b1e67e8c408d8ad929ee6e404889a593.png"></div></div><br><br><br><h2>  If you have a SPA, then you need to measure the routing time </h2>  First, there should be a common metric to evaluate performance (time to go along the route) as a whole, but you also need to have a metric for each route (for example, we have ‚ÄúList of threads‚Äù, ‚ÄúRead thread‚Äù, ‚ÄúSearch‚Äù, etc.). d), the metric itself should be broken down into submetrics: <br><br><ul><li>  Data acquisition (with partitioning, which ones) <ul><li>  Treatment </li><li>  Update </li></ul></li><li>  Render <ul><li>  Total application </li><li>  Blocks (for example, with us, it will be: ‚ÄúLeft column‚Äù (it‚Äôs ‚ÄúList of folders‚Äù), ‚ÄúSmart search string‚Äù, ‚ÄúList of letters‚Äù and in the same spirit) </li></ul></li></ul><br>  Without all this, it is impossible to understand where the problems begin, so many of our modules out of the box have timings (for example, the same module for XHR has <code>startTime</code> and <code>endTime</code> , which are automatically logged). <br><br>  But these metrics are not enough to adequately assess what is happening.  They are too general, because  we are talking about SPA, then you definitely have some kind of Runtime Cache (so as not to go to the server once again if you have already been there), so our metrics are further divided into routing with and without cache.  Also, specifically in our case, we divide the metric by the number of entities in it.  In other words, it is impossible to add a ‚ÄúThread‚Äù view into one metric with 1, 5, 10 or 100+ letters, so if you have any list output, you must select control points and additionally divide the metric. <br><br><br><h2>  Memory and traffic consumption </h2>  <b>Let's start with the memory</b> .  And here we are in for a big disappointment.  At the moment there is only non-standardized (Chrome only) performance.memory, which gives out ridiculously low numbers.  But still they need to be measured and see how the application ‚Äúflows‚Äù over time: <div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/985/6f9/3f0/9856f93f0823ac906bd1938f2cf1f11c.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/983/1bf/437/9831bf437924eb2ecf577f897d934e45.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/c08/e33/577/c08e335770d4fa05b70d8d653ae1b38f.png"></td></tr></tbody></table></div>  <i>An example of how the <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper/ext/memory">memory</a> extension works for <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">@ perf-tools / keeper</a></i> <br><br>  <b>Traffic</b> .  To count traffic, you will need <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin">Timing-Allow-Origin</a> (if the resources are in a separate domain) and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API">Resource Timing API</a> , this will help not only to calculate the traffic, but also to detail it: <br><br><ul><li>  what protocol is used (HTTP / 1, HTTP / 2, etc.); </li><li>  types of downloadable resources; </li><li>  how long it took to download them; </li><li>  size, moreover, you can still understand whether the resource is loaded on the network or taken from the cache. </li></ul><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/getpro/habr/post_images/c65/c03/c66/c65c03c660ea8d6bb70ee6597d643245.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/aa3/ba4/973/aa3ba4973933bebafe516ed63e779700.png"></td><td><img src="https://habrastorage.org/getpro/habr/post_images/35a/a87/d0d/35aa87d0d53ca31ea88ad249bacd057a.png"></td></tr></tbody></table></div>  <i>Example of the <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper/ext/resource">resource</a> extension for <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">@ perf-tools / keeper</a> .</i> <br><br>  What does traffic count do? <br><br><ul><li>  The most important thing is that it allows you to see the real picture, and not as usual CSS + JS and besides this, how this ‚Äúpicture‚Äù changes over time. </li><li>  Then you can analyze what is being loaded, divide resources into groups, etc. </li><li>  How well caching works for you. </li><li>  Are there any anomalies, for example, after 15 minutes of work, for example, the code entered into recursion and endlessly loads some resource, traffic monitoring will help with this. </li></ul><br>  Well, in a follow-up report from my colleague <a href="https://t.me/Edwardgrolsh">Igor Druzhinin</a> on this topic: <a href="https://www.youtube.com/watch%3Fv%3DaQ5NbkoY9N8">Assessing the quality of the application's performance - monitoring traffic consumption</a> <br><br><br><h2>  Analytics </h2>  We have set the metrics, and then what?  And then they need to be sent somewhere.  And then either you bring up some <a href="https://graphiteapp.org/">Graphite</a> , or, for starters, you can use <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper/analytics/google">Google Analytics</a> or similar for the purposes of aggregation of data. <br><br>  And do not forget, it is not enough just to get a schedule, for all important metrics there should be percentiles that allow you to understand, for example, what percentage of the audience the project loads for &lt;1s, &lt;2s, &lt;3s, &lt;5s, 5s +, etc. <br><br><br><h2>  We write high-performance code </h2>  At first I wanted to write something meaningful here, they say, use WebWorker, do not forget to <code>requestIdleCallback</code> or something exotic, for example, <code>requestIdleCallback</code> -through Runtime Cache through browser tabs using SharedWorker or ServiceWorker (which is not just about caching, if that).  But this is all very abstract, and many topics are beaten to impossibility, so I‚Äôll just write the following: <br><br><ol><li>  Initially cover your code with metrics that will measure its performance. </li><li>  Do not believe benchmarks with jsperf.  The vast majority of them are written poorly, and simply taken out of context.  The best benchmark is a real metric on the project, according to which you will see the effect of your actions. </li><li>  Remember about the perception of performance, or rather the Weber-Fechner law.  Namely, if you have started optimization, then do not roll out the changes until it becomes better by at least 20%, otherwise users simply will not notice.  The same law works in the opposite direction. </li><li>  Fear regulars, especially generated ones.  They can not only suspend the browser, but also get the XSS, which is why we do not allow HTML parsing in our Mail using them, only through DOM's bypass. </li><li>  You do not need to use arrays to enter a value into one or another group; for this you have an <code>object</code> or a <code>Set</code> (for example, instead of <code>successSteps.includes(currentStep)</code> you need <code>successSteps.hasOwnProperty(currentStep)</code> ), O (1) is our everything. </li><li>  The expression ‚ÄúPremature optimization is the root of all evil‚Äù is not about what you write as you wish.  If you know how to best, write best. </li></ol><br><br><div class="spoiler">  <b class="spoiler_title">Still, I'll write a couple of paragraphs about the code and its optimization.</b> <div class="spoiler_text">  <b>DOM</b> .  Very often I hear ‚ÄúThe Problem in the DOM‚Äù - this, of course, is true, but given the fact that almost everyone now has an abstraction over it.  The bottleneck is precisely it, or rather your code, which is responsible for the formation of the view and the business logic. <br><br>  But if we talk about DOM, for example, instead of deleting a fragment from the DOM, it is better to hide it or deattach it.  If you still need to delete, then put this operation in <code>requestIdleCallback</code> (if possible), or divide the destruction process into two phases: synchronous and asynchronous. <br><br>  Immediately make a reservation, use this approach wisely, or you can shoot a knee. <br><br>  We also use another interesting technique on the lists, for example, the ‚ÄúList of Threads‚Äù.  The essence of the technique is that instead of one global ‚ÄúList‚Äù and updating its data, we generate a ‚ÄúList of Trades‚Äù for each ‚ÄúFolder‚Äù.  As a result, when the user goes between the "Folders", one list is removed from the DOM (not deleted), and the other is updated either partially or not at all.  And not all, as in the case of the "Unified List". <br><br>  All this gives an instant response to user actions. <br><br>  <b>Mathematics</b> .  All mathematics can be easily removed either in the Worker or in the WebAssembly, this has been working for a long time. <br><br>  <b>Transpillers</b>  Oh, many people do not even think about the fact that the code they write passes through the transpiler.  Yes, they know about him, but that's all.  But that he will turn them no longer care.  Indeed, in DevTools they see the result of the source map. <br><br>  Therefore, study the tools that you use, for example, the same babel in the <a href="https://babeljs.io/repl">playground</a> has the opportunity to see how it generates code depending on the selected presets, just look at the same <code>yeild</code> , <code>await</code> or <code>for of</code> . <br><br>  <b>Subtleties of language</b> .  Even fewer people know about the monomorphism of the code, or trite why bind is slow and ... you finally use <code>handleEvent</code> ! <br><br>  <b>Data and prekeshiry</b> .  Less requests, more caching.  In addition, very often we use the technique of "foresight", this is when we load data in the background.  For example, after the ‚ÄúList of threads‚Äù render, we start loading N-unread threads in the current ‚ÄúFolder‚Äù, so that when you click on them, the user immediately switches to ‚ÄúReading,‚Äù and not just another ‚Äúloader‚Äù.  We use this technique not only for Data, but also for JS.  For example, ‚ÄúWriting a Letter‚Äù is a huge bundle (because of the editor), but not all letters are written and not immediately, so we ship it in the background, after the application is initialized. <br><br>  <b>Lovers</b>  I don‚Äôt know why, but I didn‚Äôt see articles that would teach you how not to do a loader, but on the contrary, to take at least a presentation of the ‚Äúfuture‚Äù React, in which a lot of time was devoted to this problem within Suspense.  But after all, the ideal application is without loaders, we in the Post have been trying to show it for a very long time only in emergency situations. <br><br>  In general, we have such a policy, no data, no view, nothing to draw a semi-interface, first load the data and only then ‚Äúdraw‚Äù.  That is why we use the "foresight" of where the user is going to go and load this data so that the user does not see the loader.  In addition, our data layer, which has persistence, i.e.  if you somewhere in the same place requested the ‚ÄúThread‚Äù, then the next time you request from another or the same place, there will be no request, we will take the data from the Runtime Cache (more precisely, the link to the data).  And so in everything, collections of threads are also just references to data. <br><br>  But if you still decide to make a loader, then do not forget the basic rules that will make your loader less annoying: <ul><li>  no need to show the loader immediately, at the time of sending the request, there should be a delay of at least 300-500 ms before the display; </li><li>  After receiving the data, you do not need to drastically remove the loader, again there should be a delay. </li></ul><br>  These simple rules are needed so that the loader appears only on heavy requests and does not ‚Äúblink‚Äù on completion.  But most importantly, the best louder is a louder that has not appeared. </div></div><br><br>  Thank you for your attention, everything, measure, analyze and use <a href="https://github.com/artifact-project/perf-tools/tree/master/keeper">PerfKeeper</a> ( <a href="https://artifact-project.github.io/perf-tools/keeper/">Live example</a> ), as well as <a href="https://github.com/RubaXa">my github</a> and <a href="https://twitter.com/ibnrubaxa">twitter</a> , in case of questions! </div><p>Source: <a href="https://habr.com/ru/post/454920/">https://habr.com/ru/post/454920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../454906/index.html">Rating sites additional education in IT: the results of the study "My Circle"</a></li>
<li><a href="../454912/index.html">By Dwarf Fortress Tarn Adams talks about game development.</a></li>
<li><a href="../454914/index.html">Use Yii2. We write another CMS or an attempt to significantly speed up development with minimal overhead</a></li>
<li><a href="../454916/index.html">Neural network architecture for the implementation of the RL algorithm with the ability to specify simultaneously running actions</a></li>
<li><a href="../454918/index.html">How to combine backups of two retailers on SAP in 12 hours</a></li>
<li><a href="../454922/index.html">Tales about foreign customers and their peculiarities of work in Russia after the law on PD</a></li>
<li><a href="../454926/index.html">Everything you know about word2vec is not true</a></li>
<li><a href="../454928/index.html">A way to bypass the Windows lock screen on RDP sessions</a></li>
<li><a href="../454930/index.html">Garbage Collection in V8: How the New Orinoco GC Works</a></li>
<li><a href="../454936/index.html">Vivaldi: ad blocking should be user selectable</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>