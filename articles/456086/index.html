<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>iOS Storyboards: analysis of the pros and cons, best practices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Apple has created Storyboards so that developers can visualize the screens of iOS applications and the connections between them. Not everyone liked th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>iOS Storyboards: analysis of the pros and cons, best practices</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/xx/gq/7w/xxgq7wvcgxjuew_bku55csqqvlu.png"><br><br>  Apple has created Storyboards so that developers can visualize the screens of iOS applications and the connections between them.  Not everyone liked this tool, and for good reason.  I have met many articles criticizing Storyboards, but I have not found a detailed and unbiased analysis of all the pros and cons of the best practices.  In the end, I decided to write such an article myself. <br><a name="habracut"></a><br>  I will try to make out in detail the disadvantages and advantages of using Storyboards.  After weighing them, you can make a sensible decision whether they are needed in the project or not.  This decision does not have to be radical.  If in some situations Storyboards create problems, in others - their use is justified: it helps to effectively solve the tasks and write simple, easily supported code. <br><br>  Let's start with the shortcomings and analyze whether all of them are still relevant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  disadvantages </h2><br><h3>  1. In Storyboards it‚Äôs hard to manage conflicts when merging changes </h3><br>  Storyboard is an XML file.  It is worse to read than the code, so it is more difficult to resolve conflicts in it.  But this complexity also depends on how we work with the Storyboard.  You can significantly simplify your task by following the rules below: <br><br><ul><li>  Do not put the entire UI in a single Storyboard, divide it into several smaller ones.  This will allow to distribute the work on Storyboards among developers without the risk of conflicts, and in the case of their inevitability they will simplify the task of resolving them. <br></li><li>  If you need to use the same View in several places - select it into a separate subclass with its own Xib file. <br></li><li>  Make commits more often, as it is much easier to work with changes coming in small chunks. <br></li></ul><br>  Using multiple Storyboards instead of one makes it impossible for us to watch the entire application map in one file.  But often this is not necessary - just a specific part, on which we are working at the moment. <br><br><h3>  2. Storyboards interfere with code reuse </h3><br>  If we are talking about using only Storyboards in the project without Xibs, then problems will surely arise.  However, Xibs, in my opinion, are necessary elements when working with Storyboards.  Thanks to them, you can easily create reusable Views, with which it is also convenient to work in code. <br><br>  To begin with, let's create a base class <code>XibView</code> , which is responsible for drawing a <code>UIView</code> created in Xib in the Storyboard: <br><br><pre> <code class="swift hljs"><span class="hljs-meta"><span class="hljs-meta">@IBDesignable</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentView: <span class="hljs-type"><span class="hljs-type">UIView?</span></span> }</code> </pre> <br>  <code>XibView</code> will load the <code>UIView</code> from Xib into the <code>contentView</code> and add it as its own subview.  We do this in the <code>setup()</code> method: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> view = loadViewFromNib() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } view.frame = bounds view.autoresizingMask = [.flexibleWidth, .flexibleHeight] addSubview(view) contentView = view }</code> </pre> <br>  The <code>loadViewFromNib()</code> method looks like this: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadViewFromNib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">UIView?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nibName = <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: type(of: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> nib = <span class="hljs-type"><span class="hljs-type">UINib</span></span>(nibName: nibName, bundle: <span class="hljs-type"><span class="hljs-type">Bundle</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: <span class="hljs-type"><span class="hljs-type">XibView</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> nib.instantiate(withOwner: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, options: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).first <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">UIView</span></span> }</code> </pre> <br>  The <code>setup()</code> method must be called in initializers: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: <span class="hljs-type"><span class="hljs-type">CGRect</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(frame: frame) setup() } <span class="hljs-keyword"><span class="hljs-keyword">required</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>?(coder aDecoder: <span class="hljs-type"><span class="hljs-type">NSCoder</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(coder: aDecoder) setup() }</code> </pre> <br>  The <code>XibView</code> class <code>XibView</code> ready.  Reusable Views whose appearance is drawn in the Xib file will inherit from <code>XibView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br><img src="https://habrastorage.org/webt/j8/ak/ny/j8aknyaa51sdpr6y8kbh7yjfwvs.png"><br>  If you now add a new <code>UIView</code> to the Storyboard and set its class in <code>RedView</code> , then everything will be successfully displayed: <br><img src="https://habrastorage.org/webt/0l/a-/wa/0la-waqvswrxya3gc8clxvro2iw.png"><br>  Creating a <code>RedView</code> instance in code happens in the usual way: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> redView = <span class="hljs-type"><span class="hljs-type">RedView</span></span>()</code> </pre> <br>  Another useful detail that not everyone can know about is the ability to add colors to the <b>.xcassets</b> catalog.  This allows you to change them globally in all Storyboards and Xibs where they are used. <br><br>  To add a color, click "+" at the bottom left and select "New Color Set": <br><img src="https://habrastorage.org/webt/zm/3u/qi/zm3uqiunozwu020zpfckzd_slbo.png"><br>  Specify the desired name and color: <br><img src="https://habrastorage.org/webt/4j/ve/lt/4jveltbjt7fiqalngh6zzg1otr4.png"><br>  The color created will appear in the ‚ÄúNamed Colors‚Äù section: <br><img src="https://habrastorage.org/webt/km/cl/ak/kmclakpy0pduyyudog1_daxmx8o.png"><br>  In addition, it can be obtained in the code: <br><br><pre> <code class="swift hljs">innerView.backgroundColor = <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(named: <span class="hljs-string"><span class="hljs-string">"BackgroundColor"</span></span>)</code> </pre><br><h3>  3. You cannot use custom initializers for <code>UIViewControllers</code> created in Storyboard </h3><br>  In the case of Storyboard, we cannot pass dependencies in the initializers of <code>UIViewControllers</code> .  Usually it looks like this: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> segue.identifier == <span class="hljs-string"><span class="hljs-string">"detail"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> detailVC = segue.destination <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>? <span class="hljs-type"><span class="hljs-type">DetailViewController</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> object = <span class="hljs-type"><span class="hljs-type">Object</span></span>() detailVC.object = object }</code> </pre> <br>  This code can be done better by using some constants to represent identifiers or tools such as <a href="https://github.com/SwiftGen/SwiftGen">SwiftGen</a> and <a href="https://github.com/mac-cain13/R.swift">R.swift</a> , and maybe even <a href="https://github.com/thoughtbot/Perform">Perform</a> .  But this is how we only get rid of string literals and add syntactic sugar, and do not solve the problems that arise: <br><br><ul><li>  How do I know how <code>DetailViewController</code> configured in the example above?  If you are new to the project and do not have this knowledge, you will have to open the file with the description of this controller and study it. <br></li><li>  The <code>DetailViewController</code> properties <code>DetailViewController</code> set after initialization, which means they should be optional.  It is necessary to handle cases where a property is <code>nil</code> , otherwise the application may fall at the most inopportune moment.  You can mark properties as implicitly expanded optional ( <code>var object: Object!</code> ), But the essence will not change. <br></li><li>  Properties should be marked as <code>var</code> , not <code>let</code> .  So a situation is possible when someone from the outside wants to change them.  <code>DetailViewController</code> should handle such situations. <br></li></ul><br>  One of the solutions is described in <a href="https://holko.pl/2017/12/06/future-proof-dependency-injection/">this article</a> . <br><br><h3>  4. As the Storyboard grows, its navigation becomes harder. </h3><br>  As we noted earlier, it is not necessary to put everything in one Storyboard, it is better to break it into several smaller ones.  With the advent of the <b>Storyboard Reference</b> it has become very simple. <br>  Add the Storyboard Reference from the object library to the Storyboard: <br><img src="https://habrastorage.org/webt/m7/v4/wc/m7v4wcm7xu_chbm7n6j_mmy1ssq.png"><br>  Set the required field values ‚Äã‚Äãin <b>Attributes Inspector</b> - this is the name of the Storyboard file and, if necessary, the <b>Referenced ID</b> , which corresponds to the <b>Storyboard ID of the</b> desired screen.  By default, the <b>Initial View Controller</b> will be loaded: <br><img src="https://habrastorage.org/webt/0j/2a/ee/0j2aeevobxwbcwd4impkwryj1ye.png"><br>  If you enter an invalid name in the Storyboard field or refer to a non-existent Storyboard ID, Xcode will warn you about this at compile time. <br><br><h3>  5. Xcode slows down when loading Storyboards </h3><br>  If the Storyboard contains a large number of screens with numerous constraints, then loading it will indeed take some time.  But again, it is better to break a large Storyboard into smaller ones.  Separately, they are loaded much faster and it becomes easier to work with them. <br><br><h3>  6. Storyboards are fragile; an error may cause the application to crash at runtime. </h3><br>  Main weaknesses: <br><br><ul><li>  Errors in the identifiers <code>UITableViewCell</code> and <code>UICollectionViewCell</code> . <br></li><li>  Errors in segues ids. <br></li><li>  Use a subclass of <code>UIView</code> that no longer exists. <br></li><li>  Synchronize <code>IBActions</code> and <code>IBOutlets</code> with code. <br></li></ul><br>  All this and some other problems can cause the application to crash at runtime, which means that there is a possibility that such errors will fall into the release assembly.  For example, when we specify cell identifiers or segues in a Storyboard, they must be copied to code wherever they are used.  By changing the identifier in one place, it must be changed in all others.  There is a possibility that you will simply forget about it or make a typo, but you will learn about the error only while the application is running. <br><br>  You can reduce the likelihood of an error if you get rid of string literals in your code.  To do this, the <code>UITableViewCell</code> and <code>UICollectionViewCell</code> can be assigned the names of the cell classes themselves: for example, the <code>ItemTableViewCell</code> string will be the <code>ItemTableViewCell</code> identifier.  In the code we get the cell like this: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell = tableView.dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span></code> </pre> <br>  You can add a generic function to the <code>UITableView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dequeueReusableCell</span></span></span><span class="hljs-function">&lt;T&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-type"><span class="hljs-type">T</span></span>: <span class="hljs-type"><span class="hljs-type">UITableViewCell</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dequeueReusableCell(withIdentifier: <span class="hljs-type"><span class="hljs-type">String</span></span>(describing: <span class="hljs-type"><span class="hljs-type">T</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span>! <span class="hljs-type"><span class="hljs-type">T</span></span> } }</code> </pre> <br>  And then it becomes easier to get a cell: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cell: <span class="hljs-type"><span class="hljs-type">ItemTableViewCell</span></span> = tableView.dequeueReusableCell()</code> </pre> <br>  If suddenly you forget to specify the value of the cell ID in the Storyboard, Xcode will give a warning, so do not ignore them. <br><br>  As for segues identifiers, you can use enumerations for them.  Create a special protocol: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>: <span class="hljs-type"><span class="hljs-type">RawRepresentable</span></span> }</code> </pre> <br>  <code>UIViewController</code> supporting this protocol will need to define a nested type with the same name.  It lists all segues identifiers that this <code>UIViewController</code> can handle: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } }</code> </pre> <br>  In addition, in the <code>SegueHandler</code> protocol extension, <code>SegueHandler</code> define two functions: one takes the <code>UIStoryboardSegue</code> and returns the corresponding value of <code>SegueIdentifier</code> , and the other simply calls the <code>performSegue</code> , taking as input <code>SegueIdentifier</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawValue</span></span></span><span class="hljs-class"> == </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">performSegue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(withIdentifier segueIdentifier: SegueIdentifier, sender: AnyObject?)</span></span></span></span> { performSegue(withIdentifier: segueIdentifier.rawValue, sender: sender) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">segueIdentifier</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">guard</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifier = segue.identifier, <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> identifierCase = <span class="hljs-type"><span class="hljs-type">SegueIdentifier</span></span>(rawValue: identifier) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">fatalError</span></span>(<span class="hljs-string"><span class="hljs-string">"Invalid segue identifier \(String(describing: segue.identifier))."</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> identifierCase } }</code> </pre> <br>  And now in <code>UIViewController</code> , which supports the new protocol, with <code>prepare(for:sender:)</code> you can work as follows: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StartViewController</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SegueIdentifier</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> signIn, signUp } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">for</span></span></span></span><span class="hljs-function"><span class="hljs-params"> segue: UIStoryboardSegue, sender: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> segueIdentifier(<span class="hljs-keyword"><span class="hljs-keyword">for</span></span>: segue) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signIn: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signIn"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .signUp: <span class="hljs-built_in"><span class="hljs-built_in">print</span></span>(<span class="hljs-string"><span class="hljs-string">"signUp"</span></span>) } } }</code> </pre> <br>  And run segue like this: <br><br><pre> <code class="swift hljs">performSegue(withIdentifier: .signIn, sender: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)</code> </pre> <br>  If you add a new identifier to <code>SegueIdentifier</code> , then Xcode will surely force it to process in <code>switch/case</code> . <br><br>  Another option to get rid of string literals such as segues and other identifiers is to use code generation tools like <a href="https://github.com/mac-cain13/R.swift">R.swift</a> . <br><br><h3>  7. Storyboards less flexible, unlike code </h3><br>  Yes this is true.  If the task is to create a complex screen with animations and effects that the Storyboard cannot handle, then you need to use the code! <br><br><h3>  8. Storyboards do not allow changing the type of special <code>UIViewControllers</code> </h3><br>  For example, when you need to change the type of <code>UITableViewController</code> to <code>UICollectionViewController</code> , you have to delete the object, add a new one with a different type, and reconfigure it again.  Although this is an infrequent case, it is worth noting that such changes are made faster in the code. <br><br><h3>  9. Storyboards add two additional dependencies to the project.  They may contain errors that the developer cannot fix. </h3><br>  This is the Interface Builder and Storyboards parser.  Such cases are rare, and they can often be circumvented by other solutions. <br><br><h3>  10. Difficult code review </h3><br>  It is necessary to take into account that code review is not quite a search for bugs.  Yes, they are found in the process of viewing the code, but the main goal is to identify weak points that can create problems in the long term.  For Storyboards, this is, first of all, the work of <b>Auto Layout</b> .  There should be no <b>ambiguous</b> and <b>misplaced</b> .  To find them, just search the Storyboard XML in the strings ‚Äúambiguous =‚Äú YES ‚Äùand‚Äú misplaced = ‚ÄúYES‚Äù, or simply open the Storyboard in Interface Builder and look for red and yellow dots: <br><img src="https://habrastorage.org/webt/u4/bw/l5/u4bwl5psqejad5ziovb2bjxy1eq.png"><br>  However, this may not be enough.  Conflicts between constraints can also be detected while the application is running.  If a similar situation occurs, information about this is displayed in the console.  Such cases are not uncommon, so their search should also be taken seriously. <br><br>  Everything else - matching the position and size of elements with the design, the correct binding <code>IBOutlets</code> and <code>IBActions</code> - not for code review. <br><br>  In addition, it is important to commit more often, then it will be easier for the reviewer to view the changes in small chunks.  He can better understand the details without losing anything.  This, in turn, will positively affect the quality of the review code. <br><br><h3>  Total </h3><br>  In the list of deficiencies of Storyboards I left 4 points (in descending order of their value): <br><br><ol><li>  In Storyboards, it‚Äôs hard to manage conflicts when merging changes. <br></li><li>  Storyboards are less flexible, unlike code. <br></li><li>  Storyboards are fragile; an error may cause the application to crash at runtime. <br></li><li>  You cannot use custom initializers for <code>UIViewControllers</code> created in Storyboard. <br></li></ol><br><h2>  Benefits </h2><br><h3>  1. User interface visualization and constraints </h3><br>  Even if you are a beginner and just take on an unfamiliar project, you can easily find the entry point into the application and how to get to the desired screen from it.  You know how each button, label or text field will look like, what position they will occupy, how they are affected by constraints, how they interact with other elements.  With a few clicks you can easily create a new <code>UIView</code> , customize its appearance and behavior.  Auto Layout allows us to work with <code>UIView</code> naturally, as if we said: "This button should be to the left of that label and have the same height with it."  Such work with the user interface is intuitive and efficient.  You can try to give examples where well-written code saves more time when creating some elements of the UI, but globally it makes little difference.  Storyboard copes well with its task. <br><br>  Separately, we note Auto Layout.  This is a very powerful and useful tool, without which it would be difficult to create an application that supports all the many different screen sizes.  Interface Builder allows you to see the result of working with Auto Layout without starting the application, and if any constraints do not fit into the overall scheme, Xcode will immediately warn about it.  Of course, there are cases when Interface Builder is not able to provide the desired behavior of some very dynamic and complex interface, then you have to rely on the code.  But even in such situations, you can do most in Interface Builder and only add a couple of lines of code to this. <br><br>  Let's look at a few examples that demonstrate the useful features of Interface Builder. <br><br><h4>  Dynamic tables based on <code>UIStackView</code> </h4><br>  Create a new <code>UIViewController</code> , add a <code>UIScrollView</code> to the full screen: <br><img src="https://habrastorage.org/webt/oh/-g/c8/oh-gc88tyx_mhu5zm6iehrnpvrk.png"><br>  In <code>UIScrollView</code> add a vertical <code>UIStackView</code> , we tie it to the edges and set the height and width equal to <code>UIScrollView</code> .  At this height, we assign <b>priority = Low (250)</b> : <br><img src="https://habrastorage.org/webt/hp/dv/v-/hpdvv-gg-hkeh_xy5k2vbbcznr0.png"><br>  Next, create all the necessary cells and add them to the <code>UIStackView</code> .  Maybe these will be the usual <code>UIView</code> in a single copy, and maybe the reused <code>UIView</code> , for which we created our Xib file.  In any case, the entire UI of this screen is in the Storyboard, and thanks to the correctly configured Auto Layout, scrolling will work perfectly, adjusting to the content: <br><br><img src="https://habrastorage.org/webt/vg/pr/dl/vgprdl652o0neubp6d87fvcyupk.gif" width="320" height="588"><br><br>  We can also make cells adapt to the size of their content.  Add to each cell by <code>UILabel</code> , tie them to the edges: <br><img src="https://habrastorage.org/webt/ei/u0/if/eiu0ifpkzcudjmimrknducpg5f4.png"><br>  It is already clear how all this will look like at the execution stage.  You can attach any actions to cells, for example, switching to another screen.  And all this without a single line of code. <br>  Moreover, if you set <code>hidden = true</code> for <code>UIView</code> from <code>UIStackView</code> , then it is not only <code>hidden = true</code> , but also will not occupy space.  <code>UIStackView</code> automatically recalculates its size: <br><br><img src="https://habrastorage.org/webt/b8/cs/ch/b8cschy8jwotcb1fge4ew2ip43s.gif"><br><br><h4>  Self-sizing cells </h4><br>  In the <b>Size inspector of the</b> table, set <b>Row Height = Automatic</b> , and <b>Estimate</b> - to some mean value: <br><img src="https://habrastorage.org/webt/p2/tp/de/p2tpdecyxveakvtukce9maxkrbq.png"><br>  For this to work, the cells themselves must have the constraints properly configured and allow you to accurately calculate the height of the cell based on the content at run time.  If it is not clear what is being said, a very good explanation is in the <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithSelf-SizingTableViewCells.html">official documentation</a> . <br><br>  As a result, running the application, we will see that everything is displayed correctly: <br><img src="https://habrastorage.org/webt/yi/mb/4q/yimb4q-qt5ydm3_3ynqavuvr4ga.png" width="432" height="702"><br><h4>  Self-sizing table </h4><br>  You need to implement this table behavior: <br><br><img src="https://habrastorage.org/webt/6g/pp/bf/6gppbf-ma4zin0czafyjn3wfj08.gif" width="320" height="588"><br><br>  How to achieve such a dynamic height change?  Unlike <code>UILabel</code> , <code>UIButton</code> and other <code>UIView</code> subclasses, it is a little more difficult to do this with the table, since the <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/AnatomyofaConstraint.html">Intrinsic Content Size</a> does not depend on the size of cells inside it.  She cannot calculate her height based on the content, but there is an opportunity to help her in this. <br><br>  Note that at some point in the video, the height of the table stops changing, reaching a certain maximum value.  This can be achieved by setting the <b>height constraint of the</b> table with the value <b>Relation = Less Than Or Equal</b> : <br><img src="https://habrastorage.org/webt/xk/47/rc/xk47rcebixtr42k1ka4wqagftyy.png"><br>  At this stage, Interface Builder does not yet know what height the table will be; it only knows its maximum value, equal to 200 (from height constraint).  As noted earlier, the Intrinsic Content Size is not equal to the table content.  However, we have the opportunity to set a placeholder in the <b>Intrinsic Size</b> field: <br><img src="https://habrastorage.org/webt/tb/i7/eu/tbi7eut1jafonqjknoyabqyev_q.png"><br>  This value is valid only while working with Interface Builder.  Of course, the Intrinsic Content Size does not have to be equal to this value at run time.  We just told Interface Builder that everything is under control. <br><br>  Next, create a new subclass of the <code>CustomTableView</code> table: <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CustomTableView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> contentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { invalidateIntrinsicContentSize() } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intrinsicContentSize: <span class="hljs-type"><span class="hljs-type">CGSize</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> contentSize } }</code> </pre> <br>  One of those cases when the code is needed.  Here we call <code>invalidateIntrinsicContentSize</code> whenever the <code>contentSize</code> table changes.  This will allow the system to adopt the new Intrinsic Content Size value.  It, in turn, returns <code>contentSize</code> , forcing the table to dynamically adjust its height and display a certain number of cells without scrolling.  Scrolling appears when we reach the height of height constraint. <br><br>  All these three features of Interface Builder can be combined with each other.  They add more flexibility in organizing content without the need for additional configuration of constraints or any <code>UIView</code> . <br><br><h3>  2. The ability to instantly see the result of their actions </h3><br>  If you change the size of <code>UIView</code> , move it a couple of points to the side or change the background color, you will immediately see how it will look at the execution stage without the need to launch the application.  No need to guess why some button did not appear on the screen or why the behavior of <code>UIView</code> does not correspond to the desired one. <br><br>  Using <code>@IBInspectable</code> reveals this advantage even more interesting.  Add two <code>UILabel</code> and two properties to <code>RedView</code> : <br><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RedView</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">XibView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> titleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBOutlet</span></span> <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitleLabel: <span class="hljs-type"><span class="hljs-type">UILabel!</span></span> <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { titleLabel.text = title } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> subtitle: <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">didSet</span></span> { subtitleLabel.text = subtitle } } }</code> </pre> <br>  Two new fields will appear in the <b>Attributes Inspector</b> for <code>RedView</code> - <code>Title</code> and <code>Subtitle</code> , which we have marked as <code>@IBInspectable</code> : <br><img src="https://habrastorage.org/webt/wv/rh/nn/wvrhnnegpjpyo7zrj7857dlujom.png"><br>  If we try to enter values ‚Äã‚Äãinto these fields, we will immediately see how everything will look like at the execution stage: <br><br><img src="https://habrastorage.org/webt/hn/bd/6u/hnbd6urq0ebbpghnuiaueovz38i.gif"><br><br>  You can control anything: <code>cornerRadius</code> , <code>borderWidth</code> , <code>borderColor</code> .  For example, <code>UIView</code> base class: <br><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIView</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cornerRadius: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.cornerRadius = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.cornerRadius } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderWidth: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderWidth = newValue } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderWidth } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> borderColor: <span class="hljs-type"><span class="hljs-type">UIColor?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { layer.borderColor = newValue?.cgColor } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layer.borderColor != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> ? <span class="hljs-type"><span class="hljs-type">UIColor</span></span>(cgColor: layer.borderColor!) : <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-meta"><span class="hljs-meta">@IBInspectable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> rotate: <span class="hljs-type"><span class="hljs-type">CGFloat</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { transform = <span class="hljs-type"><span class="hljs-type">CGAffineTransform</span></span>(rotationAngle: newValue * .pi/<span class="hljs-number"><span class="hljs-number">180</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> } } }</code> </pre> <br>  We see that the <code>RedView</code> Attributes Inspector of the <code>RedView</code> object <code>RedView</code> got 4 more new fields, which can now be played with: <br><br><img src="https://habrastorage.org/webt/gq/ib/bm/gqibbmd2an0a4zezig2iuifx5tm.gif"><br><br><h3>  3. Preview all screen sizes at once. </h3><br>  So we threw the necessary elements onto the screen, adjusted their appearance and added the necessary constraints.  How do we figure out whether the content will display correctly on different screen sizes?  Of course, you can run the application on each simulator, but it will take a lot of time.  There is a better option: Xcode has a preview mode, it allows you to see several screen sizes at the same time without running the application. <br><br>  Call the <b>Assistant editor</b> , click on the first segment of the transition panel, select <b>Preview -&gt; Settings.storyboard</b> (as an example): <br><img src="https://habrastorage.org/webt/aw/mg/nr/awmgnrb4ajxr49hrygbe70fz5is.png"><br>  At first we see only one screen, but we can add as many as we need by clicking on the ‚Äú+‚Äù in the lower left corner and selecting the necessary devices from the list: <br><img src="https://habrastorage.org/webt/18/3f/eo/183feokkgdpycsxlcr3a1upo8jk.png"><br>  In addition, if the Storyboard supports multiple languages, you can see how the selected screen will look like with each of them: <br><img src="https://habrastorage.org/webt/hy/nf/6g/hynf6gc-nzhc30fxq0ir2a2uzcc.png"><br>  Language can be selected for all screens at once, and for each separately. <br><br><h3>  4. Deleting a template UI code </h3><br>  Creating a user interface without Interface Builder is accompanied by either a large number of template code, or superclasses and extensions that entail additional maintenance work.  This code can penetrate other parts of the application, making it difficult to read and search.  Using Storyboards and Xibs allows you to unload the code, making it more focused on logic. <br><br><h3>  5. Size classes </h3><br>  Every year there are new devices for which you need to adapt the user interface.  This helps the concept of <b>trait variations</b> and, in particular, <b>size classes</b> , which allow you to create a UI for any size and orientation of the screen. <br><br>  Size classes classify the height (h) and width (w) of device screens in terms of <b>compact</b> and <b>regular</b> ( <b>C</b> and <b>R</b> ).  For example, iPhone 8 has a size class <b>(wC hR)</b> in portrait orientation and <b>(wC hC)</b> in landscape, and iPhone 8 Plus - <b>(wC hR)</b> and <b>(wR hC),</b> respectively.  For the rest of the device can be found <a href="https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/adaptivity-and-layout/">here</a> . <br><br>  In one Storyboard or Xib for each of the size classes you can store your own data set, and the application will use the appropriate device depending on the device and screen orientation at the execution stage, thus identifying the current size class.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If any layout parameters are the same for all size classes, then they can be configured in the category ‚Äú </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Any</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù, which is already selected by default. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For example, adjust the font size depending on the size class. Select for viewing in the Storyboard the iPhone 8 Plus device in portrait orientation and add a new condition for </font></font><code>font</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">: if </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">width - Regular</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (everything else is set to ‚ÄúAny‚Äù), then the font size should be 37: </font></font><br><img src="https://habrastorage.org/webt/bd/bs/-7/bdbs-7i602wtlxemns-hm3jz3ps.png"><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now, if we change the screen orientation, the font size increase - the new condition will work, since in landscape orientation the iPhone 8 Plus has size class </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hC)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . In Storyboard, depending on the size class, you can also hide Views, enable / disable constraints, change their value</font></font><code>constant</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and much more. Read more about how to do this all </font></font><a href="https://medium.com/%40craiggrummitt/size-classes-in-interface-builder-in-xcode-8-74f20a541195"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the screenshot above, it is worth noting the bottom panel with the choice of device for displaying the layout. It allows you to quickly check the adaptability of the UI on any device and for any screen orientation, and also shows the size class of the current configuration (next to the device name). Among other things, on the right there is a button " </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vary for Traits</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ". Its goal is to enable trait variations only for a certain category of width, height or width and height at the same time. For example, choosing an iPad with size class </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , click "Vary for Traits" and tick the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">width</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">height</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Now all subsequent layout changes will only be applied to devices with </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(wR hR)</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> until we click ‚Äú </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Done Varying</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù.</font></font><br><br><h2>  Conclusion </h2><div class="scrollable-table"><table><tbody><tr><th>  # <br></th><th>  disadvantages <br></th><th>  Benefits <br></th></tr><tr><td>  one <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hard to rule conflicts </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> UI visualization and constraints </font></font><br></td></tr><tr><td>  2 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Not as flexible as code </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The ability to instantly see the result of their actions </font></font><br></td></tr><tr><td>  3 <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An error can lead to a crash at run time. </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Preview all screen sizes at the same time </font></font><br></td></tr><tr><td>  four <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You cannot use custom initializers for </font></font><code>UIViewControllers</code> <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Deleting a template UI code </font></font><br></td></tr><tr><td>  five <br></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Size classes </font></font><br></td></tr></tbody></table></div><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We saw that Storyboards have their strengths and weaknesses. </font><font style="vertical-align: inherit;">My opinion - do not completely abandon their use. </font><font style="vertical-align: inherit;">When applied correctly, they bring great benefits and help to effectively solve the tasks. </font><font style="vertical-align: inherit;">You just need to learn how to set priorities and forget arguments like ‚ÄúI don‚Äôt like Storyboards‚Äù or ‚ÄúI‚Äôm used to doing that.‚Äù</font></font></div><p>Source: <a href="https://habr.com/ru/post/456086/">https://habr.com/ru/post/456086/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456070/index.html">How to attract users to the self-service portal</a></li>
<li><a href="../456072/index.html">Dav1d - the fastest AV1 decoder now in Firefox by default.</a></li>
<li><a href="../456078/index.html">Projection of corporate conflict on network connectivity</a></li>
<li><a href="../45608/index.html">Sparko</a></li>
<li><a href="../456080/index.html">Which student needs a magician and which AI do we need?</a></li>
<li><a href="../456088/index.html">Big Data Analysis Problems</a></li>
<li><a href="../456090/index.html">Introduction to unit testing in Unity</a></li>
<li><a href="../456094/index.html">Read datasheets 2: SPI on STM32; PWM, timers and interrupts on STM8</a></li>
<li><a href="../456096/index.html">What does the average reader Geektimes, soaring in the clouds</a></li>
<li><a href="../456098/index.html">Russian ICT as the foundation of national information security</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>