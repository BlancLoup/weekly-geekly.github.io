<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>10 new tales of lost time</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! I decided to continue the series of articles on the Euler hypothesis, having written several improved versions of programs for solving a Diop...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>10 new tales of lost time</h1><div class="post__text post__text-html js-mediator-article">  Hi Habr!  I decided to continue the <a href="https://habrahabr.ru/post/317588/">series of</a> <a href="https://habrahabr.ru/post/318066/">articles</a> on the Euler hypothesis, having written several improved versions of programs for solving a Diophantine equation of the form a <sup>5</sup> + b <sup>5</sup> + c <sup>5</sup> + d <sup>5</sup> = e <sup>5</sup> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/228/84a/f5e/22884af5edb445fdaef33cb76624628c.png"></div><br>  As you know, in order to solve any complex computational problem, you need to pay attention to at least the following points: <br><br><ol><li>  Efficient algorithm </li><li>  Quick implementation </li><li>  Powerful iron </li><li>  Paralleling </li></ol><br>  I paid the most attention to the first item.  Let's see what came of it. <br><a name="habracut"></a><br>  Immediately, I note that the code was written in C ++, the 32-bit MS Visual C ++ 2008 Compiler was compiled and started in one stream on the i5-2410M 2.3Ghz machine.  It's just more convenient for me - to write code lying on a not very powerful laptop, and to set the 64-bit compiler too lazy.  Measurements of time do not shine with accuracy, since the code was rarely run more than 1 time per measurement, while other processes like the browser could slightly affect the running time.  However, for our purposes, the accuracy is acceptable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And yet, with the filing of <a href="https://habrahabr.ru/users/dimchansky/" class="user_link">Dimchansky</a> , I‚Äôll clarify that I will look for integer solutions of the above equation for a, b, c, d, e&gt; 0, of which exactly 2 pieces are known.  There is a third solution, but there variables can take negative values.  You can find them all <a href="https://en.wikipedia.org/wiki/Euler%2527s_sum_of_powers_conjecture">here</a> . <br><br><h1>  Tale # 1 for O (n <sup>5</sup> ) </h1><br>  Let's start with the dumbest decision that can be.  Code: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gcd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x&amp;&amp;y) x&gt;y ? x%=y : y%=x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x+y; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=a+<span class="hljs-number"><span class="hljs-number">1</span></span>; b&lt;=n; b++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=b+<span class="hljs-number"><span class="hljs-number">1</span></span>; c&lt;=n; c++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d=c+<span class="hljs-number"><span class="hljs-number">1</span></span>; d&lt;=n; d++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e=d+<span class="hljs-number"><span class="hljs-number">1</span></span>; e&lt;=n; e++) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)a*a*a*a*a; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)b*b*b*b*b; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> c5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)c*c*c*c*c; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)d*d*d*d*d; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> e5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)e*e*e*e*e; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a5 + b5 + c5 + d5 == e5) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n"</span></span>, a, b, c, d, e ); } }</code> </pre> <br></div></div><br>  In fact, this is not the most stupid, because you can drive all the variables from 1 to n and at the end check that a &lt;b &lt;c &lt;d &lt;e.  But then I would have had to wait too long.  Working hours: <br><table><tbody><tr><th>  n </th><th>  Time </th></tr><tr><td>  100 </td><td>  1563ms </td></tr><tr><td>  200 </td><td>  40s </td></tr><tr><td>  500 </td><td>  74m </td></tr></tbody></table><br>  <b>Pros:</b> simple as a boot, spelled quickly, requires O (1) memory, finds the classic solution 27 <sup>5</sup> + 84 <sup>5</sup> + 110 <sup>5</sup> + 133 <sup>5</sup> = 144 <sup>5</sup> . <br>  <b>Cons:</b> it is <i>inhibited</i> . <br><br><h1>  Tale # 2 for O (n <sup>4</sup> log n) </h1><br>  Let's speed up our decision a bit.  In fact, this option is equivalent to what was proposed by comrade <a href="https://habrahabr.ru/users/drbasic/" class="user_link">drBasic</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; &gt; vec; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) vec.push_back( make_pair( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)a*a*a*a*a, a ) ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=a+<span class="hljs-number"><span class="hljs-number">1</span></span>; b&lt;=n; b++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=b+<span class="hljs-number"><span class="hljs-number">1</span></span>; c&lt;=n; c++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d=c+<span class="hljs-number"><span class="hljs-number">1</span></span>; d&lt;=n; d++) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)a*a*a*a*a; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)b*b*b*b*b; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> c5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)c*c*c*c*c; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)d*d*d*d*d; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = a5+b5+c5+d5; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; &gt;::iterator it = lower_bound( vec.begin(), vec.end(), make_pair( sum, <span class="hljs-number"><span class="hljs-number">0</span></span> ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (it != vec.end() &amp;&amp; it-&gt;first==sum) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gcd( a, gcd( gcd( b, c ), gcd( d, it-&gt;second ) ) ) == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n"</span></span>, a, b, c, d, it-&gt;second ); } }</code> </pre><br></div></div><br>  Here we create an array, where we save the fifth powers of all numbers from 1 to n, then inside the four nested loops we use a binary search to check if there is a <sup>5</sup> + b <sup>5</sup> + c <sup>5</sup> + d <sup>5 number</sup> in the array or not. <br><table><tbody><tr><th>  n </th><th>  Time # 1 </th><th>  Time # 2 </th></tr><tr><td>  100 </td><td>  1563ms </td><td>  318ms </td></tr><tr><td>  200 </td><td>  40s </td><td>  4140ms </td></tr><tr><td>  500 </td><td>  74m </td><td>  189s </td></tr><tr><td>  1000 </td><td></td><td>  55m </td></tr></tbody></table><br>  This option is already running faster, I even had the patience to wait for the end of the program for n = 1000. <br><br>  <b>Pros:</b> still quite simple, faster than a stupid solution, it is easy to write, it finds a classic solution. <br>  <b>Cons:</b> O (n) memory required, still <i>slow</i> . <br><br><h1>  Tale # 3 for O (n <sup>4</sup> log n), but with O (1) memory </h1><br>  In fact, it makes no sense to store all the degrees in an array and look for something binpoisk there.  We already know what number in this array is at position i.  You can simply run a bin-search on a ‚Äúvirtual‚Äù array.  No sooner said than done: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=a+<span class="hljs-number"><span class="hljs-number">1</span></span>; b&lt;=n; b++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=b+<span class="hljs-number"><span class="hljs-number">1</span></span>; c&lt;=n; c++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d=c+<span class="hljs-number"><span class="hljs-number">1</span></span>; d&lt;=n; d++) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)a*a*a*a*a; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)b*b*b*b*b; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> c5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)c*c*c*c*c; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)d*d*d*d*d; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = a5+b5+c5+d5; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum &lt;= (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)n*n*n*n*n) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mi = d, ma = n; <span class="hljs-comment"><span class="hljs-comment">// invariant: for mi &lt;, for ma &gt;= while ( mi+1 &lt; ma ) { int s = ((mi+ma)&gt;&gt;1); long long tmp = (long long)s*s*s*s*s; if (tmp &lt; sum) mi = s; else ma = s; } if (sum == (long long)ma*ma*ma*ma*ma) if (gcd( a, gcd( gcd( b, c ), gcd( d, ma ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, ma ); } } }</span></span></code> </pre><br></div></div><br>  Now the array is not needed, we have pure binary search. <br><table><tbody><tr><th>  n </th><th>  Time # 1 </th><th>  Time # 2 </th><th>  Time # 3 </th></tr><tr><td>  100 </td><td>  1563ms </td><td>  318ms </td><td>  490ms </td></tr><tr><td>  200 </td><td>  40s </td><td>  4140ms </td><td>  6728ms </td></tr><tr><td>  500 </td><td>  74m </td><td>  189s </td><td>  352s </td></tr><tr><td>  1000 </td><td></td><td>  55m </td><td></td></tr></tbody></table><br>  Unfortunately, the execution time has sunk, probably due to the fact that inside bin search we re-calculate the fifth power every time.  Well, okay. <br><br>  <b>Pros:</b> requires O (1) memory, finds a classic solution. <br>  <b>Cons:</b> slower than the previous decision. <br><br><h1>  Fairy tale # 4 for O (n <sup>4</sup> ) </h1><br>  Let's look at our equation again: <br><br>  a <sup>5</sup> + b <sup>5</sup> + c <sup>5</sup> + d <sup>5</sup> = e <sup>5</sup> <br><br>  or, for simplicity, A = B. <br><br>  Let the algorithm executes our 4 nested loops.  Fix the values ‚Äã‚Äãof a, b and c and see how the values ‚Äã‚Äãof d and e behave.  Let for some d = x the smallest value of e, for which A &lt;= B, is equal to y.  For d = x, it makes no sense to consider the values ‚Äã‚Äãof e&gt; y.  Note also that for d = x + 1 the smallest value of e, for which A &lt;= B, is not less than y.  That is, we can always just gently increase the value of e while we go by d and this ensures that we do not miss anything.  Since the values ‚Äã‚Äãof d and e only increase, the total pass through them will take O (n).  This idea is called the two-pointer method. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=a+<span class="hljs-number"><span class="hljs-number">1</span></span>; b&lt;=n; b++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c=b+<span class="hljs-number"><span class="hljs-number">1</span></span>; c&lt;=n; c++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e = c+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d=c+<span class="hljs-number"><span class="hljs-number">1</span></span>; d&lt;=n; d++) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)a*a*a*a*a; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)b*b*b*b*b; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> c5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)c*c*c*c*c; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> d5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)d*d*d*d*d; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> sum = a5+b5+c5+d5; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (e&lt;n &amp;&amp; (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)e*e*e*e*e &lt; sum) e++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sum == (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)e*e*e*e*e) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n"</span></span>, a, b, c, d, e ); } } }</code> </pre><br></div></div><br>  The code is less than for bin search, and there is more benefit. <br><table><tbody><tr><th>  n </th><th>  Time # 1 </th><th>  Time # 2 </th><th>  Time # 3 </th><th>  Time # 4 </th></tr><tr><td>  100 </td><td>  1563ms </td><td>  318ms </td><td>  490ms </td><td>  360ms </td></tr><tr><td>  200 </td><td>  40s </td><td>  4140ms </td><td>  6728ms </td><td>  4339ms </td></tr><tr><td>  500 </td><td>  74m </td><td>  189s </td><td>  352s </td><td>  177s </td></tr><tr><td>  1000 </td><td></td><td>  55m </td><td></td><td>  46m </td></tr></tbody></table><br>  Because of the large hidden constant, this solution starts to overtake solution # 2 by O (n <sup>4</sup> log n) only when n is about 500. It can, of course, be accelerated by calculating the fifth degrees more thoughtfully, but we will not do that. <br><br>  <b>Pros:</b> asymptotically faster solution # 2, requires O (1) memory.  Yes, it does. <br>  <b>Cons:</b> far from the optimum, a large hidden constant. <br><br><h1>  Fairy tale # 5 for O (n <sup>3</sup> ) </h1><br>  Let's develop an idea with two pointers, and turn the rest of the decision upside down.  Suppose we have the equation A + B = C, and for each of the A, B, C we have n (A), n (B), n (C) ways to choose them.  Let's fix some value C, and sort all valid values ‚Äã‚Äãfor A and B by ascending order.  Then we can run on the values ‚Äã‚Äãof A and B with the help of two pointers and for O (n (A) + n (B)) check everything you need for the current value of C!  Namely: for some fixed A we will decrease the value of B, while A + B&gt; C.  As soon as A + B &lt;= C becomes, then there is no point in reducing B.  Then we increase A and continue the process of decreasing B. The whole algorithm will take completely O (n (A) log n (A) + n (B) log n (B) + (n (A) + n (B)) n ( WITH) ). <br><br>  For the case when A and B are elements of the same set, the algorithm for checking fixed C can be stopped as soon as the current A and B meet (since, without loss of generality, we can assume that A &lt;B). <br><br>  Now in our equation we denote (a <sup>5</sup> + b <sup>5</sup> ) for A, (c <sup>5</sup> + d <sup>5</sup> ) for B, and e <sup>5</sup> for C. And write the following code: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; &gt; vec; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=a+<span class="hljs-number"><span class="hljs-number">1</span></span>; b&lt;=n; b++) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)a*a*a*a*a; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)b*b*b*b*b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a5 + b5 &lt; (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)n*n*n*n*n) <span class="hljs-comment"><span class="hljs-comment">// avoid overflow for n&lt;=5000 vec.push_back( make_pair( a5+b5, (a&lt;&lt;16)+b ) ); } sort( vec.begin(), vec.end() ); for (int e=1; e&lt;=n; e++) { long long e5 = (long long)e*e*e*e*e; int i = 0, j = (int)vec.size()-1; while( i &lt; j ) { while ( i &lt; j &amp;&amp; vec[i].first + vec[j].first &gt; e5 ) j--; if ( vec[i].first + vec[j].first == e5 ) { int a = (vec[i].second &gt;&gt; 16); int b = (vec[i].second &amp; ((1&lt;&lt;16)-1)); int c = (vec[j].second &gt;&gt; 16); int d = (vec[j].second &amp; ((1&lt;&lt;16)-1)); if (b &lt; c &amp;&amp; gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } i++; } } }</span></span></code> </pre><br></div></div><br>  Since the pairs (a, b) (and (c, d)) are of the order of n <sup>2</sup> , the sorting will take O (n <sup>2</sup> log n), and the next check using pointers is O (n <sup>3</sup> ).  Total clean cube. <br><br>  <b>Exercise</b> .  Find the logical error in the code above. <br><br><div class="spoiler">  <b class="spoiler_title">Think a couple of minutes before watching the answer.</b> <div class="spoiler_text">  In our case, in the sorted array, theoretically, the same sums can get caught and then the two pointers can skip some equalities.  But in fact they will be all different from the following reasoning: if there are coincidences, then x ^ 5 + y ^ 5 = z ^ 5 + t ^ 5 for some x, y, z, t and we found a counterexample <a href="https://en.wikipedia.org/wiki/Lander,_Parkin,_and_Selfridge_conjecture">to this hypothesis</a> .  As a fix, the simplest thing you can do is check that all numbers are really different. <br></div></div><br><table><tbody><tr><th>  n </th><th>  #one </th><th>  # 2 </th><th>  # 3 </th><th>  #four </th><th>  #five </th></tr><tr><td>  100 </td><td>  1563ms </td><td>  318ms </td><td>  490ms </td><td>  360ms </td><td>  82ms </td></tr><tr><td>  200 </td><td>  40s </td><td>  4140ms </td><td>  6728ms </td><td>  4339ms </td><td>  121ms </td></tr><tr><td>  500 </td><td>  74m </td><td>  189s </td><td>  352s </td><td>  177s </td><td>  516ms </td></tr><tr><td>  1000 </td><td></td><td>  55m </td><td></td><td>  46m </td><td>  3119ms </td></tr><tr><td>  2000 </td><td></td><td></td><td></td><td></td><td>  22s </td></tr><tr><td>  5000 </td><td></td><td></td><td></td><td></td><td>  328s </td></tr></tbody></table><br>  Significant acceleration allows you to drag n = 5000 for a reasonable time.  Checks when adding pairs to an array are needed to avoid overflow. <br><br>  <b>Pros:</b> probably the fastest asymptotic algorithm. <br>  <b>Cons: a</b> large hidden constant, works only up to n of the order of 5000, eats even O (n <sup>2</sup> ) memory. <br><br><h1>  Tale # 6 for O (n <sup>4</sup> log n) with an incredibly small hidden constant </h1><br>  Suddenly.  From the user's <a href="https://habrahabr.ru/users/erwins22/" class="user_link">submission</a> of <a href="https://habrahabr.ru/users/erwins22/" class="user_link">erwins22</a> from <a href="https://habrahabr.ru/post/318066/">this</a> comment, we consider the residuals that we can get by dividing the fifth power by 11. That is, what a can be compared x <sup>5</sup> = a mod 11. It turns out that the possible values ‚Äã‚Äãof a are 0, 1 and -1 (mod 11) (check for yourself and make sure). <br><br>  Then, in the equality a <sup>5</sup> + b <sup>5</sup> + c <sup>5</sup> + d <sup>5</sup> = e <sup>5</sup> units and minus ones, the total even number (they must balance each other so that the parity converges), it follows that one of the numbers a, b, c, d, e is comparable from 0 to module 11, that is, divisible by 11. Let's put it separately in one direction, we get one of two options: <br><br>  (a <sup>5</sup> + b <sup>5</sup> ) + (c <sup>5</sup> + d <sup>5</sup> ) = e <sup>5</sup> ;  e = 0 mod 11 <br><br>  (e <sup>5</sup> - a <sup>5</sup> ) - (b <sup>5</sup> + c <sup>5</sup> ) = d <sup>5</sup> ;  d = 0 mod 11 <br><br>  You will not believe, but if the number x is divisible by 11, then the number x <sup>5</sup> is divisible by 161051. Hence, the left-hand side of the above equalities must also be divisible by 161051.  As you can see, in the equations above, some numbers are already carefully paired with brackets.  Now, if we fix the first bracket, then the second bracket can have only one of all possible 161051 residues when divided by 161051. Thus, for each of O (n <sup>2</sup> ) first brackets, <i>on average,</i> there are O (n 2/161051) second.  If we now sort out all of them and see if the result is an exact fifth degree (for example, a binoisk in an array of fifth degrees), then we will find all the solutions in O (n <sup>4</sup> log n / 161051).  Code: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; &gt; vec; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=a+<span class="hljs-number"><span class="hljs-number">1</span></span>; b&lt;=n; b++) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)a*a*a*a*a; <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b5 = (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)b*b*b*b*b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a5 + b5 &lt; (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>)n*n*n*n*n) <span class="hljs-comment"><span class="hljs-comment">// avoid overflow for n&lt;=5000 vec.push_back( make_pair( a5+b5, (a&lt;&lt;16)+b ) ); } vector&lt; pair&lt; long long, int &gt; &gt; pows; for (int a=1; a&lt;=n; a++) pows.push_back( make_pair( (long long)a*a*a*a*a, a ) ); // a^5 + b^5 + c^5 + d^5 = e^5 for (int a=1; a&lt;=n; a++) for (int b=a+1; b&lt;=n; b++) { long long a5 = (long long)a*a*a*a*a; long long b5 = (long long)b*b*b*b*b; long long rem = (z - (a5+b5)%z)%z; for (int i=0; i&lt;(int)vec[rem].size(); i++) { long long sum = a5 + b5 + vec[rem][i].first; vector&lt; pair&lt; long long, int &gt; &gt;::iterator it = lower_bound( pows.begin(), pows.end(), make_pair( sum, 0 ) ); if (it != pows.end() &amp;&amp; sum == it-&gt;first) { int c = (vec[rem][i].second &gt;&gt; 16); int d = (vec[rem][i].second &amp; ((1&lt;&lt;16)-1)); int e = it-&gt;second; if (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } } } // e^5 - a^5 - b^5 - c^5 = d^5 for (int e=1; e&lt;=n; e++) for (int a=1; a&lt;e; a++) { long long e5 = (long long)e*e*e*e*e; long long a5 = (long long)a*a*a*a*a; long long rem = (e5-a5)%z; for (int i=0; i&lt;(int)vec[rem].size(); i++) if (e5-a5 &gt; vec[rem][i].first) { long long sum = e5 - a5 - vec[rem][i].first; vector&lt; pair&lt; long long, int &gt; &gt;::iterator it = lower_bound( pows.begin(), pows.end(), make_pair( sum, 0 ) ); if (it != pows.end() &amp;&amp; sum == it-&gt;first) { int b = (vec[rem][i].second &gt;&gt; 16); int c = (vec[rem][i].second &amp; ((1&lt;&lt;16)-1)); int d = it-&gt;second; if (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } } } }</span></span></code> </pre><br></div></div><br>  The working time of this solution: <br><table><tbody><tr><th>  n </th><th>  #one </th><th>  # 2 </th><th>  # 3 </th><th>  #four </th><th>  #five </th><th>  # 6 </th></tr><tr><td>  100 </td><td>  1563ms </td><td>  318ms </td><td>  490ms </td><td>  360ms </td><td>  82ms </td><td>  129ms </td></tr><tr><td>  200 </td><td>  40s </td><td>  4140ms </td><td>  6728ms </td><td>  4339ms </td><td>  121ms </td><td>  140ms </td></tr><tr><td>  500 </td><td>  74m </td><td>  189s </td><td>  352s </td><td>  177s </td><td>  516ms </td><td>  375ms </td></tr><tr><td>  1000 </td><td></td><td>  55m </td><td></td><td>  46m </td><td>  3119ms </td><td>  2559ms </td></tr><tr><td>  2000 </td><td></td><td></td><td></td><td></td><td>  22s </td><td>  38s </td></tr><tr><td>  5000 </td><td></td><td></td><td></td><td></td><td>  328s </td><td>  28m </td></tr></tbody></table><br>  From the table it can be seen that for n = 500 and n = 1000 this solution even overtakes the cubic one.  But then the cubic solution still begins to overtake.  Asymptotics she is - you can not fool her. <br><br>  <b>Pros:</b> very powerful clipping. <br>  <b>Cons: a</b> large asymptotic, it is not clear how to fasten this idea to a cubic solution. <br><br><h1>  Tale # 7 for O (n <sup>3</sup> ) with 128-bit numbers </h1><br>  Let us temporarily forget about the tricks with the modules (we will remember from later on a bit later!) And redo our cubic solution so that it can work correctly for n&gt; 5000.  To do this, we implement 128-bit integers. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> uint64; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> pair&lt; uint64, uint64 &gt; uint128; uint128 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+ (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint128 &amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint128 &amp; b) { uint128 re = make_pair( a.first + b.first, a.second + b.second ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( re.second &lt; a.second ) re.first++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } uint128 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>- (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint128 &amp; a, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uint128 &amp; b) { uint128 re = make_pair( a.first - b.first, a.second - b.second ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( re.second &gt; a.second ) re.first--; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } <span class="hljs-function"><span class="hljs-function">uint128 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">power5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x )</span></span></span><span class="hljs-function"> </span></span>{ uint64 x2 = (uint64)x*x; uint64 x3 = (uint64)x2*x; uint128 re = make_pair( (uint64)<span class="hljs-number"><span class="hljs-number">0</span></span>, (uint64)<span class="hljs-number"><span class="hljs-number">0</span></span> ); uint128 cur = make_pair( (uint64)<span class="hljs-number"><span class="hljs-number">0</span></span>, x3 ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-number"><span class="hljs-number">63</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x2&gt;&gt;i)&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>) re = re + cur; cur = cur + cur; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> re; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale7</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt; uint128, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; &gt; vec = <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt; uint128, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; &gt;( n*n/<span class="hljs-number"><span class="hljs-number">2</span></span> ); uint128 n5 = power5( n ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ind = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=a+<span class="hljs-number"><span class="hljs-number">1</span></span>; b&lt;=n; b++) { uint128 a5 = power5( a ); uint128 b5 = power5( b ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a5 + b5 &lt; n5) vec[ind++] = make_pair( a5+b5, (a&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>)+b ); } sort( vec.begin(), vec.begin()+ind ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e=<span class="hljs-number"><span class="hljs-number">1</span></span>; e&lt;=n; e++) { uint128 e5 = power5( e ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = ind<span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( i &lt; j ) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( i &lt; j &amp;&amp; vec[i].first + vec[j].first &gt; e5 ) j--; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( vec[i].first + vec[j].first == e5 ) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = (vec[i].second &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = (vec[i].second &amp; ((<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = (vec[j].second &gt;&gt; <span class="hljs-number"><span class="hljs-number">16</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d = (vec[j].second &amp; ((<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;<span class="hljs-number"><span class="hljs-number">16</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; c &amp;&amp; gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>( <span class="hljs-string"><span class="hljs-string">"%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n"</span></span>, a, b, c, d, e ); } i++; } } }</code> </pre><br></div></div><br>  The operations that needed to be added are addition and construction to the fifth degree.  There is still a subtraction, in this solution it is not needed, but it will be needed later.  So let it be.  Since the 128-bit number is implemented as pair, there are already operations &lt;,&gt;, =, and they work exactly as we need. <br><br>  At the very beginning we immediately set the size of the vector.  It‚Äôs not that this is done for optimization, I‚Äôm still too lazy to uncover the 64-bit compiler, and only 2GB of memory is available on 32 bits.  Now for n = 10,000 it takes about 1.2GB per vector.  If you expand the vector via push_back, then at the very end it captures more than 2 GB during reallocation (to increase from the length N to 2 * N you need 3 * N intermediate memory). <br><table><tbody><tr><th>  n </th><th>  #one </th><th>  # 2 </th><th>  # 3 </th><th>  #four </th><th>  #five </th><th>  # 6 </th><th>  # 7 </th></tr><tr><td>  100 </td><td>  1563ms </td><td>  318ms </td><td>  490ms </td><td>  360ms </td><td>  82ms </td><td>  129ms </td><td>  20ms </td></tr><tr><td>  200 </td><td>  40s </td><td>  4140ms </td><td>  6728ms </td><td>  4339ms </td><td>  121ms </td><td>  140ms </td><td>  105ms </td></tr><tr><td>  500 </td><td>  74m </td><td>  189s </td><td>  352s </td><td>  177s </td><td>  516ms </td><td>  375ms </td><td>  1014ms </td></tr><tr><td>  1000 </td><td></td><td>  55m </td><td></td><td>  46m </td><td>  3119ms </td><td>  2559ms </td><td>  7096ms </td></tr><tr><td>  2000 </td><td></td><td></td><td></td><td></td><td>  22s </td><td>  38s </td><td>  52s </td></tr><tr><td>  5000 </td><td></td><td></td><td></td><td></td><td>  328s </td><td>  28m </td><td>  13m </td></tr><tr><td>  10,000 </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  89m </td></tr></tbody></table><br>  You can see that now the program has slowed down almost exactly 2 times with respect to solution # 5, but we have conquered the new impregnable vertex n = 10,000! <br><br>  <b>Pros:</b> now does not overflow for n&gt; 5000. <br>  <b>Cons:</b> running 2 times slower than the solution # 5, eats a lot of memory. <br><br><h1>  Tale # 8 for O (n <sup>3</sup> ) with a smaller hidden constant </h1><br>  Recall again the remnants of division by 11. We have two equalities: <br><br>  (a <sup>5</sup> + b <sup>5</sup> ) + (c <sup>5</sup> + d <sup>5</sup> ) = e <sup>5</sup> ;  e = 0 mod 11 <br><br>  (e <sup>5</sup> - a <sup>5</sup> ) - (b <sup>5</sup> + c <sup>5</sup> ) = d <sup>5</sup> ;  d = 0 mod 11 <br><br>  Recall that the fifth degree modulo 11 always have residues 0, 1, or -1.  We remove the restrictions of the form a &lt;b &lt;c &lt;d and allow numbers to arbitrarily move from one bracket to another.  Then it is easy to show (by considering all cases) that they can always be moved so that each of the brackets will be equal to 0 modulo 11. Well, now we will need to go through all the pairs of numbers from 1 to n, find the sum and difference of their fifth degrees and remember only those that are divided by 11. And the remaining pairs can simply be thrown out. <br><br>  We can formulate such a fact: the number of such pairs will be about 51/121 of the total number of pairs (think why this is so).  Unfortunately, we will need to save two arrays of such pairs (for the sum and for the difference), which will give a gain on memory only 102/121.  Well, 15% is also a reduction.  But then we will have to run a little less along these arrays. <br><br>  And, finally, the most good news: now it makes sense for us to sort out one of the variables (which is the most external in the cubic solution) in steps of 11. The bad news is that it will be necessary to solve both types of equations separately.  The saddest thing about all this is: alas, it will speed up the program just 11 times (in fact, not yet a fact), instead of 11 <sup>5</sup> times, as in decision # 6. <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; pair&lt; uint128, pair&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; &gt; &gt; vec_p, vec_m; uint128 n5 = power5( n ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">1</span></span>; a&lt;=n; a++) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b=<span class="hljs-number"><span class="hljs-number">1</span></span>; b&lt;a; b++) { uint128 a5 = power5( a ); uint128 b5 = power5( b ); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A = a%<span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B = b%<span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> A5 = (A*A*A*A*A)%<span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> B5 = (B*B*B*B*B)%<span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (A5+B5)%<span class="hljs-number"><span class="hljs-number">11</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span> ) vec_p.push_back( make_pair( a5+b5, make_pair( a, b ) ) ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (A5-B5+<span class="hljs-number"><span class="hljs-number">11</span></span>)%<span class="hljs-number"><span class="hljs-number">11</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) vec_m.push_back( make_pair( a5-b5, make_pair( a, b ) ) ); } sort( vec_p.begin(), vec_p.end() ); sort( vec_m.begin(), vec_m.end() ); <span class="hljs-comment"><span class="hljs-comment">// (a^5 + b^5) + (c^5 + d^5) = e^5 for (int e=11; e&lt;=n; e+=11) { uint128 e5 = power5( e ); int i = 0, j = (int)vec_p.size()-1; while( i &lt; j ) { while ( i &lt; j &amp;&amp; vec_p[i].first + vec_p[j].first &gt; e5 ) j--; if ( vec_p[i].first + vec_p[j].first == e5 ) { int a = vec_p[i].second.first; int b = vec_p[i].second.second; int c = vec_p[j].second.first; int d = vec_p[j].second.second; if (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } i++; } } // (e^5 - a^5) - (b^5 + c^5) = d^5 for (int d=11; d&lt;=n; d+=11) { uint128 d5 = power5( d ); int i = 0, j = 0, mx_i = (int)vec_m.size(), mx_j = (int)vec_p.size(); while (i &lt; mx_i &amp;&amp; j &lt; mx_j) { while (j &lt; mx_j &amp;&amp; vec_m[i].first &gt; vec_p[j].first &amp;&amp; vec_m[i].first - vec_p[j].first &gt; d5) j++; if ( j &lt; mx_j &amp;&amp; vec_m[i].first &gt; vec_p[j].first &amp;&amp; vec_m[i].first - vec_p[j].first == d5 ) { int e = vec_m[i].second.first; int a = vec_m[i].second.second; int b = vec_p[j].second.first; int c = vec_p[j].second.second; if (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } i++; } } }</span></span></code> </pre><br></div></div><br>  Here, with the reallocation of vectors, there is more luck and the program for n = 10,000 fits into 2GB. <br><table><tbody><tr><th>  n </th><th>  #one </th><th>  # 2 </th><th>  # 3 </th><th>  #four </th><th>  #five </th><th>  # 6 </th><th>  # 7 </th><th>  #eight </th></tr><tr><td>  100 </td><td>  1563ms </td><td>  318ms </td><td>  490ms </td><td>  360ms </td><td>  82ms </td><td>  129ms </td><td>  20ms </td><td>  16ms </td></tr><tr><td>  200 </td><td>  40s </td><td>  4140ms </td><td>  6728ms </td><td>  4339ms </td><td>  121ms </td><td>  140ms </td><td>  105ms </td><td>  49ms </td></tr><tr><td>  500 </td><td>  74m </td><td>  189s </td><td>  352s </td><td>  177s </td><td>  516ms </td><td>  375ms </td><td>  1014ms </td><td>  472ms </td></tr><tr><td>  1000 </td><td></td><td>  55m </td><td></td><td>  46m </td><td>  3119ms </td><td>  2559ms </td><td>  7096ms </td><td>  2110ms </td></tr><tr><td>  2000 </td><td></td><td></td><td></td><td></td><td>  22s </td><td>  38s </td><td>  52s </td><td>  13s </td></tr><tr><td>  5000 </td><td></td><td></td><td></td><td></td><td>  328s </td><td>  28m </td><td>  13m </td><td>  161s </td></tr><tr><td>  10,000 </td><td></td><td></td><td></td><td></td><td></td><td></td><td>  89m </td><td>  20m </td></tr></tbody></table><br>  Alas, the program has accelerated only 4.5 times.  It seems that numerous checks in the second equation have seriously tainted the hidden constant.  Do not worry, there is still room for optimization.  The biggest problem now: wild memory consumption.  If in time for the current record n ‚Äã‚Äãis already tolerable, then we no longer fit in memory. <br><br>  <b>Pros:</b> probably the fastest solution proposed. <br>  <b>Cons:</b> still a problem with large memory consumption. <br><br><h1>  Tale # 9 for O (n <sup>3</sup> log n) with memory consumption O (n) </h1><br>  How do we reduce memory consumption?  Let's use the trick described <a href="https://arxiv.org/pdf/1108.0462v1.pdf">here</a> .  Namely: let's take some prime number p greater than n, but not much.  Consider the first equation that we have (the second equation is treated similarly): <br><br>  (a <sup>5</sup> + b <sup>5</sup> ) + (c <sup>5</sup> + d <sup>5</sup> ) = e <sup>5</sup> ;  e = 0 mod 11 <br><br>  Now let (a <sup>5</sup> + b <sup>5</sup> ) = w mod p for some w from 0 to p-1.  Then the number of pairs (a, b) that satisfy this comparison is a linear amount.  To show this, let's look at the parameter a from 1 to n.  Then, in order to find b, we will have to solve the comparison b <sup>5</sup> = (w - a <sup>5</sup> ) = u mod p.  And it is argued that this comparison will always have no more than one solution.  It follows this from this page on <a href="http://e-maxx.ru/algo/discrete_root">e-maxx</a> .  There you need to pay attention to the formula for obtaining all solutions from one: <br><br><img src="https://habrastorage.org/files/90e/6c5/ea5/90e6c5ea5b674fe382014b8008dcd94f.png"><br><br>  That is, the total solutions we have are gcd (5, phi (p)) = gcd (5, p-1).  From this, we obtain that if p = 5q + 1, then we have 5 solutions (or none), and in the remaining cases - no more than one solutions. <br><br>  (By the way, I have no idea where this formula comes from and how it works. If anyone knows the source, where it is clearly described, please share the link.) <br><br>  Now the question is how to find the value b for a fixed u?  To do this one time, but quickly - you need to understand the theory of numbers quite a lot.  But we need b for all possible values ‚Äã‚Äãof u, so we can simply find u for each b, and write it in a label: for such u, this is b. <br><br>  Further, for fixed w and fixed e <sup>5</sup> , we get that (c <sup>5</sup> + d <sup>5</sup> ) = (e <sup>5</sup> - w) mod p.  There is also a linear number of couples satisfying the comparison. <br><br>  That is, for a fixed w and a fixed e, we get a linear number of pairs that need to be sorted (unfortunately, an extra logarithm of asymptotics comes out here), after which we walk with two pointers.  Since different values ‚Äã‚Äãof w and e are of order O (n), the total asymptotic behavior is O (n <sup>3</sup> log n). <br><br>  Let's write a trial scary code: <br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_prime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a=<span class="hljs-number"><span class="hljs-number">2</span></span>; a*a&lt;=x; a++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x%a==<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tale9</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> p = n+<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( p%<span class="hljs-number"><span class="hljs-number">5</span></span>==<span class="hljs-number"><span class="hljs-number">1</span></span> || !is_prime( p ) ) p++; <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; sols = <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;( p, <span class="hljs-number"><span class="hljs-number">-1</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>; i&lt;=n; i++) { uint64 tmp = ((uint64)i*i)%p; tmp = (((tmp*tmp)%p)*i)%p; sols[(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)tmp] = i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w=<span class="hljs-number"><span class="hljs-number">0</span></span>; w&lt;p; w++) { <span class="hljs-comment"><span class="hljs-comment">// (a^5 + b^5) + (c^5 + d^5) = e^5 // (a^5 + b^5) = w (mod p) vector&lt; pair&lt; uint128, pair&lt; int, int &gt; &gt; &gt; vec1; for (int a=1; a&lt;=n; a++) { uint64 a5p = ((uint64)a*a)%p; a5p = ((a5p*a5p)%p*a)%p; int b = sols[ (w - a5p + p)%p ]; if (b!=-1 &amp;&amp; b&lt;a) { uint128 a5 = power5( a ); uint128 b5 = power5( b ); int A = a%11, A5 = (A*A*A*A*A)%11; int B = b%11, B5 = (B*B*B*B*B)%11; if ( (A5+B5)%11 == 0 ) vec1.push_back( make_pair( a5+b5, make_pair( a, b ) ) ); } } sort( vec1.begin(), vec1.end() ); for (int e=11; e&lt;=n; e+=11) { // (a^5 + b^5) + (c^5 + d^5) = e^5 // (a^5 + b^5) = w (mod p) // (c^5 + d^5) = (e^5 - w) = q (mod p) uint64 e5p = ((uint64)e*e)%p; e5p = ((e5p*e5p)%p*e)%p; int q = (int)((e5p - w + p)%p); vector&lt; pair&lt; uint128, pair&lt; int, int &gt; &gt; &gt; vec2; for (int c=1; c&lt;=n; c++) { uint64 c5p = ((uint64)c*c)%p; c5p = ((c5p*c5p)%p*c)%p; int d = sols[ (q - c5p + p)%p ]; if (d!=-1 &amp;&amp; d&lt;c) { uint128 c5 = power5( c ); uint128 d5 = power5( d ); int C = c%11, C5 = (C*C*C*C*C)%11; int D = d%11, D5 = (D*D*D*D*D)%11; if ( (C5+D5)%11 == 0 ) vec2.push_back( make_pair( c5+d5, make_pair( c, d ) ) ); } } sort( vec2.begin(), vec2.end() ); uint128 e5 = power5( e ); int i = 0, j = (int)vec2.size()-1, mx_i = (int)vec1.size(); while( i &lt; mx_i &amp;&amp; j &gt;= 0 ) { while ( j &gt;= 0 &amp;&amp; vec1[i].first + vec2[j].first &gt; e5 ) j--; if ( j &gt;= 0 &amp;&amp; vec1[i].first + vec2[j].first == e5 ) { int a = vec1[i].second.first; int b = vec1[i].second.second; int c = vec2[j].second.first; int d = vec2[j].second.second; if (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } i++; } } // (e^5 - a^5) - (b^5 + c^5) = d^5 // (b^5 + c^5) = w (mod p) // already computed as vec1 for (int d=11; d&lt;=n; d+=11) { // (e^5 - a^5) = (d^5 + w) = q (mod p) uint64 d5p = ((uint64)d*d)%p; d5p = ((d5p*d5p)%p*d)%p; int q = (int)((d5p + w)%p); vector&lt; pair&lt; uint128, pair&lt; int, int &gt; &gt; &gt; vec2; for (int e=1; e&lt;=n; e++) { uint64 e5p = ((uint64)e*e)%p; e5p = ((e5p*e5p)%p*e)%p; int a = sols[ (e5p - q + p)%p ]; if (a!=-1 &amp;&amp; a&lt;e) { uint128 e5 = power5( e ); uint128 a5 = power5( a ); int E = e%11, E5 = (E*E*E*E*E)%11; int A = a%11, A5 = (A*A*A*A*A)%11; if ( (E5-A5+11)%11 == 0 ) vec2.push_back( make_pair( e5-a5, make_pair( e, a ) ) ); } } sort( vec2.begin(), vec2.end() ); uint128 d5 = power5( d ); int i = 0, j = 0, mx_i = (int)vec2.size(), mx_j = (int)vec1.size(); while (i &lt; mx_i &amp;&amp; j &lt; mx_j) { while (j &lt; mx_j &amp;&amp; vec2[i].first &gt; vec1[j].first &amp;&amp; vec2[i].first - vec1[j].first &gt; d5) j++; if ( j &lt; mx_j &amp;&amp; vec2[i].first &gt; vec1[j].first &amp;&amp; vec2[i].first - vec1[j].first == d5 ) { int e = vec2[i].second.first; int a = vec2[i].second.second; int b = vec1[j].second.first; int c = vec1[j].second.second; if (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } i++; } } } }</span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Run this cruel tin: </font></font><br><table><tbody><tr><th>  n </th><th>  #one </th><th>  # 2 </th><th>  # 3 </th><th>  #four </th><th>  #five </th><th>  # 6 </th><th>  # 7 </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> #eight </font></font></th><th>  #9 </th></tr><tr><td>  100 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1563ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 318ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 490ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 360ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 82ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 129ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 219ms </font></font></td></tr><tr><td>  200 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 40s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4140ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6728ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4339ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 121ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 140ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 105ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1741ms </font></font></td></tr><tr><td>  500 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 74m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 189s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 352s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 177s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 516ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 375ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1014ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 472ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25s </font></font></td></tr><tr><td>  1000 </td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 55m </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 46m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3119ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2559ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7096ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2110ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 200s </font></font></td></tr><tr><td>  2000 </td><td></td><td></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 38s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 52s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28m </font></font></td></tr><tr><td>  5000 </td><td></td><td></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 328s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 161s </font></font></td><td></td></tr><tr><td>  10,000 </td><td></td><td></td><td></td><td></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 89m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20m </font></font></td><td></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gentlemen, welcome back to the stone age! Why is it so slow is something godless? Oh yeah, there is now the power5 () function at the very bottom of three nested loops, within which the loop is already at 63 iterations. Rewrite on intrinsiki? Calmly, in the next solution, we will simply drag the answer from the pre-calculated label. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But now it almost does not eat memory, and one very useful property appeared: now the task can be divided into independent subtasks, that is, ‚Äúparallelize‚Äù, or rather, distribute the calculations into several cores. Namely: for each kernel, to give its own values ‚Äã‚Äãof the parameter w and when these w cover all the numbers from 0 to p-1, we cover all cases in the problem, and the load on all the kernels will be distributed approximately evenly. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pros:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consumes very little memory, supports distributed computing. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cons:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> brakes like a shoemaker with a hangover.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tale # 10 for O (n </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> log n) with hardcore optimizations</font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We take solution # 9 and add hardcore optimizations. </font><font style="vertical-align: inherit;">Well, in fact, they are not so hardcore. </font><font style="vertical-align: inherit;">But there are many:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We foresee everything that can only be pre-calculated and put them in plates. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We reject vectors with their push_backs and redo everything into static arrays. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wherever possible, we remove the operations of taking the remainder of the division. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In the arrays for couples, we now store only the sum (or difference) of the fifth degrees, and the couples themselves try to recover only if a solution is found (since solutions are very rare - the pair is looked for exactly by the square). </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The arrays that are generated inside the cycles of e and d are now 2 times shorter on average. </font><font style="vertical-align: inherit;">Indeed, for the case of (a </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + b </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) + (c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + d </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = e </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5,</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we are interested only in (c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + d </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) &lt;e </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (good for small e), and for (e </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) - (b </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + c </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) = d </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> we are interested only in (e </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - a </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> )&gt; d </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (good for large d).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And we get the code: </font></font><br><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXN 100500 int pow5modp[MAXN]; int sols[MAXN]; uint128 vec1[MAXN], vec2[MAXN]; int vec1_sz, vec2_sz; uint128 pow5[MAXN]; int pow5mod11[MAXN]; void init_arrays( int n, int p ) { for (int i=1; i</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;=n; i++) { uint64 i5p = ((uint64)i*i)%p; i5p = (((i5p*i5p)%p)*i)%p; pow5modp[i] = (int)i5p; } for (int i=0; i&lt;p; i++) sols[i] = -1; for (int i=1; i&lt;=n; i++) sols[pow5modp[i]] = i; for (int i=1; i&lt;=n; i++) pow5[i] = power5(i); for (int i=1; i&lt;=n; i++) { int ii = i%11; pow5mod11[i] = (ii*ii*ii*ii*ii)%11; } } void tale10( int n, int start=0, int step=1 ) { int p = n+1; while ( p%5==1 || !is_prime( p ) ) p++; init_arrays( n, p ); for (int w=start; w&lt;p; w+=step) { cerr &lt;&lt; "n=" &lt;&lt; n &lt;&lt; " p=" &lt;&lt; p &lt;&lt; " w=" &lt;&lt; w &lt;&lt; "\n"; // (a^5 + b^5) + (c^5 + d^5) = e^5 // (a^5 + b^5) = w (mod p) vec1_sz = 0; for (int a=1; a&lt;=n; a++) { int tmp = w - pow5modp[a]; int b = sols[ tmp&lt;0 ? tmp+p : tmp ]; if (b!=-1 &amp;&amp; b&lt;a) if ( (pow5mod11[a]+pow5mod11[b])%11 == 0 ) vec1[vec1_sz++] = pow5[a]+pow5[b]; } sort( vec1, vec1 + vec1_sz ); for (int e=11; e&lt;=n; e+=11) { // (a^5 + b^5) + (c^5 + d^5) = e^5 // (a^5 + b^5) = w (mod p) // (c^5 + d^5) = (e^5 - w) = q (mod p) int q = (int)((pow5modp[e] - w + p)%p); uint128 e5 = pow5[e]; vec2_sz = 0; for (int c=1; c&lt;e; c++) { int tmp = q - pow5modp[c]; int d = sols[ tmp&lt;0 ? tmp+p : tmp ]; if (d!=-1 &amp;&amp; d&lt;c) if ( pow5mod11[c]+pow5mod11[d]==0 || pow5mod11[c]+pow5mod11[d]==11 ) { uint128 s = pow5[c]+pow5[d]; if (s &lt; e5) vec2[vec2_sz++] = s; } } sort( vec2, vec2 + vec2_sz ); int i = 0, j = vec2_sz-1, mx_i = vec1_sz-1; while( i &lt; mx_i &amp;&amp; j &gt;= 0 ) { while ( j &gt;= 0 &amp;&amp; vec1[i] + vec2[j] &gt; e5 ) j--; if ( j &gt;= 0 &amp;&amp; vec1[i] + vec2[j] == e5 ) { int a=-1, b=-1, c=-1, d=-1; for (int A=1; A&lt;=n; A++) for (int B=1; B&lt;A; B++) if (pow5[A]+pow5[B]==vec1[i]) { a=A; b=B; } for (int C=1; C&lt;=n; C++) for (int D=1; D&lt;C; D++) if (pow5[C]+pow5[D]==vec2[j]) { c=C; d=D; } if (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } i++; } } // (e^5 - a^5) - (b^5 + c^5) = d^5 // (b^5 + c^5) = w (mod p) // already computed as vec1 for (int d=11; d&lt;=n; d+=11) { // (e^5 - a^5) = (d^5 + w) = q (mod p) int q = (int)((pow5modp[d] + w)%p); uint128 d5 = pow5[d]; vec2_sz = 0; for (int e=d+1; e&lt;=n; e++) { int tmp = pow5modp[e]-q; int a = sols[ tmp&lt;0 ? tmp+p : tmp ]; if (a!=-1 &amp;&amp; a&lt;e) if ( pow5mod11[e]==pow5mod11[a] ) { uint128 s = pow5[e]-pow5[a]; if (s &gt; d5) vec2[vec2_sz++] = s; } } sort( vec2, vec2 + vec2_sz ); int i = 0, j = 0, mx_i = vec2_sz, mx_j = vec1_sz; while (i &lt; mx_i &amp;&amp; j &lt; mx_j) { while (j &lt; mx_j &amp;&amp; vec2[i] &gt; vec1[j] &amp;&amp; vec2[i] - vec1[j] &gt; d5) j++; if ( j &lt; mx_j &amp;&amp; vec2[i] &gt; vec1[j] &amp;&amp; vec2[i] - vec1[j] == d5 ) { int e=-1, a=-1, b=-1, c=-1; for (int E=1; E&lt;=n; E++) for (int A=1; A&lt;E; A++) if (pow5[E]-pow5[A]==vec2[i]) { e = E; a = A; } for (int B=1; B&lt;=n; B++) for (int C=1; C&lt;B; C++) if (pow5[B]+pow5[C]==vec1[j]) { b = B; c = B; } if (gcd( a, gcd( gcd( b, c ), gcd( d, e ) ) ) == 1) printf( "%d^5 + %d^5 + %d^5 + %d^5 = %d^5\n", a, b, c, d, e ); } i++; } } } }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The code has become smaller, simpler and kinder, or something. </font><font style="vertical-align: inherit;">And he became faster:</font></font><br><table><tbody><tr><th>  n </th><th>  #one </th><th>  # 2 </th><th>  # 3 </th><th>  #four </th><th>  #five </th><th>  # 6 </th><th>  # 7 </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> #eight </font></font></th><th>  #9 </th><th>  #ten </th></tr><tr><td>  100 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1563ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 318ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 490ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 360ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 82ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 129ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 16ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 219ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8ms </font></font></td></tr><tr><td>  200 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 40s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4140ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6728ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4339ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 121ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 140ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 105ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 49ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1741ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 30ms </font></font></td></tr><tr><td>  500 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 74m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 189s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 352s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 177s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 516ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 375ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1014ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 472ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 25s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 379ms </font></font></td></tr><tr><td>  1000 </td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 55m </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 46m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3119ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2559ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7096ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2110ms </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 200s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 2993ms </font></font></td></tr><tr><td>  2000 </td><td></td><td></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 38s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 52s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 24s </font></font></td></tr><tr><td>  5000 </td><td></td><td></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 328s </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 28m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 13m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 161s </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 405s </font></font></td></tr><tr><td>  10,000 </td><td></td><td></td><td></td><td></td><td></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 89m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 20m </font></font></td><td></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 59m </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We checked all the options for n = 10,000 for a more or less acceptable time, using some miserable 10 MB of memory. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pros:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> fast enough, eats little memory. </font></font><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cons:</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> they are not.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neither in a fairy tale, nor a pen to describe </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And NOW I pull out a 64-bit compiler, 6-core i7-5820K 3.3GHz and 4-core i7-3770 3.4GHz from wide-legged pants and run solution # 10 in 16 independent threads for several days. </font></font><br><table><tbody><tr><th>  n </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Total cores </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Real time </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Streams </font></font></th></tr><tr><td>  10,000 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 29m </font></font></td><td>  one </td></tr><tr><td>  20,000 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 318m </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 58m </font></font></td><td>  6 </td></tr><tr><td>  50,000 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 105h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7h </font></font></td><td>  sixteen </td></tr><tr><td>  100,000 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 970h </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 62h </font></font></td><td>  sixteen </td></tr></tbody></table><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Exact times for n = 100,000</font></font></b> <div class="spoiler_text"> <code>00 221897112ms <br> 01 221697012ms <br> 02 221413313ms <br> 03 219200228ms <br> 04 222362721ms <br> 05 221386814ms <br> 06 221880726ms <br> 07 219676217ms ** <br> 08 222212701ms <br> 09 221865811ms <br> 10 213299815ms * <br> 11 211880251ms <br> 12 211634584ms ** <br> 13 210114095ms <br> 14 211691320ms * <br> 15 212125515ms <br> * found 27^5 + 133^5 + 133^5 + 110^5 = 144^5 <br> ** found 85282^5 + 28969^5 + 28969^5 + 55^5 = 85359^5 <br> 00-09 : i7-5820K 3.3GHz <br> 10-15 : i7-3770 3.4GHz <br> sum ~ 970h <br> max ~ 62h</code> <br> </div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A 64-bit program on a faster machine (remember, I previously tested the code on the i5-2410M 2.3Ghz) works about 2 times faster. </font><font style="vertical-align: inherit;">As a result, we managed to drag n = 100000 and find the second solution to the desired Diophantine equation: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">55 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 3183 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 28969 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + 85282 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = 85359 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5</font></font></sup> <br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tale - a lie, but in her hint </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is how the not the fastest solution with the not the fastest asymptotics is best in practice. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In theory, the code can still be accelerated or the logarithm can be cut off from the asymptotics, but at the moment I am tired of optimizing - I have already </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">lost enough time</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">There are two solutions to the logarithm: replace quick sort with radix sort (but then the constant will increase to cosmic dimensions), or use a hash table instead of the idea of ‚Äã‚Äãtwo pointers (you should write and see what is really faster here). </font><font style="vertical-align: inherit;">Profiling showed that for n = 10,000 the sorting takes about half of the total time, that is, for our small values ‚Äã‚Äãof n, the logarithm is quite tolerable. </font><font style="vertical-align: inherit;">As for acceleration: there are probably some other tricks with modules that can speed up the program by 5-10 times.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Drag? </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I also have a wild idea to check all n up to a million. </font><font style="vertical-align: inherit;">The expected verification time is, in principle, real - about a million cores. </font><font style="vertical-align: inherit;">But my capacity for this will be clearly not enough. </font><font style="vertical-align: inherit;">Drag along? </font><font style="vertical-align: inherit;">However, I did not find information about how much n had already been sorted out. </font><font style="vertical-align: inherit;">Maybe a million look no longer makes sense, because everything has long been counted. </font><font style="vertical-align: inherit;">Please unsubscribe if anyone has information about this.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here and the fairy-tale end, who mastered - well done! </font></font></h3></div><p>Source: <a href="https://habr.com/ru/post/318244/">https://habr.com/ru/post/318244/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../318234/index.html">Oracle Database History ‚Äî First Commercially Successful Relational DBMS</a></li>
<li><a href="../318236/index.html">Working with C ++ tuples (std :: tuple). Functions foreach, map and call</a></li>
<li><a href="../318238/index.html">VulnHub: Exploiting the buffer overflow vulnerability in Lord Of The Root</a></li>
<li><a href="../318240/index.html">"Distribution in request" or "we get rid of search"</a></li>
<li><a href="../318242/index.html">Yii2 RESTful API for AngularJS</a></li>
<li><a href="../318246/index.html">IBM Watson will help NASA to surf the universe</a></li>
<li><a href="../318250/index.html">McAfee ATM Security Detects Hazardous Vulnerability</a></li>
<li><a href="../318254/index.html">How Drag works in Unity physics</a></li>
<li><a href="../318256/index.html">Programming gaming applications on the Corona SDK: part 1</a></li>
<li><a href="../318258/index.html">Deploy a VMware Virtual SAN 6.2 Test Cluster</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>