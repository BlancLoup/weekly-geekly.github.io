<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Poorly Documented Linux Features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Having taken a breath, said: 
 "How long have I slept!"  Once, when I first met Unix, I was fascinated by the logical harmony and completeness of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Poorly Documented Linux Features</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  Having taken a breath, said: <br>  "How long have I slept!" </blockquote><img src="https://habrastorage.org/files/ddd/a95/15b/ddda9515b1e9414f8baf11fc782a688e.jpeg" alt="image" align="left">  Once, when I first met Unix, I was fascinated by the logical harmony and completeness of the system.  A few years after that, I fiercely studied the kernel device and system calls, reading everything I could get.  Little by little my passion has come to naught, there were more pressing matters and now, starting from a certain time, I began to discover that one other feature about which I did not know before.  The process is natural, but too often such incidents are united by one thing - the absence of an authoritative source of documentation.  Often the answer is in the form of the third top comment on <i>stackoverflow</i> , often you have to bring together two or three sources to get the answer to exactly the question you asked.  I want to bring here a small collection of such poorly documented features.  None of them is new, some are not very new, but for each I killed several hours at one time and often still do not know a systematic description. <br><br>  All examples are related to Linux, although many of them are valid for other * nix systems, I simply took the most actively developing OS as a basis, besides the one that I have in my eyes and where I can quickly check the proposed code. <br><br>  Please note that in the title I wrote ‚Äúpoorly documented‚Äù and not ‚Äúobscure,‚Äù so I‚Äôm glad to add those who are aware of posting links to <b>articulate</b> documentation in the comments in the comments. <br><a name="habracut"></a><br><h3>  Does the freed memory return to the OS? </h3><br>  This question, asked by a respected colleague I have, served as a trigger for this publication.  For half an hour after that, I mixed it with mud and called it comparative epithets, explaining what else the <a href="http://www.amazon.com/The-Design-UNIX-Operating-System/dp/0132017997">classics had</a> learned - memory in Unix is ‚Äã‚Äãallocated via the <i>sbrk ()</i> system call, which simply increases the upper limit of available addresses;  usually emitted in large chunks;  that of course it is technically possible to lower the limit and return the memory to the OS for other processes, however, it is very expensive for the allocator to keep track of all used and unused fragments, so the return of memory is not provided <i>by design</i> .  This classic mechanism works fine in most cases, the exception is that the server sits quietly idle for hours / months, suddenly requesting a lot of pages to handle some event and then quietly falling asleep (but in this case it helps the swap).  After that, having satisfied my CSW, I, <s>as an honest person,</s> went to confirm my opinion on the Internet and was surprised to find that Linux starting from 2.4 can use <b>both sbrk () and mmap ()</b> to allocate memory, depending on the size requested.  Moreover, the memory allocated via <b>mmap ()</b> is completely returned to the OS after calling free () / delete.  After such a blow, I had only <s>one</s> two left - to humbly apologize and find out what exactly this mysterious limit is exactly equal to.  Since I did not find any information, I had to measure with my hands.  It turned out, on my system (3.13.0) - only 120 bytes.  Line code for those who want to try on - <a href="https://github.com/sdegtiarev/utests">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  What is the minimum interval a process / thread can sleep? </h3><br>  The same <a href="http://www.amazon.com/The-Design-UNIX-Operating-System/dp/0132017997">Maurice Bach</a> taught: the scheduler ( <i>scheduler</i> ) of processes in the core is activated by any interrupt;  after receiving control, the scheduler goes through the list of <i>sleeping</i> processes and transfers those that are awake (received the requested data from a file or socket, expired the <i>sleep ()</i> interval, etc.) into the ‚Äúready to run‚Äù list, and then goes back out of the interrupt into the current process.  When the system timer is interrupted, which happened once every 100 ms, then, as the CPU speed increased, every 10 ms, the scheduler puts the current process at the end of the ‚Äúready to run‚Äù list and starts the first process from the beginning of this list.  So, if I called <i>sleep (0)</i> or fell asleep for a moment for any reason, so my process was rearranged from the ‚Äúready to run‚Äù list to the ‚Äúpreempted‚Äù list, it has no chance of earning again before 10 ms , even if it is generally alone in the system.  In principle, the core can be rebuilt by reducing this interval, but it causes unnecessarily high CPU costs, so this is not an option.  For many years this well-known limitation has poisoned the life of the developers of fast-response systems, and it was this that greatly stimulated the development of <i>real-time systems</i> and non-blocking ( <i>lockfree</i> ) algorithms. <br><br>  And somehow I repeated this experiment (I was actually interested in more subtle moments like the probability distribution) and suddenly I saw that the process wakes up after <i>sleep (0)</i> after 40 Œºs, 250 times faster.  The same after calls <i>yield (), std :: mutex :: lock ()</i> and all other blocking calls.  What is happening ?! <br><br>  The search quickly led to the <a href="http://en.wikipedia.org/wiki/Completely_Fair_Scheduler">Completely Fair Scheduler</a> introduced since 2.6.23, but for a long time I could not understand exactly how this mechanism leads to such a fast switch.  As I found out in the end, the difference lies precisely in the algorithm of the <i>default scheduler class</i> , the one under which all processes run by default.  In contrast to the classic implementation, in this, each running process / thread has a dynamic priority, so that for a running process, the priority gradually decreases relative to other pending execution.  Thus, the scheduler can decide to start another process immediately, without waiting for the end of a fixed interval, and the algorithm for iterating the process itself is now O (1), much easier and can be executed more often. <br><br>  This change leads to surprisingly far-reaching consequences; in fact, the gap between <i>real-time</i> and the conventional system has almost disappeared, the proposed delay of 40 microseconds is really quite small for most applications, the same can be said about non-blocking algorithms - the classic blocking data structures on steel mutexes very competitive. <br><br><h3>  And what is all these classes scheduler ( <i>scheduling policies</i> )? </h3><br>  This topic is more or less described, I will not repeat myself, and nevertheless, we will open <a href="http://www.amazon.com/gp/product/0672329468/ref%3Das_li_ss_tl%3Fie%3DUTF8%26camp%3D1789%26creative%3D390957%26creativeASIN%3D0672329468%26linkCode%3Das2%26tag%3Droblov-20">one</a> and the <a href="http://shop.oreilly.com/product/9780596000028.do">second</a> authoritative books on the corresponding page and compare them among themselves.  There is almost literal repetition of each other in some places, as well as some discrepancies with what <i>man -s2 sched_setscheduler says</i> .  However, the symptom. <br><br>  Let's just play around with the code then.  I create several threads with different priorities, hang them all on the mutex and wake up all at once.  I naturally expect that they will wake up in strict accordance with their priority: <br><br><pre><code class="hljs objectivec">iBolit<span class="hljs-meta"><span class="hljs-meta"># ./sche -d0 -i0 -b0 -f1 -r2 -f3 -i0 -i0 -i0 -d0 6 SCHED_FIFO[3] 5 SCHED_RR[2] 4 SCHED_FIFO[1] 1 SCHED_OTHER[0] 2 SCHED_IDLE[0] 3 SCHED_BATCH[0] 7 SCHED_IDLE[0] 8 SCHED_IDLE[0] 9 SCHED_IDLE[0] 10 SCHED_OTHER[0]</span></span></code> </pre> <br>  The number at the beginning of the line indicates the order in which the threads were created.  As you can see, the two priority classes SCHED_FIFO and SCHED_RR always take precedence over the three regular classes SCHED_OTHER, SCHED_BATCH and SCHED_IDLE, and are ranked strictly according to priority among themselves, which is what was required.  But for example, the fact that all three user classes at the start are equal in rights is not mentioned anywhere at all, even SCHED_IDLE, which is much affected by rights compared to default SCHED_OTHER, runs ahead of it if it is first in the queue on the mutex.  Well, at least in general, everything works, but <div class="spoiler">  <b class="spoiler_title">at Solaris in this place in general a hole</b> <div class="spoiler_text">  Several years ago, I drove this test under Solaris and found that thread priorities are completely ignored, threads awaken in a completely arbitrary order.  I then contacted Sun tech support, but received a surprisingly unintelligible and empty response (before that, they willingly cooperated with us).  Two weeks later, Sun <a href="http://www.oracle.com/us/corporate/press/018363">was gone</a> .  I sincerely hope that it was not my request that caused this. </div></div><br>  For those who want to deal with priorities and classes, the source code <a href="https://github.com/sdegtiarev/utests">is also there</a> . <br><br><h3>  TCP delayed packets </h3><br>  If the previous examples can be considered a pleasant surprise, then this one is hardly pleasant to call. <br>  The story began several years ago when we suddenly discovered that one of our servers, sending clients a continuous stream of data, experiences periodic delays of 40 milliseconds.  This happened infrequently, however, we couldn‚Äôt afford this luxury, so a ritual dance with a sniffer and subsequent analysis was performed.  <b>Attention</b> , when discussing on the Internet, this problem is usually associated with the <i>Nagle algorithm</i> , <b>incorrectly</b> , according to our results, a problem arises on Linux during the interaction of <i>delayed ACK</i> and <i>slow start</i> .  Let's recall another classic, <a href="http://en.wikipedia.org/wiki/W._Richard_Stevens">Richard Stevens</a> , to refresh his memory. <br>  <i>delayed ACK</i> is an algorithm for delaying sending an ACK to a received packet for several tens of milliseconds in the expectation that a response packet will be sent immediately and an ACK can be embedded in it with the obvious goal of reducing the traffic of empty datagrams over the network.  This mechanism works in an interactive TCP session and in 1994, when <a href="http://en.wikipedia.org/wiki/TCP/IP_Illustrated">TCP / IP Illustrated</a> came out, was already a standard part of the TCP / IP stack.  What is important for further understanding is that the delay can be interrupted in particular by the arrival of the next data packet, in which case a cumulative ACK is sent to both datagrams immediately. <br>  <i>slow start</i> is an equally old algorithm designed to protect intermediate routers from an overly aggressive source.  The sender at the beginning of the session can send only one packet and must wait for the ACK from the recipient, after which it can send two, four, etc., until it reaches the other control mechanisms.  This mechanism obviously works in the case of volume traffic and, significantly, it is activated at the beginning of the session and after each forced retransmission of the lost datagram. <br>  TCP sessions can be divided into two large classes - interactive (such as <i>telnet</i> ) and volume ( <i>bulk traffic, such as ftp</i> ).  It is easy to see that the requirements for traffic-controlling algorithms in these cases are often opposite, in particular, the requirements to ‚Äúdelay ACK‚Äù and ‚Äúwait for ACK‚Äù obviously contradict each other.  In the case of a stable TCP session, the condition mentioned above is saved - the receipt of the next packet interrupts the delay and the ACK is sent to both segments without waiting for the associated data packet.  However, if suddenly one of the packets is lost, the sending side immediately initiates a <i>slow start</i> ‚Äî sends <i>one</i> datagram and waits for a response, the receiving side receives <i>one</i> datagram and delays the ACK, since no data is sent in response, the entire exchange hangs for 40 ms.  Voil√†. <br>  The effect occurs exactly in Linux - Linux TCP connections, in other systems I have not seen this, it looks like something in their implementation.  And how to deal with it?  Well, in principle, Linux offers the (non-standard) option <i>TCP_QUICKACK</i> , which disables the <i>delayed ACK</i> , but this option is not stable, it turns off automatically, so you have to check the flag before each <i>read () / write ()</i> .  There is <i>/ proc / sys / net / ipv4</i> , in particular <i>/ proc / sys / net / ipv4 / tcp_low_latency</i> , but whether she does what I suspect she should do is unknown.  In addition, this checkbox will apply to all TCP connections on this machine, not good. <br>  What are the suggestions? <br><br><h3>  From the darkness of ages </h3><br>  And finally, the very first incident in the history of Linux, just to complete the picture. <br>  From the very beginning, Linux had a non-standard system call - <i>clone ()</i> .  It works like <i>fork ()</i> , that is, it creates a copy of the current process, but the address space remains shared.  It is not difficult to guess why it was invented and, indeed, this elegant solution immediately pushed Linux into the front ranks among the operating systems for multithreading.  However, there is always one nuance ... <br><br>  The fact is that during the cloning process, all file descriptors, including sockets, are also cloned.  If previously there was a worked out scheme: a socket is opened, transferred to other threads, everyone cooperates sending and receiving data, one of the threads decides to close the socket, all others immediately see that the socket is closed, at the other end of the connection (in the case of TCP) they also see that the socket closed;  what happens now?  If one of the threads decides to close its socket, the other threads do not know anything about it, since they are actually separate processes and they have their own copies of this socket, and continue to work.  Moreover, the other end of the connection also considers the connection open.  A thing of the past, but once this innovation broke the pattern of many network programmers, and the code had to be rewritten for Linux pretty. <br><br><h3>  Literature </h3><br><ol><li>  <a href="http://www.amazon.com/The-Design-UNIX-Operating-System/dp/0132017997">Maurice J. Bach.</a>  <a href="http://www.amazon.com/The-Design-UNIX-Operating-System/dp/0132017997">The Design of the UNIX Operating System.</a> </li><li>  <a href="http://www.amazon.com/gp/product/0672329468/ref%3Das_li_ss_tl%3Fie%3DUTF8%26camp%3D1789%26creative%3D390957%26creativeASIN%3D0672329468%26linkCode%3Das2%26tag%3Droblov-20">Robert Love.</a>  <a href="http://www.amazon.com/gp/product/0672329468/ref%3Das_li_ss_tl%3Fie%3DUTF8%26camp%3D1789%26creative%3D390957%26creativeASIN%3D0672329468%26linkCode%3Das2%26tag%3Droblov-20">Linux Kernel Development</a> </li><li>  <a href="http://shop.oreilly.com/product/9780596000028.do">Daniel P. Bovet, Marco Cesati.</a>  <a href="http://shop.oreilly.com/product/9780596000028.do">Understanding the Linux Kernel</a> </li><li>  <a href="http://www.amazon.ca/TCP-IP-Illustrated-Volume-Protocols/dp/0201633469">Richard Stevens.</a>  <a href="http://www.amazon.ca/TCP-IP-Illustrated-Volume-Protocols/dp/0201633469">TCP / IP Illustrated Volume 1: The Protocols</a> </li><li>  <a href="http://www.amazon.ca/Unix-Network-Programming-Sockets-Networking/dp/0131411551/ref%3Dsr_1_3%3Fs%3Dbooks%26ie%3DUTF8%26qid%3D1427307713%26sr%3D1-3">Richard Stevens.</a>  <a href="http://www.amazon.ca/Unix-Network-Programming-Sockets-Networking/dp/0131411551/ref%3Dsr_1_3%3Fs%3Dbooks%26ie%3DUTF8%26qid%3D1427307713%26sr%3D1-3">Unix network programming</a> </li><li>  <a href="http://www.amazon.ca/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/ref%3Dsr_1_1%3Fs%3Dbooks%26ie%3DUTF8%26qid%3D1427307779%26sr%3D1-1">Richard Stevens.</a>  <a href="http://www.amazon.ca/Advanced-Programming-UNIX-Environment-3rd/dp/0321637739/ref%3Dsr_1_1%3Fs%3Dbooks%26ie%3DUTF8%26qid%3D1427307779%26sr%3D1-1">Advanced Programming in the UNIX Environment</a> </li><li>  <a href="http://www.amazon.ca/UNIX-Internals-The-New-Frontiers/dp/0131019082">Uresh Vahalia.</a>  <a href="http://www.amazon.ca/UNIX-Internals-The-New-Frontiers/dp/0131019082">UNIX Internals: The New Frontiers</a> </li></ol><br><h3>  <b>This could be your link to the topics covered.</b> </h3><br>  The first swallows: <br><ul><li>  @ Sov1et: <a href="http://www.amazon.com/TCP-Architecture-Design-Implementation-Linux/dp/0470147733">TCP / IP Architecture, Design and Implementation in Linux</a> is on the <a href="http://it-ebooks.info/book/1045/">free e-books</a> list.  I did not find the translation </li><li>  By the recommendation of <a href="http://habrahabr.ru/users/a5b/" class="user_link">a5b</a> , I add links to <a href="http://man7.org/linux/man-pages/index.html">mans</a> .  <b>Useful feature</b> : there is a group by project.  For lovers to learn by man'am. </li></ul><br><br>  And I really wonder how much I slept all the same and how far behind the times I was.  Let me include a small survey. </div><p>Source: <a href="https://habr.com/ru/post/253811/">https://habr.com/ru/post/253811/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../253795/index.html">Cognitive resistance rules and instructions</a></li>
<li><a href="../253799/index.html">zabbix_sender over HTTP - how to send data to Zabbix via HTTP | S</a></li>
<li><a href="../253801/index.html">Python Meetup 02.27.15: Hy and Toga</a></li>
<li><a href="../253805/index.html">Dynamic webpage update</a></li>
<li><a href="../253809/index.html">Puffer and the gifts of "Life"</a></li>
<li><a href="../253813/index.html">Arrow hours on CMake</a></li>
<li><a href="../253815/index.html">33 million court decisions of various courts of the Russian Federation have become public data</a></li>
<li><a href="../253817/index.html">Weekly build Vivaldi 1.0.135.2</a></li>
<li><a href="../253819/index.html">Using C # and Wix # to create msi packages</a></li>
<li><a href="../253821/index.html">Tool Preview and SDK for Windows 10 Application Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>