<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Universal soldier: how we developed and implemented an adaptive portal menu for all Mail.Ru projects</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! I am Egor Dydykin, head of the Mail.Ru. homepage development team. In this article I will talk about how we solved the problem of creating an a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Universal soldier: how we developed and implemented an adaptive portal menu for all Mail.Ru projects</h1><div class="post__text post__text-html js-mediator-article">  Hello!  I am Egor Dydykin, head of the Mail.Ru. homepage development team.  In this article I will talk about how we solved the problem of creating an adaptive portal menu - a block located at the top of almost every page of Mail.Ru projects.  Creating, developing and modifying any cross-porting solutions (to which our adaptive menu also applies) is always a voluminous and complex task.  The difficulty of working with such elements is that they are used on all projects of the Mail.Ru portal - and, accordingly, must take into account the technological and product specifics of each of them.  It is necessary that the portal menu is technically independent and can work in any environment - it is easy to integrate into each of the projects and correspond to their logic. <br><br>  The new version of the portal menu was needed as a result of a major update of portal guidelines, which occurred last year.  Details on what and why has changed, you can read on <a href="https://www.behance.net/gallery/18253171/New-branding-of-MailRu">Behance</a> .  As part of the update, it was necessary to ensure the stylistic unity of many different projects of the Mail.Ru portal, as well as a single style of navigation, visually and functionally.  On whatever project the user is located, it should be clear to him how to navigate through it.  Therefore, the menu and technically should be a single, cross-project. <br><br><img src="https://habrastorage.org/files/5c7/8da/4cb/5c78da4cbd3a42a9879a71acb9c0a32f.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The result of our work was a decision that actually represents a designer with a large set of elements, including dynamic ones.  Such an approach made it possible in real-time to ‚Äúcollect‚Äù from these elements a portal menu that meets the requirements of a project, and made it possible to bring to the forefront precisely those capabilities that are most needed by users.  The format of the elements is also adapted depending on the resolution of the screen on which the user opened the page. <br><br>  And now more about how we did it. <br><a name="habracut"></a><br><h1>  Swan, cancer and pike </h1><br>  Each project has its own needs.  One needs five buttons, the other two, and yes with dropdowns, the third one so that there are two buttons on the left, and one on the right.  Even if one of the elements of the portal menu is found on several projects, it can play different roles everywhere.  Take, for example, the search box.  In Mail.Ru Search, it will naturally occupy a central place.  In the Mail - will fade into the background: people often need to find a file or letter in a box, but still this is not the main function.  And, say, on Mail.Ru News, search is rarely used, so it makes sense to make this element compact.  And technically, projects differ radically from each other, both on the server (different platforms, languages ‚Äã‚Äãand template engines) and on the client (different libraries, doctypes, styles and technologies).  You should also not forget about the dynamic rebuild on the client in the SPA. <br><br>  One of the largest pitfalls that can be encountered when working with cross-type elements is the complexity of the update.  If you do not take care of updating the menu in advance, subsequent support will turn into a torment for the project team.  You can make the portal menu static: the project receives from the developer of the portal solution a ready code with all controls, updates also come in the form of fully generated code.  In this case, if the project team makes changes to the menu, compatibility with its next versions is lost.  This makes it even more difficult to make general changes to the portal.  In addition, the new version of the portal menu planned much more elements than in the past, including the dynamic with various states.  Due to the wide variety of templating technologies on projects from the server and the obvious technical complexity of the proposed new solution, we chose to build a portal menu on the client, which made it possible to implement a significantly more complex logic of displaying elements and introduce features such as hidden or diminishing and stretching elements. <br><br>  To avoid the problems described above and to ensure ease of updating, two conditions must be met.  First, it is necessary to develop a component that is as isolated as possible from the environment, which can be easily integrated into the project and easily updated when it is necessary, for example, to change the color of the menu throughout the portal with minimal effort from the project side.  Secondly, it is necessary to simplify the project code as much as possible by hiding the internal kitchen.  The project said ‚ÄúI want a button‚Äù - on you there is a button, ‚ÄúI want on the right‚Äù - here you are on the right.  Ideal for something declarative. <br><br><h1>  Connection </h1><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hat.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> hat.draw({}); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  I see the ideal case of working with an integrable solution as follows: I connected the library, initialized the necessary components.  This allows you to easily update the version, making a minimum of edits to the project code or not touching it at all.  But since the portal menu is a significant element located at the very top of the page, it cannot be connected and drawn anyhow, as when.  It is necessary that at the beginning of the page display the block takes its place and further does not affect the position of other blocks.  This means that the portal menu should be divided into at least three parts: styles, script and basic HTML.  HTML should be inserted in the right place on the page, drawn when loading;  further the script will integrate various elements there. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hat.css"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hat"</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hat.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> hat.draw({}); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  There is a lot of functionality planned in the new menu, which means it will have a lot of weight.  It is impossible to load all code synchronously - it will affect the loading time of the project too much.  Ideally, divide the code into two parts: the code needed to draw the placeholder (the root menu item), and the rest of the code that will be loaded asynchronously. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="hljs-comment"><span class="css"><span class="hljs-comment">/* base styles */</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hat"</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> loadExternalScript(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> hat.init(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  In this case, it turns out that you can use the portal menu only when all external data is loaded.  But I absolutely do not want to teach the project to determine when it will load everything you need.  We must look for another way.  In order to isolate the project from this knowledge, a proxy API was written, which is located in the in-line part. <br><br><pre> <code class="javascript hljs">hat.draw = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeferredQuery.getQuery(); hat.draw({}); <span class="hljs-comment"><span class="hljs-comment">// put in queue hat.draw({}); // put in queue hat.draw.replace(realDrawFn); // run two times hat.draw({}); // run immediately</span></span></code> </pre><br>  A proxy in this case is a function that remembers all its calls with arguments and, at the moment of its readiness for a call, is replaced by a real function that is run as many times as it has accumulated arguments.  In the cap are all the necessary functions for working with the portal menu, for example, drawing / redrawing. <br><br>  To load external resources with one request, styles are included in the script and are dynamically connected.  When assembling the portal menu code, the collected style code is placed in a script in a line and inserted into the house prior to API substitution. <br><br><pre> <code class="html hljs xml">var styles = ".body{background:url(\"http://...\")}", style = document.createElement('style'); style.appendChild(document.createTextNode(styles)); body.appendChild(style); init();</code> </pre><br>  It should be noted that some of the most popular browsers do not immediately apply styles under unknown circumstances.  That is, the script that follows the connection of styles works with old data.  Without thinking twice, we added an empty element to inline HTML, to which a set of rules is applied in external styles.  By its appearance, the moment of applying the styles is determined and initialization begins.  The use of styles is checked in the forehead - by timeout. <br><br><pre> <code class="html hljs xml">appendStyles(); whenStylesLoaded(init);</code> </pre><br><h1>  Building the portal menu </h1><br>  We have three assembly options (for all occasions): <br><ol><li>  Asynchronous - build for projects for which it does not matter when and how the portal menu is loaded, the main thing is that it works. </li><li>  Semi-asynchronous - for projects in which the moment of connecting styles is critical. </li><li>  Synchronous - for the guru of the web. </li></ol><br><br><h4>  Asynchronous build </h4><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span><span class="css"><span class="hljs-comment"><span class="css"><span class="hljs-comment">/* base styles */</span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">style</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hat"</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> createAPI(); loadExternalScript(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">hat.draw({});</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Thus, we got the following assembly: we stick the inline part in the right place, we immediately start the initialization of the portal menu, and then it will figure out when and how to draw.  When working with this assembly, connecting and updating to a new version comes down to copying the small inline portion to the right place in the code. <br><br><h4>  Semi-asynchronous build </h4><br>  For projects for which the moment of connecting styles is critical, it was necessary to do an assembly with styles in a separate file and a similar external script, but without styles, respectively.  An example of such a project is Mail.  The need for semi-asynchronous assembly is due to the presence of different themes on the project.  Two CSS files are connected in Mail - one with the geometry and colors of the default theme and the second with the colors of the selected theme.  We have already talked about this in more detail in a separate <a href="http://habrahabr.ru/company/mailru/blog/137552/">article</a> .  In the usual assembly of portal menus, styles are connected at an indefinite moment to an uncontrollable place: with certain changes in the menu or on the project side, it can easily turn out that menu styles will connect after theme styles (see below for code), which means they will be more powerful.  The semi-asynchronous build gives you control over the styles, and the rest is done by "itself." <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"full.css"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hat"</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined"> createAPI(); loadExternalScriptWithoutCSS(); </span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">hat.draw({});</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><h4>  Synchronous build </h4><br>  For projects that are critical in controlling the loading process, a separate assembly has been made, which includes a piece of inline HTML and external files with styles and scripts, without a loader.  A project can include files in its assemblies and load when necessary. <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">link</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">href</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"full.css"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"full.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"hat"</span></span></span><span class="hljs-tag">&gt;</span></span>...<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"><span class="undefined">hat.draw({});</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><h1>  Initialization </h1><br>  Having connected the portal menu, you need to call the drawing function, passing the configuration of the necessary elements and the callback function to which the set of API of the created elements will be transferred. <br><br><pre> <code class="html hljs xml">hat.draw({   logo: {},   toolbar: {},   submenu: {} }, function(menuItems){   menuItems.toolbar //     menuItems.submenu //    });</code> </pre><br><img src="https://habrastorage.org/files/a61/01d/909/a6101d909e2d426c9570776cc4657b6c.png"><br><br>  There are two menu levels in the portal menus: the main one (in the toolbar config) and the gray submenu (in the submenu config). <br><br>  The main code finds out that the main code needs to be drawn after rendering the placeholder and increases its height by adding an additional line.  Let me remind you that the placeholder is needed in order to reserve the place needed by the portal menu.  This means that when you first render, you need to know about the plans for the submenu and immediately draw a high menu. <br><br><pre> <code class="html hljs xml">hatConfig = {   submenu: true }</code> </pre><br>  To do this, the inline menu code learned to understand from the option announced above in the config file whether it is necessary to immediately display the placeholder for the second level. <br><br>  Then I will talk more about the content of the menu. <br><br><h1>  Items </h1><br><img src="https://habrastorage.org/files/0d8/380/de2/0d8380de20cc49b5a06303201fec7a8d.png"><br><br>  There are many items available for use in the portal menu.  These are the search string, buttons, delimiters, extended delimiters, and so on.  Most items have many options for customizing the look.  For example, we have about <b>N</b> kinds of search string.  The variety within the guidelines allows projects to flexibly customize the behavior and appearance of menu items for themselves.  All this is configurable with a large number of options.  I will not dwell on them in detail.  Particularly interested can take a walk on Mail.Ru projects and assess the difference between the menus. <br><br><h1>  Pak icons </h1><br><img src="https://habrastorage.org/files/32f/4fc/3a7/32f4fc3a7d1b4b899bd94ef4517c393a.png"><br><br>  Together with the new portal menu, we have developed and implemented unified portal icons.  The uniformity of icons helps to ensure a single user experience on all projects of the portal.  For example, the new notification icon looks the same both at the Games and in My World. <br><br>  In the portal menu for the buttons, an icon class is defined.  If it is set, an icon item is created with this class.  You can set your class icons with the appropriate styles or use the pre-set.  The preset set is automatically assembled into a sprite from the set of icons in a specific folder.  Pictures are organized by name and type.  At the moment there is a ‚Äúretin‚Äù and ‚Äúnonretinic‚Äù png with the names name.png and name@2x.png, as well as two inverted icons that are displayed when opening the dropdown.  Retinov we call icons double size, they are shown on screens with a density of more than 2. If there are both files, the icon is added to the set.  From the set using <a href="https://github.com/aheckmann/gm">https://github.com/aheckmann/gm</a> , two sprites are assembled and styles are generated for later inclusion in the assembly. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> {   <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(icons.png) no-repeat -<span class="hljs-number"><span class="hljs-number">3427px</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background-size</span></span>: <span class="hljs-number"><span class="hljs-number">3458px</span></span> <span class="hljs-number"><span class="hljs-number">21px</span></span>; } @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> only screen and (min-device-pixel-ratio: <span class="hljs-number"><span class="hljs-number">1.5</span></span>){ <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">url</span></span>(icons@2x.png); }}</code> </pre><br>  The management of the elements of the portal menu occurs through the API. <br><br><h1>  Item APIs </h1><br>  When the render function is called, a set of APIs of the created elements is passed to the callback function.  This set can also be obtained at any time by calling the function hat.getItems (function (items) {}). <br><br><pre> <code class="html hljs xml">hat.draw({}, function(menuItems){   menuItems.toolbar //     menuItems.submenu //    }); hat.getItems(function(menuItems){});</code> </pre><br>  Using the API, you can access DOM elements, hang handlers for different events, hide / show one or another element. <br><br>  For certain types of items there are additional features.  Thus, the button can change the status of the ‚Äúcurrent section‚Äù (you cannot make two ‚Äúcurrent‚Äù buttons), change the text and icon, update the number in the notification on the button.  Dropdown has a recalculation and redrawing function, which is required when updating the content of HTML dropdowns.  The search has functions for working with sadgets and a context selector. <br><br><h1>  Dynamic elements </h1><br><h4>  Collapsing groups </h4><br>  Each of the collapsing elements of such a group can be transferred to the ‚ÄúMore‚Äù drop down menu if there is not enough space for it. <br><br><img src="https://habrastorage.org/files/7dd/b4c/994/7ddb4c994b42411395851e8c2850a68c.png"><br><br><h4>  Adaptive elements </h4><br><img src="https://habrastorage.org/files/454/2eb/e12/4542ebe125654715984f40db0d86d0c4.png"><br><br><img src="https://habrastorage.org/files/02a/ac5/101/02aac5101c024793b224d4eeb05211d0.gif"><br><br>  For example, this is a button with an icon that can be slammed from icon to button with text when there is enough space for it. <br><br><h4>  Stretching elements </h4><br><img src="https://habrastorage.org/files/95b/0c8/6f7/95b0c86f7916449a8006ec5a1f6666ac.png"><br><br>  Currently, dragging elements are spacer without specifying a width and searching with the flexible parameter: true and searching. <br><br>  By default, the free space remaining after hiding the inconsistent buttons and calculating the adaptive elements is divided equally between all the stretching elements, that is, flex = 1. For any stretching element, you can set the flex parameter other than 1, then the free space will be divided according to with this value.  For example, if there are two stretching elements with flex = 1 and one element with flex = 2, when free space of 100 pixels is formed, 50 pixels will be allocated to the last element, and 25 by the rest. <br><br>  <i>&lt;additional space for element&gt; = &lt;free space&gt; / &lt;‚àë all flex&gt; * &lt;flex element&gt;</i> <br><br>  Another necessary concept for stretching elements is the base width.  This is the width relative to which free space is calculated.  It is taken from the width in the config (for the stretching spacer = 0). <br><br>  To determine the free space, all elements are rendered with a width equal to the base.  The remaining space is divided between the stretching elements in accordance with the flex parameters and added to the base width. <br><br>  <i>&lt;width of the trailing element&gt; =</i> <i><br></i>  <i>&lt;additional space for element&gt; + &lt;base width&gt;</i> <br><br><h1>  Rendering </h1><br>  hat.draw ({}); <br><br>  In the general case, the rendering of the portal menu is approximately as follows.  After the inline part (i.e. appearing on the API page), the project requests rendering of the necessary elements.  An external script is loaded in which the styles are connected, the ‚Äúclasses‚Äù of all the existing elements are created and the requested rendering is started. <br><br>  At first, the config is processed, toolbar.items is brought to a set of groups.  If it was <br><br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[ {type: 'button'}, {type: 'button'}, {type: 'group', items: [{type: 'button'},{type: 'button'}]</span></span>}, {<span class="hljs-attribute"><span class="hljs-attribute">type</span></span>: <span class="hljs-string"><span class="hljs-string">'button'</span></span>} ]</code> </pre><br>  then the output will be three groups: with the first two buttons, the original group and the group with one button. <br><br><pre> <code class="css hljs"><span class="hljs-selector-attr"><span class="hljs-selector-attr">[ {type: 'group', items: ... } {type: 'group', items: ... } {type: 'group', items: ... } ]</span></span></code> </pre><br>  Further, the configuration of each element is normalized.  We will not consider each element separately.  Here, the default values ‚Äã‚Äãof the config are set and the settings are changed that have no meaning in combination with other options.  For example, disabling the collapse of the button to the icon if the button is textual. <br><br><pre> <code class="html hljs xml">item = classes[item.type].getConfig(item);</code> </pre><br>  Configs are transferred to the template engine (Fest), which generates the necessary markup.  Elements are inserted in the right place and JS components are initialized.  Each element inside itself initializes the necessary connections, hangs up event handlers, etc. <br><br><pre> <code class="html hljs xml">html = fest(config); block.innerHTML = html; $(block).find('.elements').bem()</code> </pre><br>  It was more interesting with dynamic elements: collapsing groups, adaptive buttons and stretching elements. <br><br><h1>  Parsing items into groups </h1><br><pre> <code class="javascript hljs">getEls(); getCollapsibleGroups(); getMoreButtons(); getAdaptive(); getFlexible();</code> </pre><br>  For further calculations, we will need to disassemble all the elements according to the collections ‚Äî elements of collapsing groups, buttons ‚ÄúMore‚Äù from collapsing groups, adaptive elements, stretching elements and total flex.  The same happens when changing in the set of elements. <br><br><h4>  Default state </h4><br><pre> <code class="javascript hljs">elements.show(); adaptive.collapse(); flexible.width(baseWidth); els.each(funcion(el){ el._width = el.width(); }); fullWidth = sum(el._width);</code> </pre><br>  After initialization, all potentially visible elements are displayed.  For the stretching elements, the width is set equal to the base, the adaptive collapse, the width of all the elements, the width of all the folding elements for the groups and the full width of the toolbar are cached. <br><br>  Similar actions occur when changing the set of elements, hiding / showing, that is, changing the role of elements in the calculations or changing the set. <br><br>  The portal menu is divided into two cells with display: table-cell.  On the left is the logo, and the right - with a toolbar - takes up the remaining space.  Tublar lies inside the right cell and is positioned absolutely, so as not to affect the width of the entire menu. <br><br>  Thus, after reducing the elements to the default state (apparently), since we know the width of the cell and the toolbar, we also know how many pixels did not fit or, conversely, how much free space there is. <br><br><h4>  Calculation of visible elements </h4><br>  If the full width of the toolbar is less than the available one, simply show all the elements and hide the ‚ÄúMore‚Äù buttons. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fullWidth &lt;= currentWidth) moreButtonsHide(); collapsibleEls.show(); }</code> </pre><br>  Otherwise, we show the ‚ÄúMore‚Äù buttons and run through all the groups in order to hide the necessary number of elements in it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (fullWidth &gt; currentWidth) moreButtonsShow(); groups.each(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">group</span></span></span><span class="hljs-function">)</span></span>{ ... }) }</code> </pre><br><h4>  Group calculation </h4><br>  If you try to hide elements in the forehead from right to left in the presence of several groups, it may turn out that from one group - the one to the right - we will hide everything.  This is not good.  We are looking for another option.  You can hide by an equal number of elements from each group.  Too bad: most likely, it turns out that we will hide more elements than necessary.  So, it is necessary to distribute the hidden space in proportion to the total visible width of the group.  The more elements in a group, the more you need to hide in it. <br><br><img src="https://habrastorage.org/files/854/060/afa/854060afa1ec45ee97c0e386abd71dd0.png"><br><br>  Most likely, it turns out that the group will have to ask to hide fewer pixels than you can.  After all, it is impossible to hide an element in part, which means we will hide more.  This is shown in the picture: the right line is how much was requested, the left line is how much eventually it will turn out. <br><br>  In this scenario, it turns out that the elements jump at resize.  They are shown in one group and hidden in another, then vice versa.  To solve this problem, one should take into account the difference between the requested and actually hidden pixels and adjust the pixels of the next group for this difference. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> groupToHide = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.round(pixelsToHide * group.collapsibleWidth /collapsibleFullWidth); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> hiddenFromGroup = group.expand(groupToHide + notHidden); notHidden = groupToHide - hiddenFromGroup;</code> </pre><br><h4>  Adaptive elements </h4><br><img src="https://habrastorage.org/files/187/234/2b2/1872342b261447238c2471a4aa06b58b.png"><br><br>  When the groups are done, you can distribute the remaining pixels. <br>  First you need to check if the adaptive buttons can be slammed. <br>  The logic is simple.  At the initialization stage, the sizes of the expanded and collapsed adaptive element are cached. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expand(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._expandedWidth = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.el.clientWidth; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.collapse(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._width = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.el.clientWidth;</code> </pre><br>  That is, you can easily find out if the broken elements fit in the remaining space.  If so, then for the buttons we draw the text, and the search is switched in full view.  If not, the buttons remain in the status of the icon, and the search in the form of a button, by clicking on which a form is displayed over the other elements. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentWidth + adaptiveFullWidth &lt;= avaibleWidth){ adaptive.expand(); }</code> </pre><br><h4>  Stretching elements </h4><br><img src="https://habrastorage.org/files/95b/0c8/6f7/95b0c86f7916449a8006ec5a1f6666ac.png"><br><br>  Remaining stretching elements.  If they do not have enough space, then we reduce their dimensions to the base width. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (avaibleWidth &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>){ flexible.width(baseWidth); }</code> </pre><br>  Otherwise, we distribute the free space between the stretching elements equally. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (avaibleWidth &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>){ flexible.width(baseWidth + + avaibleWidth / flexible.length); }</code> </pre><br>  But, as we remember, we have flex factors that need to be considered.  Total, the width of a particular trailing element will be equal to its base width, folded with an additional width, calculated in proportion to the flex coefficients. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pix = (flexEl.flex) * (avaibleWidth) / (flexSum); flexEl.width(baseWidth + pix);</code> </pre><br>  There is a nuance.  Suppose we have 100 pixels of free space and three stretching elements with flex 1. It turns out that we will give each of 33 pixels and 1 will remain unallocated.  Resize the page, we get, for example, 99 pixels - everything is distributed. <br><br>  That is, periodically the elements to the right of the last stretching element will jump onto this pixel relative to the right border. <br><br><img src="https://habrastorage.org/files/bc9/99a/f2e/bc999af2ec924dccb82aff34b9235c98.png"><br><br>  To solve this problem, you can use a scheme similar to that used for collapsing groups.  It is necessary to remember the difference between the calculated value set by the element and the actually applied one, that is, round and correct the next element by this value. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pix = (flexEl.flex) * (avaibleWidth) / <span class="hljs-regexp"><span class="hljs-regexp">/ (flexSum) + delta; var roundedPix = Math.round(pix); flexEl.width(baseWidth + roundedPix); delta += (pix - roundedPix);</span></span></code> </pre><br><h1>  Finally </h1><br>  So, we managed to create an adaptive portal menu that meets both of the original requirements.  Firstly, it turned out to be technically independent - due to the use of a single technical solution, we were able to support portal guidelines on all projects, and the new portal style looks truly uniform everywhere.  Secondly, we have provided project teams with flexible management of the set of items in the portal menu.  Now each of the teams can quickly ‚Äútune‚Äù it, while remaining within the framework of the guidelines. <br><br>  What we have, we like it - this task can be considered solved.  But we still have many such tasks, both voluminous and complex.  Interesting?  Come cod to us! </div><p>Source: <a href="https://habr.com/ru/post/258901/">https://habr.com/ru/post/258901/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../258889/index.html">How we taught self-help cash desks</a></li>
<li><a href="../258891/index.html">Mastering Composer: Tips and Tricks for Using</a></li>
<li><a href="../258893/index.html">Simple cryptography: frequency and differential cryptanalysis in the task NeoQUEST-2015</a></li>
<li><a href="../258895/index.html">Video with DevConf 2014 :: PHP Cob @ cniki against kinofobov</a></li>
<li><a href="../258897/index.html">Automaton like a jet engine: real physics of unreal flight</a></li>
<li><a href="../258903/index.html">Authorization for API using tokens</a></li>
<li><a href="../258905/index.html">HP Helion OpenStack Deployment on HP BladeSystem Blades</a></li>
<li><a href="../258907/index.html">Extreme Networks Review</a></li>
<li><a href="../258909/index.html">Customer questions in the negotiations on the development of mobile applications</a></li>
<li><a href="../258911/index.html">The use of simulators in robotics on the example of the Gazebo simulator and the DARwIn-OP robot playing football</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>