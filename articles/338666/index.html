<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DI for fully reusable JSX components</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, my name is Sergey and I am interested in the problem of re-using components on the web. Looking at how trying to apply SOLID to a reactor, I decid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DI for fully reusable JSX components</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/ca8/2bd/6a2/ca82bd6a2e92447e962ce76646df42d6.jpg" alt="Dependency inception"></p><br><p>  Hi, my name is Sergey and I am interested in the problem of re-using components on the web.  Looking at how <a href="https://habrahabr.ru/company/docsvision/blog/335988/">trying to</a> apply SOLID to a reactor, I decided to continue this topic and show how to achieve good reusability by developing the idea <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25BD%25D0%25B5%25D0%25B4%25D1%2580%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25B7%25D0%25B0%25D0%25B2%25D0%25B8%25D1%2581%25D0%25B8%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">of dependency injection</a> or DI. </p><br><p>  DI as a basis for building a framework, applied to the web, is quite a young approach.  So that here it would be clearer about what it is about, I will start with things familiar to react-developers. </p><a name="habracut"></a><br><h2 id="ot-kontekstov-k-di">  From Contexts to DI </h2><br><p>  I am sure that many used <a href="https://facebook.github.io/react/docs/context.html">contexts</a> when working with react.  If not directly, then surely through <a href="http://redux.js.org/docs/basics/UsageWithReact.html">connect</a> in redux or <a href="https://github.com/mobxjs/mobx-react">inject</a> in mobx-react.  The bottom line is that in one component (MessageList) we declare something in context, and in the other (Button) we say that we want to get this something out of context. </p><br><pre><code class="hljs scala">const <span class="hljs-type"><span class="hljs-type">PropTypes</span></span> = require(<span class="hljs-symbol"><span class="hljs-symbol">'prop</span></span>-types'); const <span class="hljs-type"><span class="hljs-type">Button</span></span> = ({children}, context) =&gt; &lt;button style={{background: context.color}}&gt; {children} &lt;/button&gt;; <span class="hljs-type"><span class="hljs-type">Button</span></span>.contextTypes = {color: <span class="hljs-type"><span class="hljs-type">PropTypes</span></span>.string}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MessageList</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ getChildContext() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {color: <span class="hljs-string"><span class="hljs-string">"purple"</span></span>}; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;<span class="hljs-type"><span class="hljs-type">Button</span></span>&gt;<span class="hljs-type"><span class="hljs-type">Ok</span></span>&lt;/<span class="hljs-type"><span class="hljs-type">Button</span></span>&gt;; } }</code> </pre> <br><p>  Those.  once in the parent component <code>context.color</code> is set, and then it is automatically forwarded to any underlying components, in which color is declared through contextTypes.  Thus, the Button can be customized without passing through the properties in the hierarchy.  And at any level of the hierarchy, you can use <code>getChildContext() ...</code> override the color for all child components. </p><br><p>  This approach better isolates components from each other, simplifying their configuration and reuse.  In the example above, it is enough to determine the color in the parent component and all buttons change color.  Moreover, the Button component may be in another library, which, however, does not need to be refactored. </p><br><p>  However, for the reactor, due to the lack of reasonableness, this approach is still poorly developed.  The developers do not recommend using it directly: </p><br><blockquote>  It is an experimental API. </blockquote><p>  written in the documentation.  It has been experimental in its current form for quite a long time and the feeling that the development has reached a dead end.  The contexts in the components are linked to the infrastructure (getChildContext), pseudotyping via PropTypes, and more like a <a href="https://en.wikipedia.org/wiki/Service_locator_pattern">service locator</a> , which some consider <a href="https://habrahabr.ru/post/270005/">antipattern</a> .  The role of contexts, in my opinion, is underestimated and in the reactor is secondary: <a href="https://twitter.com/dan_abramov/status/749715530454622208">localization and temization</a> , as well as linking to libraries like redux and mobx. </p><br><p>  In other frameworks, similar tools are better developed.  For example, in vue: <a href="https://vuejs.org/v2/api/">provide / inject</a> , and in angular, its <a href="https://angular.io/guide/dependency-injection">angular di</a> is already a full featured DI with support for typescript types.  In fact, starting with Angular second version, the developers tried to rethink the backend experience (where DI has been around for a long time) in relation to the frontend.  And what if you try to develop a similar idea for the reactor and its clones, what problems would be solved? </p><br><h2 id="pribivat-ili-net-vot-v-chem-vopros">  To nail or not, that is the question </h2><br><p>  In a full reaction / redux application, not everything is done through redux actions.  The state of some insignificant ticks easier to implement through setState.  It turns out - through redux is cumbersome, and through setState is not universal, but simpler, because  he is always at hand.  The article <a href="https://medium.com/%40dan_abramov/you-might-not-need-redux-be46360cf367">You Might Not Need Redux by a</a> famous author, as if says ‚Äúif you don‚Äôt need scaling - do not use redux‚Äù, confirming this duality.  The problem is that it is not needed now, and tomorrow it may be necessary to fasten the state of the checkmark to a screw. </p><br><p>  Another article by the same author, <a href="https://medium.com/%40dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">Presentational and Container Components</a> , says roughly that "All components are equal (Presentational), but some are more equal (Container)" and are carved in granite (nailed to redux, mobx, relay, setState).  The customization of the Container component is complicated - it is not intended to reuse it, it is already nailed to the state implementation and context. </p><br><p>  In order to somehow simplify the creation of a Container-component, a <a href="https://facebook.github.io/react/docs/higher-order-components.html">HOC was</a> invented, but in fact little has changed.  Just began to combine a pure component through connect / inject with something like redux, mobx, relay.  And the resulting monolithic Container used in the code. </p><br><p>  In other words, we say Presentational and Container, and we mean - reusable and non-reusable.  The first is convenient to customize.  all the extension points are in properties, and the second is refactoring, because the properties are smaller, due to its hacking to the state and some logic.  This is a kind of compromise in solving two opposite problems, the price for which is the separation of components into two types and the sacrifice of the principle of <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BE%25D1%2582%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8/%25D0%25B7%25D0%25B0%25D0%25BA%25D1%2580%25D1%258B%25D1%2582%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">openness / closeness</a> . </p><br><p>  For example, as in the article <a href="https://habrahabr.ru/company/docsvision/blog/335988/">Replace and Conquer - the SOLID approach</a> , where it is proposed to make most of the components as simple as possible, impairing their integrity.  But, complex components from simple ones will still need to be assembled somewhere, and the question remains how to customize them.  Those.  The problem is transferred to another level. </p><br><pre> <code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalBackdrop</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag"> =&gt;</span></span> this.setState({ dialogOpen: false })} /&gt; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialog</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">open</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.state.dialogOpen}</span></span></span><span class="hljs-tag"> &gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogBox</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogHeaderBox</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogCloseButton</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag"> =&gt;</span></span> this.setState({ dialogOpen: false })} /&gt; <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogHeader</span></span></span><span class="hljs-tag">&gt;</span></span>Dialog header<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogHeader</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogHeaderBox</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogContent</span></span></span><span class="hljs-tag">&gt;</span></span>Some content<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogContent</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogButtonPanel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span><span class="hljs-tag"> =&gt;</span></span> this.setState({ dialogOpen: false })} key="cancel"&gt; {resources.Navigator_ButtonClose} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">disabled</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{!this.state.directoryDialogSelectedValue}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{this.onDirectoryDialogSelectButtonClick}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"ok"</span></span></span><span class="hljs-tag">&gt;</span></span> {resources.Navigator_ButtonSelect} <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogButtonPanel</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialogBox</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalDialog</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ModalBackdrop</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  If we nevertheless agree that we don‚Äôt customize these end components, then in reality we get a large number of template code, when, for the sake of replacing one Button, the entire component is rebuilt.  Full SOLID with this approach is impossible.  There will always be binding components to the state that cannot be expanded without modification and template components without logic inside and which are difficult to use. </p><br><h2 id="prototip">  Prototype </h2><br><p>  By developing the idea of ‚Äã‚Äãdependency injection, you can solve some of these problems.  Let us analyze the solution based on the following example: </p><br><pre> <code class="hljs xml">// @flow // @jsx lom_h // setup... class HelloService { @mem name = '' } function HelloView(props: {greet: string}, service: HelloService) { return <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> {props.greet}, {service.name} <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">/&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{service.name}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{(e)</span></span></span><span class="hljs-tag"> =&gt;</span></span> { service.name = e.target.value }} /&gt; <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> } // HelloView.deps = [HelloService] ReactDOM.render(<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">HelloView</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">greet</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Hello"</span></span></span><span class="hljs-tag">/&gt;</span></span>, document.getElementById('mount'))</code> </pre> <br><p>  <a href="https://jsfiddle.net/1xy4vy18/1/">fiddle</a> </p><br><p>  Here there is one universal form of the component as a function, regardless of whether it works with the state or not.  Contexts use types.  Descriptions of dependencies are automatically generated from them using <a href="https://github.com/zerkalica/babel-plugin-transform-metadata">babel-plugin-transform-metadata</a> .  Similarly, the typescript that does this, however, is only for classes.  Although you can manually describe the arguments: <code>HelloView.deps = [HelloService]</code> </p><br><h2 id="lifecycle">  Lifecycle </h2><br><p>  But what about the life cycle of the component?  Is it really necessary to have low-level work with it in the code?  Using HOC, they are trying to remove these lifecycle methods from the core code, for example, as in <a href="https://facebook.github.io/relay/docs/guides-root-container.html">relay / graphql</a> . </p><br><p>  The idea is that updating the data is not the responsibility of the component.  If your data is loaded after access to this data (for example, lazyObservable from <a href="https://github.com/mobxjs/mobx-utils">mobx-utils is used</a> ), then componentDidMount is not needed in this case.  If you need to tie the jquery plugin, then there is a refs property in the element, etc. </p><br><p>  Assume that the universal component, free of vendor lock-in of the reactor, is now there.  Suppose we even allocated it to a separate library.  It remains to decide how to expand and customize what comes into context.  After all, HelloService is a kind of default implementation. </p><br><h2 id="podi-tuda---ne-znayu-kuda-prinesi-to---ne-znayu-chto">  Go there - I do not know where, bring it - I do not know what </h2><br><p>  What if the components, due to frequent requirements changes, are the part of the application where encapsulation begins to interfere.  Not by itself of course, but in the form as it is implemented today in almost all frameworks: in the form of a template, a composition of functions, or JSX. </p><br><p>  Imagine for a second that in the case of any component it is impossible to say in advance that it will have its own customization.  And we need a way to change any internal part of the component without refactoring (the principle of openness / closeness), while not worsening its readability, not complicating its original implementation and not investing in reusability initially (everything cannot be foreseen). </p><br><p>  For example, without DI, you can design, implying customization through inheritance.  Those.  split up the content into small methods, losing in visibility and hierarchy.  The author writes about the disadvantages of this approach in the article <a href="https://habrahabr.ru/post/276747/">Ideal UI framework</a> : </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPanel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ header() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-header"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.head}&lt;/div&gt; } bodier() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-bodier"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.body}&lt;/div&gt; } childs() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.header() , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bodier() ] } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.childs()}&lt;/div&gt; }</code> </pre> <br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPanelExt</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyPanel</span></span></span><span class="hljs-class"> </span></span>{ footer() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>=<span class="hljs-string"><span class="hljs-string">"my-panel-footer"</span></span>&gt;{<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.foot}&lt;/div&gt; } childs() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.header() , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.bodier() , <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.footer() ] } }</code> </pre> <br><p>  I must say that this author ( <a href="https://habrahabr.ru/users/vintage">@vintage</a> ) came up with the <a href="https://habrahabr.ru/post/248147/">tree</a> format, which allows us to describe the above example while preserving the hierarchy.  Despite the fact that many people criticize this format, it has the advantage of just redefining even the smallest details without special partitioning and refactoring.  In other words, this is a free (almost, apart from comprehending a new unusual concept) letter O in SOLID. </p><br><p>  It is impossible to fully transfer this principle to JSX, but you can try to partially implement it through DI.  The point is that any component in the hierarchy is also an extension point, a slot, if we argue in terms of vue.  And we in the parent component can change its implementation, knowing its identifier (the original implementation or interface).  This is how many dependency containers work, allowing you to associate implementations with interfaces. </p><br><p>  In js / ts, at runtime, without complicating or embedding string keys that degrade the security of the code, you cannot refer to the interface.  Therefore, the following example will not work in flow or typescript (but a similar one will work in C # or Dart): </p><br><pre> <code class="hljs actionscript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISome</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySome</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ISome</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Map() map.set(ISome, MySome)</code> </pre> <br><p>  However, you can refer to an abstract class or function. </p><br><pre> <code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractSome</span></span></span><span class="hljs-class"> </span></span>{} <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MySome</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractSome</span></span></span><span class="hljs-class"> </span></span>{} const map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Map</span></span>() map.set(<span class="hljs-type"><span class="hljs-type">AbstractSome</span></span>, <span class="hljs-type"><span class="hljs-type">MySome</span></span>)</code> </pre> <br><p>  Since  When objects and components are created inside a DI container, and there can be a similar map inside, then any implementation can be overridden.  And since  components, except for the most primitive ones, are functions, then they can be substituted for functions with the same interface, but with a different implementation. </p><br><p>  For example, TodoResetButtonView is part of TodoView.  It is required to override the TodoResetButtonView on the custom implementation. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TodoResetButtonView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{onClick}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">reset</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TodoView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{todo, desc, reset}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"checkbox"</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">checked</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{todo.finished}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> todo.finished = !todo.finished} /&gt;{todo.title} #{todo.id} ({desc.title}) </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">TodoResetButtonView</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">reset</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">TodoResetButtonView</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">li</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p>  Suppose we have no way to edit TodoView (it‚Äôs in another library and we don‚Äôt want to touch it, violating the open / close principle and re-testing 11 other projects that used it with the old button). </p><br><p>  Therefore, we create a new button and clone the existing TodoView, replacing it in the clone.  This inheritance, only visibility is not violated - the hierarchy remains and you do not need to specifically design TodoView so that you can replace the button. </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClonedTodoResetButtonView</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{onClick}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">cloned reset</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ClonedTodoView = cloneComponent(TodoView, [ [TodoResetButtonView, ClonedTodoResetButtonView] ], <span class="hljs-string"><span class="hljs-string">'ClonedTodoView'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ClonedTodoListView = cloneComponent(TodoListView, [ [TodoView, ClonedTodoView] ], <span class="hljs-string"><span class="hljs-string">'ClonedTodoListView'</span></span>) ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ClonedTodoListView</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">todoList</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{store}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, document.getElementById('mount'));</span></span></code> </pre> <br><p>  <a href="https://jsfiddle.net/w7fzp1z8/14/">fiddle</a> </p><br><p>  Sometimes it is necessary to redefine not only components, but also their dependencies: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AbstractHelloService { <span class="hljs-type"><span class="hljs-type">name</span></span>: string } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HelloView(props: {greet: string}, service: AbstractHelloService) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; {props.greet}, {service.name} &lt;br/&gt;&lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>={service.name} onChange={(e) =&gt; { service.name = e.target.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> }} /&gt; &lt;/div&gt; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppHelloService { @mem <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'Jonny'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> AppView() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;HelloView greet="Hello"/&gt; } AppView.aliases = [ [AbstractHelloService, AppHelloService] ]</code> </pre> <br><p>  <a href="https://jsfiddle.net/1xy4vy18/4/">fiddle</a> </p><br><p>  HelloView will receive an instance of the AppHelloService class.  Since  <code>AppView.aliases</code> for all child components overrides AbstractHelloService. </p><br><p>  Of course, there is also a minus of the ‚Äúeverything customizes‚Äù approach through inheritance.  Since  the framework provides more extension points, then more responsibility for customization is shifted to the one who uses the component, rather than designs it.  Redefining parts of the "table" component, without realizing the meaning, can accidentally turn it into a "list", and this is a bad sign, since  is a <a href="https://habrahabr.ru/post/325478">distortion of the original meaning</a> (the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B8%25D0%25BD%25D1%2586%25D0%25B8%25D0%25BF_%25D0%25BF%25D0%25BE%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8_%25D0%2591%25D0%25B0%25D1%2580%25D0%25B1%25D0%25B0%25D1%2580%25D1%258B_%25D0%259B%25D0%25B8%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B2">LSP</a> principle is violated). </p><br><h2 id="razdelenie-sostoyaniya">  State separation </h2><br><p>  By default, the state in the dependencies of the component will be allocated for each component.  However, the general principle is that everything defined in the components above takes precedence over the underlying dependencies.  Those.  if the dependency is first used in the parent component, then it will live with it and all the underlying components that requested it will receive the parent instance. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> HelloService { @mem <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'John'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> HelloView(props: {greet: string}, service: HelloService) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; {props.greet}, {service.name} &lt;br/&gt;&lt;<span class="hljs-keyword"><span class="hljs-keyword">input</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>={service.name} onChange={(e) =&gt; { service.name = e.target.<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> }} /&gt; &lt;/div&gt; } <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> AppHelloService { @mem <span class="hljs-type"><span class="hljs-type">name</span></span> = <span class="hljs-string"><span class="hljs-string">'Jonny'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> AppView(_, service: HelloService) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;HelloView greet="Hello"/&gt; &lt;HelloView greet="Hi"/&gt; &lt;/div&gt; }</code> </pre> <br><p>  <a href="https://jsfiddle.net/1xy4vy18/3/">fiddle</a> </p><br><p>  In this configuration, both HelloViews share a shared instance of HelloService.  However, without HelloService in AppView, for each child component will be its own copy. </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AppView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div&gt; &lt;HelloView greet=<span class="hljs-string"><span class="hljs-string">"Hello"</span></span>/&gt; &lt;HelloView greet=<span class="hljs-string"><span class="hljs-string">"Hi"</span></span>/&gt; &lt;/div&gt; }</code> </pre> <br><p>  A similar principle, when it is possible to control which component the object belongs to, is used in the <a href="https://angular.io/guide/hierarchical-dependency-injection">hierarchical DI</a> Angular. </p><br><h2 id="stili">  Styles </h2><br><p>  I am not claiming that the css-in-js approach is the only correct one to use on the web.  But even here you can apply the idea of ‚Äã‚Äãdependency injection.  The problem is similar to the one described above with redux / mobx and contexts.  For example, as in many similar libraries, jss styles are nailed to a component through an injectSheet wrapper, and the component is associated with a specific implementation of styles, with react-jss: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> injectSheet <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-jss'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> styles = { <span class="hljs-attr"><span class="hljs-attr">button</span></span>: { <span class="hljs-attr"><span class="hljs-attr">background</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function"> =&gt;</span></span> props.color }, <span class="hljs-attr"><span class="hljs-attr">label</span></span>: { <span class="hljs-attr"><span class="hljs-attr">fontWeight</span></span>: <span class="hljs-string"><span class="hljs-string">'bold'</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Button = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{classes, children}</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{classes.button}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{classes.label}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> {children} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> injectSheet(styles)(Button)</code> </pre> <br><p>  However, this direct dependence on jss and others like him can be removed by transferring this responsibility to DI.  In the application code, it is sufficient to define a function with styles, as a component dependency, and mark it accordingly. </p><br><pre> <code class="hljs lua">// ... setup import {action, props, mem} from <span class="hljs-string"><span class="hljs-string">'lom_atom'</span></span> import <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> {NamesOf} from <span class="hljs-string"><span class="hljs-string">'lom_atom'</span></span> class Store { @mem red = <span class="hljs-number"><span class="hljs-number">140</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HelloTheme</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(store: Store)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { wrapper: { background: `rgb(${store.red}, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)` } } } HelloTheme.theme = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HelloView</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _, {store, theme}: { store: Store, theme: NameOf&lt;typeof HelloTheme&gt; } )</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &lt;div className={theme.wrapper}&gt; color via css {store.red}: &lt;<span class="hljs-built_in"><span class="hljs-built_in">input</span></span> <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>=<span class="hljs-string"><span class="hljs-string">"range"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">min</span></span>=<span class="hljs-string"><span class="hljs-string">"0"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">max</span></span>=<span class="hljs-string"><span class="hljs-string">"255"</span></span> value={store.red} onInput={({target}) =&gt; { store.red = Number(target.value) }} /&gt; &lt;/div&gt; }</code> </pre> <br><p>  <a href="https://jsfiddle.net/w7fzp1z8/17/">fiddle</a> </p><br><p>  Such an approach for styles has all the advantages of DI, thus it provides the theme and reactivity.  Unlike <a href="https://developer.mozilla.org/ru/docs/Web/CSS/Using_CSS_variables">variables in css</a> , types in flow / ts work here.  Of the minuses - the overhead of generating and updating css. </p><br><h2 id="itog">  Total </h2><br><p>  In an attempt to adapt the idea of ‚Äã‚Äãintroducing dependencies for components, the library turned out to be <a href="https://github.com/zerkalica/reactive-di">reactive-di</a> .  Simple examples in the article are based on it, but there are <a href="http://zerkalica.github.io/rdi-examples/">more complex ones</a> , with loading, processing of loading statuses, errors, etc.  There is a todomvc <a href="&amp;xid=25657,15700023,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgjFlv97JHLaJXMheKccPTts0n7yw#bench=">benchmark</a> for react, preact, inferno.  In which you can appreciate the overhead from the use of reactive-di.  True, by 100 todos, the measurement error I had was greater than this overhead. </p><br><p>  It turned out simplified Angular.  However, there are a number of features, reactive-di </p><br><ol><li>  Able to integrate with the reactor and its clones, while remaining compatible with legacy components in a clean reactor </li><li>  Allows you to write on some pure components without wrapping them in mobx / observe or similar. </li><li>  Works well with types in flowtype not only for classes, but also for component functions. </li><li>  Unobtrusive: no heaps of decorators are required in the code, components are abstracted from react, it can be changed to its implementation without affecting the main code </li><li>  Easy to configure, no dependency registration required, provide / inject-like constructions </li><li>  Allows you to add content to the component without modifying it, preserving the hierarchy of its internals </li><li>  Allows unobtrusively, through interfaces, to integrate css-in-js solutions into components </li></ol><br><p>  Why is the idea of ‚Äã‚Äãcontexts still not developed in this way?  Most likely, the unpopularity of DI on the frontend is explained by the non-ubiquitous dominance of flow / ts and the lack of standard interface support at the metadata level.  Attempts to copy complex implementations from other backend-oriented languages ‚Äã‚Äã(like InversifyJS Ninject clone from C #) without deep rethinking.  And also while an insufficient emphasis: for example, some similarity of DI is in react and vue, but there these implementations are an inseparable part of the framework and their role is secondary. </p><br><p>  A good DI is another half of the solution.  In the examples above, the <code>@mem</code> decorator is often flashed, which is necessary to manage the condition built on the <a href="https://habrahabr.ru/post/330466/">ORP</a> idea.  With mem, you can write code in a pseudo-sync style, with simple, in comparison with mobx, error handling and loading statuses.  I will tell you about him in the next article. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/338666/">https://habr.com/ru/post/338666/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../338654/index.html">Machine Learning: State of the art</a></li>
<li><a href="../338656/index.html">How chat bots help build omnichanal experience</a></li>
<li><a href="../338660/index.html">HR robot calls thousands of people at the same time: we tell how</a></li>
<li><a href="../338662/index.html">How to make a career in digital: the first year of the life of an internet marketer</a></li>
<li><a href="../338664/index.html">I'd go to the programmers, let them teach me</a></li>
<li><a href="../338668/index.html">Kali Linux: monitoring and logging</a></li>
<li><a href="../338670/index.html">Cat or shellCode?</a></li>
<li><a href="../338672/index.html">Profiling project build</a></li>
<li><a href="../338674/index.html">Head, what should I do to get more money</a></li>
<li><a href="../338676/index.html">The final release of 3CX Call Flow Designer and 3CX courses in Belarus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>