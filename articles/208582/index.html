<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Text interface, part 2. User interaction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, the second part. Here I will reveal how to get information from the user, as well as about the manipulation of this data. Here you can touch upon ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Text interface, part 2. User interaction</h1><div class="post__text post__text-html js-mediator-article">  So, the second part.  Here I will reveal how to get information from the user, as well as about the manipulation of this data.  Here you can touch upon the question raised in the comments to the previous <a href="http://habrahabr.ru/post/205222/">post</a> - ‚ÄúWhy is it all necessary?‚Äù.  Examples of the use of such interfaces in the 21st century are various applications on virtual machines that implement individual services.  Most often they are a minimal Linux distribution or a downloadable kernel + busybox.  Using this interface, you can implement a certain frontend for the service, allowing you to at a glance determine the status of the main nodes or perform certain operations in a user-friendly form.  An example would be similar frontends for VMware ESXi (vDirector, vCenter etc), Citrix Xen, which combine both the power of a web interface and TUI as a backup interface and / or configuration / diagnostics interface.  Switching over dozens of machines, you can see at a glance whether everything is in order or quickly find out the IP address, completely blocking the user from accessing the console, showing him only what he needs to know (foolproof). <br><img src="https://habrastorage.org/getpro/habr/post_images/08b/38f/2a8/08b38f2a85b1390bc99c4f32eefcdca2.gif"><br><a name="habracut"></a><br><br>  In order not to look into the last post, I remind you that I implement all the ‚Äúwidgets‚Äù through a structure that creates a semblance of layers, each of which is responsible for something different (shadow, design, top layer, available for the user to change).  And all this is combined into a panel that allows you to move, hide and delete all layers as one unit. <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cursed_window</span></span></span><span class="hljs-class"> {</span></span> WINDOW *background; WINDOW *decoration; WINDOW *overlay; PANEL *panel; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cursed_window</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cursed</span></span></span><span class="hljs-class">;</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Looking at the screenshots, you can see how the colors differ on some of them.  Although the code is the same, the color mapping depends on the specific implementation of the terminal emulator.  I left it as an example. <br><br>  I will not mention working with functions such as getch (), wgetch (), scanw, and associates.  These are essentially analogous to the corresponding functions from C with some additions. <br><br><h5>  Menu </h5><br><br>  The menu is implemented simply and visually.  The engine supports a wide variety of menu options, including nested ones.  Any menu items can be active or not.  There is also support for scrolling, search by combination and other joys, greatly simplifying the creation of very complex and sophisticated menus. <br>  We write a function that will return the value corresponding to the user's choice. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> tui_make_menu (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> **choices, <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> choices_num)</code> </pre><br><br>  At the entrance we have an array with lines of choices and the number of these options.  This is about our list maybe. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *choices[] = { <span class="hljs-string"><span class="hljs-string">"Restore"</span></span>, <span class="hljs-string"><span class="hljs-string">"Quick backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"Adv. backup"</span></span>, <span class="hljs-string"><span class="hljs-string">"Add machine"</span></span>, <span class="hljs-string"><span class="hljs-string">"Exit"</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, };</code> </pre><br><br>  And we will transfer it to the function like this <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tui_make_menu(choices,(<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> choices/<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> choices[<span class="hljs-number"><span class="hljs-number">0</span></span>]))==<span class="hljs-number"><span class="hljs-number">4</span></span>) do_something();</code> </pre><br><br>  And in the function itself, we now create a menu based on this array of strings. <br><br><pre> <code class="cpp hljs">ITEM **my_items = (ITEM **)<span class="hljs-built_in"><span class="hljs-built_in">calloc</span></span>(choices_num, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(ITEM *)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; choices_num; ++i) my_items[i] = new_item(choices[i], <span class="hljs-string"><span class="hljs-string">""</span></span>); MENU *my_menu = new_menu((ITEM **)my_items);</code> </pre><br><br>  In the new_item call, I specified the empty line as the second argument, this is a postfix for the menu item, it will be displayed on the right as a comment (for example, to specify the corresponding hot key). <br>  Set the window for the menu <br><pre> <code class="cpp hljs">set_menu_win(my_menu, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;overlay);</code> </pre><br>  And also we will set the character which will be a marker of the selected menu item. <br><pre> <code class="cpp hljs">set_menu_mark(my_menu, <span class="hljs-string"><span class="hljs-string">" * "</span></span>);</code> </pre><br><br>  Well, let's color our menu. <br><pre> <code class="cpp hljs">set_menu_fore(my_menu, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">1</span></span>) | A_REVERSE); set_menu_back(my_menu, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">2</span></span>)); set_menu_grey(my_menu, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">3</span></span>));</code> </pre><br><br>  And publish it <br><pre> <code class="cpp hljs">post_menu(my_menu);</code> </pre><br><br><img src="http://habrastorage.org/storage3/ee9/668/4df/ee96684df7ae60e5c6193a16daa747e7.png"><br><br>  As always, we provide the livelihood of the engine in manual, but visual mode. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(user_key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KEY_MOUSE: menu_driver(my_menu, KEY_MOUSE); touchwin(panel_window(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;panel)); update_panels(); doupdate(); sleep(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> mouse_end; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KEY_DOWN: menu_driver(my_menu, REQ_DOWN_ITEM); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> KEY_UP: menu_driver(my_menu, REQ_UP_ITEM); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } touchwin(panel_window(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;panel)); update_panels(); doupdate(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((user_key = wgetch(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;overlay)) != <span class="hljs-number"><span class="hljs-number">0xD</span></span>);</code> </pre><br><br>  Yes Yes.  Let's digress and talk about working with the mouse. <br><br><h6>  Mouse </h6><br><br>  Ncurses allows us to duplicate the actions that we have already done with the keyboard, using the mouse, without much complicating and changing the code.  It is enough to turn on the response to mouse events with a simple masking. <br><pre> <code class="cpp hljs">mousemask(ALL_MOUSE_EVENTS, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre><br>  In this case, all events are allowed, but you may naturally want to respond only to a double click with the right button <i>BUTTON2_DOUBLE_CLICKED</i> or only with the release of the left button <i>BUTTON1_RELEASED</i> , etc. <br><br>  After that, in our standard input processing loop, you will need to add a case KEY_MOUSE and then transfer the received event to the menu engine or make something different.  In the first case, the menu slider will independently determine how to move the menu marker. <br>  It is very important if the work goes through VNC with not always adequate mouse work. <br><br>  Now that the user has defined and selected a menu item, we can find out his choice. <br><br><pre> <code class="cpp hljs">mouse_end: <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> user_selection = item_index(current_item(my_menu));</code> </pre><br><br>  Remove trash <br><br><pre> <code class="cpp hljs">unpost_menu(my_menu); free_menu(my_menu); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; choices_num; ++i) free_item(my_items[i]); tui_del_win(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>);</code> </pre><br><br>  and return the value <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (user_selection);</code> </pre><br><br><h5>  Forms and fields </h5><br><br>  The input field in ncurses has a very powerful functionality that allows you to manipulate the text entered by the user over a wide range.  But first, we will write a small function that will return us the text from the user and, using its example, consider how and what can be done with this field. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tui_make_input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *info, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max_len)</span></span></span></span>;</code> </pre><br>  That is, we must specify the maximum field length and some informational message explaining what we want to receive from the user. <br><br>  Create a buffer with our input field.  In this case, the size of the field is fixed, but the field can expand automatically, <br>  This style of initialization is required. <br><pre> <code class="cpp hljs">FIELD *field[<span class="hljs-number"><span class="hljs-number">2</span></span>]; field[<span class="hljs-number"><span class="hljs-number">0</span></span>] = new_field(<span class="hljs-number"><span class="hljs-number">1</span></span>, max_len, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); field[<span class="hljs-number"><span class="hljs-number">1</span></span>] = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>;</code> </pre><br><br><pre> <code class="cpp hljs">FORM *my_form; set_field_back(field[<span class="hljs-number"><span class="hljs-number">0</span></span>], A_UNDERLINE);</code> </pre><br><br>  The field is max_len characters long, 1 line high.  We created one field for the form, but you can create as many as you like, for example, if you have a login / password input form.  Then these fields can be used together, for example, to move to a new field when you press a certain key and / or when you fill out a form (for example, if this is a serial number input form). <br>  And also included the option to highlight the input field underscore. <br><br><h6>  Types </h6><br>  Each field can have one or several types, which are defined as follows: <br><pre> <code class="cpp hljs">set_field_type(field[<span class="hljs-number"><span class="hljs-number">0</span></span>],TYPE_ALPHA);</code> </pre><br>  In this case, the filter is turned on for letters, and numbers or other non-alphabetical characters entered by the user will not be displayed.  In the screenshot, an example of such an input field with the TYPE_IPV4 filter enabled.  Unfortunately, he only checks for the presence of numbers and periods, but not the correctness of the address itself.  But even here you can check every key pressed (past filter) and, after checking, decide whether to display it or not or display a warning. <br><br><img src="http://habrastorage.org/storage3/b3a/897/130/b3a8971302a926f6eb1e3ff75a68c509.png"><br><br>  Now we combine our fields <br><br><pre> <code class="cpp hljs">my_form = new_form(field); set_form_sub(my_form, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;overlay); post_form(my_form);</code> </pre><br><br>  And also we print our invitation. <br><pre> <code class="cpp hljs">mvwprintw(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;decoration,<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>, info);</code> </pre><br><br>  Next we need to ensure the work of the form <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> user_key=<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(user_key) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xD</span></span>: form_driver(my_form, REQ_VALIDATION); <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> check; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: form_driver(my_form, user_key); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } touchwin(panel_window(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;panel)); update_panels(); doupdate(); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>((user_key = getch()) != KEY_F(<span class="hljs-number"><span class="hljs-number">12</span></span>));</code> </pre><br><br>  We are waiting in a cycle from the user pressing the key, in case it is not ENTER - we pass the key to the field driver, who already applies the filter and displays it on the screen, if necessary.  If this is the ENTER key, we ask for the field check and exit the loop. <br><br>  Now it‚Äôs easy to get what the user has entered: <br><pre> <code class="cpp hljs">check: <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *result=<span class="hljs-number"><span class="hljs-number">0</span></span>; asprintf(&amp;result, <span class="hljs-string"><span class="hljs-string">"%s"</span></span>, field_buffer(field[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><br><br>  Next, we clean up after ourselves and return the result. <br><br><pre> <code class="cpp hljs">unpost_form(my_form); free_field(field[<span class="hljs-number"><span class="hljs-number">0</span></span>]); free_form(my_form); tui_del_win(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result;</code> </pre><br><br>  Of course, you can set a preliminary value of the input field, which can be used as a prompt or a default value: <br><pre> <code class="cpp hljs">set_field_buffer(field[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>, ¬´Default¬ª);</code> </pre><br>  Well, indeed many other options.  I want to note that the manipulations with the removal / movement of characters or whole words lie on the user.  In the same do-while loop, it is necessary to catch the key presses of the necessary keys and, through form_driver, to make requests for the removal of a mark, the transition by letters or words.  Using forms, you can easily implement a simple text editor, the lion‚Äôs share of working with text in which will fall on the ncurses engine.  After all, even text alignment across fields, deletion of whole words and other joys is supported. <br><br><h5>  Buttons </h5><br><br>  Since ncurses does not provide a ready-made implementation, we will do it ourselves.  The simplest version of the button is a window with a shadow, which is pressed down on its shadow.  In the last post, I told you that in the simplest case, the shadow will fall on the bottom window.  This is due to the fact that in order to draw the same shadow, we must create a layer, and this layer is rectangular.  The unused area of ‚Äã‚Äãit still exists and will occur as in the screenshot below. <br><br><img src="http://habrastorage.org/storage3/166/a65/f67/166a65f67ea3287af1a4adbe0c623611.png"><br><br>  The effect of "transparency" in the default implementation is absent.  But it does not matter, it can be implemented independently.  In most cases, we will draw the button inside the window, so we will assume that we know on which window the button is located. <br>  In the function, we read the text in the underlying window along with its attributes (color, mode).  The ASCII code + attribute occupies one byte and lies in a variable of type chtype (uint8_t).  To display this type there is a special function mvwaddchstr. <br><br><div class="spoiler">  <b class="spoiler_title">Button code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">cursed *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tui_new_button</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WINDOW *bwin, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sy, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *label, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> len)</span></span></span><span class="hljs-function"> </span></span>{ cursed *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> w = len + <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> h = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background = newwin(h, w + <span class="hljs-number"><span class="hljs-number">1</span></span>, sy, sx); wbkgd(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">4</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/* Get start coordinates of underlying window*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> shad_x, shad_y; getbegyx(bwin, shad_y, shad_x); chtype c[len + <span class="hljs-number"><span class="hljs-number">7</span></span>] = {<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-comment"><span class="hljs-comment">/* Extract underlying text and copy it to the button's shadow layer */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; h; i++) { mvwinchnstr(bwin,sy-shad_y + i,sx-shad_x,c, len + <span class="hljs-number"><span class="hljs-number">6</span></span>); mvwaddchstr(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background,i,<span class="hljs-number"><span class="hljs-number">0</span></span>, c); } wattron(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; w - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) mvwaddch(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background, h - <span class="hljs-number"><span class="hljs-number">1</span></span>, i, <span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> i= <span class="hljs-number"><span class="hljs-number">2</span></span>; i &lt; h; i++) mvwprintw(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background, i, w - <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>); wattroff(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;decoration = derwin(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background, h<span class="hljs-number"><span class="hljs-number">-2</span></span>, w<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); wbkgd(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;decoration, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">1</span></span>)); box(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;decoration, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> x, y; getmaxyx(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;decoration, y, x); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;overlay = derwin(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;decoration, y<span class="hljs-number"><span class="hljs-number">-2</span></span>, x<span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); wbkgd(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;overlay, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;panel = new_panel(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;background); wprintw(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>-&gt;overlay, label); update_panels(); doupdate(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>; }</code> </pre><br></div></div><br><br><img src="http://habrastorage.org/storage3/f0c/e1d/699/f0ce1d6994d05a3588e440196047aa1f.png"><br><br>  It remains to make the animation button.  Insofar as <blockquote>  "The subwindow functions (subwin, derwin, mvderwin, wsyncup, wsyncdown, wcursyncup, syncok) are flaky, incompletely implemented, and not well tested", </blockquote>  then I realized the effect of pressing the button through such crutches.  That is, I hide the original button panel, make a duplicate without a shadow, move it diagonally, pause and delete the clone.  Well, of course, again showing the original button. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tui_toggle_button</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cursed *button)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> x, y; getbegyx(button-&gt;background, y, x); hide_panel(button-&gt;panel); WINDOW *dup_dec = dupwin(button-&gt;decoration); PANEL *duppan = new_panel(dup_dec); move_panel(duppan, y + <span class="hljs-number"><span class="hljs-number">2</span></span>, x + <span class="hljs-number"><span class="hljs-number">3</span></span>); update_panels(); doupdate(); usleep(<span class="hljs-number"><span class="hljs-number">200000</span></span>); del_panel(duppan); show_panel(button-&gt;panel); }</code> </pre><br><br><img src="http://habrastorage.org/storage3/396/8fc/39e/3968fc39e4db7ff3466ecdf56e06d12b.gif"><br><br><h5>  The remaining standard interface elements. </h5><br><br>  By combining the form and menu, you can easily make a drop-down list with autosearch.  With the help of a horizontally oriented menu you can make a radiobutton. <br>  The same progress indicator is simply implemented: <br><br><img src="http://habrastorage.org/storage3/c08/615/241/c086152419e37534c429761720c30718.png"><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tui_progress_bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WINDOW *win, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> progress)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> height, width; getmaxyx(win, height, width); wattron(win, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">8</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; width * progress; i++) { mvwaddch(win, (height / <span class="hljs-number"><span class="hljs-number">2</span></span>), i, <span class="hljs-string"><span class="hljs-string">' '</span></span>); } wattroff(win, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">8</span></span>)); wattron(win, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">7</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int32_t</span></span> i = width * progress; i &lt; width; i++) { mvwaddch(win, (height / <span class="hljs-number"><span class="hljs-number">2</span></span>), i, <span class="hljs-string"><span class="hljs-string">' '</span></span>); } wattroff(win, COLOR_PAIR(<span class="hljs-number"><span class="hljs-number">7</span></span>)); wattron(win, A_STANDOUT); mvwprintw(win, (height / <span class="hljs-number"><span class="hljs-number">2</span></span>), (width / <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">"%.0f%%"</span></span>, progress*<span class="hljs-number"><span class="hljs-number">100</span></span>); wattroff(win, A_STANDOUT); }</code> </pre><br><br>  The same programbar can also be used in pure text applications.  As a visual and convenient indicator of progress, although the same can be done purely on printf, but it will not be possible to update something else in other lines. <br><br><h5>  Conclusion </h5><br><br>  Text interface is easy.  Many people write console utilities, in some cases this is the main working tool.  Why not make it clearer and more convenient for perception?  In this screenshot, nothing is used except 3 output functions without windows and panels. <br><img src="http://habrastorage.org/storage3/496/d53/bca/496d53bca5cb05b7e7eb44aaa10f5154.png"><br>  If it is also used for scripts, tui can be turned on / off by key in the launch arguments.  Anyway, if a program cannot use graphics, this does not mean that it should remain incomprehensible.  The same conclusion of the help can be made clearer or even contextual.  The same TAB autocompletions can be implemented and your users will thank you.  A good example here is the xe utility from the Xen Server suite.  After the user has typed a keyword, the program offers options by pressing TAB.  For example, uuid = and immediately the UUID of the machines registered in the system are automatically substituted.  This makes it incredibly easy and quick. <br><br>  PS: If someone wants to try to work with curses, I laid out the simplest example here <br>  <a href="https://github.com/Pugnator/curses_test">github.com/Pugnator/curses_test</a> <br>  Please do not scold for the code - I'm just an amateur. <br>  In the bin directory just run make <br>  If necessary, reinstall: <br>  sudo apt-get install ncurses-dev (for debian based) </div><p>Source: <a href="https://habr.com/ru/post/208582/">https://habr.com/ru/post/208582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208568/index.html">Configuring 6in4 on Zyxel Keenetic routers</a></li>
<li><a href="../208570/index.html">45 Tips Tricks and Javascript Practitioner</a></li>
<li><a href="../208576/index.html">ZTE modular smartphone presented live at CES</a></li>
<li><a href="../208578/index.html">Play Pure Drive - smart tennis racket for everyone</a></li>
<li><a href="../208580/index.html">The use of machine learning in building AI for the game of Japanese chess (shogi)</a></li>
<li><a href="../208586/index.html">Asterisk / FreePBX: Integration of number identifier with customer base</a></li>
<li><a href="../208588/index.html">JetBrains discounts for startups</a></li>
<li><a href="../208590/index.html">‚ÄúFriends‚Äù redis with nginx</a></li>
<li><a href="../208600/index.html">Backbone.Component - standalone UI components for Backbone.js</a></li>
<li><a href="../208604/index.html">What happens if you openly report on the vulnerabilities of government sites</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>