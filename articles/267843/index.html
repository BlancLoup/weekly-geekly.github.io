<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using NSOperation and NSOperationQueue in Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Almost every one of us experienced discomfort when pressing a button or typing in iOS or Mac applications, when the user interface suddenly stopped re...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using NSOperation and NSOperationQueue in Swift</h1><div class="post__text post__text-html js-mediator-article">  Almost every one of us experienced discomfort when pressing a button or typing in <b>iOS</b> or <b>Mac</b> applications, when the user interface suddenly stopped responding, the application seemed to stop and stop responding to your actions. <br><br>  On a <b>Mac</b> , users see an hourglass or rotating rainbow cursor until the user interface again resumes.  Many users mistakenly assume that the application will immediately work when you touch the screen.  Such applications give a feeling of poor performance and seem slow, and, as a rule, receive bad reviews in the <b>AppStore</b> . <br><br>  But ensuring constant user responsiveness is not so easy.  As soon as the application performs many tasks, it starts to slow down.  Not much time is allocated to perform a large number of tasks in the main thread and to ensure responsiveness of the interface. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What should the "unfortunate" developer do?  The solution is, it is to separate the main stream through parallelism.  Parallelism is the property of an application to perform tasks in several threads at the same time - and at the same time, the user interface remains responsive as you do your work in different threads. <br><br>  One of the methods for performing operations in <b>iOS</b> simultaneously is to use the <b>NSOperation</b> and <b>NSOperationQueue classes</b> .  In this article you will learn how to use them!  You will work with an application that does not use multithreading at all, so it will be very slow and will slow down.  When you change the application so that you can add parallel operations and - I hope - this will provide a more responsive user interface! <br><a name="habracut"></a><br>  <b>Let's get started</b> <br><br>  The purpose of this article is to show a table with images to which the filter was applied.  The image will be downloaded from the Internet, to which the filter will be applied, and then displayed in the table. <br><br>  Here is a schematic representation of the application model: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/44c/2f2/41e/44c2f241e6bc9e6384d9897b5a80dd55.png" alt="image"><br><br>  <b>First try</b> <br><br>  <b><b>From the author:</b></b> Since the article was written before <b>09/09/2015</b> , <b>Swift</b> <b>1.2</b> was used to write the examples.  I made some changes to the examples with the release of the new version of the <b>Swift</b> language.  The source code for Swift 2.0 can be found at the links: the <a href="https://github.com/yarmolchuk/ClassicPhotos-Starter">‚Äústarting‚Äù project</a> and the <a href="https://github.com/yarmolchuk/ClassicPhotos-Final">‚Äúfinal‚Äù version of the project</a> . <br><br>  <a href="">Download the ‚Äústarter‚Äù project on Swift 1.2</a> and <a href="https://github.com/yarmolchuk/ClassicPhotos-Starter">Swift 2.0</a> , which you will be working on as you read this manual. <br><br>  <b>Note:</b> <i>All images are taken from <a href="http://sxc.hu/">stock.xchng</a> . Since there are cases when the image cannot be loaded, to perform this failed attempt, some images in the data source are intentionally incorrectly named.</i> <br><br>  Compile and run the application, and (eventually) you will see that the application displays a list of photos.  Try scrolling through the list.  Annoying, isn't it? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/749/7ce/564/7497ce56404759bf96f6765c00b0fc92.png" alt="image"><br><br>  All the action takes place in the <b>ListViewController.swift</b> file, and most of the actions are inside the delegate method of the <b>tableView (_: cellForRowAtIndexPath :)</b> . <br><br>  Take a look at this method and notice the two ongoing actions, which are quite voluminous: <br><br><ol><li>  Download images from the network.  Even if this is a simple job, the application must wait for the download to complete before it can continue to perform another operation. </li><li>  Apply a filter to an image using Core Image.  This method applies a sepia filter to the image.  If you want to learn more about <b>Core Image filters</b> , read <b>Beginning Core Image in Swift</b> . </li></ol><br><br>  In addition, you also upload a list of photos from the network, with the first request: <br><br><pre><code class="objectivec hljs">lazy var photos = <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>(contentsOfURL:dataSourceURL)</code> </pre> <br>  All this work is happening in the main flow of the application.  Since the main thread is also responsible for user interaction, loading and applying a filter to images reduces the ability to respond quickly to user actions.  You can verify this by using the indicators tab in the <b>Xcode</b> development <b>environment</b> .  You can get to this tab by clicking on the <b>Debug navigator</b> (Command-6) and then selecting the CPU during the execution of the application. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/536/aac/0ee/536aac0ee6caf961685b40f74a0eab84.png" alt="image"><br><br>  You will see all these peaks in the first thread, which is the main flow of the application.  For more information, launch the application using <b>Tools</b> , but that‚Äôs another story. <br><br>  It's time to think about how to improve your user experience!  And make the app more responsive. <br><br>  <b>Tasks, Threads and Processes</b> <br><br>  Before you dive into the article, there are several technical concepts that need to be considered.  I will define several terms: <br><br><ul><li>  <b>Task / Task: a</b> simple unit that needs to be executed. </li><li>  <b>Thread / Thread: a</b> mechanism created by the operating system, where several commands are executed simultaneously in a single application. </li><li>  <b>Process / Process:</b> an executable code fragment that can consist of several threads. </li></ul><br><br>  <b>Note:</b> <i>On <b>iOS</b> and <b>OS X</b> , multithreading functionality is provided by the <i>POSIX Threads API</i> and is part of the operating system.</i>  <i>This is a fairly low level job, and you will understand how easy it is to make mistakes;</i>  <i>Perhaps the worst in using streams are errors that are incredibly difficult to find!</i> <br><br>  <i><b>The Foundation framework</b> contains a class called <b>NSThread</b> , which is much easier to work with, but managing multiple threads with <b>NSThread</b> still causes difficulties.</i>  <i><b>NSOperation</b> and <b>NSOperationQueue are</b> high-level classes that greatly simplify the process of working with multiple threads.</i> <br><br>  In this diagram, you see the relationship between the process, the threads, and the tasks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fba/ef8/fd2/fbaef8fd2bebd0e08ca22a62764b837f.png" alt="image"><br><br>  As you can see, a process can contain several threads, and each thread can perform several tasks in turn. <br><br>  In this scheme, the second thread performs file reads, while the first thread executes code associated with the user interface.  This is very similar to how you should structure your code in <b>iOS</b> ‚Äî the main thread must do any work related to the user interface, and the secondary threads must perform slow or lengthy operations, such as reading files, accessing the network, etc. . <br><br>  <b>NSOperation vs. Grand Central Dispatch (GCD)</b> <br><br>  You may have heard of the <b>Grand Central Dispatch (GCD)</b> .  In general, <b>GCD</b> consists of language features, <b>runtime libraries</b> and system extensions, which in turn provides system-wide improvements to maintain concurrency on multi-core mobile devices on <b>iOS</b> and <b>OS X.</b>  If you want to know more about <b>GCD</b> , you can read the <a href="http://www.raywenderlich.com/%3Fp%3D4295">Multithreading and Grand Central Dispatch on iOS for Beginners Tutorial</a> . <br><br>  <b>NSOperation</b> and <b>NSOperationQueue</b> built on top of <b>GCD</b> .  It is worth noting that <b>Apple</b> recommends using a higher level abstraction, and then going down to the lower levels when the measurements indicate that they are necessary. <br><br>  Here is a brief comparison that will help you decide when and where to use <b>GCD</b> or <b>NSOperation</b> : <br><ul><li>  <b>GCD</b> is a lightweight way of representing the units of work that will be performed simultaneously.  It is not necessary to list these units of work;  the system will take care of this for you.  Adding dependencies among blocks may not be an easy task.  Canceling or pausing a block creates additional work for you as a developer! </li><li>  <b>NSOperation</b> adds little extra cost compared to <b>GCD</b> , but you can add dependencies for various operations, reuse, cancel, or suspend them. </li></ul><br><br>  In this tutorial, we will use the <b>NSOperation</b> class, because you are dealing with a table view and because of performance and power consumption, you need to cancel the operation for a particular image if the user has scrolled the image off the screen.  Even if the operations will be in the background thread, if dozens of such operations will wait for their turn to perform, the performance will still not be at the level we need. <br><br>  <b>Modification of the application model</b> <br><br>  It's time to change the application-specific model without a multithreading!  If you look more closely at the preliminary model, you will see that there are three problematic areas that can be improved.  Sharing these three areas and putting them into a separate thread, the main thread will be released, and will be able to respond quickly to user interaction with the <b>UI</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/085/85f/21c/08585f21c1a2ff9f224795a8c7ddaab3.png" alt="image"><br><br>  To get rid of bottlenecks in the application, you will need a stream that will respond to user interaction with the UI, another stream that will be used to load images and another stream to apply the filter to the image.  In the new model, the application starts in the main thread and loads an empty table view.  At the same time, the application starts a second stream to load data. <br><br>  As soon as the data is loaded, you need to update the table.  This should be done in the main thread, as it includes the user interface.  At this stage, the table view knows how many cells it has, and which image URLs should be displayed on the screen, but it still has no actual images!  If you immediately start downloading all the images at once, it will be completely ineffective, since you do not need all the images at once! <br><br>  <b>What can be done to improve?</b> <br><br>  The enhanced model will begin loading images that correspond to the cells displayed on the screen.  In this way, your code will first know which cells are visible, and only then will the download process begin.  Also, the process of applying a filter to an image cannot be started before the image is fully loaded.  Therefore, the code that is responsible for applying the filter should not run until there is an image to process. <br><br>  For better responsiveness of the application, we must display the image as soon as it is loaded.  Then we will start working with the images, and then update the interface to display the processed image.  The diagram below shows the flow of control for this process: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/626/740/68f/62674068fd9ef115590e8bb7340af4c0.png" alt="image"><br><br>  To achieve these goals, you will need to track whether the image is currently being loaded, or already loaded, or whether a filter has been applied to the image.  You will also need to track the status of each operation, and whether it is loading or processing an image so that you can cancel, pause or resume it. <br><br>  Good!  Now you can proceed to the most interesting, the implementation of our scheme! <br><br>  Open the project and add a new <b>Swift File</b> to the project named <b>PhotoOperations.swift</b> .  Then add the following code to it: <br><br><pre> <code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> <span class="hljs-comment"><span class="hljs-comment">// This enum contains all the possible states a photo record can be in enum PhotoRecordState { case New, Downloaded, Filtered, Failed } class PhotoRecord { let name:String let url:NSURL var state = PhotoRecordState.New var image = UIImage(named: "Placeholder") init(name:String, url:NSURL) { self.name = name self.url = url } }</span></span></code> </pre><br>  <b>Note:</b> <i>Be sure to import <b>UIKit</b> to the top of the file.</i>  <i>By default, <b>Xcode</b> imports only <b>Foundation</b> in <b>Swift</b> .</i> <br><br>  This class will represent each photo displayed in the application, along with its current state, which is set by default as <b>.New</b> for newly created records.  The default image is a picture called <b>"Placeholder"</b> . <br><br>  To track the status of each operation, you will need a separate class.  Add the following implementation to the end of <b>PhotoOperations.swift:</b> <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> PendingOperations { lazy var downloadsInProgress = [<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">NSOperation</span></span>]() lazy var downloadQueue:<span class="hljs-built_in"><span class="hljs-built_in">NSOperationQueue</span></span> = { var queue = <span class="hljs-built_in"><span class="hljs-built_in">NSOperationQueue</span></span>() queue.name = <span class="hljs-string"><span class="hljs-string">"Download queue"</span></span> queue.maxConcurrentOperationCount = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue }() lazy var filtrationsInProgress = [<span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">NSOperation</span></span>]() lazy var filtrationQueue:<span class="hljs-built_in"><span class="hljs-built_in">NSOperationQueue</span></span> = { var queue = <span class="hljs-built_in"><span class="hljs-built_in">NSOperationQueue</span></span>() queue.name = <span class="hljs-string"><span class="hljs-string">"Image Filtration queue"</span></span> queue.maxConcurrentOperationCount = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> queue }() }</code> </pre><br>  This class contains two dictionaries to track active and incomplete loading of images and filtering operations for each cell in the table and two operation queues for each type of operation. <br><br>  All values ‚Äã‚Äãare created slowly, that is, they cannot be initialized until they have access.  This will improve the performance of your application. <br><br>  Creating an <b>NSOperationQueue</b> class <b>is</b> very simple.  Naming your queues makes them easy to find in the <b>Tools</b> or in the debugger.  <b>MaxConcurrentOperationCount is</b> set to <b>1</b> , but only for this article, so you can see that operations are completed one after another.  You can skip this part to let the queue decide how many operations it can process right away - this will further increase performance. <br><br>  How does the queue decide how many operations it can run at the same time?  This is a good question!  It depends on the hardware.  By default, <b>NSOperationQueue</b> does some computation behind the scenes to decide which is best for the particular platform on which the code is being executed and to run as many threads as possible. <br><br>  Consider the following example.  Suppose the system is inactive, and there are many resources available, so the queue can run approximately eight simultaneous threads.  The next time you start the application, the system may be busy with other operations that use resources, and the queue will start only two simultaneous threads.  Since you have set the maximum parallel number of operations, only one operation will be performed in this application. <br><br>  <b>Note:</b> <i>You may wonder why you should keep track of all active and incomplete operations.</i>  <i>The queue has a operations method that returns an array of operations, so why not use it?</i>  <i>In this project, it does not make sense to use it. You have to track with which operations the associated table cells, which include the process of iterating over an array, every time you need it.</i>  <i>Storing them in a dictionary with an index as the main search tool is a quick and effective way.</i> <br><br>  It's time to take care of the operations of applying the filter to the image and loading the image itself.  Add the following code to the end of <b>PhotoOperations.swift</b> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ImageDownloader: <span class="hljs-built_in"><span class="hljs-built_in">NSOperation</span></span> { <span class="hljs-comment"><span class="hljs-comment">//1 let photoRecord: PhotoRecord //2 init(photoRecord: PhotoRecord) { self.photoRecord = photoRecord } //3 override func main() { //4 if self.cancelled { return } //5 let imageData = NSData(contentsOfURL:self.photoRecord.url) //6 if self.cancelled { return } //7 if imageData?.length &gt; 0 { self.photoRecord.image = UIImage(data:imageData!) self.photoRecord.state = .Downloaded } else { self.photoRecord.state = .Failed self.photoRecord.image = UIImage(named: "Failed") } } }</span></span></code> </pre><br>  <b>NSOperation</b> is an abstract class designed to create a derived class.  Each derived class represents a specific task, as shown in the figure above. <br><br>  Here is what happens in each of the numbered comments in the code: <br><ol><li>  Add a permalink to the operation-related <b>PhotoRecord</b> object. </li><li>  Create a specified initializer that allows you to transfer photo recordings. </li><li>  main is a method that you override in <b>NSOperation</b> derived classes to do work.  You are making an autorelease pool since you are working outside the pool created by the main thread. </li><li>  Check for cancellation before launch.  Operations should regularly check to see if they have been canceled before long and intensive work. </li><li>  Upload an image. </li><li>  Check for cancellation. </li><li>  If there is data, create an image object, and add it to the record and move the state forward.  If there is no data, mark the entry as failed and set the appropriate image. </li></ol><br><br>  Next, you will create another operation to monitor the application of the filter!  Add the following code to the end of <b>PhotoOperations.swift</b> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> ImageFiltration: <span class="hljs-built_in"><span class="hljs-built_in">NSOperation</span></span> { let photoRecord: PhotoRecord init(photoRecord: PhotoRecord) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.photoRecord = photoRecord } override func main () { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cancelled { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.photoRecord.state != .Downloaded { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let filteredImage = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.applySepiaFilter(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.photoRecord.image!) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.photoRecord.image = filteredImage <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.photoRecord.state = .Filtered } } }</code> </pre><br>  It looks like a load operation, except for applying a filter to an image <b>(using a still unimplemented method, hence the compiler error)</b> instead of loading it. <br><br>  Add the missing <b>ImageFiltration</b> method that will process the image in the class: <br><br><pre> <code class="objectivec hljs"> func applySepiaFilter(image:<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>? { let inputImage = <span class="hljs-built_in"><span class="hljs-built_in">CIImage</span></span>(data:<span class="hljs-built_in"><span class="hljs-built_in">UIImagePNGRepresentation</span></span>(image)!) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cancelled { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } let context = <span class="hljs-built_in"><span class="hljs-built_in">CIContext</span></span>(options:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) let filter = <span class="hljs-built_in"><span class="hljs-built_in">CIFilter</span></span>(name:<span class="hljs-string"><span class="hljs-string">"CISepiaTone"</span></span>) filter!.setValue(inputImage, forKey: kCIInputImageKey) filter!.setValue(<span class="hljs-number"><span class="hljs-number">0.8</span></span>, forKey: <span class="hljs-string"><span class="hljs-string">"inputIntensity"</span></span>) let outputImage = filter!.outputImage <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cancelled { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } let outImage = context.createCGImage(outputImage!, fromRect: outputImage!.extent) let returnImage = <span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">CGImage</span></span>: outImage) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnImage }</code> </pre><br>  Image processing is the same implementation that we used earlier in the <b>ListViewController</b> .  She was moved here so that she could be used as a separate operation in the background.  Again, you should check for cancellation often;  over time, you will do this on an automaton before and after any method call.  After the end of the action, you set the values ‚Äã‚Äãof the photo instance. <br><br>  <b>Fine!</b>  Now you have all the tools and the basics that you need in order to perform operations as background tasks.  It's time to go back to the view controller and change it to take advantage of all these new benefits. <br><br>  Go to the <b>ListViewController and</b> remove the <b>lazy var photos</b> property declarations.  Then add the following declarations instead: <br><br><pre> <code class="objectivec hljs">var photos = [PhotoRecord]() let pendingOperations = PendingOperations()</code> </pre><br>  They will contain an array of <b>PhotoDetails</b> objects that you created earlier, and a <b>PendingOperations</b> object for managing operations. <br><br>  Add a new method to the class to upload a list of photos: <br><br><pre> <code class="objectivec hljs">func fetchPhotoDetails() { let request = <span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span>(URL:dataSourceURL!) <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>.sharedApplication().networkActivityIndicatorVisible = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>.sendAsynchronousRequest(request, queue: <span class="hljs-built_in"><span class="hljs-built_in">NSOperationQueue</span></span>.mainQueue()) {response,data,error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { let datasourceDictionary = (try! <span class="hljs-built_in"><span class="hljs-built_in">NSPropertyListSerialization</span></span>.propertyListWithData(data!, options:<span class="hljs-built_in"><span class="hljs-built_in">NSPropertyListMutabilityOptions</span></span>.MutableContainersAndLeaves, format: <span class="hljs-literal"><span class="hljs-literal">nil</span></span>)) as! <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(key, value) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> datasourceDictionary { let name = key as? String let url = <span class="hljs-built_in"><span class="hljs-built_in">NSURL</span></span>(string:value as? String ?? <span class="hljs-string"><span class="hljs-string">""</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> name != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> &amp;&amp; url != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { let photoRecord = PhotoRecord(name:name!, url:url!) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.photos.append(photoRecord) } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.tableView.reloadData() } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> error != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { let alert = <span class="hljs-built_in"><span class="hljs-built_in">UIAlertView</span></span>(title:<span class="hljs-string"><span class="hljs-string">"Oops!"</span></span>,message:error!.localizedDescription, delegate:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>, cancelButtonTitle:<span class="hljs-string"><span class="hljs-string">"OK"</span></span>) alert.show() } <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>.sharedApplication().networkActivityIndicatorVisible = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre><br>     , ,  ,      .   ,     <b>NSDictionary</b>         <b>PhotoRecord</b> .    <b>NSOperation</b> ,         ,  <b>NSOperationQueue.mainQueue()</b> . <br><br>      <b>viewDidLoad</b> : <br><br><pre> <code class="objectivec hljs">fetchPhotoDetails ()</code> </pre><br> ,   <b>tableView(_:cellForRowAtIndexPath:)</b>    : <br><br><pre> <code class="objectivec hljs">override func tableView(tableView: <span class="hljs-built_in"><span class="hljs-built_in">UITableView</span></span>, cellForRowAtIndexPath indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">UITableViewCell</span></span> { let cell = tableView.dequeueReusableCellWithIdentifier(<span class="hljs-string"><span class="hljs-string">"CellIdentifier"</span></span>, forIndexPath: indexPath) <span class="hljs-comment"><span class="hljs-comment">//1 if cell.accessoryView == nil { let indicator = UIActivityIndicatorView(activityIndicatorStyle: .Gray) cell.accessoryView = indicator } let indicator = cell.accessoryView as! UIActivityIndicatorView //2 let photoDetails = photos[indexPath.row] //3 cell.textLabel?.text = photoDetails.name cell.imageView?.image = photoDetails.image //4 switch (photoDetails.state){ case .Filtered: indicator.stopAnimating() case .Failed: indicator.stopAnimating() cell.textLabel?.text = "Failed to load" case .New, .Downloaded: indicator.startAnimating() if (!tableView.dragging &amp;&amp; !tableView.decelerating) { self.startOperationsForPhotoRecord(photoDetails, indexPath: indexPath) } } return cell }</span></span></code> </pre><br>        : <br><br><ol><li>     ,  <b>UIActivityIndicatorView</b>        . </li><li>     <b>PhotoRecord</b> .   ,     indexPath. </li><li>    ‚Äî ()  ,      <b>PhotoRecord</b> ,   ,  ,      ,    . </li><li>  .        ,    (  ). </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can delete the implementation of the </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">applySepiaFilter</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> method </font><font style="vertical-align: inherit;">, since it will not need to be called again. Add the following method to the class to start operations:</font></font><br><br><pre> <code class="objectivec hljs">func startOperationsForPhotoRecord(photoDetails: PhotoRecord, indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (photoDetails.state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .New: startDownloadForRecord(photoDetails, indexPath: indexPath) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .Downloaded: startFiltrationForRecord(photoDetails, indexPath: indexPath) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">"do nothing"</span></span>) } }</code> </pre><br> ,    <b>PhotoRecord</b>   .              . <br><br> <b>:</b> <i>        ,     ,       ,     ,     ‚Äã‚Äã  .     ,       ,      ;       !  !</i> <br><br>     ,      . ,     , <b>PendingOperations</b> ,   ;    !     : <br><br><pre> <code class="objectivec hljs">func startDownloadForRecord(photoDetails: PhotoRecord, indexPath: <span class="hljs-built_in"><span class="hljs-built_in">NSIndexPath</span></span>){ <span class="hljs-comment"><span class="hljs-comment">//1 if let _ = pendingOperations.downloadsInProgress[indexPath] { return } //2 let downloader = ImageDownloader(photoRecord: photoDetails) //3 downloader.completionBlock = { if downloader.cancelled { return } dispatch_async(dispatch_get_main_queue(), { self.pendingOperations.downloadsInProgress.removeValueForKey(indexPath) self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) }) } //4 pendingOperations.downloadsInProgress[indexPath] = downloader //5 pendingOperations.downloadQueue.addOperation(downloader) } func startFiltrationForRecord(photoDetails: PhotoRecord, indexPath: NSIndexPath){ if let _ = pendingOperations.filtrationsInProgress[indexPath]{ return } let filterer = ImageFiltration(photoRecord: photoDetails) filterer.completionBlock = { if filterer.cancelled { return } dispatch_async(dispatch_get_main_queue(), { self.pendingOperations.filtrationsInProgress.removeValueForKey(indexPath) self.tableView.reloadRowsAtIndexPaths([indexPath], withRowAnimation: .Fade) }) } pendingOperations.filtrationsInProgress[indexPath] = filterer pendingOperations.filtrationQueue.addOperation(filterer) }</span></span></code> </pre><br>  Good!   ,  ,   ,         : <br><ol><li>  ,     <b>indexPath</b>  ,      <b>downloadsInProgress</b>  .   ,  . </li><li>  ,   <b>ImageDownloader</b> ,   . </li><li>   ,   ,    .  ‚Äî  ,     .  ,    ,    ,  ,        .     ,      ,  ,    <b>GCD</b> ,        . </li><li>    <b>downloadsInProgress</b> ,   . </li><li>     .  ,    ‚Äì    ,     . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The method of applying a filter to images occurs in the same way, except for using </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ImageFiltration</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filtrationsInProgress</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to track the operation. As an exercise, you can try to get rid of code duplication in this section.</font></font><br><br>  <b>Congratulations!</b>   .    ,       !   ,     ,         ,     ,   . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e50/863/188/e50863188a8d6a4b4a60309394177e7f.png" alt="image"><br><br>    ?         ‚Äì      ! <br><br> <b> </b> <br><br>       !               .       ,     .      ,   ! <br><br> , , ,    ,              .    ,            ,     .  ,             ,     . <br><br>              ? ,    ‚Äî     ! <br><br>   <b>Xcode</b>    <b>ListViewController</b> .     <b>tableView(_:cellForRowAtIndexPath:)</b> ,     <b>startOperationsForPhotoRecord</b>      : <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!tableView.dragging &amp;&amp; !tableView.decelerating) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.startOperationsForPhotoRecord(photoDetails, indexPath: indexPath) }</code> </pre><br>     ,     .   ,    <b>UIScrollView</b> ,     <b>UITableView</b>   <b>UIScrollView</b> ,     . <br><br>       <b>UIScrollView</b>  : <br><br><pre> <code class="objectivec hljs">override func scrollViewWillBeginDragging(scrollView: <span class="hljs-built_in"><span class="hljs-built_in">UIScrollView</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//1 suspendAllOperations() } override func scrollViewDidEndDragging(scrollView: UIScrollView, willDecelerate decelerate: Bool) { // 2 if !decelerate { loadImagesForOnscreenCells() resumeAllOperations() } } override func scrollViewDidEndDecelerating(scrollView: UIScrollView) { // 3 loadImagesForOnscreenCells() resumeAllOperations() }</span></span></code> </pre><br>       : <br><br><ol><li>     ,         ,    .   suspendAllOperations  . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the slowdown value is false, it means that the user has stopped dragging the table view. </font><font style="vertical-align: inherit;">Therefore, you need to resume paused operations, cancel operations for off-screen cells, and start operations for screen cells. </font><font style="vertical-align: inherit;">You will implement loadImagesForOnscreenCells and resumeAllOperations after a while as well.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This delegate method will tell you that the table view has stopped scrolling, so you need to follow point # 2 again. </font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now add the implementation of these missing methods to ListViewController.swift: </font></font><br><br><pre> <code class="objectivec hljs">func suspendAllOperations () { pendingOperations.downloadQueue.suspended = <span class="hljs-literal"><span class="hljs-literal">true</span></span> pendingOperations.filtrationQueue.suspended = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } func resumeAllOperations () { pendingOperations.downloadQueue.suspended = <span class="hljs-literal"><span class="hljs-literal">false</span></span> pendingOperations.filtrationQueue.suspended = <span class="hljs-literal"><span class="hljs-literal">false</span></span> } func loadImagesForOnscreenCells () { <span class="hljs-comment"><span class="hljs-comment">//1 if let pathsArray = tableView.indexPathsForVisibleRows { //2 var allPendingOperations = Set(pendingOperations.downloadsInProgress.keys) allPendingOperations.unionInPlace(pendingOperations.filtrationsInProgress.keys) //3 var toBeCancelled = allPendingOperations let visiblePaths = Set(pathsArray) toBeCancelled.subtractInPlace(visiblePaths) //4 var toBeStarted = visiblePaths toBeStarted.subtractInPlace(allPendingOperations) // 5 for indexPath in toBeCancelled { if let pendingDownload = pendingOperations.downloadsInProgress[indexPath] { pendingDownload.cancel() } pendingOperations.downloadsInProgress.removeValueForKey(indexPath) if let pendingFiltration = pendingOperations.filtrationsInProgress[indexPath] { pendingFiltration.cancel() } pendingOperations.filtrationsInProgress.removeValueForKey(indexPath) } // 6 for indexPath in toBeStarted { let indexPath = indexPath as NSIndexPath let recordToProcess = self.photos[indexPath.row] startOperationsForPhotoRecord(recordToProcess, indexPath: indexPath) } } }</span></span></code> </pre><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suspendAllOperations</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resumeAllOperations</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> have the simplest implementation. </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSOperationQueues</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> can be suspended by setting the property </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">suspended</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> to </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">true</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">It will suspend all operations in the queue, and you will not be able to suspend operations individually. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">loadImagesForOnscreenCells is a</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bit more complex. </font><font style="vertical-align: inherit;">Here is what happens:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Start with an array containing the index paths of all the visible rows currently in the table view. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Create a series of all pending operations by combining all downloads + all filters. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create a series of all index paths with operations that will be undone. </font><font style="vertical-align: inherit;">Start with all operations, and then delete the index paths of the visible rows. </font><font style="vertical-align: inherit;">This will leave a set of operations involving off-screen strings.</font></font></li><li>    ,     .       ,    ,      </li><li>      ,   ,  ,      PendingOperations. </li><li>      ,   ,   startOperationsForPhotoRecord    . </li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile and run the application, and you should be even more responsive and better at managing the resources of the application! </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/919/31f/ae2/91931fae2393801c2146357c5cd620bc.png" alt="image"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that when you finish scrolling the table, the images on the visible cells are immediately processed. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what's next? </font></font></b> <br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is the ‚Äúfinal‚Äù version of the Swift 1.2 project.</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> b and </font></font><a href="https://github.com/yarmolchuk/ClassicPhotos-Final"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Swift 2.0.</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you completed this project and took the time to really understand it, then congratulations! You can consider yourself a much more valuable </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">iOS</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> developer than you were at the beginning of this article! Most companies that specialize in hardware design can be proud if they have one or two people who really know about it.</font></font><br><br>   ,          ,      .        ,     ,     ,       ( ) .   ,    <b></b> (   ),  ,     . <br><br>    ,     ,  .           .    ,  ,    ,  .  For example: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// MyDownloadOperation is a subclass of NSOperation let downloadOperation = MyDownloadOperation() // MyFilterOperation is a subclass of NSOperation let filterOperation = MyFilterOperation() filterOperation.addDependency(downloadOperation)</span></span></code> </pre><br>   : <br><br><pre> <code class="objectivec hljs">filterOperation.removeDependency(downloadOperation)</code> </pre><br>            ?         . <b> ,       ,   ,    ,  ,      .</b>      . </div><p>Source: <a href="https://habr.com/ru/post/267843/">https://habr.com/ru/post/267843/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267831/index.html">About the features of geolocation technology in MDK</a></li>
<li><a href="../267833/index.html">Audit of system events in Linux</a></li>
<li><a href="../267837/index.html">Todoist transition to Material Design</a></li>
<li><a href="../267839/index.html">Ready assembly of the news portal NewsModxBox</a></li>
<li><a href="../267841/index.html">Deploying your own OpenVPN</a></li>
<li><a href="../267845/index.html">Automation of development in ZeptoLab</a></li>
<li><a href="../267847/index.html">How do we do without 1C?</a></li>
<li><a href="../267849/index.html">September 29, we invite you to view AzureCon and meet with experts at Microsoft Technology Center</a></li>
<li><a href="../267851/index.html">Transparent Squid with HTTPS filtering resources without certificate substitution (x86)</a></li>
<li><a href="../267853/index.html">AMD and Hyper-Threading</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>