<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overview of authentication methods and protocols in web applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I will talk about the use of various authentication methods for web applications, including password authentication, certificate authentication, one-t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overview of authentication methods and protocols in web applications</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/682/c4b/c7b/682c4bc7b2d44e24a77ed3c9678b1946.png"><br><br>  I will talk about the use of various authentication methods for web applications, including password authentication, certificate authentication, one-time password authentication, access keys and tokens.  I will address single sign-on technology (Single Sign-On), consider various standards and authentication protocols. <br><br>  Before moving on to the technical details, let's refresh the terminology a little. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  <b>Identification</b> is a statement about who you are.  Depending on the situation, it can be a name, email address, account number, and so on. </li><li>  <b>Authentication</b> is the provision of evidence that you actually are the one who identified you (from the word ‚Äúauthentic‚Äù - true, authentic). </li><li>  <b>Authorization</b> - check that you are allowed access to the requested resource. </li></ul><br><br>  For example, when you try to get to a private club, you are <i>identified</i> (asked for your first and last name), <i>authenticated</i> (asked to show your passport and checked on a photo) and <i>authorized</i> (check that the last name is in the guest list) before being allowed inside. <br><br>  Similarly, these terms are used in computer systems, where traditionally, <i>identification</i> means getting your account (identity) by username or email;  under <i>authentication</i> ‚Äî verification that you know the password for this account, and under <i>authorization</i> ‚Äî verification of your role in the system and the decision to grant access to the requested page or resource. <br><br>  However, in modern systems there are more complex authentication and authorization schemes, which I will discuss below.  But let's start with a simple and understandable. <br><a name="habracut"></a><br><h5>  <b>Password authentication</b> </h5><br>  This method is based on the fact that the user must provide username and password for successful identification and authentication in the system.  The username / password pair is set by the user upon his registration in the system, while the username may be the user's email address. <br><br>  For web applications, there are several standard password authentication protocols that we will discuss below. <br><br><h6>  <b>HTTP authentication</b> </h6><br>  This protocol, described in HTTP 1.0 / 1.1 standards, has existed for a long time and is still actively used in corporate environments.  Applies to websites works as follows: <br><br><ol><li>  The server, when an unauthorized client accesses a protected resource, sends the HTTP status ‚Äú401 Unauthorized‚Äù and adds the ‚ÄúWWW-Authenticate‚Äù header indicating the scheme and authentication parameters. </li><li>  The browser, upon receipt of such a response, <u>automatically</u> displays the input dialog username and password.  The user enters his account details. </li><li>  In all subsequent requests to this website, the browser automatically adds the HTTP header ‚ÄúAuthorization‚Äù, in which the user data is transmitted for authentication by the server. </li><li>  The server authenticates the user based on this header.  The decision to grant access (authorization) is made separately on the basis of the user's role, ACL or other account data. </li></ol><br><br>  The whole process is standardized and well supported by all browsers and web servers.  There are several authentication schemes that differ in security level: <br><br><ol><li>  <b>Basic</b> is the simplest scheme in which the username and password of a user are transmitted in the Authorization header in an unencrypted form (base64-encoded).  However, using the HTTPS (HTTP over SSL) protocol is relatively secure. <br><img width="50%" height="50%" src="https://habrastorage.org/files/c27/ac0/637/c27ac06373984352a1ebe2f6424cd9e9.png"><br>  <i>An example of HTTP authentication using the Basic scheme.</i> <br><br></li><li>  <b>Digest</b> is a challenge-response scheme in which the server sends a unique nonce value, and the browser transmits the MD5 hash of the user's password, calculated using the specified nonce.  A safer alternative to the Basic scheme for unprotected connections, but is subject to man-in-the-middle attacks (with the replacement of the scheme on the basic).  In addition, the use of this scheme does not allow using modern hash functions for storing user passwords on the server. </li><li>  <b>NTLM</b> (known as Windows authentication) is also based on a challenge-response approach, in which the password is not transmitted in its pure form.  This scheme is not an HTTP standard, but is supported by most browsers and web servers.  It is mainly used to authenticate Windows Active Directory users in web applications.  Vulnerable to pass-the-hash attacks. </li><li>  <b>Negotiate</b> is another Windows authentication scheme that allows the client to choose between NTLM and Kerberos authentication.  Kerberos is a more secure protocol based on the principle of Single Sign-On.  However, it can function only if the client and the server are in the intranet zone and are part of the Windows domain. </li></ol><br>  It is worth noting that when using HTTP authentication, the user does not have the standard opportunity to exit the web application, except to close all browser windows. <br><br><h6>  <b>Forms authentication</b> </h6><br>  There is no specific standard for this protocol, so all its implementations are specific for specific systems, and more specifically, for authentication modules of development frameworks. <br><br>  It works according to the following principle: an HTML form is included in the web application, in which the user must enter his username / password and send them to the server via HTTP POST for authentication.  If successful, the web application creates a session token, which is usually placed in browser cookies.  In subsequent web requests, the <i>session token is</i> automatically transmitted to the server and allows the application to obtain information about the current user to authorize the request. <br><br><img width="50%" height="50%" src="https://habrastorage.org/files/8e5/211/8bb/8e52118bbaa84a4286e2ef2a2a5ad36d.png"><br>  <i>Example forms authentication.</i> <br><br>  An application can create a session token in two ways: <br><br><ol><li>  As an identifier for an authenticated user session stored in server memory or in a database.  The session should contain all the necessary information about the user to authorize his requests. </li><li>  As an encrypted and / or signed object containing data about the user, as well as a validity period.  This approach allows the stateless architecture of the server to be implemented, however, it requires a mechanism for updating the session token after the expiration date.  Several standard formats for such tokens are discussed in the ‚ÄúToken authentication‚Äù section. </li></ol><br>  It should be understood that intercepting session token often provides a similar level of access as knowledge of username / password.  Therefore, all communications between the client and the server in the case of forms authentication should be made only over a secure HTTPS connection. <br><br><h6>  <b>Other password authentication protocols</b> </h6><br>  The two protocols described above are successfully used to authenticate users on websites.  But when developing client-server applications using web services (for example, iOS or Android), along with HTTP authentication, non-standard protocols are often used in which data for authentication is transmitted in other parts of the request. <br><br>  There are only a few places where you can pass username and password in HTTP requests: <br><br><ol><li>  <b>URL query</b> - is considered an insecure option, since URL strings can be remembered by browsers, proxies, and web servers. </li><li>  <b>Request body</b> is a safe option, but it is applicable only to requests containing the message body (such as POST, PUT, PATCH). </li><li>  <b>HTTP header is the</b> optimal variant, while the standard Authorization header can be used (for example, with the Basic schema), and other arbitrary headers. </li></ol><br><br><h6>  <b>Common vulnerabilities and implementation errors</b> </h6><br>  Password authentication is considered not a very reliable way, since passwords can often be picked up, and users tend to use simple and identical passwords in different systems, or write them on pieces of paper.  If the attacker was able to figure out the password, the user often does not know about it.  In addition, application developers can make a number of conceptual errors that simplify hacking accounts. <br><br>  Below is a list of the most common vulnerabilities when password authentication is used: <br><br><ul><li>  The web application allows users to create simple passwords. </li><li>  The web application is not protected from the possibility of brute-force attacks. </li><li>  The web application itself generates and distributes passwords to users, but does not require changing the password after the first login (i.e., the current password has been recorded somewhere). </li><li>  The web application allows the transmission of passwords over an unprotected HTTP connection or in the URL string. </li><li>  The web application does not use secure hash functions to store user passwords. </li><li>  The web application does not provide users with the ability to change the password or does not notify users about changing their passwords. </li><li>  The web application uses a vulnerable password recovery feature that can be used to gain unauthorized access to other accounts. </li><li>  The web application does not require re-authentication of the user for important actions: changing the password, changing the delivery address of goods, etc. </li><li>  The web application creates session tokens in such a way that they can be matched or predicted for other users. </li><li>  The web application allows the transmission of session tokens over an unprotected HTTP connection, or in the URL string. </li><li>  The web application is vulnerable to session fixation attacks (that is, it does not replace the session token when the anonymous session of the user is authenticated). </li><li>  The web application does not set the HttpOnly and Secure flags for browser cookies containing session tokens. </li><li>  The web application does not destroy the user's session after a short period of inactivity or does not provide a function to exit the authenticated session. </li></ul><br><br><h5>  <b>Certificate Authentication</b> </h5><br>  A certificate is a set of attributes that identify the owner, signed by <i>certificate authority</i> (CA).  CA acts as an intermediary who guarantees the authenticity of certificates (by analogy with the FMS, which issues passports).  Also, the certificate is cryptographically linked to the private key, which is stored with the certificate holder and allows you to unequivocally confirm the fact of ownership of the certificate. <br><br>  On the client side, the certificate along with the private key can be stored in the operating system, in the browser, in a file, on a separate physical device (smart card, USB token).  Usually, the private key is additionally protected with a password or PIN code. <br><br>  Web applications traditionally use X.509 standard certificates.  Authentication using an X.509 certificate occurs at the time of connecting to the server and is part of the SSL / TLS protocol.  This mechanism is also well supported by browsers that allow the user to select and apply a certificate if the website allows this authentication method. <br><br><img width="33%" height="33%" src="https://habrastorage.org/files/681/fec/01d/681fec01de36423183fd3da27396b2a9.png"><br>  <i>Using a certificate for authentication.</i> <br><br>  During authentication, the server verifies the certificate based on the following rules: <br><br><ol><li>  The certificate must be signed by a trusted certification authority. </li><li>  The certificate must be valid for the current date (validity check). </li><li>  The certificate should not be revoked by the corresponding CA (checking exclusion lists). </li></ol><br><br><img src="https://habrastorage.org/files/de5/425/ee9/de5425ee9f1b462da2e49cc29ad7599a.png"><br>  <i>Certificate Example X.509.</i> <br><br>  After successful authentication, the web application can authorize the request based on certificate data such as subject (owner name), issuer (issuer), serial number (certificate serial number) or thumbprint (certificate public key fingerprint). <br><br>  Using certificates for authentication is a much more reliable way than password authentication.  This is achieved by creating a digital signature during the authentication process, the presence of which proves the fact of the use of the private key in a particular situation (non-repudiation).  However, difficulties with the distribution and support of certificates makes this authentication method inaccessible in wide circles. <br><br><h5>  <b>One-time password authentication</b> </h5><br>  One-time password authentication is usually applied in addition to password authentication for <i>two-factor authentication</i> (2FA).  In this concept, the user needs to provide two types of data to log in: something that he knows (for example, a password), and something that he owns (for example, a device for generating one-time passwords).  The presence of two factors allows to significantly increase the level of security that m. B.  claimed for certain types of web applications. <br><br>  Another popular scenario for using one-time passwords is additional user authentication when performing important actions: transferring money, changing settings, etc. <br><br>  There are various sources for creating one-time passwords.  Most Popular: <br><br><ol><li> Hardware or software tokens that can generate one-time passwords based on the secret key entered into them and the current time.  User secret keys, which are a factor of ownership, are also stored on the server, which allows you to verify the entered one-time passwords.  An example of hardware implementations of tokens - <a href="http://www.emc.com/security/rsa-securid/index.htm">RSA SecurID</a> ;  software - <a href="https://play.google.com/store/apps/details%3Fid%3Dcom.google.android.apps.authenticator2">Google Authenticator</a> application. </li><li>  Randomly generated codes transmitted to the user via SMS or other communication channel.  In this situation, the ownership factor is the user's phone (more precisely, the SIM card tied to a specific number). </li><li>  Listing or scratch card with a list of pre-formed one-time passwords.  For each new login you need to enter a new one-time password with the specified number. </li></ol><br><br><img src="https://habrastorage.org/files/e9f/c06/fe1/e9fc06fe151749839f2f48f24e9f148f.jpg"><br>  <i>The RSA SecurID hardware token generates a new code every 30 seconds.</i> <br><br>  In web applications, this authentication mechanism is often implemented through the expansion of forms authentication: after the initial password authentication, a user session is created, but in the context of this session the user does not have access to the application until he performs additional authentication using a one-time password. <br><br><h5>  <b>Access Key Authentication</b> </h5><br>  This method is most often used to authenticate devices, services, or other applications when accessing web services.  Here, as a secret, access keys ( <i>access key, API key</i> ) are used - long unique strings containing an arbitrary set of characters, in effect replacing the username / password combination. <br><br>  In most cases, the server generates access keys upon request from users, which further store these keys in client applications.  When creating a key, it is also possible to limit the period of validity and the level of access that the client application will receive when authenticating with this key. <br><br>  A good example of using key authentication is the Amazon Web Services cloud.  Suppose a user has a web application that allows you to upload and view photos, and he wants to use Amazon S3 to store files.  In this case, the user can create a key through the AWS console that has limited access to the cloud: read / write its files only in Amazon S3.  As a result, this key can be used to authenticate a web application in the AWS cloud. <br><br><img width="50%" height="50%" src="https://habrastorage.org/files/e81/4ba/c63/e814bac63f3440308d6f1305e7ce2dbc.png"><br>  <i>An example of the use of authentication by key.</i> <br><br>  Using keys allows you to avoid transferring the user's password to third-party applications (in the example above, the user saved the access key in the web application, not his password).  Keys have much more entropy than passwords, so it‚Äôs almost impossible to pick them up.  In addition, if the key was disclosed, it does not compromise the main user account - you just need to cancel this key and create a new one. <br><br>  From a technical point of view, there is no single protocol: the keys can be transmitted in different parts of the HTTP request: URL query, request body or HTTP header.  As with password authentication, the best option is to use the HTTP header.  In some cases, use the Bearer HTTP scheme to transfer a token in the header (Authorization: Bearer [token]).  To avoid interception of keys, the connection to the server must be secured with SSL / TLS. <br><br><img width="50%" height="50%" src="https://habrastorage.org/files/5e1/fa4/ad6/5e1fa4ad660e45e4ad005bd335e42944.png"><br>  <i>An example of access key authentication transmitted in the HTTP header.</i> <br><br>  In addition, there are more sophisticated key authentication schemes for unprotected connections.  In this case, the key usually consists of two parts: public and secret.  The public part is used to identify the client, and the secret part allows you to generate a signature.  For example, by analogy with the digest authentication scheme, the server can send a unique nonce or timestamp value to the client, and the client can return a hash or HMAC of this value calculated using the secret part of the key.  This avoids the transfer of the entire key in its original form and protects against replay attacks. <br><br><h5>  <b>Token authentication</b> </h5><br>  This authentication method is most often used when building distributed <i>Single Sign-On</i> (SSO) systems, where one application ( <i>service provider</i> or <i>relying party</i> ) delegates user authentication to another application ( <i>identity provider</i> or <i>authentication service</i> ).  A typical example of this method is to log into the application via an account on social networks.  Here, social networks are authentication services, and the application <u>trusts</u> the user authentication function to social networks. <br><br>  The implementation of this method is that the identity provider (IP) provides reliable information about the user <u>in the form of a token</u> , and the service provider (SP) application uses this token to identify, authenticate and authorize the user. <br>  At a general level, the whole process is as follows: <br><br><ol><li>  The client is authenticated to the identity provider in one of the ways specific to it (password, access key, certificate, Kerberos, etc.). </li><li>  The client asks the identity provider to provide him with a token for a specific SP-application.  Identity provider generates a token and sends it to the client. </li><li>  The client is authenticated in the SP application using this token. </li></ol><br><br><img width="50%" height="50%" src="https://habrastorage.org/files/b19/0b1/1c0/b190b11c0d934c999c1955184ddeb0c3.png"><br>  <i>An example of authenticating an ‚Äúactive‚Äù client using a token sent by the Bearer scheme.</i> <br><br>  The process described above reflects the authentication mechanism of the <i>active</i> client, i.e., one that can perform a programmed sequence of actions (for example, an iOS / Android application).  The browser is a <i>passive</i> client in the sense that it can only display pages requested by the user.  In this case, authentication is achieved by automatically redirecting the browser between the identity provider and the service provider web applications. <br><br><img width="66%" height="66%" src="https://habrastorage.org/files/553/6a3/98c/5536a398ca884b81a8a9b649c7bb8402.png"><br>  <i>An example of authenticating a "passive" client by redirecting requests.</i> <br><br>  There are several standards that precisely define the protocol of interaction between clients (active and passive) and IP / SP-applications and the format of tokens supported.  Among the most popular standards are OAuth, OpenID Connect, SAML, and WS-Federation.  Some information about these protocols is in the article below. <br><br>  The token itself is usually a data structure that contains information about who generated the token, who can be the recipient of the token, the duration, the set of information about the user (claims).  In addition, the token is additionally signed to prevent unauthorized changes and guarantees of authenticity. <br><br>  When authenticating using a token, the SP application must perform the following checks: <br><br><ol><li>  The token was issued by a trusted identity provider application (field check <i>issuer</i> ). </li><li>  The token is assigned to the current SP application ( <i>audience</i> field check). </li><li>  The validity of the token has not yet expired (checking the <i>expiration date</i> field). </li><li>  The token is authentic and has not been changed (signature verification). </li></ol><br><br>  In case of successful verification, the SP-application authorizes the request based on the user data contained in the token. <br><br><h6>  <b>Token Formats</b> </h6><br>  There are several common token formats for web applications: <br><br><ol><li>  <b>Simple Web Token</b> (SWT) is the simplest format, which is a collection of arbitrary name / value pairs in the HTML form coding format.  The standard defines several reserved names: Issuer, Audience, ExpiresOn and HMACSHA256.  The token is signed with a symmetric key, so both IP and SP applications must have this key in order to be able to create / verify a token. <br><br>  <i>An example of a SWT token (after decoding).</i> <br><blockquote>  Issuer = http: //auth.myservice.com&amp; <br>  Audience = http: //myservice.com&amp; <br>  ExpiresOn = 1435937883 &amp; <br>  UserName = John Smith &amp; <br>  UserRole = Admin &amp; <br>  HMACSHA256 = KOUQRPSpy64rvT2KnYyQKtFFXUIggnesSpE7ADA4o9w </blockquote><br></li><li>  <b>JSON Web Token (JWT)</b> - contains three blocks separated by dots: header, set of fields (claims) and signature.  The first two blocks are presented in JSON-format and are additionally encoded in base64 format.  A set of fields contains arbitrary name / value pairs, and the JWT standard defines several reserved names (iss, aud, exp, and others).  The signature can be generated using both symmetric encryption algorithms and asymmetric ones.  In addition, there is a separate standard for writing the format of an encrypted JWT token. <br><br>  <i>An example of a signed JWT token (after decoding 1 and 2 blocks).</i> <br><blockquote>  {"Alg": "HS256", "typ": "JWT"}. <br>  {‚ÄúIss‚Äù: ‚Äú <a href="http://auth.myservice.com/">auth.myservice.com</a> ‚Äù, ‚Äúaud‚Äù: ‚Äú <a href="http://myservice.com/">myservice.com</a> ‚Äù, ‚Äúexp‚Äù: ‚Äú1435937883‚Äù, ‚ÄúuserName‚Äù: ‚ÄúJohn Smith‚Äù, ‚ÄúuserRole‚Äù: ‚ÄúAdmin‚Äù}. <br>  S9Zs / 8 / uEGGTVVtLggFTizCsMtwOJnRhjaQ2BMUQhcY </blockquote><br><br></li><li>  <b>Security Assertion Markup Language (SAML)</b> - defines tokens (SAML assertions) in XML format, including information about the issuer, the subject, the necessary conditions for checking the token, a set of additional statements about the user.  SAML tokens are signed using asymmetric cryptography.  In addition, unlike previous formats, SAML tokens contain a mechanism to confirm ownership of a token, which helps prevent tokens from intercepting through man-in-the-middle attacks when using unprotected connections. </li></ol><br><br><h5>  <b>SAML standard</b> </h5><br>  The Security Assertion Markup Language (SAML) standard describes the interaction methods and protocols between an identity provider and a service provider for exchanging authentication and authorization data through tokens.  Initially, versions 1.0 and 1.1 were released in 2002‚Äì2003, while version 2.0, which significantly extends the standard and is backward incompatible, was published in 2005. <br><br>  This fundamental standard is quite complex and supports many different systems integration scenarios.  The main "building blocks" of the standard: <br><br><ol><li>  <b>Assertions</b> is a proprietary SAML token format in XML format. </li><li>  <b>Protocols</b> - a set of supported messages between participants, among which is a request to create a new token, retrieve existing tokens, log out, manage user identities, and others. </li><li>  <b>Bindings</b> are mechanisms for transmitting messages through various transport protocols.  Methods such as HTTP Redirect, HTTP POST, HTTP Artifact (link to messages), SAML SOAP, SAML URI (address of receiving the message) and others are supported. </li><li>  <b>Profiles</b> are typical use cases of the standard, defining a set of assertions, protocols and bindings necessary for their implementation, which allows to achieve better compatibility.  Web Browser SSO is one example of such profiles. </li></ol><br><br>  In addition, the standard defines the format of the exchange of meta-information between the participants, which includes a list of supported roles, protocols, attributes, encryption keys, etc. <br><br>  Consider a brief example of using SAML for the Single Sign-On script.  The user wants to access the protected resource of the service provider (step # 1 in the passive client authentication diagram).  Since the user was not authenticated, SP sends him to the identity provider site to create a token (step # 2).  The following is an example of an SP response, where the latter uses SAML HTTP Redirect binding to send a token request message: <br><br><img src="https://habrastorage.org/files/b3e/064/4db/b3e0644db4c44581acd2cecd00b5af41.png"><br><br>  In the case of such a request, the identity provider authenticates the user (steps # 3-4), and then generates a token.  The following is an example of an IP response using HTTP POST binding (step # 5): <br><br><img src="https://habrastorage.org/files/143/d65/ab4/143d65ab44374a95a7d1552be3cbebcf.png"><br><br>  After the browser automatically sends this form to the site of the service provider (step No. 6), the latter decodes the token and authenticates the user.  According to the results of the successful authorization of the request, the user gets access to the requested resource (step No. 7). <br><br><h5>  <b>WS-Trust and WS-Federation Standards</b> </h5><br>  WS-Trust and WS-Federation are part of the WS- * standards group, which describes SOAP / XML-web services.  These standards are developed by a group of companies that include Microsoft, IBM, VeriSign, and others.  Along with SAML, these standards are quite complex and are used primarily in corporate scenarios. <br><br>  The <b>WS-Trust</b> standard describes an authorization service interface called the Secure Token Service (STS).  This service works under the SOAP protocol and supports the creation, updating, and cancellation of tokens.  At the same time, the standard allows the use of tokens of various formats, but in practice, SAML tokens are mainly used. <br><br>  The <b>WS-Federation</b> standard concerns the mechanisms for the interaction of services between companies, in particular, token exchange protocols.  At the same time, WS-Federation extends the functions and interface of the STS service described in the WS-Trust standard.  Among other things, the WS-Federation standard defines: <br><br><ul><li>  Format and methods of sharing metadata about services. </li><li>  Single sign-out function. </li><li>  An attribute service that provides additional information about a user. </li><li>  The alias service allows you to create alternative usernames. </li><li>  Support for passive clients (browsers) through redirection. </li></ul><br><br>  It can be said that WS-Federation allows us to solve the same tasks as SAML, however their approaches and implementation are somewhat different. <br><br><h5>  <b>OAuth and OpenID Connect standards</b> </h5><br><br>  Unlike SAML and WS-Federation, the OAuth (Open Authorization) standard does not describe the user authentication protocol.  Instead, it defines the mechanism for accessing one application to another on behalf of the user.  However, there are schemes that allow user authentication based on this standard (more on this below). <br><br>  The first version of the standard was developed in 2007‚Äì2010, and the current version 2.0 was published in 2012. Version 2.0 considerably expands and at the same time simplifies the standard, but is inversely incompatible with version 1.0.  OAuth 2.0 is now very popular and is used everywhere to provide delegated access and third-party user authentication. <br><br>  To better understand the standard itself, consider an example of a web application that helps users plan trips.  As part of the functionality, it is able to analyze users' mail for the presence of letters with confirmations of bookings and automatically include them in the planned route.  The question arises, how can this web application safely access mail users, such as Gmail? <br><br>  &gt; <i>Ask the user to enter their account information?</i>  - bad option. <br>  &gt; <i>Ask the user to create an access key?</i>  - perhaps, but very difficult. <br><br>  This is the problem that the OAuth standard solves: it describes how a travel application (client) can access a user's mail (resource server) with the user's permission (resource owner).  In general, the whole process consists of several steps: <br><br><ol><li>  The user (resource owner) gives permission to the application (client) to access a specific resource in the form of a grant.  What is a grant, consider a little lower. </li><li>  The application accesses the authorization server and receives the access token to the resource in exchange for its grant.  In our example, the authorization server is Google.  When you call, the application is additionally authenticated using the access key issued to it during pre-registration. </li><li>  The application uses this token to obtain the required data from the resource server (in our case, the Gmail service). </li></ol><br><br><img width="55%" height="55%" src="https://habrastorage.org/files/078/176/f4b/078176f4bee345459dcccc2ea8910d6d.png"><br>  <i>The interaction of components in the standard OAuth.</i> <br><br>  The standard describes four types of grants that define possible application scenarios: <br><br><ol><li>  <b>Authorization Code</b> - this grant can be received by the user from the authorization server after successful authentication and confirmation of consent to grant access.  This method is most often used in web applications.  The grant process is very similar to the passive client authentication mechanism in SAML and WS-Federation. </li><li>  <b>Implicit</b> - used when the application does not have the ability to securely receive a token from an authorization server (for example, a JavaScript application in a browser).  In this case, the grant is a token received from the authorization server, and step No. 2 is excluded from the scenario above. </li><li>  <b>Resource Owner Password Credentials</b> - the grant is a pair of username / password user.  It can be used if the application is an ‚Äúinterface‚Äù for the resource server (for example, the application is a mobile client for Gmail). </li><li>  <b>Client Credentials</b> - in this case there is no user, and the application gets access to its resources using its access keys (step 1 is excluded). </li></ol><br><br>  The standard does not define the format of the token that the application receives: in the scenarios addressed by the standard, the application does not need to analyze the token, since it is only used to gain access to resources.  Therefore, neither the token nor the grant per se can be used to authenticate the user.  However, if an application needs to obtain reliable information about a user, there are several ways to do it: <br><br><ol><li>  Often, the resource server API includes an operation that provides information about the user himself (for example, / me in the Facebook API).  An application can perform this operation every time after receiving a token to identify the client.  This method is sometimes called <i>pseudo-authentication</i> . </li><li>  Use the <b>OpenID Connect</b> standard, developed as a credential layer on top of OAuth (published in 2014).  In accordance with this standard, the authorization server provides an additional identity token in step No. 2. This token in the JWT format will contain a set of specific fields (claims) with information about the user. </li></ol><br><br>  It is worth noting that OpenID Connect, replacing previous versions of the standard OpenID 1.0 and 2.0, also contains a set of optional add-ons for finding authorization servers, dynamic client registration and user session management. <br><br><h4>  <b>Conclusion</b> </h4><br>  In this article, we looked at various authentication methods in web applications.  Below is a table that summarizes the described methods and protocols: <br><br><table border="1"><tbody><tr><td>  <b>The way</b> <br></td><td>  <b>Main application</b> <br></td><td>  <b>Protocols</b> <br></td></tr><tr><td>  <b>By password</b> <br></td><td>  User Authentication <br></td><td>  HTTP Forms <br></td></tr><tr><td>  <b>By certificates</b> <br></td><td>  User authentication in secure applications;  service authentication <br></td><td>  SSL / TLS <br></td></tr><tr><td>  <b>By one-time passwords</b> <br></td><td>  Additional user authentication (to achieve two-factor authentication) <br></td><td>  Forms <br></td></tr><tr><td>  <b>By access keys</b> <br></td><td>  Authentication of services and applications <br></td><td>  - <br></td></tr><tr><td> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By tokens</font></font></b> <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Delegated user authentication; </font><font style="vertical-align: inherit;">delegated application authorization</font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> SAML, WS-Federation, OAuth, OpenID Connect </font></font><br></td></tr></tbody></table><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I hope that the information was useful, and you can apply it in the design and development of new applications. </font><font style="vertical-align: inherit;">See you again! </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Author</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : Dmitry Vyrostkov, Solutions Architect in DataArt.</font></font></div><p>Source: <a href="https://habr.com/ru/post/262817/">https://habr.com/ru/post/262817/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262805/index.html">C ++ 11/14/17 features in Visual Studio 2015 RTM</a></li>
<li><a href="../262807/index.html">Notes on distributed systems for beginners</a></li>
<li><a href="../262809/index.html">How can artificial intelligence be used to solve SEO problems?</a></li>
<li><a href="../262813/index.html">How to make beautiful documentation for the Web API, for which it will not be a shame</a></li>
<li><a href="../262815/index.html">Design for Dyslexics, Part One</a></li>
<li><a href="../262819/index.html">Mail Protocol Diagnostics</a></li>
<li><a href="../262821/index.html">Intel Edison. Using Intel Cloud on the example of distance sensor implementation</a></li>
<li><a href="../262823/index.html">2 years of burry reviews - the history of the amateur show Old-Hard</a></li>
<li><a href="../262827/index.html">Testing password policies of the largest web services</a></li>
<li><a href="../262831/index.html">Unreal real estate developers, or why years of experience do not say anything</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>