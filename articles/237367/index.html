<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using NSURLProtocol in Swift</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="NSURLProtocol is a kind of magic key to a URL. It allows you to override the URL loading system, Apple defines custom URL schemes and overrides existi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using NSURLProtocol in Swift</h1><div class="post__text post__text-html js-mediator-article">  NSURLProtocol is a kind of magic key to a URL.  It allows you to override the URL loading system, Apple defines custom URL schemes and overrides existing URL schemes. <br><br>  Does this seem magical?  It should be so.  Because if you look for them, you will find that the URL, almost like love, is around us.  What do UIWebView or WKWebView use?  They use the URL.  What is used to broadcast video from MPMoviePlayer?  To do this, use the URL.  How do you send someone to your application on <a href="https://developer.apple.com/library/ios/featuredarticles/iPhoneURLScheme_Reference/iTunesLinks/iTunesLinks.html">iTunes</a> , launch <a href="https://developer.apple.com/library/ios/featuredarticles/iPhoneURLScheme_Reference/FacetimeLinks/FacetimeLinks.html">FaceTime</a> or Skype, launch another application in the system or even <a href="http://en.wikipedia.org/wiki/Data_URI_scheme">insert an image in an HTML file</a> ?  Using URL.  Take a look at the NSFileManager and note how many file handling methods URLs are needed for. <br><br>  In this article about NSURLProtocol, you will learn how to define a protocol handler that modifies the URL of a scheme.  It will add raw and ready-made transparent caching layer, saving extracted resources to Core Data.  By launching it into operation, the regular UIWebView can then take on the role of a browser, caching the loaded pages so that you can later view them in offline mode. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  Before you plunge into this with your head, you will need to learn basic network concepts and become familiar with how NSURLConnection works.  If you are not currently familiar with <a href="http://www.raywenderlich.com/51127/nsurlsession-tutorial">NSURLConnection</a> , then I suggest you read this tutorial and / or <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/URLLoadingSystem/Tasks/UsingNSURLConnection.html">document from Apple</a> . <br><br>  Well, are you ready now to study what the NSURLProtocol is for?  Well, go make yourself a cup of tea and get ready for a meaningful, mind-developing discussion and step-by-step application. <br><br>  <b>Start</b> <br><br>  In the context of the design of this tutorial, you will create an elementary mobile web browser that you could possibly add to your next application.  It will have a basic user interface that allows the user to enter and open a URL.  A characteristic feature is that your browser successfully caches the results.  In this way, the user can load the previously visited pages in the blink of an eye, because the page will be loaded not from the network request, but from the local application cache. <br><br>  You already know that if pages load quickly, users are happy, that is, this is a good example of how the NSURLProtocol can improve the performance of your application. <br><br>  You need to complete the following steps: <br><ul><li>  Use UIWebView to display websites. </li><li>  Use the Core Data Database for caching results. </li></ul><br><br>  If you are not familiar with the Core Data database, you can take a look at our <a href="http://www.raywenderlich.com/934/core-data-tutorial-for-ios-getting-started">tutorial</a> .  However, the code in this tutorial should be sufficient to understand the capabilities of the NSURLProtocol.  Using the Core Data database is an easy way to put the local cache into effect, so it‚Äôs not so important to learn something useful here. <br><br>  <b>Start Project Overview</b> <br><br>  You can download the start project <a href="">here</a> .  Once the download is complete, unzip and open the project file. <br><br>  When you open the project, you will find two main files.  The first is the Main.storyboard file.  It contains the UIViewController required to implement it.  Note the UITextField (for entering the URL), the UIButton (for launching web requests) and the UIWebView. <br><br>  Open the BrowserViewController.swift file.  Here you will see the main mode of operation configured for the UI components.  This UIViewController supports the UITextFieldDelegate protocol, and you can run a query when the user presses the enter key.  The IBAction for the button is set to work in the same way as the enter key.  Finally, the sendRequest () method simply takes the text from the text field, creates an NSURLRequest object, and calls the loadRequest method (_ :) for the UIWebView to load it. <br><br>  Once you are familiar with the application, compile and run it!  When the application starts, enter ‚Äúhttp://raywenderlich.com‚Äù and click ‚ÄúGo‚Äù.  UIWebView will load the response and display the result in the application.  Pretty simple to start with.  Now it's your turn to pull your fingers.  Next ... coding! <br><br>  <b>Interception of network requests</b> <br><br>  A number of classes, known as the <b>URL Download System</b> , process URL requests on iOS.  At the heart of the URL Loading System is the NSURL class.  For network requests, this class shows which host is trying to reach your application, and also shows the path to the resource in this host.  In addition, the NSURLRequest object adds information such as HTTP headers, the bulk of your message, etc.  The loading system provides several different classes that you can use to process a request, the most common being NSURLConnection and NSURLSession. <br><br>  Now it's time to start intercepting all NSURL requests launched by the application.  To do this, you will need to create your own implementation of the NSURL protocol. <br><br>  Click File \ New \ File ....  Select iOS \ Source \ Cocoa Touch Class and press the Next key.  In the Class field, enter MyURLProtocol and in the Subclass of field, enter NSURLProtocol.  Check that the language is Swift.  Finally, click Next and then Create when the dialog appears. <br><br>  Open the file MyURLProtocol.swift and replace its contents with the following: <br><br><pre><code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> var requestCount = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> MyURLProtocol: <span class="hljs-built_in"><span class="hljs-built_in">NSURLProtocol</span></span> { override <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func canInitWithRequest(request: <span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span>) -&gt; Bool { println(<span class="hljs-string"><span class="hljs-string">"Request #\(requestCount++): URL = \(request.URL.absoluteString)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }</code> </pre> <br><br>  Each time the Download System URL receives a request to load a URL, it searches for a registered protocol handler to process the request.  Each handler notifies the system if it can process this request with its own method canInitWithRequest (_ :). <br><br>  The parameter to this method is a query about whether the protocol can process it.  If the method returns true, the load system will rely on this subclass of the NSURL protocol to process the request and ignore all other handlers. <br><br>  If none of the registered persistent handlers can process the request, the URL loading system will process it itself using the default mode. <br><br>  If you want to execute a new protocol, such as foo: //, it is here that you need to check that the URL scheme request is foo.  But in the example above, you get a false response, which indicates that your application cannot process the request.  Wait a little, you will soon begin to process them! <br><br>  <b>Note:</b> <i>NSURLProtocol must be an abstract class.</i>  <i>You create a subclass in the individual mode for the NSURLProtocol, but you should never handle the NSURLProtocol directly.</i> <br><br>  Open AppDelegate.swift and replace the method. <br><br><pre> <code class="objectivec hljs">func application(application: <span class="hljs-built_in"><span class="hljs-built_in">UIApplication</span></span>, didFinishLaunchingWithOptions launchOptions: <span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span>?) -&gt; Bool { <span class="hljs-built_in"><span class="hljs-built_in">NSURLProtocol</span></span>.registerClass(MyURLProtocol) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> }</code> </pre><br><br>  Now that your application is running, it will register the protocol in the URL Download System.  This means that it will be able to process every request received by the download system URL.  This includes coding that directly requests the download system, as well as many system components that are based on the URL loading structure, such as UIWebView. <br><br>  Compile the project and run it.  Insert the line " <a href="http://raywenderlich/">raywenderlich</a> .com" as a website line, press the <b>Go</b> key and check the Xcode console.  Now for each request that the application must fulfill, the Download System URL will ask your class if it can process it. <br><br>  In the console, you should see something like this: <br><br><pre> <code class="objectivec hljs">Request <span class="hljs-meta"><span class="hljs-meta">#0: URL = http://raywenderlich.com/ Request #1: URL = http://raywenderlich.com/ Request #2: URL = http://raywenderlich.com/ Request #3: URL = http://raywenderlich.com/ Request #4: URL = http://raywenderlich.com/ Request #5: URL = http://raywenderlich.com/ Request #6: URL = http://www.raywenderlich.com/ Request #7: URL = http://www.raywenderlich.com/ Request #8: URL = http://www.raywenderlich.com/ Request #9: URL = http://www.raywenderlich.com/ Request #10: URL = http://www.raywenderlich.com/ Request #11: URL = http://www.raywenderlich.com/ Request #12: URL = http://raywenderlich.com/ Request #13: URL = http://cdn3.raywenderlich.com/wp-content/themes/raywenderlich/style.min.css?ver=1402962842 Request #14: URL = http://cdn3.raywenderlich.com/wp-content/plugins/swiftype-search/assets/autocomplete.css?ver=3.9.1 Request #15: URL = http://cdn4.raywenderlich.com/wp-content/plugins/videojs-html5-video-player-for-wordpress/plugin-styles.css?ver=3.9.1 Request #16: URL = http://vjs.zencdn.net/4.5/video-js.css?ver=3.9.1 Request #17: URL = http://cdn3.raywenderlich.com/wp-content/themes/raywenderlich/style.min.css?ver=1402962842 ...</span></span></code> </pre><br>  At this point, your class simply registers the request URL sequentially and returns false, which means that your custom class cannot process the request.  But if you view the registration records, you will see all the requests sent from UIWebView.  These include the main website (.html) and all assets, such as JPEGs and CSS files.  Each time a UIWebView needs to launch a request, it is registered in the console before it starts.  The total should show you a mountain of requests, probably more than five hundred, because of all the assets on the web page. <br><br>  So, this is what you need to do: Your custom class receives a notification about each URL request, and then you can do something with each request! <br><br>  <b>How do you get the data?</b> <br><br>  ‚ÄúI like it when pages load for ages,‚Äù you‚Äôll never hear from anyone.  That is, you now have to make sure that your application can process requests.  As soon as you get a true answer in canInitWithRequest (_ :), your class is simply obliged to fully process this request.  This means that you must receive the requested data and send it back to the URL Download System. <br><br>  How do you get the data? <br><br>  If you run the network protocol of a new application from scratch (for example, add the foo: // protocol), then here you will know the joys of implementing the network protocol of the application.  But since your task is to just insert a custom caching layer, you can simply retrieve the data using NSURLConnection. <br><br>  Your custom NSURLProtocol subclass returns data through an object that implements the NSURLProtocolClient protocol.  In order not to get confused in the names, remember: NSURLProtocol is a class, and NSURLProtocolClient is a protocol! <br><br>  Through the client, you notify the URL Download System of the postback of changes in operation, responses and data. <br><br>  In essence, you simply intercept the request and then transfer it back to the standard URL Download System using NSURLConnection. <br><br>  Open the file MyURLProtocol.swift and add the following characteristic at the top of the definition of the class MyURLProtocol: <br><br><pre> <code class="objectivec hljs">var connection: <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>!</code> </pre><br><br>  Then, find canInitWithRequest (_ :).  Enter true in the answer field: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br><br>  Now add four more methods: <br><br><pre> <code class="objectivec hljs">override <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func canonicalRequestForRequest(request: <span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request } override <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func requestIsCacheEquivalent(aRequest: <span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span>, toRequest bRequest: <span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span>) -&gt; Bool { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.requestIsCacheEquivalent(aRequest, toRequest:bRequest) } override func startLoading() { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.connection = <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>(request: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.request, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } override func stopLoading() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.connection != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.connection.cancel() } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.connection = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br><br>  Your protocol itself defines what ‚Äúcanonical request‚Äù means, but at a minimum it must answer an incoming request with the same canonical request.  Thus, if two semantically equal queries are entered (that is, not necessarily = = =) for this method, then outgoing queries must also be semantically equal.  For example, if the case of letters for your custom URL scheme is irrelevant, then all canonical URLs are lowercase. <br><br>  To comply with the minimum standard, simply return the request itself.  As a rule, this is a reliable competent decision, since you usually should not change the request.  In the end, you trust the developer, right?  What you could do here, for example, modify the query by adding a header and return a new query. <br><br>  The requestIsCacheEquivalent (_: toRequest :) is where you should not rush to determine when two different requests for a custom URL scheme (i.e., foo: //) are equal in terms of cache capabilities.  If the two queries are equal, then they must use the same cached data.  This concerns your own, built-in URL Loading System caching system, which you should ignore for this tutorial.  So for this exercise, simply rely on the default superclass implementation. <br><br>  The boot system uses startLoading () and stopLoading () to send a signal to your NSURLProtocol to start and stop processing the request.  Your start of the implementation puts the NSURLConnection sample to download the data.  There is also a stop method so that URL loading can be canceled.  In the above example, it was allowed to cancel the current connection and get rid of it. <br><br>  Hooray!  You have installed an interface that needs a valid NSURLProtocol example.  If you want to read more, see the official documentation describing the methods that a valid subclass of NSURLProtocol can perform. <br><br>  But your coding is not done yet!  You have yet to process the request that you carry out using the transmitted callbacks from NSURLConnection that you have created. <br><br>  Open the MyURLProtocol.swift file and add the following methods: <br><br><pre> <code class="objectivec hljs">func connection(connection: <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>!, didReceiveResponse response: <span class="hljs-built_in"><span class="hljs-built_in">NSURLResponse</span></span>!) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.client!.URLProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceiveResponse: response, cacheStoragePolicy: .NotAllowed) } func connection(connection: <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>!, didReceiveData data: <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>!) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.client!.URLProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoadData: data) } func connectionDidFinishLoading(connection: <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>!) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.client!.URLProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) } func connection(connection: <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>!, didFailWithError error: <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span>!) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.client!.URLProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didFailWithError: error) }</code> </pre><br><br>  These are all methods of the NSURLConnection delegate.  They are used when the NSURLConnection sample you use to load data responds when it has data, when the download is complete and when a failure occurs.  In each of these cases, you must pass this information to the client. <br><br>  Thus, summing up, your handler MyURLProtocol creates its own NSURLConnection and asks it to process the request.  In the NSURLConnection callback methods listed above, the protocol handler sends messages from the network back to the Download System URL.  These messages notify you of the download progress, process completion, or errors. <br><br>  Take a look and you will see a very close similarity in the message signatures for NSURLConnectionDelegate and NSURLProtocolClient, they both are APIs for asynchronous data loading.  Also note how MyURLProtocol uses its client characteristic to send messages back to the URL loading system. <br><br>  Compile the project and run it.  When the application starts, enter the same URL and press the <b>Go</b> key. <br><br>  Oh oh oh!  Your browser does not download anything anymore!  If you look at Troubleshooting Navigator while it works, you will see that memory usage is getting out of control.  The console should display a racing list of innumerable requests for the same URL.  What could be wrong? <br><br>  In the console, you should see that the lines are always registered like this: <br><br><pre> <code class="objectivec hljs">Request <span class="hljs-meta"><span class="hljs-meta">#0: URL = http://raywenderlich.com/ Request #1: URL = http://raywenderlich.com/ Request #2: URL = http://raywenderlich.com/ Request #3: URL = http://raywenderlich.com/ Request #4: URL = http://raywenderlich.com/ Request #5: URL = http://raywenderlich.com/ Request #6: URL = http://raywenderlich.com/ Request #7: URL = http://raywenderlich.com/ Request #8: URL = http://raywenderlich.com/ Request #9: URL = http://raywenderlich.com/ Request #10: URL = http://raywenderlich.com/ ... Request #1000: URL = http://raywenderlich.com/ Request #1001: URL = http://raywenderlich.com/</span></span></code> </pre><br><br>  You need to go back to Xcode and stop the application before trying to fix the problem. <br><br>  <b>Suppression of an infinite loop with tags</b> <br><br>  Think again about the URL Loading System and protocol registration, and maybe you will understand why this is happening.  When UIWebView wants to load a URL, the Download System URL asks MyURLProtocol if it can process this particular request.  If your class returns true, then it can process it. <br><br>  Thus, the URL Download System will create a sample of your protocol and call startLoading.  Then the implementation begins and its NSURLConnection is launched.  But it also calls the URL Loading System.  And what do you think?  Since you always get a true response in the canInitWithRequest (_ :) method, it creates another copy of MyURLProtocol. <br><br>  This new copy will create another one, and then another, and then an infinite number of copies.  That is why your application does not download anything!  It just continues to allocate more memory and shows only one URL in the console.  Poor browser gets stuck in an endless loop!  Your users may be so desperate that they can even cause damage to their devices. <br><br>  Obviously, you cannot always get a true response in the canInitWithRequest (_ :) method.  You must have some sort of control to let the Download System URL handle the request only once.  The solution is in the NSURLProtocol interface.  Look for a class method called setProperty (_: forKey: inRequest :) that allows you to add custom properties to a given URL request.  This way, you can 'tag' it by attaching a property to it, and the browser will know if it has already seen it before. <br><br>  Thus, you display the browser from an infinite loop.  Open the file MyURLProtocol.swift.  and replace the startLoading () and canInitWithRequest (_ :) methods with the following: <br><br><pre> <code class="objectivec hljs">override <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> func canInitWithRequest(request: <span class="hljs-built_in"><span class="hljs-built_in">NSURLRequest</span></span>!) -&gt; Bool { println(<span class="hljs-string"><span class="hljs-string">"Request #\(requestCount++): URL = \(request.URL.absoluteString)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSURLProtocol</span></span>.propertyForKey(<span class="hljs-string"><span class="hljs-string">"MyURLProtocolHandledKey"</span></span>, inRequest: request) != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } override func startLoading() { var newRequest = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.request.copy() as <span class="hljs-built_in"><span class="hljs-built_in">NSMutableURLRequest</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NSURLProtocol</span></span>.setProperty(<span class="hljs-literal"><span class="hljs-literal">true</span></span>, forKey: <span class="hljs-string"><span class="hljs-string">"MyURLProtocolHandledKey"</span></span>, inRequest: newRequest) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.connection = <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>(request: newRequest, delegate: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) }</code> </pre><br><br>  Now in the startLoading () method, it sets the property associated with the key ‚ÄúMyURLProtocolHandledKey‚Äù and assigns it true for this request.  This means that the next time canInitWithRequest (_ :) is called for a given NSURLRequest object, the protocol may ask if the same property is installed. <br><br>  If it is set, it returns true, it means that you do not need to process this request anymore.  System Download URL will download data from the network.  Since your copy of MyURLProtocol is sent for that request, it will receive callbacks from NSURLConnectionDelegate. <br><br>  Compile and run the application.  The application will successfully display web pages in your webview.  Sweet victory!  The console should now look something like this: <br><br><pre> <code class="objectivec hljs">Request <span class="hljs-meta"><span class="hljs-meta">#0: URL = http://raywenderlich.com/ Request #1: URL = http://raywenderlich.com/ Request #2: URL = http://raywenderlich.com/ Request #3: URL = http://raywenderlich.com/ Request #4: URL = http://raywenderlich.com/ Request #5: URL = http://raywenderlich.com/ Request #6: URL = http://raywenderlich.com/ Request #7: URL = http://raywenderlich.com/ Request #8: URL = http://raywenderlich.com/ Request #9: URL = http://www.raywenderlich.com/ Request #10: URL = http://www.raywenderlich.com/ Request #11: URL = http://www.raywenderlich.com/ Request #12: URL = http://raywenderlich.com/ Request #13: URL = http://cdn3.raywenderlich.com/wp-content/themes/raywenderlich/style.min.css?ver=1402962842 Request #14: URL = http://cdn3.raywenderlich.com/wp-content/plugins/swiftype-search/assets/autocomplete.css?ver=3.9.1 Request #15: URL = http://cdn4.raywenderlich.com/wp-content/pluginRse/qvidueeosjts -#h1t6m:l URL = ht5t-pv:i/d/ecodn3.raywenderlich.com/-wppl-acyoenrtent/themes/raywenderlich/-sftoyrl-ew.omridnp.css?vreers=s1/4p0l2u9g6i2n8-4s2t yles.css?ver=3.9.1 Request #17: URL = http://cdn3.raywenderlich.com/wp-content/themes/raywenderlich/style.min.css?ver=1402962842 Request #18: URL = http://vjs.zencdn.net/4.5/video-js.css?ver=3.9.1 Request #19: URL = http://www.raywenderlich.com/wp-content/plugins/wp-polls/polls-css.css?ver=2.63 Request #20: URL = http://cdn3.raywenderlich.com/wp-content/plugins/swiftype-search/assets/autocomplete.css?ver=3.9.1 Request #21: URL = http://cdn3.raywenderlich.com/wp-content/plugins/swiftype-search/assets/autocomplete.css?ver=3.9.1 Request #22: URL = http://cdn4.raywenderlich.com/wp-content/plugins/powerpress/player.min.js?ver=3.9.1 Request #23: URL = http://cdn4.raywenderlich.com/wp-content/plugins/videojs-html5-video-player-for-wordpress/plugin-styles.css?ver=3.9.1 Request #24: URL = http://cdn4.raywenderlich.com/wp-content/plugins/videojs-html5-video-player-for-wordpress/plugin-styles.css?ver=3.9.1 Request #25: URL = http://cdn3.raywenderlich.com/wp-content/themes/raywenderlich/style.min.css?ver=1402962842 Request #26: URL = http://cdn3.raywenderlich.com/wp-content/plugins/swiftype-search/assets/autocomplete.css?ver=3.9.1 ...</span></span></code> </pre><br><br>  You may wonder why you did all this just to make the application work exactly as it did when you started.  Well, because you have to prepare for the fun part!  Now you have all control over the data from the URL of your application, and you can do whatever you want with it.  It's time to start caching the received data of your application. <br><br>  <b>Local cache injection</b> <br><br>  Remember the basic requirement for this application: for this request, data from the network must be downloaded only once, and then they need to be cached.  If the same request is launched again in the future, your protocol will return a cached response without loading it from the network. <br><br>  <b>Note: the</b> <i>starting project already includes the core Core Data model and stack.</i>  <i>You do not need to know the details of Core Data, you can think of it as a dark data warehouse;</i>  <i>If you're interested, check out <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CoreData/cdProgrammingGuide.html">Apple's Core Data Guide.</a></i> <br><br>  It's time to save the answers your application receives from the network and retrieve them when the corresponding cached data appears.  Open the MyURLProtocol.swift file and add the following import at the top of the file: <br><br><pre> <code class="objectivec hljs">import CoreData</code> </pre><br><br>  Then add two variables in the class definition: <br><br><pre> <code class="objectivec hljs">var mutableData: <span class="hljs-built_in"><span class="hljs-built_in">NSMutableData</span></span>! var response: <span class="hljs-built_in"><span class="hljs-built_in">NSURLResponse</span></span>!</code> </pre><br><br>  The response variable will store a link to the metadata you need when saving the response from the server.  The mutableData variable will be used to store data that it receives in the delegate method of connection (_: didReceiveData :).  When the answer comes, you can cache the data and metadata. <br><br>  Then add the following method to the class: <br><br><pre> <code class="objectivec hljs">func saveCachedResponse () { println(<span class="hljs-string"><span class="hljs-string">"Saving cached response"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1 let delegate = UIApplication.sharedApplication().delegate as AppDelegate let context = delegate.managedObjectContext! // 2 let cachedResponse = NSEntityDescription.insertNewObjectForEntityForName("CachedURLResponse", inManagedObjectContext: context) as NSManagedObject cachedResponse.setValue(self.mutableData, forKey: "data") cachedResponse.setValue(self.request.URL.absoluteString, forKey: "url") cachedResponse.setValue(NSDate(), forKey: "timestamp") cachedResponse.setValue(self.response.MIMEType, forKey: "mimeType") cachedResponse.setValue(self.response.textEncodingName, forKey: "encoding") // 3 var error: NSError? let success = context.save(&amp;error) if !success { println("Could not cache the response") } }</span></span></code> </pre><br><br>  Here is what this method does: <br><ol><li>  Get Core Data NSManagedObjectContext from an AppDelegate instance.  The context of the object being manipulated is your interface to Core Data. </li><li>  Create an instance of the NSManagedObject class to match the data model, as in the .xcdatamodeld file.  Set its properties based on the references to the NSURLResponse and NSMutableData that you saved. </li><li>  Save the context of a Core Data managed object. </li></ol><br><br>  Now that you have a way to store data, you need to call this method from somewhere.  All in the same MyURLProtocol.swift, change the delegate methods of the NSURLConnection to the following: <br><br><pre> <code class="objectivec hljs">func connection(connection: <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>!, didReceiveResponse response: <span class="hljs-built_in"><span class="hljs-built_in">NSURLResponse</span></span>!) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.client!.URLProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didReceiveResponse: response, cacheStoragePolicy: .NotAllowed) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.response = response <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mutableData = <span class="hljs-built_in"><span class="hljs-built_in">NSMutableData</span></span>() } func connection(connection: <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>!, didReceiveData data: <span class="hljs-built_in"><span class="hljs-built_in">NSData</span></span>!) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.client!.URLProtocol(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, didLoadData: data) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.mutableData.appendData(data) } func connectionDidFinishLoading(connection: <span class="hljs-built_in"><span class="hljs-built_in">NSURLConnection</span></span>!) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.client!.URLProtocolDidFinishLoading(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.saveCachedResponse() }</code> </pre><br><br>  Instead of being directly transferred to the client, the response actions and data are now saved by your custom protocol class. <br><br>  Compile and run the application.  Nothing has changed in the application, but remember that the now successfully obtained data from the web server is stored in the local database of your application. <br><br>  <b>Getting a cached response</b> <br><br>  Finally, now is the time to get the cached data and send it to the client on the NSURLProtocol.  Open the file MyURLProtocol.swift.  and add the following method: <br><br><pre> <code class="objectivec hljs">func cachedResponseForCurrentRequest() -&gt; <span class="hljs-built_in"><span class="hljs-built_in">NSManagedObject</span></span>? { <span class="hljs-comment"><span class="hljs-comment">// 1 let delegate = UIApplication.sharedApplication().delegate as AppDelegate let context = delegate.managedObjectContext! // 2 let fetchRequest = NSFetchRequest() let entity = NSEntityDescription.entityForName("CachedURLResponse", inManagedObjectContext: context) fetchRequest.entity = entity // 3 let predicate = NSPredicate(format:"url == %@", self.request.URL.absoluteString!) fetchRequest.predicate = predicate // 4 var error: NSError? let possibleResult = context.executeFetchRequest(fetchRequest, error: &amp;error) as Array&lt;NSManagedObject&gt;? // 5 if let result = possibleResult { if !result.isEmpty { return result[0] } } return nil }</span></span></code> </pre><br><br>  Here is what he does: <br><ol><li>  Takes the context of a Core Data managed object, just like in saveCachedResponse (). </li><li>  Creates an NSFetchRequest and indicates that you want to find an element called CachedURLResponse.  This is the element in the managed object model that needs to be extracted. </li><li>  The predicate for a sample query needs to get a CachedURLResponse object that corresponds to the URL you upload.  This code sets it up. </li><li>  Fulfills a sample query. </li><li>  If there are any results, opens the first result. </li></ol><br><br>        startLoading ().  ,      ,        URL.    startLoading    : <br><br><pre> <code class="objectivec hljs">override func startLoading() { <span class="hljs-comment"><span class="hljs-comment">// 1 let possibleCachedResponse = self.cachedResponseForCurrentRequest() if let cachedResponse = possibleCachedResponse { println("Serving response from cache") // 2 let data = cachedResponse.valueForKey("data") as NSData! let mimeType = cachedResponse.valueForKey("mimeType") as String! let encoding = cachedResponse.valueForKey("encoding") as String! // 3 let response = NSURLResponse(URL: self.request.URL, MIMEType: mimeType, expectedContentLength: data.length, textEncodingName: encoding) // 4 self.client!.URLProtocol(self, didReceiveResponse: response, cacheStoragePolicy: .NotAllowed) self.client!.URLProtocol(self, didLoadData: data) self.client!.URLProtocolDidFinishLoading(self) } else { // 5 println("Serving response from NSURLConnection") var newRequest = self.request.copy() as NSMutableURLRequest NSURLProtocol.setProperty(true, forKey: "MyURLProtocolHandledKey", inRequest: newRequest) self.connection = NSURLConnection(request: newRequest, delegate: self) } }</span></span></code> </pre><br><br>  This is what happens: <br><br><ol><li> -,          . </li><li>  ,        . </li><li>   NSURLResponse   . </li><li>       .         NotAllowed,     ,     ,     .       URLProtocolDidFinishLoading,  ,   .   ,   ! </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If no cached data was found, then load the data as usual. </font></font></li></ol><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compile and run your project. </font><font style="vertical-align: inherit;">Browse multiple websites and then exit the application. </font><font style="vertical-align: inherit;">Or switch the device to airplane mode (or, using the iOS simulator, turn off Wi-Fi on your computer / unplug the Ethernet cable) Try to download any website you just downloaded. </font><font style="vertical-align: inherit;">Pages should load from cached data.</font></font> Hooray!<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rejoice! </font><font style="vertical-align: inherit;">You did it !!! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You will see many entries in the console that look like this:</font></font><br><br><pre> <code class="objectivec hljs">Request <span class="hljs-meta"><span class="hljs-meta">#22: URL = http://vjs.zencdn.net/4.5/video-js.css?ver=3.9.1 Serving response from cache</span></span></code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This entry indicates that data is being returned from your cache! </font></font><br><br>  And it's all.            -.           ! <br><br> <b>  NSURLProtocol?</b> <br><br>     NSURLProtocol,     , ,    ?  Here are some examples: <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Provide your Network Requests with Custom Notifications: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It doesn't matter if you send a request using UIWebView, NSURLConnection or even using a third-party library (such as AFNetworking, MKNetworkKit, your own, etc., as they are all built on NSURLConnection). You can provide custom notification for both metadata and data. You could also use it if you, for example, want to ‚Äúredeem‚Äù the request notification for testing purposes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skip the Web Workflow and Provide Local Data:</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sometimes you may feel that there is no need to run a network request in order to provide the application with the data it needs. NSURLProtocol can configure your application to find data in a local storage or local database. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Forward your network requests: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Have you ever wanted to redirect requests to a proxy server, trusting the user to follow the specific instructions for installing iOS? Can you do it! NSURLProtocol gives you what you want - control over requests. You can configure your application to intercept and redirect them to another server or proxy, or wherever you want. This is about control !!! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Modify the user agent of your requests:</font></font><br><br> ,     ,        . ,     -.    ,         -.       ,         ,    . <br><br>     : <br><br>         (, -   UDP).                   . <br><br>   ,  .     (  )   ,     NSURLProtocol    .    ,      NSURLRequest,     ,   NSURLResponse.       NSURLResponse.   ,  . <br><br>     NSURLProtocol  ,  ,     .  ,        ,    .  ,        NSURLProtocol,        . <br><br>  <b>What's next?</b> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can download the completed project for this training manual. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This example demonstrated the simple use of the NSURLProtocol, but do not confuse it with an absolute caching solution. Implementing a high-quality browser caching requires much more. In fact, the loading system has built-in caching configurations that you should be familiar with. The goal of this tutorial is to simply show you the possibilities. Since the NSURLProtocol has access to data coming in and out of a large number of components, this is very powerful! There are almost no limits to what you can do when implementing the startLoading method. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">While </font></font><a href="http://tools.ietf.org/html/rfc3986"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">RFC 3986 IET</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F can modestly define a URL as ‚Äú... a compact sequence of characters that defines an abstract or physical resource ...‚Äù the fact is that a URL is its own mini-language. It is designated domain domain (DSL) for designation and location of things. This is probably the most common domain domain in the world, given that URLs have gone off the screen and are now broadcast on radio and television advertisements, printed in magazines and drawn on store signs all over the world. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NSURLProtocol is a language that can be used in many different ways. When Twitter wanted to implement </font></font><a href="https://blog.twitter.com/2013/cocoaspdy-spdy-for-ios-os-x"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SPDY on iOS</font></font></a> ,   HTTP 1.1,      NSURLProtocol. ,     ,  . NSURLProtocol     ,            . </div><p>Source: <a href="https://habr.com/ru/post/237367/">https://habr.com/ru/post/237367/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../237353/index.html">OpenSSL to encrypt QNAP NAS connection SSL WebDav</a></li>
<li><a href="../237359/index.html">Wolfram Research has launched the Tweet-a-Program service: interesting programs in Wolfram Language, the length of which does not exceed 140 characters</a></li>
<li><a href="../237361/index.html">How we did the QIWI Universe accelerator</a></li>
<li><a href="../237363/index.html">Local Internet?</a></li>
<li><a href="../237365/index.html">How to receive information if the Russian segment of the Internet is cut off from the global</a></li>
<li><a href="../237371/index.html">iPhone 6 Plus: iFixit full review (7 out of 10 on the repair scale)</a></li>
<li><a href="../237373/index.html">Poll. Does everyone step on the ERP rake</a></li>
<li><a href="../237375/index.html">Learning C ++ through game programming</a></li>
<li><a href="../237379/index.html">The new version of Android will encrypt default user data</a></li>
<li><a href="../237381/index.html">Overview of mail clients for Android, or how I chose the mailer</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>