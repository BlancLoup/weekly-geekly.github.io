<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Consider Kotlin more closely</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="https://trends.google.com/trends/explore?q=%2Fm%2F0_lcrx4 


 The above is a screenshot of Google Trends when I searched for the word "kotlin". A sudd...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Consider Kotlin more closely</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/web/f82/801/1aa/f828011aa02b4e519114ec713c725421.png" alt="image"></p><br><p>  <a href="https://trends.google.com/trends/explore%3Fq%3D%252Fm%252F0_lcrx4">https://trends.google.com/trends/explore?q=%2Fm%2F0_lcrx4</a> </p><br><p>  The above is a screenshot of Google Trends when I searched for the word "kotlin".  A sudden surge is when <a href="https://android-developers.googleblog.com/2017/05/android-announces-support-for-kotlin.html">Google announced that Kotlin is becoming the main language in Android</a> .  It happened at the Google I / O conference a few weeks ago.  To date, you have either used this language before, or are interested in it, because everyone around you suddenly started talking about it. </p><a name="habracut"></a><br><p>  One of the main features of Kotlin is its <strong>mutual compatibility</strong> with Java: you can call Kotlin code from Java, and Java code from Kotlin.  This is perhaps the most important feature by which the language is widely distributed.  You do not need to migrate everything at once: just take a piece of the existing code base and start adding the Kotlin code, and this will work.  If you <strong>experiment</strong> with Kotlin and you do not like it, then you can always refuse it (although I recommend trying it). </p><br><p>  When I first used Kotlin after five years in Java, some things seemed like real magic to me. </p><br><p> ‚ÄúWait, what?  Can I just write a <a href="https://kotlinlang.org/docs/reference/data-classes.html"><code>data class</code></a> to avoid templating code? ‚Äù <br>  ‚ÄúStop, so if I write <code>apply</code> , then I no longer need to define an object every time I want to call a method with reference to it?‚Äù </p><br><p>  After the first sigh of relief from the fact that at last there was a language that does not look outdated and cumbersome, I began to feel some discomfort.  If mutual compatibility with Java is required, how exactly all these great features are implemented in Kotlin?  What's the catch? </p><br><p>  This article is dedicated to.  I was very interested in finding out how the Kotlin compiler transforms concrete constructs so that they become interoperable with Java.  For my research, I chose the four most requested methods from <a href="https://kotlinlang.org/api/latest/jvm/stdlib/index.html">the Kotlin standard library</a> : </p><br><ol><li> <code>apply</code> </li> <li> <code>with</code> </li> <li> <code>let</code> </li> <li> <code>run</code> </li> </ol><br><p>  When you read this article, you will no longer need to fear.  Now I feel much more confident, because I understood how everything works, and I know that I can <strong>trust the</strong> language and the compiler. </p><br><h2 id="apply">  Apply </h2><br><pre> <code class="hljs kotlin"><span class="hljs-comment"><span class="hljs-comment">/** *    [block]   `this`        `this`. */</span></span> <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T&gt;</span></span></span><span class="hljs-function"> T.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Unit</span></span>): T { block(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }</code> </pre> <br><p>  <code>apply</code> is simple: it is an extension function that executes the <em>block</em> parameter in relation to an extended type instance (it is called the "receiver") and returns the receiver itself. </p><br><p>  There are many ways to use this feature.  You can bind the creation of an object to its initial configuration: </p><br><p> <code>val layout = LayoutStyle().apply { orientation = VERTICAL }</code> </p> <br><p>  As you can see, we provide the configuration for the new <code>LayoutStyle</code> right at creation, which contributes to the <strong>purity of the code</strong> and the <strong>implementation, which is much less error prone</strong> .  Did it happen to call the method in relation to the wrong instance, because it had the same name?  Or even worse, when refactoring was completely wrong?  With the above approach it will be much more difficult to face such troubles.  Also note that it is not necessary to define the <code>this</code> parameter: we are <strong>in the same scope as the class itself</strong> .  It‚Äôs as if we were extending the class itself, so <code>this</code> is implicitly specified. </p><br><p>  But how does this work?  Let's take a quick example. </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ VERTICAL, HORIZONTAL } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutStyle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation = HORIZONTAL } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layout = LayoutStyle().apply { orientation = VERTICAL } }</code> </pre> <br><p>  Thanks to the IntelliJ IDEA Show Kotlin bytecode tool ( <code>Tools &gt; Kotlin &gt; Show Kotlin Bytecode</code> ), we can see how the compiler converts our code into JVM bytecode: </p><br><pre> <code class="hljs swift"><span class="hljs-type"><span class="hljs-type">NEW</span></span> kotlindeepdive/<span class="hljs-type"><span class="hljs-type">LayoutStyle</span></span> <span class="hljs-type"><span class="hljs-type">DUP</span></span> <span class="hljs-type"><span class="hljs-type">INVOKESPECIAL</span></span> kotlindeepdive/<span class="hljs-type"><span class="hljs-type">LayoutStyle</span></span>.&lt;<span class="hljs-keyword"><span class="hljs-keyword">init</span></span>&gt; ()<span class="hljs-type"><span class="hljs-type">V</span></span> <span class="hljs-type"><span class="hljs-type">ASTORE</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">ALOAD</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">ASTORE</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">ALOAD</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-type"><span class="hljs-type">GETSTATIC</span></span> kotlindeepdive/<span class="hljs-type"><span class="hljs-type">Orientation</span></span>.<span class="hljs-type"><span class="hljs-type">VERTICAL</span></span> : <span class="hljs-type"><span class="hljs-type">Lkotlindeepdive</span></span>/<span class="hljs-type"><span class="hljs-type">Orientation</span></span>; <span class="hljs-type"><span class="hljs-type">INVOKEVIRTUAL</span></span> kotlindeepdive/<span class="hljs-type"><span class="hljs-type">LayoutStyle</span></span>.setOrientation (<span class="hljs-type"><span class="hljs-type">Lkotlindeepdive</span></span>/<span class="hljs-type"><span class="hljs-type">Orientation</span></span>;)<span class="hljs-type"><span class="hljs-type">V</span></span> <span class="hljs-type"><span class="hljs-type">ALOAD</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-type"><span class="hljs-type">ASTORE</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br><p>  If you are not too good at bytecode, then I suggest reading <a href="http://www.javaworld.com/article/2077233/core-java/bytecode-basics.html">these</a> <a href="https://arhipov.blogspot.de/2011/01/java-bytecode-fundamentals.html">wonderful</a> <a href="https://www.wikiwand.com/en/Java_bytecode_instruction_listings">articles</a> , after them you will understand much better (remember that when calling each method, the stack is accessed, so the compiler needs to load the object each time). </p><br><p>  We will sort by points: </p><br><ol><li>  A new instance of <code>LayoutStyle</code> and duplicated <code>LayoutStyle</code> stack. </li><li>  Called constructor with zero parameters. </li><li>  The operations are performed store / load (about this - below). </li><li>  The value of <code>Orientation.VERTICAL</code> passed to the stack. </li><li>  Called <code>setOrientation</code> , which raises an object and a value from the stack. </li></ol><br><p>  Here we note a couple of things.  First, no magic is involved, everything happens as expected: the <code>LayoutStyle</code> method is called for the <code>setOrientation</code> instance we created.  In addition, the <code>apply</code> function is nowhere to be seen, because the compiler <a href="https://kotlinlang.org/docs/reference/inline-functions.html"><strong>inline</strong> it</a> . </p><br><p>  Moreover, the bytecode is almost identical to the one generated by using only Java!  Judge for yourself: </p><br><pre> <code class="hljs pgsql">// Java enum Orientation { VERTICAL, HORIZONTAL; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> LayoutStyle { private Orientation orientation = HORIZONTAL; <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> Orientation getOrientation() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> setOrientation(Orientation orientation) { this.orientation = orientation; } <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> main(String[] args) { LayoutStyle layout = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> LayoutStyle(); layout.setOrientation(VERTICAL); } } // Bytecode <span class="hljs-built_in"><span class="hljs-built_in">NEW</span></span> kotlindeepdive/LayoutStyle DUP ASTORE <span class="hljs-number"><span class="hljs-number">1</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">1</span></span> GETSTATIC kotlindeepdive/Orientation.VERTICAL : kotlindeepdive/Orientation; INVOKEVIRTUAL kotlindeepdive/LayoutStyle.setOrientation (kotlindeepdive/Orientation;)V</code> </pre> <br><p>  <em>Tip: You may have noticed a large number of <code>ASTORE/ALOAD</code> .</em>  <em>They are inserted by the Kotlin compiler, so the debugger works for lambdas too!</em>  <em>We will talk about this in the last section of the article.</em> </p><br><h2 id="with">  With </h2><br><pre> <code class="hljs kotlin"><span class="hljs-comment"><span class="hljs-comment">/** *    [block]   [receiver]       . */</span></span> <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">with</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(receiver: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">, block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; R): R = receiver.block()</code> </pre> <br><p>  <code>with</code> looks similar to <code>apply</code> , but there are some important differences.  First, <code>with</code> not a type extension function: the receiver must be explicitly passed as a parameter.  Moreover, <code>with</code> returns the result of the <em>block</em> function, and <code>apply</code> - the recipient itself. </p><br><p>  Since we can return anything, this example looks very believable: </p><br><pre> <code class="hljs scala"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layout = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(contextWrapper) { <span class="hljs-comment"><span class="hljs-comment">// `this` is the contextWrapper LayoutStyle(context, attrs).apply { orientation = VERTICAL } }</span></span></code> </pre> <br><p>  Here you can omit the <code>contextWrapper</code> prefix.  for <code>context</code> and <code>attrs</code> , because <code>contextWrapper</code> is the receiver of the <code>with</code> function.  But even in this case, the application methods are not so obvious as compared to <code>apply</code> , this function may be useful under certain conditions. </p><br><p>  Given this, let us return to our example and see what happens if we use <code>with</code> : </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ VERTICAL, HORIZONTAL } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutStyle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation = HORIZONTAL } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SharedState { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> previousOrientation = VERTICAL } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layout = with(SharedState) { LayoutStyle().apply { orientation = previousOrientation } } }</code> </pre> <br><p>  The recipient <code>with</code> is a <code>SharedState</code> singleton, it contains an orientation parameter (orientation parameter) that we want to set for our layout.  Inside the <em>block</em> function, we create an instance of <code>LayoutStyle</code> , and thanks to <code>apply</code> we can simply set the orientation, reading it from <code>SharedState</code> . </p><br><p>  Look again at the generated bytecode: </p><br><pre> <code class="hljs pgsql">GETSTATIC kotlindeepdive/SharedState.INSTANCE : Lkotlindeepdive/SharedState; ASTORE <span class="hljs-number"><span class="hljs-number">1</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">1</span></span> ASTORE <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NEW</span></span> kotlindeepdive/LayoutStyle DUP INVOKESPECIAL kotlindeepdive/LayoutStyle.&lt;init&gt; ()V ASTORE <span class="hljs-number"><span class="hljs-number">3</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">3</span></span> ASTORE <span class="hljs-number"><span class="hljs-number">4</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">4</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">2</span></span> INVOKEVIRTUAL kotlindeepdive/SharedState.getPreviousOrientation ()Lkotlindeepdive/Orientation; INVOKEVIRTUAL kotlindeepdive/LayoutStyle.setOrientation (Lkotlindeepdive/Orientation;)V ALOAD <span class="hljs-number"><span class="hljs-number">3</span></span> ASTORE <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span></code> </pre> <br><p>  Nothing special.  Singleton extracted, implemented as a static field in the <code>SharedState</code> class;  an instance of <code>LayoutStyle</code> is created in the same way as before, a constructor is called, another call to get the <code>previousOrientation</code> value inside a <code>SharedState</code> and the last call to assign a value to an instance of <code>LayoutStyle</code> . </p><br><p>  <em>Tip: when using Show Kotlin Bytecode, you can click Decompile and see the Java representation of the bytecode created for the Kotlin compiler.</em>  <em>Spoiler: it will be exactly as you expect!</em> </p><br><h2 id="let">  Let </h2><br><pre> <code class="hljs kotlin"><span class="hljs-comment"><span class="hljs-comment">/** *    [block]   `this`      . */</span></span> <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> T.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">let</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: (</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; R): R = block(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)</code> </pre> <br><p>  <code>let</code> very useful when working with objects that can be null.  Instead of creating endless chains of if-else expressions, you can simply combine the operator <code>?</code>  (called the ‚Äúsafe call operator‚Äù) with <code>let</code> : as a result, you get a lambda, in which the argument <code>it</code> is a non-nullable version of the original object. </p><br><pre> <code class="hljs mel">val <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span> = LayoutStyle() SharedState.previousOrientation?.let { <span class="hljs-keyword"><span class="hljs-keyword">layout</span></span>.orientation = it }</code> </pre> <br><p>  Consider the whole example: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ VERTICAL, HORIZONTAL } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutStyle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation = HORIZONTAL } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SharedState { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> previousOrientation: Orientation? = VERTICAL } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layout = LayoutStyle() <span class="hljs-comment"><span class="hljs-comment">// layout.orientation = SharedState.previousOrientation -- this would NOT work! SharedState.previousOrientation?.let { layout.orientation = it } }</span></span></code> </pre> <br><p>  Now <code>previousOrientation</code> can be null.  If we try to assign it directly to our layout, the compiler will be indignant, because the nullable type cannot be assigned to the non-nullable type.  Of course, you can write an if expression, but this will lead to a double reference to the <code>SharedState.previousOrientation</code> expression.  And if we use <code>let</code> , we get a non-nullable link to the same parameter that can be safely assigned to our layout. <br>  From the point of view of bytecode, everything is very simple: </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">NEW</span></span> kotlindeepdive/<span class="hljs-keyword"><span class="hljs-keyword">let</span></span>/LayoutStyle DUP INVOKESPECIAL kotlindeepdive/<span class="hljs-keyword"><span class="hljs-keyword">let</span></span>/LayoutStyle.&lt;init&gt; ()V GETSTATIC kotlindeepdive/<span class="hljs-keyword"><span class="hljs-keyword">let</span></span>/SharedState.INSTANCE : Lkotlindeepdive/<span class="hljs-keyword"><span class="hljs-keyword">let</span></span>/SharedState; INVOKEVIRTUAL kotlindeepdive/<span class="hljs-keyword"><span class="hljs-keyword">let</span></span>/SharedState.getPreviousOrientation ()Lkotlindeepdive/<span class="hljs-keyword"><span class="hljs-keyword">let</span></span>/Orientation; DUP IFNULL L2 ASTORE <span class="hljs-number"><span class="hljs-number">1</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">1</span></span> ASTORE <span class="hljs-number"><span class="hljs-number">2</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">2</span></span> INVOKEVIRTUAL kotlindeepdive/<span class="hljs-keyword"><span class="hljs-keyword">let</span></span>/LayoutStyle.setOrientation (Lkotlindeepdive/<span class="hljs-keyword"><span class="hljs-keyword">let</span></span>/Orientation;)V <span class="hljs-keyword"><span class="hljs-keyword">GOTO</span></span> L9 L2 POP L9 RETURN</code> </pre> <br><p>  It uses a simple <code>IFNULL</code> conditional transition, which, in fact, you would have to do manually, except for this time, when the compiler effectively executes it for you, and the language offers a pleasant way of writing such code.  I think this is great! </p><br><h2 id="run">  Run </h2><br><p>  <em>There are two versions of the run: the first is a simple function, the second is an extension function of a generic type (generic type).</em>  <em>Since the first only calls the function block, which is passed as a parameter, we will analyze the second.</em> </p><br><pre> <code class="hljs kotlin"><span class="hljs-comment"><span class="hljs-comment">/** *    [block]   `this`      . */</span></span> <span class="hljs-meta"><span class="hljs-meta">@kotlin</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">internal</span></span>.InlineOnly <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-type"><span class="hljs-function"><span class="hljs-type">&lt;T, R&gt;</span></span></span><span class="hljs-function"> T.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(block: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span><span class="hljs-function"><span class="hljs-params">.()</span></span></span></span> -&gt; R): R = block()</code> </pre> <br><p>  Perhaps, <code>run</code> is the simplest of the functions considered.  It is defined as an extension function of the type, whose instance is then passed as the receiver and returns the result of executing the <code>block</code> function.  It may seem that <code>run</code> is a hybrid of <code>let</code> and <code>apply</code> , and this is true.  The only difference is in the return value: in the case of <code>apply</code> we return the receiver itself, and in the case of <code>run</code> , the result of the <code>block</code> function (as in <code>let</code> ). </p><br><p>  This example emphasizes the fact that <code>run</code> returns the result of the <code>block</code> function, in this case, the assignment ( <code>Unit</code> ): </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ VERTICAL, HORIZONTAL } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutStyle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation = HORIZONTAL } <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> SharedState { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> previousOrientation = VERTICAL } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layout = LayoutStyle() layout.run { orientation = SharedState.previousOrientation } <span class="hljs-comment"><span class="hljs-comment">// returns Unit }</span></span></code> </pre> <br><p>  Equivalent bytecode: </p><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">NEW</span></span> kotlindeepdive/LayoutStyle DUP INVOKESPECIAL kotlindeepdive/LayoutStyle.&lt;init&gt; ()V ASTORE <span class="hljs-number"><span class="hljs-number">0</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">0</span></span> ASTORE <span class="hljs-number"><span class="hljs-number">1</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">1</span></span> ASTORE <span class="hljs-number"><span class="hljs-number">2</span></span> ALOAD <span class="hljs-number"><span class="hljs-number">2</span></span> GETSTATIC kotlindeepdive/SharedState.INSTANCE : Lkotlindeepdive/SharedState; INVOKEVIRTUAL kotlindeepdive/SharedState.getPreviousOrientation ()Lkotlindeepdive/Orientation; INVOKEVIRTUAL kotlindeepdive/LayoutStyle.setOrientation (Lkotlindeepdive/Orientation;)V <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span></code> </pre> <br><p>  <code>run</code> was inline, like other functions, and it all comes down to simple method calls.  Here, too, there is nothing strange! </p><br><hr><br><p>  We noted that there are many similarities between the functions of the standard library: this is done intentionally to cover as many applications as possible.  On the other hand, it is not so easy to understand which of the functions is best suited for a particular task, given the small differences between them. </p><br><p>  To help you deal with the standard library, I drew a table that summarizes all the differences between the main features considered (except <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html">also</a> ): </p><br><p><img src="https://habrastorage.org/web/864/503/fbf/864503fbfb9c4d0ca9f516b89f78b1e9.png" alt="image"></p><br><h2 id="prilozhenie-dopolnitelnye-operacii-storeload">  Appendix: additional <code>store/load</code> operations </h2><br><p>  I still could not fully understand when comparing "Java-bytecode" and "Kotlin-bytecode".  As I said before, in Kotlin, unlike Java, there were additional operations <code>astore/aload</code> .  I knew that it was somehow connected with lambdas, but I could figure out why they were needed. </p><br><p>  It seems that these additional operations are necessary for the debugger to <strong>process lambdas as <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html">stack frames</a></strong> , which allows us to intervene (step into) in their work.  We can see what the local variables are, who causes the lambda, who will be called from the lambda, etc. </p><br><p>  But when we send the APK to production, we don‚Äôt care about the debugger‚Äôs capabilities, right?  So, these functions can be considered redundant and subject to removal, despite their small size and insignificance. </p><br><p>  For this, <strong><a href="https://www.guardsquare.com/en/proguard">ProGuard</a></strong> , a well-known and well-loved tool, can be suitable.  It works at the bytecode level and, in addition to obfuscation and cutting, also performs optimization passes to make the bytecode more compact.  I wrote the same piece of Java and Kotlin code, applied it to both versions of ProGuard with one set of rules, and compared the results.  That's what came to light. </p><br><h3 id="konfiguraciya-proguard">  ProGuard configuration </h3><br><pre> <code class="hljs pgsql">-dontobfuscate -dontshrink -<span class="hljs-keyword"><span class="hljs-keyword">verbose</span></span> -keep,allowoptimization <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> kotlindeepdive.apply.LayoutStyle -optimizationpasses <span class="hljs-number"><span class="hljs-number">2</span></span> -keep,allowoptimization <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> kotlindeepdive.LayoutStyleJ</code> </pre> <br><h3 id="ishodnyy-kod">  Source </h3><br><p>  Java: </p><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> kotlindeepdive <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> OrientationJ { VERTICAL, HORIZONTAL; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutStyleJ</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> OrientationJ orientation = HORIZONTAL; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrientationJ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrientation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> orientation; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LayoutStyleJ</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (System.currentTimeMillis() &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { main(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setOrientation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OrientationJ orientation)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.orientation = orientation; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> OrientationJ </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ LayoutStyleJ layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LayoutStyleJ(); layout.setOrientation(VERTICAL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> layout.orientation; } }</code> </pre> <br><p>  Kotlin: </p><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> kotlindeepdive.apply <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Orientation</span></span></span><span class="hljs-class"> </span></span>{ VERTICAL, HORIZONTAL } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LayoutStyle</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> orientation = Orientation.HORIZONTAL <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (System.currentTimeMillis() &lt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { main() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> layout = LayoutStyle().apply { orientation = Orientation.VERTICAL } layout.orientation } }</code> </pre> <br><h3 id="baytkod">  Baytkod </h3><br><p>  Java: </p><br><pre> <code class="hljs pgsql"> sgotti@Sebastianos-MBP ~/Desktop/proguard5<span class="hljs-number"><span class="hljs-number">.3</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>/lib/PD/kotlindeepdive &gt; javap -c LayoutStyleJ.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Compiled <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "SimpleJ.java" final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> kotlindeepdive.LayoutStyleJ { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> kotlindeepdive.LayoutStyleJ(); Code: <span class="hljs-number"><span class="hljs-number">0</span></span>: aload_0 <span class="hljs-number"><span class="hljs-number">1</span></span>: invokespecial #<span class="hljs-number"><span class="hljs-number">8</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> java/lang/<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>."&lt;init&gt;":()V <span class="hljs-number"><span class="hljs-number">4</span></span>: aload_0 <span class="hljs-number"><span class="hljs-number">5</span></span>: getstatic #<span class="hljs-number"><span class="hljs-number">6</span></span> // Field kotlindeepdive/OrientationJ.HORIZONTAL<span class="hljs-meta"><span class="hljs-meta">$5</span></span>c1d747f:I <span class="hljs-number"><span class="hljs-number">8</span></span>: putfield #<span class="hljs-number"><span class="hljs-number">5</span></span> // Field orientation<span class="hljs-meta"><span class="hljs-meta">$5</span></span>c1d747f:I <span class="hljs-number"><span class="hljs-number">11</span></span>: invokestatic #<span class="hljs-number"><span class="hljs-number">9</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> java/lang/<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.currentTimeMillis:()J <span class="hljs-number"><span class="hljs-number">14</span></span>: lconst_1 <span class="hljs-number"><span class="hljs-number">15</span></span>: lcmp <span class="hljs-number"><span class="hljs-number">16</span></span>: ifge <span class="hljs-number"><span class="hljs-number">34</span></span> <span class="hljs-number"><span class="hljs-number">19</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> #<span class="hljs-number"><span class="hljs-number">3</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> kotlindeepdive/LayoutStyleJ <span class="hljs-number"><span class="hljs-number">22</span></span>: dup <span class="hljs-number"><span class="hljs-number">23</span></span>: invokespecial #<span class="hljs-number"><span class="hljs-number">10</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> "&lt;init&gt;":()V <span class="hljs-number"><span class="hljs-number">26</span></span>: getstatic #<span class="hljs-number"><span class="hljs-number">7</span></span> // Field kotlindeepdive/OrientationJ.VERTICAL<span class="hljs-meta"><span class="hljs-meta">$5</span></span>c1d747f:I <span class="hljs-number"><span class="hljs-number">29</span></span>: pop <span class="hljs-number"><span class="hljs-number">30</span></span>: iconst_1 <span class="hljs-number"><span class="hljs-number">31</span></span>: putfield #<span class="hljs-number"><span class="hljs-number">5</span></span> // Field orientation<span class="hljs-meta"><span class="hljs-meta">$5</span></span>c1d747f:I <span class="hljs-number"><span class="hljs-number">34</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><p>  Kotlin: </p><br><pre> <code class="hljs pgsql"> sgotti@Sebastianos-MBP ~/Desktop/proguard5<span class="hljs-number"><span class="hljs-number">.3</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span>/lib/PD/kotlindeepdive &gt; javap -c apply/LayoutStyle.<span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Compiled <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> "Apply.kt" <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> kotlindeepdive.apply.LayoutStyle { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> kotlindeepdive.apply.LayoutStyle(); Code: <span class="hljs-number"><span class="hljs-number">0</span></span>: aload_0 <span class="hljs-number"><span class="hljs-number">1</span></span>: invokespecial #<span class="hljs-number"><span class="hljs-number">13</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> java/lang/<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>."&lt;init&gt;":()V <span class="hljs-number"><span class="hljs-number">4</span></span>: aload_0 <span class="hljs-number"><span class="hljs-number">5</span></span>: getstatic #<span class="hljs-number"><span class="hljs-number">11</span></span> // Field kotlindeepdive/apply/Orientation.HORIZONTAL:Lkotlindeepdive/apply/Orientation; <span class="hljs-number"><span class="hljs-number">8</span></span>: putfield #<span class="hljs-number"><span class="hljs-number">10</span></span> // Field orientation:Lkotlindeepdive/apply/Orientation; <span class="hljs-number"><span class="hljs-number">11</span></span>: invokestatic #<span class="hljs-number"><span class="hljs-number">14</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> java/lang/<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.currentTimeMillis:()J <span class="hljs-number"><span class="hljs-number">14</span></span>: lconst_1 <span class="hljs-number"><span class="hljs-number">15</span></span>: lcmp <span class="hljs-number"><span class="hljs-number">16</span></span>: ifge <span class="hljs-number"><span class="hljs-number">32</span></span> <span class="hljs-number"><span class="hljs-number">19</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> #<span class="hljs-number"><span class="hljs-number">8</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> kotlindeepdive/apply/LayoutStyle <span class="hljs-number"><span class="hljs-number">22</span></span>: dup <span class="hljs-number"><span class="hljs-number">23</span></span>: invokespecial #<span class="hljs-number"><span class="hljs-number">16</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">Method</span></span> "&lt;init&gt;":()V <span class="hljs-number"><span class="hljs-number">26</span></span>: getstatic #<span class="hljs-number"><span class="hljs-number">12</span></span> // Field kotlindeepdive/apply/Orientation.VERTICAL:Lkotlindeepdive/apply/Orientation; <span class="hljs-number"><span class="hljs-number">29</span></span>: putfield #<span class="hljs-number"><span class="hljs-number">10</span></span> // Field orientation:Lkotlindeepdive/apply/Orientation; <span class="hljs-number"><span class="hljs-number">32</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br><p>  Conclusions after comparing the two bytecode listings: </p><br><ol><li>  Additional <code>astore/aload</code> in ‚ÄúKotlin-bytecode‚Äù disappeared, because ProGuard considered them redundant and immediately deleted (curiously, this required two optimization passes, after one they were not deleted). </li><li>  ‚ÄúJava bytecode‚Äù and ‚ÄúKotlin bytecode‚Äù are almost identical.  In the first there are interesting / strange moments when working with enum-value, and in Kotlin there is nothing like that. </li></ol><br><h2 id="zaklyuchenie">  Conclusion </h2><br><p>  It's great to get a new language offering so many possibilities to developers.  But it is also important to know that we can rely on the tools used, and feel confident when working with them.  I'm glad I can say: ‚ÄúI trust Kotlin‚Äù, in the sense that I know: the compiler does nothing extra or risky.  It only does what we need to do manually in Java, saving us time and resources (and returns the long lost joy of coding for the JVM).  To some extent, this also benefits the end users, because, due to more stringent type safety, we will leave fewer bugs in the applications. </p><br><p>  In addition, the Kotlin compiler is constantly improving, so that the generated code becomes more efficient.  So no need to try to optimize Kotlin-code using the compiler, it is better to focus on writing more efficient and idiomatic code, leaving everything else to the compiler. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/331442/">https://habr.com/ru/post/331442/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../331432/index.html">SIP: this growth does not stop</a></li>
<li><a href="../331434/index.html">We put Selenium Grid on Apache Mesos wheels</a></li>
<li><a href="../331436/index.html">Monitoring System Delays with JHiccup</a></li>
<li><a href="../331438/index.html">Artificial Intelligence Half-Life SDK: Retrospective</a></li>
<li><a href="../331440/index.html">Medici effect or is it possible to cross a peach and melon or Windows and iOs</a></li>
<li><a href="../331444/index.html">Dynamic Apache NiFi cluster creation</a></li>
<li><a href="../331446/index.html">Abnormal GraphQL in Electron or as I wrote a desktop client for Tinder</a></li>
<li><a href="../331448/index.html">‚ÄúI can't just walk with the flag‚Äú Postgres - our everything ‚Äù. We need to prove with our hands that this works ‚Äù- Alexey Lustin</a></li>
<li><a href="../331450/index.html">Post-mortem Age of Empires</a></li>
<li><a href="../331452/index.html">Make QR Codes Great Again or Apple‚Äôs Camera Revolution</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>