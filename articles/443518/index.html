<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>RBKmoney Payments under the hood - microservices, protocols and platform configuration</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi Habr! RBKmoney gets in touch again and continues the series of articles on how to write payment processing with your own hands. 





 I wanted to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>RBKmoney Payments under the hood - microservices, protocols and platform configuration</h1><div class="post__text post__text-html js-mediator-article"><p>  Hi Habr!  RBKmoney gets in touch again and continues the series of articles on how to write payment processing with your own hands. </p><br><p><img src="https://habrastorage.org/webt/nc/w-/dh/ncw-dhwzrbb-b84-afrgy1syhri.jpeg"></p><br><p>  I wanted to immediately immerse myself in the details of the description of the implementation of the payment business process as a finite state machine, to show examples of such a machine with a set of events, implementation features ... But, it seems, we cannot do without a couple of review articles.  Too large was the subject area.  In this post, the nuances of work and interactions between microservices of our platform, interaction with external systems and how we manage the business configuration will be revealed. <a name="habracut"></a></p><br><h3 id="makroservis">  Macroservice </h3><br><p>  Our system consists of a set of microservices, which, realizing each of its complete part of business logic, interact with each other and together form a macroservice.  Actually, the macroservice deployed in the data center, connected to banks and other payment systems - this is our payment processing. </p><br><h4 id="shablon-mikroservisa">  Microservice template </h4><br><p>  We use a unified approach to the development of any microservice in whatever language it is written.  Each microservice is a Docker container, which contains: </p><br><ul><li>  the application itself that implements business logic written in Erlang or Java; </li><li>  RPClib - a library that implements the communication between microservices; <br><ul><li>  we use Apache Thrift, its main advantages are ready-made client-server libraries and the possibility of a strictly typed description of all public methods that each microservice gives; </li><li> The second feature of the library is our implementation of <a href="https://ai.google/research/pubs/pub36356">Google Dapper</a> , which allows us the ability to quickly trace requests by a simple search in Elasticsearch.  The first microservice that receives a request from an external system generates a unique <code>trace_id</code> , which is saved by each subsequent request chain.  Also, we generate and save <code>parent_id</code> and <code>span_id</code> , which allows us to build a query tree, visually controlling the entire chain of microservices involved in processing the request; </li><li>  the third feature is actively using the transport at the transport level of different information about the context of the request.  For example, the deadline (set on the client the expected lifetime of the request), or on whose behalf we perform a call to a particular method; </li></ul></li><li>  Consul template is a service discovery agent that maintains information about the location, availability and status of microservice.  Microservices find each other by DNS names, TTL zones are zero, a dead or unchecked healthcheck service stops resolving and thus receives traffic; </li><li>  the logs that the application writes in the format understandable for Elasticsearch in the local container file and <code>filebeat</code> , which is running on the host machine relative to the container, picks up these logs and sends them to the Elasticsearch cluster; <br><ul><li>  since we implement the platform using Event Sourcing models, the resulting chains of logs are also used for visualization in the form of different Grafana-dashboards, which allows us to reduce the time for the implementation of different metrics (we also use some metrics). </li></ul></li></ul><br><p><img src="https://habrastorage.org/webt/2v/ac/a2/2vaca2u7qtih8_1iqtl0h_2ywoq.jpeg"></p><br><p>  When developing microservices, we use restrictions that we have specially designed to solve the problem of both high availability of the platform and its resiliency: </p><br><ul><li>  strict memory limits for each container, when going out of limits - OOM, most microservices live within 256-512M.  This makes it more fragile to split the implementation of business logic, protects from drift towards the monolith, reduces the cost of the point of failure, provides an opportunity to work on cheap hardware (the platform is deployed and runs on low-cost single-dual-processor servers); </li><li>  as few stateful microservices as possible and as many stateless implementations as possible.  This allows solving problems of fault tolerance, speed of recovery and in general, minimization of places with potentially incomprehensible behavior.  This becomes especially important with an increase in the lifetime of the system when a large Legacy accumulates; </li><li>  approaches let it crash and "it will surely break."  We know that any part of our system will fail, so we design so that it does not affect the overall correctness of the information accumulated in the platform.  Helps minimize the number of undefined states in the system. </li></ul><br><p>  <em>Certainly familiar to many who integrate with third parties the situation.</em>  <em>We expected a response from a third party to the request for withdrawal of money according to the protocol, but a completely different answer came, not described in any specification that is unknown how to interpret.</em> </p><br><p>  In such a situation, we kill the state machine servicing this payment, any actions on it outside will receive error 500. And inside we find out the current status of the payment, bring the state of the machine in line with reality and revitalize the state machine. </p><br><h2 id="protocol-oriented-development">  Protocol Oriented Development </h2><br><p><img src="https://habrastorage.org/webt/my/8p/o1/my8po16kkxanpoanxnzrea_i7gg.jpeg"></p><br><p>  At the time of writing this article, 636 different checks for services that ensure the functioning of the platform have been registered in our Service Discovery.  Even if we take into account that several checks go on one service, and also that most stateless services work at least in a triple instance, it still turns out to be about fifty applications that need to be able to somehow be connected with each other and not fail in RPC hell. </p><br><p>  The situation is complicated by the fact that we have three development languages ‚Äã‚Äãon the stack - Erlang, Java, JS and they all need to be able to communicate transparently with each other. </p><br><p>  The first task that had to be solved was to design the correct data exchange architecture between microservices.  We took Apache Thrift as a basis.  All microservices exchange trifto binary files, using HTTP as the transport. </p><br><p>  Trifet specifications are hosted as separate repositories in our github, so they are available to any developer who has access to them.  Initially, they used one common repository for all protocols, but over time they came to the conclusion that this was inconvenient - joint parallel work on protocols turned into a constant headache.  Different teams and even different developers were forced to agree on the names of variables, an attempt to divide into namespaces also did not help. </p><br><p>  In general, we can say that we have protocol-driven development.  Before starting any implementation, we develop the future protocol of microservice in the form of a trift specification, go through 7 laps of the review, attracting future clients of this microservice, and get the opportunity to simultaneously start developing several microservices in parallel, because we know all its future methods and we can write their handlers optionally using moki. </p><br><p>  A separate step in the protocol development process is security-review, where guys look at the nuances of the specification being developed from their pentester point of view. </p><br><p>  We also found it expedient to single out a separate role of the protocol owner in the team.  The task is complex, a person has to keep in mind the specifics of the work of all microservices, but it pays for itself in a large order and with a single point of escalation. </p><br><p>  Without the final approval of the pull request by these employees, the protocol cannot be merged into a master branch.  In githaba there is a very convenient functionality for this - <a href="https://help.github.com/en/articles/about-code-owners">codeowners</a> , we use it with pleasure. </p><br><p>  Thus, we solved the problem of communication between microservices, possible problems of misunderstanding, what microservice appeared in the platform, and what it is for.  This set of protocols is probably the only part of the platform where we certainly choose quality against the cost and speed of development, because the implementation of one microservice can be rewritten relatively painlessly, and the protocol on which several dozen is tied is already expensive and painful. </p><br><p>  Along the way, careful logging helps in solving the problem of documentation.  Reasonably selected method and parameter names, few comments, and a self-documented specification saves a lot of time! </p><br><p>  For example, the specification of the method of one of our microservices looks like this, which allows you to get a list of events that occurred in the platform: </p><br><pre> <code class="plaintext hljs">/**    */ typedef i64 EventID /* Event sink service definitions */ service EventSink { /** *       ,   *    ,  ,  `range`.  *      `0`  `range.limit` . * *   `range.after`    ,   * ,        , *   `EventNotFound`. */ Events GetEvents (1: EventRange range) throws (1: EventNotFound ex1, 2: base.InvalidRequest ex2) /** *         *  . */ base.EventID GetLastEventID () throws (1: NoLastEvent ex1) } /* Events */ typedef list&lt;Event&gt; Events /** * ,    -,  . */ struct Event { /** *  . *    ,     *      (total order). */ 1: required base.EventID id /** *   . */ 2: required base.Timestamp created_at /** *  -,  . */ 3: required EventSource source /** *  ,    ( ) *   -,  . */ 4: required EventPayload payload /** *      . *    . */ 5: optional base.SequenceID sequence } // Exceptions exception EventNotFound {} exception NoLastEvent {} /** * ,       -   */ exception InvalidRequest { /**          */ 1: required list&lt;string&gt; errors }</code> </pre> <br><h3 id="thrift-console-client">  Thrift console client </h3><br><p>  Sometimes we are faced with the task of calling certain methods of the required microservice directly, for example, with hands from the terminal.  This is useful for debugging, getting some kind of data set in raw form or in the case when the task is so rare that the development of a separate user interface is inappropriate. </p><br><p>  Therefore, we have developed a tool for ourselves that combines <code>curl</code> functions, but allows you to make triple requests in the form of JSON structures.  We <code>woorl</code> it accordingly - <code>woorl</code> .  The utility is universal; it is enough to pass the location of any trift specification to the command line parameter, it will do the rest.  Very handy utility, you can start a payment directly from the terminal, for example. </p><br><p>  This is how the appeal directly to the platform microservice, which is responsible for managing requests (for example, to create a store), looks like.  I requested data from my test account: </p><br><p><img src="https://habrastorage.org/webt/zk/9f/zy/zk9fzypaopdlugw06vwkso2qt0q.jpeg"></p><br><p>  <em>Observant readers probably noticed one feature in the screenshot.</em>  <em>We don't like it either.</em>  <em>It is necessary to fasten the authorization triftovyh calls between microservices, it is necessary in a good way TLS there gash.</em>  <em>But while resources, as always, are not enough.</em>  <em>They were limited to total perimeter fencing in which processing microservices live.</em> </p><br><h2 id="protokoly-obscheniya-s-vneshnimi-sistemami">  Communication protocols with external systems </h2><br><p>  To publish outside the trift specifications and to force our merchants to communicate using a binary protocol, we found it too cruel to them.  It was necessary to choose a human readable protocol that would allow us to conveniently integrate with us, conduct debugging and be able to easily document.  We chose the Open API standard, also known as <a href="https://swagger.io/">Swagger</a> . </p><br><p>  Returning to the problem of documenting protocols, Swagger allows you to quickly and cheaply solve this problem.  There are many implementations of the beautiful design of the Swagger-specification in the form of developer documentation.  We looked through all that we could find and finally chose <a href="https://github.com/Rebilly/ReDoc">ReDoc</a> , the JS library, which accepts swagger.json as input, and at the output generates just such three-column documentation: <a href="https://developer.rbk.money/api/">https://developer.rbk.money/api/</a> . </p><br><p>  The approaches to the development of both protocols, internal Thrift and external Swagger are absolutely identical with us.  This adds time to development, but pays off over the long term. </p><br><p>  We also needed to solve one more important task - we not only accept requests for writing off money, but also send them further - to banks and payment systems. </p><br><p>  Making them implement our trift would be an even more impossible task than to give it to public APIs. </p><br><p>  Therefore, we have come up with and implemented the concept of protocol adapters.  This is just another microservice, which one side implements our internal trift specification, which is the same for the entire platform, and the second is the specific protocol specific for a particular bank or PS. </p><br><p>  <em>The problems that arise when writing such adapters, when you have to interact with third parties, is a topic that is very rich in different stories.</em>  <em>In our practice, we have met different, answers like: "Of course, you can implement this function as described in the protocol that we gave you, but I do not give any guarantees. After 2 weeks, our person will leave the hospital room for all this answers, and you ask him for confirmation. "</em>  <em>Also, such situations are not rare: "here's your login and password from our server, go there and set everything up yourself."</em> </p><br><p>  <em>It seems to me that the case when we integrated with a payment partner, who, in turn, integrated with our platform and successfully made payments through us (it often happens, the business specifics of the payment industry), seems to me especially interesting.</em>  <em>The partner replied to our request for a test environment that he doesn‚Äôt have a test environment as such, but he can direct the traffic for integration with RBC, that is, with our platform, where we can be tested.</em>  <em>This is how we, through our partner, integrated with ourselves once.</em> </p><br><p>  Thus, we simply solved the problem of implementing mass parallel connection of various payment systems and other third parties.  In the absolute majority of cases, you do not need to touch the platform code, it is enough just to write adapters and add payment instruments to the enums. </p><br><p>  As a result, we have such a scheme of work - RBKmoney API microservices look outward (we call them Common API, or capi *, you saw them in the consul above), which validate the input data according to the public Swagger-specification, authorize clients, broadcast These methods are in our internal trift calls and send requests further along the chain to the next microservice.  In addition, these services implement another requirement for the platform, whose TZ was formulated as: "the system must always be able to get a cat." </p><br><p>  When we need to make a call to some external system, internal microservices pull the trift methods of the corresponding protocol adapter, they translate them into the language of a specific bank or payment system and send them outside. </p><br><h3 id="trudnosti-obratnoy-sovmestimosti-protokolov">  Protocol backward compatibility difficulties </h3><br><p>  The platform is constantly evolving, new functions are being added, old ones are changing.  In such conditions, it is necessary either to invest in supporting backward compatibility, or to constantly update dependent microservices.  And if the situation when the required field turns into an optional everything is simple, you can do nothing at all, then in the opposite case you have to spend additional resources. </p><br><p>  With a set of internal protocols, everything goes easier.  The payment industry rarely changes so much that there are some fundamentally new methods of interaction.  Let us take, for example, the task that is frequent for us - connecting a new provider with a new means of payment.  For example, local purse processing, which allows to process payments on the territory of Kazakhstan in tenge.  This is a new wallet for our platform, but it doesn‚Äôt differ in principle from the same Qiwi-wallet - it always has some unique identifier and methods that allow you to debit / cancel funds from it. </p><br><p>  Accordingly, our trift specification for all purse providers looks like this: </p><br><pre> <code class="plaintext hljs">typedef string DigitalWalletID struct DigitalWallet { 1: required DigitalWalletProvider provider 2: required DigitalWalletID id } enum DigitalWalletProvider { qiwi rbkmoney }</code> </pre> <br><p>  and adding a new payment instrument in the form of a new wallet simply complements the enum: </p><br><pre> <code class="plaintext hljs">enum DigitalWalletProvider { qiwi rbkmoney newwallet }</code> </pre> <br><p>  Now it remains to bump all microservices using this specification, synchronizing with the repository master with the specification and rolling them out via CI / CD. </p><br><p>  With external protocols more difficult.  Each update of the Swagger-specification, especially without backward compatibility, is practically unrealistic to apply within a reasonable time - it is unlikely that our partners keep free developer resources specifically for updating our platform. </p><br><p>  <em>And sometimes it is simply impossible, we periodically encounter situations like: ‚Äúthe programmer wrote us a store and left, took the source code with us, how it works, we don‚Äôt know, it works and we don‚Äôt touch it‚Äù.</em> </p><br><p>  Therefore, we are investing in supporting backward compatibility on external protocols.  In our architecture, this is slightly easier to do - since we use separate protocol adapters for each specific version of the Common API, we simply leave the old capi microservices to work, changing only the part that looks trift inside the platform, if necessary.  This is how <code>capi-v1</code> , <code>capi-v2</code> , <code>capi-v3</code> microservices appear and stay with us forever, and so on. </p><br><p>  What will happen when a <code>capi-v33</code> let's see, you'll have to deprecate some old versions, probably. </p><br><p>  <em>At this point, I usually begin to understand very well companies like Microsoft and all their pain in supporting backward compatibility solutions that have been around for decades.</em> </p><br><h2 id="nastraivaem-sistemu">  Configure the system </h2><br><p>  And, ending the topic, we will describe how we manage the business-specific settings of the platform. </p><br><p>  Simply making a payment is not as easy as it sounds.  For each payment, the business customer wants to attach a huge amount of conditions - from commission to, in principle, the possibility of a successful outcome depending on the time of day.  We set ourselves the task of digitizing the entire set of conditions that a business customer can come up with now and in the future and apply this set to each newly launched payment. </p><br><p>  As a result, we stopped at developing our own DSL, which we used to attach tools for convenient management, which allow us to describe the business model in the right way: selection of protocol adapters, description of the posting plan, according to which money will be scattered over accounts inside the system, setting limits, fees, categories and other things specific to the payment system. </p><br><p>  For example, when we want to take a commission of 1% for acquiring with the maestro and MS cards and scatter it over the accounts within the system, we configure the domain like this: </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"cash_flow"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"decisions"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"if_"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"any_of"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"condition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payment_tool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bank_card"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"definition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payment_system_is"</span></span>: <span class="hljs-string"><span class="hljs-string">"maestro"</span></span> } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"condition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payment_tool"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"bank_card"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"definition"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"payment_system_is"</span></span>: <span class="hljs-string"><span class="hljs-string">"mastercard"</span></span> } } } } } ] }, <span class="hljs-attr"><span class="hljs-attr">"then_"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"source"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"system"</span></span>: <span class="hljs-string"><span class="hljs-string">"settlement"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"destination"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"provider"</span></span>: <span class="hljs-string"><span class="hljs-string">"settlement"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"volume"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"share"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"parts"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"p"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">"q"</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"of"</span></span>: <span class="hljs-string"><span class="hljs-string">"operation_amount"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"details"</span></span>: <span class="hljs-string"><span class="hljs-string">"1% processing fee"</span></span> } ] } } ] } }</code> </pre> <br><p>  ,         ,   .     ,             JSON.    ,    ,    ,  .        ,  ,     .  ,  CVS/SVN-. </p><br><p>    "               ". , ,     ,     1%,   ,    ,    .    ,        ,   .         ,         . </p><br><p> <em> cvs-like        ,       .   ,    ‚Äî  stateless, ,               .         .         .</em> </p><br><p> <em>    -     .            ,      ,   .     ,    ,                   .</em> </p><br><p> <em>             .     ,   10   ,     ,           .</em> </p><br><p>     , ,    ,   -,       woorl-.    -        JSON-  .    -  JS,       ,      UX: </p><br><p><img src="https://habrastorage.org/webt/c0/ni/ge/c0nigeglg1reebztmvml6svc7ia.jpeg"></p><br><p>           ,    ,         ,          . </p><br><p>     , , . </p><br><p>        ,     ,       SaltStack. </p><br><p> ,    ! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/443518/">https://habr.com/ru/post/443518/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443506/index.html">Simple parser for youtube in google tables</a></li>
<li><a href="../443510/index.html">Laptop Compaq Armada 7700 - as the development of the line Compaq LTE</a></li>
<li><a href="../443512/index.html">Hakaton on data analysis in Nizhny Novgorod</a></li>
<li><a href="../443514/index.html">We write our network layer on Swift: a protocol-oriented approach</a></li>
<li><a href="../443516/index.html">Hacker Geohot decided to free up people from an AI simulation</a></li>
<li><a href="../443520/index.html">Choosing a car for an IT person, or tips for teapots from a teapot</a></li>
<li><a href="../443522/index.html">Hosting: options, comparisons, user statistics</a></li>
<li><a href="../443524/index.html">Flash animation in Unity3D do it yourself. Part One, Lyrical</a></li>
<li><a href="../443528/index.html">Amazon has released Open Distro for Elasticsearch</a></li>
<li><a href="../443530/index.html">Evolution of database infrastructure: from database and application on one server to streaming replication</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>