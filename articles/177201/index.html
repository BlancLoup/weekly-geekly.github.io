<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Porting the Genode OS Framework to a new hardware platform</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, more and more companies have shown interest in microkernel operating systems. These systems from the category of academic begin to move into...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Porting the Genode OS Framework to a new hardware platform</h1><div class="post__text post__text-html js-mediator-article">  Recently, more and more companies have shown interest in microkernel operating systems.  These systems from the category of academic begin to move into the category of operating systems for use in real products.  For example, the recently introduced Samsung Knox platform was built using OKL4 Microvisor.  It is very likely that there are much more such solutions, but not all manufacturers advertise the technologies used, since at the moment micronuclear systems are mainly used in the field of information security. <br><br>  A brief history of microkernel OS and a description of the most well-known projects were recently described by my colleague <a href="http://habrahabr.ru/users/sartakov/" class="user_link">sartakov</a> in the article " <a href="http://habrahabr.ru/post/171375/">Microkernels and FOSDEM'13</a> ".  I want to tell in more detail about the <a href="http://genode.org/">Genode OS Framework</a> and the process of porting it to a new hardware platform based on the ARM architecture processor.  As a core for Genode used <a href="http://os.inf.tu-dresden.de/fiasco/">Fiasco.OC</a> . <br><br><img src="https://habrastorage.org/storage2/a02/3d5/9d4/a023d59d400ed0b0616655673658818b.png"><br><a name="habracut"></a><br>  And so, what is the Genode OS Framework?  This is a framework for building an operating system based on a microkernel.  Genode provides a single API that allows you to use different microkernels to build the OS.  The following microkernels are currently supported: Codezero, Fiasco, Fiasco.OC, Nova, OKL4, Pistachio.  Work on the Linux kernel is also supported.  In addition, it is possible to run without the use of third-party cores (base-hw) on some platforms based on the ARM architecture. <br>  These cores support different processor architectures and may use some hardware features.  For example, the Fiasco.OC core can work on a large number of architectures, such as: x86, amd64, ARM (other architectures are available, but their support is not used in the Genode at the moment), and the Nova core is a micro-hypervisor for the x86 architecture and allows using hardware virtualization.  Through the use of the Genode framework, we can compile the application without any changes to the source code for use on any of the supported kernels. <br>  More information about Genode can be obtained from the documentation posted on the project website, as well as from materials read by Norman Feske for the " <a href="http://ksyslabs.ru/index.php%3Fnn%3D36">Summer School of System Programming Ksys labs</a> " 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Currently Genode + Fiasco.OC for ARM architecture supports the following platforms: Realview PBXA9, Versatile Express A9X4, Pandaboard (TI OMAP4), Freescale iMX53, Arndale (Samsung Exynos 5).  All of these debug boards are quite expensive, and some are generally very difficult to purchase.  Now there are many single-board PCs with a price of less than $ 100, which are used by enthusiasts both as debugging boards for learning about the operating system, and as a basis for prototyping and manufacturing their devices.  Linux is usually ported to these devices, and some even have documentation in open sources.  A good article with an overview of the available devices " <a href="http://habrahabr.ru/post/170031/">Choosing a mini computer for home creativity (DIY)</a> ".  Some platforms of the described boards are already supported by the Fiasco.OC core and do not require porting. <br><br>  As you may have guessed from the photo at the beginning of the post, I used the <a href="http://cubieboard.org/">Cubieboard</a> mini-PC based on the SoC <a href="http://linux-sunxi.org/A10">Allwinner A10</a> as a platform for porting. <br>  This platform is interesting for several reasons: <br>  - not too outdated architecture Cortex-A8; <br>  - availability of the source code of the U-Boot loader, the Linux kernel and the presence of documentation ‚Äúleaked‚Äù to the network in the form of a user manual; <br>  - a large set of peripherals (SATA, HDMI, etc.); <br>  - the presence of a large number of inexpensive ‚Äúhackable‚Äù devices on this chip (Cubieboard, Mele A1000 / A2000, and others). <br><br>  Consider this SoC in more detail. <br><img src="https://habrastorage.org/storage2/2d8/aa7/f3d/2d8aa7f3d7512922416ef2dc8dbd7027.png"><br>  CPU: ARM Cortex-A8 up to 1Ghz with support for NEON, VFPv3, Trustzone <br>  GPU: Mali 400 MP with support for Open GL ES 2.0 <br>  VPU: CedarX with FullHD video support. <br>  Periphery: 4xUSB Host, USB OTG, 4xSD / MMC, 8xUART, 4xSPI, 3xI2C, GPIO, SATA, HDMI, LCD-interface and others <br><br>  The core of Fiasco.OC supports the architecture of Cortex-A8 processors.  This means that in order to port it to a new platform, you only need to add support for the platform, the so-called <a href="http://ru.wikipedia.org/wiki/Board_Support_Package">Board Support Package</a> (BSP).  The BSP source code is located in the kernel / fiasco / src / kern / arm / bsp directory. <br>  The BSP for ARM architecture in Fiasco.OC includes: <br>  - driver interrupt controller; <br>  - driver timer; <br>  - UART driver; <br>  - implementation of a reset. <br>  In addition, the BSP includes a memory allocation configuration. <br>  The memory in A10, according to the user manual, is distributed as follows: <br><img src="https://habrastorage.org/storage2/0cb/844/6ca/0cb8446cabf050a658cb82232b39ffdf.png"><br>  In order for the OS to use memory, it must know the physical addresses.  These parameters are set in the Mem_layout class, mem_layout-arm-sun4i.cpp file: <br><pre><code class="cpp hljs">EXTENSION <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Mem_layout</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Virt_layout_sun4i : Address { Timer_map_base = Devices1_map_base + <span class="hljs-number"><span class="hljs-number">0x020C00</span></span>, Intc_map_base = Devices1_map_base + <span class="hljs-number"><span class="hljs-number">0x020400</span></span>, Uart_base = Devices1_map_base + <span class="hljs-number"><span class="hljs-number">0x028000</span></span>, Watchdog_map_base = Timer_map_base + <span class="hljs-number"><span class="hljs-number">0x90</span></span>, }; <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Phys_layout_sun4i : Address { Devices1_phys_base = <span class="hljs-number"><span class="hljs-number">0x01c00000</span></span>, Sdram_phys_base = <span class="hljs-number"><span class="hljs-number">0x40000000</span></span>, Flush_area_phys_base = <span class="hljs-number"><span class="hljs-number">0xe0000000</span></span>, }; };</code> </pre> <br>  An interrupt controller is required to handle events from various sources.  The driver of the interrupt controller is used to control the controller, performing such operations as: controller configuration, interrupt masking, processing function.  The driver code in the pic-arm-sun4i.cpp file. <br><br>  The timer is required to generate events, such as: end of time-slot or IPC timeout.  A10 has 6 timers.  As a timer for periodic interrupts, Timer0 is used.  In addition to general-purpose timers, the SoC also includes Watchdog and an RTC with an alarm clock.  To use the timer in the system mode, it must generate an interrupt every 1 ms.  Initialization of the timer and the necessary functions are implemented in the file timer-arm-sun4i.cpp. <br><br>  The UART driver is used by the kernel to display debug messages and access the JDB kernel debugger.  There is no initialization of the UART module in Fiasco.OC; it is believed that the bootloader has already configured it, in our case U-Boot.  The UART driver code is in the uart-arm-sun4i.cpp and kernel / fiasco / src / lib / uart / uart_sun4i.cc files. <br><br>  To perform a full reset of the processor, the Watchdog timer is used, the purpose of which is to reset the system when the code loops.  The implementation is in the reset-arm-sun4i.cpp file. <br><br>  After performing these steps, we get the BSP for the selected processor.  But the kernel still needs to be loaded.  Consider the Genode + Fiasco.OC boot process on the ARM architecture: <br><br>  1. When the ROM-boot starts, it searches for the bootloader on the SD card or boots from NAND when there is no SD card. <br>  2. U-Boot, executing startup scripts, loads the Genode image as an ELF or u-boot-image. <br>  3. The loaded module contains the Fiasco.OC kernel and all other executable files, such as: sigma0, root task (in Genode it is the core module) and user programs. <br>  4. The first bootstrap starts, which performs part of the operations necessary for the start of the kernel, such as: <br>  - scanning of available memory (not performed for all architectures, on ARM, the value of available memory is set in the configuration on the platform); <br>  - relocation of modules in memory (sigma0 and root tasks must be located in certain regions so that the kernel at launch can start them); <br>  - and directly launching the kernel. <br>  7. The kernel performs the necessary system initialization, starts the sigma0 and root task. <br>  8. The core module (which is the root task) starts up, which initializes the Genode services and allows you to run the applications we need using the configuration file. <br><br>  Correspondingly, to launch bootstrap on Cubieboard, he needs to know about this platform, so we add the required configuration l4 / mk / platforms / cubieboard.conf and l4 / pkg / bootstrap / server / src / platform / sun4i.cc.  In addition, you must implement the UART driver to display information about the download to the console. <br><br>  The final step in porting is to add the necessary configuration files to the Genode build system.  The process is simple, I will not describe, the changes can be viewed in the corresponding commit in the repository.  A good description of the build system was discussed in the " <a href="http://ksyslabs.ru/index.php%3Fnn%3D45">Genode OS Framework Programming Environment</a> " lecture. <br><br>  Source codes are on Github <a href="https://github.com/Ksys-labs/genode">https://github.com/Ksys-labs/genode</a> in the tutorials branch.  A modified version of Fiasco.OC in the <a href="https://github.com/Ksys-labs/foc">https://github.com/Ksys-labs/foc</a> repository in the r47-sun4i branch, these source codes already contain the necessary patches and are downloaded using the Genode build system. <br><br>  To build, you need to clone the source code: <br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> git://github.com/Ksys-labs/genode.git git checkout tutorials <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> genode</code> </pre><br>  Assemble the toolchain for ARM: <br><pre> <code class="bash hljs">./tools/tool_chain arm</code> </pre><br>  And download the core of Fiasco.OC: <br><pre> <code class="bash hljs">make prepare -C base-foc</code> </pre><br>  Now everything is ready for launch. <br>  1. Create a build directory using the command: <br><pre> <code class="bash hljs">./tools/create_builddir foc_cubieboard BUILD_DIR=_build.foc_cubieboard <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> _build.foc_cubieboard</code> </pre><br>  2. Add the hello_tutorial repository to build the simplest script that does not require drivers that are not yet available. <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'REPOSITORIES += $(GENODE_DIR)/hello_tutorial'</span></span> &gt;&gt; etc/build.conf</code> </pre><br>  3. Turn on the generation of the file u-boot-image <br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'SPECS += uboot'</span></span> &gt;&gt; etc/spec.conf</code> </pre><br>  4. We collect an image <br><pre> <code class="bash hljs">make run/hello</code> </pre><br>  After a brief build, we get the image in the form: ELF (hello.elf) and u-boot-image (uImage) in the var / run / hello directory. <br>  After running on the device, in the connected console, you can see the boot process and running applications from the hello tutorial: <br><div class="spoiler">  <b class="spoiler_title">Log</b> <div class="spoiler_text">  L4 Bootstrapper <br>  Build: # 4 Thu.  Apr  18 22:48:37 MSK 2013, 4.7.2 <br>  Scanning up to 1024 MB RAM <br>  Memory size is 1024MB (40,000,000 - 8,000,000,000) <br>  RAM: 0000000040000000 - 000000007fffffff: 1048576kB <br>  Total RAM: 1024MB <br>  mod07: 4117e000-411b8e3c: genode / timer <br>  mod06: 41148000-4117ddc0: genode / hello_server <br>  mod05: 4111c000-41147c28: genode / hello_client <br>  mod04: 410d6000-4111b738: genode / init <br>  mod03: 410d5000-410d51a4: genode / config <br>  mod02: 4106e000-410d431c: genode / core <br>  mod01: 41064000-4106d374: sigma0 <br>  mod00: 41015000-41063d20: /home/vanner/projects/genode/_build.foc_cubieboard/kernel/fiasco.oc/fiasco <br>  Moving up to 8 modules behind 41100000 <br>  moving module 00 {41015000-41063d1f} -&gt; {412a4000-412f2d1f} [322848] <br>  moving module 01 {41064000-4106d373} -&gt; {412f3000-412fc373} [37748] <br>  moving module 02 {4106e000-410d431b} -&gt; {412fd000-4136331b} [418588] <br>  moving module 03 {410d5000-410d51a3} -&gt; {411b9000-411b91a3} [420] <br>  moving module 04 {410d6000-4111b737} -&gt; {411ba000-411ff737} [284472] <br>  moving module 05 {4111c000-41147c27} -&gt; {41100000-4112bc27} [179240] <br>  moving module 06 {41148000-4117ddbf} -&gt; {4112c000-41161dbf} [220608] <br>  moving module 07 {4117e000-411b8e3b} -&gt; {41162000-4119ce3b} [241212] <br>  moving module 03 {411b9000-411b91a3} -&gt; {4119d000-4119d1a3} [420] <br>  moving module 04 {411ba000-411ff737} -&gt; {4119e000-411e3737} [284472] <br>  Scanning /home/vanner/projects/genode/_build.foc_cubieboard/kernel/fiasco.oc/fiasco -serial_esc <br>  Scanning sigma0 <br>  Scanning genode / core <br>  Relocated mbi to [0x4100e000-0x4100e19c] <br>  Loading cts / genode / _build.foc_cubieboard / kernel / fiasco.oc / fiasco <br>  Loading sigma0 <br>  Loading genode / core <br>  find kernel info page ... <br>  found kernel info page at 0x40002000 <br>  Regions of list 'regions' <br>  [40001000, 400019ff] {a00} Kern cts / genode / _build.foc_cubieboard / kernel / fiasco.oc / fiasco <br>  [40002000, 40060fff] {5f000} Kern cts / genode / _build.foc_cubieboard / kernel / fiasco.oc / fiasco <br>  [40090000, 4009673b] {673c} Sigma0 sigma0 <br>  [40098000, 4009e17b] {617c} Sigma0 sigma0 <br>  [40100000, 4024743f] {147440} Root genode / core <br>  [41000000, 410143f3] {143f4} Boot bootstrap <br>  [4100e000, 4100e299] {29a} Root Multiboot info <br>  [41100000, 411e3737] {e3738} Root Module <br>  API Version: (87) experimental <br>  Sigma0 config ip: 40090100 sp: 41013d24 <br>  Roottask config ip: 4014af84 sp: 00000000 <br>  Starting kernel cts / genode / _build.foc_cubieboard / kernel / fiasco.oc / fiasco at 40001198 <br>  Hello from Startup :: stage2 <br>  Boot_alloc: size = 0x180 <br>  Boot_alloc: allocated memory block @ 0xf13e1000 (size = 400) <br>  Boot_alloc: @ 0xf13e1000 <br>  Boot_alloc: remaining free block @ 0xf13e1180 (size = 280) <br>  Cache config: ON <br>  ID_PFR [01]: 00001131 00000011 ID_ [DA] FR0: 00000400 00000000 <br>  ID_MMFR [04]: 01100003 20000000 01202000 00000211 <br>  FPU0: Arch: VFPv3 (3), Part: VFPv3 (30), r: 3, v: c, i: 41, t: hard, p: dbl / sngl <br>  Startup :: stage2 finished <br>  SERIAL ESC: IRQ 1 allocated for serial uart <br>  Not using serial hack in slow timer handler. <br>  Welcome to Fiasco.OC (arm)! <br>  L4 / Fiasco.OC arm microkernel 1998-2013 TU Dresden <br>  Rev: 8991035 compiled with gcc 4.7.2 for sun4i [] <br>  Build: # 3 Thu.  Apr  18 22:48:33 MSK 2013 <br><br>  Calibrating timer loop ... done. <br>  SIGMA0: Hello! <br>  KIP @ 40002000 <br>  allocated 4KB for maintenance structures <br>  SIGMA0: Dump of all resource maps <br>  RAM: ------------------------ <br>  [0: 40,000,000; 40,000fff] <br>  [0: 40061000; 4008ffff] <br>  [0: 40097000; 40097fff] <br>  [0: 4009f000; 400fffff] <br>  [4: 40100000; 40247fff] <br>  [0: 40248000; 4100dfff] <br>  [4: 4100e000; 4100efff] <br>  [0: 4100f000; 410fffff] <br>  [4: 41100000; 411e3fff] <br>  [0: 411e4000; 7effffff] <br>  IOMEM: ---------------------- <br>  [0: 0; 3fffffff] <br>  [0: 80000000; ffffffff] <br><br>  KIP @ 40002000 <br>  magic: 4be6344c <br>  version: 87014444 <br>  sigma0 esp: 41013d24 eip: 40090100 <br>  sigma1 esp: 00000000 eip: 00000000 <br>  root esp: 00000000 eip: 4014af84 <br>  MBI @ 4100e000 <br>  mod [3] [4119d000,4119d1a4) config <br>  mod [4] [4119e000,411e3738) init <br>  mod [5] [41100000,4112bc28) hello_client <br>  mod [6] [4112c000,41161dc0) hello_server <br>  mod [7] [41162000,4119ce3c) timer <br>  : ram_alloc: Allocator 40230784 dump: <br>  Block: [50000000,5000001c) size = 0000001c avail = 00000000 max_avail = 00000000 <br>  Block: [5000001c, 50000038) size = 0000001c avail = 00000000 max_avail = 00000000 <br>  Block: [50000038,50000054) size = 0000001c avail = 00000000 max_avail = 00000000 <br>  Block: [50000054,50000070) size = 0000001c avail = 00000000 max_avail = 2effff58 <br>  Block: [50000070,5000008c) size = 0000001c avail = 00000000 max_avail = 00000000 <br>  Block: [5000008c, 500000a8) size = 0000001c avail = 00000000 max_avail = 2effff58 <br>  Block: [500000a8,7f000000) size = 2effff58 avail = 2effff58 max_avail = 2effff58 <br>  =&gt; mem_size = 788529152 (752 MB) / mem_avail = 788528984 (751 MB) <br>  : region_alloc: Allocator 402318f4 dump: <br>  Block: [00001000,40000000) size = 3ffff000 avail = 3ffff000 max_avail = 3ffff000 <br>  Block: [7f000000, bfff0000) size = 40ff0000 avail = 40ff0000 max_avail = 40ff0000 <br>  Block: [bfff1000, c0000000) size = 0000f000 avail = 0000f000 max_avail = 0000f000 <br>  =&gt; mem_size = 2164252672 (2063 MB) / mem_avail = 2164252672 (2063 MB) <br>  : io_mem: Allocator 40230be0 dump: <br>  Block: [00000000,40000000) size = 40000000 avail = 40000000 max_avail = 40000000 <br>  Block: [40001000,40002000) size = 00001000 avail = 00001000 max_avail = 40000000 <br>  Block: [40003000,40061000) size = 0005e000 avail = 0005e000 max_avail = 0005e000 <br>  Block: [40090000,40097000) size = 00007000 avail = 00007000 max_avail = 0005e000 <br>  Block: [40098000,4009f000) size = 00007000 avail = 00007000 max_avail = 80ffffff <br>  Block: [7f000000, ffffffff) size = 80ffffff avail = 80ffffff max_avail = 80ffffff <br>  =&gt; mem_size = 3238449151 (3088 MB) / mem_avail = 3238449151 (3088 MB) <br>  : io_port: Allocator 4023103c dump: <br>  : irq: Allocator 40231498 dump: <br>  Block: [00000000,00000100) size = 00000100 avail = 00000100 max_avail = 00000100 <br>  =&gt; mem_size = 256 (0 MB) / mem_avail = 256 (0 MB) <br>  : rom_fs: Rom_fs 402321a8 dump: <br>  Rom: [4119e000,411e3738) init <br>  Rom: [41100000,4112bc28) hello_client <br>  Rom: [4119d000,4119d1a4) config <br>  Rom: [4112c000,41161dc0) hello_server <br>  Rom: [40002000.40003000) l4v2_kip <br>  Rom: [40002000.40003000) kip <br>  Rom: [41162000,4119ce3c) timer <br>  : core ranges: Allocator 40233f08 dump: <br>  Block: [40100000,40248000) size = 00148000 avail = 00148000 max_avail = 00148000 <br>  Block: [41100000,411e4000) size = 000e4000 avail = 000e4000 max_avail = 2f000000 <br>  Block: [50000000.7f000000) size = 2f000000 avail = 2f000000 max_avail = 2f000000 <br>  =&gt; mem_size = 790806528 (754 MB) / mem_avail = 790806528 (754 MB) <br>  int main (): - create local services - int main (): - start init - int main (): transferred 751 MB to init <br>  int main (): - init created, waiting for exit condition - [init] Could not open file "ld.lib.so" <br>  [init -&gt; hello_server] Hello :: Root_component :: Root_component (Genode :: Rpc_entrypoint *, Genode :: Allocator *): Creating root component. <br>  [init -&gt; hello_server] virtual Hello :: Session_component * Hello :: Root_component :: _ create_session (const char *): creating hello session. <br>  [init -&gt; hello_client] virtual void Hello :: Session_client :: say_hello (): Saying Hello. <br>  [init -&gt; hello_server] virtual void Hello :: Session_component :: say_hello (): I am here ... Hello. <br>  [init -&gt; hello_client] int main (): Added 2 + 5 = 7 <br>  [init -&gt; hello_client] virtual void Hello :: Session_client :: say_hello (): Saying Hello. <br>  [init -&gt; hello_server] virtual void Hello :: Session_component :: say_hello (): I am here ... Hello. <br>  [init -&gt; hello_client] int main (): Added 2 + 5 = 7 <br>  ... <br></div></div><br>  As you can see, porting a microkernel to a new architecture is not at all difficult.  Of course, as I wrote above, to use microkernels in real projects, everything depends on supporting the platform hardware.  For example, in the manufacture of prototypes of devices based on the Pandaboard and Gumstix Overo, we had to add a lot of drivers, such as: GPIO, UART, SPI, I2C.  These interfaces were required to work with LCD, touchscreen and smartcard reader.  To use Cubieboard as a mini-PC with Genode, at a minimum, you need to write (or port) drivers: Framebuffer, USB, Ethernet. <br><br>  Genode Labs is planning to build a modern OS based on its framework, and they are confidently moving in this direction.  This is a very interesting open source project related to alternative OSes.  Genode is not very demanding of resources, and in my opinion, single-board PCs on the ARM architecture may well be used as one of the cheapest platforms for this OS. <br><br>  In addition, Genode is great for studying in Computer Science, and if you are a student and you are interested, you can join us.  To do this, look at the first three lectures ( <a href="http://ksyslabs.ru/index.php%3Fnn%3D37">1</a> , <a href="http://ksyslabs.ru/index.php%3Fnn%3D38">2</a> , <a href="http://ksyslabs.ru/index.php%3Fnn%3D39">3</a> ) and complete the tasks from them.  You need to put the solution on Github and send a link to edu@ksyslabs.org. </div><p>Source: <a href="https://habr.com/ru/post/177201/">https://habr.com/ru/post/177201/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../177181/index.html">Using Yii's ActiveRecord in a time manager game</a></li>
<li><a href="../177187/index.html">Powerful speakers at the conference # MBLT13</a></li>
<li><a href="../177189/index.html">Function Code Integrity Monitoring</a></li>
<li><a href="../177191/index.html">Zingaya's free iOS mobile app</a></li>
<li><a href="../177197/index.html">Turing's biggest test</a></li>
<li><a href="../177203/index.html">22 years in orbit</a></li>
<li><a href="../177209/index.html">High-capacity 3600mAh HLI-820XL Battery for Nokia Lumia 820</a></li>
<li><a href="../177215/index.html">Collecting advanced upstream statistics using nginx-sla</a></li>
<li><a href="../177217/index.html">Knowledge Base. Part 2. Freebase: making requests to the Google Knowledge Graph</a></li>
<li><a href="../177219/index.html">ASP.NET MVC and unobtrusive validation with Backbone.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>