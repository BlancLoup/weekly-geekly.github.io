<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compact RSA implementation for embedded applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RSA is a well-known public key encryption algorithm. On its basis, in addition to asymmetric encryption, you can also implement an electronic signatur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compact RSA implementation for embedded applications</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://ru.wikipedia.org/wiki/RSA">RSA</a> is a well-known public key encryption algorithm.  On its basis, in addition to asymmetric encryption, you can also implement an electronic signature ( <a href="https://ru.wikipedia.org/wiki/%25D0%25AD%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2582%25D1%2580%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BF%25D0%25BE%25D0%25B4%25D0%25BF%25D0%25B8%25D1%2581%25D1%258C">EDS</a> ).  These features are attractive for embedded systems, microcontrollers.  The encryption method itself is extremely simple in appearance: <br><table><tbody><tr><td>  C = (M <sup>e</sup> ) mod n </td><td>  (one) </td></tr></tbody></table>  where C, M, e, n are integers, M is a plaintext, numbers e and n are a public key, C is a ciphertext.  mod is the remainder of the division. <br><br>  The extension looks just as simple: <br><table><tbody><tr><td>  M = (C <sup>d</sup> ) mod n </td><td>  (2) </td></tr></tbody></table>  where C, M, n play the same role as for encryption, d is the private key. <br><br>  In this case, n = p * q, where p and q are prime numbers (secret), e is usually 65537, d is calculated on the basis of e, p and q.  Cryptographic strength is based on the fact that, for sufficiently large p and q, the task of decomposing n into factors or reversing an encryption formula without knowing p and q is not solved in a reasonable time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But this seeming simplicity is deceptive.  Behind it lies a huge amount of detail and complexity of implementation.  Especially if the goal is to get an effective in speed and memory implementation, suitable for use in microcontrollers.  I did not find the appropriate libraries on the Internet, and attempts to study the source code of <b>libgcrypt</b> lead to such jungle from which you can‚Äôt get out.  Therefore, I wrote my compact library, which I share with respected readers. <br><a name="habracut"></a><br><h4>  1. Long arithmetic (Multi-precision integer arithmetics) </h4><br>  The first difficulties begin when trying to test the performance of RSA for small numbers.  For example, if we take p = 7, q = 11, then we get n = 77.  The chosen e must be mutually simple with (p-1) * (q-1), therefore 2, 3, 4 and 5 do not fit, the minimum is 7. Leaving aside the calculation method d, I‚Äôll just give the result: d = 43.  And now, although encrypting a small message is not a problem, for decryption, you need to raise C to a power of 43, and this leads to overflow even of 64-bit integers already at C = 3. <br><br>  However, even without this example, it was clear that one could not do without the use of long arithmetic.  After all, to ensure cryptographic resistance, p and q must be large.  In modern practice of using RSA, these numbers are of the order of 2 <sup>1024</sup> each, and the order of n is 2 <sup>2048</sup> when using a key length of 2048 bits.  It is possible to reduce the order of numbers by 2 times (512 bits for p and q, 1024 for n), but in recent publications one can often find the opinion that 1024-bit RSA-keys no longer provide the proper level of cryptographic strength. <br><br>  Long arithmetic is a loose concept.  There is a desire to use the C ++ class to represent long numbers and implement the addition, subtraction, multiplication, etc. operators.  My practice shows that this approach is suitable only for initial acquaintance with RSA.  For implementation in microcontrollers, we need to implement not the entire set of operations, but only the most necessary ones.  And implement effectively.  Not in C ++, but in C or even assembly language. <br><br>  Historically, at first I implemented the necessary algorithms of long-term arithmetic, in C ++, then translated them into dsPIC33F assembler and optimized, and then translated back to C. In this connection, the C code was much more efficient than the original C ++ and only slightly inferior to assembler. <br><br><h5>  1.1.  Exponentiation </h5><br>  Obviously, first of all we need an exponentiation algorithm.  The <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25B1%25D1%258B%25D1%2581%25D1%2582%25D1%2580%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B2%25D0%25BE%25D0%25B7%25D0%25B2%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25B2_%25D1%2581%25D1%2582%25D0%25B5%25D0%25BF%25D0%25B5%25D0%25BD%25D1%258C">algorithm</a> studied in school [1], which reduces the operation to a series of multiplications and has complexity O (log e), where e is the exponent, is suitable for this. <br><br>  Even when using algorithms of long arithmetic, raising the 2048-bit number M to the power e = 65537 results in a bit length of 2048 * 65537 bits, which will require more than 16 megabytes to be stored in memory.  The execution time of the multiplication for such numbers completely exceeds all imaginable limits.  Fortunately, we do not need the result M <sup>e itself</sup> , but only the remainder of its division by n.  Since exponentiation is reduced to a series of multiplications, it is necessary after each multiplication to reduce the length of the intermediate result, finding the remainder from dividing it by n.  There are theorems that guarantee a correct result.  Thus, the algorithm of exponentiation and the subsequent calculation of the remainder of dividing the result by n is transformed into a unified <a href="http://en.wikipedia.org/wiki/Modular_exponentiation">exponentiation</a> algorithm <a href="http://en.wikipedia.org/wiki/Modular_exponentiation">modulo</a> , which calculates the results of both operations simultaneously and thereby fully realizes RSA encryption using formula (1). <br><br>  To implement this algorithm, we will need long multiplication operations and finding the remainder of the division.  Private does not interest us.  At the same time, the operand width for multiplication will be 2048 bits each; 4096-bit numbers should be divided into 2048-bit, the remainder of the division will be 2048 bits long. <br><br>  Despite the good performance, the above algorithm is only suitable for encryption, where the ‚Äúgood‚Äù exponent e = 65537 is used.  Its value is large enough for cryptographic strength;  at the same time, it is quite small compared with the key width;  it is a prime number, and it also has an advantageous binary representation that increases the efficiency of exponentiation.  At the same time, the number d cannot be chosen arbitrarily, it depends on p, q and e, and in order of magnitude it is comparable to n, 2048 bits.  If you can raise to the power of 65537 in 17 long multiplications and divisions, then to raise to the power d will take an average of about 3,072 such operations, which will reduce the decryption speed compared to encryption by more than 180 times.  However, in the case of decryption, you can significantly increase the speed by using the knowledge of p and q (for the encrypting side, these numbers are usually unknown).  As a result, the decryption algorithm is significantly different from the encryption with all the mathematical similarity of these operations. <br><br>  My embedded implementation uses only encryption (or an electronic signature verification operation), so raising to the power of e modulo n can be done in the form of a specialized procedure rigidly bound to the value of e = 65537.  In the source code text, this procedure is called <b>mpi_powm65537</b> , it takes as input the numbers M and n.  In her work, she uses the procedures of long multiplication and finding the remainder of the long division. <br><br><h5>  1.2.  Long multiplication </h5><br>  There are a number of algorithms for long multiplication.  The most widely known is the multiplication "in a column."  This method reduces the multiplication of long numbers to a series of multiplications and additions of individual numbers.  If there is a hardware multiplier in the processor, long multiplication can be implemented in the base number system of 256, 65536 and more, depending on the multiplier capacity.  He will multiply the individual "digits" of long numbers. <br><br>  Column multiplication is not the most efficient method.  Its complexity is O (k <sup>2</sup> ), where k is the bit width of the operands in the selected number system.  There are more efficient algorithms: <a href="https://ru.wikipedia.org/wiki/%25D0%25A3%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%259A%25D0%25B0%25D1%2580%25D0%25B0%25D1%2586%25D1%2583%25D0%25B1%25D1%258B">Karatsuba multiplication</a> , multiplication by Fourier transform [2, 7], etc. However, these advanced methods are more difficult to implement.  In conditions of lack of time, I limited myself to multiplying by a bar.  This gave an acceptable speed on the selected microcontroller. <br><br>  So, multiplication "in a column" reduces a long multiplication to a series of short multiplications and additions.  It is reasonable to use the capacity of the existing hardware multiplier completely.  For example, in PIC24 and dsPIC microcontrollers there is a multiplier 16 * 16 =&gt; 32, that is, multiplying 16-bit numbers and giving a 32-bit result.  Thus, the maximum possible base of the number system for these microcontrollers is 2 <sup>16</sup> = 65536. <br><br>  Moreover, it is important that the result is 32-bit, because all these 32 bits will be needed in the course of further calculations.  For example, in x86 processors, the bit depth of the result is equal to the bit width of the operands, i.e.  32 bits.  To avoid overflow, it is necessary to limit the width of the operands to 16 bits.  The same is true for some other 32-bit processors.  They also have to use the number system on the base of 65536, as in a 16-bit microcontroller. <br><br>  When multiplying "in a column", you can calculate intermediate results in a different order.  Let's say, as we are accustomed to in school, you can first multiply the entire first factor by one digit of the second, then by the second, etc., by writing the results into lines.  It turns out the matrix, which further must be added line by line.  But for dsPIC microcontrollers, a different approach is more effective [6].  Namely, the calculation of the matrix is ‚Äã‚Äãnot in rows, but in columns.  First the first column, then the second, and so on.  When a column is calculated - its values ‚Äã‚Äãcan be immediately added together, we get the figure of the final result and the transfer.  Of course, it makes no sense to store all the numbers from the column - you can instead add them to the sum instead.  With this approach, the multiplication operations alternate with the operations of adding the result to the accumulator.  And consequently, it becomes possible to use powerful <acronym>DSP-</acronym> means of this microcontroller, REPEAT and MAC instructions, which take two operands from the memory in one clock cycle, multiply them, add the result to the accumulator and increase the values ‚Äã‚Äãof the pointers.  Although the algorithm still remains inefficient - O (k <sup>2</sup> ), such an optimized implementation can compete with more efficient algorithms that spend more processor cycles for each pass of the internal cycle. <br><br>  Long unsigned multiplication of 2048 * 2048 =&gt; 4096 is in my library routine <b>mpi_muluu</b> . <br><br><h5>  1.3.  Number Representation - Little Endian or Big Endian? </h5><br>  Any developer of a long arithmetic library must decide in what form it represents numbers in memory.  Are the low-order and then most significant digits of the number (Little Endian) located in the memory or vice versa (Big Endian).  For a person, the Big Endian format is more natural, because all the numbers we work with are represented in this format.  However, for the internal representation of numbers in the computer may be different. <br><br>  In our case, the conditions are dictated by the algorithm of long multiplication.  When it works, numbers are represented in memory in the form of 16-bit "numbers".  It would be desirable to read these "numbers" from the memory as a whole, rather than one byte.  In this case, you have to use the instructions of the 16-bit read processor, and they are in the case of dsPIC, and x86 - Little Endian.  There are other considerations for which Little Endian is preferable, but this is the most important thing.  To improve performance, we want to read the processed information from the memory as large as possible, while avoiding unnecessary transformations.  Therefore, I chose Little Endian, despite the fact that many textbooks use the Big Endian format, and I do not regret it.  This choice led to a beautiful and optimal code.  Of course, for Big-endian processors, you should choose Big-endian format. <br><br><h5>  1.4.  Long division </h5><br>  Effective methods of long division reduce it to multiplying by the reciprocal of the divisor number [7].  In turn, this inverse number is also calculated using multiplication, for example, by an iterative method based on the Newton method for solving equations [3, 7].  Theoretically, this could be very beneficial for RSA, because it is necessary to divide many times into the same number, so that the reverse number needs to be calculated only once.  However, I did not bother with this, limiting myself to the implementation of the division ‚Äúin a column‚Äù in relation to computers, which is described in [4]. <br><br>  If we recall the method of dividing "in a column" studied in school and try to implement it "on the forehead" on a computer, then you come across the fact that this method, with the exception of working in the binary number system, does not reduce the long division to short or other simple operations.  In fact, having demolished a certain number of divisible digits, it is necessary to divide them by the whole long divisor in order to get the next private digit.  How to be here?  In [4], a theorem is given which makes it possible to ‚Äúguess‚Äù the digit of a particular with a small error.  It is valid for cases when: <br><ol><li>  the bit width of the divider is one digit less than the bit width of the partial remainder; </li><li>  the first digit of the divisor is greater than or equal to half the base of the number system. </li></ol>  The first condition is met due to the fact that we demolish the figures of the dividend into a partial remainder in the correct way (similar to the school procedure).  To satisfy the second condition, you can multiply the dividend and the divisor by the same number.  However, for RSA keys, it is guaranteed that the high bit n (of the divider) is equal to 1. And this means that the 16-bit ‚Äúdigit‚Äù formed from the higher 16 bits of the key will be greater than or equal to 32768. Therefore, the RSA does not require the division . <br><br>  In order to "guess" the digit of the quotient, it is necessary to divide the first two digits of the partial remainder by the first digit of the divisor.  The resulting value is either equal to the true private digit, or exceeds it by no more than 2. Indeed, if we divide 499 by 50, then dividing 49 by 5, we get 9, which coincides with the true first digit of the private.  If we divide 890 by 99 - then dividing 89 by 9, we get 9, which is 1 more than necessary.  In other cases, the estimate turns out to be overestimated by 2, but never again, this is guaranteed by a theorem. <br><br>  The division of two digits of the partial remainder by one digit of the divisor is a ‚Äúshort‚Äù division, the hardware support of which is very desirable.  In dsPIC33 there is hardware support for dividing 32-bit numbers into 16-bit, with 16-bit quotients and the remainder.  This is quite enough for the implementation of long division in the base number system 2 <sup>16</sup> = 65536.  For x86, the maximum bit depth of the dividend is 32 bits, which also provides the basis for the number system 65536. <br><br>  After ‚Äúguessing‚Äù the quotient numbers, it is necessary to multiply this number by the divisor and subtract the product from the partial remainder.  If the result is less than 0, add the divisor back and reduce the estimate of the quotient by 1. If the remainder is less than 0, add the divider again and decrease the quotient again.  As a result, we will get the correct value of the quotient and the correct value of the partial balance to continue the division process. <br><br>  RSA does not need to know the quotient, but only the remainder of the division is needed.  In this regard, I wrote a function <b>mpi_moduu</b> , which calculates only the remainder.  For a 2048-bit RSA, you need to divide 4096-bit numbers into 2048-bit, with a 2048-bit remainder.  My procedure performs division ‚Äúin place‚Äù: the dividend is replaced by the remainder after the procedure ends.  This increases its efficiency, since the "demolition" of the next digit from the dividend turns into a simple increment of the pointer.  Also, no additional memory is required to store the partial balance and the private (as it is not saved). <br><br>  The following components of long arithmetic are necessary for the operation of the above described division algorithm: <br><ol><li>  multiplying a long number by a short (one digit); </li><li>  subtraction of long numbers; </li><li>  addition of long numbers; </li><li>  comparison of long numbers </li></ol>  which are described below. <br><br>  The complexity of the long division procedure is O (k <sup>2</sup> ) for short multiplications and O (k) for short divisions, where k is the number of digits of the divider in the base number system of 65536. <br><br><h5>  1.5.  Long addition and subtraction </h5><br>  Writing the <b>mpi_add</b> addition and subtraction <b>mpi_sub procedures</b> does not require much ingenuity and some complicated methods.  Each processor has an ADC type instruction that adds two numbers and a carry bit from the previous addition.  If you cascade ADC commands, then you can add operands of any capacity.  This is true for subtraction and SBC instructions.  The complexity is O (k).  My procedures return a carry flag when adding or subtracting, which is used in the division procedure. <br><br>  In the C language, there is no access to the processor flags, so you have to attract numbers that are larger than necessary.  For example, when adding two 16-bit numbers, it is necessary to use at least 32-bit for storing the result and transfer, in order to avoid overflow. This again leads us to the need to work in the number system on the basis of 65536 on 32-bit processors.  Well, in the assembler, the digits of digits of long numbers coincide with the digits of the processor, 16 bits in the case of dsPIC. <br><br><h5>  1.6.  Long comparison </h5><br>  Comparison can be implemented more efficiently than subtraction, if you start processing with higher digits.  If the high digit of one number is greater than the high digit of the other, then the whole number is greater, the remaining numbers can not be compared.  Thus, the complexity of the comparison procedure is the same as for subtracting O (k), but statistically the comparison is faster.  The procedure in the source is called <b>mpi_cmp</b> . <br><br><h5>  1.7.  Multiply a long number by a short </h5><br>  Multiplying a long number by a short one (ie, by one digit), which is used when dividing long numbers, is not fundamentally different from a long multiplication.  However, it lacks one level of nesting cycles.  Multiplying the number of digits k by a digit in the system, based on 65536, leads to the number of digits k + 1.  Since in the division procedure such multiplication immediately follows subtraction of the product from the partial remainder, I implemented both operations simultaneously in the <b>mpi_mulsubuuk</b> procedure, which multiplies the 2048-bit number by the 16-bit and subtracts the product from the 2064-bit number, which leads to some saving of memory and time execution. <br><br>  That's all the long arithmetic needed for RSA encryption. <br><br><h4>  2. Key generation </h4><br>  Key generation in RSA begins with the selection of two large primes p and q.  When they say: ‚ÄúRSA-key is 2048 bits long‚Äù, they mean that the product p * q is a 2048-bit number, the highest bit of which is 1 (otherwise, in some interpretations, this would be a 2047-bit number).  The size of the numbers p and q separately is not specified, but I noticed that such p and q are generated in <a href="https://www.gnupg.org/">GnuPG</a> , that each of them is a 1024-bit number with the most significant bit equal to 1. <br><br>  On the generation of large prime numbers, you can write books, not so much as articles.  But in many situations, including mine, it is not required to generate keys on the microcontroller.  So I tried, and successfully, to generate keys using GnuPG. <br><br>  First you need to generate a key pair (open + closed) in GnuPG in the usual way.  At the same time, make sure that the RSA-key of the desired length is obtained (2048 bits are now set by default there).  Despite persistent calls from GnuPG, you should refuse to protect this key with a password and store it on disk in clear text.  What difference does it make? We are all the same going to ‚Äúgut‚Äù this key into its p, q, n, d numbers and save them to disk in the clear, at least temporarily. <br>  The key can be exported from the GnuPG key database undocumented in new gpg versions. <pre><code class="dos hljs">gpg --export-secret-keys --armor [key_id] &gt;filename.asc</code> </pre> <br>  Where key_id is the key identifier that can be obtained by calling gpg --list-secret-keys. <br><br>  You‚Äôll get a text file with content like: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">-----BEGIN</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PGP</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">PRIVATE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">KEY</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BLOCK-----</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Version</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">GnuPG</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">v2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.17</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">MingW32</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">lQOXBE9IdyABCADGT3</span></span>+<span class="hljs-selector-tag"><span class="hljs-selector-tag">Dj0dsVPSkzW</span></span>+<span class="hljs-selector-tag"><span class="hljs-selector-tag">zPlfXc4AsuKpkE9GJNAYD3mrcF70nwk1L</span></span> ...</code> </pre><br>  How do we extract the numbers that make up the key from here?  It turned out that in the gpg program itself and the attached utilities there are NO such tools.  There is only a third-party utility " <a href="http://www.mew.org/~kazu/proj/pgpdump/en/">pgpdump</a> ", which interprets the contents of the PGP Private Key Block and displays it in human-readable form.  Calling it like this: <pre> <code class="dos hljs">pgpdump -i filename.asc &gt;filename.txt</code> </pre> <br>  We get the parameters we need: <br><pre> <code class="hljs perl">Old: Secret Key Packet(tag <span class="hljs-number"><span class="hljs-number">5</span></span>)(<span class="hljs-number"><span class="hljs-number">919</span></span> bytes) Ver <span class="hljs-number"><span class="hljs-number">4</span></span> - new Public key creation <span class="hljs-keyword"><span class="hljs-keyword">time</span></span> - Sat Feb <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span>:<span class="hljs-number"><span class="hljs-number">52</span></span>:<span class="hljs-number"><span class="hljs-number">32</span></span> FLE Standard Time <span class="hljs-number"><span class="hljs-number">2012</span></span> Pub alg - RSA Encrypt <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> Sign(pub <span class="hljs-number"><span class="hljs-number">1</span></span>) RSA n(<span class="hljs-number"><span class="hljs-number">2048</span></span> bits) - c6 <span class="hljs-number"><span class="hljs-number">4</span></span>f <span class="hljs-number"><span class="hljs-number">7</span></span>f ... RSA e(<span class="hljs-number"><span class="hljs-number">17</span></span> bits) - <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> RSA d(<span class="hljs-number"><span class="hljs-number">2040</span></span> bits) - a5 c5 ce ... RSA p(<span class="hljs-number"><span class="hljs-number">1024</span></span> bits) - d<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-number"><span class="hljs-number">28</span></span> ad ... RSA <span class="hljs-string"><span class="hljs-string">q(1024 bits)</span></span> - f3 e3 <span class="hljs-number"><span class="hljs-number">61</span></span> ... RSA u(<span class="hljs-number"><span class="hljs-number">1024</span></span> bits) - <span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>b <span class="hljs-number"><span class="hljs-number">22</span></span> ... Checksum - <span class="hljs-number"><span class="hljs-number">3</span></span>e <span class="hljs-number"><span class="hljs-number">22</span></span> ...</code> </pre>  Here I don‚Äôt completely give real numbers, but you will easily get them for your key.  It remains only to copy them where necessary, not forgetting that in this file they are presented in the format <b>Big Endian</b> .  So in order to use them in conjunction with my procedures, you need to convert them to Little Endian, that is, rearrange all the bytes in reverse order. <br><br>  Also do not forget that the public key is only the numbers e and n.  The remaining numbers are the secret (private) key, and knowing any of them (d, p, q, u) will make it easy to calculate the rest and decrypt your message, or forge an electronic signature. <br><br><h4>  3. Decryption </h4><br>  Since most RSA implementations hide somewhere inside the number that the keys consist of, and wrap encrypted messages in all sorts of packets, then at least to check the subroutines listed in section 1, it is necessary, in addition to the encryption operation, to also implement decryption. <br><br>  As mentioned above, the formula (2) decryption can be implemented "in the forehead."  And although it will work a hundred times slower than encryption, due to the large value of the exponent d, but this will be enough for many applications.  If there is a desire to speed up the operation, then the trick using the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B8%25D1%2582%25D0%25B0%25D0%25B9%25D1%2581%25D0%25BA%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D0%25B1_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D0%25BA%25D0%25B0%25D1%2585">Chinese theorem on residues</a> , described in [5], is applied.  I do not have beautiful sources that implement all this, therefore I give only a verbal description of the algorithm: <br><br>  First, the number d ‚Äúdecomposes‚Äù into two parts, <b>d <sub>p</sub> = d mod (p-1)</b> and <b>d <sub>q</sub> = d mod (q-1)</b> .  At the same time, the width of each of the parts is 2 times smaller than the ‚Äúkey length‚Äù (digit capacity n).  Further, <b>q <sub>inv</sub></b> is calculated such that (q * q <sub>inv</sub> ) mod p = 1. That is, q <sub>inv</sub> is the inverse of q in the ring modulo p.  In English terminology, this is called " <a href="http://en.wikipedia.org/wiki/Modular_multiplicative_inverse">Modular multiplicative inverse</a> ".  To calculate the inverse of the element is usually used the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2595%25D0%25B2%25D0%25BA%25D0%25BB%25D0%25B8%25D0%25B4%25D0%25B0">advanced Euclidean algorithm</a> . <br><br>  When the numbers d <sub>p</sub> , d <sub>q</sub> and q <sub>inv</sub> are found, the decryption of the message using the RSA method is performed as follows: <br><ol><li>  m <sub>1</sub> : = (C <sup>d <sub>p</sub></sup> ) mod p </li><li>  m <sub>2</sub> : = (C <sup>d <sub>q</sub></sup> ) mod q </li><li>  h: = ((m <sub>1</sub> -m <sub>2</sub> ) * q <sub>inv</sub> ) mod p </li><li>  M: = m <sub>2</sub> + h * q </li></ol><br>  Note that the calculations in steps 1-3 are made in a lower bit depth: 1024 bits instead of 2048 for the formula (2).  Since the modular exponentiation algorithms have a cubic complexity (quadratic of multiplication and division, and still linear of ‚Äúfast‚Äù exponentiation), the speed gain is obtained when working with half the number of digits 8 times.  But since we now have two expensive exponentiation operations modulo, then the total gain is 4 times compared with the direct application of formula (2).  Although it is a lot, it is still not so significant that in all cases it is necessary to reject direct application of formula (2), especially considering the difficulties in calculating q <sub>inv</sub> . <br><br>  It is worth mentioning the interesting vulnerability associated with ‚Äúrapid‚Äù exponentiation.  This is mentioned in the source code libgcrypt, file mpi-pow.c.  The attack is called ‚ÄúYarom / Falkner flush + reload cache side-channel attack‚Äù and allows using the processor‚Äôs second level cache (which is common to all cores) for unauthorized applications to fully find out the value of d or its parts d <sub>p</sub> and d <sub>q</sub> .  Both means full disclosure of the secret key, allowing the attacker to read all the messages encrypted with this key or generate an electronic signature.  That is, for example, your program decrypts something with a secret key, and a malicious program at this moment is working on the same system, but on behalf of another user, so you do not know about it.  And at this moment there is a key leak. <br><br><h4>  Conclusion </h4><br>  I presented a C language module suitable for RSA encryption or electronic signature verification on 32-bit embedded processors with clock frequencies of the order of 40 MHz and a hardware multiplier.  When translating the C source code into assembler and using materials [6], you can get a realization for dsPIC33F that encrypts one RSA-2048 data block in a time on the order of 10ms at a processor clock frequency of 80 MHz. <br><br>  Sources can be downloaded from <a href="https://github.com/mborisov1/rsa_embedded/">GitHub</a> . <br><br>  RSA decryption (or electronic signature generation) can also be implemented on microcontrollers of this class, but this operation will be approximately 45-180 times slower. <br><br>  It is possible to accelerate the library by attracting efficient multiplication and division algorithms mentioned in the article by reference. <br><br>  I recommend using my routines only for embedded applications, and for ‚Äúlarge‚Äù computers in most cases it is better to use standard tools like Windows CryptoAPI or libgcrypt. <br><h4>  Bibliography </h4><br>  1. A. G. Kushnirenko, G.V.  Lebedev, R. A. Svoren.  Fundamentals of computer science and computing.  M.: 1990, p. 133. <br>  2. Wikipedia.  <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B5%25D1%2582%25D0%25BE%25D0%25B4_%25D1%2583%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D0%25BD%25D0%25B8%25D1%258F_%25D0%25A8%25D1%2591%25D0%25BD%25D1%2585%25D0%25B0%25D0%25B3%25D0%25B5_%25E2%2580%2594_%25D0%25A8%25D1%2582%25D1%2580%25D0%25B0%25D1%2581%25D1%2581%25D0%25B5%25D0%25BD%25D0%25B0">Sch√∂nhage-Strassen</a> multiplication method <br>  3. Wikipedia.  " <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BB%25D0%25B8%25D0%25BD%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B0%25D1%2580%25D0%25B8%25D1%2584%25D0%25BC%25D0%25B5%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0">Long arithmetic</a> " <br>  4. Donald Whip.  "The Art of Programming", volume 2. The algorithms <br>  5. Wikipedia, ‚Äú <a href="http://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA (cryptosystem)</a> ‚Äù article, ‚ÄúA worked example‚Äù section <br>  6. Erich Wegener, Mario Werner.  "Evaluating 16-bit Processors for Elliptic Curve Cryptography".  Institute for Applied Information Processing and Communications (IAIK), Graz University of Technology <br>  7. William H. Press et al.  Numerical Recipes in C ++, Second edition, Cambridge University Press 2002, page 922 </div><p>Source: <a href="https://habr.com/ru/post/243425/">https://habr.com/ru/post/243425/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../243413/index.html">Configuring Virtual Infrastructure: VDI Cluster Optimization</a></li>
<li><a href="../243417/index.html">Ethernet Weather Station 2 - Continued ...</a></li>
<li><a href="../243419/index.html">Turing test based on real search queries in Yandex</a></li>
<li><a href="../243421/index.html">Print from Google Apps Script</a></li>
<li><a href="../243423/index.html">New IBM Global Entrepreneurship Program Accelerates Cloud Development</a></li>
<li><a href="../243427/index.html">[TRANSFER] JSON Web Token-based authentication in Django and AngularJS: part one</a></li>
<li><a href="../243429/index.html">Autostarting Node.js application on CentOS 6.2</a></li>
<li><a href="../243431/index.html">Why you should never say "never"</a></li>
<li><a href="../243433/index.html">How we tested the dependence of LTE speed on S1 parameters</a></li>
<li><a href="../243437/index.html">C ++ code refactoring in Visual Studio 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>