<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Development of digital hardware in C ++ / SystemC through the eyes of the programmer SystemVerilog</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="SystemC is a library for C ++ that allows you to simulate various hardware systems at different levels of abstraction. It supports both traditional di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Development of digital hardware in C ++ / SystemC through the eyes of the programmer SystemVerilog</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/cd1/ad6/877/cd1ad6877c9b4171a9ee4d5e31761809.png"><br><br>  SystemC is a library for C ++ that allows you to simulate various hardware systems at different levels of abstraction.  It supports both traditional discrete event modeling, familiar to programmers on Verilog and VHDL, and analog modeling in the spirit of SPICE / Verilog AMS.  The kit also includes a library and methodology for virtual prototyping, a library for writing test environments and verification using randomized tests. <br><br>  In this article, I will talk about the synthesizable subset of SystemC, comparing it with synthesizable SystemVerilog.  I myself have been using SystemC for about 3 years, and before that I had been writing on Verilog / SystemVerilog for several years.  I will try to cover the subject from different angles: from philosophical discourse on the causes of SystemC, an overview of the ecosystem and tools, and ending with practical examples of syntax and semantics. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This implies that readers are familiar with Verilog and C ++. <a name="habracut"></a><br><br><h4>  Reflections on the causes of SystemC </h4><br>  Over its long history, the electronics development industry has found application to many programming languages ‚Äã‚Äãand has spawned a huge number of domain-specific languages.  If we imagine a hypothetical full-stack apparatchik (by analogy with a full-stack web programmer) who can single-handedly design a modern microcircuit, from an algorithm to implementation in silicon, then in addition to knowledge of the hardware (arychitecture computer, electronics, algorithms from and others) will have to own a whole bunch of different languages: Matlab for developing algorithms, Verilog or VHDL for describing RTL models, SystemVerilog / E / Vera for writing tests and test environments, TCL for writing scripts managing CAD packages, SPICE / Verilog-AMS for model  tion analog subsystems, SKILL or Python for generating topologies, Cu / Asm for writing all kinds of firmware.  If desired, the list goes on and on. <br><br>  Of course, in nature, such universal engineers practically do not occur, and the project is made by several teams, each of which is well versed in its own rather narrow field.  However, it is very often necessary to combine work at several stages of development.  For example, it is easy to imagine that a person who wrote an RTL model of an IP block will write for him and a set of tests for verification.  This in turn creates a request for the creation of universal languages ‚Äã‚Äãsuitable for solving related problems. <br><br>  In the world of digital microelectronics, SystemVerilog has become such a universal language, which, apart from the classic Verilog (with small extensions), contains an object-oriented language for writing test environments, an assertions language for formal verification, as well as special constructions for randomization and analysis of test cover.  In a sense, SystemVerilog is not a completely new language, but rather a conglomeration of languages, glued together with a common syntax. <br><br>  But what if we want more?  A language in which in addition to the above, you can develop algorithms, write firmware, create virtual prototypes.  Is it time to add another DSL to SystemVerilog? <br><br><img src="https://habrastorage.org/files/0ec/bc5/473/0ecbc5473c504eb4a792f1da047c5d4b.png"><br>  <i>We need to go deeper</i> <br><br>  However, there is another approach: instead of inventing all new DSLs, you can create software libraries designed to solve a special class of problems.  In this way, the creators of SystemC went - a library for C ++ that allows you to simulate digital equipment.  Although in a sense SystemC is a DLS created by means of metaprogramming in C ++, C ++ itself is not extended with new syntactic constructions.  Metaprogramming is widely used in other C ++ libraries. <br><br>  This approach has its pros and cons.  The main advantage of C ++ is its versatility: today you can write a hardware on SystemC, and tomorrow a GUI on Qt.  (Although it will take a lot of time to study each of these libraries).  The main minus in the syntax: the code on pure DSL will be much more beautiful, especially if you need to do something simple (for simple modules, the Verilog code will be smaller and simpler than the similar code on SystemC). <br><br>  In addition to the lack of versatility, Verilog has another problem: it is very low-level.  In a sense, synthesized Verilog is a macro-assembler for hardware (if an assembler for hardware is a logic circuit).  New designs that appeared in the synthesized SystemVerilog do not solve this problem of low level.  Very often, you have to resort to using all sorts of Verilog code generators, <a href="http://habrahabr.ru/company/metrotek/blog/263005/">such as Python scripts</a> .  Among my colleagues, the idea of ‚Äã‚Äãinserting Perl code inside Verilog modules was a popular idea.  The hybrid thus obtained was called perlilogue.  I think many are familiar with <a href="http://www.veripool.org/wiki/verilog-mode">Verilog-mode for emacs</a> , which can generate Verilog code for connecting modules. <br><br>  Compared to SystemVerilog, synthesized by SystemC allows much more.  Yes, you can write synthesized code with classes!  When solving complex problems, the C ++ abstraction tools allow you to write more elegant (simple and compact) code. <br><br><h4>  SystemC Ecosystem </h4><br>  Consider the basic software tools that developers on SystemVerilog and SystemC have to deal with. <br><br><h5>  Development environment </h5><br>  <i>SystemVerilog:</i> <br>  Most Verilog programmers use a text editor to write code: Verilog support is found in Vim, Emacs, Sublime Text, Notepad ++, Slickedit, and other popular editors.  Writing code in a test editor may seem archaic to application programmers: most of them use smart IDEs with auto-prompts, automated refactorings, and easy navigation.  However, in the world of synthesized Verilog there is no great benefit from the use of IDE: this is explained by the fact that all the functionality is divided into completely independent modules.  The whole context with which the developer of a separate module works usually fits into one file.  Quite another thing with writing testbenches on SystemVerilog, an IDE such as <a href="http://www.dvteclipse.com/">DVT</a> may be useful here. <br><br>  <i>SystemC:</i> <br>  When writing a synthesized C ++ / SystemC simple text editor is not enough.  Fortunately, there are many C ++ IDEs (including free ones) that can handle SystemC code.  For example, you can use the familiar to many <a href="https://www.visualstudio.com/">MS Visual Studio</a> .  I have used <a href="https://eclipse.org/cdt/">Eclipse CDT</a> and <a href="https://netbeans.org/features/cpp/">Netbeans</a> for a long time to write C ++ / SystemC code.  Last time I try <a href="https://www.jetbrains.com/clion/">Clion from Jetbrains</a> . <br><img src="https://habrastorage.org/files/062/3be/b1d/0623beb1d9234b778729d9a330aaa66b.png">  <i>Writing SystemC Code in Clion</i> <br><br><h5>  Simulation and debugging </h5><br>  <i>SystemVerilog:</i> <br>  To simulate and debug code on Verilog, an HDL simulator is used.  There are both free (IcarusVerilog) and paid simulators.  Compared to a free simulator, commercial solutions provide faster simulation speeds and provide convenient graphical environments for debugging. <br><br>  <i>SystemC:</i> <br>  With SystemC, the situation is generally similar: you can use the reference simulator and GDB for debugging, but when you need to debug some more or less complex signaling protocol, you have to use one of the commercial simulators. <br><img src="https://habrastorage.org/files/bd5/900/238/bd5900238bd843e0a1b47fe51ee2dc52.png"><br>  <i>Debugging SystemC in the simulator</i> <br><br><h5>  Synthesis </h5><br>  <i>SystemVerilog:</i> <br>  Synthesis of SystemVerilog is supported by major FPGA and ASIC vendors.  There are also free versions of packages for FPGA, which are used by many Russian universities for teaching students the basics of digital circuitry. <br><br>  <i>SystemC:</i> <br>  For SystemC synthesis, special high-level synthesis packages (HLS) are used.  What in them such a high-level you ask?  The thing is that HLS packages, in addition to traditional RTL code written on SystemC, can also synthesize purely behavioral (‚Äúuntimed‚Äù) code, automatically inserting registers where necessary. <br><br>  Most HLS packages can synthesize pure C / C ++, SystemC is used only in cases where you need to add modularity and signaling interfaces.  In a sense, synthesis with C / C ++ is a technology for developing accelerators that competes with <a href="http://habrahabr.ru/company/metrotek/blog/269009/">synthesis with OpenCL</a> .  Although using SystemC, we are not limited only to the development of accelerators, but we can develop completely any digital circuits.  A little later, I will talk about HLS a little more. <br><br>  At the output of the HLS package, we usually have the usual RTL modules on Verilog, which are then synthesized using the Verilog synthesizer. <br><br>  Unfortunately, all existing HLS with SystemC support are purely commercial and cost a lot of money.  There are no free versions, although universities sell everything at a big discount. <br>  The best means of synthesizing SystemC on the market are <a href="http://www.cadence.com/products/sd/stratus/pages/default.aspx">Stdence from Cadence</a> and <a href="http://calypto.com/en/products/catapult/overview/">Catapult C from Calypto / Mentor Graphics</a> . <br><br><h5>  Other EDA packages for SystemC </h5><br>  In addition to writing synthesized code, SystemC is widely used for virtual prototyping.  The creation of virtual prototypes (emulators) on the C ++ / SystemC is used in the packages <a href="http://www.synopsys.com/Prototyping/VirtualPrototyping/Pages/virtualizer.aspx">Synopsys Virtualizer</a> , <a href="https://www.mentor.com/products/fv/vista">Mentor Graphics Vista</a> , <a href="http://www.cadence.com/products/sd/virtual_system/pages/default.aspx">Cadence Virtual System Platform</a> .  At the same time, we cannot say that SystemC is the dominant solution in this market: there are also SystemC products that do not use, for example, <a href="http://www.windriver.com/products/simics/">WindRiver Simics</a> . <br><br>  This concludes the article.  It's time to dive into the code. <br><br><img src="https://habrastorage.org/files/ec3/994/188/ec39941880854e5987dda993807e748f.jpg"><br>  <i>Dive into code</i> <br><br><h4>  Synthesized SystemC.  Base building blocks </h4><br>  I will not fully describe the entire SystemC standard here, I will go over only the most necessary.  All examples will be built on a comparison of SystemVerilog and SystemC. <h5>  Data types </h5><br>  <i>SystemVerilog:</i> <br>  The main type used in the synthesized SystemVerilog is the type of <b>logic</b> .  A variable of the type <b>logic</b> can take 4 values: 1, 0, x, z.  <b>x</b> means unknown value.  <b>z</b> means high impedance state.  You can create logic type vectors of various lengths, for example: <br><pre><code class="delphi hljs">logic [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] data; <span class="hljs-comment"><span class="hljs-comment">// 2-   initial begin data = 7; $display(data); end</span></span></code> </pre>  Will output to console: 3 <br><br>  <i>SystemC:</i> <br>  In SystemC, there are also types with 4 states.  However, in practice, types with 2 states 1 and 0 are mainly used. The main reason is that types with 2 states are simulated faster. <br><br>  After synthesis, all types with 2 states turn into logic.  This can lead to differences in the results of SystemC simulations (before synthesis) and Verilog (after synthesis).  In SystemC, an unset register will have the value 0, in Verilog - x.  Fortunately, the synthesizer issues a warning every time it sees a register without a reset, so in practice, after reading the synthesizer log, problems with divergence of the simulation results can be avoided. <br><br>  Very often, C code on the SystemC uses built-in C ++ types, such as int or char.  If we need a number with a specified number of bits, we can use the type sc_uint: <pre> <code class="cpp hljs">sc_uint&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; data; <span class="hljs-comment"><span class="hljs-comment">// 2-   data = 7; cout &lt;&lt; data;</span></span></code> </pre>  Will output to console: 3 <br><br>  How is sc_uint implemented?  This is just a template class in which all major operators are overloaded. <br><br><h5>  Modules </h5><br>  Consider the example of an empty module on SystemVerilog and SystemC <br>  <i>SystemVerilog:</i> <br><pre> <code class="delphi hljs">module top ( input clk, rstn, input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] din, output logic [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] dout ) <span class="hljs-comment"><span class="hljs-comment">//   endmodule</span></span></code> </pre><br>  <i>SystemC:</i> <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">top</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sc_module { sc_in&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; clk, rstn; sc_in&lt;sc_uint&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt; din; sc_out&lt;sc_uint&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt; dout; top(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name) : sc_module(name) , clk(<span class="hljs-string"><span class="hljs-string">"clk"</span></span>) , rstn(<span class="hljs-string"><span class="hljs-string">"rstn"</span></span>) , din(<span class="hljs-string"><span class="hljs-string">"din"</span></span>), dout(<span class="hljs-string"><span class="hljs-string">"dout"</span></span>) { } };</code> </pre>  Let us examine the interesting lines in more detail: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">top</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> sc_module {</code> </pre>  modules in SystemC are derived classes from the sc_module class <pre> <code class="cpp hljs"> sc_in&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; clk, rstn; sc_in&lt;sc_uint&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt; din; sc_out&lt;sc_uint&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt; dout;</code> </pre>  To create ports in SystemC, the special classes sc_in and sc_out are used. <pre> <code class="cpp hljs"> top(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* name) : sc_module(name) , clk(<span class="hljs-string"><span class="hljs-string">"clk"</span></span>) , rstn(<span class="hljs-string"><span class="hljs-string">"rstn"</span></span>) , din(<span class="hljs-string"><span class="hljs-string">"din"</span></span>), dout(<span class="hljs-string"><span class="hljs-string">"dout"</span></span>)</code> </pre>  Module and port constructors are passed strings containing their name.  This is necessary for the simulation core to produce easy-to-read logs, for example: <br> <code>Error: (E109) complete binding failed: port not bound: port 'top.dout' (sc_out)</code> <br> <code>:  dout  top   .</code> <br>  (Probably, when normal introspection support appears in C ++, objects in SystemC will be able to recognize their names on their own) <br>  For the convenience of creating modules in SystemC, several macros are defined.  Using them, a similar module looks like this: <pre> <code class="cpp hljs">SC_MODULE(top) { sc_in&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; clk, rstn; sc_in&lt;sc_uint&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt; din; sc_out&lt;sc_uint&lt;<span class="hljs-number"><span class="hljs-number">8</span></span>&gt; &gt; dout; SC_CTOR(top) , clk(<span class="hljs-string"><span class="hljs-string">"clk"</span></span>) , rstn(<span class="hljs-string"><span class="hljs-string">"rstn"</span></span>) , din(<span class="hljs-string"><span class="hljs-string">"din"</span></span>), dout(<span class="hljs-string"><span class="hljs-string">"dout"</span></span>) {} };</code> </pre><br><h5>  Variables and Assignments </h5><br>  <i>SystemVerilog:</i> <br>  It can be argued that all the variables in the synthesized SystemVerilog are static: they exist from the beginning to the end of the simulation.  And they have a global scope (although access to the signals ‚Äúthrough the roof‚Äù by the hierarchical name is not allowed in the synthesized code).  Another feature of SystemVerilog is the presence of several assignment operators: blocking and non-blocking assignments in procedural blocks, as well as continuous assignments. <br>  The blocking assignment occurs either immediately or blocks the execution of the current process until the moment when the assignment is completed. <br>  Example: <pre> <code class="delphi hljs">logic a; initial <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> a = <span class="hljs-string"><span class="hljs-string">#42</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; $display($time); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre>  Will output to console: 42 <br>  because  The call to the $ display function will occur only at time 42, when assignment will occur. <br>  Non-blocking assignment defers assignment at some point in the simulation time in the future and does not block the execution of the process.  If time is not specified explicitly, assignment occurs on the next delta cycle. <pre> <code class="cpp hljs">initial begin a &lt;= #<span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; $display($time); end</code> </pre>  Will output to console: 0 <br><br>  <i>SystemC:</i> <br>  Variables in C ++ do not know anything about the SystemC simulation kernel and therefore behave in a way familiar to a C ++ programmer.  In order to simulate non-blocking assignment in SystemC, a special type of sc_signal is used, variables of this type are referred to below as signals: <pre> <code class="cpp hljs">sc_signal&lt; sc_uint&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>&gt; &gt; data; <span class="hljs-comment"><span class="hljs-comment">//   sc_uint&lt;2&gt;</span></span></code> </pre>  Any assignment of the data value will be non-blocking. <br>  Synthesized SystemC requires that the interaction between multiple processes takes place through signals.  Similarly, in Verilog, a good style is to use exclusively non-blocking assignments in always_ff procedural blocks.  Otherwise, we risk to get an indefinite behavior (race condition) when the simulation result will depend on the order of calling the processes in one delta cycle. <br>  There is no blocking assignment analog in SystemC. <br><br><h5>  Processes (Procedural blocks) </h5><br>  <i>SystemVerilog:</i> <br>  Synthesized SystemVerilog supports two main types of procedural blocks always_comb and always_ff.  In addition to them, there is always always_latch, but in practice it is quite rare to use latch registers. <br>  always_comb is used to describe combinatorial logic. <pre> <code class="delphi hljs">always_comb <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> a = b + c; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre>  The process will be executed each time the value of b or c changes.  The same could be written more explicitly, as in the classic Verilog: <pre> <code class="delphi hljs">always@(b <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> c) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> a = b + c; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre>  In addition to the always_comb procedure block, a continuous assignment operator can be used to describe combinational circuits: <pre> <code class="delphi hljs">assign a = b + c;</code> </pre>  The procedural block always_ff is used to describe sequential logic, i.e.  circuits with memory. <pre> <code class="delphi hljs">always_ff @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge arst_n) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(~arst_n) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> a &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> a &lt;= a + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre>  This example describes a binary counter with asynchronous reset. <br><br><h5>  SystemC: </h5>  Processes in SystemC are created in the module constructor.  The body of the processes is described in the member functions of the module.  The type of process that always looks like a block from Verilog in SystemC is called SC_METHOD. <br>  Consider examples of processes similar to the procedural blocks shown earlier on SystemVerilog: <br>  Combinatorial logic: <pre> <code class="cpp hljs">SC_CTOR(top) { SC_METHOD(comb_method); <span class="hljs-comment"><span class="hljs-comment">//      SC_METHOD sensitive &lt;&lt; b &lt;&lt; c; //   ( @(a or b) ) } void comb_method() { a = b + c; } //     -</span></span></code> </pre>  Sequence logic: <pre> <code class="cpp hljs">SC_CTOR(top) { SC_METHOD(seq_method); <span class="hljs-comment"><span class="hljs-comment">//      SC_METHOD sensitive &lt;&lt; clk.pos() &lt;&lt; arst_n.neg(); //   ( @(posedge clk or negedge arst_n) ) } void seq_method() { //     - if (!arst_n) a = 0; else a = a + 1; }</span></span></code> </pre>  There is no analogue of continuous assignment in SystemC.  Just as there is no possibility to specify the wildcard in the sensitivity list (always @ * in Verilog).  Even the powerful template magic of C ++ does not allow this to be implemented by means of metaprogramming. <br><br><h5>  Parameterization </h5><br>  Modules on SystemVerilog can be parameterized.  For example, you can write a parameterized FIFO, the width and depth of which will be specified when creating an instance. <br><br>  In SystemC, template classes are used to create parameterizable modules.  With the use of patterns and inheritance, the parameterization possibilities in SystemC become almost limitless. <br><br><h5>  Subtotals </h5><br>  SystemC allows you to describe hardware at the RTL level in a style very close to simple Verilog.  The Verilog code will be sleeker and more compact, but in general, all the functionality can be repeated.  Consider a full-fledged example: let's implement a shift register with serial input and output (serial-in / serial-out) and asynchronous reset on Verilog and SystemC: <br>  Verilog code: <pre> <code class="delphi hljs">module shifreg ( input clk, sin, reset, output sout ); reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] tmp; always @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (reset) tmp &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> tmp &lt;= <span class="hljs-comment"><span class="hljs-comment">{tmp[6:0], sin}</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign sout = tmp[<span class="hljs-number"><span class="hljs-number">7</span></span>]; endmodule</code> </pre>  Code on SystemC <pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         C++11 SC_MODULE(shift_reg) { sc_in&lt;bool&gt; clk{"clk"}, sin{"sin"}, reset{"reset"}; sc_out&lt;bool&gt; sout{"sout"}; SC_CTOR(shift_reg) { SC_METHOD(shift_method); sensitive &lt;&lt; clk.pos() &lt;&lt; reset.pos(); // ..   ,    SC_METHOD(sout_method); sensitive &lt;&lt; tmp; } private: sc_signal &lt;sc_uint&lt;8&gt; &gt; tmp {"tmp"}; void shift_method() { //        read  write //  write -     verilog if ( reset.read() ) { tmp.write(0); } else { //   "," ()    tmp.write((tmp.read().range(6,0) , sin.read())); } } void sout_method() { sout = tmp.read()[7]; } };</span></span></code> </pre><br><h4>  Good systemc.  Opportunities synthesized SystemC, which are not in SystemVerilog </h4><br><h5>  User Data Types </h5><br>  Synthesized SystemC fully supports C ++ object-oriented programming.  This allows you to create convenient data types for work in your subject area.  For example, if you are engaged in 3D graphics, then you constantly have to deal with 3-dimensional real vectors.  For their hardware implementation will need to solve several problems. <br>  First, floating point operations are generally not supported by the synthesizer.  Therefore, you will have to implement them yourself, or use a third-party library, such as DesignWare floating point.  In either case, you can create a convenient class for working with a floating point: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_float</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: my_float <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> my_float &amp;rval) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; my_float <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> my_float &amp;rval ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; my_float <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> my_float &amp;rval ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    ... private: sc_uint&lt;32&gt; raw_data; //   float   32-  }</span></span></code> </pre>  Using my_float, you can implement a class for working with vectors: <pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vector_3d</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: vector_3d <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> vector_3d &amp;rval ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>; <span class="hljs-comment"><span class="hljs-comment">// vector product vector_3d dot_product (const vector_3d &amp;other) const; // dot product //    ... private: my_float x, y, z; };</span></span></code> </pre>  Then these custom types can be used in the synthesized SystemC. <pre> <code class="cpp hljs">vector_3d a,b,c; c = a + b;</code> </pre>  SystemVerilog synthesizers do not support class synthesis, but are able to synthesize structures.  Therefore, programming on SystemVerilog is somewhat similar to C programming.  On SystemVerilog, this problem with vectors is usually solved as follows: you create a separate package, and in it you define structures and functions for working with them: <pre> <code class="delphi hljs">package Vector3DPkg; typedef struct <span class="hljs-comment"><span class="hljs-comment">{ logic [31:0] x, y, x; }</span></span> vector_3d; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vector_3d</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vector_3d a, b)</span></span></span><span class="hljs-function">;</span></span> add.x = float_add (ax, bx); add.y = float_add (ay, by); <span class="hljs-comment"><span class="hljs-comment">//... endfunction function vector_3dmul(vector_3d a, b); //.... endpackage : Vector3DPkg</span></span></code> </pre><br><h5>  SC_CTHREADS (clocked threads).  Processes with implicit state </h5><br>  Synthesized processes in Verilog cannot use expressions to control time and wait for events.  Those.  A running process must be executed to the end and only then transfer control to another process.  For example, this process is not synthesized: <pre> <code class="delphi hljs">always @(posedge clk) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; @(posedge clk); <span class="hljs-comment"><span class="hljs-comment">//     out &lt;= 2; @(posedge clk); out &lt;= 42; end</span></span></code> </pre>  In Verilog, we need to explicitly specify a state register that will determine the behavior of the process at each tick.  The following process will be the synthesized analogue of the previous code example: <pre> <code class="delphi hljs">logic [<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] state; always @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> negedge reset_n) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( ~ reset_n) state &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (state) <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> state &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> state &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> state &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">42</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre>  In SystemC, synthesized processes describing sequential logic (digital automaton) can stop waiting for an event from a clock signal.  This allows the machine to be described without explicit specification of the status register.  Processes of this type are created using the SC_CTHREAD macro.  The process is stopped until the next clock signal by calling the function wait ();  Example: <pre> <code class="cpp hljs">SC_CTOR ( top ) { <span class="hljs-comment"><span class="hljs-comment">//     // clk.pos()       clk SC_CTHREAD(test_cthread, clk.pos() ); async_reset_signal_is(reset_n, 0); //     0 } void test_cthread () { //     wait()  reset-,         . out &lt;= 1; wait(); //    SC_METHOD, SC_CTHREAD     //         while (1) { out.write(1); wait (); //     clk out.write(2); wait (); //     clk out.write(42); } }</span></span></code> </pre>  At first glance, the benefits of having such processes are not obvious.  In the end, it is not so difficult to explicitly encode a variable for the state of the digital automaton (the state variable in the example on Verilog). <br>  The true power of SC_CTHREAD processes is the ability to call functions that can block a process, i.e.  call the wait () function.  Such a function can be performed several cycles!  Analogous from the world of Verilog are the tasks, but they are not synthesized and are used only in tests. <br>  For example: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { res = calculate_something(); <span class="hljs-comment"><span class="hljs-comment">//    -  spi_send(res); //    SPI,     }</span></span></code> </pre>  Even more useful for functions, the execution of which sometimes takes several cycles, and sometimes it happens instantly, without calling wait (). <br>  For example, consider a process that reads data from a FIFO, processes it, and then sends the result to memory via the system bus (for example, AMBA AXI).  Let the data be a 3-dimensional vector considered earlier, and the processing will be to normalize this vector.  Using SC_CTHREAD and ready-made classes for working with FIFO and AXI, writing such a process is very simple: <pre> <code class="cpp hljs">fifo data_fifo; <span class="hljs-comment"><span class="hljs-comment">//  FIFO amba_axi bus_master; //    AMBA AXI void computational_thread() { wait(); while (1) { vector_3d vec = data_fifo.pop(); //    FIFO vec.normalize(); //   bus_master.write( 0xDEADBEEF, vec); //       0xDEADBEEF }</span></span></code> </pre>  Suppose that the normalization of a vector is implemented as a combinational circuit.  Then, depending on the readiness of the FIFO and the bus, the execution of one cycle of such a process can take from one clock cycle or more.  If there is data in the FIFO and the bus is not busy, then normalization of one vector will occur per clock.  If the FIFO is empty, then the process will be blocked for reading from the FIFO data_fifo.pop until the new data is received.  If the bus is busy, the process will be blocked on the bus_master.write function until the bus is free. <br><br>  An experienced developer probably had a question, how do we normalize the vector per clock?  At what frequency does our module work?  Indeed, a chain of multiplication, two additions, a square root and division is too much for one combinational circuit.  Especially since we are talking about floating point operations.  In the case of synchronous circuitry, this combination chain is likely to become a bottleneck, limiting the maximum clock frequency of the entire circuit. <br><img src="https://habrastorage.org/files/856/61d/e3b/85661de3b6124ba6bce33e0b847d678b.png"><br>  Depending on the bandwidth requirements of our normalizer, the problem can be solved in several ways: <ul><li>  If we are not in a hurry, we can save on resources and implement normalization in the form of FSMD with one multiplier, adder, divider and square root module.  In this case, we will spend 6 clocks to calculate the length of the vector and another 3 clocks to calculate the value of each of the elements of the result, in total - 9 clocks per vector. <br><img src="https://habrastorage.org/files/d11/3b5/d84/d113b5d84e2c4158be371bc1c39cceb7.png"><br></li><li>  If we are in a hurry and resources are not sorry, the original combinational circuit can be turned into a pipeline.  In this case, at the peak (when there is always data in the FIFO) we get the same 1 clock per vector, but at a higher clock frequency. <br><img src="https://habrastorage.org/files/7ce/655/410/7ce6554102824b77ada9f5f91fbdf8e0.png"><br></li><li>  Any intermediate between the first and second variants are also possible.  For example, if the logic is expensive and the registers are cheap, then in the first considered variant of the micro-architecture, you can begin processing the next vector without waiting for the completion of the previous one, as resources become available.  After calculating the three squares of the elements of the first vector, the multiplier is released and you can begin processing the next vector.  Such an implementation is called a pipeline with an initialization interval of 3 cycles.  Those.  every three cycles the pipeline will pick up a new vector from the FIFO. </li></ul><br>  Unfortunately, the implementation of any of the proposed solutions manually will require a lot of time and will significantly complicate our 3-line source.  For example, in the case of a pipeline implementation, you will have to create a process for each of the stages of the pipeline.  Fortunately, when using SystemC, we don‚Äôt need to do anything with our hands - after all, you can simply use high-level synthesis! <br><br><h4>  High-level synthesis. </h4><br>  High-level synthesis is the process of transforming an algorithmic code written in a high-level programming language into digital equipment that implements it.  At the input of the HLS packet are: <ul><li>  Source.  Sometimes it is called untimed code, because  it contains no constructs to stop the process, such as the wait function </li><li>  Timing constraints.  Temporary restrictions.  Set the list of clock signals and their period, as well as delays on external ports </li><li>  Specification microarchitecture.  As a microarchitecture, we can choose any of the previously considered options </li></ul>  In our example, we want to subject the vector normalization function to high-level synthesis: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> vector_3d::normalize() { my_float magnitude = <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>( x*x + y*y + z*z ); x = x / magnitude; y = y / magnitude; z = z / magnitude; }</code> </pre>  As a micro-architecture, you can, for example, select a pipeline with an initialization interval of 1 clock and a latency of 4 clock cycles, and a clock frequency of 500 MHz.  Using the technology library HLS package will determine the delay of signal propagation through each arithmetic element and optimally arrange them into stages of the conveyor.  If necessary, the execution of a single operation can be divided into several stages: for example, a division is a rather complicated operation, the execution of which may not fit into one clock period.  Therefore, it is quite possible that the synthetor will split the divider between the 3rd and 4th stage of the pipeline. <br><img src="https://habrastorage.org/files/4df/a46/b4f/4dfa46b4fc8d4b5788651cb332747f5c.png"><br>  <i>Analysis of the project in the HLS package from Cadence</i> <br><br>  Experienced users of logic synthesis tools know that some of them (for example, the Deisgn Compiler) have a similar function called retiming.  Compared with retyming, HLS has several advantages: <ul><li>  There is no need to specify the registers, the logic of the pipeline stop. </li><li>  HLS allows you to switch between multiple micro-architectures without changing the source code. </li></ul>  Another interesting feature of HLS is working with memory.  The abstraction of memory in HLS is a regular array.  All we have to do is to tell the synthesizer the library of memories available in the process technology.  For example, you can remake our example so that the result is not sent via the AXI bus, but is recorded directly in the memory: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> write_address; <span class="hljs-comment"><span class="hljs-comment">// 32-  vector_3d memory[1024]; //  1024x96 ,   - 96  .... while (1) { vector_3d vec = data_fifo.pop(); //    FIFO vec.normalize(); //   memory [write_address] = vec; //     write_address ++; }</span></span></code> </pre>  I would also like to note that not all HLS tools support synthesis with SystemC.  Using SystemC is required only where it is necessary to describe signal interfaces (for example, AMBA or UART).  On FPGA platforms, bus interfaces are typically standardized, so their use in the HLS code may be implicit.  For example, Vilado HLS from Xilinx is primarily focused on synthesis from pure C / C ++.  As part of the Xilinx SoC platform, the standard is the AMBA AXI interface, so it is assumed that your functions will be sent and received via AXI, or using a simple handshake protocol.  All that is required of you is to describe the algorithmic code.  Of course, this approach also has its drawbacks: when creating complex projects, you may well come to pasting many HLS modules in the code on Verilog or the graphical editor of schemes.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For these purposes, Xilinx has another product - Vivado IP Integrator. </font></font><br><img src="https://habrastorage.org/files/63e/a63/dd8/63ea63dd8ec54441bb785ffa9993122b.jpg"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connecting the HLS unit to the ARM processor via AMBA AXI in Vivado IP Integrator</font></font></i> <br><br><h4>  Conclusion </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a conclusion, I want to try to answer the question that is often asked by RTL developers after seeing the new tool: And what about the quality of the result? How will the timings, area, power consumption of the circuits described on SystemC and synthesized using HLS compared to the RTL described on SystemVerilog differ? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Actually nothing. Everything is in your hands: SystemC and HLS do not deprive you of the opportunity to zatyunit everything up to the gate where it is required. And at the same time, HLS does not release you from the need to understand the basics of digital circuitry. HLS is not a magic tool that turns a C ++ programmer into an apparatchik, it is a tool that allows you to automate routine work, facilitating the process of writing and maintaining the synthesized code.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this article, I did not touch on the question of verification. </font><font style="vertical-align: inherit;">Verification always takes most of the development time and SystemC has something to offer in this field. </font><font style="vertical-align: inherit;">Well-written SystemC is stimulated faster than RTL, because </font><font style="vertical-align: inherit;">part of the code is written in the ‚Äúuntimed style‚Äù, and signal interfaces can be replaced with function calls (Transaction-level modeling). </font><font style="vertical-align: inherit;">The SCV (SystemC Verification Library) library allows you to randomize test vectors, also on the approach of SystemC version of UVM.</font></font> And since<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SystemC is C ++, parts of the source code can be reused between the synthesized code, the reference model, the virtual prototype and the operating system driver. </font><font style="vertical-align: inherit;">But the story about all this is worthy of a separate article.</font></font></div><p>Source: <a href="https://habr.com/ru/post/274137/">https://habr.com/ru/post/274137/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274109/index.html">The digest of interesting materials for the mobile developer # 135 (December 21-27)</a></li>
<li><a href="../274117/index.html">The botnet of thousands of hacked Aethra routers was used to attack Wordpress sites</a></li>
<li><a href="../274129/index.html">I want sites to open instantly</a></li>
<li><a href="../274131/index.html">Monitoring Dynamic XML Documents</a></li>
<li><a href="../274135/index.html">Animator - what is it? Why is it needed? Why use it instead of Animation?</a></li>
<li><a href="../274139/index.html">Functional Expressions in JavaScript</a></li>
<li><a href="../274141/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ191 (December 20 - 27, 2015)</a></li>
<li><a href="../274143/index.html">How to "animate" the product? Lettering</a></li>
<li><a href="../274145/index.html">Highlight interactive maps using jquery.maphilight.js</a></li>
<li><a href="../274147/index.html">Product Design Digest, December 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>