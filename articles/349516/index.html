<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: Faster, Better, Smarter ...</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- How angels soar together in a row ... 
 - Together in a row, amicably in a row ... 
 - Raise your head! And fly! And fly! .. 

 Sir Terry Pratchett ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: Faster, Better, Smarter ...</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <b><i>- How angels soar together in a row ...</i></b> <b><i><br></i></b>  <b><i>- Together in a row, amicably in a row ...</i></b> <b><i><br></i></b>  <b><i>- Raise your head!</i></b>  <b><i>And fly!</i></b>  <b><i>And fly! ..</i></b> <b><i><br><br></i></b>  <b><i>Sir Terry Pratchett "Night Watch"</i></b> <br><br>  Sooner or later, there always comes a point when quantity inevitably turns into quality.  New games that need to be comprehended accumulate, the <a href="https://glukkazan.github.io/index.html">project</a> acquires new possibilities, the possibilities are combined with each other.  If everything does not collapse under its own weight, the result may exceed all expectations.  What does not kill - makes us stronger! <br><a name="habracut"></a><br>  Here is an example of such a "amount of technology."  The game, in general, is not too difficult, but very unexpected.  <a href="https://glukkazan.github.io/elimination/apocalypse.htm">Apocalypse</a> - on the field four horsemen and supporting their infantry.  Usual moves of <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D0%25BD%25D1%258B%25D0%25B5_%25D1%2584%25D0%25B8%25D0%25B3%25D1%2583%25D1%2580%25D1%258B">chess pieces</a> .  Pawns, having reached the last line, are expectedly turned into riders, but the number of riders on each side cannot exceed two.  The player who first lost all his riders loses.  The devil, as always, is in the details.  Figures walk at the same time! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/THDgcSuKFBU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><div class="spoiler">  <b class="spoiler_title">What does this mean in terms of a project?</b> <div class="spoiler_text">  First of all, like puzzles, this is a ‚Äúgame for one‚Äù - the player makes a move, and the bot ‚Äúmixes‚Äù his own into it, not knowing what kind of move the person made.  This is a game with incomplete information, although in a form very unusual for us.  There are no playing dice or ‚Äúfog of war‚Äù here, but each of the players, performing a move, does not know how his opponent is descending at the same time. <br><br>  Of course, possible conflicts.  For example, both players can simultaneously move to the same empty field, or a pawn can try to eat a piece leaving the same turn from a strike.  <a href="https://en.wikipedia.org/wiki/Apocalypse_(chess_variant)">The rules of the game</a> well describe these nuances.  A pawn is allowed to perform a diagonal move, provided that it is going to beat someone, even if the piece has left this position, and the result of the conflict over an empty field is determined by the rank of the pieces.  The rider always kills a pawn, but if the pieces are equal, they are both destroyed (which, by the way, makes a draw outcome possible). <br><br><div class="spoiler">  <b class="spoiler_title">Merge moves</b> <div class="spoiler_text"><pre><code class="javascript hljs">Dagaz.Model.join = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, a, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = getPiece(design, board, a); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = getPiece(design, board, b); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((x !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (y !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = Dagaz.Model.createMove(); r.protected = []; checkPromotion(design, board, a, x, b); checkPromotion(design, board, b, y, a); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = a.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> q = b.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((p == q) &amp;&amp; (x.type &gt; y.type)) { r.actions.push(b.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>]); r.actions.push(a.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.actions.push(a.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>]); r.actions.push(b.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>]); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == q) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type &gt; y.type) { r.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = [ Dagaz.Model.createPiece(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) ]; r.protected.push(x.player); r.captured = p; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x.type == y.type) { r.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = [ Dagaz.Model.createPiece(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ]; r.actions[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = [ Dagaz.Model.createPiece(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ]; r.capturePiece(p); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] = [ Dagaz.Model.createPiece(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) ]; r.protected.push(y.player); r.captured = p; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } }</code> </pre> </div></div><br>  The task is not easy, but the ‚Äúexpansion of moves‚Äù mechanism <a href="">copes</a> with it perfectly.  Indeed, as I have repeatedly said before, at the post-processing stage, we can not only prohibit the move (violating the game invariant, for example), but also add to it any arbitrary actions, including those obtained from the bot-generated move. <br><br>  There is a truth, one subtlety - usually, post-processing is performed immediately after generation, for all formed moves.  In this case, it is impossible to do this, because it will inevitably lead to a ‚Äúcombinatorial explosion‚Äù (the game, though small, is still not enough).  Most importantly, this is not necessary.  There is a simpler way.  No one said that we can not <a href="">rewrite the controller</a> .  Modularity has its advantages. <br></div></div><br>  From the point of view of the AI ‚Äã‚Äãbot, the game, in many respects, ‚Äúturns out‚Äù.  There is no need to perform a multi-turn view.  It is important to guess how the opponent will walk!  Changing tactics of the game.  It is almost useless to try to attack the riders who are ‚Äúunder battle‚Äù - they will certainly run away.  "Forks" are more promising, but you have to choose which of the riders to beat.  If the enemy has only one rider left (and you have a complete set of them), you can try to ‚Äúwatch for‚Äù him by going to the field chosen by him.  Just do not make it a pawn!  There are nuances associated with the transformation of figures, but, in general ... <br><br><div class="spoiler">  <b class="spoiler_title">It all comes down to a set of heuristics</b> <div class="spoiler_text"><pre> <code class="javascript hljs">... var isCovered = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, pos, player, type</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; _.each(Dagaz.Model.GetCover(design, board)[pos], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.player == player)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(type) || (piece.type == type)) { r = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } Ai.prototype.getMove = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moves = Dagaz.AI.generate(ctx, ctx.board); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moves.length == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">ai</span></span>: <span class="hljs-string"><span class="hljs-string">"nothing"</span></span> }; } timestamp = <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> enemies = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> friends = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(ctx.design.allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = ctx.board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.type == <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player == <span class="hljs-number"><span class="hljs-number">1</span></span>) { enemies++; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { friends++ } } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = -MAXVALUE; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> best = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; _.each(moves, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> e = _.random(<span class="hljs-number"><span class="hljs-number">0</span></span>, NOISE_FACTOR); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (move.isSimpleMove()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trg = move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = ctx.board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = ctx.board.getPiece(trg); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.type == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCovered(ctx.design, ctx.board, pos, <span class="hljs-number"><span class="hljs-number">1</span></span>)) e += MAXVALUE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCovered(ctx.design, ctx.board, trg, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) e += LARGE_BONUS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCovered(ctx.design, ctx.board, trg, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((enemies == <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (friends == <span class="hljs-number"><span class="hljs-number">2</span></span>)) { e += BONUS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { e -= MAXVALUE; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target.type == <span class="hljs-number"><span class="hljs-number">1</span></span>) { e += SMALL_BONUS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { e += BONUS; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isCovered(ctx.design, ctx.board, pos, <span class="hljs-number"><span class="hljs-number">1</span></span>)) e += SMALL_BONUS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((target === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; isCovered(ctx.design, ctx.board, trg, <span class="hljs-number"><span class="hljs-number">1</span></span>)) e -= MAXVALUE; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (friends == <span class="hljs-number"><span class="hljs-number">1</span></span>) e += BONUS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (target !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) e += SMALL_BONUS; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (move.actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>].type != piece.type)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (friends == <span class="hljs-number"><span class="hljs-number">1</span></span>) { e += MAXVALUE; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { e -= MAXVALUE; } } } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((best === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (<span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> &lt; e)) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Move: "</span></span> + move.toString() + <span class="hljs-string"><span class="hljs-string">", eval = "</span></span> + e); best = move; <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = e; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">done</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">move</span></span>: best, <span class="hljs-attr"><span class="hljs-attr">time</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - timestamp, <span class="hljs-attr"><span class="hljs-attr">ai</span></span>: <span class="hljs-string"><span class="hljs-string">"aggressive"</span></span> }; }</code> </pre></div></div><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/shogi/tenjiku-shogi.htm"><img src="https://habrastorage.org/webt/hh/by/cs/hhbycsfa5xuwxcxnfsqqhpp5aag.png"></a> </div><br>  The other extreme is that the games are large and complex, so much so that it‚Äôs technically impossible to look at it in depth.  Here we are <b>forced to</b> use a more <a href="">casual AI</a> , looking at the position only 1-2 moves ahead, and even at this depth, it will not be possible to view all the available moves!  In any case, for a time convenient for a person to search for a bot in 2-3 seconds. <br><br><div class="spoiler">  <b class="spoiler_title">More about performance</b> <div class="spoiler_text">  Large and complex games expose all the problems associated with performance.  Usually, how fast the code is executed is related to the quality of the AI ‚Äã‚Äãwork (the more positions it has to consider in the allotted time, the better it works), but sometimes performance problems become more obvious.  While working on <a href="https://en.wikipedia.org/wiki/Tenjiku_shogi">Tenjiku shogi</a> , I noticed that in some positions, the user interface response time was simply indecent (about 10-15 seconds). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zf/hc/-b/zfhc-bqbwi9rcrxqkwbpjmnuemw.png"></div><br>  It's all about the "Fire Demon" (and similar figures).  Pay attention to the diagram on the right.  In addition to the usual "range" -attack, "demon" has the right, at any time, to perform up to three single-step movements in an arbitrary direction, while he is allowed to return to the previously passed fields.  This is a real "combinatorial killer" of performance!  In the initial position, when all such pieces are ‚Äúclamped‚Äù, this effect does not manifest itself so much, but when they go to the operational space ... anyone can count the possible options for moves (the diagram below shows graphs of changes in the average number of allowable moves, during the game for several famous games). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ck/n4/xn/ckn4xniuhfw5r3-ehvcn9zv74ao.png"></div><br>  Here you should tell a little about the architecture of Dagaz.  The main idea is that, before transferring control to the user or bot, the game model generates <b>all</b> possible moves from the current position.  This allows us to consider the totality of moves "as a whole" and helps to solve a number of problems of <a href="http://zillions-of-games.com/">Zillions of Games</a> related to compound moves.  In addition, this approach is very convenient for the development of bots.  But there is one problem. <br><br>  For the user, a complex composite move is a <b>sequence of</b> different actions (movements, taking and, possibly, dumping new pieces on the board).  Somewhere there should be a code that allows you to select a single move from a previously formed and possibly large list of a sequence of user "clicks".  And there is such a code in Dagaz, of course. <br><br><div class="spoiler">  <b class="spoiler_title">It hid a mistake</b> <div class="spoiler_text"><pre> <code class="javascript hljs">MoveList.prototype.isUniqueFrom = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">move</span></span></span><span class="hljs-function">) </span></span>{ _.each(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getActions(move), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((action[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (_.indexOf(action[<span class="hljs-number"><span class="hljs-number">0</span></span>], pos) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) c++; }); }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c == <span class="hljs-number"><span class="hljs-number">1</span></span>; } MoveList.prototype.isUniqueTo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">move</span></span></span><span class="hljs-function">) </span></span>{ _.each(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getActions(move), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">action</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((action[<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (_.indexOf(action[<span class="hljs-number"><span class="hljs-number">1</span></span>], pos) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) c++; }); }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c == <span class="hljs-number"><span class="hljs-number">1</span></span>; } ... MoveList.prototype.getStops = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getTargets(); _.each(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.moves, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actions = _.filter(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getActions(move), isMove); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((actions.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>].length == <span class="hljs-number"><span class="hljs-number">1</span></span>) &amp;&amp; (actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>].length == <span class="hljs-number"><span class="hljs-number">1</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Dagaz.Model.smartFrom) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isUniqueFrom(actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]) &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.canPass()) { result.push(actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Dagaz.Model.smartTo) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.isUniqueTo(actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>])) { result.push(actions[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]); } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ... } }, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _.uniq(result); }</code> </pre></div></div><br>  See what the problem is?  The <b>getStops</b> function builds a list of all trailing fields of each move and, for this, <b>iterates</b> through all the moves in the cycle, but with the <b>smartFrom</b> or <b>smartTo</b> options enabled (options for immediately executing a move on the first click, if there are no alternatives), <b>nested</b> iteration of all moves is performed.  A lot of moves formed! <br><br>  In small games, like checkers or chess, the error did not manifest itself.  Even in the initial position of <a href="https://glukkazan.github.io/shogi/tenjiku-shogi.htm">Tenjiku shogi,</a> it was not noticeable.  It took "performance killers" to reveal it.  And for the error localization, the <a href="">KPI</a> module was very useful, without which I simply would not know where to look for the problem.  Now the bug is fixed and, as a result, the whole code is better. <br></div></div><br>  So, we are limited in depth and must make the right (or at least not disastrous) decision for a limited time.  At the same time, it is highly desirable to ensure the implementation of the following principles: <br><br><ol><li>  Of course, the move must lead to an immediate victory. </li><li>  There should not be a move to which there is an answer leading to an immediate victory. </li><li>  The selected move should provide the greatest improvement in position. </li></ol><br><div class="spoiler">  <b class="spoiler_title">How to evaluate the position?</b> <div class="spoiler_text">  The easiest way is to evaluate the material balance.  Each type of pieces is assigned a cost, then we add the cost of our pieces and wean the cost of the pieces of the opponent.  Estimation is rough, but for really difficult games, perhaps, the only possible one.  An improved assessment should take into account the mobility of the figures and their mutual threats (I will discuss this below).  For "big" games with complex rules, the assessment of mutual threats may be too expensive. <br><br><div class="spoiler">  <b class="spoiler_title">The simplest estimate function</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Dagaz.AI.eval = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, params, board, player</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(design.allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = design.price[piece.type]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player != player) { v = -v; } r += v; } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre></div></div><br>  The second tool is heuristics.  It‚Äôs just a numerical score of a <b>move</b> , not a position, allowing to distinguish between ‚Äúbad‚Äù moves and ‚Äúgood‚Äù moves.  Of course, first of all, ‚Äúgood‚Äù moves will be considered, and there may simply be no time left for the consideration of ‚Äúbad‚Äù times.  The simplest heuristics can include the cost of a taken figure, but in addition, it is desirable to estimate the cost of a figure performing a move, possible transformations, threats, etc. <br><br><div class="spoiler">  <b class="spoiler_title">Heuristic example</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> player = board.player; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stop = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> captures = []; _.each(move.actions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((a[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = a[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.player != player)) { r += design.price[piece.type] * ai.params.CAPTURING_FACTOR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_.isUndefined(board.bonus) &amp;&amp; (board.bonus[pos] &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { r -= board.bonus[pos]; } } captures.push(pos); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((a[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { start = a[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_.isUndefined(board.bonus)) { r += board.bonus[start]; } } stop = a[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; } }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> price = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (start !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(start); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { price = design.price[piece.type]; } } _.each(move.actions, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((a[<span class="hljs-number"><span class="hljs-number">0</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = a[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.indexOf(captures, pos) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.player != player)) { r += design.price[piece.type] * ai.params.CAPTURING_FACTOR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_.isUndefined(board.bonus)) { r += <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.abs(board.bonus[pos]); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a[<span class="hljs-number"><span class="hljs-number">2</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> promoted = a[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; r -= price * ai.params.SUICIDE_FACTOR; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (promoted.player == player) { r += design.price[promoted.type] * ai.params.PROMOTING_FACTOR; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r -= price * ai.params.SUICIDE_FACTOR; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((a[<span class="hljs-number"><span class="hljs-number">0</span></span>] === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">1</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (a[<span class="hljs-number"><span class="hljs-number">2</span></span>] !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (_.indexOf(captures, a[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = a[<span class="hljs-number"><span class="hljs-number">1</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player != player) { r += design.price[piece.type] * ai.params.CAPTURING_FACTOR; } } piece = a[<span class="hljs-number"><span class="hljs-number">2</span></span>][<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player == player) { r += design.price[piece.type] * ai.params.CREATING_FACTOR; } } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!_.isUndefined(board.cover) &amp;&amp; (start !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (stop !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isAttacked(design, board, board.player, stop, start, price)) { r -= price * ai.params.SUICIDE_FACTOR; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre></div></div><br>  It is important to understand that the maximum value of heuristics does not mean at all that this particular move will be chosen.  Heuristics set only the order of viewing moves.  Within the framework of this order, the move is chosen that maximizes the value of the evaluation function (after the opponent‚Äôs move with the maximum heuristics is completed).  It is possible to forcibly exclude part of the moves from consideration by giving them a negative heuristic value, but this tool should be used with caution, only in cases where there is a 100% certainty that the move in question is not just useless, but harmful. <br><br><div class="spoiler">  <b class="spoiler_title">Cost figures</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> ... design.addPiece(<span class="hljs-string"><span class="hljs-string">"King"</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Prince"</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Blind-Tiger"</span></span>, <span class="hljs-number"><span class="hljs-number">34</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Drunk-Elephant"</span></span>, <span class="hljs-number"><span class="hljs-number">35</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Ferocious-Leopard"</span></span>, <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Gold-General"</span></span>, <span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Silver-General"</span></span>, <span class="hljs-number"><span class="hljs-number">39</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Copper-General"</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Chariot-Soldier"</span></span>, <span class="hljs-number"><span class="hljs-number">41</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Dog"</span></span>, <span class="hljs-number"><span class="hljs-number">43</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Bishop-General"</span></span>, <span class="hljs-number"><span class="hljs-number">44</span></span>, <span class="hljs-number"><span class="hljs-number">21</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Rook-General"</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Vice-General"</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>, <span class="hljs-number"><span class="hljs-number">39</span></span>); design.addPiece(<span class="hljs-string"><span class="hljs-string">"Great-General"</span></span>, <span class="hljs-number"><span class="hljs-number">49</span></span>, <span class="hljs-number"><span class="hljs-number">45</span></span>); ...</code> </pre></div></div><br>  Remember, above I spoke about the three principles?  It makes sense for the royal figures (there can be several types of such figures in the game) to assign a very high cost.  With this we kill two birds with one stone: first, the move taking the royal piece will receive the maximum possible heuristics (and will always be considered first), moreover, the absence of a royal figure on the board will significantly affect the value of the evaluation function, which is also very convenient.  Unfortunately, as applied to <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B">Chess,</a> this trick is not relevant, since the <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2580%25D0%25BE%25D0%25BB%25D1%258C_(%25D1%2588%25D0%25B0%25D1%2585%25D0%25BC%25D0%25B0%25D1%2582%25D1%258B)">king</a> is never taken in them. <br></div></div><br>  It should be noted that the position should always be evaluated only at the end of the opponent‚Äôs retaliatory move!  If there is a chain of exchanges, you should look through it to the end, otherwise it may turn out that the attacking figure will be given away for the less valuable one. <br><br>  Games of more than two players - another application of casual "one-way" AI.  It's all about the evaluation function.  Minimax algorithms work only if the score from the point of view of one player coincides with the score of another, taken with the opposite sign.  What one loses gets the other.  If there are three players ( <a href="https://glukkazan.github.io/xiangqi/qiquo-xiangqi-kanji.htm">or more</a> ), everything breaks down.  Of course, you can still use algorithms based on the <a href="https://en.wikipedia.org/wiki/Monte_Carlo_tree_search">Monte Carlo</a> method, but other difficulties are associated with them. <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/shogi/yonin-shogi.htm"><img src="https://habrastorage.org/webt/fl/yr/lb/flyrlb-vy6r4e0-yj32ynn26j04.png"></a> </div><br>  <a href="https://glukkazan.github.io/shogi/yonin-shogi.htm">Yonin Shogi</a> is a variant of " <a href="https://en.wikipedia.org/wiki/Shogi_variant">Japanese chess</a> " for four players.  Most of the rules in this game remain the same, but the goal of the game changes.  The concept of ‚Äúmata‚Äù, to a certain extent, loses its meaning.  In fact, if the "east" threatens the king of the "south" - this is not a reason for protection from the "Shah", until the "west" and "north" say their word.  On the other hand, if the threat is not eliminated, the ‚Äúeast‚Äù will eat the king by the next move.  Thus, in Yonin Shogi it is allowed to take kings (and this is the goal of the game). <br><br>  In addition, the game does not end with the capture of the king (a similar outcome would be too boring, for the remaining three players).  A player losing a king is eliminated from the game, losing the right of his turn.  Since kings are allowed to be taken, they, like all other pieces, fall into the reserve and can be put on the board at any time.  The player is <b>obliged</b> to put the king from the reserve, if there are no kings left on the board.  After all that has been said, the goal of the game becomes obvious - the one who collects all four kings wins (when I made the game for <a href="http://zillions-of-games.com/">Zillions of Games</a> , <a href="http://zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fsearchauthor%3D505">Howard McCay</a> helped me realize this nuance). <br><br><div class="spoiler">  <b class="spoiler_title">Everything said above leads to a simple thought.</b> <div class="spoiler_text">  There are games in which complex depth-first search algorithms cannot be used, and the concept of the evaluation function itself must be rethought.  To keep the quality of the AI ‚Äã‚Äãalgorithms acceptable, it is necessary to improve the estimates and heuristics, possibly due to their complexity.  The obvious way is the introduction of mobility - the number of all possible moves made by the player, minus the moves of the opponent. <br><br> <code>eval = A * material-balance + B * mobility;  A &gt;= 0, B &gt;= 0, A + B = 1 <br></code> <br>  When using "one-way" algorithms, the assessment of mobility works wonders.  The stupid game of the bot becomes more "meaningful."  There is one minus truth - in order to evaluate mobility, it is necessary to build (or at least recount) all possible moves for each of the players, and this is a very expensive operation.  Since we, all the same, are forced to do this, I want to "squeeze" out of the generation of moves everything possible, as well as minimize the number of such operations. <br><br><div class="spoiler">  <b class="spoiler_title">Coating</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Dagaz.AI.eval = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, params, board, player</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cover = board.getCover(design); _.each(design.allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defended = _.filter(cover[pos], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">p</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> piece.player == player; }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (defended.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) r++; }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre></div></div><br>  So I came to the idea of ‚Äã‚Äã"coverage."  This is just an array of arrays.  For each of the fields (and any field in Dagaz is always encoded with an integer), the list of positions in which the figures are located that can beat this field is preserved, possibly empty.  At the same time (and this is important) no distinction is made between empty and occupied fields, as well as the owners of the ‚Äúbatter‚Äù figures.  The list of possible moves is calculated for all players <b>at the same time</b> , and at the expense of caching, also once. <br><br>  Of course, the universal algorithm for constructing the "cover" is not suitable for all games.  For <a href="https://glukkazan.github.io/checkmate/chess.htm">Chess</a> and <a href="https://glukkazan.github.io/checkers/russian-checkers.htm">Checkers,</a> it works, but for <a href="https://glukkazan.github.io/elimination/spock-board.htm">Spock it is</a> already gone (since, in this game, pieces can easily pass through other pieces of their own color).  This should not be confusing.  As well as the evaluation function and heuristics, the algorithm for constructing a "cover" can be redefined using the name <b>Dagaz.Model.GetCover</b> .  Moreover, even in cases where the universal algorithm works, it is useful to think about its customization.  Specialized algorithms, as a rule, are more productive. <br></div></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xrgoW2_ZC-g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Here is <a href="https://glukkazan.github.io/elimination/maharadja-variant.htm">an example of</a> using "coverage" in a real game.  This is still the simplest ‚Äúone-step‚Äù algorithm and is very easy to deceive, but the actions of the bot seem to be meaningful!  Analyzing the coverage, the AI ‚Äã‚Äãnever leaves its pieces unprotected and seeks to maximize them on the board, maximizing the number of fields under battle.  This is a good tactic, certainly leading to victory when playing against a single <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D0%25B3%25D0%25B0%25D1%2580%25D0%25B0%25D0%25B4%25D0%25B6%25D0%25B0_(%25D0%25B8%25D0%25B3%25D1%2580%25D0%25B0)">Maharaja</a> .  Also this algorithm shows itself well in " <a href="https://glukkazan.github.io/checkmate/charge-light-brigade.htm">Charge of the Light Brigade</a> ", " <a href="https://glukkazan.github.io/checkmate/dunsanys-chess.htm">Dunsany's Chess</a> ", " <a href="https://glukkazan.github.io/checkmate/horde-chess.htm">Horde Chess</a> ", " <a href="https://glukkazan.github.io/checkmate/weak.htm">Weak!</a> " And other "small" chess games.  For me, it is obvious that the use of "coverage" will help to improve more complex algorithms, but before moving on to them, I need to practice. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/nDOLry-do9A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Somewhere around <a href="https://youtu.be/nDOLry-do9A%3Ft%3D341">5:39</a> all movements are dramatically accelerated.  This is simply explained.  In parallel with the animation of the movement of the dice (just so that the person does not get bored), the bot searches for the target position and after it finds it, goes to it in a straight line, without losing time for additional calculations. <br><br><div class="spoiler">  <b class="spoiler_title">By the way</b> <div class="spoiler_text">  I did not manage to observe this effect on FireFox 52.6.0.  In Chrome and even in IE, the algorithm found a solution in about 5 minutes, and in the ‚ÄúFire Fox‚Äù I continued to slowly move the dies for about fifteen minutes, until I cut it down (while memory guzzled as not in itself).  I have not yet found an explanation for this phenomenon. <br></div></div><br>  For me, this is a significant step forward compared to the <a href="https://www.youtube.com/watch%3Fv%3Dl4oi8r747a0">previous version</a> .  <a href="">The algorithm</a> is a simple <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D1%2588%25D0%25B8%25D1%2580%25D0%25B8%25D0%25BD%25D1%2583">search in width</a> (not <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA_%25D0%25B2_%25D0%25B3%25D0%25BB%25D1%2583%25D0%25B1%25D0%25B8%25D0%25BD%25D1%2583">in depth</a> ! Is this important, are we interested in the shortest solution?).  Repeated positions are cut off, with the help of <a href="https://en.wikipedia.org/wiki/Zobrist_hashing">Zobrist hash</a> , which by the way makes possible (although extremely unlikely) a situation in which a solution may not be found as a result of a collision.  In addition, the search priority is given to nodes that are descendants of the current animation node (in order to minimize the number of required returns, after finding a solution). <br><br><div class="spoiler">  <b class="spoiler_title">Along the way, I did one more thing.</b> <div class="spoiler_text">  The fact is that in Zillions of Games there is an option, the purpose of which I never understood.  It is called ‚Äúprogressive levels‚Äù.  As soon as you finish one level of the game, it immediately loads the next one, just in order.  Now, I think, I caught what is the point.  Try to turn off these lights: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/1a/ej/zy/1aejzy62kpn-7cvomapgmaax01a.png"></div><br>  Agree, it delays.  And so how someone solves puzzles for you, you can generally <a href="https://glukkazan.github.io/sliding-puzzles/fujiware_1-ai.htm">look up to infinity</a> .  But this is only half the battle!  Like almost any Dagaz option, <b>my</b> ‚Äúprogressive levels‚Äù can be customized. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/o_/aj/lp/o_ajlpvgnzcglfojk3vd-rhwozy.png"></div><br>  This puzzle was devoted to the election of <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B0%25D1%2588%25D0%25B8%25D0%25BD%25D0%25B3%25D1%2582%25D0%25BE%25D0%25BD,_%25D0%2594%25D0%25B6%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B6">George Washington</a> for the presidency and, initially, I did not realize it correctly.  For the <b>right</b> solution, you need to draw a red square through all four corners alternately, but in Dagaz you can only set one goal.  This is where the <b>custom</b> ‚Äúprogressive levels‚Äù comes into play. <br><br>  As soon as we reach the next goal, the next level is loaded, but the arrangement of the figures, at the same time, is taken from the previous one!  We just continue from where we left off. <a href=""></a> ,      ,    . ,     ,       ,     .    URL ,      ¬´Setup:¬ª.     ! <br><br>  ¬´progressive levels¬ª       ,   <a href="https://glukkazan.github.io/breakthrough/kamisado.htm">Kamisado</a> .       <b></b>    !  <a href="http://www.boardspace.net/kamisado/english/RULES%2520ENG.pdf"></a> ,        ¬´¬ª   ,  ,         . , Dagaz  !  ,        <a href=""></a> .     ,   ,       <a href="https://ru.wikipedia.org/wiki/Roguelike"></a> . <br></div></div><br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/breakthrough/horn-chess.htm"><img src="https://habrastorage.org/webt/cv/d9/n7/cvd9n7nfma6bohidvqv4gejg12k.png"></a> </div><br>    <a href="https://sites.google.com/site/boardandpieces/list-of-games/horn-chess">  </a> .      ,  ‚Äî    .    ,   ¬´¬ª     ¬´¬ª.    ‚Äî  : <br><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><iframe width="560" height="315" src="https://www.youtube.com/embed/0cx8jRmYvjA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br></div></div><br> -   " <a href="https://glukkazan.github.io/breakthrough/french-military-small.htm">  </a> "  " <a href="https://glukkazan.github.io/breakthrough/game-of-dwarfs.htm"> </a> ", ,   , ¬´ ¬ª      .   ,    <a href="https://glukkazan.github.io/breakthrough/horn-chess-hard.htm"></a> .    ,    .      ( ),  .       <a href="">  AI</a> . <br><br><div class="spoiler"> <b class="spoiler_title"> -    !</b> <div class="spoiler_text"><pre> <code class="javascript hljs">Dagaz.AI.eval = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, params, board, player</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> white = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> black = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = <span class="hljs-number"><span class="hljs-number">0</span></span>; pos &lt; design.positions.length - <span class="hljs-number"><span class="hljs-number">3</span></span>; pos++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player == <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (white === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { black.push(pos); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r += MAXVAL / <span class="hljs-number"><span class="hljs-number">2</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { white = pos; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (white !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { r += white; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (black.length == <span class="hljs-number"><span class="hljs-number">2</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((black[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span> == black[<span class="hljs-number"><span class="hljs-number">1</span></span>]) &amp;&amp; (black[<span class="hljs-number"><span class="hljs-number">1</span></span>] + <span class="hljs-number"><span class="hljs-number">1</span></span> == white)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (board.player == <span class="hljs-number"><span class="hljs-number">1</span></span>) { r = MAXVAL; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { r = -MAXVAL; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (player == <span class="hljs-number"><span class="hljs-number">1</span></span>) { r = -r; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = board.apply(move); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> design.positions.length + Dagaz.AI.eval(design, ai.params, b, board.player) - Dagaz.AI.eval(design, ai.params, board, board.player); } ... AbAi.prototype.ab = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, node, a, b, deep</span></span></span><span class="hljs-function">) </span></span>{ node.loss = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.expand(ctx, node); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (node.goal !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -node.goal * MAXVALUE; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (deep &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.eval(ctx, node); } node.ix = <span class="hljs-number"><span class="hljs-number">0</span></span>; node.m = a; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((node.ix &lt; node.cache.length) &amp;&amp; (node.m &lt;= b) &amp;&amp; (<span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.now() - ctx.timestamp &lt; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.params.AI_FRAME)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> n = node.cache[node.ix]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(n.win)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t = -<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ab(ctx, n, -b, -node.m, deep - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((t !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (t &gt; node.m)) { node.m = t; node.best = node.ix; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { node.loss++; } node.ix++; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node.m; }</code> </pre></div></div><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/breakthrough/horn-chess-hard.htm%3Fsetup%3D02%3B03%3B-19"><img src="https://habrastorage.org/webt/de/cn/1e/decn1emepgcw-an_njtmbejda5m.png"></a> </div><br>     .     .   ¬´¬ª <a href="https://glukkazan.github.io/breakthrough/horn-chess.htm%3Fsetup%3D02%3B03%3B-19"></a>  ,        .   ‚Äî   ,    ,    .   ,    ,          ! <br><br> ,   <a href="https://glukkazan.github.io/shogi/tenjiku-shogi.htm">Tenjiku Shogi</a> ,   ,          .  ,    ‚Äî          .      AI,   .  ,   ,    <a href="https://glukkazan.github.io/breakthrough/horn-chess-hard.htm">Horn Chess</a>        ,  <a href="https://glukkazan.github.io/shogi/ko-shogi-board.htm">Ko Shogi</a>  <a href="https://glukkazan.github.io/xiangqi/gwangsanghui.htm">Gwangsanghui</a> .   ,    ¬´¬ª     ,     " <a href="https://glukkazan.github.io/checkmate/chess.htm"></a> ".     . <br><br><div style="text-align:center;"> <a href="https://glukkazan.github.io/custodian/ming-mang-small.htm"><img src="https://habrastorage.org/webt/uj/ti/ml/ujtimlfdgk2r1s8ehgqpi_p_vug.png"></a> </div><br>     .  ,   ,        .     ,    ,          .   " <a href="https://en.wikipedia.org/wiki/Custodian_capture">Custodian</a> "- (   " <a href="https://en.wikipedia.org/wiki/Ming_Mang_(game)">-</a> ")    . <br><br><div class="spoiler"> <b class="spoiler_title">     !</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span> = Dagaz.AI.eval; Dagaz.AI.eval = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, params, board, player</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> r = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(design, params, board, board.player); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cover = board.getCover(design); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cnt = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; _.each(cover, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">list</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cn = <span class="hljs-number"><span class="hljs-number">0</span></span>; _.each(list, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player == board.player) { r--; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { cn++; } } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((cnt === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) || (cnt &lt; cn)) { cnt = cn; } }); r += cnt * <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (board.player != player) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -r; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> done = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, player, pos, dir, trace, captured</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = design.navigate(player, pos, dir); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player == player) { _.each(trace, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.indexOf(captured, pos) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { captured.push(pos); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { trace.push(p); done(design, board, player, p, dir, trace, captured); trace.pop(); } } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> capture = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, player, pos, dir, dirs, trace, captured</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = design.navigate(player, pos, dir); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece.player == player) { _.each(trace, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.indexOf(captured, pos) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { captured.push(pos); } }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { trace.push(p); capture(design, board, player, p, dir, dirs, trace, captured); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (trace.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { _.each(dirs, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pos = design.navigate(player, p, dir); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pos !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (piece.player != player)) { trace.push(pos); done(design, board, player, pos, dir, trace, captured); trace.pop(); } } }); } trace.pop(); } } } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> checkCapturing = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board, pos, player, captured</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trace = []; capture(design, board, player, pos, <span class="hljs-number"><span class="hljs-number">3</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], trace, captured); capture(design, board, player, pos, <span class="hljs-number"><span class="hljs-number">1</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], trace, captured); capture(design, board, player, pos, <span class="hljs-number"><span class="hljs-number">2</span></span>, [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>], trace, captured); capture(design, board, player, pos, <span class="hljs-number"><span class="hljs-number">0</span></span>, [<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>], trace, captured); } Dagaz.Model.GetCover = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">design, board</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_.isUndefined(board.cover)) { board.cover = []; _.each(design.allPositions(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pos</span></span></span><span class="hljs-function">) </span></span>{ board.cover[pos] = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (board.getPiece(pos) === <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> neighbors = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attackers = []; _.each(design.allDirections(), <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">dir</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> p = design.navigate(<span class="hljs-number"><span class="hljs-number">1</span></span>, pos, dir); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> piece = board.getPiece(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { neighbors.push(piece.player); attackers.push(piece.player); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (p !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { piece = board.getPiece(p); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (piece !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { attackers.push(piece.player); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } p = design.navigate(<span class="hljs-number"><span class="hljs-number">1</span></span>, p, dir); } } } }); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (neighbors.length &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> captured = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((_.indexOf(attackers, <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (_.indexOf(neighbors, <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) { checkCapturing(design, board, pos, <span class="hljs-number"><span class="hljs-number">1</span></span>, captured); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((_.indexOf(attackers, <span class="hljs-number"><span class="hljs-number">2</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (_.indexOf(neighbors, <span class="hljs-number"><span class="hljs-number">1</span></span>) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>)) { checkCapturing(design, board, pos, <span class="hljs-number"><span class="hljs-number">2</span></span>, captured); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (captured.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { board.cover[pos] = _.uniq(captured); } } } }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> board.cover; }</code> </pre></div></div><br>   ,      ¬´¬ª,       .   ,      : <br><br><pre> <code class="javascript hljs">Dagaz.AI.heuristic = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ai, design, board, move</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> move.actions.length; }</code> </pre><br>      (    ) ‚Äî  !      ,     : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/QeE6VQzxpNg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> ,      ¬´¬ª  ( ,    ¬´¬ª       ).     ,      ¬´¬ª  ! <br><br>  ,   ,  ,   custodian-: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qJ_G8PyDBDg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <b><i>       !</i></b> <br></div><p>Source: <a href="https://habr.com/ru/post/349516/">https://habr.com/ru/post/349516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349504/index.html">tdlib-ruby: how to build a telegram client in ruby</a></li>
<li><a href="../349508/index.html">Java time machine</a></li>
<li><a href="../349510/index.html">How we set up Continuous Delivery at Kubernetes using TFS</a></li>
<li><a href="../349512/index.html">Browser! = Browser engine</a></li>
<li><a href="../349514/index.html">Announcement of Serverless Moscow Meetup # 1</a></li>
<li><a href="../349518/index.html">A new version of RMM-solution Panda Systems Management has been released.</a></li>
<li><a href="../349520/index.html">What it is - BPM, and how companies build it</a></li>
<li><a href="../349522/index.html">Quick Start Guide: Linking ASP.NET Core Web API + Angular 5</a></li>
<li><a href="../349524/index.html">School of information security. Yandex Experience and Practice</a></li>
<li><a href="../349526/index.html">Porting your own OS to Xen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>