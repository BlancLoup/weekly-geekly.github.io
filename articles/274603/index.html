<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PROLOG for programmers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The logic programming language PROLOG (hereinafter - the PROLOGUE) seems to most programmers to be something confusing and unsuitable for practical us...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PROLOG for programmers</h1><div class="post__text post__text-html js-mediator-article"> The logic programming language PROLOG (hereinafter - the PROLOGUE) seems to most programmers to be something confusing and unsuitable for practical use.  At the same time, the Internet is based on symbolic information, therefore almost all modern programmers are faced with the need to process symbolic data structures, and after all, the logic language PROLOG is intended for this.  This language is ideal for working with character structures, text files and for building intelligent programs. <a name="habracut"></a><br>  After many years of working with the PROLOG, I ran into the new-fangled Haskell, about which all authors proudly say - ‚Äúhigh threshold of entry‚Äù.  In my opinion, the ‚Äúheight‚Äù of this threshold was formed as a result of confusing syntax and clutter of embedded procedures.  Another source of this ‚Äúheight‚Äù is the arrogance of the authors of numerous manuals, which are written as if the reader never wrote programs. <br>  I immediately wanted to go back, to the ‚Äúnative‚Äù PROLOGUE - simple and understandable.  I think if you explain without piling up, such as declarative semantics, the time of entry into logic programming for the "ordinary" programmer will not exceed 30 minutes. <br>  I will try to describe it in terms of procedural programming. <br>  PROLOGUE has two main differences from procedural languages ‚Äã‚Äã- the method of organizing calculations and the way of presenting data.  Both of these aspects of the language are fundamentally different from traditional programming languages.  But let's not forget that logic programming is implemented on the same machines with the background - Neuman architecture. <br>  Imagine a programming language in which all operations are reduced to a procedure call.  Moreover, each procedure exists in several variants and the program chooses for itself the correct, or more precisely, variant implementation (body) of the procedure that is suitable for each specific variant of the initial data.  How suitability is determined - each procedure call, during the execution of the program, according to the results of the procedure execution, gets a logical value - TRUE or FALSE.  A set of procedures with the same name and arity is called a predicate. <br>  Each predicate in the PROLOG language is identified by two parameters ‚Äî a name and an arity ‚Äî the number of parameters.  For example, the predicate for inverting lists is identified as nrev / 2, and the predicate for joining lists as append / 3.  No declaration of parameters or variables is required, but you can limit the parameters to a pattern in the procedure header.  For example, in one variant of the predicate, the first parameter can be specified as [] - an empty list, in the other - as [A, B, C] - a list of three elements, and in the third one as [H | T] - an arbitrary non-empty list. <br>  If some condition in the procedure body is not met, the execution is terminated and the procedure call, more precisely, the execution of the next variant of the procedure body, is terminated and gets the value FALSE.  In this case, the language interpreter launches the next in order version of the body of this procedure.  If all the options turned out to be unsuitable, a return to the previous procedure occurs and for it the selection of options also occurs, thus, the calculation in the PROLOGUE is reduced to bypassing the procedure nesting tree. <br>  Returning to the previous call is called backtracking.  In essence, this is a rollback, since all values ‚Äã‚Äãreceived by the variables in the canceled procedure are canceled.  Backtracking is a unique tool of this language, which has no analogues in any of the other mass programming languages.  Backtracking provides a complete traversal of the inference tree, which provides the basis for solving intelligent tasks. <br><br>  Algorithm of program interpretation (goal fulfillment) in the PROLOG system. <br><br>  Input: target p (A1, A2, ..., An) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      1. Find in memory a procedure named p with the arity n. <br>  2. Unify the input parameters of the target with the header of the procedure found. <br>  3. If the unification of parameters has passed, perform the first goal from the body of the procedure found. <br>  4. If the unification fails, find the next variant of the P / n procedure. <br>  5. If the next variant of the P / n procedure is not found, finish the job with the result FAIL. <br>  6. If the first goal is fulfilled, go to the next goal. <br>  7. If the next goal is not fulfilled, return to the previous goal and execute the next variant of its implementation. <br>  8. If the current implementation of the P / n procedure fails, go to the next option. <br>  9. If all targets from the procedure body are completed, finish the work with the result TRUE. <br><br>  In connection with such a structure of calculations, each procedure call is called a goal, which can be achieved or not.  Every calculation in the PROLOGUE has a logical value.  Computation is also called the search for inference (proof), and the PROLOGUE is called the logic programming language. <br>  Probably syntactically PROLOGUE is the easiest programming language.  The main syntax is a predicate - an expression similar to a procedure call - a name and a list of arguments - <br>  P (x1, ... xn).  Names are written with a small letter, and variables - with a large one. <br>  If you omit the details, the syntax of the PROLOGUE can be described as follows: <br><br>  &lt;PROLOGUE&gt;&gt; = = rule&gt; |  &lt;fact&gt; |  &lt;request&gt; <br>  &lt;rule&gt; :: = &lt;header&gt; ': -' &lt;body&gt; <br>  &lt;fact&gt; :: = &lt;header&gt; '.' <br>  &lt;query&gt; :: = &lt;body&gt; '.' <br>  &lt;body&gt; :: = &lt;target&gt; / ',' &lt;target&gt; / '.' <br>  &lt;heading&gt; :: = &lt;predicate&gt; <br>  &lt;target&gt; :: = &lt;predicate&gt; | &lt;expression&gt; <br>  &lt;predicate&gt; :: = &lt;name&gt; / '(' &lt;&lt;term&gt; / ',' &lt;term&gt; / ')' / <br>  &lt;term&gt; :: = &lt;atom&gt; | &lt;predicate&gt; | &lt;list&gt; <br>  &lt;atom&gt; :: = &lt;variable&gt; | &lt;number&gt; | &lt;line&gt; | &lt;name&gt; <br>  &lt;list&gt; :: = &lt;list with heading&gt; |  &lt;simple list&gt; <br>  &lt;list with title&gt; :: = '[' &lt;term&gt; / ',' &lt;term&gt; / '|'  &lt;term&gt; ']' <br>  &lt;simple list&gt; :: = '[' &lt;term&gt; / ',' &lt;term&gt; / ']' | '[' ']' <br>  &lt;expression&gt; :: = &lt;term&gt; / &lt;operator&gt; &lt;term&gt; / <br>  &lt;operator&gt; :: = 'is' |  '=' |  '==' |  '\ =' |  '&gt; =' |  '= &lt;' |  '= \ =' | <br><br>  As can be seen from the syntax, there are no reserved names in the PROLOGUE except for the predicate ‚Äúis‚Äù, although various built-in predicates are used for convenience and connection with the external environment. <br><br>  An example is family relationships. <br>  We define the rules for relationships - spouse, child, mother, daughter, brother, descendant.  Family relationships are given by binary and unary predicates - rules (predicates with variables) and facts (predicates with constants).  The rules are easy to understand, since family relationships are clear to everyone.  For example, the first rule is: X is the mother of Y if Y is a child of X and X is female. <br><br>  mother (X, Y): - child (X, Y), female (X). <br>  daughter (X, Y): - child (Y, X), female (X). <br>  grandchild (X, Y): - child (X, Z), child (Z, Y). <br>  descendant (X, Y): - child (X, Y). <br>  descendant (X, Y): - grandchild (X, Z). <br><br>  Facts describe relatives of a particular family. <br><br>  marrow (john, meri).  female (meri). <br>  child (john, jack).  child (meri, jack).  child (john, kate). <br>  marrow (jack, joan).  marrow (kate, dick). <br>  child (jack, henry).  child (kat, josh). <br>  male (john).  female (mery). <br>  male (henry).  female (joan). <br>  male (josh)  male (dick). <br><br>  One set of rules (program) can be applied to different sets of facts (data). <br>  The set of possible requests is determined by the existing set of rules.  The title of each rule is the basis for building queries. <br>  Requests can be of two types - verification and search. <br>  Examples of search queries: <br>  Whose daughter is Kat?  - daughter (X, kat). <br>  Whose grandson is Henry?  - grandchild (X, henry) <br>  Examples of verification requests: <br>  Dick is Meri's baby?  - child (mery, dick). <br><br>  The main concepts of the PROLOGUE: lists, recursion, unification, backtracking.  Lists are the basic data structure used in this language.  Lists are the basis for the organization of all complex calculations.  One of the main properties of the list is the absence of restrictions on the elements and size of the list.  The nesting of lists is also not limited by anything.  The list in the language is interpreted as a structure of two elements - "head" and "tail".  This division is the basis for the computation of lists, so the most commonly used list pattern is [H | T]. <br>  The first list item can have any structure, and the second one is also a list.  An empty list contains no elements and is denoted as []. <br>  The second basic structural unit of the language - the predicate has the form - p (A1, A2, ..).  Predicates are convenient for grouping data into one sense unit.  Unlike the list, the number of predicate arguments is fixed.  The name of the predicate is written with a small letter, like all constants in the language. <br>  Variables always begin with a capital letter.  On the basis of variables it is possible to build patterns for lists. <br><br>  Examples of list patterns: <br>  [H | T] is not an empty list; <br>  [] - empty list; <br>  [A1, A2, A3] - a list of three arbitrary elements; <br>  [A, A, A | T] - a list in which the first three elements are the same; <br>  [x, 10 | T] is a list in which the symbolic constant ‚Äúx‚Äù is in the first place, and the second is the numeric constant 10. <br>  The recursiveness of the list structure is an important element in the organization of recursive calculations.  Recursive predicates have at least two procedures ‚Äî one for the general case, the other for the completion. <br>  Recursiveness of lists provides the possibility of a simple formulation of the algorithm for operations on lists. <br>  Example: Calculating the length of a list. <br><br>  length ([H | T], N): - length (T, N1), N is N1 + 1. <br>  length ([], 0). <br><br>  Example: Invert list. <br><br>  nrev ([H | T], L): - nrev (T, L1), append (L1, [H], L). <br>  nrev ([], []). <br><br>  There are no functions in PROLOGUE; therefore, it is impossible to insert, for example, the length of the list length (L) as an argument, as is done in all procedural languages. <br>  At the same time, PROLOGUE can be considered as a completely imperative language, in which all operations, with the exception of betrecking, are explicitly prescribed. <br>  Unification at first glance introduces some mystery and incomprehensibility into the language, but it has a completely procedural explanation. <br>  Unification is the substitution of parameters into a pattern and is used not only to select input parameters, but also to automatically select the necessary list items and manipulate them - add and delete the head element of the list. <br>  Example: join lists. <br><br>  append ([H | T], L, [H | L2]): - append (T, L, L2). <br>  append ([], L, L). <br><br>  It would be more correct to write the second argument in the form [H1 | T1], since the second argument should be a list, but this will complicate the predicate, since the second argument can be an empty list. <br>  Variables in the PROLOGUE are logical, i.e.  re-unification within one procedure is impossible.  You cannot write L = [a, b, c], and then L = [12].  The consistency of variables leads to the complication of unification, since all unifications in the body of a single procedure cannot be revised during the calculation process, which means that they cannot contradict each other. <br>  The unification of logical variables leads to unexpected effects that have a completely imperative explanation. <br>  Example: use case for list join predicate. <br>  Compound: <br><br>  append ([a, b, c], [d, e, f], L). <br>  L = [a, b, c, d, e, f] =&gt; <br>  yes. <br><br>  Check connection lists: <br><br>  append ([a, b, c], [1,2,3], [a, b, c, 1,2,3]). <br>  yes. <br><br>  List decomposition: <br><br>  append (L1, L2, [a, b, c]). <br><br>  L1 = [a, b, c] <br>  L2 = [] -&gt;; <br><br>  L1 = [a, b] <br>  L2 = [c] -&gt;; <br><br>  L1 = [a] <br>  L2 = [b, c] -&gt;; <br><br>  L1 = [] <br>  L2 = [a, b, c] -&gt;; <br>  no. <br><br>  Here, the symbol ‚Äú;‚Äù means a request for another solution by running backtracking. <br><br>  Subtract lists: <br><br>  append ([a, b], L, [a, b, c, d]). <br>  L = [c, d]. <br><br>  In the PROLOGUE, it is customary to distinguish calculations with backtracking (non-deterministic) and without it (deterministic). <br>  Example of a non-deterministic predicate: Solving a numerical puzzle. <br><br>  / * <br>  DONALD <br>  + <br>  Gerald <br>  - ROBERT * / <br><br>  sum (L1, L2, L3): - <br>  sum1 (L1, L2, L3, L1, L2, L3.0, [0,1,2,3,4,5,6,7,8,9]). <br><br>  sum1 (L1, L2, L3, L11, L12, L13, Ii, Lv): - <br>  dl (L11, L111, E1), <br>  dl (L12, L121, E2), <br>  dl (L13, L131, E3), <br>  val (E1, Lv, Lv1), val (E2, Lv1, Lv2), val (E3, Lv2, Lv3), <br>  sd (E1, E2, E3, Ii, Io), <br>  sum1 (L1, L2, L3, L111, L121, L131, Io, Lv3). <br><br>  sum1 (L1, L2, L3, [], _, _, 0, _): -! .. <br><br>  dl ([H | T], [H | T1], E): - dl (T, T1, E). <br>  dl ([H], [], H). <br><br>  val (E, L, L): - nonvar (E). <br>  val (E, L1, L2): - del (E, L1, L2). <br><br>  sd (A, B, C, Ii, Io): - <br>  C1 is A + B + Ii, <br>  C is C1 mod 10, <br>  Io is C1 // 10. <br><br>  del (E, [E | T], T). <br>  del (E, [H | T], [H | T1]): - del (E, T, T1). <br><br>  s: - <br>  A1 = [D, O, N, A, L, D], <br>  A2 = [G, E, R, A, L, D], <br>  A3 = [R, O, B, E, R, T], <br>  sum (A1, A2, A3), <br>  write (A1), nl, <br>  write (A2), nl, <br>  write (A3), nl. <br><br>  The predicate sum / 3 performs the basic operation of selecting the values ‚Äã‚Äãof numbers for a given letter formula.  The calculation is carried out for the formula of adding two numbers of any length.  If there are known digits, you can insert them instead of variables.  If the length of the items is different, you can insert zeros at the beginning of the corresponding list. <br>  The predicate sum1 / 8 uses the first three arguments to record the result, the arguments numbered 4,5,6 as working variables, the seventh argument the initial value of the hyphenation digit, the eighth argument the list of valid digits. <br>  The dl / 3 predicate selects and removes the last item from the list of variables. <br>  The predicate val / 3 selects a valid value from the list of remaining options, and the selected digit option is removed from the list of valid options. <br>  If the variant of the value for the next letter was established earlier, then it remains unchanged. <br>  The predicate sd / 5 checks the variant of a given triple of digits of one column: <br><br>  A + B + Ii = C + Io * 10 <br><br>  If sd / 5 is not executed, backtracking occurs ‚Äî the last of the calls to the predicate val / 3 assigns the new value to the variable E3.  If none of the values ‚Äã‚Äãof E3 come up, backtracking goes one step back - a new value is selected for E2, then - if no other E3 E2 variant is suitable, for E1. <br>  The predicate sum1 / 8 is executed recursively until the input list of variables is exhausted. <br>  Predicate s / 0 - an example of calling sum / 3 predicate to solve one variant of the puzzle. <br>  As can be seen from the example, the program on the PROLOGE can be very compact, and the algorithm is simple and transparent, since no implicit function calls are used. <br><br>  It is possible to develop a program for solving such puzzles, for example, to make it universal - for all types of numerical puzzles, to improve the input of initial data. <br>  To do this, you need to do such operations as lexical and syntactic analysis.  These operations will be considered in the second part. </div><p>Source: <a href="https://habr.com/ru/post/274603/">https://habr.com/ru/post/274603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../274591/index.html">Experience Angular + Typescript + Offline SPA project in a year</a></li>
<li><a href="../274593/index.html">Universal Memcomputing Machines as an alternative to Turing Machine</a></li>
<li><a href="../274595/index.html">Next week, Microsoft stops supporting all versions of IE, except 11</a></li>
<li><a href="../274597/index.html">Overview of the example application of reinforcement learning using TensorFlow</a></li>
<li><a href="../274601/index.html">Tips for novice microcontroller programmers</a></li>
<li><a href="../274605/index.html">Low-level optimization of parallel algorithms or SIMD in .NET</a></li>
<li><a href="../274611/index.html">Use apply, sapply, lapply in R</a></li>
<li><a href="../274613/index.html">Wi-Fi Alliance announced a new type of Wi-Fi for IoT and low-power devices</a></li>
<li><a href="../274615/index.html">The pitfalls of using Excel Power Query and MySQL to automate reporting</a></li>
<li><a href="../274617/index.html">Disable the bomb with Radare2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>