<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The architecture of the network core in the iOS application on Swift 3. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Network core as part of the application 
 To begin with, I will explain a little about what will be discussed in this article. Now the majority of mob...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The architecture of the network core in the iOS application on Swift 3. Part 1</h1><div class="post__text post__text-html js-mediator-article"><h1>  Network core as part of the application </h1><br>  To begin with, I will explain a little about what will be discussed in this article.  Now the majority of mobile applications, in my opinion, are client-server.  This means that they contain, as part of the code, a network core responsible for sending requests and receiving responses from the server.  Moreover, this is not about network libraries that take responsibility for "low-level" request management, such as sending REST requests, building a multipart body, working with sockets, web sockets, and so on.  This is an additional binding that allows you to manage requests, responses and status data specific to your server.  It is in the embodiments of this binding that the main problems of the network layer are contained in many mobile projects with which I had to work. <br><br>  This article aims to bring <i>one of the</i> architectural solutions for building the network core of the application, which I came to after a long time working with different models and different server APIs, and which is currently the most optimal for the tasks I encounter in the process of working on projects .  I hope this option will help you develop a well-structured and easily expandable network core if you start a new project or modify an existing one.  I will also be glad to hear your advice and comments on improving the code and / or the proposed architecture.  And yes, the article due to the large volume will be released in two parts. <br><br>  Details under the cut. <br><a name="habracut"></a><br><h1>  Client-server interaction </h1><br>  In the course of work, you have to disassemble a lot of various projects that in one way or another interact with servers built using the REST protocol.  And in most of these projects, there is a picture from the category ‚Äúwho is in the forest, who is for firewood‚Äù, since the network core is everywhere implemented differently (however, like other architectural parts of the application).  The situation is especially bad when in one project one can see the hand of several developers who have succeeded each other (and, moreover, under tight deadlines, as a rule).  In such cases, it often turns out that the ‚Äúcore‚Äù of a rather creepy look, almost having its own intellect.  Let's try to protect ourselves from such problems with the help of the proposed approach. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Where do we start? </h2><br><ul><li>  To implement we will use the language Swift version 3.0. <br><br></li><li>  Let's agree that we will use a hypothetical REST server that works only with GET and POST requests.  As answers, he will return us either JSON or some data (unfortunately, not all servers have a unified form of response, so we have to provide different options). <br><br></li><li>  We also agree that for a ‚Äúlow-level‚Äù network communication we do not need a separate network library, we will write this part ourselves (especially at the time of this writing, the network libraries updated to version 3.0 of the language simply do not exist). <br><br></li><li>  The proposed approach is a stripped-down version of the SOA (Service-Oriented Architecture) architecture, with remote parts not used in small projects (such as a separate caching subsystem) adapted to the strict typing conditions of the Swift language. <br><br></li><li>  Xcode Playground will be enough for us to implement, a separate project is not required. </li></ul><br>  Let's get started  First, a little about the process itself.  We describe the step-by-step scheme of the client mobile application with the server: <br><br><ul><li>  The user performs an action that requires interaction with the server. <br><br></li><li>  The application sends a GET or POST request to the server through the network core, specifying a specific URL, header set, request body, timeout, cache policy, and other parameters. <br><br></li><li>  The server processes the request and sends (or does not send, if something went wrong with the communication channel) response to the application. <br><br></li><li>  The application analyzes the information received, updates the state data and the user interface. </li></ul><br><h2>  And what's the difficulty? </h2><br>  And really, as long as everything sounds pretty simple.  However, in reality, these 4 simple points contain additional steps that require additional labor, and this is where the diversity begins in terms of the implementation of these very intermediate steps.  Let's expand our sequence a little, having added it with the questions arising in the course of work: <br><br><ul><li>  <em>The user performs an action that requires interaction with the server.</em> <br><br><ul><li>  Does user action depend on the status data associated with the server?  For example, does the action require an authorization token?  If so, where to store it, how to check it? <br><br></li><li>  The server API can consist of several ‚Äúaccess points‚Äù, for example, an authorization node, a user data processing node, and so on.  It would be nice to somehow divide these actions into groups, so as not to dump all the code into one big sheet. <br><br></li><li>  The user may want to cancel his action (if the application gives him the opportunity).  We should also be able to handle such situations. <br><br></li></ul></li><li>  <em>The application sends a GET or POST request to the server via the network core.</em> <br><br><ul><li>  We have a separate base URL of our server (there may be several of them), relative to which the absolute address is built.  It needs to be somehow set in order not to spend a lot of code not this same type of action, but at the same time make our solution customizable. <br><br></li><li>  Each request may have a mandatory set of headers, as well as additional headers required for a particular request, including the types of data sent and received. <br><br></li><li>  The request can be launched in a special session (speech about URLSession), with a specific timeout and data caching policy. <br><br></li><li>  It would be nice to have a list of all asynchronous requests being executed at the moment; this can be useful both from the point of view of analytics and from the point of view of debug information. <br><br></li></ul></li><li>  <em>The server processes the request and sends (or does not send, if something went wrong with the communication channel) response to the application.</em> <br><br><ul><li>  Since the receipt of the response is an unstable event, we definitely need to be able to handle not only the answers, but also the generated errors.  And given that server APIs often do not have any kind of unified structure of responses and error output, you should be prepared to receive a variety of error formats, including system ones. <br><br></li><li>  Since, in a successful response (depending on the implementation of the server API), we may receive both a successful response itself and a server‚Äôs failure to process the operation (for example, if we forgot to specify an authorization token for a request closed by user authorization), we need to be able to process successful responses as well as ‚Äúsuccessful mistakes‚Äù.  At the same time, the handlers themselves should preferably be placed in the form of self-contained separate entities in the code, which can be easily analyzed and accompanied. <br><br></li></ul></li><li>  <em>The application analyzes the information received, updates the state data and the user interface.</em> <br><br><ul><li>  This item again brings us back to the issue of storing state data.  We must select the data from the server response that we need to display the user interface, as well as the data that may be needed for further requests to the server, process them and save them in a convenient form. </li></ul></li></ul><br>  It would seem that a fairly simple set of questions, but due to the number and variety of tools available in the language, the implementation of all these stages from project to project may vary beyond recognition.  By the way, with a small modification, the proposed approach can also be applied in Objective-C (as a language with weak typing), but this is beyond the scope of this article. <br><br><h1>  Design </h1><br>  To solve all the above questions, we need several entities: <br><br><ul><li>  <em>Information about the "successful error."</em>  This entity will provide receiving and storing information about the "successful error" or "server failure", as I most often call it - for example, an authorization error. <br><br></li><li>  <em>Server response information.</em>  It will store all the information received from the server so that it is guaranteed that there is no shortage.  Sooner or later, projects have to analyze what has come from the server, down to the URLResponse parameters, so it‚Äôs best to keep all such data in quick access. <br><br></li><li>  <em>Asynchronous network task.</em>  Actually the asynchronous task itself, which stores its state, as well as input and output parameters, including, of course, the server request itself. <br><br></li><li>  <em>Task pool</em>  The class is engaged in sending and accounting for active asynchronous network tasks.  It also stores general data on the server API, such as the base URL, standard header set, and so on. <br><br></li><li>  <em>Response processing protocol</em>  This protocol will provide us with the ability to create strongly typed entities ( <i>‚Äúparsers‚Äù, or handlers</i> ) that can take data stream (including formatted JSON) as input and transform it into application-friendly structures or <i>data models</i> (about them below). <br><br></li><li>  <em>Data models</em>  Data structures that are understandable and user-friendly.  They are a reflection of server data in a form adapted for the application. <br><br></li><li>  <em>Parsers, or response handlers.</em>  Entities that transform raw data into data models, and vice versa.  Implement the response processing protocol. <br><br></li><li>  <em>Service, or data access node.</em>  Encapsulates the management of a group of logically related operations.  For example, AuthService, UserService, ProfileService, and so on. </li></ul><br>  If it seems to you that there are too many links here, initially I thought so too.  Until I tried several projects with a lack of a designed network core in principle.  Without a clear structure, after the implementation of 5-10 requests to the server, the code begins to quickly turn into a mess, if left unstructured.  Again, I propose only one of the approaches, and at the moment it is he who is most convenient for me in working on projects. <br><br>  For clarity, I reflected the whole process in the diagram (the image is clickable): <br><br> <a href="http://piccy.info/view3/10279406/701196943a20b3068e09035894f28c12/1200/"><img src="http://i.piccy.info/i9/0d83fa56c804280cb7e583517d41dd63/1473874742/49300/1070064/soa_scheme_800.jpg"></a> <a href="http://i.piccy.info/a3c/2016-09-14-17-39/i9-10279406/800x523-r"><img src="https://habrastorage.org/getpro/habr/post_images/0ca/608/1c3/0ca6081c3a10b0f426bc590924d6001b.gif"></a> <br><br><h1>  Kernel implementation </h1><br>  Go.  Create a Playground and go straight along the steps from the previous section.  Plus, suppose that in most cases my server returns me JSON.  Which JSON parser to use is at your discretion, at the time of writing this article, again, there were no libraries adapted for the third version of the language, so I used the self-written GJSON parser. <br><br><h3>  Error info </h3><br>  It's all pretty basic, a class with a pair of fields and an initializer.  We finalize it, as part of our task, we don‚Äôt need extensions (of course, this may be different in your project): <br><br><div class="spoiler">  <b class="spoiler_title">Error info</b> <div class="spoiler_text"><pre><code class="hljs cmake">final class ResponseError { let code: NSNumber? let <span class="hljs-keyword"><span class="hljs-keyword">message</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">String</span></span>? // MARK: - Root init(json: Any?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let obj = GJSON(json) { code = obj.number(<span class="hljs-string"><span class="hljs-string">"code"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> = obj.<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(<span class="hljs-string"><span class="hljs-string">"message"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { code = nil <span class="hljs-keyword"><span class="hljs-keyword">message</span></span> = nil } } }</code> </pre> </div></div><br><h3>  Response information </h3><br>  Slightly more detailed class, the principle is the same.  In this case, it also corresponds to the response returned by the server, this is binary input data, response code, optional message + parsed error: <br><br><div class="spoiler">  <b class="spoiler_title">Response information</b> <div class="spoiler_text"><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> data: <span class="hljs-type"><span class="hljs-type">Any?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> code: <span class="hljs-type"><span class="hljs-type">NSNumber?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> message: <span class="hljs-type"><span class="hljs-type">String?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> error: <span class="hljs-type"><span class="hljs-type">ResponseError?</span></span> <span class="hljs-comment"><span class="hljs-comment">// MARK: - Root init?(json: Any?) { guard let obj = GJSON(json) else { return nil } code = obj.number("code") message = obj.string("message") data = json error = ResponseError(json: json) } }</span></span></code> </pre> </div></div><br>  For convenience in your project, if you work with guaranteed JSON in the returned binary data, you can extend this class through extension, for example, by adding a field that returns a json parser (as an example) to it: <br><br><div class="spoiler">  <b class="spoiler_title">Expansion for convenience</b> <div class="spoiler_text"><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Response</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parser: <span class="hljs-type"><span class="hljs-type">GJSON?</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">GJSON</span></span>(data) } }</code> </pre> </div></div><br><h3>  Asynchronous network task </h3><br>  This is a much more interesting thing.  The purpose of this class is to store all the data returned, all the received data and its state (completed / canceled).  It can also send itself to the network and call a callback after completion of the work.  Upon receiving a response from the server, it records all received data, including attempts to transform the input data into a JSON object, if possible, to simplify subsequent processing.  Also, since we will use the set of such tasks in the future within the Set, we will need to implement a couple of system protocols. <br><br><div class="spoiler">  <b class="spoiler_title">Asynchronous network task</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">typealias DataTaskCallback = (DataTask) -&gt; () final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> DataTask: Hashable, Equatable { let taskId: String let request: URLRequest let <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>: URLSession private(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) var responseObject: Response? private(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) var response: URLResponse? private(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) var error: Error? private(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) var isCancelled = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> private(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) var isCompleted = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> private var task: URLSessionDataTask? // MARK: - Root init(taskId: String, request: URLRequest, <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>: URLSession = URLSession.shared) { self.taskId = taskId self.request = request self.<span class="hljs-keyword"><span class="hljs-keyword">session</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> } // MARK: - Controls func <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>(callback: DataTaskCallback?) { task = <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>.dataTask(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: request) { [unowned self] (data, response, error) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.isCancelled { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } self.isCompleted = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> // <span class="hljs-keyword"><span class="hljs-keyword">transform</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> possible var wrappedData: <span class="hljs-keyword"><span class="hljs-keyword">Any</span></span>? = data <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> data != nil { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> let <span class="hljs-type"><span class="hljs-type">json</span></span> = try? JSONSerialization.jsonObject(<span class="hljs-keyword"><span class="hljs-keyword">with</span></span>: data!, <span class="hljs-keyword"><span class="hljs-keyword">options</span></span>: .allowFragments) { wrappedData = <span class="hljs-type"><span class="hljs-type">json</span></span> } } // parse self.responseObject = Response(<span class="hljs-type"><span class="hljs-type">json</span></span>: wrappedData) self.error = error // callback callback?(self) } task?.resume() } func cancel(callback: DataTaskCallback?) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> task != nil &amp;&amp; !isCompleted &amp;&amp; !isCancelled { isCancelled = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> task?.cancel() // callback callback?(self) } } // MARK: - Equatable static func ==(lhs: DataTask, rhs: DataTask) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lhs.taskId == rhs.taskId } // MARK: - Hashable var hashValue: <span class="hljs-type"><span class="hljs-type">Int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> taskId.hashValue } }</code> </pre> </div></div><br><h3>  Task pool </h3><br>  As mentioned earlier, this class will keep track of active asynchronous tasks, which can be useful when analyzing or debugging.  As a bonus, it allows you to find a task by its identifier and, for example, cancel it.  Through the task pool, all tasks are sent to the network (it can be done without it, but then you have to store the task somewhere independently, which is not very convenient).  Class doing singlton, of course. <br><br><div class="spoiler">  <b class="spoiler_title">Task pool</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">final <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> TaskPool { static let instance = TaskPool() // singleton let <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> = URLSession.shared // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">session</span></span> let baseURLString = "https://myserver.com/api/v1/" // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> base URL var defaultHeaders: [String: String] { // <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> headers list <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ["Content-Type": "application/json"] } private(<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>) var activeTasks = <span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>&lt;DataTask&gt;() // MARK: - Root private init() { } // forbid multi-instantiation // MARK: - Controls func send(task: DataTask, callback: DataTaskCallback?) { // <span class="hljs-keyword"><span class="hljs-keyword">check</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> existing task <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> taskById(task.taskId) != nil { print("task with id \"\(task.taskId)\" is already active.") <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } // <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> activeTasks.<span class="hljs-keyword"><span class="hljs-keyword">insert</span></span>(task) print("start task \"\(task.taskId)\". URL: \(task.request.url!.absoluteString)") task.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span> { [unowned self] (task) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.activeTasks.remove(task) print("task finished \"\(task.taskId)\". URL: \(task.request.url!.absoluteString)") callback?(task) } } func send(taskId: String, request: URLRequest, callback: DataTaskCallback?) { let task = DataTask(taskId: taskId, request: request, <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">session</span></span>) send(task: task, callback: callback) } func taskById(_ taskId: String) -&gt; DataTask? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> activeTasks.first(<span class="hljs-keyword"><span class="hljs-keyword">where</span></span>: { (task) -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> task.taskId == taskId }) } }</code> </pre> </div></div><br><h3>  Protocol </h3><br>  And the final part, relating directly to the network core, is the processing of responses.  Strong language typing makes its own adjustments.  We want our parser classes to process the data and give us a specific data type, not some Any ?.  For these purposes, we will make a small generic protocol, which we will further implement: <br><br><div class="spoiler">  <b class="spoiler_title">Protocol</b> <div class="spoiler_text"><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JSONParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">ModelType</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(json: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ModelType?</span></span> }</code> </pre> </div></div><br><h1>  What's next? </h1><br>  Actually, on this creation of a network kernel is complete.  It can be easily transferred between projects, only slightly podhertovyvaya structure information about the response and error, as well as the address of the server API. <br><br>  In the second part of this article, we will look at how to use the created network core in a project in order to maximize the benefits of the proposed architecture. </div><p>Source: <a href="https://habr.com/ru/post/309990/">https://habr.com/ru/post/309990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309978/index.html">One-way data binding with ECMAScript-2015 Proxy</a></li>
<li><a href="../309980/index.html">Automatic deployment of the ElasticBeanstalk application using Bitbucket Pipelines</a></li>
<li><a href="../309984/index.html">Comparison of EDS available on the Kazakhstan market</a></li>
<li><a href="../309986/index.html">Reaching goals: 9 life hacking from SmartProgress</a></li>
<li><a href="../309988/index.html">Keen observer</a></li>
<li><a href="../309992/index.html">Webinar: Tools for Data Scientist</a></li>
<li><a href="../309994/index.html">Remote annunciator of critical temperature and humidity based on AVR MK and DHT22 sensor</a></li>
<li><a href="../309996/index.html">How the Dolphin Emulator defeated the latest unplayed GameCube game</a></li>
<li><a href="../310000/index.html">How we repaired compaction in Cassandra for a week</a></li>
<li><a href="../310002/index.html">Hypervisor wars: To be continued</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>