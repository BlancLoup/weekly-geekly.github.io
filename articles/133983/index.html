<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Impressive Solids: making a game in C # under OpenGL, part I</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Once upon a time in america 
 Once, in 2002, an interesting toy called Amazing Blocks came to my computer. The game, so to speak, Tetris class (a deta...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Impressive Solids: making a game in C # under OpenGL, part I</h1><div class="post__text post__text-html js-mediator-article"><h3>  Once upon a time in america </h3><br>  Once, in 2002, an interesting toy called Amazing Blocks came to my computer.  The game, so to speak, Tetris class (a detailed description of the gameplay below);  She was very fond of my mother, who played the game for hours.  However, there was an annoying drawback: after what seems to be 10 launches, the game began to require registration, which, surprisingly, was free, but through the Internet, which, of course, was an insurmountable obstacle, since there was no Internet then. , although they heard that there is such a thing.  I had to constantly reinstall. <br><br>  Three years later, when the Internet was already held, and the game managed to become shareware and start asking for registration for some money, I tried to register it, however, the manufacturer‚Äôs website was dead rather than alive by that time, and apparently remains so and to this day.  The shareware-version of the game is easily found on the Internet, a lot of, I‚Äôm not afraid of this word, keygens, which are actually trojans, and not a single opportunity to register the game so that mom can play it on a completely different computer.  At some point I thought: why not just make the same game myself and solve the problem at the root?  At the same time, this can result in some kind of hello-world in developing a simple PC game in modern conditions - which I offer to the attention of readers. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a19/a28/fcc/a19a28fcc36df9eacf2a4ddbd6c2ed68.png" alt="image" align="left">  So, what kind of game are we going to do?  The bottom line is this.  In a rectangular glass 7 √ó 13, a horizontal stick consisting of 3 color blocks falls (there are 5 colors in total).  While moving, it can be moved left and right, as well as interchanged blocks in rotation from right to left (red, green, blue ‚Üí green, blue, red).  As soon as the stick touches the floor of the glass or any of the fixed blocks in the glass, it can no longer be controlled.  The blocks that make up the stick continue to fall apart until they are placed on a fixed block or half a glass.  After that, it is checked whether a horizontal, vertical or diagonal line of three or more blocks of the same color has turned out in the glass;  such lines are destroyed.  If there were blocks on top of the destroyed line, they slide down to the empty space formed, then the formed lines are destroyed again.  When everything settles down, a new stick begins to fall from above.  For building lines destroyed player gets points.  The game ends when the glass is filled to the top. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Technology.  The game will be done in C # (I have long wanted to see what it is), OpenGL (DirectX only works under Windows, but I prefer Linux more), Mercurial for version control (writing code without VCS is disrespect for myself). <br><br>  The game will be called Impressive Solids. <br><br><a name="habracut"></a><br><h3>  Inception </h3><br>  Development under Windows will be conducted in <a href="http://www.microsoft.com/visualstudio/en-us/products/2010-editions/visual-csharp-express">Microsoft Visual C # 2010 Express</a> (distributed for free).  We also need <a href="http://tortoisehg.bitbucket.org/">TortoiseHg</a> , the Windows client of the Mercurial version control system.  Under Linux-based systems, we will use MonoDevelop and console hg. <br><br>  To connect OpenGL, we use binding <a href="http://www.opentk.com/">OpenTK</a> .  You need to download a fresh <a href="http://sourceforge.net/projects/opentk/files/opentk/nightly/">nightly build</a> (at the time of writing: 2011-12-03). <br><br>  Create a new empty project in Visual C # Express called ImpressiveSolids.  We save.  Then open the project directory, call the context menu for it and select TortoiseHg ‚Üí Create Repository Here.  We mark the points of creating the .hgignore file and opening the workbench after initialization. <br><br>  Open the .hgignore file in Visual C # Express and write the following lines to it.  This is necessary so that the version control system does not take into account unnecessary binary files. <br><br><pre><code class="cs hljs">syntax: glob *.suo *.pidb ImpressiveSolids/bin<span class="hljs-comment"><span class="hljs-comment">/* ImpressiveSolids/obj/*</span></span></code> </pre> <br><br>  Inside the solution directory (not the project; where the .hgignore is located), create an OpenTK subdirectory and copy the OpenTK * .dll and OpenTK * .dll.config files from the opentk \ Binaries \ OpenTK \ Release \ directory in the OpenTK archive into it. <br><br>  In Visual C # Express, the context menu is References ‚Üí Add Reference ‚Üí Browse.  Choose ../OpenTK/OpenTK.dll.  In addition, you need to add reference to System.Drawing from the .NET tab. <br><br>  Create a new class <code>Game</code> .  This is the main class of the program, it contains the entry point, and it is the heir to <code>OpenTK.GameWindow</code> and is responsible for updating the game state ( <code>OnUpdateFrame</code> ) and redrawing ( <code>OnRenderFrame</code> ).  Now it will be just a black window. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK.Graphics; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OpenTK.Graphics.OpenGL; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ImpressiveSolids</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Game</span></span> : <span class="hljs-title"><span class="hljs-title">GameWindow</span></span> { [STAThread] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Game = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Game()) { Game.Run(<span class="hljs-number"><span class="hljs-number">30</span></span>); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">700</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">, GraphicsMode.Default, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Impressive Solids"</span></span></span></span></span><span class="hljs-function">)</span></span> { VSync = VSyncMode.On; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLoad</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnLoad(E); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnResize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnResize(E); GL.Viewport(ClientRectangle.X, ClientRectangle.Y, ClientRectangle.Width, ClientRectangle.Height); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdateFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnUpdateFrame(E); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRenderFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnRenderFrame(E); GL.ClearColor(Color4.Black); GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit); SwapBuffers(); } } }</code> </pre><br><br>  Go to the project properties (Project ‚Üí ImpressiveSolids Properties) and specify the Target framework: .NET Framework 2.0;  Output type: Windows Application;  Startup object: ImpressiveSolids.Game. <br><br>  You can save and run, a black window with a size of 700 √ó 500 should appear with the title ‚ÄúImpressive Solids‚Äù. <br><br>  If everything went smoothly, go to TortoiseHg Workbench and commit everything with the mark ‚ÄúInitial game window‚Äù. <br><br><h3>  The fall </h3><br>  We realize the managed falling of a stick.  To do this, you first need to set the model of the current state of the stick.  First, the position.  By default - the top center of the glass.  We assume that (0; 0) corresponds to the upper left corner of the glass.  It is necessary, by the way, to set its dimensions <code>MapWidth</code> , <code>MapHeight</code> .  The colors of the blocks that make up the stick will be stored as an array of integers;  set the number of possible colors <code>ColorsCount</code> and agree that the color is indicated by an integer value from <code>0</code> to <code>ColorsCount ‚àí 1</code> . <br><br>  Add a New method to the Game class and call it from OnLoad.  In this method we implement the construction of a stick from blocks of random colors. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Random Rand; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MapWidth = <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MapHeight = <span class="hljs-number"><span class="hljs-number">13</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> StickLength = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] StickColors; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Vector2 StickPosition; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ColorsCount = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnLoad</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnLoad(E); New(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Rand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); StickColors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[StickLength]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; StickLength; i++) { StickColors[i] = Rand.Next(ColorsCount); } StickPosition.X = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Math.Floor((MapWidth - StickLength) / <span class="hljs-number"><span class="hljs-number">2</span></span>d); StickPosition.Y = <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br><br>  Let's try to display our stick on the screen, while in the most primitive version (the block is represented by a colored rectangle, the glass is started right in the upper left corner of the window).  Let's make some changes to the code. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NominalWidth = <span class="hljs-number"><span class="hljs-number">700</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> NominalHeight = <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ProjectionWidth; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> ProjectionHeight; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SolidSize = <span class="hljs-number"><span class="hljs-number">35</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Color4[] Colors = {Color4.PaleVioletRed, Color4.LightSeaGreen, Color4.CornflowerBlue, Color4.RosyBrown, Color4.LightGoldenrodYellow}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NominalWidth, NominalHeight, GraphicsMode.Default, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Impressive Solids"</span></span></span></span></span><span class="hljs-function">)</span></span> { VSync = VSyncMode.On; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnResize</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">EventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnResize(E); GL.Viewport(ClientRectangle.X, ClientRectangle.Y, ClientRectangle.Width, ClientRectangle.Height); ProjectionWidth = NominalWidth; ProjectionHeight = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)ClientRectangle.Height / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)ClientRectangle.Width * ProjectionWidth; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ProjectionHeight &lt; NominalHeight) { ProjectionHeight = NominalHeight; ProjectionWidth = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)ClientRectangle.Width / (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)ClientRectangle.Height * ProjectionHeight; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnRenderFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnRenderFrame(E); GL.ClearColor(Color4.Black); GL.Clear(ClearBufferMask.ColorBufferBit | ClearBufferMask.DepthBufferBit); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Projection = Matrix4.CreateOrthographic(-ProjectionWidth, -ProjectionHeight, <span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); GL.MatrixMode(MatrixMode.Projection); GL.LoadMatrix(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Projection); GL.Translate(ProjectionWidth / <span class="hljs-number"><span class="hljs-number">2</span></span>, -ProjectionHeight / <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Modelview = Matrix4.LookAt(Vector3.Zero, Vector3.UnitZ, Vector3.UnitY); GL.MatrixMode(MatrixMode.Modelview); GL.LoadMatrix(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> Modelview); GL.Begin(BeginMode.Quads); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; StickLength; i++) { RenderSolid(StickPosition.X + i, StickPosition.Y, StickColors[i]); } GL.End(); SwapBuffers(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderSolid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> X, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Color</span></span></span><span class="hljs-function">)</span></span> { GL.Color4(Colors[Color]); GL.Vertex2(X * SolidSize, Y * SolidSize); GL.Vertex2((X + <span class="hljs-number"><span class="hljs-number">1</span></span>) * SolidSize, Y * SolidSize); GL.Vertex2((X + <span class="hljs-number"><span class="hljs-number">1</span></span>) * SolidSize, (Y + <span class="hljs-number"><span class="hljs-number">1</span></span>) * SolidSize); GL.Vertex2(X * SolidSize, (Y + <span class="hljs-number"><span class="hljs-number">1</span></span>) * SolidSize); }</code> </pre><br><br>  Tricks with <code>Nominal/Projection Width/Height</code> needed to image scaled when resizing the window, but at the same time, the proportions are not distorted. <br><br>  Now let's finally make the stick fall and so that the ‚Üê, ‚Üí, ‚Üë keys (color rotation) work. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">NominalWidth, NominalHeight, GraphicsMode.Default, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Impressive Solids"</span></span></span></span></span><span class="hljs-function">)</span></span> { VSync = VSyncMode.On; Keyboard.KeyDown += <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventHandler&lt;KeyboardKeyEventArgs&gt;(OnKeyDown); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdateFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnUpdateFrame(E); StickPosition.Y += <span class="hljs-number"><span class="hljs-number">0.02f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnKeyDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sender, KeyboardKeyEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Key.Left == E.Key) { --StickPosition.X; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Key.Right == E.Key) { ++StickPosition.X; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Key.Up == E.Key) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> T = StickColors[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; StickLength - <span class="hljs-number"><span class="hljs-number">1</span></span>; i++) { StickColors[i] = StickColors[i + <span class="hljs-number"><span class="hljs-number">1</span></span>]; } StickColors[StickLength - <span class="hljs-number"><span class="hljs-number">1</span></span>] = T; } }</code> </pre><br><br>  Let's commit all changes: ‚ÄúThe stick, falling and controllable‚Äù. <br><br>  As you can see, there is no check to go beyond the boundaries of the glass.  We will correct this omission in the future. <br><br><h3>  A Map of the World </h3><br>  Let us deal with the situation when the stick fell on the floor or on the blocks already present in the glass.  For now, we will not deal with the subsequent uncontrolled fall of the blocks and the destruction of the lines, but we will simply make the components of the stick freeze in place (even hanging in the air) and the next stick will begin to fall. <br><br>  We simulate the state of the glass as a two-dimensional array of integers.  The coordinates will correspond to the checkered grid of the glass, the values ‚Äã‚Äãwill be the color of the block in this cell - or a negative number if the cell is empty. <br><br>  Here it will be necessary to enter a check for the stick out of the glass, otherwise there will be calls to the array on non-existent indices. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[,] Map; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Rand = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); Map = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[MapWidth, MapHeight]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> X = <span class="hljs-number"><span class="hljs-number">0</span></span>; X &lt; MapWidth; X++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Y = <span class="hljs-number"><span class="hljs-number">0</span></span>; Y &lt; MapHeight; Y++) { Map[X, Y] = <span class="hljs-number"><span class="hljs-number">-1</span></span>; } } StickColors = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[StickLength]; GenerateNextStick(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateNextStick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; StickLength; i++) { StickColors[i] = Rand.Next(ColorsCount); } StickPosition.X = (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)Math.Floor((MapWidth - StickLength) / <span class="hljs-number"><span class="hljs-number">2</span></span>d); StickPosition.Y = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdateFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>.OnUpdateFrame(E); StickPosition.Y += <span class="hljs-number"><span class="hljs-number">0.02f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FellOnFloor = (StickPosition.Y &gt;= MapHeight - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> FellOnBlock = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!FellOnFloor) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Floor(StickPosition.Y + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; StickLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> X = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)StickPosition.X + i; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Map[X, Y] &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { FellOnBlock = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (FellOnFloor || FellOnBlock) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Y = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)Math.Floor(StickPosition.Y); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; StickLength; i++) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> X = (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)StickPosition.X + i; Map[X, Y] = StickColors[i]; } GenerateNextStick(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnKeyDown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Sender, KeyboardKeyEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Key.Left == E.Key) &amp;&amp; (StickPosition.X &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { --StickPosition.X; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((Key.Right == E.Key) &amp;&amp; (StickPosition.X + StickLength &lt; MapWidth)) { ++StickPosition.X; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Key.Up == E.Key) { <span class="hljs-comment"><span class="hljs-comment">// . . . } } protected override void OnRenderFrame(FrameEventArgs E) { // . . . GL.Begin(BeginMode.Quads); for (var X = 0; X &lt; MapWidth; X++) { for (var Y = 0; Y &lt; MapHeight; Y++) { if (Map[X, Y] &gt;= 0) { RenderSolid(X, Y, Map[X, Y]); } } } for (var i = 0; i &lt; StickLength; i++) { RenderSolid(StickPosition.X + i, StickPosition.Y, StickColors[i]); } GL.End(); SwapBuffers(); }</span></span></code> </pre><br><br>  Now you can quickly sketch blocks to the very top, as in the good old Tetris.  For testing, you can increase the fall rate by replacing <code>0.02f</code> with <code>0.2f</code> , but in general it will be necessary to make it possible to accelerate by pressing the ‚Üì key. <br><br>  Do not forget to commit changes to the Mercurial repository: "Fixing blocks after the stick fell". <br><br><h3>  Double impact </h3><br>  The next thing we need to do is to ensure that the blocks do not hang in the air, but continue to fall down until they abut.  During this period of time there is no stick on the screen, you cannot control anything.  In this regard, we introduce into the game the concept of state. <br><br>  The game at any time is in one of the following states: <br><ol><li>  The next stick falls, it can be managed.  When a new game begins, this state is activated. </li><li>  Uncontrollable falling of blocks, destruction of lined lines.  This state turns on after the stick has touched a block.  It ends when all blocks are stationary and there are no lines to be destroyed.  If the entire top row of the glass is free, then the game continues in state No. 1;  otherwise, the game ends (state number 3). </li><li>  The game is over, nothing happens.  A player can start a new game (for example, by pressing a certain button). </li></ol><br>  We make the appropriate ads in the code. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameStateEnum { Fall, Impact, GameOver } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> GameStateEnum GameState; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . GenerateNextStick(); GameState = GameStateEnum.Fall; } protected override void OnUpdateFrame(FrameEventArgs E) { base.OnUpdateFrame(E); if (GameStateEnum.Fall == GameState) { StickPosition.Y += 0.2f; // . . . if (FellOnFloor || FellOnBlock) { var Y = (int)Math.Floor(StickPosition.Y); for (var i = 0; i &lt; StickLength; i++) { var X = (int)StickPosition.X + i; Map[X, Y] = StickColors[i]; } GameState = GameStateEnum.Impact; } } else if (GameStateEnum.Impact == GameState) { var Stabilized = true; // TODO   if (Stabilized) { GenerateNextStick(); GameState = GameStateEnum.Fall; } } }</span></span></code> </pre><br><br>  In order to depict the smooth fall of the blocks and not complicate the model of the glass ( <code>Map</code> ), we will resort to tricks.  Let the block that falls from the cell (X; Y) into the cell (X; Y + 1) - but where else should it fall?  - is listed in the cage (X; Y) until the moment of the final entry into the lower cage;  and we will additionally store a fractional offset of the block vertically, which will gradually increase until it exceeds one.  That is, the real coordinates of the block will not be (X; Y), but (X; Y + Œî), this will need to be <code>OnRenderFrame</code> into account in <code>OnRenderFrame</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> FallSpeed = <span class="hljs-number"><span class="hljs-number">0.2f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span>[,] ImpactFallOffset; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">New</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . ImpactFallOffset = new float[MapWidth, MapHeight]; } protected override void OnUpdateFrame(FrameEventArgs E) { base.OnUpdateFrame(E); if (GameStateEnum.Fall == GameState) { StickPosition.Y += FallSpeed; // . . . } else if (GameStateEnum.Impact == GameState) { var Stabilized = true; for (var X = 0; X &lt; MapWidth; X++) { for (var Y = MapHeight - 2; Y &gt;= 0; Y--) { if ((Map[X, Y] &gt;= 0) &amp;&amp; ((Map[X, Y + 1] &lt; 0) || (ImpactFallOffset[X, Y + 1] &gt; 0))) { Stabilized = false; ImpactFallOffset[X, Y] += FallSpeed; if (ImpactFallOffset[X, Y] &gt;= 1) { Map[X, Y + 1] = Map[X, Y]; Map[X, Y] = -1; ImpactFallOffset[X, Y] = 0; } } } } if (Stabilized) { GenerateNextStick(); GameState = GameStateEnum.Fall; } } } protected override void OnRenderFrame(FrameEventArgs E) { // . . . GL.Begin(BeginMode.Quads); for (var X = 0; X &lt; MapWidth; X++) { for (var Y = 0; Y &lt; MapHeight; Y++) { if (Map[X, Y] &gt;= 0) { RenderSolid(X, Y + ImpactFallOffset[X, Y], Map[X, Y]); } } } if (GameStateEnum.Fall == GameState) { for (var i = 0; i &lt; StickLength; i++) { RenderSolid(StickPosition.X + i, StickPosition.Y, StickColors[i]); } } GL.End(); SwapBuffers(); }</span></span></code> </pre><br><br>  In order to fall at once, a whole column of blocks under which a hole was formed, we look up the card cells from bottom to top (the lower block carries the upper one) and take into account not only the void of the cell, but also the status <code>ImpactFallOffset</code> (because a positive number means that this block falls down ). <br><br>  Make a note with the note: "Blocks fall from impact until stabilized." <br><br><h3>  Weapon of Mass Destruction </h3><br>  It is time to finally deal with the main element of the gameplay: the destruction of lined lines of the same color.  Set the minimum length of the line.  It is enough to go through all the cells in which there are blocks, and from each try to build a line in one of four possible directions (horizontal, vertical and two diagonals).  If a line of the same color of sufficient length is found, each component of its block is put on the stack.  After the entire map has been verified, we destroy all blocks placed on the stack and mark the position as unstable. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> DestroyableLength = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Stack&lt;Vector2&gt; Destroyables = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Stack&lt;Vector2&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdateFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . } else if (GameStateEnum.Impact == GameState) { // . . . if (Stabilized) { Destroyables.Clear(); for (var X = 0; X &lt; MapWidth; X++) { for (var Y = 0; Y &lt; MapHeight; Y++) { CheckDestroyableLine(X, Y, 1, 0); CheckDestroyableLine(X, Y, 0, 1); CheckDestroyableLine(X, Y, 1, 1); CheckDestroyableLine(X, Y, 1, -1); } } if (Destroyables.Count &gt; 0) { foreach (var Coords in Destroyables) { Map[(int)Coords.X, (int)Coords.Y] = -1; } Stabilized = false; } } if (Stabilized) { GenerateNextStick(); GameState = GameStateEnum.Fall; } } } private void CheckDestroyableLine(int X1, int Y1, int DeltaX, int DeltaY) { if (Map[X1, Y1] &lt; 0) { return; } int X2 = X1, Y2 = Y1; var LineLength = 0; while ((X2 &gt;= 0) &amp;&amp; (Y2 &gt;= 0) &amp;&amp; (X2 &lt; MapWidth) &amp;&amp; (Y2 &lt; MapHeight) &amp;&amp; (Map[X2, Y2] == Map[X1, Y1])) { ++LineLength; X2 += DeltaX; Y2 += DeltaY; } if (LineLength &gt;= DestroyableLength) { for (var i = 0; i &lt; LineLength; i++) { Destroyables.Push(new Vector2(X1 + i * DeltaX, Y1 + i * DeltaY)); } } }</span></span></code> </pre><br><br>  In the repository we mark: ‚ÄúDestroying lines of the same color‚Äù. <br><br><h3>  Game over </h3><br>  You probably noticed the funny behavior of the game when you reach the top of the glass: at the top they start to blink in different colors, replacing each other, endlessly appearing and immediately sticking sticks.  Let's handle the loss situation: nothing will happen until the user presses the Enter key. <br><br>  Everything is simple here. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnUpdateFrame</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">FrameEventArgs E</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// . . . } else if (GameStateEnum.Impact == GameState) { // . . . if (Stabilized) { var GameOver = false; for (var X = 0; X &lt; MapWidth; X++) { if (Map[X, 0] &gt;= 0) { GameOver = true; break; } } if (GameOver) { GameState = GameStateEnum.GameOver; } else { GenerateNextStick(); GameState = GameStateEnum.Fall; } } } } protected void OnKeyDown(object Sender, KeyboardKeyEventArgs E) { if (GameStateEnum.Fall == GameState) { if ((Key.Left == E.Key) &amp;&amp; (StickPosition.X &gt; 0)) { --StickPosition.X; } else if ((Key.Right == E.Key) &amp;&amp; (StickPosition.X + StickLength &lt; MapWidth)) { ++StickPosition.X; } else if (Key.Up == E.Key) { var T = StickColors[0]; for (var i = 0; i &lt; StickLength - 1; i++) { StickColors[i] = StickColors[i + 1]; } StickColors[StickLength - 1] = T; } } else if (GameStateEnum.GameOver == GameState) { if ((Key.Enter == E.Key) || (Key.KeypadEnter == E.Key)) { New(); } } }</span></span></code> </pre><br><br>  Let's commit, without superfluous thinking, by signing: ‚ÄúGame over‚Äù. <br><br>  On it the first part of development is finished.  We have on hand - a fully-featured game that you can already play.  In the <a href="http://habrahabr.ru/blogs/gdev/134283/">second part,</a> we will deal with the design.  We will overlay the textures, we will show the current score, a record score;  the stick that comes up next.  Finally, we will center the image of the glass in the game window, draw its borders.  In general, we will bring everything to mind. <br><br>  The project is available on <del>  <a href="http://code.google.com/p/impressive-solids/">Google Project Hosting</a> </del>  <a href="https://bitbucket.org/denyspopov/impressive-solids">Bitbucket</a> , there you can see the final source code, download the archive with an executable file ready for launch. </div><p>Source: <a href="https://habr.com/ru/post/133983/">https://habr.com/ru/post/133983/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../133978/index.html">FTBB programmer for minimalist Arduino</a></li>
<li><a href="../133979/index.html">How do you pronounce python (in Russian)?</a></li>
<li><a href="../133980/index.html">JSF GUI Development Experience</a></li>
<li><a href="../133981/index.html">Memory model in the examples and not only</a></li>
<li><a href="../133982/index.html">Habrahabr - winner ROTOR 2011</a></li>
<li><a href="../133984/index.html">Setting up a proxy on the firmware Tomato</a></li>
<li><a href="../133987/index.html">Choosing a distributed file system for Linux. A few words about Ceph and the rest</a></li>
<li><a href="../133988/index.html">Gingerbread holds 50.51% of the market for Android smartphones</a></li>
<li><a href="../133989/index.html">System of settings and change of versions of programs: evolution of viable forms</a></li>
<li><a href="../133990/index.html">OpenOffice COM Automation: Reading Clipboard Content</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>