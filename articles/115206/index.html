<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>(How to write (Lisp) interpreter (in Python))</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of the article "(How to Write a (Lisp) Interpreter (in Python))" by Peter Norvig. In this article, Peter quite briefly, but succinctly, de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>(How to write (Lisp) interpreter (in Python))</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage/ef4fe9a4/abe7e9a9/0a2de085/216913a5.png"><br><br>  <i>Translation of the article "(How to Write a (Lisp) Interpreter (in Python))" by Peter Norvig.</i>  <i>In this article, Peter quite briefly, but succinctly, describes the principle of the interpreters and shows how you can write a very tiny (only 90 lines in Python) interpreter of a subset of the Scheme language.</i>  <i>The translation is published with the permission of the author.</i> <i><br><br><img align="left" src="https://habrastorage.org/storage/abdae41d/8d27e509/91ae93fd/0fc86d53.png"></i>  <i>Peter Norvig (English Peter Norvig) - American scientist in the field of computing.</i>  <i>Currently working as research director (previously - director for search quality) at Google.</i>  <i>Previously, he was the head of the Computer Engineering Division at the Ames NASA Research Center, where he led a staff of two hundred NASA scientists in the fields of anatomy and robotics, automated software development and data analysis, neuroengineering, collective systems development, and decision-making based on simulation.</i> <i><br></i> <br><a name="habracut"></a><br>  This article has two goals: to describe in general the implementation of programming language interpreters, as well as to demonstrate the implementation of a subset of the <a href="http://ru.wikipedia.org/wiki/Scheme"><i>Scheme language</i></a> , a Lisp dialect, using <a href="http://python.org/">Python</a> .  I called my interpreter <i>Lispy</i> ( <a href="http://norvig.com/lis.py">lis.py</a> ).  A year ago, I showed how to write <a href="http://norvig.com/jscheme.html">the Scheme interpreter in Java</a> , as well as <a href="http://books.google.com/books%3Fid%3DQzGuHnDhvZIC%26lpg%3DPA756%26vq%3Dscheme%2520interpreter%26dq%3DParadigms%2520of%2520Artificial%2520Intelligence%2520Programming%26pg%3DPA753">in Common Lisp</a> .  This time, the goal is to demonstrate, briefly and as accessible as possible, what <a href="http://queue.acm.org/detail.cfm%3Fid%3D1039523">Alan Kay called</a> <i>"</i> Maxwell's Equations of Software". 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  <i>Lispy</i> syntax and semantics </h4><br>  Most programming languages ‚Äã‚Äãhave different syntax conventions (keywords, infix operators, brackets, operator precedence, dot notation, semicolons, etc.), but like a member of the Lisp family of languages, Scheme‚Äôs entire syntax is based on lists in parentheses. prefix notation.  This form may seem unfamiliar, but it has advantages in simplicity and consistency.  Some people joke that ‚ÄúLisp‚Äù means <i>‚ÄúLots of Irritating Silly Parentheses‚Äù</i> , I think it means <i>‚ÄúLisp is syntactically clean‚Äù</i> (Lisp Is Syntactically Pure).  See: <br><table cellpadding="3"><tbody><tr><th>  Java </th><th></th><th>  Scheme </th></tr><tr><td> <code>if ( <i>x.val() &gt; 0</i> ) {&lt;br&gt; <i>z = f(a * x.val() + b);</i> &lt;br&gt;}</code> <br> </td><td></td><td> <code>(if (&gt; (val x) 0)&lt;br&gt;    (set! z (f (+ (* a (val x)) b))))</code> <br> </td></tr></tbody></table><br>  Note that the exclamation mark is not a special character in Scheme, it is just part of the name " <code>set!</code> ".  Only brackets are special characters.  A list, such as <code>(set! xy)</code> , with a special keyword at the beginning is called a <i>special form</i> in Scheme;  The beauty of the language is that we need only 6 special forms, plus 3 syntactic constructions - variables, constants and procedure calls: <br><table cellpadding="3" border="1"><tbody><tr><th>  The form </th><th>  Syntax </th><th>  Semantics and Example </th></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html">variable reference</a> <br></td><td>  <i>var</i> <br></td><td>  A symbol is interpreted as a variable name, its value is a variable value. <br>  Example: <code>x</code> <br></td></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html">constant literal</a> <br></td><td>  <i>number</i> <br></td><td>  The number means itself. <br>  Examples: <code>12</code> <i>or</i> <code>-3.45e+6</code> <br></td></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html">quote</a> <br></td><td>  <code>(quote</code> <i>exp</i> <code>)</code> <br></td><td>  Returns <i>exp</i> literally without evaluating it. <br>  Example: <code><code>(quote (abc)) ‚áí (abc)</code></code> <br></td></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html">conditional</a> <br></td><td>  <code>(if</code> <i>test conseq alt</i> <code>)</code> <br></td><td>  Calculate <i>test</i> ;  if true, calculate and return <i>conseq</i> ;  otherwise calculate and return <i>alt</i> . <br>  Example: <code>(if (&lt; 10 20) (+ 1 1) (+ 3 3)) ‚áí 2</code> <br></td></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html">assignment</a> <br></td><td>  <code>(set!</code> <i>var exp</i> <code>)</code> </td><td>  Calculate <i>exp</i> and assign the value to the variable <i>var</i> , which should be previously defined (using <code>define</code> or as a procedure parameter). <br>  Example: <code>(set! x2 (* xx))</code> <br></td></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-8.html">definition</a> <br></td><td>  <code>(define</code> <i>var</i> <i>exp</i> <code>)</code> <br></td><td>  Define a new variable in the nested environment itself and give it the value of the expression <i>exp</i> . <br>  Examples: <code>(define r 3)</code> <i>or</i> <code>(define square (lambda (x) (* xx)))</code> . <br></td></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html">function</a> <br></td><td>  <code>(lambda (</code> <i>var ...</i> <code>)</code> <i>exp</i> <code>)</code> <br></td><td>  Create a function with a parameter (s) with the names <i>var ...</i> and an expression in the body. <br>  Example: <code>(lambda ( r ) (* 3.141592653 (* rr)))</code> <br></td></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html">sequencing</a> </td><td>  <code>(begin</code> <i>exp ...</i> <code>)</code> <br></td><td>  Calculate each expression from left to right and return the last value. <br>  Example: <code>(begin (set! x 1) (set! x (+ x 1)) (* x 2)) ‚áí 4</code> <br></td></tr><tr><td align="center">  <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html">procedure call</a> <br></td><td>  <code>(</code> <i>proc exp ...</i> <code>)</code> <br></td><td>  If <i>proc is</i> not <code>if, set!, define, lambda, begin,</code> or <code>quote</code> then it is considered as a procedure.  It is calculated according to the same rules as defined here.  All expressions are evaluated, and then the function is called with a list of expressions in the argument. <br>  Example: <code>(square 12) ‚áí 144</code> <br></td></tr></tbody></table><br>  In this table, <i>var</i> must be an identifier symbol, such as <code>x</code> or <code>square</code> ;  <i>number</i> - must be an integer or floating point number, while the remaining italicized words can be any expression.  The notation <i>exp ...</i> means zero or more reps of <i>exp</i> . <br><br>  To learn more about the Scheme, refer to the following great books ( <a href="http://books.google.com/books%3Fid%3DxyO-KLexVnMC%26lpg%3DPP1%26dq%3Dscheme%2520programming%2520book%26pg%3DPP1">Friedman and Fellesein</a> , <a href="http://books.google.com/books%3Fid%3DxyO-KLexVnMC%26lpg%3DPP1%26dq%3Dscheme%2520programming%2520book%26pg%3DPP1">Dybvig</a> , <a href="http://books.google.com/books%3Fid%3DwftS4tj4XFMC%26lpg%3DPA300%26dq%3Dscheme%2520programming%2520book%26pg%3DPP1">Queinnec</a> , <a href="http://www.eecs.berkeley.edu/~bh/ss-toc2.html">Harvey and Wright</a> or <a href="http://mitpress.mit.edu/sicp/">Sussman and Abelson</a> ), video ( <a href="http://groups.csail.mit.edu/mac/classes/6.001/abelson-sussman-lectures/">Abelson and Sussman</a> ), introductions ( <a href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html">Dorai</a> , <a href="http://docs.racket-lang.org/quick/index.html">PLT</a> , or <a href="http://cs.gettysburg.edu/~tneller/cs341/scheme-intro/index.html">Neller</a> ), or a <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/">reference guide</a> . <br><br><h4>  What the language interpreter does </h4><br>  The interpreter consists of two parts: <br><ol><li>  <b>Parsing:</b> the parsing component receives a program as a sequence of characters as input, checks it in accordance with the <i>syntax rules of the</i> language and translates the program into an internal representation.  In a simple interpreter, the internal representation looks like a tree structure that accurately reflects the structure of nested operators and expressions in the program.  In a language translator called a <i>compiler</i> , the internal representation is a sequence of instructions that can be directly executed by a computer.  As <a href="http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html">Steve Yegge said</a> , <i>‚ÄúIf you don‚Äôt know how compilers work, then you don‚Äôt know how computers work</i> . <i>‚Äù</i>  Egge described 8 scenarios that can be solved using compilers (or, equivalently, interpreters).  The Lispy parser is implemented using the <code>parse</code> function. <br></li><li>  <b>Execution: the</b> internal representation is processed in accordance with the <i>semantic rules of the</i> language, thereby the calculations are performed.  Execution is performed by the <code>eval</code> function (note, it hides the built-in Python function). <br></li></ol><br>  Here is a picture of the process of interpretation and interactive session, showing how <code>parse</code> and <code>eval</code> handle a short program: <br><br><img src="https://habrastorage.org/storage/habraeffect/13/27/13274b0bdfaafda50086381cb1f798a4.png"><br><br><blockquote>  <font color="#66cc66">&gt;&gt;</font> program <font color="#66cc66">=</font> <font color="#ff0000">"(begin (define r 3) (* 3.141592653 (* r r)))"</font> <br><br>  <font color="#66cc66">&gt;&gt;&gt;</font> parse <font color="#66cc66">(</font> program <font color="#66cc66">)</font> <br>  <font color="#66cc66">[</font> ' <font color="#b1b100">begin</font> ', <font color="#66cc66">[</font> ' <font color="#b1b100">define</font> ', 'r', <font color="#cc66cc">3</font> <font color="#66cc66">]</font> , <font color="#66cc66">[</font> ' <font color="#66cc66">*</font> ', <font color="#cc66cc">3.141592653</font> , <font color="#66cc66">[</font> ' <font color="#66cc66">*</font> ', 'r', 'r' <font color="#66cc66">]</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> <br><br>  <font color="#66cc66">&gt;&gt;&gt;</font> eval <font color="#66cc66">(</font> parse <font color="#66cc66">(</font> program <font color="#66cc66">)</font> <font color="#66cc66">)</font> <br>  <font color="#cc66cc">28.274333877</font> </blockquote><br><br>  We use the simplest internal representation, where the lists, numbers, and symbols of Scheme are represented by lists, numbers, and Python strings, respectively. <br><br><h4>  Execution: <code>eval</code> </h4><br>  Each of the nine cases in the table above has one, two, or three lines of code.  To define <code>eval</code> nothing else is needed: <br><br><blockquote>  <font color="#ff7700">def</font> <font color="#008000">eval</font> <font>(</font> x, env = global_env <font>)</font> : <br>  <font color="#483d8b">"Evaluate an expression in an environment."</font> <br>  <font color="#ff7700">if</font> isa <font>(</font> x, Symbol <font>)</font> : <font color="#808080"># variable reference</font> <br>  <font color="#ff7700">return</font> env.  <font>find</font> <font>(</font> x <font>)</font> <font>[</font> x <font>]</font> <br>  <font color="#ff7700">elif</font> <font color="#ff7700">not</font> isa <font>(</font> x, <font color="#008000">list</font> <font>)</font> : <font color="#808080"># constant literal</font> <br>  <font color="#ff7700">return</font> x <br>  <font color="#ff7700">elif</font> x <font>[</font> <font color="#ff4500">0</font> <font>]</font> == <font color="#483d8b">'quote'</font> : <font color="#808080"># (quote exp)</font> <br>  <font>(</font> _, exp <font>)</font> = x <br>  <font color="#ff7700">return</font> exp <br>  <font color="#ff7700">elif</font> x <font>[</font> <font color="#ff4500">0</font> <font>]</font> == <font color="#483d8b">'if'</font> : <font color="#808080"># (if test conseq alt)</font> <br>  <font>(</font> _, <font color="#dc143c">test</font> , conseq, alt <font>)</font> = x <br>  <font color="#ff7700">return</font> <font color="#008000">eval</font> <font>(</font> <font>(</font> conseq <font color="#ff7700">if</font> <font color="#008000">eval</font> <font>(</font> <font color="#dc143c">test</font> , env <font>)</font> <font color="#ff7700">else</font> alt <font>)</font> , env <font>)</font> <br>  <font color="#ff7700">elif</font> x <font>[</font> <font color="#ff4500">0</font> <font>]</font> == <font color="#483d8b">'set!'</font>  : <font color="#808080"># (set! var exp)</font> <br>  <font>(</font> _, var, exp <font>)</font> = x <br>  env.  <font>find</font> <font>(</font> var <font>)</font> <font>[</font> var <font>]</font> = <font color="#008000">eval</font> <font>(</font> exp, env <font>)</font> <br>  <font color="#ff7700">elif</font> x <font>[</font> <font color="#ff4500">0</font> <font>]</font> == <font color="#483d8b">'define'</font> : <font color="#808080"># (define var exp)</font> <br>  <font>(</font> _, var, exp <font>)</font> = x <br>  env <font>[</font> var <font>]</font> = <font color="#008000">eval</font> <font>(</font> exp, env <font>)</font> <br>  <font color="#ff7700">elif</font> x <font>[</font> <font color="#ff4500">0</font> <font>]</font> == <font color="#483d8b">'lambda'</font> : <font color="#808080"># (lambda (var *) exp)</font> <br>  <font>(</font> _, <font color="#008000">vars</font> , exp <font>)</font> = x <br>  <font color="#ff7700">return</font> <font color="#ff7700">lambda</font> <font color="#66cc66">*</font> args: <font color="#008000">eval</font> <font>(</font> exp, env <font>(</font> <font color="#008000">vars</font> , args, env <font>)</font> <font>)</font> <br>  <font color="#ff7700">elif</font> x <font>[</font> <font color="#ff4500">0</font> <font>]</font> == <font color="#483d8b">'begin'</font> : <font color="#808080"># (begin exp *)</font> <br>  <font color="#ff7700">for</font> exp <font color="#ff7700">in</font> x <font>[</font> <font color="#ff4500">1</font> : <font>]</font> : <br>  val = <font color="#008000">eval</font> <font>(</font> exp, env <font>)</font> <br>  <font color="#ff7700">return</font> val <br>  <font color="#ff7700">else</font> : <font color="#808080"># (proc exp *)</font> <br>  exps = <font>[</font> <font color="#008000">eval</font> <font>(</font> exp, env <font>)</font> <font color="#ff7700">for</font> exp <font color="#ff7700">in</font> x <font>]</font> <br>  proc = exps.  <font>pop</font> <font>(</font> <font color="#ff4500">0</font> <font>)</font> <br>  <font color="#ff7700">return</font> proc <font>(</font> <font color="#66cc66">*</font> exps <font>)</font> <br><br>  isa = <font color="#008000">isinstance</font> <br><br>  Symbol = <font color="#008000">str</font> </blockquote><br><br>  <i>That's all that eval needs! ..</i> well, except for the media.  The environment is simply the mapping of characters to the values ‚Äã‚Äãbelonging to them.  New symbol / value associations are added using <code>define</code> or ( <code>lambda</code> expression). <br><br>  Let's take a look at an example of what happens when we declare and call a function in Scheme (the hint <code>lis.py&gt;</code> means that we interact with the Lisp interpreter, not Python): <br><br><blockquote>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> <font color="#b1b100">define</font> area <font color="#66cc66">(</font> <font color="#b1b100">lambda</font> <font color="#66cc66">(</font> r <font color="#66cc66">)</font> <font color="#66cc66">(</font> <font color="#66cc66">*</font> <font color="#cc66cc">3.141592653</font> <font color="#66cc66">(</font> <font color="#66cc66">*</font> r r <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> area <font color="#cc66cc">3</font> <font color="#66cc66">)</font> <br>  <font color="#cc66cc">28.274333877</font> </blockquote><br><br>  When we execute <code>(lambda ( r ) (* 3.141592653 (* rr)))</code> , we fall into the <code>elif x[0] == 'lambda'</code> branch in <code>eval</code> , assign the three elements of the list <code>x</code> ( and signal an error if the length <code>x</code> not 3).  We create a new function that, when called, will compute the expression <code>['*', 3.141592653 ['*', 'r', 'r']]</code> in the environment formed by a bunch of formal parameters of the function (in this case, only one parameter <code>r</code> ) with arguments in the function call, as well as using the current environment for any variables that are not parameters (in the example, the variable <code>*</code> ).  The value of this newly-minted function is then assigned as the value of the <code>area</code> in <code>global_env</code> . <br><br>  Now, what happens when we calculate <code>(area 3)</code> ?  Because  area is not a special form of characters, so this is a function call (the last <code>else:</code> in <code>eval</code> ), and the entire list of expressions is executed at once.  The <code>area</code> calculation returns the function we just created;  calculating <code>3</code> returns <code>3</code> .  Then (according to the last line of <code>eval</code> ) the newly created function with the list of arguments <code>[3]</code> called.  This means <code>exp</code> , which is <code>['*', 3.141592653 ['*', 'r', 'r']]</code> in an environment where <code>r</code> is <code>3</code> and the external environment is global and therefore <code>*</code> is a multiplication function. <br><br>  Now we are ready to explain the details of the <code>Env</code> class: <br><br><blockquote>  <font color="#ff7700">class</font> Env <font>(</font> <font color="#008000">dict</font> <font>)</font> : <br>  <font color="#483d8b">"An environment: a dict of {'var': val} pairs, with an outer Env."</font> <br>  <font color="#ff7700">def</font> <font color="#0000cd">__init__</font> <font>(</font> <font color="#008000">self</font> , parms = <font>(</font> <font>)</font> , args = <font>(</font> <font>)</font> , outer = <font color="#008000">None</font> <font>)</font> : <br>  <font color="#008000">self</font> .  <font>update</font> <font>(</font> <font color="#008000">zip</font> <font>(</font> parms, args <font>)</font> <font>)</font> <br>  <font color="#008000">self</font> .  <font>outer</font> = outer <br>  <font color="#ff7700">def</font> find <font>(</font> <font color="#008000">self</font> , var <font>)</font> : <br>  <font color="#483d8b">"Find the innermost Env where the var appears."</font> <br>  <font color="#ff7700">return</font> <font color="#008000">self</font> <font color="#ff7700">if</font> var <font color="#ff7700">in</font> <font color="#008000">self</font> <font color="#ff7700">else</font> <font color="#008000">self self</font> .  <font>outer</font> .  <font>find</font> <font>(</font> var <font>)</font> </blockquote><br><br>  Please note that the <code>Env</code> class is a subclass of <code>dict</code> , which means that it is using regular dictionary operations.  In addition, there are two methods, the constructor <code>__init__</code> and <code>find</code> for finding the right environment for a variable.  The key to understanding this class (as well as the reason that we do not use just <code>dict</code> ) is the concept of the <i>external</i> environment.  Consider the following program: <br><br><img src="https://habrastorage.org/storage/cc7cc0ea/f1c276ac/28cc4d00/7a642a3d.png"><br><br>  Each rectangle represents a medium, and its color corresponds to the color of the variables that were defined in that medium.  In the last two lines, we define <code>a1</code> and call <code>(a1 -20.00)</code> ;  These two lines represent the creation of a bank account with a balance of $ 100 and the subsequent withdrawal of $ 20.  In the process of execution <code>(a1 -20.00)</code> we calculate the expression highlighted in yellow.  3 variables are involved in this expression.  The <code>amt</code> variable can be found immediately in the most nested (green) environment.  But <code>balance</code> not defined here, we will search in the external environment relatively green, ie  in blue.  Finally, the variable <code>+</code> not found in any of these environments; we need to take another step into the global (red) environment.  This search process, from the internal environment to the external, is called lexical scoping.  <code>Procedure.find</code> finds the right environment according to the lexical scope. <br><br>  All that remains is to define the global environment.  It is necessary to have <code>+</code> and all other functions built into Scheme.  We will not worry about the implementation of all of them, we will get a bunch of necessary by importing the <code>math</code> module in Python and then explicitly adding 20 popular ones: <br><br><blockquote>  <font color="#ff7700">def</font> add_globals <font>(</font> env <font>)</font> : <br>  <font color="#483d8b">"Add some Scheme standard procedures to an environment."</font> <br>  <font color="#ff7700">import</font> <font color="#dc143c">math</font> , <font color="#dc143c">operator</font> <font color="#ff7700">as</font> op <br>  env.  <font>update</font> <font>(</font> <font color="#008000">vars</font> <font>(</font> <font color="#dc143c">math</font> <font>)</font> <font>)</font> <font color="#808080"># sin, sqrt, ...</font> <br>  env.  <font>update</font> <font>(</font> <br>  <font>{</font> <font color="#483d8b">'+'</font> : op.  <font>add</font> , <font color="#483d8b">'-'</font> : op.  <font>sub</font> , <font color="#483d8b">'*'</font> : op.  <font>mul</font> , <font color="#483d8b">'/'</font> : op.  <font>div</font> , <font color="#483d8b">'not'</font> : op.  <font>not_</font> , <br>  <font color="#483d8b">'&gt;'</font> : op.  <font>gt</font> , <font color="#483d8b">'&lt;'</font> : op.  <font>lt</font> , <font color="#483d8b">'&gt; ='</font> : op.  <font>ge</font> , <font color="#483d8b">'&lt;='</font> : op.  <font>le</font> , <font color="#483d8b">'='</font> : op.  <font>eq</font> , <br>  <font color="#483d8b">'equal?'</font>  : op.  <font>eq</font> , <font color="#483d8b">'eq?'</font>  : op.  <font>is_</font> , <font color="#483d8b">'length'</font> : <font color="#008000">len</font> , <font color="#483d8b">'cons'</font> : <font color="#ff7700">lambda</font> x, y: <font>[</font> x <font>]</font> + y, <br>  <font color="#483d8b">'car'</font> : <font color="#ff7700">lambda</font> x: x <font>[</font> <font color="#ff4500">0</font> <font>]</font> , <font color="#483d8b">'cdr'</font> : <font color="#ff7700">lambda</font> x: x <font>[</font> <font color="#ff4500">1</font> : <font>]</font> , <font color="#483d8b">'append'</font> : op.  <font>add</font> , <br>  <font color="#483d8b">'list'</font> : <font color="#ff7700">lambda</font> <font color="#66cc66">*</font> x: <font color="#008000">list</font> <font>(</font> x <font>)</font> , <font color="#483d8b">'list?'</font>  : <font color="#ff7700">lambda</font> x: isa <font>(</font> x, <font color="#008000">list</font> <font>)</font> , <br>  <font color="#483d8b">'null?'</font>  : <font color="#ff7700">lambda</font> x: x == <font>[</font> <font>]</font> , <font color="#483d8b">'symbol?'</font>  : <font color="#ff7700">lambda</font> x: isa <font>(</font> x, Symbol <font>)</font> <font>}</font> <font>)</font> <br>  <font color="#ff7700">return</font> env <br><br>  global_env = add_globals <font>(</font> Env <font>(</font> <font>)</font> <font>)</font> </blockquote><br><br><h4>  Parsing: <code>read</code> and <code>parse</code> </h4><br>  Now about the <code>parse</code> function.  Parsing is traditionally divided into two parts: <i>lexical analysis</i> , during which the input string of characters is divided into a sequence of <i>tokens</i> , and <i>syntactic analysis</i> , during which the tokens are assembled into an internal representation.  Lispy tokens are brackets, characters (such as <code>set!</code> Or <code>x</code> ), and numbers.  Here's how it works: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> program <font color="#66cc66">=</font> <font color="#ff0000">"(set! x * 2 (* x 2))"</font> <br><br>  <font color="#66cc66">&gt;&gt;&gt;</font> tokenize <font color="#66cc66">(</font> program <font color="#66cc66">)</font> <br>  <font color="#66cc66">[</font> ' <font color="#66cc66">(</font> ', ' <font color="#b1b100">set!</font> ', 'x <font color="#66cc66">*</font> <font color="#cc66cc">2</font> ', ' <font color="#66cc66">(</font> ', ' <font color="#66cc66">*</font> ', 'x', ' <font color="#cc66cc">2</font> ', ' <font color="#66cc66">)</font> ', ' <font color="#66cc66">)</font> ' <font color="#66cc66">]</font> <br><br>  <font color="#66cc66">&gt;&gt;&gt;</font> parse <font color="#66cc66">(</font> program <font color="#66cc66">)</font> <br>  <font color="#66cc66">[</font> ' <font color="#b1b100">set!</font>  ',' x <font color="#66cc66">*</font> <font color="#cc66cc">2</font> ', <font color="#66cc66">[</font> ' <font color="#66cc66">*</font> ',' x ', <font color="#cc66cc">2</font> <font color="#66cc66">]</font> <font color="#66cc66">]</font> </blockquote><br><br>  There are a lot of tools for lexical analysis (for example, <a href="http://dinosaur.compilertools.net/">lex</a> Mike Lesk and Eric Schmidt), but we will go the simple way: we use the Python <code>str.split</code> .  We simply add spaces around each bracket, and then get a list of tokens by calling <code>str.split</code> . <br><br>  Now about the syntax analysis.  We saw that the Lisp syntax is very simple, but some Lisp interpreters have made the parsing work even easier, taking as a program <i>any</i> character string that is a list.  In other words, the string <code>(set! 1 2)</code> will be accepted by the syntactically correct program, and only at run time the interpreter will swear that <code>set!</code>  expects the first argument to be a character, not a number.  In Java or Python, the equivalent assignment of <code>1 = 2</code> will be recognized as an error at compile time.  On the other hand, Java and Python do not require detection at compile time of an error in the <code>x/0</code> expression, therefore, as you can see, it is not always strictly defined when errors should be recognized.  Lispy implements <code>parse</code> using <code>read</code> , a function that reads any expression (number, character, or nested list). <br><br>  The <code>read</code> function works by passing <code>read_from</code> tokens obtained after lexical analysis.  Having a list of tokens, we look at the first token;  if this is a syntax error.  If this is <code>'('</code> , then we start building a list of expressions until we get to the corresponding <code>')'</code> .  Everything else must be characters or numbers, which are full expressions in their own right.  The final trick is knowing that <code>'2'</code> represents an integer, <code>'2.0'</code> is a floating point number, and <code>x</code> represents a character.  We allow Python to make these distinctions: for each ‚Äúnon-bracket‚Äù token, we first try to interpret it as an integer, and then as a floating point number, and finally as a symbol.  Following these instructions will get: <br><br><blockquote>  <font color="#ff7700">def</font> read <font>(</font> s <font>)</font> : <br>  <font color="#483d8b">"Read a Scheme expression from a string."</font> <br>  <font color="#ff7700">return</font> <font color="#dc143c">read_from</font> <font>(</font> <font color="#dc143c">tokenize</font> <font>(</font> s <font>)</font> <font>)</font> <br><br>  parse = read <br><br>  <font color="#ff7700">def</font> <font color="#dc143c">tokenize</font> <font>(</font> s <font>)</font> : <br>  <font color="#483d8b">"Convert a string into a list of tokens."</font> <br>  <font color="#ff7700">return</font> s.  <font>replace</font> <font>(</font> <font color="#483d8b">'('</font> , <font color="#483d8b">'('</font> <font>)</font> . <font>replace</font> <font>(</font> <font color="#483d8b">')'</font> , <font color="#483d8b">')'</font> <font>)</font> .  <font>split</font> <font>(</font> <font>)</font> <br><br>  <font color="#ff7700">def</font> read_from <font>(</font> tokens <font>)</font> : <br>  <font color="#483d8b">"Read an expression of a sequence of tokens."</font> <br>  <font color="#ff7700">if</font> <font color="#008000">len</font> <font>(</font> tokens <font>)</font> == <font color="#ff4500">0</font> : <br>  <font color="#ff7700">raise</font> <font color="#008000">SyntaxError</font> <font>(</font> <font color="#483d8b">'unexpected EOF while reading'</font> <font>)</font> <br>  <font color="#dc143c">token</font> = tokens.  <font>pop</font> <font>(</font> <font color="#ff4500">0</font> <font>)</font> <br>  <font color="#ff7700">if</font> <font color="#483d8b">'('</font> == <font color="#dc143c">token</font> : <br>  L = <font>[</font> <font>]</font> <br>  <font color="#ff7700">while</font> tokens <font>[</font> <font color="#ff4500">0</font> <font>]</font> <font color="#66cc66">!</font>  = <font color="#483d8b">')'</font> : <br>  L. <font>append</font> <font>(</font> read_from <font>(</font> tokens <font>)</font> <font>)</font> <br>  tokens  <font>pop</font> <font>(</font> <font color="#ff4500">0</font> <font>)</font> <font color="#808080"># pop off ')'</font> <br>  <font color="#ff7700">return</font> L <br>  <font color="#ff7700">elif</font> <font color="#483d8b">')'</font> == <font color="#dc143c">token</font> : <br>  <font color="#ff7700">raise</font> <font color="#008000">SyntaxError</font> <font>(</font> <font color="#483d8b">'unexpected)'</font> <font>)</font> <br>  <font color="#ff7700">else</font> : <br>  <font color="#ff7700">return</font> atom <font>(</font> <font color="#dc143c">token</font> <font>)</font> <br><br>  <font color="#ff7700">def</font> atom <font>(</font> <font color="#dc143c">token</font> <font>)</font> : <br>  <font color="#483d8b">"Numbers become numbers; every other token is a symbol."</font> <br>  <font color="#ff7700">try</font> : <font color="#ff7700">return</font> <font color="#008000">int</font> <font>(</font> <font color="#dc143c">token</font> <font>)</font> <br>  <font color="#ff7700">except</font> <font color="#008000">ValueError</font> : <br>  <font color="#ff7700">try</font> : <font color="#ff7700">return</font> <font color="#008000">float</font> <font>(</font> <font color="#dc143c">token</font> <font>)</font> <br>  <font color="#ff7700">except</font> <font color="#008000">ValueError</font> : <br>  <font color="#ff7700">return</font> Symbol <font>(</font> <font color="#dc143c">token</font> <font>)</font> </blockquote><br><br>  Finally, we add the <code>to_string</code> function in order to convert the expression back to a readable Lisp string, as well as the <code>repl</code> function, which is needed for the read-eval-print loop in the form of an interactive interpreter: <br><br><blockquote>  <font color="#ff7700">def</font> to_string <font>(</font> exp <font>)</font> : <br>  <font color="#483d8b">"Convert a Python object back into a Lisp-readable string."</font> <br>  <font color="#ff7700">return</font> <font color="#483d8b">'('</font> + <font color="#483d8b">''</font> . <font>join</font> <font>(</font> <font color="#008000">map</font> <font>(</font> to_string, exp <font>)</font> <font>)</font> + <font color="#483d8b">')'</font> <font color="#ff7700">if</font> isa <font>(</font> exp, <font color="#008000">list</font> <font>)</font> <font color="#ff7700">else</font> <font color="#008000">str</font> <font>(</font> exp <font>)</font> <br><br>  <font color="#ff7700">def</font> repl <font>(</font> prompt = <font color="#483d8b">'lis.py&gt;'</font> <font>)</font> : <br>  <font color="#483d8b">"A prompt-read-eval-print loop."</font> <br>  <font color="#ff7700">while</font> <font color="#008000">true</font> : <br>  val = <font color="#008000">eval</font> <font>(</font> parse <font>(</font> <font color="#008000">raw_input</font> <font>(</font> prompt <font>)</font> <font>)</font> <font>)</font> <br>  <font color="#ff7700">if</font> val <font color="#ff7700">is</font> <font color="#ff7700">not</font> <font color="#008000">None</font> : <font color="#ff7700">print</font> to_string <font>(</font> val <font>)</font> </blockquote><br><br>  Here is our code at work: <br><br><blockquote>  <font color="#66cc66">&gt;&gt;&gt;</font> repl <font color="#66cc66">(</font> <font color="#66cc66">)</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> <font color="#b1b100">define</font> area <font color="#66cc66">(</font> <font color="#b1b100">lambda</font> <font color="#66cc66">(</font> r <font color="#66cc66">)</font> <font color="#66cc66">(</font> <font color="#66cc66">*</font> <font color="#cc66cc">3.141592653</font> <font color="#66cc66">(</font> <font color="#66cc66">*</font> r r <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> area <font color="#cc66cc">3</font> <font color="#66cc66">)</font> <br>  <font color="#cc66cc">28.274333877</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> <font color="#b1b100">define</font> fact <font color="#66cc66">(</font> <font color="#b1b100">lambda</font> <font color="#66cc66">(</font> n <font color="#66cc66">)</font> <font color="#66cc66">(</font> <font color="#b1b100">if</font> <font color="#66cc66">(</font> <font color="#66cc66">&lt;=</font> n <font color="#cc66cc">1</font> <font color="#66cc66">)</font> <font color="#cc66cc">1</font> <font color="#66cc66">(</font> <font color="#66cc66">*</font> n <font color="#66cc66">(</font> fact <font color="#66cc66">(</font> <font color="#66cc66">-</font> n <font color="#cc66cc">1</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> fact <font color="#cc66cc">10</font> <font color="#66cc66">)</font> <br>  <font color="#cc66cc">3628800</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> fact <font color="#cc66cc">100</font> <font color="#66cc66">)</font> <br>  <font color="#cc66cc">93326215443944152681699238856266700490715968264381621468592963895217599322991</font> <br>  <font color="#cc66cc">56089414639761565182862536979208272237582511852109168640000000000000000000000</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> area <font color="#66cc66">(</font> fact <font color="#cc66cc">10</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <br>  4.1369087198e <font color="#66cc66">+</font> 13 <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> <font color="#b1b100">define</font> first <font color="#b1b100">car</font> <font color="#66cc66">)</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> <font color="#b1b100">define</font> rest <font color="#b1b100">cdr</font> <font color="#66cc66">)</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> <font color="#b1b100">define</font> count <font color="#66cc66">(</font> <font color="#b1b100">lambda</font> <font color="#66cc66">(</font> item <font color="#b1b100">L</font> <font color="#66cc66">)</font> <font color="#66cc66">(</font> <font color="#b1b100">if</font> <font color="#b1b100">L</font> <font color="#66cc66">(</font> <font color="#66cc66">+</font> <font color="#66cc66">(</font> <font color="#b1b100">equal?</font> item <font color="#66cc66">(</font> first <font color="#b1b100">L</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">(</font> count item <font color="#66cc66">(</font> rest <font color="#b1b100">L</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#cc66cc">0</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> count <font color="#cc66cc">0</font> <font color="#66cc66">(</font> <font color="#b1b100">list</font> <font color="#cc66cc">0</font> <font color="#cc66cc">1</font> <font color="#cc66cc">2</font> <font color="#cc66cc">3</font> <font color="#cc66cc">0</font> <font color="#cc66cc">0</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <br>  <font color="#cc66cc">3</font> <br>  lis.py <font color="#66cc66">&gt;</font> <font color="#66cc66">(</font> count <font color="#66cc66">(</font> <font color="#b1b100">quote</font> the <font color="#66cc66">)</font> <font color="#66cc66">(</font> <font color="#b1b100">quote</font> <font color="#66cc66">(</font> the more the bigger the better the better <font color="#66cc66">)</font> <font color="#66cc66">)</font> <font color="#66cc66">)</font> <br>  <font color="#cc66cc">four</font> </blockquote><br><br><h4>  How small / fast / complete / good is Lispy? </h4><br>  We will judge Lispy by the following criteria: <br><ul><li>  <b><i>Size:</i></b> Lispy is tiny, 90 lines with no comments, less than 4K of source code.  There are fewer lines compared to the first version, which had 96 lines - I accepted the offer of Eric Cooper to remove the definition of the <code>Procedure</code> class and use the Python <code>lambda</code> instead.  The smallest Java version of my Scheme ( <a href="http://norvig.com/jscheme.html">Jscheme</a> ) consisted of 1664 lines and 57K source code.  Jsceheme was originally called SILK (Scheme in Fifty Kilobytes, Scheme is 50 kilobytes), but I only met this limit in relation to the resulting bytecode.  I think it satisfies Alan Kay‚Äôs 1972 <a href="http://gagne.homedns.org/~tgagne/contrib/EarlyHistoryST.html">requirement</a> that <i>you could define ‚Äúthe most powerful language in the world‚Äù in the ‚Äúcode page‚Äù</i> . <br><blockquote>  bash $ grep "^ \ s * [^ # \ s]" lis.py |  wc <br>  90 398 3423 </blockquote><br></li><li>  <b><i>Speed:</i></b> Lispy calculates <code>(fact 100)</code> in 0.004 seconds.  For me, this is quite fast (although much slower than most other ways to calculate it). <br></li><li>  <b><i>Completion:</i></b> Lispy does not fully comply with the Scheme standard.  Here are the main disadvantages: <br><ul><li>  <b><i>Syntax:</i></b> missing comments, quoting / quasi-citing, # literals, derived expression types (such as <code>cond</code> , derived from <code>if</code> , or <code>let</code> , derived from <code>lambda</code> ), and point list notation. <br></li><li>  <b><i>Semantics:</i></b> call / cc and tail recursion absent. <br></li><li>  <b><i>Data types:</i></b> no lines, single characters, boolean type, ports (ports), vectors, exact / inaccurate numbers.  Lists in Python are actually closer to vectors in Scheme than pairs and lists. <br></li><li>  <b><i>Functions:</i></b> More than 100 primitive functions are missing, most of which are for missing data types, plus some others (such as <code>set-car!</code> And <code>set-cdr!</code> we cannot implement <code>set-cdr!</code> Completely using Python lists) . <br></li><li>  <b><i>Error handling:</i></b> Lispy does not attempt to detect errors, make an acceptable report of them, or recover.  Lispy expects programmer excellence. <br></li></ul><br></li><li>  <b><i>Good:</i></b> it's up to the readers.  I find it good for my purpose to explain Lisp interpreters. <br></li></ul><br><br><h4>  True story </h4><br>  Returning to the idea that knowing how interpreters work can be very useful, I will tell a story.  In 1984, I wrote my doctoral thesis.  That was before LaTeX, before Microsoft Word - we used troff.  Unfortunately, troff had no way to link to symbolic labels: I wanted to be able to write "As we will see on the @theoremx page", and then write something like "@ (set theoremx \ n%)" in the appropriate place ( troff reserved \ n% as page number).  My friend Tony Deroz felt the same need, and together we sketched a simple Lisp program that worked as a preprocessor.  However, it turned out that Lisp, which we had at that time, was good for reading Lisp expressions, but was so slow to read everything else that it irritated. <br><br>  Tony and I went in different ways.  He thought that the difficult part was the interpreter for expressions, he needed Lisp for this, but he knew how to write a small C subroutine to repeat non-Lisp characters and link them to a Lisp program.  I did not know how to do this binding, but I thought that writing an interpreter for this trivial language (all that was in it - setting the value of a variable, getting the value of a variable, and concatenating strings) was a simple task, so I wrote this interpreter in C. Funny that Tony wrote a Lisp program because he was a C programmer, and I wrote a C program because I was a Lisp programmer. <br><br>  In the end, we both achieved the result. <br><br><h4>  Together </h4><br>  The full Lispy code is available for download: <a href="http://norvig.com/lis.py">lis.py</a> </div><p>Source: <a href="https://habr.com/ru/post/115206/">https://habr.com/ru/post/115206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../115200/index.html">What is not protected by copyright?</a></li>
<li><a href="../115201/index.html">Error updating Windows 7 SP1 fatal error c0000034</a></li>
<li><a href="../115202/index.html">Sberbank Online Homepage Design Contest</a></li>
<li><a href="../115203/index.html">Blekko banned 1.1 million sites</a></li>
<li><a href="../115204/index.html">Report Yandex: 25% of content in RuNet - copy-paste</a></li>
<li><a href="../115207/index.html">Updated user manual in the new version of nanoCAD</a></li>
<li><a href="../115209/index.html">Logging. "From the box"</a></li>
<li><a href="../115210/index.html">Foursquare effect</a></li>
<li><a href="../115212/index.html">Post office in Sweden and Denmark switches to digital stamps</a></li>
<li><a href="../115213/index.html">Windows Azure SDK 1.4 update released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>