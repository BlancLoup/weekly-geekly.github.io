<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Theory and Practice EFI Byte Code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the late 90s, Number Nine Visual Technology, the then design graphics card designer, offered a VGA BIOS for its PCI devices on the site. There is n...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Theory and Practice EFI Byte Code</h1><div class="post__text post__text-html js-mediator-article">  In the late 90s, Number Nine Visual Technology, the then design graphics card designer, offered a VGA BIOS for its PCI devices on the site.  There is nothing remarkable in this event.  Is that the video card Number Nine could work on IBM PC-compatible platforms, and in MAC-systems using Power PC.  Therefore, the same device was packaged with different BIOS files. <br><br>  Most likely, then it could not be otherwise.  How is the situation with the support of devices designed to work in different hardware environments?  The answer to this question is given by the UEFI specification, within which an elegant solution is proposed - <i>EFI Byte Code</i> or EBC.  With it, you can create cross-platform applications for firmware. <a name="habracut"></a><br><br><h2>  How does EBC work </h2><br>  In the framework of the UEFI-standard, the virtual machine architecture of the register type <i>EFI Byte Code Virtual Machine is</i> defined.  The command interpreter is included in the firmware of the motherboard.  The firmware of the expansion cards is written in the command system of the virtual machine, ideally without using instructions from the central processor.  Thus, the expansion card will work on any motherboard that supports EBC, regardless of the type of CPU.  Today, their list does not shine with a variety: as usual, there is AMD and Intel in 32-bit and 64-bit versions, Itanium, ARM. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  EBC virtual processor architecture </h2><br>  The 64-bit EBC virtual processor contains 8 general-purpose registers (R0-R7), supports direct, indirect, and direct addressing of operands.  The command system includes arithmetic and logical operations, shifts, operand transfers with support for character expansion, conditional and unconditional control transfer, subroutine calls and returns, as well as a number of auxiliary operations.  The stack is supported, with the stack pointer (register R0) according to the traditions of the x86 architecture, classified as a general-purpose register.  It is noteworthy that the special form of the CALL instruction allows you to call out subroutines written in the <i>native</i> language of the platform from EBC routines, because sometimes such a need does arise.  In the same way, procedures for supporting UEFI protocols can be called from the EBC programs using the transmission model of the input and output parameters, independent of the type of central processor. <br><br><h2>  We start experiments </h2><br>  The proposed example is ‚Äú <a href="">Hello, EBC!</a>  "Is a UEFI application written in the EBC Byte Code virtual machine command system.  As mentioned above, the EBC command interpreter, which allows you to run modules of this type, is resident in the UEFI firmware of the motherboard.  Using EBC instead of machine code allows you to create cross-platform applications and drivers, including the firmware of various expansion cards, which makes these devices compatible with platforms that use CPUs other than x86 architecture. <br><br><h2>  Explanations for example </h2><br>  The program displays a text message using the line output procedure from the <b>EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL</b> function <b>set</b> .  Let us consider in more detail its <a href="" title="Hello, EBC source code!">source code</a> . <br><br>  To call this EFI-function in the stack, you need to pass two parameters: a pointer to the interface unit of the protocol used and a pointer to a string represented in the UNICODE format.  These parameters are prepared in registers R1 and R2, then pushed onto the stack with PUSHn instructions, starting with the last parameter.  Then, in the R3 register, the address for the procedure call is read, read from the interface unit of the protocol used, and the target procedure for the line output is called.  After returning, we release the stack with POPn instructions. <br><br><h2>  System tables and cross-platform </h2><br>  To call UEFI protocol service procedures, applications use pointers located in the UEFI system tables and various interface blocks.  In 32-bit UEFI implementations, 4 byte pointers are used, and in 64-bit implementations, 8 bytes are used.  Consequently, the address of the pointer inside the table will depend on the width of the CPU.  How is cross-platform provided? <br><br>  Consider an example of an instruction transferring to the R1 register the contents of a memory cell whose address is equal to the initial value of the R1 register plus the <i>offset</i> . <br><br> <code>MOVnw R1,@R1(+5,+24)</code> <br> <br>  The offset is given as two terms: +5 and +24. <br><br>  The first term +5 is the indexable pointer number.  The EBC command interpreter multiplies this value by the pointer size, which is 4 for 32-bit UEFI implementations and 8 for 64-bit implementations. <br><br>  The second term +24 is a constant independent of the type of platform.  It is used to set the size of the header for the <b>EFI_SYSTEM_TABLE</b> table. <br><br>  Similarly, PUSHn (Push Natural) instructions work when preparing a stack frame for called procedures.  The width of the parameters written to the stack (32 or 64 bits) depends on the width of the CPU.  This provides a gateway between the EBC code of the application and the procedures that are part of the UEFI firmware written in the system commands of the central processor. <br><br><h2>  Broadcast and launch </h2><br>  FASM 1.69.50 is used to <a href="" title="BAT file to run FASM">broadcast the program</a> and generate the EBC application.  The EFI Byte Code virtual machine instructions are given as hexadecimal constants.  Guided by research interest, we deliberately abandoned the use of high-level languages ‚Äã‚Äãand wrote our example in the EBC assembler.  At the same time, we had to solve several problems related to the fact that the FASM compiler does not support EBC. <br><br>  After the translation, in the header of the file <a href="" title="EBC application for UEFI">helloebc.efi</a> , at addresses 84h, 85h, bytes 64h, 86h must be replaced by BCh, 0Eh.  Thus, the <i>Machine Type</i> field, initially containing 8664h (x86-64 machine), is replaced by 0EBCh (EBC machine).  To run the editor embedded in the UEFI Shell, type the following at the command line: <b>hexedit helloebc.efi</b> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f6b/fbb/cc1/f6bfbbcc1ed24e03dd329837f636f0a8.png" alt="  Machine Type   " title="Correction of the Machine Type field in the application header"><br><br>  <b>Figure 1</b> .  <i>Correction of the Machine Type field in the application header</i> <br><br>  After that, you can run the application. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/874/06f/201/87406f2011493b813b128d07702f8147.png" alt="  " title="Application Result"><br><br>  <b>Figure 2</b> .  <i>Application Result</i> <br><br>  The application can also be run under the Intel EBC Debugger. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/818/160/70a/81816070a6fdf60887cb46c59751a814.png" alt="   load   EBC-" title="Loading the debugger with the load command and running the EBC application"><br><br>  <b>Figure 3</b> .  <i>Loading the debugger with the load command and running the EBC application under the Intel EBC Debugger debugger</i> <br><br><h2>  Summary </h2><br>  We tested the test case in IA32 EFI and x64 UEFI environments.  Theoretically, it should work on platforms with Itanium and ARM processors, but due to the unavailability of these systems, we could not make sure of this. <br><br>  The application is broadcast in PE64 (Portable Executable 64-bit) mode.  Some outdated EFI implementations (for example, the <b><i>Intel EFI Version 1.10.14.59 Sample Implementation</i></b> emulator running from a bootable diskette) are not compatible with this application format.  This is reflected in the incorrect interpretation of the table of relocatable elements used when configuring the module to load addresses.  One of the solutions is to perform the setup programmatically. <br><br>  Since the FASM translator does not support the EFI Byte Code, to ensure effective programming at the EBC assembler level in the FASM environment, we have to do the following: <br><br><ol><li>  Write a small service utility to automate the rewriting of the Machine Type field in the UEFI application header with the module checksum recalculated. </li><li>  Prepare a set of macros for using assembler EBC mnemonics in the FASM environment. </li></ol><br><br><h3>  Information sources </h3><br><ul><li>  <a href="http://wiki.phoenix.com/wiki/index.php/UEFI">UEFI PhoenixWiki, Phoenix Technologies</a> </li><li>  <a href="http://www.uefi.org/node/550">Intel EBC Debugger, UEFI Forum</a> </li><li>  <a href="http://jelezo.com.ua/stati/kak_polzovatsya_uefi-prilozheniyami.html">How to use UEFI</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/201954/">https://habr.com/ru/post/201954/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201942/index.html">Microsoft changes employee rating system</a></li>
<li><a href="../201944/index.html">Bcache versus btier</a></li>
<li><a href="../201948/index.html">China and the Chinese. View from the outside. Part 1</a></li>
<li><a href="../201950/index.html">On the Kickstarter they raise funds for the robot Robokind Zeno R25, which is able to recognize and imitate emotions.</a></li>
<li><a href="../201952/index.html">Incorrect interpretation of the Aho-Korasik algorithm</a></li>
<li><a href="../201958/index.html">A free Jelastic appeared in Russia</a></li>
<li><a href="../201960/index.html">CyanogenMod Installer appeared in the Play Market</a></li>
<li><a href="../201966/index.html">Development of Windows 8.1 applications on XAML / –° #. Part 1. Making the main screen of the application based on Hub</a></li>
<li><a href="../201968/index.html">Googlebot learns to index mobile apps</a></li>
<li><a href="../201972/index.html">Wikification of short text messages</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>