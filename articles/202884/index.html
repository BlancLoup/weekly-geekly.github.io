<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overcoming the hidden dangers of KVO in Objective C</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It wouldn‚Äôt be possible to get it. 
 - Douglas Adams 

 Objective C has been around since 1983 and is the same age as C ++. However, unlike the latter...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overcoming the hidden dangers of KVO in Objective C</h1><div class="post__text post__text-html js-mediator-article">  <i>It wouldn‚Äôt be possible to get it.</i> <i><br></i>  <i>- Douglas Adams</i> <br><br>  Objective C has been around since 1983 and is the same age as C ++.  However, unlike the latter, it began to gain popularity only in 2008, after the release of iOS 2.0, the new version of the operating system for the revolutionary iPhone, which included the AppStore application, which allows users to purchase third-party applications. <br>  Objective C continued to succeed not only because of the popularity of iOS devices and the relative ease of sales through the AppStore, but also through Apple's significant efforts to improve both standard libraries and the language itself. <br>  According <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html">to the TIOBE rating,</a> by the beginning of 2013, Objective C overtook C ++ in popularity and finished third, second only to C and Java. <br><br>  Today, Objective C includes both relatively old features like <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html">KVC</a> and <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html">KVO</a> , which existed 4 years before the release of the first iPhone, and such new features as <a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html">blocks</a> (blocks, introduced in Mac OS 10.6 and iOS 4) and <a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">automatic reference counting</a> (ARC). , available in Mac OS 10.7 and iOS 5), which make it easy to solve problems that caused serious difficulties earlier. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      KVO is a technology that allows you to immediately respond in one object (the observer) to changes in the state of another object (the observed), without introducing knowledge about the type of observer in the implementation of the observed object.  In Objective C, along with KVO, there are several ways to solve this problem: <br><br><a name="habracut"></a>  1. <a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/DelegatesandDataSources/DelegatesandDataSources.html">Delegation</a> is a common object-oriented programming pattern, consisting in that an object is passed a link to an arbitrary object (called a delegate) that implements a specific <a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html">protocol</a> ‚Äî a fixed set of selectors.  After this, the implementation of the object ‚Äúmanually‚Äù sends messages to the delegate corresponding to the occasion.  For example, the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollView_Class/Reference/UIScrollView.html">UIScrollView</a> notifies its delegate of a change in the value of its contentOffset property by calling the <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIScrollViewDelegate_Protocol/Reference/UIScrollViewDelegate.html">scrollViewDidScroll</a> : selector. <br>  It is recommended that one of the parameters of all protocol selectors make a reference to the object that calls it, so that in the case when the same object is a delegate of several objects of the same class, it should be possible to distinguish from which of them the message comes. <br><br>  2. <a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html">Target-action</a> .  The difference between this technique and delegation is that instead of the delegate implementing a particular protocol, its selector is passed along with it, which will be called upon a specific event.  This technique is most often used by successors of <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIControl_Class/Reference/Reference.html">UIControl</a> , for example, a <a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UISwitch_Class/Reference/Reference.html">UISwitch</a> object can be set to a target-action pair for the call when the user switches this control (UIControlEventValueChanged event).  Such a solution is more convenient than delegation in the case when one object ‚Äútarget‚Äù must respond to the same events from different sources (for example, several UISwitch). <br><br>  3. Callback block.  This solution consists in the fact that the reference to the observed object is transmitted not to the observer object itself, but to the block.  As a rule, this block is created in the same place where it is installed.  At the same time, the block implementation is capable of capturing the values ‚Äã‚Äãof local variables of the scope where it is defined, eliminating the need to add a separate method and restore the context within its implementation. <br>  An important difference of this approach from the previous ones is that if the reference to the delegate or target is weak (weak reference), then the link to the block is strong (usually it is the only one), and the programmer needs every time to implement the blocks to ensure that the block was capturing objects by weak links.  Otherwise, it can lead to cyclic strong connections and memory leaks. <br>  Just as in the first two techniques, one of the block's arguments is recommended to make a reference to the object that calls it, but for a slightly different reason.  In spite of the fact that the block can capture this link from the context anyway, it is easy to grab an object by a strong link by mistake, or <a href="http://stackoverflow.com/questions/8113268/how-to-cancel-nsblockoperation">to capture the nil</a> with which this link was initialized. <br><br>  4. <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html">NSNotificationCenter</a> allows <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html">you</a> to send alerts (NSNotification) consisting of a string name and an arbitrary object from any method of any class.  Such an alert will be received by any objects that subscribe to alerts with that name and (optionally) an object.  A subscription to alerts is implemented either on the basis of target-action, or using a callback block. <br>  Unlike the previous approaches, the use of NSNotificationCenter leads to weaker dependencies between objects and allows you to easily sign several objects to the same notification without additional efforts. <br><br>  5. <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html">NSKeyValueObserving</a> is an informal protocol implemented in the NSObject class that allows you to sign an arbitrary object (observer) to change the value on the specified key path of the specified other object (the observed) by calling on it the addObserver: forKeyPath: options: context :.  After that, each time the value is changed, the observer will receive the observeValueForKeyPath: ofObject: change: context: message, similar to the delegation pattern. <br>  Thus, KVO allows you to sign an unlimited number of objects on changes not only of a single attribute, but also of values ‚Äã‚Äãalong the composite key path of the observed object, as a rule, without any modifications of the latter. <br><br>  Despite the obvious power of KVO, it is not very popular among developers, and is often treated as at least, resorting only when other solutions are not available.  To try to understand (and correct) the reasons for such dislike, consider a couple of examples of using KVO. <br><br>  Suppose we have an ETRDocument class that has the title and isFavorite attributes <br><br><pre><code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocument</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSString</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">title</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BOOL</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isFavorite</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><br>  and we want to implement a table cell displaying information about the document <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocument</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocumentCell</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UITableViewCell</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocument</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">document</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBOutlet</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UILabel</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">titleLabel</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBOutlet</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIButton</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isFavoriteButton</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IBAction</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">toggleIsFavorite</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocumentCell</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">updateIsFavoriteButton</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isFavoriteButton.selected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)toggleIsFavorite { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite = !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> updateIsFavoriteButton]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setDocument:(ETRDocument *)document { _document = document; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.titleLabel.text = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.title; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> updateIsFavoriteButton]; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  Suppose we find that the value of isFavorite can be changed not only by pressing a button, but also in some way external to the cell.  This does not affect the appearance of the cell, which should be corrected.  When we changed the isFavorite, we could manually find the cells and update them by calling updateIsFavoriteButton, but this would create unnecessary connections between the classes and break the encapsulation of our cell.  Therefore, we decide to sign the cell itself on the changes in the document.  We could make it a document delegate, or send notifications when the isFavorite changes, but if we use KVO instead, we will not need to make any changes in the document class: all additional logic will be encapsulated in the cell class. <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)startObservingIsFavorite { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"isFavorite"</span></span> options:<span class="hljs-number"><span class="hljs-number">0</span></span> context:<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)stopObservingIsFavorite { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document removeObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"isFavorite"</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setDocument:(ETRDocument *)document { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> stopObservingIsFavorite]; _document = document; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> startObservingIsFavorite]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.titleLabel.text = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.title; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> updateIsFavoriteButton]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)observeValueForKeyPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)keyPath ofObject:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)object change:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)change context:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)context { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> updateIsFavoriteButton]; }</code> </pre><br>  We start - everything works, the cell reacts to the change of isFavorite.  We can even remove the updateIsFavoriteButton call from toggleIsFavorite.  However, it is necessary to close the table and change the value of isFavorite in one of the documents, as the application falls with EXC_BAD_ACCESS. <br>  What happened?  Let's try to enable <a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html">NSZombieEnabled</a> and repeat the steps.  This time we get a more sensible message when falling: <br>  *** - [ETRDocumentCell retain]: message sent to deallocated instance 0x8bcda20 <br><br>  Indeed, looking into the KVO documentation we will see the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOBasics.html">following</a> : <br>  Note: The key-value observing: the addObserver: forKeyPath: options: context:  You must ensure that you keep your references. <br><br>  Observation does not create strong references to either the observer, or the observed object, or to the context.  However, the documentation is silent about what happens when one of these objects is deleted. <br><br>  The context for KVO is a regular pointer from the C language. Even if it points to an Objective C object, KVO will not consider it as such: will not send messages to it or track its lifetime.  Therefore, if the context is removed, then the hanging link will be transmitted to observeValueForKeyPath, and an attempt to pass a message on it will lead to consequences similar to those we have.  However, we did not use context in our example.  Moreover, it will further become clear that the context has a slightly different ‚Äútrue‚Äù purpose. <br><br>  If the observed object is deleted, instead of stopping the observation (after all, no values ‚Äã‚Äãcan be changed anymore), a warning will be displayed in the console: <br><br>  An instance 0xac62490 of class ETRDocument was a deallocated while key value observers were still registered <br>  with it.  Observation info was leaked, and may even become mistakenly attached to some other object. <br>  Set a breakpoint on NSKVODeallocateBreak to stop here in the debugger.  Here's the current observation info: <br>  &lt;NSKeyValueObservationInfo 0xaaa77e0&gt; ( <br>  &lt;NSKeyValueObservance 0xaaa77a0: Observer: 0xaaa2100, Key path: isFavorite, Options: <br>  &lt;New: NO, Old: NO, Prior: NO&gt; Context: 0x0, Property: 0xabf12e0&gt; <br>  ) <br><br>  after which the application will behave in an unpredictable way, and sooner or later will fall.  However, in our case, the cell stores a strong link to the observed object, and it cannot be deleted before the cell is deleted. <br><br>  If the observer is removed, the KVO will retain the ‚Äúhanging‚Äù link to it (which corresponds to the unsafe_unretained modifier in the ARC terminology), and will send messages on it with changes.  This is exactly what happens in our example.  Perhaps in later versions, the behavior of ‚Äúunsafe_unretained‚Äù will be replaced with a more secure ‚Äúweak‚Äù, and the ‚Äúhanging‚Äù links to observers will automatically be reset. <br>  To fix this fall, just call stopObservingIsFavorite from dealloc. <br><br>  There is a way to simplify the logic of our cell.  Instead of observing the document's key path ‚ÄúisFavorite‚Äù, the cell can observe the key path ‚Äúdocument.isFavorite‚Äù on itself.  As a result, the cell will be notified both when the isFavorite attribute is changed in the associated document, and when its link to the document changes.  At the same time, you still need to call removeObserver from dealloc, but you do not need to stop and start monitoring every time you change the current document. <br>  You can go further and watch not only is Favorite, but also the title.  This will save us from overriding setDocument :, but it will deal with another inconvenience of KVO: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocumentCell</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeFromNib]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span> options:<span class="hljs-number"><span class="hljs-number">0</span></span> context:<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.title"</span></span> options:<span class="hljs-number"><span class="hljs-number">0</span></span> context:<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)dealloc { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> removeObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span>]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> removeObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.title"</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)toggleIsFavorite { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite = !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)observeValueForKeyPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)keyPath ofObject:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)object change:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)change context:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)context { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([keyPath isEqualToString:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isFavoriteButton.selected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([keyPath isEqualToString:<span class="hljs-string"><span class="hljs-string">@"document.title"</span></span>]) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.titleLabel.text = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.title; } } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  Old (but not very kind) case analysis in one method with string comparison duplicated in two other places.  This is not only ugly, but fraught with errors, like any other "copy-paste". <br><br>  We could stop at this, hoping that nothing bad will happen and everything will work.  And now it really will work.  But sooner or later, something bad may still happen, and after a couple of hours in the debugger, we will be entrenched in the conviction that it is better not to get involved with KVO. <br>  What can happen?  Let's slightly complicate our example and suppose that we decided to make another table for displaying our documents, but with slightly more ‚Äúclever‚Äù cells, which will also contain the document title and the same button, but along with other changes, the background color will change depending on whether the document is a favorite. <br>  So that the work already done is not in vain, we decide to inherit a new cell from the old one. <br>  To change the cell background, we use the same KVO technique: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRAdvancedDocumentCell</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeFromNib]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span> options:<span class="hljs-number"><span class="hljs-number">0</span></span> context:<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)observeValueForKeyPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)keyPath ofObject:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)object change:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)change context:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)context { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> updateBackgroundColor]; } ...</code> </pre><br>  Great, the background changes color.  That's just the button has ceased to stand out, the title has ceased to be updated, and updateBackgroundColor is called somehow too often.  Obviously, ETRAdvancedDocumentCell receives observeValueForKeyPath messages, related to both own and ETRDocumentCell observations.  What on this account is written in the documentation?  In the comments inside the code of one of the examples we find the <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOBasics.html">following lines</a> : <br>  Be sure to call the superclass implementation. <br>  NSObject does not implement the method. <br><br>  We, of course, know that ETRDocumentCell implements observeValueForKeyPath, which means you need to call <br>  [super observeValueForKeyPath: keyPath ofObject: object change: change context: context] from ETRAdvancedDocumentCell. <br><br>  But all is not limited to a call of implementation from a parent class.  You should process the changes for which the ETRAdvancedDocumentCell itself is signed, and pass only the other changes to the parent class.  Obviously, some checks of the keyPath and object values ‚Äã‚Äãare indispensable: the parent class is subscribed to exactly the same keyPath (document.isFavorite) of the same object (self).  This is where the very ‚Äútrue‚Äù purpose of the context argument is shown. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ETRAdvancedDocumentCellIsFavoriteContext = &amp;ETRAdvancedDocumentCellIsFavoriteContext; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRAdvancedDocumentCell</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeFromNib]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span> options:<span class="hljs-number"><span class="hljs-number">0</span></span> context:ETRAdvancedDocumentCellIsFavoriteContext]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)dealloc { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> removeObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span> context:ETRAdvancedDocumentCellIsFavoriteContext]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)observeValueForKeyPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)keyPath ofObject:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)object change:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)change context:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)context { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == ETRAdvancedDocumentCellIsFavoriteContext) { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> updateBackgroundColor]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> observeValueForKeyPath:keyPath ofObject:object change:change context:context]; } } ...</code> </pre><br>  The static variable ETRAdvancedDocumentCellIsFavoriteContext contains a pointer to a fixed memory region containing its own address.  This guarantees different values ‚Äã‚Äãfor all variables declared in this way. <br><br>  It is obvious that the observation should also be stopped with an indication of the context.  Curious is the fact that the corresponding method was added only in iOS 5, and before that there was only a variant without a context argument.  This made it impossible to correctly stop one of the indistinguishable by other parameters of observations. <br><br>  But what about ETRDocumentCell: do you need to call super from it?  Does the UITableViewCell class implement the observeValueForKeyPath selector?  You can resort to the trial and error method, try to call super, get the expected drop with the exception <br><br>  *** Terminating app due to uncaught exception 'NSInternalInconsistencyException', <br>  reason: '&lt;ETRDocumentCell: 0x8d3c540;  baseClass = UITableViewCell; <br>  frame = (0 0; 320 64);  autoresize = W;  layer = &lt;CALayer: 0x8d3c730 &gt;&gt;: <br>  An -observeValueForKeyPath: ofObject: change: context: it was received but not handled. <br>  Key path: document.title <br>  Observed object: &lt;ETRDocumentCell: 0x8d3c540;  baseClass = UITableViewCell; <br>  frame = (0 0; 320 64);  autoresize = W;  layer = &lt;CALayer: 0x8d3c730 &gt;&gt; <br>  Change: { <br>  kind = 1; <br>  } <br>  Context: 0x0 ' <br>  *** First throw call stack: <br>  ( <br>  0 CoreFoundation 0x0173b5e4 __exceptionPreprocess + 180 <br>  1 libobjc.A.dylib 0x014be8b6 objc_exception_throw + 44 <br>  2 CoreFoundation 0x0173b3bb + [NSException raise: format:] + 139 <br>  3 Foundation 0x0118863f - [NSObject (NSKeyValueObserving) observeValueForKeyPath: ofObject: change: context:] + 94 <br>  4 ETRKVO 0x00002e35 - [ETRDocumentCell observeValueForKeyPath: ofObject: change: context:] + 229 <br>  5 Foundation 0x0110d8c7 NSKeyValueNotifyObserver + 362 <br>  6 Foundation 0x0110f206 NSKeyValueDidChange + 458 <br>  ... <br><br>  and put the call back.  But where is the guarantee that the parent class will not start (or, on the contrary, stop) implement observeValueForKeyPath in the next version?  Even if you implement the parent class yourself, you risk forgetting to add or remove the super call in the child classes.  The most reliable solution would be to perform an appropriate check at runtime.  This is not done at all by calling [super respondsToSelector: ...], which always returns YES, because our class does not override respondsToSelector :, and calling it on super doesn‚Äôt call it on self.  This is done using a slightly longer expression [[ETRDocumentCell superclass] instancesRespondToSelector: ...].  But as it turns out, the documentation is deceiving us, and [[NSObject class] instancesRespondToSelector: @selector (observeValueForKeyPath: ofObject: change: context :)] returns YES, and the corresponding implementation is exactly the same and is responsible for the above exception.  It turns out that we have two options: either never call super and risk breaking the logic of the parent class, or calling super only for observations not guaranteed by our code, risking getting an exception, skipping something extra. <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ETRDocumentCellIsFavoriteContext = &amp;ETRDocumentCellIsFavoriteContext; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* ETRDocumentCellTitleContext = &amp;ETRDocumentCellTitleContext; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocumentCell</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeFromNib]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span> options:<span class="hljs-number"><span class="hljs-number">0</span></span> context:ETRDocumentCellIsFavoriteContext]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.title"</span></span> options:<span class="hljs-number"><span class="hljs-number">0</span></span> context:ETRDocumentCellTitleContext]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)dealloc { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> removeObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span> context:ETRDocumentCellIsFavoriteContext]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> removeObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.title"</span></span> context:ETRDocumentCellTitleContext]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)toggleIsFavorite { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite = !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)observeValueForKeyPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)keyPath ofObject:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)object change:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)change context:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)context { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == ETRDocumentCellIsFavoriteContext) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isFavoriteButton.selected = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == ETRDocumentCellTitleContext) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.titleLabel.text = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.title; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> observeValueForKeyPath:keyPath ofObject:object change:change context:context]; } } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span></code> </pre><br>  From the above example, it follows that for the correct implementation of KVO it is necessary to do a lot of non-trivial and non-obvious actions.  Moreover, they should be done in a consistent way at all levels of inheritance, which is not at the mercy of the developer, if some of these levels are implemented in standard or third-party libraries, or if the product itself is a library that assumes inheritance from some of its classes. <br>  In addition, the programmer must clearly monitor all active observations in the observer class in order to ensure that they are processed in observeValueForKeyPath and stopped at the right time (for example, when an observer is deleted).  This is complicated by the separation of the associated code in several places (defining contexts, adding, deleting and processing observations) and is aggravated by the fact that it is impossible to verify the existence of an observation, and an attempt to stop a nonexistent observation results in an exception: <br><br>  *** Terminating app due to uncaught exception 'NSRangeException', <br>  reason: 'Cannot remove an observer &lt;ETRAdvancedDocumentCell 0x1566cdd0&gt; <br>  for the key path "document.title" from &lt;ETRAdvancedDocumentCell 0x1566cdd0&gt; <br>  because it is not registered as an observer. ' <br><br>  You can often find UIViewControllers that add themselves as observers inside the implementation of one of the viewDidLoad, vewDidUnload, viewWillAppear, viewDidAppear, viewWillDisappear or viewDidDisappear methods, and stop watching in another of these methods.  However, no one guarantees the strict pairing of these calls, especially when using custom container view controllers, especially with shouldAutomaticallyForwardAppearanceMethods, which returns NO.  In particular, the logic of these calls for controllers contained in the UINavigationController stack has changed in iOS 7 with the introduction of an interactive gesture to move backwards through the navigation stack.  And a link to an object passed as an observable may change between these calls. <br>  As a result, some developers even seriously suggest using <a href="http://nshipster.com/key-value-observing/">solutions like the following</a> : <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@try</span></span> { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document removeObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:<span class="hljs-string"><span class="hljs-string">@"isFavorite"</span></span> context:DocumentCellIsFavoriteContext]; } <span class="hljs-keyword"><span class="hljs-keyword">@catch</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">NSException</span></span> *exception) {}</code> </pre><br>  When I see something similar, I remember how in my childhood I wrote the line ‚ÄúOn Error Resume Next‚Äù in Visual Basic, and my ‚Äúcreations‚Äù miraculously stopped falling. <br><br>  From all that has been written, it follows that KVO is a very powerful technology, access to which we have through an API, which is not only inconvenient, but also deadly for applications that use it.  Such situations are not rare in the field of programming, and the right way out of them is to write a more convenient and safe interface that isolates and neutralizes all the flaws within its implementation. <br><br>  In the case of KVO, the root of the problems with both inheritance and removeObserver is that a single observation loses its identity to the programmer after it is added.  Instead of stopping ‚Äúspecifically this observation‚Äù, the developer is forced to demand to stop ‚Äúany observation that meets the specified criteria.‚Äù  Moreover, there may be several such observations, or not at all.  The same thing happens in the observeValueForKeyPath implementation: when it is not enough to distinguish observations by object and key, one has to resort to specific contexts.  But even the context does not define the specific act of adding observation, but only a line of code in which it is performed.  If the same line of code is called twice with the same observer, the object being observed and the key path, it will not be possible to distinguish between the consequences of these two calls.  Similarly, inheritance problems are also caused by the fact that the parent and child classes are related in the details of their KVO implementation (which must be securely encapsulated), since their object is the same observer from the KVO point of view. <br><br>  From these considerations it follows that in order to use KVO more reliably, it is necessary to give an identity to each individual observation, namely, to create a separate object for each observation.  The same object should be an observer in terms of the standard KVO interface.  By observing exactly one keyPath of exactly one object, and clearly associating this observation with its own lifetime, this object will be reliably protected from the hazards described above.  Receiving a message about a change in the observed value, the only thing he will do is notify another object with one of the first three methods indicated at the beginning of the article. <br>  Let's try to implement such an object: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVO</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSObject</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unsafe_unretained</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subject</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">readonly</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSString</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keyPath</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">copy</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> (^</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block</span></span></span><span class="hljs-class">)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVO</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kvo</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSDictionary</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">change</span></span></span><span class="hljs-class">); - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initWithSubject</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keyPath</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSString</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keyPath</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">options</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSKeyValueObservingOptions</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">options</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> (^)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVO</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kvo</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSDictionary</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">change</span></span></span><span class="hljs-class">))</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block</span></span></span><span class="hljs-class">; - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stopObservation</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVOContext</span></span></span><span class="hljs-class"> = &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVOContext</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVO</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">initWithSubject</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">id</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">subject</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keyPath</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSString</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">keyPath</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">options</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSKeyValueObservingOptions</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">options</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block</span></span></span><span class="hljs-class">:(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> (^)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVO</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">kvo</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NSDictionary</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">change</span></span></span><span class="hljs-class">))</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">block</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { _subject = subject; _keyPath = [keyPath <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>]; _block = [block <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>]; [subject addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:keyPath options:options context:ETRKVOContext]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)observeValueForKeyPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)keyPath ofObject:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)object change:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)change context:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)context { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == ETRKVOContext) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.block) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.block(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, change); } <span class="hljs-comment"><span class="hljs-comment">// NSObject does not implement observeValueForKeyPath } - (void)stopObservation { [self.subject removeObserver:self forKeyPath:self.keyPath context:ETRKVOContext]; _subject = nil; } - (void)dealloc { [self stopObservation]; } @end</span></span></code> </pre><br>  Alternative solutions can be found in the <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> library, claiming a radical shift in the Objective-C programming paradigm, and in the somewhat outdated <a href="https://github.com/mikeash/MAKVONotificationCenter">MAKVONotificationCenter</a> . <br>  In addition, similar changes were made to NSNotificationCenter for the same reasons: in iOS 4, the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSNotificationCenter_Class/Reference/Reference.html">addObserverForName: object: queue: usingBlock</a> : method was added that returns an object that identifies an alert subscription. <br><br>  The ETRKVO interface can be somewhat simplified by considering the behavior of the options and change arguments. <br>  NSKeyValueObservingOptions is a bitmask that can combine the following flags: <br><ul><li>  NSKeyValueObservingOptionNew </li><li>  NSKeyValueObservingOptionOld </li><li>  NSKeyValueObservingOptionInitial </li><li>  NSKeyValueObservingOptionPrior </li></ul><br><br>  The first two indicate that the change argument should contain the old and the new values ‚Äã‚Äãof the observed attribute.  It can not cause any negative consequences, except for a slight slowdown. <br>  Specifying NSKeyValueObservingOptionInitial causes the observeValueForKeyPath to be called immediately upon adding a supervision, which, generally speaking, is useless. <br>  Specifying NSKeyValueObservingOptionPrior causes observeValueForKeyPath to be called not only after changing the value, but also before it.  However, the new value will not be transferred, even if the NSKeyValueObservingOptionNew flag is specified.  The need for this can be met extremely rarely, and most likely it arises only in the process of implementing some kind of ‚Äúcrutch‚Äù. <br>  Therefore, you can always pass as options (NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld). <br><br>  The argument (NSDictionary *) change may contain the following keys: <br><ul><li>  NSKeyValueChangeNewKey </li><li>  NSKeyValueChangeOldKey </li><li>  NSKeyValueChangeKindKey </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NSKeyValueChangeIndexesKey </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NSKeyValueChangeNotificationIsPriorKey </font></font></li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first two contain the oldest and newest values ‚Äã‚Äãthat can be queried with the appropriate options. </font><font style="vertical-align: inherit;">Values ‚Äã‚Äãof scalar types are wrapped in NSNumber or NSValue, and instead of nil, the singleton object [NSNull null] is passed. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following two are only needed when observing a mutable collection, which is most likely a bad idea. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The last key is transmitted only in the case of a previous change made when the NSKeyValueObservingOptionPrior option is available. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, it is possible to consider only the NSKeyValueChangeNewKey and NSKeyValueChangeOldKey keys, and transfer their values ‚Äã‚Äãto the block in expanded form. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, ETRKVO can be changed as follows:</font></font><br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)initWithSubject:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)subject keyPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)keyPath block:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (^)(ETRKVO *kvo, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> oldValue, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> newValue))block { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { _subject = subject; _keyPath = [keyPath <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>]; _block = [block <span class="hljs-keyword"><span class="hljs-keyword">copy</span></span>]; [subject addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> forKeyPath:keyPath options:(<span class="hljs-built_in"><span class="hljs-built_in">NSKeyValueObservingOptionNew</span></span> | <span class="hljs-built_in"><span class="hljs-built_in">NSKeyValueObservingOptionOld</span></span>) context:ETRKVOContext]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)observeValueForKeyPath:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)keyPath ofObject:(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)object change:(<span class="hljs-built_in"><span class="hljs-built_in">NSDictionary</span></span> *)change context:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)context { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context == ETRKVOContext) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.block) { <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> oldValue = change[<span class="hljs-built_in"><span class="hljs-built_in">NSKeyValueChangeOldKey</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldValue == [<span class="hljs-built_in"><span class="hljs-built_in">NSNull</span></span> null]) oldValue = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> newValue = change[<span class="hljs-built_in"><span class="hljs-built_in">NSKeyValueChangeNewKey</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (newValue == [<span class="hljs-built_in"><span class="hljs-built_in">NSNull</span></span> null]) newValue = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.block(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, oldValue, newValue); } } <span class="hljs-comment"><span class="hljs-comment">// NSObject does not implement observeValueForKeyPath }          NSObject,    : - (ETRKVO *)observeKeyPath:(NSString *)keyPath withBlock:(void (^)(ETRKVO *kvo, id oldValue, id newValue))block;</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since keyPath is often the name of a property that matches the corresponding getter, it is more convenient to use the selector of this getter instead of the keyPath string. </font><font style="vertical-align: inherit;">At the same time autocompletion will work, and there will be less chance to make a mistake when writing, or when renaming property.</font></font><br><br><pre> <code class="objectivec hljs">- (ETRKVO *)observeSelector:(SEL)selector withBlock:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (^)(ETRKVO *kvo, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> oldValue, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> newValue))block { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [[ETRKVO alloc] initWithSubject:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> keyPath:<span class="hljs-built_in"><span class="hljs-built_in">NSStringFromSelector</span></span>(selector) block:block]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rewrite our cells using this class and category. </font></font><br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocumentCell</span></span></span><span class="hljs-class"> () @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVO</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">isFavoriteKVO</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVO</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">titleKVO</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRDocumentCell</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeFromNib]; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) __<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> weakSelf = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isFavoriteKVO = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> observeKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span> withBlock:^(ETRKVO *kvo, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> oldValue, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> newValue) { weakSelf.isFavoriteButton.selected = weakSelf.document.isFavorite; }]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.titleKVO = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> observeKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.title"</span></span> withBlock:^(ETRKVO *kvo, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> oldValue, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> newValue) { weakSelf.titleLabel.text = weakSelf.document.title; }]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)dealloc { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isFavoriteKVO stopObservation]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.titleKVO stopObservation]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)toggleIsFavorite { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite = !<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.document.isFavorite; } <span class="hljs-keyword"><span class="hljs-keyword">@end</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRAdvancedDocumentCell</span></span></span><span class="hljs-class"> () @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">property</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nonatomic</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">strong</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRKVO</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">advancedIsFavoriteKVO</span></span></span><span class="hljs-class">; @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">end</span></span></span><span class="hljs-class"> @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">implementation</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ETRAdvancedDocumentCell</span></span></span><span class="hljs-class"> - (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class">)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">awakeFromNib</span></span></span><span class="hljs-class"> </span></span>{ [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> awakeFromNib]; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) __<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> weakSelf = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.advancedIsFavoriteKVO = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> observeKeyPath:<span class="hljs-string"><span class="hljs-string">@"document.isFavorite"</span></span> withBlock:^(ETRKVO *kvo, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> oldValue, <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> newValue) { [weakSelf updateBackgroundColor]; }]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)dealloc { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.advancedIsFavoriteKVO stopObservation]; } ...</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The full implementation of ETRKVO along with an example can be downloaded </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here.</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The only non-obvious method here is to use weakSelf to prevent memory leaks. If the blocks captured self by a strong link, a cycle of strong links would form: ETRDocumentCell ‚Üí isFavoriteKVO ‚Üí block ‚Üí ETRDocumentCell. However, if you actively use blocks, capturing objects from weak links should already become a habit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that although the objects of the ETRKVO class are deleted after the cells lose references to them (they delete themselves), and when counting the links, there are no effects like waiting for garbage collection, deletion nevertheless may not happen immediately if the link is in autorelease pool.</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, you should always manually call stopObservation before the ETRKVO object or the observed object is deleted.</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> When using the same property for a sequence of different observations, it is convenient to call stopObservation in its setter.</font></font><br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)setIsFavoriteKVO:(ETRKVO *)isFavoriteKVO { [_isFavoriteKVO stopObservation]; _isFavoriteKVO = isFavoriteKVO; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)dealloc { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.isFavoriteKVO = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Requirements for manual termination of observations could be relaxed if automatic reference counting could nullify weak KVO links in a compliant way, that is, in such a way that objects that monitor their values ‚Äã‚Äãare notified of this. At the moment, in iOS 7, </font></font><a href="http://www.mikeabdullah.net/weak-properties-kvo-compliance.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this is impossible</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (unless we consider ‚Äúdirty tricks‚Äù like the </font></font><a href="http://cocoadev.com/MethodSwizzling"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">substitution of the implementation of</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the dealloc method). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We should not forget that the change handler is called on the same thread of execution in which this change occurs. If the observation of an object that can be changed from another thread is justified and is not a consequence of a frivolous relationship to multithreading, then the handler code should usually be wrapped in </font></font><a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dispatch_async</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. At the same time, special attention should be paid to the fact that the external block does not capture objects that belong to a specific stream (for example, UIView, UIViewController or NSManagedObject) by strong references, as this can lead to the so-called </font></font><a href="https://developer.apple.com/library/ios/technotes/tn2109/_index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deallocation problem</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If the handler fails when the observed value changes, the observed attribute is most likely not a KVO compliant. How to make it as such is fully described in the </font></font><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOCompliance.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">KVO Compliance</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVODependentKeys.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Registering Dependent Keys</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> documentation sections </font><font style="vertical-align: inherit;">. It should be separately stated that even if you do not use a standard (synthesized) property setter for a property, but define a setter yourself, this property will remain KVO compliant.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even being aware of all the potential dangers of KVO, and neutralizing some of them, you should not uselessly use KVO in any case. </font><font style="vertical-align: inherit;">Abuse of any technology leads to a phenomenon called ‚Äú[Technology Name] hell‚Äù. </font><font style="vertical-align: inherit;">Although the connections between objects created with the help of KVO look very weak when they spin out of control, they can hit very painfully. </font><font style="vertical-align: inherit;">In our case, ‚ÄúKVO hell‚Äù can be expressed in unpredictable avalanche-like triggers of observation handlers leading to unexpected consequences and killing performance, or even in cyclic calls ending with a stack overflow.</font></font><br><br><ol><li> <a href="http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TIOBE Programming Community Index for November 2013</font></font></a> </li><li> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueCoding/Articles/KeyValueCoding.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Key-Value Coding Programming Guide</font></font></a> </li><li> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Key-Value Observing Programming Guide</font></font></a> </li><li> <a href="https://developer.apple.com/library/ios/documentation/cocoa/Conceptual/Blocks/Articles/00_Introduction.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Blocks Programming Topics</font></font></a> </li><li> <a href="https://developer.apple.com/library/mac/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Transitioning to ARC Release Notes</font></font></a> </li><li> <a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/DelegatesandDataSources/DelegatesandDataSources.html">Concepts in Objective-C Programming: Delegates and Data Sources</a> </li><li> <a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/ProgrammingWithObjectiveC/WorkingwithProtocols/WorkingwithProtocols.html">Programming with Objective-C: Working with Protocols</a> </li><li> <a href="https://developer.apple.com/library/mac/documentation/General/Conceptual/CocoaEncyclopedia/Target-Action/Target-Action.html">Concepts in Objective-C Programming: Target-Action</a> </li><li> <a href="http://stackoverflow.com/questions/8113268/how-to-cancel-nsblockoperation">stackoverflow: How to cancel NSBlockOperation</a> </li><li> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Notifications/Introduction/introNotifications.html">Notification Programming Topics</a> </li><li> <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Protocols/NSKeyValueObserving_Protocol/Reference/Reference.html">NSKeyValueObserving Protocol Reference</a> </li><li> <a href="https://developer.apple.com/library/ios/technotes/tn2239/_index.html">iOS Debugging Magic</a> </li><li> <a href="http://nshipster.com/key-value-observing/">NSHipster: Key-Value Observing</a> </li><li> <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> </li><li> <a href="https://github.com/mikeash/MAKVONotificationCenter">MAKVONotificationCenter</a> </li><li> <a href="http://www.mikeabdullah.net/weak-properties-kvo-compliance.html">Weak properties KVO compliance</a> </li><li> <a href="http://cocoadev.com/MethodSwizzling">Method Swizzling</a> </li><li> <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html">Grand Central Dispatch (GCD) Reference</a> </li><li> <a href="https://developer.apple.com/library/ios/technotes/tn2109/_index.html">Simple and Reliable Threading with NSOperation</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/202884/">https://habr.com/ru/post/202884/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202870/index.html">Automate subtitle uploading from * .mkv files</a></li>
<li><a href="../202874/index.html">Tiny Tron on JS (30 lines of code)</a></li>
<li><a href="../202876/index.html">Upgrading Nexus 4 to Android 4.4 on Linux</a></li>
<li><a href="../202878/index.html">What do bad security managers do?</a></li>
<li><a href="../202880/index.html">Git to help admin lokalkhost</a></li>
<li><a href="../202888/index.html">Asteroids javascript implementation</a></li>
<li><a href="../202890/index.html">PHP creator Rasmus Lerdorf - about anarchy and democracy in language development, PHP 5.6 and complaining programmers</a></li>
<li><a href="../202894/index.html">Galileo is the first Arduino-compatible microcomputer on the Intel platform. Now Available!</a></li>
<li><a href="../202896/index.html">Continuous Integration in Selectle</a></li>
<li><a href="../202898/index.html">Wireless communications "smart home". Part two, practical</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>