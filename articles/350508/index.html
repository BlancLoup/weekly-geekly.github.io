<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lessons to learn from the LLVM / Clang codebase</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="From the translator: in the article that I bring to your attention, the authors investigated the LLVM / Clang code base using the CppDepend code analy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lessons to learn from the LLVM / Clang codebase</h1><div class="post__text post__text-html js-mediator-article">  <i>From the translator: in the article that I bring to your attention, the authors investigated the LLVM / Clang code base using the CppDepend code analysis tool, which allows you to calculate various code metrics and analyze large projects in order to improve the quality of the code.</i> <br><br>  Time has proven that Clang is as mature a C and C ++ compiler as GCC and Microsoft‚Äôs compiler, but what makes it special is that it‚Äôs not just a compiler.  This is an infrastructure for creating tools.  Due to the fact that its architecture is based on the use of libraries, the reuse and integration of functionality into your project is made easier and more flexible. <br><br><img src="https://habrastorage.org/webt/xg/bh/uj/xgbhuj5ayarkll-pcq1shrt943m.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h3>  Clang structure </h3><br>  Like many other compilers, Clang consists of three phases: <br><br>  The frontend, which parses the source code, checks for errors, and builds a language-dependent abstract syntax tree (AST) representing the input code. <br>  Optimizer: its goal is to optimize the AST generated by the front-end. <br>  Backend: generates the final code executed by the machine, depending on the target machine. <br><br><img src="https://habrastorage.org/webt/8v/ru/hm/8vruhm71hrnjcrrdiyavqdjym7m.gif"><br><br><h3>  What is the difference between Clang and other compilers? </h3><br>  The biggest difference is that Clang is based on LLVM, and the main idea of ‚Äã‚ÄãLLVM is to use intermediate representation (IR), which is something like Java bytecode. <br><br>  LLVM IR is designed to support intermediate stages of analysis and conversion that are in the optimizing stage of the compiler.  It is designed taking into account many specific requirements, including support for ‚Äúlight‚Äù runtime optimizations, interprocedural / interfunctional optimizations, program analysis in general, aggressive structural transformations, etc.  The most important aspect, however, is that the intermediate representation itself is a first-class language with well-defined semantics. <br><br>  With this structure, we can reuse most of the compiler to create other compilers, for example, you can replace the frontend to support other languages. <br><br><img src="https://habrastorage.org/webt/vm/so/r9/vmsor9cei6wlwe_lptc_dv9itjs.gif"><br><br>  It is very interesting to climb inside this powerful toy and see how it is designed and implemented.  C ++ developers can learn a lot of good practices from this code base. <br><br>  Let's X-ray the source code using CppDepend and CQLinq to understand some of the developer‚Äôs decisions. <br><br><h3>  1. Modularity </h3><br><h4>  1.1.  Modularity and use of libraries </h4><br>  The main concept in the development of clang was the use of libraries.  The different parts of the frontend can be clearly divided into different libraries that can be shared for different purposes.  This approach encourages the use of good interfaces and makes it easier for new developers (since they only need to understand a small part of the big picture). <br><br>  DSM (Dependency Structure Matrix), a dependency structure matrix is ‚Äã‚Äãa compact way of representing dependencies between components.  A non-empty matrix cell contains a number.  This number expresses the bond strength represented by the cell.  Link strength can be expressed as the number of members / methods / fields / types and namespaces involved in the link. <br><br><img src="https://habrastorage.org/webt/no/na/gh/nonaghfcnnve6bdgzl9dfxa2qhy.png"><br><br>  This dependency graph shows us the libraries that clang uses directly. <br><br><img src="https://habrastorage.org/webt/x-/fa/zd/x-fazdn_5wrslqk5hwza7rjqeay.png"><br><br>  As we can see, there are three cyclic dependencies between the clangBasic / clangFrontEnd, clangBasic / clangDriver and clangBasic / clangLex libraries.  It is recommended to remove any circular dependencies between libraries so that the code is more readable and easier to maintain. <br><br>  Why does clangFrontend use the clangBasic library? <br><br><img src="https://habrastorage.org/webt/_j/4c/yu/_j4cyuufozwj3ihkfvb6ru7h6yw.png"><br><br>  Only one enum field causes cyclic dependencies, the code can be refactored, and the dependency can be easily eliminated. <br><br><h4>  1-2 Modularity using namespaces </h4><br>  In C ++, namespaces are used to give code modularity, and in LLVM / clang they are used for three main reasons: <br><br>  Many namespaces contain only enums, as shown in the following CQLinq query. <br><br><img src="https://habrastorage.org/webt/ok/nv/zu/oknvzuqdbqeg7i7sbarib_zj7ti.png"><br><br>  In a large project, it cannot be guaranteed that two different enumerations will not be named the same.  The problem was resolved in C ++ 11, using enumeration classes, which involve using enumeration values ‚Äã‚Äãalong with the enumeration name.  The code may be refactored in the near future using the C ++ 11 enumeration classes. <br><br>  Anonymous namespaces: Nameless namespaces that allow you to avoid creating global static variables.  The anonymous namespace you created will only be available in the file in which it was created.  Here is a list of all the anonymous namespaces used. <br><br><img src="https://habrastorage.org/webt/ax/3s/5d/ax3s5donm_c9gybrkfnaink9gpu.png"><br><br>  All non-anonymous namespaces: <br><br><img src="https://habrastorage.org/webt/_r/xj/st/_rxjstwnvsapeox878v8e1zx8vg.png"><br><br>  Namespaces are a good solution to make an application modular, LLVM / clang defines more than 500 namespaces to provide modularity to make code readable and maintainable. <br><br><h3>  2. Using paradigms </h3><br>  C ++ is not just an object-oriented language.  Bjarn Straustrup indicated that C ++ is a multi-paradigm language.  It supports many programming styles, or paradigms, and object orientation is just one of them.  Others are procedural programming and generic programming. <br><br><h4>  2.1.  Procedural programming </h4><br>  <b>2.1.1.</b>  <b>Global functions</b> <br><br>  Find all global functions defined in the LLVM / Clang source: <br><br><img src="https://habrastorage.org/webt/zn/t8/au/znt8auurij3_g6d1ckwybakutso.png"><br><br>  We can divide these functions into three categories: <br><br>  1 - Utilities: For example, conversion functions from one type to another. <br><br><img src="https://habrastorage.org/webt/aq/g6/ki/aqg6kiohjikvhcvnjajjzza2esw.png"><br><br>  2 - Operators: many operators are defined, as the result of CQLinq shows: <br><br><img src="https://habrastorage.org/webt/ln/uq/bf/lnuqbfc0f_xizcwqlqqojzey8pa.png"><br><br>  In the llvm / clang source code there are almost all overridden operators. <br><br>  3 - Functions related to compiler logic: A set of global functions that implement various compiler functions. <br><br>  Perhaps this type of function should be grouped into categories, like static class methods, or grouped into namespaces. <br><br><img src="https://habrastorage.org/webt/vm/ih/xs/vmihxsh6l0j_qulhisdgzv7yenw.png"><br><br>  <b>2.1.2.</b>  <b>Static global functions</b> <br><br>  It is best practice to declare global functions as static, except in those specific cases where you need to call them from another source file. <br><br><img src="https://habrastorage.org/webt/91/4i/ft/914iftkzz9i1ssurlsumcbj-_3c.png"><br><br>  Almost all global functions are declared as static. <br><br>  <b>2.1.3.</b>  <b>Global Functions - Static Candidates</b> <br><br>  Global, non-exported functions, not declared in an anonymous namespace, not used by any method outside the file where they were declared are good candidates for static refactoring. <br><br><img src="https://habrastorage.org/webt/0e/sy/cm/0esycm5mf2xnyntgkxuysis108a.png"><br><br>  As we can see, only a few functions can be refactored to static. <br><br><h4>  2.2.  Object Oriented Paradigm </h4><br>  <b>2.2.1.</b>  <b>Inheritance</b> <br><br>  In object-oriented programming (OOP), inheritance is a way to establish an ‚Äúis‚Äù relationship between objects.  It is often confused with the way in which existing code is reused, which is not a good practice, because inheriting to reuse an implementation leads to a strong correlation.  The ability of the code to reuse is achieved through the composition (composition is preferable to inheritance).  Let's look for all classes that have at least one base class: <br><br><img src="https://habrastorage.org/webt/dg/kg/ee/dgkgeebfmlsrhxgw4c0r-ro6iqa.png"><br><br>  It is best to use Metric View in this query. <br><br>  In Metric View, the codebase is represented as a treemap.  This is a method of displaying a tree data structure using nested rectangles.  The tree structure used in CppDepend is the usual code hierarchy: <br><br>  Projects contain namespaces. <br>  Namespaces contain types. <br>  Types contain methods and fields. <br><br>  Treemap is a useful way to present the results of CQLinq queries, blue rectangles represent the result, we can see the types associated with the query. <br><br><img src="https://habrastorage.org/webt/ac/xk/tg/acxktgtz8npmflg9ermckwstit0.png"><br><br>  As we can see, inheritance is widely used in the llvm / clang source code. <br><br>  Multiple Inheritance: Let's find classes inherited from more than one class. <br><br><img src="https://habrastorage.org/webt/mx/tz/fj/mxtzfjgqssx_soltncuwvrklhvw.png"><br><br>  Multiple inheritance is rarely used, less than 1% of classes are inherited from more than one class. <br><br>  <b>2.2.2.</b>  <b>Virtual methods</b> <br><br>  Let's find all the virtual methods defined in the source code: <br><br><img src="https://habrastorage.org/webt/bg/bm/v1/bgbmv1kii_n3lv8vqmfgixomwom.png"><br><br>  Many methods are virtual, some of them are pure virtual (pure virtual): <br><br><img src="https://habrastorage.org/webt/ha/2n/n_/ha2nn_gcuhk4j1wqojtkwtzz9-e.png"><br><br>  The OOP paradigm is widely used in the llvm / clang source code.  What about generic programming? <br><br><h4>  2.3.  Generalized programming </h4><br>  C ++ provides unique opportunities to express ideas of generic programming through patterns.  Patterns are a form of parametric polymorphism that allows you to express generalized algorithms and data structures.  The mechanism for instantiating C ++ templates ensures that when generalized algorithms and data structures are used, a fully optimized and specialized version will be created specifically for specific parameters, allowing the generalized algorithms to be as effective as their non-generic versions. <br><br>  <b>2.3.1.</b>  <b>Generic types</b> <br><br>  Let's find all the generic types defined in the source code: <br><br><img src="https://habrastorage.org/webt/qq/ly/v8/qqlyv8a13py2rbvojydd416agso.png"><br><br>  Many types are defined as generalized.  Let's find the generic methods: <br><br><img src="https://habrastorage.org/webt/tm/z-/ac/tmz-acfazkpkrdhifk25w6jwu3k.png"><br><br>  Less than 1% of generalized methods <br><br>  So, the source code llvm / clang uses three paradigms. <br><br><h3>  3. PODs define a data model. </h3><br>  In object-oriented programming, plain old data (POD) is a data structure that represents only a passive collection of values, without using object-oriented functions.  In computer science, they are also known as passive data structures. <br><br>  Let's look for the POD types in the source code. <br><br><img src="https://habrastorage.org/webt/ch/6f/8x/ch6f8xaeyke1qnzejmk25yq7-4y.png"><br><br>  More than 1,500 types are defined as POD types, many of which are used to define the compiler data model. <br><br><h3>  4. Design patterns of the gang of four </h3><br>  Design patterns are a software engineering concept that describes solutions to common problems in software design.  Gang of Four patterns are the most popular.  Let's find their use in the llvm / clang source code. <br><br><h4>  4.1.  Factory </h4><br>  List of factory methods defined in the source code: <br><br><img src="https://habrastorage.org/webt/xu/fe/ip/xufeip-6r0uwoqge1vr_5af9vy4.png"><br><br>  List of abstract factory methods: <br><br><img src="https://habrastorage.org/webt/k9/ky/ij/k9kyijn8jf5o5llivxkl1j5llmi.png"><br><br><h4>  4.2.  Observer </h4><br>  An observer pattern is a design pattern in which an object contains a list of observer objects, and automatically notifies them of any state changes, usually by calling one of their methods. <br><br>  There is only one observer in the source text: <br><br><img src="https://habrastorage.org/webt/cg/wz/xy/cgwzxyr3g5nwxhfutwdfh1ngdhu.png"><br><br><h4>  4.3.  Visitor </h4><br>  The visitor pattern is recommended when you need to go around the structure and perform specific actions in each node of the structure. <br><br>  In the llvm / clang source code, the visitor pattern is widely used: <br><br><img src="https://habrastorage.org/webt/k3/4g/5j/k34g5jbs3lrwdbeppq4wdfjhhg8.png"><br><br><h3>  5. Coupling and Connectivity (Coupling and Cohesion) </h3><br><h4>  5.1.  Clutch </h4><br>  A low degree of coupling is desirable, since changes in one part of the application will require fewer changes in the rest of the application.  In the long run, this can save a lot of time, effort, and money associated with modifying and adding new features to the application. <br><br>  A low degree of coupling can be achieved using abstract classes or using generic types and methods. <br><br>  Let's find all the abstract classes defined in the source code: <br><br><img src="https://habrastorage.org/webt/i8/xd/_f/i8xd_fyr1r13m468cqwb0-l9bhq.png"><br><br>  More than 280 types are declared as abstract.  However, a low degree of cohesion is also achieved through the use of generic types and generic methods. <br><br>  Connectivity <br><br>  The principle of single responsibility states that a class cannot have more than one reason for change.  Such classes are called connected.  A high LCOM value most often corresponds to poorly related classes.  There are several LCOM metrics.  LCOM takes a value in the range [0-1].  LCOM HS (HS for Henderson-Sellers) takes a value in the range [0-2].  LCOM HS value greater than 1 should be alarming.  LCOM metrics are counted as: <br><br>  LCOM = 1 - (sum (MF) / M * F) <br>  LCOM HS = (M - sum (MF) / F) (M-1) <br><br>  Where: <br><br>  M is the number of class methods (including static methods, constructors, getters / setters, methods for adding and deleting events). <br>  F is the number of non-static class fields. <br>  MF is the number of class methods that have access to a specific non-static field. <br>  Sum (MF) - the sum of the MF over all non-static fields of the class. <br><br>  The idea expressed by this formula can be formulated as follows: a class is connected if all methods use all non-static fields, that is, sum (MF) = M * F, and therefore LCOM = 0 and LCOMHS = 0. <br><br><img src="https://habrastorage.org/webt/vq/mn/6s/vqmn6si5zisvcczioqdwapjiezw.png"><br><br>  235 classes have been considered, perhaps some of them can be refactored to improve connectivity. <br><br><h3>  6. Immunity, purity and side effects </h3><br><h4>  6.1.  Immunable types </h4><br>  An object is said to be immutable if its state does not change from the moment it was created.  Therefore, a class is called immutable if its instances are immutable. <br><br>  There is one argument in favor of using immutable objects: it greatly simplifies competitive programming.  Think about why writing operations in multi-threaded programming is so complicated?  Because it is difficult to synchronize the access of threads to a resource (objects or other OS resources).  Why is it difficult to synchronize access?  Because it is difficult to guarantee that there will be no race between multiple streams.  What if there is no write access?  In other words, what if the state of the objects to which streams have access is invariable?  Then there is no need to synchronize. <br><br>  Another advantage of the immutable classes is that they never violate the Liskov substitution principle, here‚Äôs the definition of the Liskov principle from Wikipedia: <br><br>  "the <i>subclass should not create new mutators of the properties of the base class. If the base class does not provide methods for changing the properties defined in it, a subtype of this class should not create such methods. In other words, the immutable data of the base class should not be changeable in the subclass.</i> " <br><br>  Here is a list of immutable types in the source code: <br><br><img src="https://habrastorage.org/webt/ll/qa/fs/llqafsdl2d5lyrdcq9olpjkquho.png"><br><br><h4>  6.2.  Purity and side effects </h4><br>  The main advantage of immune types comes from the fact that they eliminate side effects.  I can‚Äôt say this better than Wes Dyer, and I‚Äôll quote him: <br><br>  ‚ÄúWe all know that using global variables is not a good idea.  This is due to the danger of side effects (global scope).  Many programmers who do not use global variables do not understand that the same principle applies to fields, properties, parameters, and variables on a more limited scale: do not change them without good reasons (...) ‚Äù <br><br>  One way to increase the reliability of a module is to get rid of side effects.  This makes compiling and integrating modules easier and more reliable.  If they do not have side effects, they always work in the same way, regardless of the environment.  This is called referential transparency. <br><br>  Write functions and methods without side effects - these will be pure functions that do not change the object - this will be better in the sense of the correctness of your program. <br><br>  Here is a list of all methods without side effects: <br><br><img src="https://habrastorage.org/webt/y6/vt/dv/y6vtdviimcxl_eft6bmos-ssbwy.png"><br><br>  More than 100,000 methods are clean. <br><br><h3>  7. Quality of implementation </h3><br><h4>  7.1.  Too big methods </h4><br>  Methods with many lines of code are difficult to maintain and understand.  Let's find methods, more than 60 lines. <br><br><img src="https://habrastorage.org/webt/b5/s4/5s/b5s45sagwmfhxksdqcbw0wqbfru.png"><br><br>  The source code llvm / clang contains more than 100,000 methods, and less than 2% of them can be considered too large. <br><br><h4>  7.2.  Methods with a large number of parameters </h4><br><img src="https://habrastorage.org/webt/co/ub/1b/coub1bbxgizf2shuj8nyos_wiio.png"><br><br>  Several methods have more than 8 parameters. <br><br><h4>  7.3.  Methods with multiple local variables </h4><br><img src="https://habrastorage.org/webt/15/wq/pl/15wqpldcxze6t9gyvksbmlr3vms.png"><br><br>  Less than 1% of methods have many local variables. <br><br><h4>  7.4.  Too complex methods </h4><br>  Many metrics exist to detect complex functions, calculate the number of lines of code, the number of parameters, the number of local variables. <br><br>  There are also interesting metrics for the detection of complex functions: <br><br>  Cyclomatic complexity is a popular metric of procedural programming, equal to the number of decisions taken in a procedure. <br><br>  Nested depth - a metric defined for the method that determines the maximum nesting depth of the scopes in the method body. <br><br>  The maximum nesting cycles. <br><br>  The maximum values ‚Äã‚Äãallowed for these metrics depend more on the choice of the development team; there are no generally accepted standards. <br><br>  Let's find methods that can be considered as complex. <br><br><img src="https://habrastorage.org/webt/rm/be/7a/rmbe7altch8zoswzqs00hz0c0qk.png"><br><br>  Only 1.5% of the methods are candidates to minimize complexity. <br><br><h4>  7.5.  Halstead Difficulty </h4><br>  Halstead complexity is a software metric introduced by Maurice Howard Halstead in 1977.  Halstead made the observation that the program metric should reflect the implementation of the algorithm in different languages, but regardless of the platform.  These metrics are calculated statically by code. <br><br>  Halstead introduced a variety of different metrics, consider for example one of them - TimeToImplement, which indicates the time required to program the method in seconds. <br><br><img src="https://habrastorage.org/webt/jq/wt/o3/jqwto3gri4lwxyerkxv3s4gsr1o.png"><br><br>  2690 methods require more than an hour for their implementation. <br><br><h3>  8. RTTI </h3><br>  RTTI is the system's ability to report a dynamic type of an object and provide type information at runtime (and not at compile time).  However, using RTTI is considered controversial in the C ++ community.  Many C ++ developers do not use this mechanism. <br><br>  And how does the llvm / clang development team relate to this? <br><br><img src="https://habrastorage.org/webt/0i/ou/24/0iou24gqm7fsiblggfs39xlggck.png"><br><br>  No method uses the dynamic_cast keyword.  The llvm / clang development team has chosen not to use the RTTI mechanism. <br><br><h3>  9. Exceptions </h3><br>  Exception support is another controversial feature of C ++.  Many well-known open source C ++ projects do not use it. <br><br>  Let's see if exceptions are thrown anywhere in the code. <br><br><img src="https://habrastorage.org/webt/zd/bp/qa/zdbpqauqvcee-8jhxamzd6f_zp8.png"><br><br>  Like RTTI, the exception mechanism is not used. <br><br><h3>  10. Some statistics </h3><br><h4>  10.1.  Most popular types </h4><br>  It is interesting to know which are the most used types in a project, since such types should be best designed, implemented and tested.  Any changes in them will affect the project as a whole. <br><br>  Find them using the TypesUsingMe metric: <br><br><img src="https://habrastorage.org/webt/mj/uz/hu/mjuzhu0pc_g5xkfgwmpidsahkik.png"><br><br>  There is another interesting metric for finding popular types: TypeRank. <br><br>  The TypeRank value is calculated by applying the Google PageRank algorithm on the type dependency graph.  A center <a href="https://ru.wikipedia.org/wiki/%25D0%2593%25D0%25BE%25D0%25BC%25D0%25BE%25D1%2582%25D0%25B5%25D1%2582%25D0%25B8%25D1%258F">homothety</a> of 0.15 is applied so that the average TypeRank is equal to one. <br><br>  Types with high TypeRank should be tested more carefully, because the bugs in them can be more catastrophic. <br><br>  Below are the results of all popular types according to the TypeRank metric: <br><br><img src="https://habrastorage.org/webt/83/ji/m0/83jim0lj3ym74xy74xlord6tuwa.png"><br><br><h4>  10.2.  Most popular methods </h4><br><img src="https://habrastorage.org/webt/41/vw/uu/41vwuu3axxsnaibgljabqkqfti0.png"><br><br><h4>  10.3.  Methods calling many other methods </h4><br>  It is interesting to know which methods cause many other methods; this can reveal design problems.  In some cases, refactoring is required to make them more readable and easy to maintain. <br><br><img src="https://habrastorage.org/webt/0s/um/n4/0sumn4rkptz6sb5rro2aoqvborc.png"><br><br><h3>  Results </h3><br>  LLVM / Clang is very well designed and implemented, and, as for any other project, it can be improved by some refactoring.  In this post we have revealed some minimal possible changes that can be made in the source code.  Do not be afraid to explore the source code and improve your knowledge of C ++. </div><p>Source: <a href="https://habr.com/ru/post/350508/">https://habr.com/ru/post/350508/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350496/index.html">CUBA platform in 2017: new features, new services, new plans</a></li>
<li><a href="../350498/index.html">Anime search bot</a></li>
<li><a href="../350500/index.html">Work with Anaconda on the example of searching for the correlation of cryptocurrency rates</a></li>
<li><a href="../350502/index.html">Rational prioritization of key operations</a></li>
<li><a href="../350504/index.html">Unit testing of react components withRouter (jest, enzyme)</a></li>
<li><a href="../350510/index.html">Collector task</a></li>
<li><a href="../350512/index.html">Using the KOMPAS-3D API ‚Üí Lesson 7 ‚Üí Getting to know the settings</a></li>
<li><a href="../350514/index.html">Two-tier ERP and SAP Business One: how it works</a></li>
<li><a href="../350516/index.html">Using the KOMPAS-3D API ‚Üí Lesson 8 ‚Üí More complex methods of writing to the title block</a></li>
<li><a href="../350520/index.html">Google, Qualcomm and cloud gaming services. Integration success?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>