<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Stan Drapkin. High-level cryptography hooks in .NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Stan Drapkin is a security and compliance expert with more than 16 years of experience working with the .NET Framework (since .NET 1.0-beta in 2001). ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Stan Drapkin. High-level cryptography hooks in .NET</h1><div class="post__text post__text-html js-mediator-article">  Stan Drapkin is a security and compliance expert with more than 16 years of experience working with the .NET Framework (since .NET 1.0-beta in 2001).  Unfortunately, he himself does not write articles in Russian, so we agreed with him to release a translation of <a href="https://dotnext-piter.ru/2018/spb/talks/6dlrku3cryugkuo4awiusu">his report with DotNext Piter</a> .  This report <b>took the first place</b> at the conference! <br><br>  Symmetric cryptography, asymmetric, hybrid, high-level, low-level, streaming, and modern elliptical cryptography.  Fifty-six minutes of video about cryptography, and much faster - in the form of text. <br><br><img src="https://habrastorage.org/webt/ye/8s/g0/ye8sg0kuwhgvtitnjxvwpehfnwc.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Under the cut - video, slides and translation.  Enjoy reading! <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ZqGyV7Jshww" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <a href="https://assets.ctfassets.net/9n3x4rtjlya6/60HsMjl9DOsMIeSKEiIwYW/9a3fe6eeabb58431d270c3fde3b616e5/Stan_Drapkin_-_Pitfalls_of_High-Level_Cryptography_in_.NET__1_.pdf">Slides</a> <br><br>  My name is Stan Drapkin, I am the technical director of a firm specializing in information security and regulatory compliance.  In addition, I am the author of several open source libraries that have been very well received by the community.  Who of you heard about <i>Inferno</i> ?  This library demonstrates the correct approach to cryptography in .NET, and <i>TinyORM</i> implements a micro-ORM for .NET.  In addition, I have written several books that may be relevant to the topic of today's article.  One of them, 2014 edition - ‚ÄúSecurity Driven .NET‚Äù, the other, 2017 - ‚ÄúApplication Security in .NET, Succinctly‚Äù. <br><br>  First we will talk about what I call the four stages of crypto enlightenment.  Then there will be two main topics, the first one will be about symmetric cryptography, the second about asymmetric and hybrid.  In the first part, we will compare high-level and low-level cryptography and take a look at the example of streaming cryptography.  In the second part, we will have many ‚Äúadventures‚Äù with RSA, after which we will get acquainted with modern elliptical cryptography. <br><br>  So, what do these stages of crypto enlightenment look like?  The first stage - ‚ÄúXOR is so cool, look, mom, how can I!‚Äù Surely many of you are familiar with this stage and know about the wonders of the XOR function.  But, I hope, the majority of this stage has outgrown and moved on to the next one, that is, learned how to perform encryption and decryption using AES (Advanced Encryption Standard), a well-known and highly appreciated algorithm.  Most developers who do not visit DotNext are at this stage.  But, since you follow DotNext and are familiar with the reports on the dangers of low-level APIs, you are most likely at the next stage - ‚ÄúI did everything wrong, you need to switch to higher-level APIs‚Äù.  Well, for the sake of completeness, I will also mention the last stage - the understanding that with the best solution to the problem, cryptography may not be necessary at all.  To reach this stage is the most difficult, and there are few people on it.  One example is Peter G. Neumann, who said: ‚ÄúIf you think that the solution to your problem lies in cryptography, then you don‚Äôt understand exactly what your problem is.‚Äù <br><br>  The fact that low-level cryptography is dangerous has already been discussed in many .NET reports.  You can refer to the report of Vladimir Kochetkov 2015, <a href="https://www.youtube.com/watch%3Fv%3DX1V6_OyQKLw%26list%3DPLtWrKx3nUGBd905TLsV5wMhAhKto0gyx_">"Pitfalls System.Security.Cryptography"</a> .  His main idea is that at each stage of working with low-level cryptographic APIs we, without knowing it, make many decisions, for many of which we simply do not have the relevant knowledge.  The main conclusion is that ideally, instead of low-level cryptography, you should use high-level.  This is a remarkable conclusion, but it leads us to another problem - do we know exactly how high-level cryptography should look like?  Let's talk a little about it. <br><br>  We define the attributes of a <i>non-</i> high-level cryptographic API.  For a start, such an API will not come across as native to .NET, rather it will look like a low-level shell.  Further, such an API will easily be used incorrectly, i.e.  not as it should.  In addition, it will force you to generate a lot of strange low-level things ‚Äî nonce, initialization vectors, and the like.  Such an API will force you to make unpleasant decisions, to which you may not be ready - to choose algorithms, padding modes, key sizes, nonce and so on.  He also will not have the right API for streams (streaming API) - we will talk about how the latter should look like. <br><br>  In contrast, what should the high-level cryptographic API look like?  I believe that it should first of all be intuitive and concise for both the reader of the code and the writer of the code.  Further, such an API should be easy to learn and use, and it should be extremely difficult to use in the wrong way.  It should also be powerful, that is, it should allow us to achieve our goal at the cost of a small effort, a small amount of code.  Finally, such an API should not have a long list of restrictions, warnings, special cases, in general - there should be a minimum of things to keep in mind when working with it, in other words - it should be characterized by a low level of interference (low-friction), just work without any reservations. <br><br>  Having dealt with the requirements for the high-level cryptographic API for .NET, how do we find it now?  You can try to just google, but that would be too primitive - we are professional developers, and this is not our method.  Therefore, we investigate this problem and try out various alternatives.  But for this, we first need to make for ourselves the correct idea of ‚Äã‚Äãwhat is authenticated encryption (Authenticated Encryption), and for this it is necessary to deal with the basic concepts.  They are the following: plaintext P (plaintext), which we translate into ciphertext C (ciphertext) of the same length using some secret key K (key).  As you can see, so far we are working with a very simple scheme.  In addition, we also have an authentication tag T and nonce N. An important parameter is NÃÖ, that is, reuse of nonce with one key.  As many of you probably know, it leads to a violation of the confidentiality of the text, which is obviously undesirable.  Another important concept is AD (Associated Data), i.e. associated data.  This is optional data that is authenticated but not involved in encryption and decryption. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2f9/41c/537/2f941c537ee2813920df009759b19e97.jpg"><br><br>  Having dealt with the basic concepts, take a look at the various options for cryptographic libraries for .NET.  Let's start with the analysis of <i>Libsodium.NET.</i>  How many of you know her?  As I see, some are familiar. <br><br><pre><code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre> <br>  This is C # code that is used to encrypt with <i>Libsodium.NET</i> .  At first glance, it is quite simple and concise: the first line generates nonce, which is then used in the second line, where the actual encryption takes place, and in the third, where the text is decrypted.  It seemed - what difficulties could there be?  To begin with, Libsodium.NET offers not one, but three different methods of symmetric encryption: <br><br>  Time <br><br><pre> <code class="cs hljs">nonce = SecretAeadAes.GenerateNonce(); c = SecretAeadAes.Encrypt(p, nonce, key, ad); d = SecretAeadAes.Decrypt(c, nonce, key, ad);</code> </pre><br>  Two <br><br><pre> <code class="cs hljs">nonce = SecretAead.GenerateNonce(); c = SecretAead.Encrypt(p, nonce, key, ad); d = SecretAead.Decrypt(c, nonce, key. ad);</code> </pre><br>  Three <br><br><pre> <code class="cs hljs">nonce = SecretBox.GenerateNonce(); c = SecretBox.Create(p, nonce, key); d = SecretBox.Open(c, nonce, key);</code> </pre><br>  Obviously, the question arises - which of them is better in your particular situation?  To answer it, it is necessary to climb inside these methods, which we will now do. <br><br>  The first method, <code>SecretAeadAes</code> , uses AES-GCM with 96-bit nonce.  It is important that he has a fairly long list of restrictions.  For example, when using it, you should not encrypt more than 550 gigabytes with one key, and there should not be more than 64 gigabytes in one message with a maximum of 2 <sup>32</sup> messages.  Moreover, the library does not warn about approaching these restrictions, you need to track them yourself, which creates an additional burden on you as a developer. <br><br>  The second method, <code>SecretAead</code> uses a different cipher suite, <code>ChaCha20/Poly1305</code> with a significantly smaller 64-bit nonce.  Such a small nonce makes collisions extremely likely, and this is the only way to use this method - with the exception of quite rare cases and provided that you are very well versed in the subject. <br><br>  Finally, the third method, <code>SecretBox</code> .  Here you need to immediately notice that the arguments for this API are missing associated data.  If you need authenticated encryption with AD, this method will not work for you.  The encryption algorithm used here is called <code>xSalsa20/Poly1305</code> , nonce is large enough - 192 bits.  Yet, the lack of AD is a significant limitation. <br><br>  When using <i>Libsodium.NET</i> some questions arise.  For example, what exactly should we do with the nonce generated by the first line of code in the examples above?  The library does not tell us anything about this, we have to figure it out on our own.  Most likely, we will manually add this nonce to the beginning or to the end of the ciphertext.  Further, we could get the impression that AD in the first two methods can be of any length.  But in fact, the library supports AD no longer than 16 bytes - after all, 16 bytes is enough for everyone, right?  Go ahead.  What happens with decryption errors?  In this library, it was decided to throw exceptions in these cases.  If the data integrity in your environment can be compromised, then you will have many exceptions that need to be handled.  What if your key size is not exactly 32 bytes?  The library does not tell us anything about it, these are your problems that do not interest it.  Another important topic is the reuse of byte arrays to reduce the load on the garbage collector in intensive scenarios.  For example, in the code we saw an array which was returned to us by a nonce generator.  I would like not to create a new buffer every time, but to reuse the existing one.  This is not possible in this library; an array of bytes will be re-generated each time. <br><br>  Using the scheme we have already seen, we will try to compare the various algorithms of <i>Libsodium.NET</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b3c/6e3/d3c/b3c6e3d3ce4ef29723e2ac691c3fd4d4.jpg"><br><br>  The first algorithm, AES-GCM, uses 96-bit nonce (the yellow column in the picture).  It is less than 128 bits, which creates some discomfort, but not too significant.  The next column is blue, this is the place occupied by the authentication tag, with AES-GCM it is 16 bytes or 128 bits.  The second blue number, in parentheses, means the amount of entropy, or randomness, contained in this tag - less than 128 bits.  How much less - in this algorithm depends on how much data is encrypted.  The more encrypted, the weaker the tag becomes.  Already this should give us doubts about this algorithm, which will only increase if we take a look at the white column.  It says that repetitions (collisions) of nonce-s will lead to falsification of all ciphertexts created by the same key.  If out of, say, 100 of your Ciphertexts created by the shared key in two, there is a nonce collision, this nonce will lead to an internal authentication key leak and allow the attacker to forge any other ciphertext created by this key.  This is a very significant limitation. <br><br>  Let's <i>move</i> on to the second method <i>Libsodium.NET</i> .  As I said before, here for nonce, too little space is used, only 64 bits.  The tag takes 128 bits, but contains only 106 bits of entropy or less, in other words, significantly below the security level of 128 bits, which in most cases they are trying to achieve.  As for forging, the situation here is somewhat better than in the case of AES-GCM.  The nonce collision leads to the falsification of ciphertexts, but only for those blocks in which the collisions occurred.  In the previous example, we would have been forged 2 ciphertext, not 100. <br><br>  Finally, in the case of the xSalsa / Poly algorithm, we have a very large nonce with a size of 192 bits, which makes collisions extremely unlikely.  The authentication method is the same as in the previous method, so the tag again takes 128 bits and has 106 bits of entropy or less. <br><br>  Let's compare all these numbers with the corresponding indicators of the <i>Inferno</i> library.  In it, nonce occupies a colossal space, 320 bits, which makes collisions almost impossible.  As for the tag, everything is simple with it: it takes exactly 128 bits and has exactly 128 bits of entropy, no less.  This is an example of a safe and secure approach. <br><br>  Before getting acquainted in more detail with <i>Libsodium.NET</i> , we need to understand its purpose - unfortunately, not everyone who uses this library is aware of it.  To do this, refer to its documentation, which states that <i>Libsodium.NET</i> is a C # wrapper for <i>libsodium</i> .  This is another open source project, the documentation of which says that it is a fork of <i>NaCl</i> with a compatible API.  Well, refer to the documentation of <i>NaCl</i> , another open source project.  In it, as a goal, <i>NaCl is</i> postulated to provide all the necessary operations for creating high-level cryptographic tools.  This is where the dog is buried: the task of <i>NaCl</i> and all its shells is to provide low-level elements, of which then someone else will be able to build high-level cryptographic APIs.  These shells themselves were not thought of as high-level libraries.  Hence the moral: if you need a high-level cryptographic API, you need to find a high-level library, and not use a low-level wrapper and pretend to work with a high-level one. <br><br>  Consider how encryption works in <i>Inferno</i> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/64f/367/fe7/64f367fe769bce5d8fa0482f8a301648.jpg"><br><br>  Here is a sample code in which, as in the case of <i>Libsodium</i> , each encryption and decryption takes only one line.  Key, text, and optional associated data are used as arguments.  It should be noted that there are no non-s, there is no need to make any decisions, in case of a decryption error, it simply returns null, without throwing exceptions.  Since the creation of exceptions significantly increases the load on the garbage collector, their absence is very important for scenarios with processing large data streams.  I hope I managed to convince you that this approach is optimal. <br><br>  Out of interest, let's try to encrypt a string.  This should be the simplest scenario that everyone can implement.  Suppose that we have only two different string values: "LEFT" and "RIGHT". <br><br><img src="https://habrastorage.org/getpro/habr/post_images/88b/522/92b/88b52292b7ce52dc2a90302cbbbe1f36.jpg"><br><br>  In the picture you see the encryption of these lines using <i>Inferno</i> (although for this example it does not matter which library is used).  We encrypt two strings with one key and get two ciphertext, <code>c1</code> and <code>c2</code> .  Is everything correct in this code?  Is he ready for production?  Someone may say that a problem is possible in a short key, but it is far from the main one, so we will assume that the key is used the same, and it is of sufficient length.  I mean something else: with the usual cryptographic approaches, <code>c1</code> in our example will be shorter than <code>c2</code> .  This is called length leaking ‚Äî in many cases, <code>c2</code> will be one byte longer than <code>c1</code> .  This may allow an attacker to understand exactly which string is represented by the given ciphertext, ‚ÄúLEFT‚Äù or ‚ÄúRIGHT‚Äù.  The easiest way to solve this problem is to make both strings have the same length ‚Äî for example, add the character to the end of the string ‚ÄúLEFT‚Äù. <br><br>  At first glance, length leaking is perceived as a somewhat contrived problem that cannot be encountered in real applications.  But in January 2018, Wired magazine published an article with a study by the Israeli Checkmarx company, under the headline "The lack of encryption in Tinder allows outsiders to track when you navigate the screen."  I will briefly retell the content, but first a rough description of the Tinder functionality.  Tinder is an application that receives a stream with photos, and then the user navigates the screen right or left, depending on whether he likes the photo or not.  The researchers found that, although the commands themselves were correctly encrypted using TLS and HTTPS, the command data for the right hand held a different number of bytes than the data for the left.  This is, of course, a vulnerability, but in itself it is not very significant.  More significant for Tinder was the fact that they themselves sent the streams with photos via regular HTTP, without any encryption.  So the attacker could get access not only to the reactions of users in the photo, but also to the photos themselves.  So, as you can see, length leaking is a very real problem. <br><br>  Now let's try to encrypt the file.  Immediately I must say that in <i>Libsodium.NET</i> file encryption or, more broadly, stream encryption is not implemented by default, it has to be done manually there - which, believe me, is very difficult to do correctly.  <i>Inferno</i> does much better with this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f0/446/955/5f0446955f52e679e6dbeaacee2389b4.jpg"><br><br>  Above, you see an example taken with little or no change from MSDN.  It is very simple, here we see one stream for the source file and another for the destination file, as well as a crypto stream that converts the first to the second.  In this code, <i>Inferno is</i> used only in one line - in the one where the conversion occurs.  So, we have a simple and at the same time fully working and proven solution for encrypting a stream. <br><br>  It should be remembered that when encrypting with the same key, we have a limit on the number of messages.  They also exist in <i>Inferno</i> , and in this library they are clearly written on the screen.  But at the same time in <i>Inferno</i> they are so large that in practice you will never reach them.  In <i>Libsodium.NET, the</i> restrictions are different for different algorithms, but in all cases they are low enough to be likely to exceed them.  So it is necessary to check whether they will be achieved in each individual scenario. <br><br>  We should also talk about authentication of associated data, since this is a topic that is not often covered.  ADs can be ‚Äúweak‚Äù: this means that they are authenticated, but they don‚Äôt participate in the encryption and decryption process.  On the contrary, "strong" AD change this process itself.  Most of the AD libraries I know are weak, while <i>Inferno</i> uses the second approach, where AD is used in the encryption / decryption process itself ... <br><br>  It should also dwell on what level of security high-level cryptography should strive for.  In short, my answer is: 256-bit encryption with a 128-bit authentication tag.  Why is needed so big key?  There are many reasons for this, each of which is significant in itself, but now I would like you to remember one thing: we need to protect ourselves from possible bias (bias) when generating cryptographic keys.  Let me explain what is meant by bias.  For a random-bit generator with no bias, for each bit, the probabilities of taking the value 0 or 1 are equal.  But suppose that our bit generator will take the value 1 with a probability of 56%, rather than 50%.  At first glance, this bias is small, but in fact it is significant: 25%.  Now let's try to calculate how much entropy we will get when generating a certain number of bits by our generator. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3eb/f2e/df8/3ebf2edf8c049579b2e4218f9dff16b8.jpg"><br><br>  In the picture you see the formula by which this calculation will be made.  It is important that there are only two variables in it: bias, which we have already spoken about (bias), and the number of bits created by the generator.  We assume that bias is equal to 25% - this is quite an extreme case, in practice you most likely will not work in systems with such a distorted random number generator.  Anyway, with a 25% bias and a 128-bit key, we get only 53 bits of entropy.  Firstly, it is substantially less than 128 bits, which are usually expected from a random number generator, and secondly, with modern technologies such a key can simply be brutalized.  But if instead of a 128-bit key we use 256-bit, then we get 106 bits of entropy.  This is already quite good, although less than the expected 256. With modern technology, it is almost impossible to crack such a key. <br><br>  At the end of the first part of the report I will summarize the interim results.  I recommend everyone use a well-written cryptographic API.  Find the one that suits you, or send a petition to Microsoft to write it to you.  In addition, when choosing an API, you should pay attention to the presence of support for working with threads.  For reasons already explained, the minimum key length should be 256 bits.  Finally, it should be borne in mind that high-level cryptography, like any other, is not perfect.  Leaks can occur, and in most scenarios, their capabilities need to be remembered. <br><br>  Let's talk now about asymmetric, or hybrid cryptography.  I'll put a trick question: can you use RSA in .NET?  Do not rush to respond in the affirmative, as many do - let's first check your knowledge in this area.  The following slides will be specifically designed for people already familiar with this topic.  But first, let us turn to Wikipedia, and recall what exactly RSA is - in case someone has forgotten or has not used this algorithm for a long time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fec/e71/6ba/fece716ba7a00668b4d955c37745e744.png"><br><br>  Suppose there is a certain Alice, who with the help of a random number generator creates a pair of keys that includes one private and one public.  Next, there is some Bob who wants to encrypt a message for Alice: ‚ÄúHello, Alice!‚Äù With her public key, she generates a ciphertext, which she then sends to her.  She decrypts this ciphertext with the private part of her key. <br><br>  Let's try to reproduce this scenario in practice. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/35d/021/627/35d021627d87f316a65b87bc4662aa05.jpg"><br><br>  As you can see above, we create an instance of RSA and encrypt some text.  Immediately note that .NET makes us choose padding mode.  There are five of them, all with incomprehensible names.  If we try them all in turn, we find out that the last three simply throw an exception and do not work.  We use one of the two remaining - <code>OaepSHA1</code> .  Here the key will be 1 kilobits in size, which is too small for RSA, it is almost a cracked key.  Therefore, we will have to set the key size manually.  From the documentation, we learn that there is a special property <code>.KeySize</code> , which gets or sets the key size. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e0e/e77/a12/e0ee77a12bcd866142463ee8440c9b28.jpg"><br><br>  At first glance, this is exactly what we need, so we write: <code>rsa.KeySize = 3072</code> .  But if, guided by a vague suspicion, we then check what the key size is now equal to, then we find out that it still takes 1 kilobit.  It does not matter, we will check this parameter using the <code>WriteLine(rsa.KeySize)</code> method, or <code>rsa.ExportParameters(false).Modulus.Length * 8</code> - in the latter case, the public RSA key component is exported, this requires the argument ‚Äúfalse‚Äù.  The modulus of this key is an array, which we multiply by 8 and get the size in bits - which again will be 1 kilobit.  As you can see, this algorithm is too early to send to production. <br><br>  Let's not spend time figuring out why this API does not work, instead try another implementation of RSA provided by Microsoft in .NET 4.6, that is, completely new.  It is called <i>RSACng</i> , and <i>Cng</i> stands for Cryptography of the next generation (‚Äúthe next generation of cryptography‚Äù).  Great, who doesn't want to work with the next generation tools?  Surely here we will find the magic solution to all our problems. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7ed/1af/3fb/7ed1af3fbcd93422ff6648e2af791264.jpg"><br><br>  We request an instance of RSACng, re-set the key size to 3 kilobits, re-check the key size via <code>WriteLine(rsa.KeySize)</code> - and again find out that the key size is still equal to one kilobit.  In addition, if we request the type of the object that generated the key - as we remember, we requested an instance of RSACng - then we find out that it is RSACryptoServiceProvider.  I just want to share here my personal feeling of despair, and yell: ‚ÄúFor what, Microsoft ?!‚Äù. <br><br>  After long torments and torments, we find out that you really need to use a designer, not a factory. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c20/5e7/be1/c205e7be1603914e310bfb703f25e157.jpg"><br><br>  Here the default key size value is 2048 bits, which is already significantly better.  What is even better - here we manage to finally set the key size to 3 kilobits.  As they say, achievement unlocked. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let me remind you that all our efforts so far boiled down to creating RSA, we haven‚Äôt even begun to encrypt. There are still questions that we need to answer in advance. For starters, to what degree can you rely on default key sizes? The implementation of the RSA factory can be redefined to </font></font><code>machine.config</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, therefore, it can change without your knowledge (for example, it can be changed by the system administrator). This means that the default key size can also change. Thus, you should never trust the default values, the key size should always be set independently. Further, how good are the default RSA key sizes? In .NET, there are two RSA implementations, one based on one </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and the other based on</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. In the first one, the default size is 1 kilobit, in the second two. Out of interest, let's compare these values ‚Äã‚Äãwith the Bitcoins (BCN) available on the network. I apologize in advance for raising the sore subject, but we will not discuss Bitcoin or cryptocurrency, we will only discuss the network itself. She has a published hashrate, which is growing every month and today is 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hashes per second. This is equivalent to 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> hashes per year. Suppose, for simplicity, that the hash is equivalent to the underlying operation ‚Äî although this is not quite true, it is more complex. If you read cryptography books written by real professionals, not people like me, then you know that 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">70</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> operations (that is, one minute BCN) are enough to crack the 1-kilobyte RSA key, and 2 </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">90</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(one year BCN) - to crack the 2-kilobit key. Both values ‚Äã‚Äãshould cause our concern - this is what can be achieved with existing technologies. That is why I strongly recommend that you always set the key size yourself, and make it at least 3 kilobits in size, and if performance allows you, then 4. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In .NET, it is not so easy to figure out how to export public and private keys. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/4ea/836/078/4ea8360788f3ffdbb6a07dfe9c0587e0.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the top of the slide, you see two instances of the RSA key, the first from </font></font><code>RSACryptoServiceProvider</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, the second from</font></font><code>RSACng</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, each of 4 kilobits. Below is the code by which the public and private key is extracted from both instances. Here you should pay attention to the fact that both APIs are quite different from each other - different code, different methods, different parameters. Further, if we compare the size of the public keys of the first and second copies, we will see that they are comparable, approximately half a kilobyte each. But the private key of the new RSA implementation is much smaller than the old one. It is necessary to keep in mind and observe uniformity, not to interfere with these two APIs with each other. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Everything that we have done with RSA so far has come down to attempts to get a working copy; Now we will try to encrypt something. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c88/fb5/c3c/c88fb5c3ca4ee8a62b9b0bd2595291cf.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Create an array of bytes that will be our plaintext (</font></font><code>data</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and then encrypt it using one of those add-on modes that did not throw an exception. But this time we will have an exception. This is the exception of an invalid parameter; but what parameter are we talking about? I have no idea - and Microsoft, most likely, too. If we try to run the same method with other add-on modes, then in each case we get the same exception. So it's not about add-on mode. So the problem is in the source code itself. It‚Äôs hard to say what‚Äôs wrong with him, so we‚Äôll try to cut it in half, just in case. This time the encryption is successful. We remain at a loss.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps the whole point is that we used the SHA-1 supplement? SHA-1, as we know, is no longer a cryptographically strong function, so our auditors and the compliance department insist that we get rid of it. Replace </font></font><code>OaepSHA1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on </font></font><code>OaepSHA256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, at least it will calm auditors. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/29e/7ed/275/29e7ed275ae1eb8deea59683289b5b6b.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But when trying to encrypt, we again get the exception of the wrong parameter. This whole situation is caused by the fact that the limit on the size of the text that can be transferred to a cryptographic function depends not only on the mode of addition, but also on the size of the key. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let us try to find out exactly how that magic formula looks like, which determines the maximum amount of encrypted data. It must be in the method.</font></font><code>int GetMaxDataSizeForEnc(RSAEncryptionPadding pad)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">which calculates this volume, having received an addition mode on an input. The main disadvantage of this method is that it does not exist, I invented it. I'm trying to convey the idea that even the most basic information needed by the developer for the correct use of RSA is not available to us. Thank you, Microsoft.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will give reasons why RSA should be avoided, even for a signature. As I hope, I managed to show, the API for RSA in .NET is extremely unsatisfactory. You are forced to make many decisions regarding the mode of addition, the size of the data and the like, which is undesirable. Further, for a 128-bit security level, you will need at least a very cumbersome 4-kilobit key. It will give you a kilobyte private key, a half-kilobyte public key, and a half-kilobyte signature. For many scenarios such values ‚Äã‚Äãmay not be desirable. And if you try to achieve a 256-bit security level, you will need a huge key at all - 15360 bits. In RSA, using such a key is almost impossible. On my laptop one such key is generated one and a half minutes.In addition to this, RSA at the fundamental level, as an algorithm, very slowly implements a signature, regardless of implementation. Why is signature speed important to us? If you use TLS with RSA certificates, then the signature is performed on the server. And we, as developers, are most concerned with exactly what happens on the server, we are responsible for it, its bandwidth is important to us. Summarizing, I want to once again recommend not to use RSA.I want to once again recommend not to use RSA.I want to once again recommend not to use RSA.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, what to replace the RSA? I would like to introduce you to modern elliptical cryptographic primitives. First of all, you should keep in mind the ECDSA (Digital Signature Algorithm) algorithm, which can be used instead of RSA for signatures. In this and the following abbreviations, EC is a common prefix, which stands for Elliptic-Curve (‚Äúelliptic‚Äù). Under the link securitydriven.net/inferno/#DSA Signatures you can find an example of ECDSA code, which, by the way, is native to .NET. Another important algorithm is ECIES (Integrated Encryption Scheme, "elliptical integrated encryption scheme"). This algorithm can perform hybrid encryption instead of RSA, that is, where you generate a symmetric key, encrypt the data with it, and then encrypt the key itself.Sample code is available at the securitydriven.net/inferno/#ECIES example link. Finally, another very important algorithm is ECDH (Diffie-Hellman key exchange, ‚ÄúDiffie-Hellman key exchange‚Äù). It allows you to create keys for symmetric encryption between two parties with known public keys. In some situations and ways of using it, it allows to achieve direct secrecy (</font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">forward secrecy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font><font style="vertical-align: inherit;">Sample code is available </font></font><a href="http://securitydriven.net/inferno/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">via the</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> link </font><a href="http://securitydriven.net/inferno/"><font style="vertical-align: inherit;">securitydriven.net/inferno/#DHM</font></a><font style="vertical-align: inherit;"> Key Exchange.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's sum up the conversation about asymmetric encryption. You should always use high-level APIs that do not force you to make decisions for which you are not ready. I would also recommend to stop using RSA. Of course, this is easier said than done, since we are all working with large applications that have already been created, which can be completely refactored. In this case, at least you need to learn how to use RSA correctly. Next, I advise you to get acquainted with modern elliptical cryptographic algorithms (ECDSA, ECDH, ECIES). Finally, it is important that high-level cryptography does not magically solve all the problems, so you need to remember the goals you are pursuing. I will quote from StackOverflow, with which I fully agree: ‚ÄúCryptography alone does not solve problems.Symmetric encryption only turns the issue of data privacy into a key management problem. ‚Äù</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will say a few words about resources that may be useful to you. There is a relatively acceptable high-level </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">securityDriven.Inferno</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">with good documentation. There is an excellent book ‚ÄúSerious Cryptography‚Äù by Jean-Philippe Aumasson (Serious Cryptography). It provides an overview of the current state of cryptography, taking into account the latest innovations. In addition, I have written the already mentioned book Application Security in .NET, Succinctly, which is in the public domain. It has even more information about security traps in .NET. Finally, Slideshare has an excellent presentation by Vladimir Kochetkov, which is somewhat simplistic, but very soundly, sets out the basics of the theory of application security and explains various sources of hazards.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a conclusion, let's see some additional examples that I have prepared. At the very beginning, I spoke about the fourth stage of crypto-enlightenment, in which comes the realization that the best solution may not need cryptography at all. Let's look at an example of such a solution. Take a look at the classic .NET - CSRF (Cross-Site Request Forgery, ‚Äúcross-site request forgery‚Äù) mechanism designed to protect against a class of attacks, including cross-site request forgery. In this model, we have a user agent - usually a browser. He is trying to establish a connection with the server by sending a GET request. In response, the server sends a CSRF token, which is hidden in the HTML field ‚Äúhidden‚Äù. In addition, the same token is attached to the response as a cookie, as a header.The user processes some form and performs POST, which is returned to the server with both tokens. The server checks, firstly, whether both tokens are sent, and, secondly, whether they are. It is this identity comparison that allows the server to protect itself against an intruder. This is a classic mechanism built into ASP.NET and ASP.NET Core. Mikhail Shcherbakov made an excellent report in which the work of the CSRF was examined in detail.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem with this approach is that CSRF token generation uses encryption. The difficulty is that encryption itself is a complex and resource-intensive operation, it loads the processor, requires memory, increases latency. All this is undesirable. In addition, the injection of a token is a cumbersome, confusing and inconvenient process. In many cases ‚Äî for example, using AJAX, asynchronous calls ‚Äî its implementation lies with you as the developer. Those who did it, know that this occupation is extremely unpleasant. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a22/806/cae/a22806caea546a62b7a14d2af7583d48.jpg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same or comparable crypto can be created without the use of encryption, how </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> shown on the slide. I understand that the text here is quite complicated, so I am ready to discuss it in more detail in the discussion area. I have it all, thank you very much.</font></font><br><br><blockquote>  .       DotNext.      DotNext 2018 Moscow ‚Äî   22-23  2018  - ¬´  ¬ª. <br><br> <b>  </b> .  ,  ,    .          !     <a href="https://dotnext-moscow.ru/registration/">  </a> . <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/428121/">https://habr.com/ru/post/428121/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428111/index.html">Arithmetic of arbitrary precision in Erlang</a></li>
<li><a href="../428113/index.html">On the question of Bezier curves, speed Arduino and one interesting site, or how I spent the weekend</a></li>
<li><a href="../428115/index.html">Web development for ecommerce: 5 technology trends for 2019</a></li>
<li><a href="../428117/index.html">Google's free tensor processors in the cloud laboratory</a></li>
<li><a href="../428119/index.html">Class-fields-proposal or What went wrong on the tc39 committer</a></li>
<li><a href="../428123/index.html">Security Week 41: Good News</a></li>
<li><a href="../428125/index.html">Who are the product analysts and why are they needed in the team?</a></li>
<li><a href="../428127/index.html">Nginx cache: all new - well forgotten old</a></li>
<li><a href="../428129/index.html">Simple fuzzy logic blinded "from what it was" for a gas turbine engine</a></li>
<li><a href="../428131/index.html">The whole truth about the RTOS. Article # 17. Event flag groups: introduction and basic services</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>