<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Injection MSIL code into a third-party assembly using Mono.Cecil. Implementing AOP principles in NET</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 In this article, I will discuss how you can add your code to existing .NET assemblies and how it relates to aspect-oriented programming...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Injection MSIL code into a third-party assembly using Mono.Cecil. Implementing AOP principles in NET</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  In this article, I will discuss how you can add your code to existing .NET assemblies and how it relates to aspect-oriented programming.  The article will be accompanied by working examples, as I believe that the code is the best way to convey the idea. <br><br>  Many .NET developers know that you can use Reflection to access objects of someone else‚Äôs assembly.  Using the types from System.Reflection, we can access many .NET objects of the assembly, view their metadata, and even use those objects that are restricted (for example, private methods of another class).  But using Reflection has its limitations and the main reason for this is that the data you are working with through Reflection is still considered code.  Thus, for example, you can get a CodeAccessSecurity exception if the assembly to which you are trying to apply Reflection prohibits it.  For the same reason, Reflection is rather slow.  But the most important thing for this article is that standard Reflection does not allow changing existing assemblies, only generate and save new ones. <br><br><h4>  Mono.Cecil </h4><br>  A qualitatively different approach is offered by the free open source library Mono.Cecil.  The main difference between the Mono.Cecil approach and the Reflection approach is that this library works with the .NET assembly as a stream of bytes.  When loading the assembly, Mono.Cecil parses the PE header, CLR header, MSIL code of classes and methods, etc.  working directly with the stream of bytes representing the assembly.  Thus, with the help of this library, you can arbitrarily (within the limits of the stipulated) modify the existing assembly. <br><a name="habracut"></a><br>  Download Mono.Cecil <a href="http://www.go-mono.com/mono-downloads/download.html">here</a> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Immediately, I note that modifying a third-party assembly signed with a strong name will result in a reset of the signature, with all the ensuing consequences.  After modification, the assembly can be re-signed (with the same key, if you have it, or with another - if, for example, you need to put the assembly in the GAC). <br><br><h4>  Small example </h4><br>  Immediately consider an example of using the capabilities of Mono.Cecil.  Suppose we have a third-party build of a console application without source code, which has the type Program.  We do not have access to the source code, but we want this application to display each message when calling each method, some message to the console.  To do this, we write our own console application.  As an argument at startup, we will pass the path to the target application: <br><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Mono.Cecil; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Mono.Cecil.Cil; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Program { static <span class="hljs-type"><span class="hljs-type">void</span></span> Main(string[] args) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Length == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; string assemblyPath = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; //     Mono.Cecil var assembly = AssemblyDefinition.ReadAssembly(assemblyPath); //   Console.WriteLine,    Reflection var writeLineMethod = typeof(Console).GetMethod("WriteLine", <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>[] { typeof(string) }); //    ,  Reflection,    Mono.Cecil var writeLineRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(writeLineMethod); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var typeDef <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Types</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> typeDef.Methods) { //       //     "Inject!" <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.Body.Instructions.<span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldstr, "Inject!")); //   Console.WriteLine,      -     "Injected". <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.Body.Instructions.<span class="hljs-keyword"><span class="hljs-keyword">Insert</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>, writeLineRef)); } } assembly.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(assemblyPath); } }</code> </pre> <br>  When passing the path to a third-party assembly to our console application, it will add an IL code to the beginning of each method that displays the message ‚ÄúInject!‚Äù To the console, and then saves the modified assembly.  When you run the modified assembly, each method will write in the console "Inject!". <br><br>  Let us dwell on the above code.  NET is known to support many programming languages.  This is achieved due to the fact that any code in any programming language is compiled into CIL - Common Intermediate Language - intermediate language.  Why intermediate?  Because after, the CIL code is converted to instructions of the corresponding processor.  Thus, the code in any languages ‚Äã‚Äãis compiled into approximately the same CIL code, due to which you can use, for example, an assembly on VB in your C # project. <br><br>  Thus, each assembly, conventionally speaking, is a set of metadata (which, for example, Reflection uses), and a set of instructions in CIL. <br><br>  I will not elaborate on the description of CIL, since this is not the topic of this article.  I will confine myself only to what will be important for further, namely, some features of the CIL instructions.  Information about the presentation of metadata and other instructions you can always find on the Internet. <br><br>  To begin, consider the part of the code from the example above: <br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Body</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Instructions</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Insert</span></span>(0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Instruction</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Create</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">OpCodes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Ldstr</span></span>, "<span class="hljs-selector-tag"><span class="hljs-selector-tag">Inject</span></span>!")); <span class="hljs-selector-tag"><span class="hljs-selector-tag">method</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Body</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Instructions</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Insert</span></span>(1, <span class="hljs-selector-tag"><span class="hljs-selector-tag">Instruction</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Create</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">OpCodes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Call</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">writeLineRef</span></span>));</code> </pre><br>  In this code, we got access to a set of CIL instructions of some method and add our own.  The CIL instruction set can be found here:.  When working directly with CIL, the stack is important.  We can put some data on the stack and retrieve it from there (according to how the stack works).  In the example above, using the Ldstr instruction, we put the string ‚ÄúInject!‚Äù On the stack.  Next, we call System.Console.WriteLine.  Any method call calls the stack to get the necessary arguments.  In this case, System.Console.WriteLine, we need an argument of type string, which we loaded onto the stack.  The call instruction loads the arguments from the end, so you need to load the argument values ‚Äã‚Äãonto the stack in the usual way.  Thus, this instruction will transfer control to the System.Console.WriteLine method with the string parameter equal to ‚ÄúInject!‚Äù.  This instruction set is equivalent to: <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Console.WriteLine("Injected!");</code> </pre> <br><br>  Since Mono.Cecil perceives the assembly as a set of instructions (bytes), we can change its contents without any restrictions.  After adding the CIL code, we save it (as a set of bytes) and get the modified assembly. <br><br><h4>  Real application of code generation for implementation of an aspect-oriented approach </h4><br><br>  Consider applying the above approach to your own builds.  Very often we want to execute some code when entering or exiting a method, and to have access to some data describing the method or its context.  The simplest example is logger.  If we want to record in the log entry and exit of each method, then writing uniform code at the beginning and end of each method can be very tedious.  Also, in my opinion, this somewhat pollutes the code.  In addition, we cannot access the method parameters on the stack automatically, and if we want to also record the state of the parameters at the input, we will have to do it manually.  The second known problem is the implementation of INotifyPropertyChanged, which has to be assigned to each property manually. <br><br>  Consider a different approach.  To test it, create a new console application.  Add a class: <br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">AttributeUsage(AttributeTargets.Method)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MethodInterceptionAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">Attribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">System.Reflection.MethodBase method, Dictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; parameters</span></span></span><span class="hljs-function">)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnExit</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } }</code> </pre><br>  The user can inherit from this class, override the OnEnter method, and apply the inherited attribute to any method.  Our goal is to realize the following possibility: when entering a method marked with an attribute of type MethodInterceptionAttribute, call OnEnter, where to send a reference to the method and parameter set of this method in the form of &lt;parameter_name: value&gt;. <br><br>  For experiments we will create two console applications.  The first will contain the attribute definition and all the methods needed to inject code into third-party applications.  The second application will be a test.  We first consider the short code of the test application: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { MethodToChange(<span class="hljs-string"><span class="hljs-string">"Test"</span></span>); } [TestMethodInterception()] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodToChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { Console.ReadLine(); } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TestMethodInterceptionAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">MethodInterceptionAttribute</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnEnter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">System.Reflection.MethodBase method, Dictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; parameters</span></span></span><span class="hljs-function">)</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering method "</span></span> + method.Name + <span class="hljs-string"><span class="hljs-string">"..."</span></span> + Environment.NewLine); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> paramName <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> parameters.Keys) { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Parameter "</span></span> + paramName + <span class="hljs-string"><span class="hljs-string">" has value "</span></span> + parameters[paramName] + Environment.NewLine); } } }</code> </pre><br>  This is a simple console application that calls the MethodToChange method with the text parameter equal to Test.  This method is marked with the TestMethodInterceptionAttribute attribute inherited from MethodInterceptionAttribute.  OnEnter is overridden to display information about any methods marked with this attribute to the console.  Without pre-processing, this application will launch Console.ReadLine when it is started and exit. <br><br>  Let's continue consideration of the main application (also console).  To demonstrate the example MSIL code and to assist in further development, we will write the following auxiliary method: <br><br><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">void</span></span> DumpAssembly(string <span class="hljs-type"><span class="hljs-type">path</span></span>, string methodName) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.IO.File.AppendAllText("dump.txt", "Dump started... " + Environment.NewLine); var assembly = AssemblyDefinition.ReadAssembly(<span class="hljs-type"><span class="hljs-type">path</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var typeDef <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Types</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> typeDef.Methods) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(methodName) || <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.Name == methodName) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.IO.File.AppendAllText("dump.txt", "Method: " + <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.ToString()); <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.IO.File.AppendAllText("dump.txt", Environment.NewLine); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var instruction <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.Body.Instructions) { <span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.IO.File.AppendAllText("dump.txt", instruction.ToString() + Environment.NewLine); } } } } }</code> </pre><br>  This method reads the existing MSIL code from any assembly method (or all) and writes it to the dump.txt file.  How can this be useful?  Suppose we know what specific code we want to add to a third-party build, but we don‚Äôt want to write all MSIL code from scratch.  Then we will write this code in C # to some of our methods and make it a dump.  After that, it will be much easier to write MSIL using Mono.Cecil, already having a ready-made example of how it will look (of course, other, more convenient methods can be used to view the MSIL code of assemblies). <br><br>  Consider what we want to get at the beginning of each method (in the form of C #): <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> currentMethod = System.Reflection.MethodBase.GetCurrentMethod(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> attribute = (MethodInterceptionAttribute)Attribute.GetCustomAttribute(currentMethod, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodInterceptionAttribute)); Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; parameters = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); <span class="hljs-comment"><span class="hljs-comment">//              parameters,    #   attribute.OnEnter(currentMethod, parameters);</span></span></code> </pre><br>  Part of the dump of this code on MSIL: <br><br> <code>IL_0000: nop <br> IL_0001: call System.Reflection.MethodBase System.Reflection.MethodBase::GetCurrentMethod() <br> IL_0006: ldtoken EmitExperiments.MethodInterceptionAttribute <br> IL_000b: call System.Type System.Type::GetTypeFromHandle(System.RuntimeTypeHandle) <br> IL_0010: call System.Attribute System.Attribute::GetCustomAttribute(System.Reflection.MemberInfo,System.Type) <br> IL_0015: castclass EmitExperiments.MethodInterceptionAttribute <br> IL_001a: stloc V_1 <br> IL_001e: ldloc V_1 <br> IL_0022: callvirt System.Void EmitExperiments.MethodInterceptionAttribute::OnEnter() <br> ... <br></code> <br>  Next, I simply provide the complete code for the InjectToAssembly method (with detailed comments), which will add the necessary code to all methods with the MethodInterceptionAttribute of the specified assembly: <br><br><pre> <code class="hljs pgsql">static <span class="hljs-type"><span class="hljs-type">void</span></span> InjectToAssembly(string <span class="hljs-type"><span class="hljs-type">path</span></span>) { var assembly = AssemblyDefinition.ReadAssembly(<span class="hljs-type"><span class="hljs-type">path</span></span>); //   GetCurrentMethod() var getCurrentMethodRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(typeof(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Reflection.MethodBase).GetMethod("GetCurrentMethod")); //   <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span>.GetCustomAttribute() var getCustomAttributeRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(typeof(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span>).GetMethod("GetCustomAttribute", <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>[] { typeof(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Reflection.MethodInfo), typeof(<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>) })); //   <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>.GetTypeFromHandle() -  typeof() var getTypeFromHandleRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(typeof(<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>).GetMethod("GetTypeFromHandle")); //    MethodBase var methodBaseRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(typeof(<span class="hljs-keyword"><span class="hljs-keyword">System</span></span>.Reflection.MethodBase)); //    MethodInterceptionAttribute var interceptionAttributeRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(typeof(MethodInterceptionAttribute)); //   MethodInterceptionAttribute.OnEnter var interceptionAttributeOnEnter = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(typeof(MethodInterceptionAttribute).GetMethod("OnEnter")); //    <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;string,<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; var dictionaryType = <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>.GetType("System.Collections.Generic.Dictionary`2[System.String,System.Object]"); var dictStringObjectRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(dictionaryType); var dictConstructorRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(dictionaryType.GetConstructor(<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span>.EmptyTypes)); var dictMethodAddRef = assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Import</span></span>(dictionaryType.GetMethod("Add")); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var typeDef <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> assembly.MainModule.<span class="hljs-keyword"><span class="hljs-keyword">Types</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var <span class="hljs-keyword"><span class="hljs-keyword">method</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> typeDef.Methods.<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>(m =&gt; m.CustomAttributes.<span class="hljs-keyword"><span class="hljs-keyword">Where</span></span>( attr =&gt; attr.AttributeType.Resolve().BaseType.Name == "MethodInterceptionAttribute").FirstOrDefault() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>)) { var ilProc = <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.Body.GetILProcessor(); //   InitLocals  <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>,       <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> (      ) //      -  IL   . <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.Body.InitLocals = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; //      <span class="hljs-keyword"><span class="hljs-keyword">attribute</span></span>, currentMethod  parameters var attributeVariable = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> VariableDefinition(interceptionAttributeRef); var currentMethodVar = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> VariableDefinition(methodBaseRef); var parametersVariable = <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> VariableDefinition(dictStringObjectRef); ilProc.Body.Variables.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(attributeVariable); ilProc.Body.Variables.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(currentMethodVar); ilProc.Body.Variables.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(parametersVariable); Instruction firstInstruction = ilProc.Body.Instructions[<span class="hljs-number"><span class="hljs-number">0</span></span>]; ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Nop)); //    ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>, getCurrentMethodRef)); //       currentMethodVar ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Stloc, currentMethodVar)); //        ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldloc, currentMethodVar)); //     MethodInterceptionAttribute ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldtoken, interceptionAttributeRef)); //  GetTypeFromHandle (   typeof()) -  typeof(MethodInterceptionAttribute) ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>, getTypeFromHandleRef)); //          MethodInterceptionAttribute.  <span class="hljs-keyword"><span class="hljs-keyword">Attribute</span></span>.GetCustomAttribute ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>, getCustomAttributeRef)); //     MethodInterceptionAttribute ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Castclass, interceptionAttributeRef)); //     attributeVariable ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Stloc, attributeVariable)); //   <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;stirng, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Newobj, dictConstructorRef)); //   parametersVariable ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Stloc, parametersVariable)); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (var argument <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">method</span></span>.Parameters) { //    //     <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>&lt;string,<span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldloc, parametersVariable)); //    ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldstr, argument.Name)); //    ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldarg, argument)); //  <span class="hljs-keyword"><span class="hljs-keyword">Dictionary</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">Add</span></span>(string key, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.<span class="hljs-keyword"><span class="hljs-keyword">Call</span></span>, dictMethodAddRef)); } //     ,       OnEnter ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldloc, attributeVariable)); ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldloc, currentMethodVar)); ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Ldloc, parametersVariable)); //  OnEnter.     ,    OnEnter    ilProc.InsertBefore(firstInstruction, Instruction.<span class="hljs-keyword"><span class="hljs-keyword">Create</span></span>(OpCodes.Callvirt, interceptionAttributeOnEnter)); } } assembly.<span class="hljs-keyword"><span class="hljs-keyword">Write</span></span>(<span class="hljs-type"><span class="hljs-type">path</span></span>); } }</code> </pre><br>  Let's not forget also about the Main method of our console application: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (args.Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> mode = args[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path = args[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mode == <span class="hljs-string"><span class="hljs-string">"-dump"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> methodName = args.Length &gt; <span class="hljs-number"><span class="hljs-number">2</span></span> ? args[<span class="hljs-number"><span class="hljs-number">2</span></span>] : String.Empty; DumpAssembly(path, methodName); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mode == <span class="hljs-string"><span class="hljs-string">"-inject"</span></span>) { InjectToAssembly(args[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } } }</code> </pre><br>  Done!  Now, if you run the main application with the -inject parameter, giving it the path to our test application, the code of the MethodToChange method changes as follows (obtained using Reflector): <br><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">TestMethodInterception</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodToChange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> text</span></span></span><span class="hljs-function">)</span></span> { MethodBase currentMethod = MethodBase.GetCurrentMethod(); MethodInterceptionAttribute customAttribute = (MethodInterceptionAttribute) Attribute.GetCustomAttribute(currentMethod, <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(MethodInterceptionAttribute)); Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt; parameters = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>&gt;(); parameters.Add(<span class="hljs-string"><span class="hljs-string">"text"</span></span>, text); customAttribute.OnEnter(currentMethod, parameters); Console.ReadLine(); }</code> </pre><br><br>  As required.  Now, every method marked with TestMethodInterception will be intercepted and each call will be processed without writing a lot of duplicate code.  To automate the process, you can use Post-Build events in VS, so that after the successful construction of a project, you can automatically process the finished assembly and implement code based on attributes.  You can also create class or assembly level attributes to embed code at once into all methods of a class or assembly. <br><br>  This approach is an example of using the techniques of aspect-oriented programming in .NET.  I will not dwell in detail on what AOP is, in general terms you can always read about it on <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D1%2581%25D0%25BF%25D0%25B5%25D0%25BA%25D1%2582%25D0%25BD%25D0%25BE-%25D0%25BE%25D1%2580%25D0%25B8%25D0%25B5%25D0%25BD%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">wikipedia</a> .  The most famous library that allows you to use the principles of AOP in .NET is <a href="http://www.sharpcrafters.com/">PostSharp</a> , which inspired me to study the possibilities of code injection into my assemblies to implement this functionality and, accordingly, writing this article. <br><br>  Using AOP allows you to write clean and easily maintained code, mainly due to the fact that most of the code is generated automatically based on aspects. <br><br>  In this article, I tried to describe in detail how code can be added to existing NET assemblies using Mono.Cecil, as well as how it can be used to benefit from the implementation of AOP principles in Net, hopefully, this will seem interesting or useful. </div><p>Source: <a href="https://habr.com/ru/post/108947/">https://habr.com/ru/post/108947/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../108931/index.html">NAT on Cisco. Part 1</a></li>
<li><a href="../108932/index.html">Microsoft continues to support Creative Commons!</a></li>
<li><a href="../108934/index.html">Not another social network or how we decided to create our own social network (Part 2 - organizing the information space on news portals)</a></li>
<li><a href="../108936/index.html">Unusual laptop with two touch screens: Acer Iconia</a></li>
<li><a href="../108938/index.html">A group of enthusiasts has developed a technology for surfing the web using Kinect</a></li>
<li><a href="../108948/index.html">Writing Magic 8-Ball for Android</a></li>
<li><a href="../108950/index.html">Migrating physical Linux servers to Microsoft Hyper-V hypervisor virtual environment</a></li>
<li><a href="../108951/index.html">We draw a fluorescent acrylic on a solid surface</a></li>
<li><a href="../108955/index.html">How to trick NET.Reflector</a></li>
<li><a href="../108957/index.html">Modified firmware ports from Nokia C6 to 5530/5800</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>