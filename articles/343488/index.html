<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PostgreSQL Indexes - 8</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have already reviewed the PostgreSQL indexing mechanism , the access method interface and all the main access methods, such as: hash indices , B-tr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PostgreSQL Indexes - 8</h1><div class="post__text post__text-html js-mediator-article"><br>  We have already reviewed <a href="https://habrahabr.ru/company/postgrespro/blog/326096/">the PostgreSQL indexing mechanism</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">the access method interface</a> and all the main access methods, such as: <a href="https://habrahabr.ru/company/postgrespro/blog/328280/">hash indices</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/330544/">B-trees</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> , <a href="https://habrahabr.ru/company/postgrespro/blog/337502/">SP-GiST</a> and <a href="https://habrahabr.ru/company/postgrespro/blog/340978/">GIN</a> .  And in this part we will look at the transformation of gin into rum. <br><br><h1>  RUM </h1><br>  Although the authors claim that gin is a powerful spirit, but the topic of drinks still won: the next-generation GIN was called RUM. <br><br>  This access method develops the idea embedded in the GIN and allows you to perform full-text search even faster.  This is the only method in this series of articles that is not included in the standard PostgreSQL distribution and is a third-party extension.  There are several options for installing it: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Take the yum or apt package from <a href="https://www.postgresql.org/download/">the PGDG repository</a> .  For example, if you installed PostgreSQL from the postgresql-10 package, then add another postgresql-10-rum. </li><li>  Independently build and install from <a href="https://github.com/postgrespro/rum">source codes on github</a> (instruction there). </li><li>  Use as part of Postgres Pro Enterprise (or at least read the <a href="https://postgrespro.ru/docs/enterprise/9.6/rum">documentation</a> from there). </li></ul><br><h2>  GIN restrictions </h2><br>  What are the limitations of the GIN index to overcome RUM? <br><br>  First, the tsvector data type, in addition to the tokens themselves, contains information about their positions within the document.  In the GIN-index, as we saw <a href="https://habrahabr.ru/company/postgrespro/blog/340978/">last time</a> , this information is not saved.  Because of this, the <em>phrasal search</em> operations <em>,</em> which appeared in version 9.6, are serviced by the GIN-index inefficiently and are forced to refer to the initial data for rechecking. <br><br>  Secondly, search engines typically return results in order of relevance (whatever that means).  To do this, you can use the <em>ranking</em> functions ts_rank and ts_rank_cd, but they have to be calculated for each row of the result, which, of course, is slow. <br><br>  As a first approximation, the RUM access method can be viewed as a GIN, to which positional information has been added, and which supports outputting the result in the desired order (similar to how <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> can produce the nearest neighbors).  Let's go in order. <br><a name="habracut"></a><br><h2>  Phrase Search </h2><br>  A query in a full-text search may contain special constructions that take into account the distance between the tokens.  For example, you can find documents in which the grandmother from Dedki separates another word: <br><br> <code>postgres=# select to_tsvector('  ,   ...') @@ <br> to_tsquery(' &lt;2&gt; '); <br> ?column? <br> ---------- <br> t <br> (1 row) <br></code> <br>  Or indicate that words should stand next to each other: <br><br> <code>postgres=# select to_tsvector('  ,   ...') @@ <br> to_tsquery(' &lt;-&gt; '); <br> ?column? <br> ---------- <br> t <br> (1 row) <br></code> <br>  A regular GIN index can produce documents that have both tokens, but you can check the distance between them only by looking at the tsvector: <br><br> <code>postgres=# select to_tsvector('  ,   ...'); <br> to_tsvector <br> ------------------------------ <br> '':1 '':3,4 '':6 <br> (1 row) <br></code> <br>  In the RUM index, each token does not simply refer to the rows of the table: along with each TID, there is a list of positions in which the token is found in the document.  Here's how to imagine an index created on a table already familiar to us with a white birch tree (the default for the tsvector is the rum_tsvector_ops operator class): <br><br> <code>postgres=# create extension rum; <br> CREATE EXTENSION <br> postgres=# create index on ts using rum(doc_tsv); <br> CREATE INDEX <br></code> <br><img src="https://habrastorage.org/webt/ln/s0/ew/lns0ew3racuwhw3_m0rdoilckwu.png"><br><br>  Gray squares in the figure - added positional information: <br><br> <code>postgres=# select ctid, doc, doc_tsv from ts; <br> ctid  |          doc          |            doc_tsv <br> --------+-------------------------+-------------------------------- <br> (0,1)  |      | '':3 '':2 '':4 <br> (0,2)  |     | '':3 '':2 '':4 <br> (0,3)  | , ,       | '':1,2 '':3 <br> (0,4)  | , ,       | '':1,2 '':3 <br> (1,1)  |     | '':2 '':3 '':1 <br> (1,2)  |    | '':3 '':2 '':1 <br> (1,3)  | , ,     | '':3 '':1,2 <br> (1,4)  | , ,     | '':3 '':1,2 <br> (2,1)  |           | '':3 '':2 <br> (2,2)  |       | '':1 '':2 '':3 <br> (2,3)  | , ,     | '':3 '':1,2 <br> (2,4)  | , ,     | '':3 '':1,2 <br> (12 rows) <br></code> <br>  The GIN still has a delayed insert when you specify the fastupdate parameter;  RUM has removed this functionality. <br><br>  To see how the index works on real data, we use the pgsql-hackers mailing list known to us. <br><br> <code>fts=# alter table mail_messages add column tsv tsvector; <br> ALTER TABLE <br> fts=# set default_text_search_config = default; <br> SET <br> fts=# update mail_messages <br> set tsv = to_tsvector(body_plain); <br> ... <br> UPDATE 356125 <br></code> <br>  Here is how a query is executed using a phrase search with a GIN index: <br><br> <code>fts=# create index tsv_gin on mail_messages using gin(tsv); <br> CREATE INDEX <br> fts=# explain (costs off, analyze) <br> select * from mail_messages where tsv @@ to_tsquery('hello &lt;-&gt; hackers'); <br> QUERY PLAN <br> --------------------------------------------------------------------------------- <br> Bitmap Heap Scan on mail_messages (actual time=2.490..18.088 <strong>rows=259</strong> loops=1) <br> Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) <br> <strong>Rows Removed by Index Recheck: 1517</strong> <br> Heap Blocks: exact=1503 <br> -&gt;  Bitmap Index Scan on <strong>tsv_gin</strong> (actual time=2.204..2.204 <strong>rows=1776</strong> loops=1) <br> Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) <br> Planning time: 0.266 ms <br> Execution time: 18.151 ms <br> (8 rows) <br></code> <br>  As can be seen from the plan, the GIN-index is used, but returns 1776 potential matches, of which 259 remain, and 1517 are discarded during the recheck phase. <br><br>  Now remove the GIN-index and build RUM. <br><br> <code>fts=# drop index tsv_gin; <br> DROP INDEX <br> fts=# create index tsv_rum on mail_messages using rum(tsv); <br> CREATE INDEX <br></code> <br>  Now the index has all the necessary information and the search is performed exactly: <br><br> <code>fts=# explain (costs off, analyze) <br> select * from mail_messages <br> where tsv @@ to_tsquery('hello &lt;-&gt; hackers'); <br> QUERY PLAN <br> -------------------------------------------------------------------------------- <br> Bitmap Heap Scan on mail_messages (actual time=2.798..3.015 <strong>rows=259</strong> loops=1) <br> Recheck Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) <br> Heap Blocks: exact=250 <br> -&gt;  Bitmap Index Scan on <strong>tsv_rum</strong> (actual time=2.768..2.768 <strong>rows=259</strong> loops=1) <br> Index Cond: (tsv @@ to_tsquery('hello &lt;-&gt; hackers'::text)) <br> Planning time: 0.245 ms <br> Execution time: 3.053 ms <br> (7 rows) <br></code> <br><h2>  Sort by relevance </h2><br>  In order to issue documents at once in the right order, the RUM index supports the <em>ordering operators,</em> which we discussed in the <a href="https://habrahabr.ru/company/postgrespro/blog/333878/">GiST</a> part.  The rum extension defines such an operator <code>&lt;=&gt;</code> that returns some distance between the document (tsvector) and the query (tsquery).  For example: <br><br> <code>fts=# select to_tsvector('  ,   ...') &lt;=&gt; to_tsquery(''); <br> ?column? <br> ---------- <br> 16.4493 <br> (1 row) <br> <br> fts=# select to_tsvector('  ,   ...') &lt;=&gt; to_tsquery(''); <br> ?column? <br> ---------- <br> 13.1595 <br> (1 row) <br></code> <br>  The document turned out to be more relevant to the first request than to the second: the more often the word appears in the document, the less ‚Äúvaluable‚Äù it is. <br><br>  Again, try to compare GIN and RUM on a relatively large amount of data: select the ten most relevant documents containing ‚Äúhello‚Äù and ‚Äúhackers‚Äù. <br><br> <code>fts=# explain (costs off, analyze) <br> select * from mail_messages <br> where tsv @@ to_tsquery('hello &amp; hackers') <br> order by ts_rank(tsv,to_tsquery('hello &amp; hackers')) <br> limit 10; <br> QUERY PLAN <br> --------------------------------------------------------------------------------------------- <br> Limit (actual time=27.076..27.078 rows=10 loops=1) <br> -&gt; <strong>Sort</strong> (actual time=27.075..27.076 <strong>rows=10</strong> loops=1) <br> Sort Key: (ts_rank(tsv, to_tsquery('hello &amp; hackers'::text))) <br> Sort Method: top-N heapsort  Memory: 29kB <br> -&gt;  Bitmap Heap Scan on mail_messages (actual ... rows=1776 loops=1) <br> Recheck Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) <br> Heap Blocks: exact=1503 <br> -&gt;  Bitmap Index Scan on <strong>tsv_gin</strong> (actual ... <strong>rows=1776</strong> loops=1) <br> Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) <br> Planning time: 0.276 ms <br> Execution time: 27.121 ms <br> (11 rows) <br></code> <br>  GIN-index returns 1776 matches, which are then separately sorted for a sample of the ten most appropriate. <br><br>  With the RUM index, the query is performed by a simple index scan: no unnecessary documents are scanned, no separate sorting is required: <br><br> <code>fts=# explain (costs off, analyze) <br> select * from mail_messages <br> where tsv @@ to_tsquery('hello &amp; hackers') <br> order by tsv &lt;=&gt; to_tsquery('hello &amp; hackers') <br> limit 10; <br> QUERY PLAN <br> -------------------------------------------------------------------------------------------- <br> Limit (actual time=5.083..5.171 <strong>rows=10</strong> loops=1) <br> -&gt;  Index Scan using <strong>tsv_rum</strong> on mail_messages (actual ... <strong>rows=10</strong> loops=1) <br> Index Cond: (tsv @@ to_tsquery('hello &amp; hackers'::text)) <br> Order By: (tsv &lt;=&gt; to_tsquery('hello &amp; hackers'::text)) <br> Planning time: 0.244 ms <br> Execution time: 5.207 ms <br> (6 rows) <br></code> <br><h2>  Additional Information </h2><br>  The RUM index, like the GIN, can be built in several fields.  But if in the GIN, the tokens of different columns are stored independently of each other, then RUM allows you to "link" the main field (tsvector in our case) with an additional one.  To do this, use the special class of rum_tsvector_addon_ops operators: <br><br> <code>fts=# create index on mail_messages using rum(tsv <strong>rum_tsvector_addon_ops,</strong> sent) <br> <strong>with (attach='sent', to='tsv');</strong> <br> CREATE INDEX <br></code> <br>  Such an index can be used to produce results in the sort order by the additional field: <br><br> <code>fts=# select id, sent, sent &lt;=&gt; '2017-01-01 15:00:00' <br> from mail_messages <br> where tsv @@ to_tsquery('hello') <br> order by sent &lt;=&gt; '2017-01-01 15:00:00' <br> limit 10; <br> id    |        sent        | ?column? <br> ---------+---------------------+---------- <br> 2298548 | 2017-01-01 15:03:22 |      202 <br> 2298547 | 2017-01-01 14:53:13 |      407 <br> 2298545 | 2017-01-01 13:28:12 |    5508 <br> 2298554 | 2017-01-01 18:30:45 |    12645 <br> 2298530 | 2016-12-31 20:28:48 |    66672 <br> 2298587 | 2017-01-02 12:39:26 |    77966 <br> 2298588 | 2017-01-02 12:43:22 |    78202 <br> 2298597 | 2017-01-02 13:48:02 |    82082 <br> 2298606 | 2017-01-02 15:50:50 |    89450 <br> 2298628 | 2017-01-02 18:55:49 |  100549 <br> (10 rows) <br></code> <br>  Here we are looking for suitable lines, located as close as possible to the specified date, no matter, sooner or later.  To get the results strictly preceding the date (or following it), you need to use the operation <code>&lt;=|</code>  (or <code>|=&gt;</code> ). <br><br>  The query, as we expect, is performed by a simple index scan: <br><br> <code>ts=# explain (costs off) <br> select id, sent, sent &lt;=&gt; '2017-01-01 15:00:00' <br> from mail_messages <br> where tsv @@ to_tsquery('hello') <br> order by sent &lt;=&gt; '2017-01-01 15:00:00' <br> limit 10; <br> QUERY PLAN <br> --------------------------------------------------------------------------------- <br> Limit <br> -&gt;  Index Scan using mail_messages_tsv_sent_idx on mail_messages <br> Index Cond: (tsv @@ to_tsquery('hello'::text)) <br> Order By: (sent &lt;=&gt; '2017-01-01 15:00:00'::timestamp without time zone) <br> (4 rows) <br></code> <br>  If we created an index without additional information about the connection of fields, then for a similar query we would have to sort all the results obtained from the index. <br><br>  Of course, in addition to the date, you can add fields and other data types to the RUM index ‚Äî almost all base types are supported.  For example, an online store can quickly display products by newness (date), price (numeric), popularity, or discount size (whole or floating point). <br><br><h2>  Other classes of operators </h2><br>  For completeness, it is worth mentioning about other available classes of operators. <br><br>  Let's start with <strong>rum_tsvector_hash_ops</strong> and <strong>rum_tsvector_hash_addon_ops.</strong>  They are all similar to those already discussed above rum_tsvector_ops and rum_tsvector_addon_ops, but the lexeme itself is not stored in the index, but its hash code.  This may reduce the size of the index, but, of course, makes the search less accurate and requires rechecking.  In addition, the index no longer supports the search for partial matches. <br><br>  The class of <strong>rum_tsquery_ops</strong> operators is <strong>curious.</strong>  It allows you to solve the "reverse" task: to find requests that match the document.  Why this may be needed?  For example, to sign a user for new products by his filter.  Or automatically classify new documents.  Here is a simple example: <br><br> <code>fts=# create table categories(query tsquery, category text); <br> CREATE TABLE <br> fts=# insert into categories values <br> (to_tsquery('vacuum | autovacuum | freeze'), 'vacuum'), <br> (to_tsquery('xmin | xmax | snapshot | isolation'), 'mvcc'), <br> (to_tsquery('wal | (write &amp; ahead &amp; log) | durability'), 'wal'); <br> INSERT 0 3 <br> fts=# create index on categories using rum(query); <br> CREATE INDEX <br> <br> fts=# select array_agg(category) <br> from categories <br> where to_tsvector( <br> 'Hello hackers, the attached patch greatly improves performance of tuple <br> freezing and also reduces size of generated write-ahead logs.' <br> ) @@ query; <br> array_agg <br> -------------- <br> {vacuum,wal} <br> (1 row) <br></code> <br>  There are classes of operators <strong>rum_anyarray_ops</strong> and <strong>rum_anyarray_addon_ops</strong> - they are designed to work not with tsvector, but with arrays.  For GIN, this has already been considered <a href="https://habrahabr.ru/company/postgrespro/blog/340978/">last time</a> , so there is no reason to repeat. <br><br><h2>  Index size and prerecord log </h2><br>  It is clear that, since RUM contains more information than the GIN, then it will take up more space.  Last time we compared the sizes of different indices;  add to this table and RUM: <br><br> <code>rum   |  gin  |  gist  | btree <br> --------+--------+--------+-------- <br> 457 MB | 179 MB | 125 MB | 546 MB <br></code> <br>  As you can see, the volume has grown quite significantly - this is the fee for a quick search. <br><br>  Another non-obvious point that is worth paying attention to is that RUM is an extension, that is, it can be installed without making any changes to the core of the system.  This was made possible in version 9.6 thanks to the patch that was made by <a href="https://habrahabr.ru/users/smagen/">Alexander Korotkov</a> .  One of the tasks that had to be solved was the generation of journal entries.  The journaling mechanism must be absolutely reliable, so the extension should not be allowed into this kitchen.  Instead of allowing the extension to create its own types of journal entries, it‚Äôs done like this: the extension code reports the intention to change the page, makes any changes to it and signals completion, and the kernel of the system compares the old and new versions of the page and generates the necessary unified journal entries records <br><br>  The current generation algorithm compares pages byte-by-by, finds changed fragments and logs each such fragment along with the offset from the beginning of the page.  This works well when changing only a few bytes, and when the page has changed completely.  But if you add some fragment inside the page, sliding the rest of the content down (or, on the contrary, removing the fragment, sliding the content up), many more bytes will be formally changed than was actually added or deleted. <br><br>  Because of this, the actively changing RUM-index can generate log entries that are significantly larger than the GIN (which, being not an extension, but a part of the kernel, manages the journal itself).  The degree of this unpleasant effect strongly depends on the real load, but in order to somehow feel the problem, let's try to remove and add a few lines several times, alternating these actions with cleaning (vacuum).  You can estimate the size of the log entries as follows: at the beginning and at the end, you can remember the position in the log by the function pg_current_wal_location (up to the tenth version - pg_current_xlog_location) and then look at their difference. <br><br>  Here, of course, many factors must be kept in mind.  You need to make sure that only one user is working in the system, otherwise ‚Äúextra‚Äù entries will be included in the calculation.  Even in this case, we consider not only RUM, but also changes to the table itself and the index supporting the primary key.  The values ‚Äã‚Äãof the configuration parameters also affect (here the replica log level was used, without compression).  But still try. <br><br> <code>fts=# select pg_current_wal_location() as start_lsn \gset <br> <br> fts=# insert into mail_messages(parent_id, sent, subject, author, body_plain, tsv) <br> select parent_id, sent, subject, author, body_plain, tsv <br> from mail_messages where id % 100 = 0; <br> INSERT 0 3576 <br> fts=# delete from mail_messages where id % 100 = 99; <br> DELETE 3590 <br> fts=# vacuum mail_messages; <br> VACUUM <br> <br> fts=# insert into mail_messages(parent_id, sent, subject, author, body_plain, tsv) <br> select parent_id, sent, subject, author, body_plain, tsv <br> from mail_messages where id % 100 = 1; <br> INSERT 0 3605 <br> fts=# delete from mail_messages where id % 100 = 98; <br> DELETE 3637 <br> fts=# vacuum mail_messages; <br> VACUUM <br> <br> fts=# insert into mail_messages(parent_id, sent, subject, author, body_plain, tsv) <br> select parent_id, sent, subject, author, body_plain, tsv from mail_messages <br> where id % 100 = 2; <br> INSERT 0 3625 <br> fts=# delete from mail_messages where id % 100 = 97; <br> DELETE 3668 <br> fts=# vacuum mail_messages; <br> VACUUM <br> <br> fts=# select pg_current_wal_location() as end_lsn \gset <br> fts=# select pg_size_pretty(:'end_lsn'::pg_lsn - :'start_lsn'::pg_lsn); <br> pg_size_pretty <br> ---------------- <br> 3114 MB <br> (1 row) <br></code> <br>  So, it turned out about 3 GB.  And if the same experiment is repeated with the GIN index, there will be only about 700 MB. <br><br>  Therefore, I would like to have another algorithm that finds the minimum number of insert and delete operations, with which one page state can be brought to another - in the same way as the diff utility works.  This algorithm has already been implemented by <a href="https://habrahabr.ru/users/tigvarts/">Oleg Ivanov</a> , his <a href="https://commitfest.postgresql.org/15/1363/">patch is being</a> discussed.  In the above example, this patch, at the cost of a slight slowdown, allows reducing the volume of journal entries by one and a half times, to 1900 MB. <br><br><h2>  Properties </h2><br>  Traditionally, we look at the properties of the rum access method (requests <a href="https://habrahabr.ru/company/postgrespro/blog/326106/">were cited earlier</a> ), drawing attention to the differences from gin. <br><br>  Method properties: <br><br> <code>amname |    name      | pg_indexam_has_property <br> --------+---------------+------------------------- <br> rum    | can_order    | f <br> rum    | can_unique    | f <br> rum    | can_multi_col | t <br> rum    | can_exclude  | t -- f  gin <br></code> <br>  Index properties: <br><br> <code>name      | pg_index_has_property <br> ---------------+----------------------- <br> clusterable  | f <br> index_scan    | t -- f  gin <br> bitmap_scan  | t <br> backward_scan | f <br></code> <br>  Note that RUM, in contrast to GIN, supports index scanning - otherwise it would be impossible to get exactly the required number of results in queries with the phrase limit.  Accordingly, there is no need for an analogue of the gin_fuzzy_search_limit parameter.  Well, as a result, the index can be used to support exception constraints. <br><br>  Column level properties: <br><br> <code>name        | pg_index_column_has_property <br> --------------------+------------------------------ <br> asc                | f <br> desc              | f <br> nulls_first        | f <br> nulls_last        | f <br> orderable          | f <br> distance_orderable | t -- f  gin <br> returnable        | f <br> search_array      | f <br> search_nulls      | f <br></code> <br>  Here the difference is that RUM supports ordering operators.  Although not for all classes of operators: for example, for tsquery_ops it will be false. <br><br>  <a href="https://habrahabr.ru/company/postgrespro/blog/346460/">Continued</a> . </div><p>Source: <a href="https://habr.com/ru/post/343488/">https://habr.com/ru/post/343488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../343478/index.html">‚ÄúONLYOFFICE Documents‚Äù for iOS: how the application has changed over the year</a></li>
<li><a href="../343480/index.html">NFC in the world of sports - 5 examples</a></li>
<li><a href="../343482/index.html">How to shuffle songs?</a></li>
<li><a href="../343484/index.html">Performance as Perception: Time Perception</a></li>
<li><a href="../343486/index.html">Impressions of developers and designers from the iPhone X - and from the cutout</a></li>
<li><a href="../343490/index.html">Opensource helps us to build and live: an interview with Yii Framework developer Alexander Makarov</a></li>
<li><a href="../343492/index.html">How is the Hamster Marketplace token different from other project tokens?</a></li>
<li><a href="../343494/index.html">Investors reduced Uber's financial valuation by $ 18.5 billion after a series of scandals and hacker attacks</a></li>
<li><a href="../343496/index.html">Setting the user interface when installing applications on nanoCAD Plus 8.5</a></li>
<li><a href="../343498/index.html">Basics of information security. Part 2. Information and means of its protection</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>