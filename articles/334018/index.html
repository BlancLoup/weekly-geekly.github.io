<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dotty - the future of the Scala language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At the end of May, I was among the listeners of the Scala Days conference in Copenhagen. One of the key speakers was the creator of the Scala language...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search"></a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings"></a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">猬锔</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">猬锔</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dotty - the future of the Scala language</h1><div class="post__text post__text-html js-mediator-article">  At the end of May, I was among the listeners of the Scala Days conference in Copenhagen.  One of the key speakers was the creator of the Scala language, Martin Oderski.  He spoke about the development of the language and, in particular, about the development of a compiler called Dotty.  It is planned that a new compiler for version 3.0 will be developed on the basis of Dotty. <br><br>  Martin has repeatedly spoken on this topic, and I would like to collect here all the latest information about Dotty - new key features and elements that were removed as unnecessary. <br><br> <a href="https://habrahabr.ru/company/lanit/blog/334018/"><img src="https://habrastorage.org/web/ade/537/cb1/ade537cb168a4e3f92959d8479417caa.jpg"></a> <br>  <i>Martin Oderski.</i>  <i>Scala development plan for the next few years</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This post will be useful both for connoisseurs and completely newbies, for whom I talk about Dotty with a story about the features of Scala, as well as about its mathematical basis. <br><a name="habracut"></a><br>  <a href="http://scala-lang.org/">Scala</a> is a multi-paradigm programming language, originally developed for the JVM (Java virtual machine).  But now translators are also developed in JavaScript (ScalaJS) and in native code (Scala native).  The name Scala comes from <b>Sca</b> lable <b>la</b> nguage ("scalable language").  Indeed, it is convenient to write on Scala both small scripts of several lines, which can then be run in the interpreter (read-eval-print loop, REPL), as well as complex systems running on a cluster of a large number of machines (in particular, systems built with using <a href="http://akka.io/">akka</a> and <a href="https://spark.apache.org/">apache spark</a> frameworks). <br><br>  Before developing Scala, Martin Oderski was involved in the development of generic types (generics) for Java, which appeared in Java 5 in 2004.  Around that time, Martin got the idea of creating a new language for the JVM, which would not have the huge baggage of backward compatibility that Java had at that time.  Martin's idea was to combine a Java object-oriented approach with a functional approach similar to that used in Haskell, OCaml and Erlang, and still be a strongly typed language. <br><br>  One of the main features of Scala as a strongly typed language is support for automatic type inference.  Unlike other typed languages, where for each expression you need to explicitly specify the type, Scala allows you to define the type of variables, as well as the return type of the function implicitly.  For example, the definition of a constant in Java is as follows: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> String s = <span class="hljs-string"><span class="hljs-string">"Hello world"</span></span>;</code> </pre> <br>  This is equivalent to the following Scala expression: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = <span class="hljs-string"><span class="hljs-string">"Hello world"</span></span></code> </pre> <br>  However, in Scala, you can also specify the type of expression explicitly, for example, in the case when the variable must have a type that is a supertype of the specified expression. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> cs: <span class="hljs-type"><span class="hljs-type">CharSequence</span></span> = <span class="hljs-string"><span class="hljs-string">"Hello world"</span></span></code> </pre> <br>  The rules of implicit type inference Martin Oderski considers the main feature of the language that distinguishes it from others.  He is currently leading the work on the improvement of this system, as well as on its mathematical rationale, called the DOT-calculus (DOT-calculus). <br><br><h2>  DOT calculus </h2><br>  DOT stands for dependent object types, i.e.  deduction of types of dependent objects.  By dependent type is meant the type resulting from a particular operation.  In the current version of the language, there is already a certain set of rules for type inference based on existing ones, for example, restrictions on the inheritance hierarchy from above or below, or type inference depending on the argument (path-dependent type).  Let's give a small example: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">def</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">someFunction</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">b: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">B</span></span></span></span></span><span class="hljs-class">)</span></span>: <span class="hljs-type"><span class="hljs-type">B</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class"> &lt;: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">D</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Y</span></span></span><span class="hljs-class"> </span></span>= (<span class="hljs-type"><span class="hljs-type">X</span></span>, <span class="hljs-type"><span class="hljs-type">D</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun1</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">X</span></span>): <span class="hljs-type"><span class="hljs-type">Y</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun2</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">A</span></span>): aB }</code> </pre><br>  In this example, we define two traits, A and C. trait A has a field-type B, and also defines some operation SomeFunction, which accepts a type B parameter as input. The value of type B is determined depending on the specific implementation of A. trait C has the parameter-type X, which must be a successor of type D. trait C, defines the field-type Y, as well as two functions: fun1 and fun2.  fun1 takes a value of type X as input and returns a value of type Y. fun2 takes a value of type A, but the type of the return value is determined by the value of the field-type B of argument A. <br><br>  DOT-calculus is a mathematical formalization of the rules for such an inference.  Basic elements of DOT calculus: <br><br><ol><li>  Top type (Any) - the type that lies at the very top of the hierarchy is the superclass for all types. <br></li><li>  Bottom type (Nothing) - the type that lies at the bottom of the hierarchy is a subtype of all types. <br></li><li>  Type declaration - type declaration in the specified limits above and below. <br></li><li>  Type selection - type inference depending on a variable. <br></li><li>  Function - a function that takes as input one or more arguments of various types and has a specific type of value. <br></li></ol><br>  In addition, the DOT calculus defines the following set of valid operations on types: <br><br><ol><li>  Inheritance.  Any type, if it is not borderline (in our case, Any and Nothing), can be either a supertype or a subtype of another type.  Each type is a supertype and a subtype for itself. <br></li><li>  Creating structured types (Records), including other types (by analogy with objects and structures for variables). <br></li><li>  Union of types  The resulting type will be the disjunction of fields and operations of the original types. <br></li><li>  Type intersection  The resulting type will be a conjunction of fields and operations of the original types. <br></li><li>  Recursive type definition. <br></li></ol><br>  A detailed review of DOT is beyond the scope of this publication.  More information about DOT-calculus can be found <a href="https://infoscience.epfl.ch/record/215280/files/paper_1.pdf">here</a> . <br><br><h2>  Overview of innovations in Dotty </h2><br>  DOT calculus is the mathematical basis for the Dotty compiler.  Actually, this is reflected in its name. <br><br>  Now Dotty is an experimental platform for developing new language concepts and compilation technologies.  According to Martin Oderski, the goal of developing Dotty is to strengthen the basic structures and get rid of unnecessary elements of the language.  Dotty is currently developing as an independent project, but it is planned that over time it will join the main Scala branch. <br><br><img src="https://habrastorage.org/web/08b/ff8/03a/08bff803aac447619e17a121a3f506e6.jpg"><br><br>  A complete list of innovations can be found <a href="http://dotty.epfl.ch/docs/index.html">on the official Dotty website</a> .  And in this article I will consider only those innovations in Dotty that I consider the most important. <br><br><h3>  1. Type Intersections </h3><br>  Type intersection is defined as a type that simultaneously possesses all the properties of the original types.  Suppose we have defined some types A and B: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun1</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">Int</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun2</span></span></span></span>(): <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre> <br>  Type C is defined as the intersection of types A and B: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">A</span></span> &amp; <span class="hljs-type"><span class="hljs-type">B</span></span></code> </pre> <br>  In this case, we can write the following function: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun3</span></span></span></span>(c: <span class="hljs-type"><span class="hljs-type">C</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${c.fun1()}</span></span></span><span class="hljs-string"> - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${c.fun2()}</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  As follows from the example, with the c parameter we can call both the fun1 () method defined for type A and the fun2 () method defined for type B. <br><br>  In the current version of the compiler, this feature is supported through the with construction, for example: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">B</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun3</span></span></span></span>(c: <span class="hljs-type"><span class="hljs-type">C</span></span>): <span class="hljs-type"><span class="hljs-type">String</span></span> = <span class="hljs-string"><span class="hljs-string">s"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${c.fun1()}</span></span></span><span class="hljs-string"> - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${c.fun2()}</span></span></span><span class="hljs-string">"</span></span></code> </pre> <br>  There is a significant difference between &amp; and with constructions: &amp; is a commutative operation, that is, type A &amp; B is equivalent to type B &amp; A, while A with B is not equivalent to B with A. Let us give an example: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Int</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">String</span></span> }</code> </pre><br>  For type A with B, the value of type T is equal to Int, since A takes precedence over B. In Dotty, for type A &amp; B, type T will be equal to Int &amp; String. <br><br>  The with construction for types is currently supported in Dotty, however, it is declared as deprecated and is planned to be removed in the future. <br><br><h3>  2. Combining Types </h3><br>  A type union is defined as a type that has the properties of one of the source types.  Unlike type intersection, in the current version of the scala compiler there is no analogy for type combining.  For values with a merged type, the standard library has the Either type [A, B].  Suppose we have the following types defined: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, surname: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">User</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">nickname: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  In this case, we can write the following function: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greeting</span></span></span></span>(somebody: <span class="hljs-type"><span class="hljs-type">Person</span></span> | <span class="hljs-type"><span class="hljs-type">User</span></span>) = somebody <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, surname) =&gt; <span class="hljs-string"><span class="hljs-string">s"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$name</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$surname</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">User</span></span>(nickname) =&gt; <span class="hljs-string"><span class="hljs-string">s"Hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$nickname</span></span></span><span class="hljs-string">, (sorry, I actually don't know your real name)"</span></span> }</code> </pre><br>  The union of types gives us a shorter form of the record in comparison with the use of Either in the current version of the language: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">greeting</span></span></span></span>(somebody: <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>, <span class="hljs-type"><span class="hljs-type">User</span></span>]) = somebody <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Left</span></span>(<span class="hljs-type"><span class="hljs-type">Person</span></span>(name, surname)) =&gt; <span class="hljs-string"><span class="hljs-string">s"Hello, </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$name</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$surname</span></span></span><span class="hljs-string">"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Right</span></span>(<span class="hljs-type"><span class="hljs-type">User</span></span>(nickname)) =&gt; <span class="hljs-string"><span class="hljs-string">s"Hello </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$nickname</span></span></span><span class="hljs-string">, (sorry, I actually don't know your real name)"</span></span> }</code> </pre> <br>  A type union, like an intersection, is also a commutative operation. <br><br>  One of the uses of type combining is to completely eliminate the null construction.  Now, as an alternative to using null, is the Option construction, however, since it is implemented as a wrapper, this slightly slows down the work, because additional packing and unpacking operations are necessary.  With use of association of types permission will be carried out at a compilation stage. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodWithOption</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]) = s <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Some</span></span>(string) =&gt; println(string) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">None</span></span> =&gt; println(<span class="hljs-string"><span class="hljs-string">"There's nothing to print"</span></span>) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">String?</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">String</span></span> | <span class="hljs-type"><span class="hljs-type">Null</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">methodWithUnion</span></span></span></span>(s: <span class="hljs-type"><span class="hljs-type">String</span></span>?) = s <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> string: <span class="hljs-type"><span class="hljs-type">String</span></span> =&gt; println(string) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Null</span></span> =&gt; println(<span class="hljs-string"><span class="hljs-string">"There's nothing to print"</span></span>) }</code> </pre> <br><h3>  3. Determination of the closest subtypes and supertypes </h3><br>  With the introduction of new operations on such composite types as union and intersection, the rules for calculating the nearest types according to the inheritance hierarchy have changed.  Dotty determines that for any type T and U the closest supertype will be T |  U, and the closest subtype is T &amp; U. Thus, the so-called subtyping lattice is formed.  She is in the picture below. <br><br><img src="https://habrastorage.org/web/b73/81f/2df/b7381f2dfe534f6888e898e4d68986ba.png"><br><br>  In the current implementation of Scala, the nearest supertype is defined as a common supertype for the two types.  So, in general, for two case classes T and U, the nearest supertype will be Product with Serializable.  In Dotty, this is uniquely defined as T |  U. <br><br>  For the case of the closest subtype in the current implementation of Scala there is no single answer.  The closest subtype can be either T with U or U with T. As mentioned previously, the with operation is not commutative, so the type of T with U is not equivalent to the type of U with T. Dotty eliminates this uncertainty by defining the nearest subtype as T &amp; U. The operation &amp; is commutative, therefore the value is unique. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> s = <span class="hljs-string"><span class="hljs-string">"String"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> i  = <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> i</code> </pre><br>  In Scala 2.12, the Any value will be assigned to the result value.  In Dotty, if you do not explicitly specify the type for result, it will also be assigned the type Any.  However, we can explicitly specify the type of the result: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result: <span class="hljs-type"><span class="hljs-type">String</span></span> | <span class="hljs-type"><span class="hljs-type">Int</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) s <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> i</code> </pre> <br>  Thus, we have limited the set of valid values for result to String and Int. <br><br><h3>  4. Lambda expressions for types </h3><br><br>  One of the most difficult language features in Scala is the support of so-called Higher-kinded types.  The essence of higher order types is to further increase the level of abstraction using generalized programming.  More details about higher order types are described in <a href="https://infoscience.epfl.ch/record/222780%3Fln%3Den">this article</a> .  We will consider a specific example, which is taken from the book <a href="https://www.amazon.com/Programming-Scala-Scalability-Functional-Objects/dp/1491949856">Programming Scala by Dean Wampler and Alex Payne (2nd edition)</a> . <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, +</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">M</span></span></span><span class="hljs-class">[_]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](f: <span class="hljs-type"><span class="hljs-type">A</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">M</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SeqFunctor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">seq: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Seq</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Seq</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](f: (<span class="hljs-type"><span class="hljs-type">A</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = seq map f } <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OptionFunctor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">opt: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Option</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">A</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">A</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Option</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>](f: (<span class="hljs-type"><span class="hljs-type">A</span></span>) =&gt; <span class="hljs-type"><span class="hljs-type">B</span></span>): <span class="hljs-type"><span class="hljs-type">Option</span></span>[<span class="hljs-type"><span class="hljs-type">B</span></span>] = opt map f }</code> </pre><br>  Here we create the type Functor, which is parameterized by two types: the type of value A and the type of some wrapper M. In Scala, the expression M (without parameters) is called a type constructor.  By analogy with object constructors, which can take a certain set of parameters in order to create a new object, type constructors can also take parameters in order to define a particular type.  Therefore, in order to define a specific type for Functor from our example, several steps must be performed: <br><br><ol><li>  The type for A and B is determined. <br></li><li>  Type is defined for M [A] and M [B] <br></li><li>  Type is defined for Functor [A, M] <br></li></ol><br>  Thus, the compiler can determine the type for the Functor only after the third iteration, so it is considered the highest order type.  In general, a higher order type is a type, which takes both simple types and type constructors as parameters. <br><br>  In the example above, there is one drawback: in parameters of type Functor, the constructor of type M takes one parameter.  Suppose we need to write the method map2, which will change the values of Map [K, V], while keeping the keys unchanged.  Dean Wampler in his book proposes the following solution: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapFunctor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">,</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V1</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">mapKV1: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">K</span></span></span></span><span class="hljs-class"><span class="hljs-params">,</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">V1</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V1</span></span></span><span class="hljs-class">,({type 位[伪] </span></span>= <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">K</span></span>,伪]})#位] { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">V2</span></span>](f: <span class="hljs-type"><span class="hljs-type">V1</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">V2</span></span>): <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">K</span></span>,<span class="hljs-type"><span class="hljs-type">V2</span></span>] = mapKV1 map {   <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k,v) =&gt; (k,f(v)) } }</code> </pre> <br>  In this example, we create a new constructor of type 位, which takes one parameter, closing the first parameter K for the Map.  This implementation is quite confusing, since in order to create a constructor of type 位, we first create the structural type {type 位 [伪] = Map [K, 伪]}, in which we define the field type 位 with one parameter, and then we pull out it through the mechanism of type projection (which Dotty decided to get rid of). <br><br>  For such cases, Dotty has developed a lambda expression mechanism for types.  Its syntax is as follows: <br><br><pre> <code class="scala hljs">[<span class="hljs-type"><span class="hljs-type">X</span></span>] =&gt; <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">K</span></span>, <span class="hljs-type"><span class="hljs-type">X</span></span>]</code> </pre> <br>  This expression is read as a type that has one parameter that constructs the Map type, whose key type K can be any, and the value type is equal to the parameter.  Thus, we can write Functor to work with values in Map as follows. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapFunctor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">,</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V1</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">mapKV1: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Map</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">K</span></span></span></span><span class="hljs-class"><span class="hljs-params">,</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">V1</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Functor</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">V1</span></span></span><span class="hljs-class">, [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">=&gt;</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Map</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">K</span></span></span><span class="hljs-class">,</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">X</span></span></span><span class="hljs-class">]] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map2</span></span></span></span>[<span class="hljs-type"><span class="hljs-type">V2</span></span>](f: <span class="hljs-type"><span class="hljs-type">V1</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">V2</span></span>): <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">K</span></span>,<span class="hljs-type"><span class="hljs-type">V2</span></span>] = mapKV1 map {  <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (k,v) =&gt; (k,f(v)) } }</code> </pre><br>  As you can see from this example, the lambda expression syntax for types entered in Dotty allows you to simplify the definition of the MapFunctor class, getting rid of all confusing constructs. <br><br>  Lambda expressions for types also allow imposing restrictions on covariance and contravariance on arguments, for example: <br><br>  [+ X, Y] =&gt; Map [Y, X] <br><br><h3>  5. Adaptivity of arity of functions under tuples </h3><br>  This innovation is syntactic sugar, which simplifies working with collections from tuples (tuple), as well as in the general case with all implementations of the Product class (these are all case classes). <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> pairsList: <span class="hljs-type"><span class="hljs-type">List</span></span>[(<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>)] = <span class="hljs-type"><span class="hljs-type">List</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>))</code> </pre> <br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rectangle</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">width: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, height: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rectangles</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">Rectangle</span></span>] = <span class="hljs-type"><span class="hljs-type">List</span></span>(<span class="hljs-type"><span class="hljs-type">Rectangle</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-type"><span class="hljs-type">Rectangle</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>))</code> </pre> <br>  Now, to work with collections of this type, we can use either functions with one argument: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sums = pairsLIst.map(pair =&gt; pair._1 + pair_2) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> areas = rectangles.map(r =&gt; r.width * r.height)</code> </pre> <br>  Or we can use partial functions: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sums = pairsLIst.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (a, b) =&gt; a + b } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> areas = rectangles.map { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Rectangle</span></span>(w, h) =&gt; w * h }</code> </pre> <br>  Dotty offers a more compact and convenient option: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sums = pairsLIst.map(_ + _) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> areas = rectangles.map(_ * _)</code> </pre><br>  Thus, for subclasses of type Product Dotty selects a function whose arity is equal to the arity of the original product. <br><br><h3>  6. Parameters for traits </h3><br>  Dotty has finally added the ability to set parameters when defining traits.  This was not done before due to the fact that in the case of complex inheritance hierarchies, the parameter values were uncertain.  Dotty introduced additional restrictions on the use of parameterized traits. <br><br><ul><li>  Parameter values for a trait can only be passed when defining a class, but not another trait. </li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">x: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">42</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">42</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><ul><li>  When defining a class that implements a parameterized trait, it is necessary to specify the parameter values for it.  If the class extends another class, when determining which trait-y a certain value was transferred, then in this case it is not necessary to specify the value on the contrary. <br></li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">D2</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">84</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span></span></code> </pre> <br><ul><li>  A class that extends a trait, which is a descendant of a parameterized trait, must pass a value through an explicit indication of this trait. <br></li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">E</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">42</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span></span></code> </pre> <br><h3>  7. Non-blocking lazy values </h3><br>  In the current version of Scala, deferred initialization of values (lazy val) is implemented using the synchronization mechanism on the object in which it is contained.  This solution has the following disadvantages: <br><br><ul><li>  Additional costs of synchronization, which lose their meaning if the value is used by only one thread. <br></li><li>  The possibility of potential interlocking, for example: <br></li></ul><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a1 = <span class="hljs-type"><span class="hljs-type">B</span></span>.b1 <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> a2 = <span class="hljs-number"><span class="hljs-number">42</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b1 = <span class="hljs-type"><span class="hljs-type">A</span></span>.a2 }</code> </pre> <br>  If the two threads simultaneously begin to initialize the values of a1 and b1, they get a lock on objects A and B, respectively.  Since the initialization of b1 requires the value of a2, which has not yet been initialized in object A, the second thread waits to release the lock on object A, keeping the lock on object B. At the same time, the first thread needs to access the b1 field, but it is in turn unavailable because of the blocking by the second thread of object B. As a result, we had a deadlock, or Deadlock.  (This example is taken <a href="https://www.youtube.com/watch%3Fv%3DaftdOFuVU1o">from the report of Dmitry Petrashko</a> ) <br><br>  The Dotty for lazy values canceled thread-safe initialization.  In the case where secure publication of a value is required for use by multiple threads, this variable should be annotated as <pre>  @volatile </pre><br><pre> <code class="scala hljs"><span class="hljs-meta"><span class="hljs-meta">@volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = {... some initialization code }</code> </pre> <br><h3>  8. Enumerations </h3><br>  Dotty has made support for enum types.  The syntax for their definition was made by analogy with Java. <br><br><pre> <code class="scala hljs">enum <span class="hljs-type"><span class="hljs-type">Color</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Red</span></span>, <span class="hljs-type"><span class="hljs-type">Green</span></span>, <span class="hljs-type"><span class="hljs-type">Blue</span></span> }</code> </pre> <br>  Enumeration support is implemented at the source code parsing level.  At this stage, the enum construction is converted to the following form. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">$new</span></span></span></span>(tag: <span class="hljs-type"><span class="hljs-type">Int</span></span>, name: <span class="hljs-type"><span class="hljs-type">String</span></span>) = {   <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">Color</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> enumTag = tag     <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-function"> </span></span>= name     <span class="hljs-comment"><span class="hljs-comment">//       } } val Red = $new(0, "Red") val Green = $new(1, "Green") val Blue = $new(2, "Blue") }</span></span></code> </pre> <br>  As in Java, the Dotty enumerated type also supports parameters: <br><br><pre> <code class="scala hljs">enum <span class="hljs-type"><span class="hljs-type">Color</span></span>(code: <span class="hljs-type"><span class="hljs-type">Int</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Red</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-type"><span class="hljs-type">Color</span></span>(<span class="hljs-number"><span class="hljs-number">0xFF0000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Green</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-type"><span class="hljs-type">Color</span></span>(<span class="hljs-number"><span class="hljs-number">0x00FF00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-type"><span class="hljs-type">Blue</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-type"><span class="hljs-type">Color</span></span>(<span class="hljs-number"><span class="hljs-number">0x0000FF</span></span>) }</code> </pre> <br>  Thus, enumerated types possess all the properties of sealed hierarchies of case classes.  In addition, enumerated types allow you to get a value by name, by index, or a collection of all valid values. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> green = <span class="hljs-type"><span class="hljs-type">Color</span></span>.enumValue(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> blue = <span class="hljs-type"><span class="hljs-type">Color</span></span>.enumValueNamed(<span class="hljs-string"><span class="hljs-string">"Blue"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> allColors = <span class="hljs-type"><span class="hljs-type">Color</span></span>.enumValues</code> </pre> <br><h3>  9. Functional types for implicit parameters </h3><br>  In the current implementation of the Scala language, implicit (implicit) parameters of functions are the canonical way to represent the execution context. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">Int</span></span>, b: <span class="hljs-type"><span class="hljs-type">Int</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> context: <span class="hljs-type"><span class="hljs-type">Context</span></span>): <span class="hljs-type"><span class="hljs-type">Int</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = context.getInt(<span class="hljs-string"><span class="hljs-string">"some.configuration.parameter"</span></span>) a * x + b }</code> </pre> <br>  In this example, the context is passed implicitly, its value is taken from the so-called implicit scope. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> context: <span class="hljs-type"><span class="hljs-type">Context</span></span> = createContext() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = calculate(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)</code> </pre> <br>  Thus, each time we call the calculate function, we need to pass only the parameters a and b.  The compiler for each such call will substitute the value of context, taken from the corresponding implicit scope.  The main problem of the current approach is that in the case of a large number of functions that accept the same set of implicit parameters, they must be specified for each of these functions. <br><br>  In Dotty, a function that accepts implicit parameters can be represented as a type: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Contextual</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-type"><span class="hljs-type">Context</span></span> =&gt; <span class="hljs-type"><span class="hljs-type">T</span></span></code> </pre> <br>  By analogy with the usual functions that are implementations of the Function type, all implementations of the type implicit A =&gt; B will be a subtype of the following trait. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ImplicitFunction1</span></span></span><span class="hljs-class">[-</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T0</span></span></span><span class="hljs-class">, +</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class">] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Function1</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T0</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">R</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> x0: <span class="hljs-type"><span class="hljs-type">T0</span></span>): <span class="hljs-type"><span class="hljs-type">R</span></span> }</code> </pre> <br>  Dotty provides various definitions of the ImplicitFunction trait, depending on the number of arguments, up to and including 22. <br><br>  Thus, using the Contextual type, we can override the function calculate as follows: <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">context</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Contextual</span></span>[<span class="hljs-type"><span class="hljs-type">Context</span></span>] = implicitly[<span class="hljs-type"><span class="hljs-type">Context</span></span>]</code> </pre> <br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">calculate</span></span></span></span>(a: <span class="hljs-type"><span class="hljs-type">Int</span></span>, b: <span class="hljs-type"><span class="hljs-type">Int</span></span>): <span class="hljs-type"><span class="hljs-type">Contextual</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = context.getInt(<span class="hljs-string"><span class="hljs-string">"some.configuration.parameter"</span></span>) a * x + b }</code> </pre> <br>  Here we define a special function def context, which we get the necessary Context from the environment.  Thus, the body of the calculate function has not changed much, except for the fact that context is now outside the brackets, and now it does not need to be declared in each function. <br><br><h2>  What is not included in Dotty </h2><br>  At the end of the review I will tell about those elements that have been removed from the language.  As a rule, the need for them disappeared after the introduction of new, more convenient structures or their implementation became more problematic and began to cause conflicts, so it turned out that they were easier to remove. <br><br>  Over time, Dotty will become the basis for the new version of the Scala language, and the version number will most likely be already 3.xx. This means that backward compatibility with previous versions of 2.x.x will not be provided.  However, the Dotty development team promises that special tools will be developed that will facilitate the transition from version 2.x.x to 3.x.x. <br><br><h3>  1. Projection types </h3><br>  Projection types (type projections) are constructions of the form T # A, where T can be any type, and A is a type field of type T. For example: <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">A</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun1</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">Any</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun2</span></span></span></span>(x: <span class="hljs-type"><span class="hljs-type">T</span></span>#<span class="hljs-type"><span class="hljs-type">A</span></span>): <span class="hljs-type"><span class="hljs-type">Any</span></span> }</code> </pre> <br>  Suppose we have two variables defined: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> t1: <span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">T</span></span> {  } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> t2: <span class="hljs-type"><span class="hljs-type">T</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">T</span></span> {  }</code> </pre> <br>  In this case, the argument of the fun1 method at t1 can be only the value of t1.a, but not t2.a.  The argument of the fun2 method can be either t1.a or t2.a, since the argument of the method is defined as any value of the type-A field of the T type. <br><br>  This design was excluded, as it is not stable and can lead to collisions when crossing types.  For example, the code below will compile, but will result in a ClassCastException at runtime (taken <a href="https://github.com/lampepfl/dotty/issues/1050">from here</a> ): <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">C</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&gt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Any</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">U</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">C</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Nothing</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">X</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">T</span></span> &amp; <span class="hljs-type"><span class="hljs-type">U</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>(args: <span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]) = {   <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: <span class="hljs-type"><span class="hljs-type">X</span></span>#<span class="hljs-type"><span class="hljs-type">A</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> z: <span class="hljs-type"><span class="hljs-type">String</span></span> = y } }</code> </pre> <br>  Instead of type projections it is proposed to use dependent types (path-dependent types) or implicit parameters. <br><br><h3>  2. Existential types </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existential types show that there is some unknown type that is a parameter for another type. </font><font style="vertical-align: inherit;">The value of this type does not interest us, the fact that it exists is simply important to us.</font></font> Hence the name.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This type of type has been added to Scala primarily to ensure compatibility with parameterized mask (wildcard) types in Java. </font><font style="vertical-align: inherit;">For example, any collection in Java is parameterized, and in case we are not interested in the type of the parameter, we can set it through the mask as follows:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Iterable</span></span>&lt;?&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> if we are not interested in the type of the parameter, but we know that restrictions are imposed on it, then in this case the type is defined as: </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Iterable</span></span>&lt;? <span class="hljs-keyword"><span class="hljs-keyword">extends</span></span> <span class="hljs-type"><span class="hljs-type">Comparable</span></span>&gt;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In Scala, these types will be defined as follows: </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Iterable</span></span>[<span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">forSome</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> } </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title"></span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forSome</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">&lt;</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">Comparable</span></span> } <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scala also has the ability to parameterize the type of mask: </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-type"><span class="hljs-type">Iterable</span></span>[_] <span class="hljs-comment"><span class="hljs-comment">//      Iterable[_ &lt;: Comparable] //     </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In recent versions, these forms of writing are fully equivalent, therefore the form X [T] forSome {type T} was decided to be abandoned, since it does not comply with the principles of DOT and entails additional difficulties in compiler development. </font><font style="vertical-align: inherit;">In general, the design forSome has not received wide distribution, as it is quite cumbersome. </font><font style="vertical-align: inherit;">Now practically everywhere where integration with types from Java is required, a construction with mask parameterization is used, which was decided to be left in Dotty.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3. Pre-initialization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Scala traits do not have parameters. </font><font style="vertical-align: inherit;">This created difficulties in the case when trait has a part of abstract parameters, on which some specific parameters depend. </font><font style="vertical-align: inherit;">Consider the following example:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: <span class="hljs-type"><span class="hljs-type">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = x * <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">C</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this case, the value of cb is 0, not 20, because, according to the initialization rules, the body of the trait is first initialized in Scala and only then the class. </font><font style="vertical-align: inherit;">At the time of initialization of the field b, the value for x is not yet defined, and therefore 0 is taken as the default value for the type Int. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve this problem Scala was introduced syntax pre-initialization. </font><font style="vertical-align: inherit;">With it, you can fix the bug in the previous example:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-type"><span class="hljs-type">A</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The disadvantage of this construction is that here one has to resort to an unobvious solution instead of just taking advantage of polymorphism. </font><font style="vertical-align: inherit;">With the introduction of parameters for traits, the need for preliminary initializers has disappeared, and now our example can be implemented in a simpler and more understandable way:</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">x: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> b = x * <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">10</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4. Delayed initialization </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Scala has a special trait for deferred initialization. </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DelayedInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedInit</span></span></span></span>(body: =&gt; <span class="hljs-type"><span class="hljs-type">Unit</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Classes that implement this trait, when initialized, call the method delayedInit, from which you can already call the initializer for the class using the body parameter: </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DelayedInit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delayedInit</span></span></span></span>(body: =&gt; <span class="hljs-type"><span class="hljs-type">Unit</span></span>): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = {   println(<span class="hljs-string"><span class="hljs-string">"This is delayedInit body"</span></span>)   body } println(<span class="hljs-string"><span class="hljs-string">"This is class body"</span></span>) }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, when we create a new Test object, we get the following output: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a delayedInit body </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is a class body </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Trait DelayedInit declared as Deprecated in Scala. </font><font style="vertical-align: inherit;">In Dotty, it was completely excluded from the library due to the fact that traits can now be parameterized. </font><font style="vertical-align: inherit;">Thus, using call-by-name semantics, similar behavior can be achieved.</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Delayed</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">body: =&gt; </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Unit</span></span></span></span></span><span class="hljs-class">) </span></span>{ println(<span class="hljs-string"><span class="hljs-string">"This is delayed body"</span></span>) body } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Delayed</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">println("</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">This</span></span></span></span><span class="hljs-class"><span class="hljs-params"> is class"</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similarly, when creating a new Test, the output will be: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is delayed body </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is class</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Procedural syntax </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To unify the declaration of functions, it was decided to abandon the procedural syntax for defining functions that have a return type of Unit. </font><font style="vertical-align: inherit;">So instead</font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>(args: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]) { <span class="hljs-comment"><span class="hljs-comment">//Method body }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> now you need to write </font></font><br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span></span>(args: <span class="hljs-type"><span class="hljs-type">List</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Unit</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//Method body }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is worth noting that many IDEs, in particular in IntelliJ IDEA, now automatically replace the procedural syntax with the functional one. </font><font style="vertical-align: inherit;">In Dotty, it was abandoned at the compiler level.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, Dotty offers fairly simple and interesting solutions to long-overdue problems that arise when developing on Scala. For example, in my practice I somehow came across the need to write a method that had to accept several types of objects that were not connected through the inheritance hierarchy as input. It was necessary to use Any as the type for the argument followed by the pattern matching. Dotty could solve this problem by combining types. In addition, I also lack the parameters for traits. In some cases, they would be very helpful. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the Scala community, judging by the reports at the conference, they are also waiting for the release of Dotty. In particular, in one report devoted to the </font><a href="http://akka.io/"><font style="vertical-align: inherit;">akka</font></a><font style="vertical-align: inherit;"> framework</font></font><a href="http://akka.io/"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, they said that it would be possible to make the actors typed, specifying the type of parameters in the receive method, which unites all messages. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dotty can already be tried: on </font></font><a href="http://dotty.epfl.ch/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Dotty website</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> there are instructions on how to install and configure it. However, the authors do not recommend using it in an industrial code, as it is still unstable. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">About the author</font></font></b></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> My name is Alexander Tokarev, and I have been developing server software for over 10 years. I started as a PHP developer, then switched to Java and recently switched to Scala. Since 2015 I work in the company </font></font><a href="http://cleverdata.ru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">CleverDATA</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">where Scala is one of the main development languages, along with Java and Python. </font><font style="vertical-align: inherit;">We use Scala primarily to develop processes for processing large amounts of data using Apache Spark, as well as to build highly loaded REST services for interaction with external systems based on Akka Streams. </font></font><br><br> <i><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Additional materials</font></font></b></i> <br><br><ol><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Martin Oderski report at Scala Days Copenhagen conference, May 2017: </font></font><a href="https://www.youtube.com/watch%3Fv%3D9lWrt6H6UdE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Video</font></font></a></i> <br></li><li> <i><a href="https://www.scala-lang.org/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The official website of the language Scala</font></font></a></i> <br></li><li> <i><a href="http://dotty.epfl.ch/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The official site of the project Dotty</font></font></a></i> <br></li><li> <i><a href="https://en.wikipedia.org/wiki/Scala_(programming_language)"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in Wikipedia about the Scala language</font></font><br></i> </li><li> <a href="https://infoscience.epfl.ch/record/215280/files/paper_1.pdf"><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">DOT calculus</font></font></i></a> <br></li><li> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Article </font></font><a href="http://www.scala-lang.org/blog/2016/02/03/essence-of-scala.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The essence of Scala</font></font></a></i> <br></li><li> <i><a href="https://www.youtube.com/watch%3Fv%3DspjkUL-WMOE"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Martin Oderski report</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> about DOT on YOW! </font><font style="vertical-align: inherit;">Nights, February 2017</font></font></i> </li><li> <i><a href="https://www.youtube.com/watch%3Fv%3DaftdOFuVU1o"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Report by Dmitry Petrashko</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , one of the developers of Dotty</font></font><br></i> </li><li> <i><a href="https://infoscience.epfl.ch/record/222780%3Fln%3Den"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Higher-Kinded types</font></font></a></i> <br></li><li> <i><a href="https://www.scala-lang.org/blog/2016/12/07/implicit-function-types.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Implicit function types</font></font></a></i> <br></li></ol></div><p>Source: <a href="https://habr.com/ru/post/334018/">https://habr.com/ru/post/334018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../334006/index.html">How the advertising network Vungle tries to make life difficult for its customers</a></li>
<li><a href="../334008/index.html">FIAS is dead, long live ... long live ... yes it is not clear that for now</a></li>
<li><a href="../334010/index.html">Runtime repainting application</a></li>
<li><a href="../334012/index.html">Release CLion 2017.2: integration with Clang-Tidy, C ++ 17 in the wizard to create a new project, improving the performance of the IDE</a></li>
<li><a href="../334016/index.html">Resolving PTRACE_ATTACH Restriction Issues in Docker Containers</a></li>
<li><a href="../334020/index.html">Piracy and four currencies</a></li>
<li><a href="../334022/index.html">Confederations Cup: what is behind the smooth connection at the stadium</a></li>
<li><a href="../334024/index.html">Extreme Networks 802.11ac Wave 2  new generation wireless solutions</a></li>
<li><a href="../334026/index.html">Zimbra - Teamwork</a></li>
<li><a href="../334028/index.html">GHC 8.2 released</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>