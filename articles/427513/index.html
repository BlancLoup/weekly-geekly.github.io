<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to analyze Thread Dump</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="There are a lot of topics on the internals of the JVM in the Java Developer course program. We understand the mechanisms of collections, bytecode, gar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to analyze Thread Dump</h1><div class="post__text post__text-html js-mediator-article">  <i>There are a lot of topics on the internals of the JVM in the <a href="https://otus.pw/YXS8/">Java Developer</a> course program.</i>  <i>We understand the mechanisms of collections, bytecode, garbage collection, etc.</i>  <i>Today we offer your heed a translation of a rather interesting article on thread dump.</i>  <i>What it is, how to get it and how to use it.</i> <br><br>  Want to learn how to analyze a thread dump?  Come under the cat to learn more about how to get thread dump in Java and what to do with it then. <br><a name="habracut"></a><br>  Most modern Java applications are multi-threaded.  Multithreading can significantly expand the functionality of the application, at the same time it introduces significant complexity. <br><br>  In a single-threaded application, all resources (shared memory, input / output operations, etc.) can be used without synchronization, since  at any time, only one thread uses the resource. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the case of multi-threaded applications, it is necessary to find a compromise between the complexity of the program and the possible performance improvement, when several threads can use all available (often more than one) cores of the central processing unit (CPU).  If you do everything right, then using multithreading (formalized in <a href="https://en.wikipedia.org/wiki/Amdahl%2527s_law">Amdahl's Law</a> ), you can achieve a significant increase in application performance.  However, it should be remembered about ensuring synchronous access of several threads to a shared resource.  In most cases, frameworks such as Spring encapsulate work with threads and hide many technical details from users.  However, in the case of the use of modern complex frameworks, something can go wrong, and we, as users, will encounter difficult-to-solve multi-threading bugs. <br><br>  Fortunately, Java is equipped with a special mechanism for obtaining information about the current state of all threads at any given time - this is a thread dump (a kind of snapshot).  In this article, we will learn how to get a thread dump for an application of realistic dimensions and how to analyze this dump. <br><br>  It is assumed that the reader has basic information about multi-threaded programming and is aware of the problems of thread synchronization and the use of shared resources.  Nevertheless, it will not be superfluous to brush up on some basic terms and concepts. <br><br><h4>  Basic terminology </h4><br>  At first glance, Java thread dumps may seem like a ‚ÄúChinese letter‚Äù, the key to which I understand is the following concepts.  In general, let's repeat the main terms of multithreading, which we will use for the analysis of dumps. <br><br><ul><li>  <strong>Thread</strong> or thread is a discrete unit of multithreading driven by a Java Virtual Machine (JVM).  JVM threads correspond to threads in the operating system (OS) - native threads (‚Äúnatural flows‚Äù), which implement the mechanism for executing code. <br><br>  Each thread has a unique identifier and name.  Streams can be "demons" and "not demons." <br><br>  The program ends its work when all non-daemons threads are terminated or the <i>Runtime.exit</i> method is <i>called</i> .  Working "demons" do not affect the completion of the program.  Those.  JVMs are waiting for all the ‚Äúnon-demons‚Äù to be completed and the work is completed; the ‚Äúnon-demons‚Äù pays no attention. <br><br>  For more information, see the documentation for the <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Thread.html">class Thread</a> . <br>  A thread can be in one of the following states: <br><br><ul><li>  <strong>Alive thread</strong> or ‚Äúlive‚Äù is a thread that does some work (normal state). </li><li>  <strong>Blocked thread</strong> or ‚Äúblocked‚Äù - a stream that tried to enter the synchronization section (synchronized), however, another stream has already managed to enter this block first, and all the following streams that try to enter the same block turn out to be blocked. </li><li>  <strong>Waiting thread</strong> or ‚Äúwaiting‚Äù is the thread that called the <i>wait</i> method (possibly with a timeout indication) and is now waiting for another method to execute <i>notify</i> or <i>nonifyAll</i> on the same object. <br><br>  Note that the thread is not considered "waiting" if it has called a wait with a timeout and this timeout has expired. </li><li>  <strong>Sleeping thread</strong> or "sleeping" - a thread that is not currently running, because  performed the Thread.sleep method (indicating the duration of the "sleep"). </li></ul></li><li>  <strong>Monitor</strong> is the mechanism used in the JVM to provide multi-threaded access to a single object.  The mechanism is started using the special <i>synchronized keyword</i> . <br><br>  Each object in Java has a monitor with which the stream can synchronize, i.e.  set a lock, which guarantees that no other thread will gain access to this object until the lock is released, i.e.  thread - lock owner will not exit <i>synchronized</i> block. <br><br>  For more information, see the <a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html">Synchronization section (17.1) of the Java Langauge Specification (JLS)</a> . <br></li><li>  <strong>Deadlock</strong> is a situation in which a thread, say A, blocks a resource, it needs another resource that is blocked by another thread, say B. Stream B does not release this resource, because  to complete a certain operation, it needs a resource that is blocked by stream A. It turns out that stream A is waiting for the resource to be unlocked by thread B, which is waiting for the unlocking of another resource by stream A. And thus, the threads are waiting for each other.  As a result, the whole program ‚Äúhangs‚Äù and waits for the threads to somehow unlock and continue working.  Mutual blocking can have many threads.  This problem is well known as the <a href="https://en.wikipedia.org/wiki/Dining_philosophers_problem">‚ÄúProblem of the Dining Philosophers‚Äù</a> . <br><br><img src="https://habrastorage.org/webt/8t/ll/jb/8tlljb_n-e80_dk_0uayobgil_s.png"><br></li><li>  <strong>Livelock</strong> is a situation where flow A causes flow B to perform some action, which in turn results in execution A of the original action, which once again causes the action of flow B. A cyclical relationship is obtained.  This can be imagined as a dog running after its tail.  Similar to <i>Deadlock</i> , in the Livelock situation, the program does not make progress, i.e.  does not perform a useful action, however, in this situation, threads are not blocked. <br></li></ul><br>  The terminology presented is not exhaustive for describing the world of multithreading, but this is enough to begin analyzing thread dumps. <br><br>  More detailed information can be found in these sources: <br><br>  <a href="https://docs.oracle.com/javase/specs/jls/se10/html/jls-17.html">Section 17 of the JLS</a> and <a href="https://www.amazon.com/Java-Concurrency-Practice-Brian-Goetz/dp/0321349601/ref%3Dsr_1_2%3Fie%3DUTF8%26qid%3D1529361763%26sr%3D8-2%26keywords%3Djava%2Bconcurrency%2Bin%2Bpractice">Java Concurrency in Practice</a> <br><br>  By applying these simple notions about flow in Java, we can create a test application.  For this application we will collect thread dump.  The resulting dump will analyze and extract useful information about the current flows of the application. <br><br><h4>  Creating an example program </h4><br>  Before creating a thread dump, we need to develop a Java application.  The traditional ‚Äúhello, world!‚Äù Is too simple for our purpose, and a medium sized application dump may be too difficult to demonstrate.  Based on this, we will create a fairly simple application in which two streams are created.  And the threads get into the deadlock: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceB, resourceA)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span>(secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  This program creates two resources: resourceA and resourceB, and starts two threads: threadLockingResourceAFirst and threadLockingResourceBFirst, which block each other‚Äôs resources. <br><br>  The cause of the deadlock is a "cross" blocking of resources by threads. <br><br>  The cause of the deadlock is an attempt to "mutual" capture of resources, i.e.  thread threadLockingResourceAFirst captures resource resourceA, thread threadLockingResourceBFirst captures resource resourceB.  After that, the thread threadLockingResourceAFirst, without releasing its resource, tries to grab resourceB, and the thread threadLockingResourceBFirst, without releasing its resource, tries to grab resource ResourceA.  As a result, threads are blocked.  A 1s delay is added to ensure blocking occurs.  Streams are waiting for the release of the necessary resources, but this will never happen. <br><br>  The output of the program will be as follows (the numbers after java.lang.Object @ will be different for each launch): <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">Thread-0</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">locked</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">resource</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">java</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.lang</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Object</span></span>@<span class="hljs-keyword"><span class="hljs-keyword">149bc794</span></span> Thread-<span class="hljs-number"><span class="hljs-number">1</span></span>: locked resource -&gt; java.lang.Object@<span class="hljs-number"><span class="hljs-number">17</span></span>c10009</code> </pre> <br>  After the output of these messages, the program will look like working (the process that executes this program is not completed), while the program does not perform any work.  This is how deadlock looks like in practice.  To solve the problem, we need to manually create a tread dump and analyze the state of the threads. <br><br><h4>  Thread Dump Generation </h4><br>  In practice, a Java program can crash and create a thread dump.  However, in some cases (for example, in the case of deadlocks), the program does not terminate and the thread dump does not create, it just hangs.  To create a dump of such hung programs, first of all you need to find out the program process ID, i.e.  Process ID (PID).  To do this, you can use the JVM Process Status (JPS) utility, which, since version 7, is part of the Java Development Kit (JDK).  To find the PID process of our hung program, we simply execute jps in the terminal (Windows or Linux): <br><br><pre> <code class="hljs ruby">$ jps <span class="hljs-number"><span class="hljs-number">11568</span></span> DeadlockProgram <span class="hljs-number"><span class="hljs-number">15584</span></span> Jps <span class="hljs-number"><span class="hljs-number">15636</span></span></code> </pre> <br>  The first column is the local virtual machine identifier (Local VM ID, i.e. lvmid) for the running Java process.  In the context of the local JVM, lvmid points to the PID of the Java process. <br><br>  It should be noted that this value is likely to differ from the value above.  The second column is the name of the application, which may indicate the name of the main class, jar file or be equal to ‚ÄúUnknown‚Äù  It all depends on how the application was launched. <br><br>  In our case, the application name DeadlockProgram is the name of the main classes that was launched when the program started.  In the example above, the PID of the program is 11568, this information is enough to generate a thread dump.  To generate a dump, we will use the <strong>jstack</strong> utility, which is included in the JDK, starting with version 7. To get the dump, we will pass in the <strong>jstack</strong> as the PID parameter of our program and specify the -l flag (create a long listing).  The utility output is redirected to a text file, i.e.  thread_dump.txt: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">jstack</span></span> -l <span class="hljs-number"><span class="hljs-number">11568</span></span> &gt; thread_dump.txt</code> </pre> <br>  The resulting thread_dump.txt file contains a thread dump of our hung program and contains important information for diagnosing the causes of the deadlock. <br><br>  If you use JDK up to version 7, then you can use the Linux utility - <strong>kill</strong> with the -3 flag to generate a dump.  Calling kill -3 will send a SIGQUIT signal to the program. <br><br>  In our case, the call will be like this: <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> <span class="hljs-number"><span class="hljs-number">-3</span></span> <span class="hljs-number"><span class="hljs-number">11568</span></span></code> </pre> <br><h4>  Analysis of simple thread dump </h4><br>  Opening the file thread_dump.txt, we will see something like the following content: <br><br><pre> 2018-06-19 16:44:44
 Full thread dump Java HotSpot (TM) 64-Bit Server VM (10.0.1 + 10 mixed mode):
 Threads class SMR info:
 _java_thread_list = 0x00000250e5488a00, length = 13, elements = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
 "Reference Handler" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 waiting on condition [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     at java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     at java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     at java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     at java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Locked ownable synchronizers:
     - None
 "Finalizer" # 3 daemon prio = 8 os_prio = 1 tid = 0x00000250e4982800 nid = 0x2a54 in Object.wait () [0x000000b82aaff000]
    java.lang.Thread.State: WAITING (on object monitor)
     at java.lang.Object.wait (java.base@10.0.1/Native Method)
     - waiting on &lt;0x0000000089509410&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     at java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - waiting for re-lock in wait () &lt;0x0000000089509410&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     at java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 172)
     at java.lang.ref.Finalizer $ FinalizerThread.run (java.base@10.0.1/Finalizer.java: 216)
    Locked ownable synchronizers:
     - None
 "Signal Dispatcher" # 4 daemon prio = 9 os_prio = 2 tid = 0x00000250e52f2800 nid = 0x2184 runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Locked ownable synchronizers:
     - None
 "Attach Listener" # 5 daemon prio = 5 os_prio = 2 tid = 0x00000250e4992800 nid = 0x1624 waiting on condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Locked ownable synchronizers:
     - None
 "C2 CompilerThread0" # 6 daemon prio = 9 os_prio = 2 tid = 0x00000250e4995800 nid = 0x4198 waiting on condition [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    No compile task
    Locked ownable synchronizers:
     - None
 "C2 CompilerThread1" # 7 daemon prio = 9 os_prio = 2 tid = 0x00000250e49a5800 nid = 0x3b98 waiting on condition [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    No compile task
    Locked ownable synchronizers:
     - None
 "C1 CompilerThread2" # 8 daemon prio = 9 os_prio = 2 tid = 0x00000250e49ae800 nid = 0x1a84 waiting on condition [0x000000000000000000]
    java.lang.Thread.State: RUNNABLE
    No compile task
    Locked ownable synchronizers:
     - None
 "Sweeper thread" # 9 daemon prio = 9 os_prio = 2 tid = 0x00000250e5324000 nid = 0x5f0 runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Locked ownable synchronizers:
     - None
 "Service Thread" # 10 daemon prio = 9 os_prio = 0 tid = 0x00000250e54cd800 nid = 0x169c runnable [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Locked ownable synchronizers:
     - None
 Common cleaner # 11 daemon prio = 8 os_prio = 1 tid = 0x00000250e54cf000 nid = 0x1610 in Object.wait () [0x000000b82b2fe000]
    java.lang.Thread.State: TIMED_WAITING (on object monitor)
     at java.lang.Object.wait (java.base@10.0.1/Native Method)
     - waiting on &lt;0x000000008943e600&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     at java.lang.ref.ReferenceQueue.remove (java.base@10.0.1/ReferenceQueue.java: 151)
     - waiting for re-lock in wait () &lt;0x000000008943e600&gt; (a java.lang.ref.ReferenceQueue $ Lock)
     at jdk.internal.ref.CleanerImpl.run (java.base@10.0.1/CleanerImpl.java: 148)
     at java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
     at jdk.internal.misc.InnocuousThread.run (java.base@10.0.1/InnocuousThread.java: 134)
    Locked ownable synchronizers:
     - None
 "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec waiting for monitor entry [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (on object monitor)
     at DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - waiting to lock &lt;0x00000000894465b0&gt; (a java.lang.Object)
     - locked &lt;0x00000000894465a0&gt; (a java.lang.Object)
     at java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Locked ownable synchronizers:
     - None
 "Thread-1" # 13 prio = 5 os_prio = 0 tid = 0x00000250e54d2000 nid = 0x415c waiting for monitor entry [0x000000b82b5ff000]
    java.lang.Thread.State: BLOCKED (on object monitor)
     at DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - waiting to lock &lt;0x00000000894465a0&gt; (a java.lang.Object)
     - locked &lt;0x00000000894465b0&gt; (a java.lang.Object)
     at java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Locked ownable synchronizers:
     - None
 "DestroyJavaVM" # 14 prio = 5 os_prio = 0 tid = 0x00000250e54d0800 nid = 0x2b8c waiting on condition [0x0000000000000000]
    java.lang.Thread.State: RUNNABLE
    Locked ownable synchronizers:
     - None
 "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 runnable  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c runnable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 runnable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 runnable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 runnable  
 "G1 Main Marker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 runnable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 runnable  
 "G1 Refine # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c runnable  
 "G1 Refine # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 runnable  
 "G1 Refine # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 runnable  
 "G1 Refine # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 runnable  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 runnable  
 "VM Periodic Task Thread" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 waiting on condition  
 JNI global references: 2
 Found one java-level deadlock:
 =============================
 "Thread-0":
   monitor 0x00000250e4982480 (object 0x00000000894465b0, a java.lang.Object) waiting for lock
   which is held by "Thread-1"
 "Thread-1":
   monitor 0x00000250e4982380 (object 0x00000000894465a0, a java.lang.Object),
   which is held by "Thread-0"
 Java stack information listed above:
 ================================================= =
 "Thread-0":
     at DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - waiting to lock &lt;0x00000000894465b0&gt; (a java.lang.Object)
     - locked &lt;0x00000000894465a0&gt; (a java.lang.Object)
     at java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     at DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - waiting to lock &lt;0x00000000894465a0&gt; (a java.lang.Object)
     - locked &lt;0x00000000894465b0&gt; (a java.lang.Object)
     at java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Found 1 deadlock.
</pre><br><h3>  Introductory Information </h3><br>  Although at first glance this file may seem too complicated and confusing, in reality it is quite simple, if you take it apart in parts, step by step. <br><br>  The first line indicates the time when the dump was generated, the second - the diagnostic information about the JVM, on which the dump was received: <br><br><pre> <code class="hljs css">2018<span class="hljs-selector-tag"><span class="hljs-selector-tag">-06-19</span></span> 16<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:44</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Full</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">thread</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">dump</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Java</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">HotSpot</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">TM</span></span>) 64<span class="hljs-selector-tag"><span class="hljs-selector-tag">-Bit</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">Server</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">VM</span></span> (10<span class="hljs-selector-class"><span class="hljs-selector-class">.0</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.1</span></span>+10 <span class="hljs-selector-tag"><span class="hljs-selector-tag">mixed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">mode</span></span>):</code> </pre> <br>  There is no thread information in this section.  This sets the general context of the system in which the dump was collected. <br><br><h4>  General flow information </h4><br>  The next section provides information about the threads that were running in the system at the time of the dump: <br><br><pre> Threads class SMR info:
 _java_thread_list = 0x00000250e5488a00, length = 13, elements = {
 0x00000250e4979000, 0x00000250e4982800, 0x00000250e52f2800, 0x00000250e4992800,
 0x00000250e4995800, 0x00000250e49a5800, 0x00000250e49ae800, 0x00000250e5324000,
 0x00000250e54cd800, 0x00000250e54cf000, 0x00000250e54d1800, 0x00000250e54d2000,
 0x00000250e54d0800
 }
</pre><br>  The following section lists: <br><br>  <a href="https://ieeexplore.ieee.org/document/1291819/">Safe Memory Reclamation (SMR) information</a> <br><br>  It contains information about threads outside the JVM, i.e.  these are not virtual machine threads or garbage collector threads.  If you look at the addresses of these streams, you can see that they correspond to the value of the <i>tid</i> - ‚Äúnatural, iron‚Äù (native) address in the operating system, not the Thread ID. <br><br>  Triplets are used to hide unnecessary information: <br><br><pre> "Reference Handler" # 2 ... tid = 0x00000250e4979000 ...
 "Finalizer" # 3 ... tid = 0x00000250e4982800 ...
 "Signal Dispatcher" # 4 ... tid = 0x00000250e52f2800 ...
 "Attach Listener" # 5 ... tid = 0x00000250e4992800 ...
 "C2 CompilerThread0" # 6 ... tid = 0x00000250e4995800 ...
 "C2 CompilerThread1" # 7 ... tid = 0x00000250e49a5800 ...
 "C1 CompilerThread2" # 8 ... tid = 0x00000250e49ae800 ...
 "Sweeper thread" # 9 ... tid = 0x00000250e5324000 ...
 "Service Thread" # 10 ... tid = 0x00000250e54cd800 ...
 Common Cleaner # 11 ... tid = 0x00000250e54cf000 ...
 "Thread-0" # 12 ... tid = 0x00000250e54d1800 ...
 "Thread-1" # 13 ... tid = 0x00000250e54d2000 ...
 "DestroyJavaVM" # 14 ... tid = 0x00000250e54d0800 ...
</pre><br><h3>  Streams </h3><br>  Immediately after the SMR block follows a list of threads.  The first thread on our list is the Reference Handler: <br><br><pre> "Reference Handler" # 2 daemon prio = 10 os_prio = 2 tid = 0x00000250e4979000 nid = 0x3c28 waiting on condition [0x000000b82a9ff000]
    java.lang.Thread.State: RUNNABLE
     at java.lang.ref.Reference.waitForReferencePendingList (java.base@10.0.1/Native Method)
     at java.lang.ref.Reference.processPendingReferences (java.base@10.0.1/Reference.java: 174)
     at java.lang.ref.Reference.access $ 000 (java.base@10.0.1/Reference.java: 44)
     at java.lang.ref.Reference $ ReferenceHandler.run (java.base@10.0.1/Reference.java: 138)
    Locked ownable synchronizers:
     - None
</pre><br><h4>  Brief stream description </h4><br>  The first line for each stream provides a general description.  The description contains the following items: <br><table><tbody><tr><th width="70">  Section </th><th width="100">  Example </th><th>  Description </th></tr><tr><td>  Name </td><td>  "Reference Handler" </td><td>  The human-readable name of the thread.  The name can be set by calling the <i>Thread</i> object's <i>setName</i> method.  And get through a call to <i>getName</i> </td></tr><tr><td>  ID </td><td>  # 2 </td><td>  Unique ID assigned to each object of class <i>Thread</i> .  An ID is generated for threads in the system.  The initial value is 1. Each newly created thread is assigned its own ID, previously increased by 1. This property of the ‚Äúread-only‚Äù stream can be obtained using the <i>getId</i> function of the object of the class <i>Thread</i> . </td></tr><tr><td>  Daemon status </td><td>  daemon </td><td>  The flag is a sign that the thread is a daemon.  If it is a demon, then the flag will be set.  For example, <i>Thread-0 is</i> not a daemon. </td></tr><tr><td>  Priority </td><td>  prio = 10 </td><td>  The numeric priority of the java stream.  Note that this priority does not necessarily correspond to the priority of the associated thread in the operating system.  To set the priority you can <br>  use the <i>setPriority</i> method of <i>an</i> object of class <i>Thread</i> , and to get <br>  method <i>getPriority</i> . </td></tr><tr><td>  OS Thread Priority </td><td>  os_prio = 2 </td><td>  The priority of the thread in the operating system.  This priority may differ from the one assigned to the coherent java stream. </td></tr><tr><td>  Address </td><td>  tid = 0x00000250e4979000 </td><td>  Java stream address  This address is a pointer to a <a href="https://en.wikipedia.org/wiki/Java_Native_Interface" rel="nofollow">Java Native Interface (JNI)</a> native object of class <i>Thread</i> (a C ++ <i>Thread</i> object that is associated with a Java stream via JNI).  This value is obtained by casting a pointer to this. <br>  (a C ++ object that is associated with this Java stream) to integer.  Cm. <br>  <a href="">line 879 in hotspot / share / runtime / thread.cpp</a> : <br><pre> st-&gt; print ("tid =" INTPTR_FORMAT "", p2i (this));
</pre><br>  Although the key for this object ( <i>tid</i> ) may be similar to a stream ID, <br>  in fact, this is the address of the connected <i>JNI C ++ Thread</i> object, and this is not the value that <br>  returns the <i>getId</i> method of the Java <i>Thread</i> object. </td></tr><tr><td>  OS Thread ID </td><td>  nid = 0x3c28 </td><td>  The unique identifier for the operating system thread to which the Java thread is bound. <br>  This value is output by the following code: <br>  <a href="">line 42 in hotspot / share / runtime / osThread.cpp</a> : <br><pre> st-&gt; print ("nid = 0x% x", thread_id ());
</pre><br></td></tr><tr><td>  Status </td><td>  waiting on condition </td><td>  The human-readable status of the current thread. <br>  This line prints additional information to the simple status of the stream (see below), which can be <br>  used to understand what the thread was going to do (i.e., did the thread try to get the lock <br>  or waited for the unlock condition to be met). </td></tr><tr><td>  Last Known Java Stack Pointer </td><td>  [0x000000b82a9ff000] </td><td>  The last known pointer to the stack (SP) associated with this thread. <br>  This value is obtained using native C ++ code mixed with Java code using JNI.  The value returned by the function <i>last_Java_sp ()</i> , <br>  <a href="">line 2886 in hotspot / share / runtime / thread.cpp</a> : <br><pre>   st-&gt; print_cr ("[" INTPTR_FORMAT "]", 
     (intptr_t) last_Java_sp () &amp; ~ right_n_bits (12));
</pre><br>  For simple thread dumps, this information is almost useless.  However, in difficult cases, SP can <br>  be used to track locks. </td></tr></tbody></table><br><h4>  Flow condition </h4><br>  The second line is the current state of the stream.  Possible flow conditions are given in enum: <br>  <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Thread.State.html" rel="nofollow">Thread.State</a> : <br><br>  NEW <br>  RUNNABLE <br>  BLOCKED <br>  WAITING <br>  TIMED_WAITING <br>  TERMINATED <br><br>  For more information, see the <a href="https://docs.oracle.com/javase/10/docs/api/java/lang/Thread.State.html" rel="nofollow">documentation</a> . <br><br><h4>  Thread stack trace </h4><br>  The next section contains the stack trace trace at the time of the dump.  This stack trace is very similar to the trace that is generated by an uncaught exception.  It contains the names of the classes and lines that were executed at the time of the formation of the dump.  In the case of the Reference Handler stream, we see nothing interesting. <br><br>  However, there is something interesting in the trace of Thread-02 that differs from the standard trace: <br><br><pre> "Thread-0" # 12 prio = 5 os_prio = 0 tid = 0x00000250e54d1800 nid = 0xdec waiting for monitor entry [0x000000b82b4ff000]
    java.lang.Thread.State: BLOCKED (on object monitor)
     at DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - waiting to lock &lt;0x00000000894465b0&gt; (a java.lang.Object)
     - locked &lt;0x00000000894465a0&gt; (a java.lang.Object)
     at java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
    Locked ownable synchronizers:
     - None
</pre><br>  In the trace, we see that information about the blocking has been added.  This thread waits for a lock on the object with the address 0x00000000894465b0 (object type java.lang.Object).  Moreover, the thread itself holds the lock with the address 0x00000000894465a0 (also a java.lang.Object object).  This information is useful to us further for the diagnosis of deadlock. <br><br><h4>  Captured synchronization primitives (Ownable Synchronizer) </h4><br>  The last section provides a list of synchronization primitives captured by the stream.  These are objects that can be used to synchronize threads, for example, locks. <br><br>  According to the official Java documentation, <strong>Ownable Synchronizer</strong> is the heirs of the <i>AbstractOwnableSynchronizer</i> (or its subclass), which can be exclusively captured by the stream for synchronization purposes. <br><br>  <i>ReentrantLock</i> and <i>write-lock</i> , but not the <i>read-lock</i> class of the <i>ReentrantReadWriteLock</i> are two good examples of such ‚Äúownable synchronizers‚Äù offered by the platform. <br><br>  For more information on this, you can refer to this. <br>  <a href="https://stackoverflow.com/questions/41300520/what-is-locked-ownable-synchronizers-in-thread-dump" rel="nofollow">post</a> . <br><br><h4>  JVM threads </h4><br>  The next section of the dump contains information about JVM technical threads that are not part of the application and are associated with operating system threads.  Since  These threads work outside the application, they do not have thread identifiers.  Most often these are garbage collector streams and other technical JVM streams: <br><br><pre> "VM Thread" os_prio = 2 tid = 0x00000250e496d800 nid = 0x1920 runnable  
 "GC Thread # 0" os_prio = 2 tid = 0x00000250c35b5800 nid = 0x310c runnable  
 "GC Thread # 1" os_prio = 2 tid = 0x00000250c35b8000 nid = 0x12b4 runnable  
 "GC Thread # 2" os_prio = 2 tid = 0x00000250c35ba800 nid = 0x43f8 runnable  
 "GC Thread # 3" os_prio = 2 tid = 0x00000250c35c0800 nid = 0x20c0 runnable  
 "G1 Main Marker" os_prio = 2 tid = 0x00000250c3633000 nid = 0x4068 runnable  
 "G1 Conc # 0" os_prio = 2 tid = 0x00000250c3636000 nid = 0x3e28 runnable  
 "G1 Refine # 0" os_prio = 2 tid = 0x00000250c367e000 nid = 0x3c0c runnable  
 "G1 Refine # 1" os_prio = 2 tid = 0x00000250e47fb800 nid = 0x3890 runnable  
 "G1 Refine # 2" os_prio = 2 tid = 0x00000250e47fc000 nid = 0x32a8 runnable  
 "G1 Refine # 3" os_prio = 2 tid = 0x00000250e47fd800 nid = 0x3d00 runnable  
 "G1 Young RemSet Sampling" os_prio = 2 tid = 0x00000250e4800800 nid = 0xef4 runnable  
 "VM Periodic Task Thread" os_prio = 2 tid = 0x00000250e54d6800 nid = 0x3468 waiting on condition
</pre><br><h4>  JNI global links </h4><br>  This section indicates the number of global links used by the JVM via JNI.  These links are not served by the garbage collector and in certain circumstances may cause a memory leak. <br><br><pre> JNI global references: 2
</pre><br>  In most simple cases, this information is not used.  However, the importance of global links must be understood.  For more information, see this <a href="https://stackoverflow.com/questions/112603/what-is-jni-global-reference" rel="nofollow">post</a> . <br><br><h4>  Deadlocked streams </h4><br>  The last section contains information about deadlocks found. <br>  If these do not show up, then the section will be empty.  Since  We specifically developed an application with locks, in our case this section is there.  A lock was detected during dump generation and is represented by the following message: <br><br><pre> Found one java-level deadlock:
 =============================
 "Thread-0":
   monitor 0x00000250e4982480 (object 0x00000000894465b0, a java.lang.Object) waiting for lock
   which is held by "Thread-1"
 "Thread-1":
   monitor 0x00000250e4982380 (object 0x00000000894465a0, a java.lang.Object),
   which is held by "Thread-0"
 Java stack information listed above:
 ================================================= =
 "Thread-0":
     at DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - waiting to lock &lt;0x00000000894465b0&gt; (a java.lang.Object)
     - locked &lt;0x00000000894465a0&gt; (a java.lang.Object)
     at java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 "Thread-1":
     at DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)
     - waiting to lock &lt;0x00000000894465a0&gt; (a java.lang.Object)
     - locked &lt;0x00000000894465b0&gt; (a java.lang.Object)
     at java.lang.Thread.run (java.base@10.0.1/Thread.java: 844)
 Found 1 deadlock.
</pre><br>  The first subsection describes the deadlock scenario: <br><br>  Thread-0 expects the ability to capture the monitor (this is a call to the <i>synchronized (secondResource)</i> block in our application), at the same time, this thread is holding the monitor that is trying to capture the Thread-1 thread (this is the same code snippet: <i>synchronized (secondResource )</i> in our application). <br><br>  This circular lock is otherwise called <strong>deadlock</strong> .  The picture below <br>  This situation is presented graphically: <br><br><img src="https://habrastorage.org/webt/11/yd/kr/11ydkrm0xkbw8aqxb8t71kypskg.png"><br><br>  In the second section, the stack trace is given for both blocked threads. <br><br>  This stack trace allows us to follow the operation of each thread until a lock appears. <br>  In our case, if we look at the line: <br><br>  <i>at DeadlockProgram $ DeadlockRunnable.run (DeadlockProgram.java:34)</i> , then we will see the problem area of ‚Äã‚Äãthe code: <br><br><pre> printLockedResource (secondResource);
</pre><br>  This line is the first line of the synchronized block, which is the cause of the lock, and tells us that the synchronization on the secondResource is the cause of the interlocking.  To remedy the situation, we must ensure the same synchronization order on resourceA and resourceB in both flows.  If we do this, we will come to the following application: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockProgram</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ Object resourceA = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Object resourceB = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Object(); Thread threadLockingResourceAFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); Thread threadLockingResourceBFirst = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeadlockRunnable(resourceA, resourceB)); threadLockingResourceAFirst.start(); Thread.sleep(<span class="hljs-number"><span class="hljs-number">500</span></span>); threadLockingResourceBFirst.start(); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Runnable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object firstResource; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Object secondResource; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DeadlockRunnable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object firstResource, Object secondResource)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.firstResource = firstResource; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.secondResource = secondResource; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (firstResource) { printLockedResource(firstResource); Thread.sleep(<span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">synchronized</span></span> (secondResource) { printLockedResource(secondResource); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { System.out.println(<span class="hljs-string"><span class="hljs-string">"Exception occurred: "</span></span> + e); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printLockedResource</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object resource)</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(Thread.currentThread().getName() + <span class="hljs-string"><span class="hljs-string">": locked resource -&gt; "</span></span> + resource); } } }</code> </pre> <br>  This application will end without interlocking, and as a result we will get the following output (note that the addresses of instances of the Object class have changed): <br><br><pre> Thread-0: locked resource -&gt; java.lang.Object@1ad895d1
 Thread-0: locked resource -&gt; java.lang.Object@6e41d7dd
 Thread-1: locked resource -&gt; java.lang.Object@1ad895d1
 Thread-1: locked resource -&gt; java.lang.Object@6e41d7dd
</pre><br>  As a result, using only the information obtained from the thread dump, we were able to find the cause and fix the deadlock in our application.        (     deadlock-).      ,   . <br><br><h3>    Thread Dump- </h3><br>         . <br><br>   JVM       .         (     ,   ). <br><br>         . <br><br>       - ‚Äî Thread Dump Analyzers (TDAs).    Java thread dump-     - ,     .  ,           . ,        . <br><br>        TDA: <br><br><ul><li> <a href="http://fastthread.io/" rel="nofollow">fastThread</a> </li><li> <a href="https://spotify.github.io/threaddump-analyzer/" rel="nofollow">Spotify TDA</a> </li><li> <a href="https://www.ibm.com/developerworks/community/groups/service/html/communityview%3FcommunityUuid%3D2245aa39-fa5c-4475-b891-14c205f7333c" rel="nofollow">IBM Thread and Monitor Dump Analyze for Java</a> </li><li> <a href="https://github.com/irockel/tda" rel="nofollow">irockel TDA</a> </li></ul><br>        .               . <br><br><h4>  Conclusion </h4><br> Thread dump- ‚Äî      Java-,       .     ,           . <br><br>        deadlock,    .         .     ,           ‚Äî . <br><br>   ,   Java-     thread dump-.     ,             . <br><br> , thread dump ‚Äî   ¬´ ¬ª   ,        ,      Java-. <br><br> <i>   <a href="https://otus.pw/YXS8/"> Java</a>     .       ,        deadlock- .</i> <br><br> <i>      ,         <a href="https://otus.pw/o6hK/">   </a> .</i> </div><p>Source: <a href="https://habr.com/ru/post/427513/">https://habr.com/ru/post/427513/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../427499/index.html">What do they write to tech-support video streamer?</a></li>
<li><a href="../427501/index.html">Seymour Papert: Hard Fun</a></li>
<li><a href="../427505/index.html">Presumption of mind</a></li>
<li><a href="../427507/index.html">Seymour Papert: The Delightful Discovery of ‚ÄúNothing‚Äù</a></li>
<li><a href="../427509/index.html">Web servers: Southbridge experience and practice</a></li>
<li><a href="../427517/index.html">Review of the most interesting reports Joker 2018: version of EastBanc Technologies</a></li>
<li><a href="../427519/index.html">@Kubernetes Meetup in Mail.Ru Group: October 29th and always</a></li>
<li><a href="../427521/index.html">Breakthrough Prize 2019. Winners of the Milner, Brin and Zuckerberg Science Award announced</a></li>
<li><a href="../427523/index.html">Success hedge</a></li>
<li><a href="../427525/index.html">Intel Core 9th Gen in numbers and benchmarks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>