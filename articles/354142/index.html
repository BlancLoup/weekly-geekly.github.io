<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Difficulties of translation: how to find plagiarism from English in Russian scientific articles</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In our first article in the corporate blog of the company Antiplagiat on Habr√©, I decided to talk about how the algorithm for the search for transfera...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Difficulties of translation: how to find plagiarism from English in Russian scientific articles</h1><div class="post__text post__text-html js-mediator-article">  In our first article in the corporate blog of the company <a href="https://www.antiplagiat.ru/">Antiplagiat</a> on Habr√©, I decided to talk about how the algorithm for the search for transferable borrowings works.  A few years ago, the idea arose of making a tool for detecting translated and borrowed text from the original in English in Russian-language texts.  At the same time, it is important that this tool could work with a database of sources in billions of texts and withstand the usual peak load of Antiplagiat (200-300 texts per minute). <br><br><img src="https://habrastorage.org/webt/ml/lr/pj/mllrpjwflzrpxt65r2x-qyby4u8.png">  " <br><br>  During the 12 years of its operation, the Antiplagiat service has found borrowings in one language.  That is, if the user downloaded the text in Russian for verification, then we searched in Russian-language sources, if in English, then in English-language, etc. In this article I will talk about the algorithm we developed for detecting translational plagiarism, and that what cases of translated plagiarism could be found by testing this solution on the basis of Russian-language scientific articles. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I want to dot the i's: the article will deal only with those manifestations of plagiarism that are associated with the use of someone else‚Äôs text.  Everything connected with the theft of other people's inventions, ideas, thoughts, will remain outside the scope of the article.  In cases where we do not know how legitimate, correct or ethical such use was, we will say ‚Äútext borrowing‚Äù or ‚Äútext borrowing‚Äù.  The word "plagiarism" we use only when an attempt to give someone else‚Äôs text as your own is obvious and beyond doubt. <br><br>  We worked on this article together with <a href="https://habr.com/users/rita_kuznetsova/" class="user_link">Rita_Kuznetsova</a> and <a href="https://habr.com/users/oleg_bakhteev/" class="user_link">Oleg_Bakhteev</a> .  We decided that the images of Pinocchio and Buratino serve as an excellent illustration of the problem of finding plagiarism from foreign sources.  At once I will make a reservation that in no case do we accuse <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25BE%25D0%25BB%25D1%2581%25D1%2582%25D0%25BE%25D0%25B9,_%25D0%2590%25D0%25BB%25D0%25B5%25D0%25BA%25D1%2581%25D0%25B5%25D0%25B9_%25D0%259D%25D0%25B8%25D0%25BA%25D0%25BE%25D0%25BB%25D0%25B0%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2587">A.N. Tolstoy</a> of plagiarizing the ideas of <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BB%25D0%25BB%25D0%25BE%25D0%25B4%25D0%25B8,_%25D0%259A%25D0%25B0%25D1%2580%25D0%25BB%25D0%25BE">Carlo Collodi</a> . <br><br>  To begin with, I will briefly tell you how the "ordinary Anti-plagiarism" works.  We built our solution on the basis of the so-called.  ‚ÄúShingle algorithm‚Äù, which allows you to quickly find borrowing in very large collections of documents.  This algorithm is based on splitting the text of the document into small overlapping sequences of words of a certain length - shingly.  Usually used shingly length from 4 to 6 words.  For each shingle, a <a href="https://ru.wikipedia.org/wiki/%25D0%25A5%25D0%25B5%25D1%2588%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">hash</a> value is calculated.  The search index is formed as a sorted list of hash function values ‚Äã‚Äãwith the identifiers of the documents in which the corresponding shingles were encountered. <br><br>  The scanned document is also divided into shingly.  Then the index contains the documents with the highest number of shingle matches with the document being checked. <br>  This algorithm has successfully established itself in the search for borrowing in both English and Russian.  The search algorithm for shingles allows you to quickly find borrowed fragments, while it allows you to search not only completely copied text, but also borrowing with minor changes.  You can learn more about the task of detecting fuzzy text duplicates and how to solve them, for example, from an <a href="http://rcdl2007.pereslavl.ru/papers/paper_65_v1.pdf">article by Yu. Zelenkov and I. Segalovich</a> . <br><br>  As the ‚Äúalmost duplicate‚Äù search system developed, it became insufficient.  Many authors needed to quickly increase the percentage of originality of a document, or, in other words, to "deceive" the existing algorithm in one way or another and to obtain a higher percentage of originality.  Naturally, the most effective way that comes to mind is to rewrite the text in other words, that is, to rephrase it.  However, the main disadvantage of this method is that it takes too much time to implement.  Therefore, you need something more simple, but guaranteed to bring results. <br><br>  Borrowing from foreign sources comes to mind.  The rapid growth of modern technologies and the success of machine translation make it possible to obtain original work, which, at a quick glance, looks as if it was written independently (if you do not read carefully and do not look for machine translation errors, which, however, are easily corrected). <br><br>  Until recently, this kind of plagiarism could be detected only with a broad knowledge of the subject of work.  An automatic borrowing detection tool of this kind did not exist.  This is well illustrated by the case of the article <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2580%25D1%2587%25D0%25B5%25D0%25B2%25D0%25B0%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C_(%25D1%2581%25D1%2582%25D0%25B0%25D1%2582%25D1%258C%25D1%258F)">‚ÄúRooting: Algorithm of typical unification of access points and redundancy‚Äù</a> .  In fact, ‚ÄúRooting Machine‚Äù is a translation of the automatically generated article <a href="https://ru.wikipedia.org/wiki/SCIgen">‚ÄúRooter: A Methodology for the Typical Unification of Access Points and Redundancy‚Äù</a> .  The precedent was created artificially in order to illustrate problems in the structure of journals from the HAC list in particular and in the state of Russian science in general. <br><br>  Alas, the translated work by ‚Äúordinary Anti-plagiarism‚Äù would not be found - firstly, the search is carried out in the Russian-language collection, and secondly, we need a different search algorithm for such borrowings. <br><br><img src="https://habrastorage.org/webt/4j/uo/6z/4juo6zsgs0gdoykaez9dc-w6au0.png"><br><br><img src="https://habrastorage.org/webt/po/uo/fh/pouofhs_hizsowdcl_vvobyuycw.png"><br><br><h1>  General scheme of the algorithm </h1><br>  Obviously, if they borrow texts by translation, they are mostly from English-language articles.  And this happens for several reasons: <br><br><ul><li>  an incredible amount of all kinds of texts are written in English; </li><li>  Russian scientists in most cases use English as the second ‚Äúworking‚Äù language; </li><li>  English is a common working language for most international scientific conferences and journals. </li></ul><br>  Based on this, we decided to develop solutions for finding borrowings from English to Russian.  The result was this general scheme of the algorithm: <br><br><ol><li>  The Russian-language checked document comes to an input. </li><li>  Machine translation of the Russian text into English is in progress. </li><li>  There is a search for candidates for sources of borrowing on the indexed collection of English-language documents. </li><li>  A comparison is made of each candidate found with the English version of the document being checked - the definition of the borders of borrowed fragments. </li><li>  The boundaries of the fragments are transferred to the Russian version of the document.  At the end of the process, a verification report is generated. </li></ol><br><h1>  Step one.  Machine translation and its ambiguity </h1><br>  The first task to be solved after the appearance of the document being checked is the translation of the text into English.  In order not to depend on third-party tools, we decided to use ready-made algorithmic solutions from open access and train them on our own.  To do this, it was necessary to assemble parallel corpus texts for a couple of English-Russian languages ‚Äã‚Äãthat are publicly available, and also try to assemble such corpuses independently by analyzing the web pages of bilingual websites.  Of course, the quality of a translator trained by us is inferior to leading solutions, but no one from us demands a high quality translation.  In the end, managed to collect about 20 million pairs of proposals of scientific topics.  This sample was suitable for solving the task before us. <br><br>  Having implemented a machine translator, we faced the first difficulty - the translation is always ambiguous.  The same meaning can be expressed in different words, the structure of the sentence and the order of words can change.  And since the translation is done automatically, then machine translation errors are also superimposed here. <br><br>  To illustrate this ambiguity, we took the first preprint from arxiv.org <br><br><img src="https://habrastorage.org/webt/nu/jy/3n/nujy3nibq6a2mp_wswxnexodf3a.png"><br><br>  and chose a small fragment of the text, which they offered to translate to two colleagues with a good knowledge of English and two well-known machine translation services. <br><br><img src="https://habrastorage.org/webt/65/z0/xm/65z0xmgrug5ltt05nofzwycscgy.png"><br><br>  After analyzing the results, we were very surprised.  Below you can see how different the translations turned out, although the general meaning of the fragment is preserved: <br><br><img src="https://habrastorage.org/webt/po/hp/iu/pohpiuqd5fegxycpd1gwpxgivp8.png"><br><br>  We assume that the text that we automatically translated from Russian to English in the first step of our algorithm could have been translated from English to Russian.  Naturally, exactly how the original translation was made is unknown to us.  But even if we knew this, the chances of getting exactly the source code would be negligible. <br><br>  Here you can draw a parallel with the mathematical model of a ‚Äúnoisy channel model‚Äù ( <a href="https://en.wikipedia.org/wiki/Noisy_channel_model">noisy channel model</a> ).  Suppose some text in English went through a ‚Äúchannel with noise‚Äù and became text in Russian, which, in turn, passed through another ‚Äúchannel with noise‚Äù (of course, it was already another channel) and became output text in English, which is different from the original.  The imposition of such a double "noise" - one of the main problems of the task. <br><br><img src="https://habrastorage.org/webt/38/r0/ey/38r0ey936d0qq4hpzr5mbg6e34c.jpeg"><br><br><h1>  Step two.  From exact matches to search "by meaning" </h1><br>  It became obvious that, even with the translated text, it was correct to find borrowing in it, searching through a collection of sources consisting of many millions of documents, providing sufficient completeness, accuracy and speed of search, using the traditional Shingles algorithm is impossible. <br><br>  And here we decided to leave the old search pattern based on word matching.  We definitely needed a different borrowing detection algorithm, which, on the one hand, could match fragments of texts ‚Äúby meaning‚Äù, and on the other, it remained as fast as the shingle algorithm. <br><br>  But what to do with the noise that gives us "double" machine translation in the texts?  Will the texts generated by different translators be detected, as in the example below? <br><br><img src="https://habrastorage.org/webt/7c/pf/ln/7cpflnur3is4uqhrgpeylasagxo.jpeg"><br><br>  Search "by meaning" we decided to ensure through the clustering of English words so that the semantically close words and word forms of the same word fall into one cluster.  For example, the word "beer" will fall into a cluster, which also contains the following words: <br><br>  <em>[beer, beers, brewing, ale, brew, brewery, pint, stout, guinness, ipa, brewed, lager, ales, brews, pints, cask]</em> <br><br>  Now, before splitting texts into shingles, it is necessary to replace words with labels of classes to which these words belong.  In this case, due to the fact that shingles are built with overlapping, you can ignore certain inaccuracies inherent in clustering algorithms. <br><br>  Despite clustering errors, the search for candidate documents takes place with sufficient completeness - we need only a few shingles to match, and still with high speed. <br><br><h1>  Step three.  Of all the candidates, the most worthy win </h1><br>  So, candidate documents for the availability of transfer borrowings have been found, and one can proceed to a ‚Äúsemantic‚Äù comparison of the text of each candidate with the text being checked.  Here, the Shingles will no longer help us - this tool for solving this task is too inaccurate.  We will try to implement such an idea: we will put in correspondence to each piece of text a point in space of a very large dimension, while we will strive to ensure that fragments of texts that are close in meaning are represented by points located in this space nearby (were close by some distance function ). <br><br>  We will calculate the coordinates of a point (or a little more scientific - vector components) for a text fragment using a neural network, and we will train this network using data marked by assessors.  The role of the assessor in this work is to create a training set, that is, to indicate for some pairs of text fragments whether they are close in meaning or not.  Naturally, the more it is possible to collect tagged fragments, the better the trained network will work. <br><br>  The key task in all the work is to choose the right architecture and train the neural network.  Our network should display a text fragment of arbitrary length into a vector of large but fixed dimension.  At the same time, it should take into account the context of each word and the syntactic features of text fragments.  To solve problems associated with any sequences (not only text, but also, for example, biological) there is a whole class of networks, which are called recurrent.  The main idea of ‚Äã‚Äãthis network is to obtain a sequence vector by iteratively adding information about each element of this sequence.  In practice, such a model has many drawbacks: it is difficult to train it, and it rather quickly ‚Äúforgets‚Äù the information that was obtained from the first elements of the sequence.  Therefore, on the basis of this model, many more convenient network architectures have been proposed that correct these shortcomings.  In our algorithm, we use the <abbr title="Gated Recurrent Unit"><a href="https://en.wikipedia.org/wiki/Gated_recurrent_unit">GRU</a></abbr> architecture.  This architecture allows you to control how much information should be obtained from the next element of the sequence and how much information the network can ‚Äúforget‚Äù. <br><br>  In order for the network to work well with different types of translation, we have taught it both with manual and machine translation examples.  The network was trained iteratively.  After each iteration, we studied which fragments it was wrong most of all.  Such fragments we also gave the network for training. <br><br>  It is interesting, but the use of ready-made neural network libraries, such as <a href="https://code.google.com/archive/p/word2vec/">word2vec</a> , did not bring success.  We used their results in our work as an estimate of the base level, below which it was impossible to fall. <br><br>  It is worth noting another important point, namely - the size of a piece of text that will be displayed to a point.  Nothing prevents, for example, operating with full texts, presenting them as a single object.  But in this case, only texts that coincide in meaning will be close.  If in the text only some part is borrowed, then the neural network will arrange them far away, and we will not find anything.  A good, though not certain, option is to use sentences.  It was on him that we decided to stop. <br><br>  Let's try to estimate how many comparisons of sentences will need to be performed in the typical case.  Suppose both the document being checked and the candidates' documents contain 100 proposals each, which corresponds to the size of the average scientific article.  Then we will need 10,000 comparisons to compare each candidate.  If there are only 100 candidates (in practice, tens of thousands of candidates sometimes rise from a multi-million dollar index), then we will need 1 million distance comparisons to search for borrowing in just one document.  And the flow of checked documents often exceeds 300 per minute.  At the same time, the calculation of each distance by itself is also not the easiest operation. <br><br>  In order not to compare all the proposals with all, we use a preliminary selection of potentially close vectors based on <a href="https://ru.wikipedia.org/wiki/Locality-sensitive_hashing">LSH hashing</a> .  The main idea of ‚Äã‚Äãthis algorithm is as follows: we multiply each vector by a certain matrix, after which we remember which components of the multiplication result have a value greater than zero and which ones are smaller.  Such a record about each vector can be represented by a binary code with an interesting property: close vectors have a similar binary code.  Thus, with the proper selection of the algorithm parameters, we reduce the number of required pairwise vector comparisons to a small number that can be carried out in a reasonable time. <br><br><h1>  Step Four.  "In order not to violate reporting ..." </h1><br>  Let's display the results of our algorithm - now when a user loads a document, you can choose to check the collection of transfer borrowings.  The result of the check is visible in your account: <br><br><img src="https://habrastorage.org/webt/jn/t-/sn/jnt-snn9ytu-tyy1mzmgoqpfcye.jpeg"><br><br><h1>  Practical test - unexpected results </h1><br>  So, the algorithm is ready, its training was conducted on model samples.  Will we succeed in finding something interesting in practice? <br><br>  We decided to search for transferable borrowings in the largest electronic library of scientific articles <a href="https://elibrary.ru/defaultx.asp">eLibrary.ru</a> , which is based on scientific articles included in the Russian Science Citation Index (RISC).  In total, we checked about 2.5 million scientific articles in Russian. <br><br>  As a search area, we indexed a collection of English-language archival articles from the collections of elibrary.ru, open access journal sites, the resource arxiv.org, and the English-language wikipedia.  The total volume of the source database in a combat experiment amounted to 10 million texts.  It may seem strange, but 10 million articles is a very small base.  The number of scientific texts in English is at least billions.  In this experiment, having a base in which there was less than 1% of potential sources of borrowing, we believed that even the 100 cases identified would be good luck. <br><br>  As a result, we found more than 20 thousand articles containing transferable borrowings in significant volumes.  We invited experts to verify the detailed cases.  As a result, managed to check a little less than 8 thousand articles.  The results of the analysis of this part of the sample are presented in the table: <br><br><table><tbody><tr><th>  Trigger Type </th><th>  amount </th></tr><tr><td>  <strong>Borrowing</strong> </td><td>  <strong>2627</strong> </td></tr><tr><td>  Remittances <br>  (text translated from English and issued as original) <br></td><td>  921 </td></tr><tr><td>  Borrowing "vice versa" - from Russian to English (determined by the date of publication) </td><td>  1706 </td></tr><tr><td>  <strong>Legal borrowing</strong> </td><td>  <strong>2355</strong> </td></tr><tr><td>  Bilingual articles <br>  (works of the same author in two languages) <br></td><td>  788 </td></tr><tr><td>  Quotes of laws <br>  (use of wording laws) </td><td>  1567 </td></tr><tr><td>  <strong>Self-citation</strong> <br>  (translated quotation by the author of his own English-language work) </td><td>  <strong>660</strong> </td></tr><tr><td>  <strong>Erroneous operation</strong> <br>  (due to incorrect translation or neural network error) </td><td>  <strong>507</strong> </td></tr><tr><td>  <strong>Other</strong> <br>  (checked articles contained fragments in English, or difficult to refer to any category) <br></td><td>  <strong>1540</strong> </td></tr><tr><td>  Total </td><td>  7689 </td></tr></tbody></table><br>  Part of the results relates to legal borrowing.  These are translated works of the same authors or co-authored, some of the results are correct triggers of identical phrases, as a rule, of the same legal laws translated into Russian.  But a significant part of the results are incorrect transferable borrowings. <br><br>  Based on the analysis, one can draw several interesting conclusions, for example, on the distribution of the percentage of borrowings: <br><br><img src="https://habrastorage.org/webt/qo/8u/a2/qo8ua2hrctqnzsbtxu9gwdh8o3u.png"><br><br>  It is seen that most often borrow small fragments, however, there are works borrowed entirely, including graphs and tables. <br><br><img src="https://habrastorage.org/webt/pq/s2/au/pqs2aulss3w11vook8kwxam6t8e.png"><br><br>  From the histogram below, it is clear that they prefer to borrow from recently published articles, although there are works where the source dates from, for example, 1957. <br><br>  We used the metadata provided by eLibrary.ru, including which area of ‚Äã‚Äãknowledge the article belongs to.  Using this information, you can determine which Russian scientific fields are most often borrowed by translation from English. <br><br><img src="https://habrastorage.org/webt/kb/dc/df/kbdcdfymrswtkymc-gkfu16j-vw.png"><br><br>  The most obvious way to ensure the correctness of the results is to compare the texts of both works, the source and the source, by checking them side by side. <br><br><img src="https://habrastorage.org/webt/ax/x_/ae/axx_aeovnom__j45_h5rekththg.png"><br><br>  Above - work in English from arxiv.org, from below - Russian-language work, which is entirely, including graphs and results, is a translation.  The corresponding blocks are marked in red.  Noteworthy is the fact that the authors went even further - they also translated the remaining pieces of the original article and published a couple more of their ‚Äúown‚Äù articles.  The authors decided not to refer to the original.  Information on all found cases of transferable borrowings has been submitted to the editorial offices of scientific journals that have published relevant articles. <br><br>  Thus, the result could not fail to please us - the Antiplagiat system received a new module for detecting transferable borrowing, which checks Russian-language documents now also from English-language sources. <br><br>  <strong>Create your own mind!</strong> </div><p>Source: <a href="https://habr.com/ru/post/354142/">https://habr.com/ru/post/354142/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354132/index.html">We relieve the player from irritation: the correct use of random numbers</a></li>
<li><a href="../354134/index.html">Hypothesis</a></li>
<li><a href="../354136/index.html">Build rpm packages and configure your repository</a></li>
<li><a href="../354138/index.html">How the stats and monitoring of WebRTC changed the monitoring of VoIP</a></li>
<li><a href="../354140/index.html">Kubernetes Ice Cream, or Beginner Container Solutions</a></li>
<li><a href="../354144/index.html">Hypothesis Quick Start Guide</a></li>
<li><a href="../354146/index.html">Hypotesis - Details and Extras</a></li>
<li><a href="../354148/index.html">Security Week 14: RSA Conference, Holed Advertising Networks, Alliances and Confrontation</a></li>
<li><a href="../354150/index.html">How we participated in the hackathon from OpenData</a></li>
<li><a href="../354152/index.html">Mobius-2018: robo report</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>