<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to reduce the likelihood of errors at the stage of writing code. Note N3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the third article where I want to tell you about a new pair of programming techniques that will help make the code simpler and more reliable. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to reduce the likelihood of errors at the stage of writing code. Note N3</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/0a6/2e5/7a4/0a62e57a4482cc6069996da4ca434f1e.png" alt="PVS-Studio VS QT"><br>  This is the third article where I want to tell you about a new pair of programming techniques that will help make the code simpler and more reliable.  The previous two notes can be found <a href="http://habrahabr.ru/blogs/cpp/115143/">here</a> [1] and <a href="http://habrahabr.ru/blogs/cpp/116397/">here</a> [2].  This time the examples will be taken from the Qt project. <br><a name="habracut"></a><br><h2>  Introduction </h2><br>  Qt Project 4.7.3.  I came across for studying not by chance.  PVS-Studio users noticed that the analysis is somehow weak when it comes to checking projects built on the basis of the Qt library.  No wonder.  Static analysis allows you to find errors due to the fact that the code looks at a higher level than the compiler.  Therefore, he must know certain code patterns and what the functions of the various libraries do.  Otherwise, he will pass by many wonderful blunders.  Let me explain with an example: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(My_Str_A, My_Str_A) == <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  It makes no sense to compare the string with itself.  But the compiler is silent.  He does not think about the essence of the strcmp () function.  He has enough of his worries.  But static analyzers may be suspicious.  Qt has its own kind of string comparison function - qstrcmp ().  And, accordingly, the analyzer must be trained to pay attention to the following line: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (qstrcmp(My_Str_A, My_Str_A) == <span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre> <br>  Mastering the Qt library and creating specialized checks is a big and systematic job.  And the beginning of this work was the verification of the library itself. <br><br>  Having finished viewing the warnings, I have matured a few new thoughts on improving the code, which I hope will be interesting and useful for you. <br><br><h2>  1. Process the variables in the same sequence as they are declared. </h2><br>  The Qt library code is very qualitative and contains almost no errors.  But it revealed a large number of unnecessary initializations, unnecessary comparisons or unnecessary copying of the values ‚Äã‚Äãof variables. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will give a couple of examples for clarity: <br><pre> <code class="cpp hljs">QWidget *WidgetFactory::createWidget(...) { ... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (widgetName == m_strings.m_qDockWidget) { &lt;&lt;&lt;=== w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QDesignerDockWidget(parentWidget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (widgetName == m_strings.m_qMenuBar) { w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QDesignerMenuBar(parentWidget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (widgetName == m_strings.m_qMenu) { w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QDesignerMenu(parentWidget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (widgetName == m_strings.m_spacer) { w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Spacer(parentWidget); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (widgetName == m_strings.m_qDockWidget) { &lt;&lt;&lt;=== w = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QDesignerDockWidget(parentWidget); ... }</code> </pre> <br>  Here the same comparison is duplicated twice.  This is not an error, but a completely redundant code.  Another similar example: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QXmlStreamReaderPrivate::init() { tos = <span class="hljs-number"><span class="hljs-number">0</span></span>; &lt;&lt;&lt;=== scanDtd = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; token = <span class="hljs-number"><span class="hljs-number">-1</span></span>; token_char = <span class="hljs-number"><span class="hljs-number">0</span></span>; isEmptyElement = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; isWhitespace = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; isCDATA = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; standalone = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; tos = <span class="hljs-number"><span class="hljs-number">0</span></span>; &lt;&lt;&lt;=== ... }</code> </pre> <br>  Again, no mistake, but completely unnecessary double initialization of the variable.  And I counted a lot of similar duplicate actions.  They arise because of long lists of comparisons, assignments, initializations.  It is simply not visible that the variable is already being processed, which is why extra operations appear.  I can name three unpleasant consequences of having such duplicate actions: <br><ol><li>  Duplicates increase the length of the code.  And the longer the code, the easier it is to add another duplicate. </li><li>  If we want to change the program logic and delete one check or one assignment, then a duplicate of this action can give you several hours of fascinating debugging.  Imagine yourself, you write ‚Äútos = 1‚Äù (see the first example), and then in another part of the program you are surprised that why ‚Äútos‚Äù is still zero. </li><li>  Slow down the speed of work.  Almost always they can be neglected in such situations, but it still exists. </li></ol><br>  I hope, convinced that duplicates have no place in our code.  How to deal with them?  As a rule, such initialization / comparisons go in a block.  And there is the same block of variables.  It is rational to write code so that the order of declarations of variables and the order of working with them coincide.  I will give an example of not very good code: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y, z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q, w, e, r, t; } A; ... Am = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; Aq = <span class="hljs-number"><span class="hljs-number">0</span></span>; Ax = <span class="hljs-number"><span class="hljs-number">0</span></span>; Ay = <span class="hljs-number"><span class="hljs-number">0</span></span>; Az = <span class="hljs-number"><span class="hljs-number">0</span></span>; Aq = <span class="hljs-number"><span class="hljs-number">0</span></span>; Aw = <span class="hljs-number"><span class="hljs-number">0</span></span>; Ar = <span class="hljs-number"><span class="hljs-number">1</span></span>; Ae = <span class="hljs-number"><span class="hljs-number">1</span></span>; At = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Naturally, this is a schematic example.  The point is that when initialization is not consistent, it is much easier to write two identical strings.  In the code above, the 'q' variable is initialized twice.  And the error is poorly noticeable if you look at the code fluently.  If you now initialize the variables in the same sequence as they are declared, then there will simply be no room for such an error.  Improved version of the code: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y, z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> q, w, e, r, t; } A; ... Ax = <span class="hljs-number"><span class="hljs-number">0</span></span>; Ay = <span class="hljs-number"><span class="hljs-number">0</span></span>; Az = <span class="hljs-number"><span class="hljs-number">0</span></span>; Am = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; Aq = <span class="hljs-number"><span class="hljs-number">0</span></span>; Aw = <span class="hljs-number"><span class="hljs-number">0</span></span>; Ae = <span class="hljs-number"><span class="hljs-number">1</span></span>; Ar = <span class="hljs-number"><span class="hljs-number">1</span></span>; At = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Of course, I know that it is not always possible to write and work with variables in the order they are declared.  But often this is possible and useful.  An additional advantage will be that it will be easier for you to navigate the code. <br><br>  <b>Recommendation.</b>  <b>When adding a new variable, try to initialize and process it in accordance with its position relative to other variables.</b> <br><br><h2>  2. Tabular methods are good. </h2><br>  Tabular methods are well written by S. McConnell in the book ‚ÄúPerfect Code‚Äù in Chapter 18 [3]: <br><br>  <i>The table method is a schema that allows you to search for information in a table, rather than using logical expressions such as if and case.</i>  <i>Practically everything that you can choose by means of logical operators can be selected using tables.</i>  <i>In simple cases, logical expressions are simpler and clearer.</i>  <i>But with the complication of logical constructions tables are becoming more attractive.</i> <br><br>  So, it‚Äôs a pity that programmers still love the huge switch () or dense forest of if-else constructions.  Overcome it is very difficult.  It seems that one more ‚Äúcase:‚Äù or a small ‚Äúif‚Äù does not hurt.  But it hurts.  And unsuccessfully add new conditions even the most experienced programmers.  As an example, a pair of defects found in Qt. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> QCleanlooksStyle::pixelMetric(...) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ret = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (metric) { ... <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PM_SpinBoxFrameWidth: ret = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PM_MenuBarItemSpacing: ret = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> PM_MenuBarHMargin: ret = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; ... }</code> </pre> <br>  Long-lasting switch ().  And, of course, there is a forgotten operator ‚Äúbreak‚Äù.  The analyzer has detected this error due to the fact that the variable ‚Äúret‚Äù is assigned a different value twice in a row. <br><br>  Perhaps, much better, it would be to get some kind of std :: map &lt;PixelMetric, int&gt; and clearly sign to set the correspondence between the metric and the numbers.  You can come up with other table options for implementing the function. <br><br>  One more example: <br><pre> <code class="cpp hljs">QStringList ProFileEvaluator::Private::values(...) { ... <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ver == QSysInfo::WV_NT) ret = QLatin1String(<span class="hljs-string"><span class="hljs-string">"WinNT"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ver == QSysInfo::WV_2000) ret = QLatin1String(<span class="hljs-string"><span class="hljs-string">"Win2000"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ver == QSysInfo::WV_2000) &lt;&lt;&lt;=== <span class="hljs-number"><span class="hljs-number">2003</span></span> ret = QLatin1String(<span class="hljs-string"><span class="hljs-string">"Win2003"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ver == QSysInfo::WV_XP) ret = QLatin1String(<span class="hljs-string"><span class="hljs-string">"WinXP"</span></span>); ... }</code> </pre> <br>  In the code, we compare the variable 'ver' two times with the constant WV_2000.  A good example is where the table method is.  For example, such a method could look like this: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> QSysInfo::WinVersion; m_ver; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *m_str; } Table_WinVersionToString[] = { { WV_Me, <span class="hljs-string"><span class="hljs-string">"WinMe"</span></span> }, { WV_95, <span class="hljs-string"><span class="hljs-string">"Win95"</span></span> }, { WV_98, <span class="hljs-string"><span class="hljs-string">"Win98"</span></span> }, { WV_NT, <span class="hljs-string"><span class="hljs-string">"WinNT"</span></span> }, { WV_2000, <span class="hljs-string"><span class="hljs-string">"Win2000"</span></span> }, { WV_2003, <span class="hljs-string"><span class="hljs-string">"Win2003"</span></span> }, { WV_XP, <span class="hljs-string"><span class="hljs-string">"WinXP"</span></span> }, { WV_VISTA,<span class="hljs-string"><span class="hljs-string">"WinVista"</span></span> } }; ret = QLatin1String(<span class="hljs-string"><span class="hljs-string">"Unknown"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i != count_of(Table_WinVersionToString); ++i) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Table_WinVersionToString[i].m_ver == ver) ret = QLatin1String(Table_WinVersionToString[i].m_str);</code> </pre> <br>  Of course, this is just a prototype, but it demonstrates well the idea of ‚Äã‚Äãtabular methods.  Agree that to identify the error in such a table is much easier. <br><br>  <b>Recommendation.</b>  <b>Do not be lazy to write a function using table methods.</b>  <b>Yes, it will take a little time, but it will pay off later.</b>  <b>It will be easier and faster to add new conditions, and the probability of error will be much lower.</b> <br><br><h2>  3. Other interesting </h2><br>  Since Qt is a large library, despite the high quality, you can find various errors in it.  The law of large numbers.  The size of * .cpp, * .h and similar Qt project files is about 250 megabytes.  As the error is not improbable, in the big code it is quite realistic to meet it.  Based on other errors that I discovered in Qt, it is difficult to make some recommendations.  Just describe some errors that I liked. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QString </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decodeMSG</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> MSG&amp; msg)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> repCount = (lKeyData &amp; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>); <span class="hljs-comment"><span class="hljs-comment">// Bit 0-15 int scanCode = (lKeyData &amp; 0xf0000) &gt;&gt; 16; // Bit 16-23 bool contextCode = (lKeyData &amp;&amp; 0x20000000); // Bit 29 bool prevState = (lKeyData &amp;&amp; 0x40000000); // Bit 30 bool transState = (lKeyData &amp;&amp; 0x80000000); // Bit 31 ... }</span></span></code> </pre> <br>  Randomly using the &amp;&amp; operator instead of &amp;.  Notice how useful it is to have comments in the code.  It immediately becomes clear that this is indeed a mistake and how bits should actually be processed. <br><br>  The following example will be on the topic of long expressions: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ShiftResult </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">shift</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ ... qreal l = (orig-&gt;x1 - orig-&gt;x2)*(orig-&gt;x1 - orig-&gt;x2) + (orig-&gt;y1 - orig-&gt;y2)*(orig-&gt;y1 - orig-&gt;y1) * (orig-&gt;x3 - orig-&gt;x4)*(orig-&gt;x3 - orig-&gt;x4) + (orig-&gt;y3 - orig-&gt;y4)*(orig-&gt;y3 - orig-&gt;y4); ... }</code> </pre> <br>  See a mistake?  Just about, on the move and you will not notice.  Well, I will.  The trouble is here: "orig-&gt; y1 - orig-&gt; y1".  I am also confused by the third multiplication, but maybe this is necessary. <br><br>  Yes, another question.  Do you also have computing blocks in programs?  Isn't it time to try the <a href="http://www.viva64.com/ru/pvs-studio-download/">PVS-Studio</a> static code analyzer?  So, advertised.  Let's go further. <br><br>  Use of uninitialized variables.  They can be found in any large application: <br><pre> <code class="cpp hljs">PassRefPtr&lt;Structure&gt; Structure::getterSetterTransition(Structure* structure) { ... RefPtr&lt;Structure&gt; transition = create( structure-&gt;storedPrototype(), structure-&gt;typeInfo()); transition-&gt;m_propertyStorageCapacity = structure-&gt;m_propertyStorageCapacity; transition-&gt;m_hasGetterSetterProperties = transition-&gt;m_hasGetterSetterProperties; transition-&gt;m_hasNonEnumerableProperties = structure-&gt;m_hasNonEnumerableProperties; transition-&gt;m_specificFunctionThrashCount = structure-&gt;m_specificFunctionThrashCount; ... }</code> </pre> <br>  Here again, you need to give a hint, so as not to torment your eyes for a long time.  You need to look at the initialization of the variable "transition-&gt; m_hasGetterSetterProperties". <br><br>  I am sure that almost every one of us, when I first started programming, made a mistake in the spirit: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *p = ...; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (p == <span class="hljs-string"><span class="hljs-string">"12345"</span></span>)</code> </pre> <br>  And only then came the realization of why we needed strange functions at first glance, like strcmp ().  Unfortunately, C ++ is so severe that you can make such a mistake even after many years, being a professional developer with experience: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> TCHAR* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getQueryName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; ... Query* MultiFieldQueryParser::parse(...) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (q &amp;&amp; (q-&gt;getQueryName() != _T(<span class="hljs-string"><span class="hljs-string">"BooleanQuery"</span></span>) ... ... }</code> </pre> <br>  What else to show.  Here, for example, incorrectly written exchange of variable values. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">qt_testCollision</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ ... t=x1; x1=x2; x2=t; t=y1; x1=y2; y2=t; ... }</code> </pre> <br>  This is an example of what can be mistaken, even in very simple code.  So, for the present there were no examples on the topic of going beyond the array.  Will now be: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">equals</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( class1* val1, class2* val2 )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> size = val1-&gt;size(); ... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ( --size &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span> ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( !comp(*itr1,*itr2) ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; itr1++; itr2++; } ... }</code> </pre> <br>  The condition "--size&gt; = 0" is always true, since size has an unsigned type.  If the same sequences are compared, then the arrays will overflow <br><br>  You can continue further.  I hope you, as programmers, understand that there is no possibility to describe errors in a project of such a size in one article.  Therefore, the last, for a snack: <br><pre> <code class="cpp hljs">STDMETHODIMP QEnumPins::QueryInterface(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IID &amp;iid,<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> **out) { ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (S_OK) AddRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> hr; }</code> </pre> <br>  There should have been something in the spirit of ‚Äúif (hr == S_OK)‚Äù or ‚Äúif (SUCCEEDED (hr))‚Äù.  The macro S_OK is nothing more than 0. Therefore, byak with an incorrect calculation of the number of links is inevitable here. <br><br><h2>  Instead of conclusion </h2><br>  Thanks for attention.  Use static code analysis, and you can save a lot of time for more useful things than debugging and maintaining code. <br><br>  Also, I will be grateful to the readers if you send me interesting examples of errors that you found in your or someone else's code and for which you can implement diagnostic rules. <br><br><h2>  Bibliographic list </h2><br><ol><li>  Andrey Karpov.  How to reduce the likelihood of errors at the stage of writing code.  Note N1.  <a href="http://habrahabr.ru/blogs/cpp/115143/">http://habrahabr.ru/blogs/cpp/115143/</a> </li><li>  Andrey Karpov.  How to reduce the likelihood of errors at the stage of writing code.  Note N2.  <a href="http://habrahabr.ru/blogs/cpp/116397/">http://habrahabr.ru/blogs/cpp/116397/</a> </li><li>  McConnell S. Perfect Code.  Master Class / Trans.  from English  - M .: Publishing and trading house "Russian Edition";  SPb .: Peter, 2005. - 896 pages: ill. </li></ol></div><p>Source: <a href="https://habr.com/ru/post/123603/">https://habr.com/ru/post/123603/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123596/index.html">Review of fresh materials, April-May 2011</a></li>
<li><a href="../123599/index.html">Specialists from MIT have developed a mobile accessory for the diagnosis of cataracts</a></li>
<li><a href="../123600/index.html">Nigerian scammers at Molotok.ru. One of the fraud schemes</a></li>
<li><a href="../123601/index.html">The history of the conference ‚ÄúPlatform. Defining the future "</a></li>
<li><a href="../123602/index.html">About $ 585 million US dollars spent on Google+ development</a></li>
<li><a href="../123604/index.html">Morgan Stanley sent out a warning to 34,000 customers about the loss of their data</a></li>
<li><a href="../123605/index.html">IE gets rid of Conditional Comments</a></li>
<li><a href="../123606/index.html">Courses training center MUK in July</a></li>
<li><a href="../123607/index.html">June 10, 2011 - Oracle Database Machine has been certified by SAP</a></li>
<li><a href="../123608/index.html">Two-letter domains in the .SU domain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>