<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating tools for researching NES games</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I decided to continue the series of publications about the internal structure of NES-games, this time I will talk about the tools I use for research. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating tools for researching NES games</h1><div class="post__text post__text-html js-mediator-article">  I decided to continue the <a href="https://habrahabr.ru/post/259761/">series of publications</a> about the internal structure of NES-games, this time I will talk about the tools I use for research. <br><br>  Most of what the researcher needs is already in the <a href="http://www.fceux.com/web/help/fceux.html">FCEUX</a> emulator, which is well suited for debugging games.  The documentation should thoroughly examine the <b>Debug</b> section, each tool from there is useful to the researcher, and the ability to use them together with each other enhances the hacker's capabilities. <br><br>  However, I will not retell the documentation, but I‚Äôll dwell on cases when the emulator‚Äôs capacity is not enough and you need to add new ones, or when there are unusual ways to find what you want in a ROM file directly, bypassing the lengthy study of the game code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/8c0/2dc/935/8c02dc935a0242eea88baaab5b407177.png"><br><a name="habracut"></a><br><h2>  Using Lua Scripts </h2><br>  Actually, the first method, an example of which is shown in the picture for attracting attention, is the creation of auxiliary tools using the Lua script interpreter built into the emulator. <br>  In the example above, for the study of the game (and just a cheat pass, if desired), this scripting feature is used, such as <b>displaying images on the screen over the image drawn by the emulator</b> . <br><br>  Thus, the researcher may notice what is not available to the ordinary player, for example, in the screenshot above of the three hidden diamonds, the player can jump only to the first two, and in no way can take the third or even just guess about its existence.  In "Duck stories 2" there are even such jewels that are generally placed outside the game level. <br><br>  Another example of a script displaying additional data is a <a href="https://gist.github.com/spiiin/14acca27ded1989f86622eaa3ad1b515">compass</a> to the nearest gem in the "Book of the Jungle": <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/_SVjgF7rcbs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Naturally, the visualization of information from the RAM or ROM games is not the only possibility of scripts. <br><br>  Another frequently used feature is <b>logging what is happening in the game code</b> , for example, a script template for <a href="https://github.com/lab313ru/gens_lua_dumper">dumping unzipped data</a> immediately after unpacking it (for SMD games, but the principle is also applicable for NES). <br><br>  Well, no one forbids <b>creating full-fledged utilities on the Lua-scripts</b> , such as the <i>TasEditor</i> keystroke editor already included in the emulator. <br><br>  Also, in my opinion, the idea of <b>partial rewriting of the</b> script <b>code</b> when the game data is patched on the fly to modify the gameplay is undervalued.  Proof-of-concept of such a script that modifies enemies in New Ghostbusters 2: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/aSGLA1R96Gc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  However, for complex processing of a particular game or creating new hack methods, it is worth thinking about using the following method. <br><br><h2>  Modification of emulator source code </h2><br>  There is a place where fantasies about various topics that are not related to the study of games, such as adding <a href="http://retroachievements.org/">achievements</a> to emulators, a <a href="https://geod.itch.io/3dnes">3d render</a> or <a href="https://forums.nesdev.com/viewtopic.php%3Ff%3D3%26t%3D9935">improved graphics</a> , can be roamed around, but I will try to keep within the scope of the article. <br><br>  One of the directions for expanding the emulator in order to improve the possibilities for reverse engineering is to <b>push as many of its internal capabilities as possible into the Lua library</b> .  In the <a href="https://habrahabr.ru/post/259483/">second article of the cycle,</a> I already showed how by prokidydka all a couple of new functions, the opportunity to make a universal (suitable for the study of any game) tool for research. <br><br><img src="https://habrastorage.org/files/c4e/9e5/a65/c4e9e5a65f3240a29b8c3643ea422018.png"><br><br>  Another simple and useful example that is still missing in the latest version of the emulator is the <i>possibility of modification from the PPU memory script</i> . <br><br>  A modification of the emulator can also be used to <b>embed an editor for a particular game</b> with the ability to launch it on the fly and check the changes made: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wgfV36Wl0-E" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2>  Scripts for static game code analysis </h2><br>  The previous two categories of modifications related to the dynamic analysis of the game during its execution.  However, most of the research is a static analysis of the game's ROM file (or dumps of any data from it). <br><br>  The main program for such code analysis is the interactive <a href="https://www.hex-rays.com/products/ida/">IDA</a> disassembler.  It supports 6502 assembler, but it requires both a <b>plug-in</b> to properly <a href="http://www.romhacking.net/utilities/627/">load files in the nes format</a> , and a <b>set of scripts</b> to automate routine actions to convert the downloaded file into combed code.  A set of scripts specific to the study of NES-games compiled <a href="https://tcrf.net/User:Cah4e3">here</a> . <br><br>  The IDA scripts themselves can be written in the built-in command language <b><i>idc</i></b> or <b><i>python</i></b> , in any case it is best to open them with a text editor and learn, in most cases it helps to better understand the commands of the IDA itself, which will be useful in working with it and learn how to write such scripts yourself .  This is very useful when you need to spend a few hundred of the same type of action, such as combining bytes into pointers or selecting arrays according to some rules. <br><br><h2>  Tools for static game data analysis </h2><br>  IDA is a good code analysis tool, so good that some game research gurus even think that only it is enough to research and change games.  However, even having a game that was parsed before the compiled and commented source codes on a game, it is difficult to modify the game data - levels, graphics cards, character animations.  Unfortunately, the format of the game data is often very different from game to game, so creating universal tools suitable for most games is quite difficult. <br><br><h3>  Tile Card Editors </h3><br>  The storage format of graphic banks (the lowest graphics storage level) is standard for all NES games, so there are many <a href="http://www.romhacking.net/%3Fpage%3Dutilities%26category%3D10">tile card editors</a> , however, among them I did not find a single library that would allow rendering these tiles in my application. <br><br>  With such programs you can edit graphics tiles in games with the presence of CHR-ROM - whole banks of graphics.  In other games, CHR-RAM is used - the video memory of the tiles in them is read out in parts from the bank with data and code and is copied into the video memory (sometimes with quite clever ways, but it‚Äôs rather better to talk about them in the article about data compression). <br><br>  At a higher level, the games are so different that there are practically no general editing programs, the maximum is editors covering several games on one engine.  I will write about my attempts to make a universal level editor at the end of the article, but in the meantime I‚Äôll give some more general ideas on how to find data in games and utilities that implement these ideas. <br><br>  As an implementation language, I use <i><b>python</b></i> for the fact that it is possible to quickly and easily test a guess, sometimes even directly in interactive mode. <br><br><h3>  Corrupt ROM </h3><br>  Actually, just about this idea was the <a href="https://habrahabr.ru/post/259483/">second article of the cycle</a> - if we go through all possible options for changing one byte in ROM and see how it affects the screen, then it can help clarify the internal structure of the game.  After that, it is even possible to create a simple version of the game editor - you need to prepare a set of top-level picture blocks from which the screen is built, without going to the end, how these pictures themselves are constructed from the ROM data and display an array of these pictures detected by this method. <br><br><h3>  Block Search </h3><br>  You can also go from the other side. <br><br>  The background that is displayed on the screen is specified by an array of indexes of video memory tiles at a fixed PPU address ‚Äî for NES, there are 4 screen pages that can be displayed on the screen in various ways, depending on the PPU settings.  It doesn't matter what will be on the screen, it is enough just to capture any loaded page for analysis. <br><br>  The first screen (Name Table) is located at PPU $ 2000- $ 23BF.  Its contents in the <i>FCEUX</i> emulator can be viewed in the <b><i>Debug ‚Üí Name Table Viewer</i></b> window: <br><br><img src="https://habrastorage.org/files/b56/d0c/0f8/b56d0c0f866446bbb57576ecccaaecc4.png"><br><br>  Also in the form of bytes in the <i><b>Debug ‚Üí Hex Editor, View ‚Üí PPU Memory</b></i> window (go to $ 2000). <br><br>  Here you can also dump the entire video memory, which is useful for us to analyze ( <i><b>File ‚Üí Dump to File ‚Üí PPU Memory</b></i> ). <br><br>  This is just an array of 960 indexes of small video memory tiles of 8x8 pixels in size.  At the same time, after the reverse of a large number of games, it is known that game screens are often described by larger blocks, for example, 16x16 or 32x32 pixels.  Thus, if we assume a certain block size (for a start, we will try the most standard - 2x2 tiles, highlighted with a red frame in the screenshot), then we can split the data from the screen page into sections, each of which will contain a description of one block. <br><br>  So it turns out a list of all the blocks that are present on the screen.  Moreover, we have ‚Äúclean‚Äù descriptions of blocks, without information about sprites of characters (sprites are drawn in a different way), and independent of animation (background animations are almost always made using palette changes or the video memory itself, the tile numbers in the Name Table remain unchanged).  However, we do not know the number of blocks. <br><br>  We have a description of the blocks on the screen, but we do not know their order of storage in ROM.  Nevertheless, we can with some probability assume exactly where the description of the blocks is located.  The algorithm for this is as follows: <br><br>  1. Pass through the ROM and mark up all the addresses at which a block is detected, while keeping its number (the real number may be different, it is important for us to note only the differences between the blocks from each other). <br><br>  2. Find the region in ROM in which the largest number of DIFFERENT blocks is found.  This is most likely the very description of the blocks. <br><br>  <a href="https://gist.github.com/spiiin/500262e8d9da86f10a093bbb41833360">https://gist.github.com/spiiin/500262e8d9da86f10a093bbb41833360</a> <br><br>  Thus, we can find blocks of 2x2 in games in which they are stored sequentially. <br><br>  This is not bad, but there is a way to drastically improve the results of the algorithm.  The fact is that there is a limited number of basic block sizes and ways of storing them in ROM, and we can sort them all out. <br><br>  The main block sizes are 2x2, 4x2, 2x4 and 4x4, but if necessary, other dimensions are easy to add. <br><br>  With the method of storing them in ROM, it is a little trickier, the blocks can be stored both linearly and arrays broken into parts ( <a href="https://en.wikipedia.org/wiki/AOS_and_SOA">Structure of Arrays</a> , abbreviated SoA), i.e.  First, an array of only the first parts of the blocks is stored in ROM, followed by arrays with the following parts.  Most often such arrays are stored one after another, while the gap between the beginnings of arrays is equal to the number of blocks.  In order to find such SoA arrays in ROM, we need to find out their length, which can be done by enumerating all the options (quite often 256 blocks are used in games, so it‚Äôs worth starting the check with this number and decreasing it gradually). <br><br>  All this looks quite complicated, because we rely only on the probability that the game uses a certain type of blocks, but in practice the utility finds blocks in 80-90% of tested games! <br><br><img src="https://habrastorage.org/files/bb8/91c/738/bb891c7387c54a8580d69ffc2090fd1a.jpg"><br><br>  <a href="https://github.com/spiiin/NesBlockFinder">https://github.com/spiiin/NesBlockFinder</a> <br><br>  In addition, it allows you to weed out games with an unusual structure (non-block), to study them more closely. <br><br><h3>  CDL file comparison </h3><br>  The FCEUX emulator is able to mark each instruction during emulation, which bytes were interpreted as code and which as data (menu <i><b>Debug ‚Üí Code / Data Logger ...</b></i> ).  This feature is useful by itself and tightly integrated with other emulator debugging capabilities ‚Äî try turning on this mode and see how other debugging windows have changed.  However, I want to tell about her one particular application.  If you save two such cdl-files, one BEFORE performing the action being studied, and the other immediately AFTER it is completed, the difference between the two such files will show only the data (or code) that was used during the execution of the action.  With proper clipping, you can find the necessary data, just by correctly choosing two points in time between the measured events. <br><br>  The file format is quite <a href="http://www.fceux.com/web/help/fceux.html%3FCodeDataLogger.html">simple</a> , as is <a href="https://github.com/spiiin/CadEditor/blob/master/Stuff/diff_cdl/diff_data.py">the comparison script</a> , but it can bring a lot of benefits, you can build a separate debugging methodology on it. <br><br><h3>  Compressors / Decompressors </h3><br>  This topic can not be opened in a couple of paragraphs, and it will be too simplified in the context of only NES-games, so it deserves a separate article. <br><br><h3>  Universal level editor <a href="https://github.com/spiiin/CadEditor/">CadEditor</a> </h3><br>  Actually, initially this program was created to display the levels in the game Chip &amp; Dale ( <b>C</b> hip <b>A</b> nd <b>D</b> ale <b>Editor</b> ), then, upon request, it was converted into an editor and eventually acquired support from other Capcom games (Darkwing Duck, Duck Tales 1-2 "," Tale Spin "," Little Mermaid "). <br><br><img src="https://habrastorage.org/files/ff4/4c7/526/ff44c7526a5e4cd2894e6b5e5e0041d1.png"><br><br>  Later it also became clear that the principles of block-level construction in these games are very similar to the ways of organizing levels from many other games, but the devil is in the details - minor differences in each game require you to describe the internal structures of the editor as flexibly as possible so that using combinations of these structures describe the format of the levels for games for which it was not originally intended, without changing the kernel of the editor itself. <br><br>  The feature with which the universality of the editor is ensured - the so-called <b>configs of games</b> .  These are script files in C #, which describe how to load data of a particular game.  Why C #?  The editor has already been written in this language and this made it possible to easily transfer the code from the kernel to the configs without changing it, which would have to be done if a more classical scripting language like Lua was used. <br><br>  Using a full-fledged language instead of a simple settings file allows you to define your own functions for loading and saving data of any desired complexity in configs.  Scripts are plain text files, which allows users to create their own configs, if necessary, without recompiling the editor, using existing configs as templates.  Included with the editor are about 500 configs for 60 different games, about 100 of them are made by users of the editor without my participation, for games, some of which I have never even played: <br><br><img src="https://habrastorage.org/files/be4/81e/ef6/be481eef6b3745bb8e6f5d6c7ddd6341.png"><br><br>  However, at the moment, despite attempts to make a universal editor, there are games that cannot be described without modifying the editor itself (however, many games can already be added).  To collect information about such games with an unusual structure, I went a little further and started using the editor itself as a library for <i><b>Python</b></i> to examine the format of games before adding them to the editor and test the correctness of understanding the level of construction of a particular game.  I implemented this in the form of <i><b>Jupyter</b></i> notebooks, due to the fact that it is convenient in them to write code interactively, so to <a href="http://nbviewer.jupyter.org/github/spiiin/CadEditor/blob/master/JupyterCadEditor/CadEditor-example-yonoid.ipynb">document it</a> . <br><br>  Composing a large game structure from base tiles and building an entire level as a result of a puzzle resembles assembling a puzzle of thousands of pieces, and gives the same pleasure when, finally, each piece is in its place. <br><br>  In the next article there will not be such an abundance of technical information and I will give examples of assembling the levels of games with a non-standard structure or using unusual modifications of the standard block architecture.  You can also name the game on the NES in the comments, the level format of which is interesting to you, perhaps I will explore it too. </div><p>Source: <a href="https://habr.com/ru/post/317796/">https://habr.com/ru/post/317796/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317784/index.html">Fighting HPE Vertica loads</a></li>
<li><a href="../317786/index.html">Recursion formulas for calculating iterative summation errors of binary numbers of limited length</a></li>
<li><a href="../317788/index.html">Unit testing in modern teams</a></li>
<li><a href="../317792/index.html">Story about the first RDSFront & Meetup</a></li>
<li><a href="../317794/index.html">Security Week 50: crypto-socialization socialization, OpenVPN audit, Linux kernel vulnerability</a></li>
<li><a href="../317798/index.html">Looking for familiar faces</a></li>
<li><a href="../317800/index.html">Problems with hyper-v on wi-fi network</a></li>
<li><a href="../317802/index.html">‚ÄúUtilities‚Äù or ‚ÄúWindows Registry as a platform‚Äù</a></li>
<li><a href="../317804/index.html">Bug in Visual Studio 2017 RC using new C # 7 features</a></li>
<li><a href="../317806/index.html">Talk about Java 9 with Ivan Krylov on jug.msk.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>