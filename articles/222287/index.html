<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Hardware Number Sorter Verilog</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article of mine, like the previous one , digital circuitry is viewed from the programmer‚Äôs point of view. But this time the ‚Äúmore algorithmic‚Äù...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Hardware Number Sorter Verilog</h1><div class="post__text post__text-html js-mediator-article">  In this article of mine, like the <a href="http://habrahabr.ru/post/203018/">previous one</a> , digital circuitry is viewed from the programmer‚Äôs point of view.  But this time the ‚Äúmore algorithmic‚Äù problem of sorting numbers will be parsed, with the <a href="http://ru.wikipedia.org/wiki/Verilog">verilog</a> code parsing.  The considered hardware solution allows you to sort n numbers in time 2 * n.  The picture shows the output from the test project for the <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%259B%25D0%2598%25D0%25A1">FPGA</a> to the monitor, where each line corresponds to one sorter tick, first n ticks random numbers are written to the sorter, then n ticks the sorted numbers are displayed. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/11b/397/dc3/11b397dc3ce75000bc7e959a0e4e7ccd.jpg"><br><br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8">It is known</a> that software sorting of n numbers in general takes time O (n * log (n)).  The hardware allows you to circumvent this limitation, by performing several comparisons at once, see, for example <a href="http://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D1%2582%25D1%258C_%25D1%2581%25D0%25BE%25D1%2580%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8">, sorting networks</a> .  The network of sorting works entirely in parallel, data comes and goes together, my module accepts or issues only one number at a time, but does not require additional time: First, N &lt;Nmax numbers are written to the buffer in N ticks, then N ticks are read from there (taken) sorted sequence. <br>  <i>UPDATE: in the comments I was convinced that this does not give the right to talk about the complexity of the algorithm o (n).</i>  <i>If N&gt; Nmax, then it is necessary to sort by parts, then using merge sort, the elapsed time will be ~ N * log (N / Nmax).</i>  <i>When N -&gt; inf, this will give the same O (n * log (n)).</i>  <i>This, however, does not negate the fact that hardware sorting is faster than software.</i> <br><br><div class="spoiler">  <b class="spoiler_title">The picture gives a conditional description of the basic version of the algorithm.</b>  <b class="spoiler_title">Hopefully, the meaning can be caught.</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/01e/ee9/8a1/01eee98a125a71848909d9fe169dc69a.png"></div></div><br><br>  Let's look at the source code on verilog.  Let me remind you of the main difference between <abbr title="hardware description language">HDL</abbr> and a programming language - a programming language is an instruction for a performer that is executed sequentially, line by line, and a program on HDL corresponds to an electronic circuit, all parts of which work simultaneously. <br><br><div class="spoiler">  <b class="spoiler_title">Let's sort the source code of the sorter - chains.</b> <div class="spoiler_text">  We define the module of the whole chain.  it has inputs, outputs, and internal modules, all of which must be connected into a single network using a combinational circuit.  There are no explicit registers here, they are encapsulated inside sorting cells. <br><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/  module Sorting_Stack ( clk, hold, is_input, data_in, data_out ); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   parameter HBIT= 15; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ size of number in bits parameter R_SZ= 256; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ capacity, max sequence size parameter _R_SZ= (R_SZ+1)/</span></span><span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> to modify /<span class="hljs-regexp"><span class="hljs-regexp">/  -  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   input clk; ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -  input [HBIT:0] data_in; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ load one number per clock output [HBIT:0] data_out; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ while is_input==0, max value popping out here /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      -  ... /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    wire [HBIT:0] in_prev[_R_SZ]; wire [HBIT:0] in_next[_R_SZ]; wire [HBIT:0] out[_R_SZ]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      -   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ storage Cell_Compare #(HBIT) ribbon[_R_SZ] ( clk, hold, is_input, in_prev, in_next, out );</span></span></code> </pre> <br>  Let us consider in more detail the substitution of one module into another <br>  <b>Cell_Compare</b> - module type <br>  <b># (HBIT)</b> - setting numeric parameters <br>  <b>ribbon</b> - instance name <br>  <b>[_R_SZ]</b> is an array, we specify the quantity <br>  <b>(clk, hold, is_input,</b> - common signals for all <br>  <b>in_prev, in_next, out);</b>  - specific signals for each element of the array. <br><br>  Next, <b>generate</b> is a useful construct that allows <br>  apply cycles, etc.  when describing combinational circuits. <br><br><pre> <code class="hljs vhdl">//     <span class="hljs-keyword"><span class="hljs-keyword">generate</span></span> genvar i,j; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;_R_SZ-<span class="hljs-number"><span class="hljs-number">1</span></span>; i=i+<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> : block_name01 assign in_prev[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]= <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>[i]; assign in_next[i]= <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> assign in_prev[<span class="hljs-number"><span class="hljs-number">0</span></span>]= data_in; assign data_out= <span class="hljs-keyword"><span class="hljs-keyword">out</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>]; assign in_next[_R_SZ-<span class="hljs-number"><span class="hljs-number">1</span></span>]= <span class="hljs-number"><span class="hljs-number">0</span></span>; endgenerate endmodule</code> </pre><br>  Now the module of the sorting cell. <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">module</span></span> Cell_Compare ( clk, hold, is_input, in_prev, in_next, out ); <span class="hljs-attribute"><span class="hljs-attribute">parameter</span></span> HBIT= <span class="hljs-number"><span class="hljs-number">15</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">input</span></span> clk; <span class="hljs-attribute"><span class="hljs-attribute">input</span></span> hold; <span class="hljs-attribute"><span class="hljs-attribute">input</span></span> is_input; <span class="hljs-attribute"><span class="hljs-attribute">input</span></span> [HBIT:<span class="hljs-number"><span class="hljs-number">0</span></span>] in_prev; <span class="hljs-attribute"><span class="hljs-attribute">input</span></span> [HBIT:<span class="hljs-number"><span class="hljs-number">0</span></span>] in_next;</code> </pre><br>  Here begins the actual sorting logic.  Each cell stores two numbers, one smaller than the other.  Each clock (if not <b>hold</b> ) cell compares the number that came from a neighbor with its "champion".  Champion - the maximum number when writing and the minimum when reading.  The loser will leave the cell on the next measure.  As a result, the data moves along the chain, first in one direction, then in another.  The number of numbers that fit in the device is equal to twice the number of cells. <br><br>  Let's go back to the source code.  Here, when describing the output, a selector is applied (compiled into a multiplexer).  <b>is_input</b> determines <b>whether</b> we read data or write, it depends on it in which direction the data moves along the chain. <br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">output</span></span> [HBIT:<span class="hljs-number"><span class="hljs-number">0</span></span>] out= is_input ? <span class="hljs-built_in"><span class="hljs-built_in">lower</span></span> : higher; // .   ,     bit [HBIT:<span class="hljs-number"><span class="hljs-number">0</span></span>] higher; bit [HBIT:<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-built_in"><span class="hljs-built_in">lower</span></span>; //  ,       . //      ,   //  higher  in_prev (<span class="hljs-built_in"><span class="hljs-built_in">lower</span></span>   ), //  <span class="hljs-built_in"><span class="hljs-built_in">lower</span></span>  in_next (higher   ) wire [HBIT:<span class="hljs-number"><span class="hljs-number">0</span></span>] cand_h= is_input ? higher : <span class="hljs-built_in"><span class="hljs-built_in">lower</span></span>; wire [HBIT:<span class="hljs-number"><span class="hljs-number">0</span></span>] cand_l= is_input ? in_prev : in_next; //    . //     ,    , //        . always@(posedge clk ) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (~hold) begin //      -. higher &lt;= ( cand_h &gt;= cand_l ) ? cand_h : cand_l; <span class="hljs-built_in"><span class="hljs-built_in">lower</span></span> &lt;= ( cand_h &gt;= cand_l ) ? cand_l : cand_h; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> endmodule</code> </pre><br>  Everything. <br><br></div></div><br><br>  But I made another implementation with the same interface, but with slightly different properties.  The differences of implementations: The first is based on a chain of sorting cells, the second is based on a binary tree, in the nodes of which there are the same cells. <br>  The first implementation allows you to add data to a partially empty buffer (for example, you can sort interrupt requests by priority), the tree after writing requires a full read. <br>  The advantage of a tree implementation is that not the whole chain moves in the process of working, but only one branch is theoretically more energy efficient. <br><br><div class="spoiler">  <b class="spoiler_title">Tree implementation</b> <div class="spoiler_text">  uses recursion to describe a binary tree, I did not even expect it to work on verilog.  I will give only a sample of the recursive definition of a tree. <br><br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NodeType</span></span></span><span class="hljs-class"> ( );</span></span> endmodule <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">module</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TreeTemplate</span></span></span><span class="hljs-class"> ( );</span></span> parameter TREE_LEVEL= <span class="hljs-number"><span class="hljs-number">4</span></span>; NodeType node(); generate <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( TREE_LEVEL &gt;<span class="hljs-number"><span class="hljs-number">0</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> TreeTemplate <span class="hljs-comment"><span class="hljs-comment">#( TREE_LEVEL-1 ) leftSubtree ( ); TreeTemplate #( TREE_LEVEL-1 ) rightSubtree ( ); end endgenerate endmodule</span></span></code> </pre><br>  The logic of the movement of data on a tree is as follows: when recording, branches are selected alternately.  When reading, you need to make an additional comparison to determine at the root of which subtree the number is greater.  As a result, the tree needs more comparators compared to the chain of the same size.  The advantage of the tree is that the data moves less, and the power consumption of the circuit strongly depends on the number of switches of the state of the registers. <br><div class="spoiler">  <b class="spoiler_title">The corresponding picture</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/857/69e/297/85769e2973b185197a91a4082040d4b9.png"></div></div><br></div></div><br>  Generally, recursive definitions of modules is a very uncharacteristic style for a verilog.  I must admit that this project is a ‚Äúlocomotive for the driver‚Äù.  The correct approach is as follows: the goal is to write a sorter; we choose an implementation ‚Äî a tree.  In my case, the very idea of ‚Äã‚Äãwriting a sorter arose from the need to master the work with tree structures, - for the needs of a calculator based on <a href="http://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D0%25BC%25D0%25B1%25D0%25B8%25D0%25BD%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D0%25BA%25D0%25B0">combinatorial logic</a> .  I have already written a little about this project at the end of my previous, first post on Habr√©.  The operation of a machine is reduced to the calculation of a combinatorial expression using the parallel <a href="http://ru.wikipedia.org/wiki/%25D0%259F%25D0%25B5%25D1%2580%25D0%25B5%25D0%25BF%25D0%25B8%25D1%2581%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">term rewriting</a> method.  The main idea is to assign a hardware tree of cells capable of using combinators to a tree of a functional program.  Theoretically, it is possible to effectively solve problems from Boolean algebra or predicate calculus, for the purposes of symbolic calculations or proof of theorems.  I hope that in the coming months I will have a working version that will be able to reduce simple expressions.  If you know any practical problems that fit well with pure lambda calculus or combinatorial logic, please write in the comments. <br><br>  The sources of the modules of the sorters are <a href="http://opencores.org/project,numbert_sort_device">here</a> under the LGPL, there are test projects for the <a href="http://www.marsohod.org/index.php/howtostart/marsohod2">Mars</a> <a href="http://www.terasic.com.tw/cgi-bin/page/archive.pl%3FLanguage%3DEnglish%26CategoryNo%3D56%26No%3D364">Rover 2</a> , <a href="http://www.terasic.com.tw/cgi-bin/page/archive.pl%3FLanguage%3DEnglish%26CategoryNo%3D56%26No%3D364">Terasic DE0</a> and DE2-115 boards. <br><br>  <i>ps I apologize for the re-creation of the topic.</i>  <i>Now I know that it is impossible to remove a freshly published topic in drafts for a long time on the first day.</i> </div><p>Source: <a href="https://habr.com/ru/post/222287/">https://habr.com/ru/post/222287/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222277/index.html">CARDIAC - do-it-yourself computer paper</a></li>
<li><a href="../222279/index.html">May habor competition: we make our own GLONASS</a></li>
<li><a href="../222281/index.html">12 lessons from project management and startup startups</a></li>
<li><a href="../222283/index.html">Video from the ISS in HD quality in real time: High Definition Earth Viewing</a></li>
<li><a href="../222285/index.html">XKB: reconfigure the keys for a loved one</a></li>
<li><a href="../222291/index.html">The future of Unreal Tournament starts today: open source, free and cross-platform</a></li>
<li><a href="../222293/index.html">Firefox OS 1.3 has been released: improvements in graphics, audio, dual-SIM support</a></li>
<li><a href="../222295/index.html">Secrets of buttons in Android. Part 3: Buttons in the main menu</a></li>
<li><a href="../222297/index.html">Organizational report on the conference ‚ÄúJust Sell IT! Effective IT Sales ¬ª</a></li>
<li><a href="../222299/index.html">The most popular trends of SEO-2014 according to Forbes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>