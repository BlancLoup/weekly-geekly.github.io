<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Droplet of reflection for C ++. Part One: Development Retrospective</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="IMPORTANT UPDATE. READ BEFORE READING ARTICLE  It was my fault that there were some misunderstandings about these publications. So I decided to add th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Droplet of reflection for C ++. Part One: Development Retrospective</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/1fa/2fd/451/1fa2fd4512e142be9ae0f9f942006973.jpg"><br><br><div class="spoiler">  <b class="spoiler_title">IMPORTANT UPDATE.</b>  <b class="spoiler_title">READ BEFORE READING ARTICLE</b> <div class="spoiler_text">  It was my fault that there were some misunderstandings about these publications.  So I decided to add this warning. <br><br>  In this series of articles, I wanted to put more emphasis on the development history of a certain open source library, regardless of the specific cpprt.  A story from writing source codes (with an emphasis on some interesting things that people find interesting to read in general, regardless of the library itself), to the formation of a repository (with a CMake lesson) and library promotion (where part of the promotion implies publishing this series of articles).  Such a training demo project for people who were thinking of posting their open source, but were either afraid or did not know how. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Of course, I would not mind if the library somehow came to life and there is a minimal amount of library advertising in the articles (I tried to hide it under spoilers).  But still, the objectives of this cycle I considered more educational and, I hope, applicable in general, without regard to my library. <br><br>  Please take this into account when reading a series of articles. <br></div></div><br><br>  Create objects by the string names of their classes and receive information about the heirs of classes during program execution.  C ++ either does not support or poorly supports similar functionality out of the box. <br><br>  In this series of articles I will talk in detail about how I created my own micro-library that implements such behavior and how I prepared it for publication. <br><br><div class="spoiler">  <b class="spoiler_title">Links to all articles of the cycle</b> <div class="spoiler_text">  <a href="https://habrahabr.ru/post/281993/">1. About development</a> <br>  <a href="https://habrahabr.ru/post/281995/">2. About preparation for publication</a> <br>  <a href="https://habrahabr.ru/post/281997/">3. About the result</a> <br></div></div><br><br><a name="habracut"></a><br><br>  My conscience will not be clear if I do not confess one cunning thought that pushed me to write this cycle of articles.  As it concerns marketing, I use hide-and-seek under cat.  I warn you: there is a lot of text there. <br><br><a name="marketing_intro"></a><div class="spoiler">  <b class="spoiler_title">Spacious intro with self-exposure about PR and stuffed cones</b> <div class="spoiler_text"> I will come from afar ... <br><br>  While reading these articles, you will see a reference to a certain ‚Äúmain library‚Äù, of which cpprt was a part.  I am working on this very ‚Äúmain library‚Äù (which does not even have a name yet, only conditional data_mapping) in pure time for the second month.  And about the ‚Äúmain library‚Äù I had one very naive idea.  I wanted to earn on it. <br><br>  Do you understand?  Earn at the library.  And at the utility library.  And selling it to people on their own, and not through some kind of platform ... Madness.  The plan was as follows: <br><br>  1. Create a kind of relatively stable core of the functional, which would show the main features of the library on a few spectacular examples. <br>  2. Find people who will light up the idea of ‚Äã‚Äãthe project.  It was planned to search among friends (and through friends), at conferences, through social networks, etc. <br>  3. Having found like-minded people, bring them up to date on the project and ensure that they begin to commit to the project repository. <br>  4. Collective forces bring the project to a commercial type, find out about the sale mechanisms on the way (only here, pay attention, find out - holy simplicity! ..) and start selling the library.  The profit from sales was planned to be divided as a percentage of some honest, predetermined conditions between the main participants. <br>  5. After sales, as a founder, I hoped to delegate the support and development tasks to other participants (perhaps, having somewhat reduced my percentage of profits) and continue to invest less effort in the library and do my most important things myself, having this is a source of more or less stable income. <br>  6. Well, here, as it should be, where could it be without him ... PROFIT! <br><br>  The strangest thing, I seriously believed in the efficiency of this plan. <br><br>  I believed in this plan, despite the fact that I had five years of experience in developing my pet projects and I knew that people have a tendency to want to live life outside working hours, and this very ‚Äúdesire to live life‚Äù for a very small number of acquaintances (where then for one and a half acquaintances, to be honest) means "to code all the interesting things on the pros."  I knew that it was impossible to lure experienced colleagues into my repositories, and it was almost impossible to pull interested students up to the level of a worthy committer. <br><br>  I believed in this plan even after I asked a <a href="https://toster.ru/q/236510">question</a> and got an <a href="http://www.apofig.com/2015/09/pet-project.html">answer in the</a> <a href="https://toster.ru/user/apofig">apofig</a> user <a href="https://toster.ru/user/apofig">blog</a> (aka Sanyok Baglay, thanks to him).  The essence of the answer boiled down, in brief, to the fact that the library, even if it starts to be sold, is the same work - and the work is sometimes more convict and nervous than a peaceful plowing for an uncle. <br><br>  I believed in this plan, regularly working on the code for two months in a row.  And only happened two weeks ago, already at the time of writing this series of articles, the conversation really opened my eyes to the true order of things.  I present the essence of this conversation below and very much hope that he will justify such a long and extensive introduction: <br><br>  <b>Answer Yuriy Roshchenko</b> <br><br>  The man who dotted <i>i</i> was named <a href="https://ua.linkedin.com/in/yuriyroshchenko">Yuri Roshchenko</a> .  He worked as a department manager at a large international outsourcing company and was well versed in managing projects in general.  Yuri spent forty minutes of his time talking to me, for which I am extremely grateful to him. <br><br>  Having stated my plan for developing the library, I received an unequivocal answer: no, it does not work that way.  We need to act completely differently.  And Yuri told how.  Combining Yury Roshchenko‚Äôs answer and some advice from Alexander Baghlay, I formulated the following project development steps: <br><br>  1. Design the minimum repository of the project with a description and demonstration of its capabilities.  At the same time, it is important that the project be launched without complicated settings, in one click, without any participation from you as the author and source of hints. <br><br>  2. Show the project to the widest possible circle of acquaintances: colleagues in the companies where you worked, friends, etc.  Give access to the repository, offer to test the project.  This is what apofig indicated was ‚Äúgive him [the user] a tool in his hand, shut his mouth and see what he will do with it.‚Äù <br><br>  3. The next item was a revelation to me.  According to Yuri, if the project has a positive reaction from friends, you need - attention!  - <b>roll it to open source</b> .  How can you!! .. I always shook over my achievements like aki Koschey Immortal over gold.  The idea of ‚Äã‚Äãso easily giving back the fruits of their labors sounded seditious to me.  ‚ÄúSnooze!‚Äù I thought.  ‚ÄúThey will steal, make a splash!‚Äù - I thought. <br>  No, Yuri answered me.  Everything will be fine ... Why everything will be fine, he explained further. <br><br>  4. After the publication of the project in open source, you need to maximize it.  More publicity - more users, more caught bugs, more really useful features requested directly from people who have tried the project.  The quantity according to Hegel tends to grow into quality, and users - into contributors.  More contributors - even higher quality project, even more <a href="https://help.github.com/articles/about-stars/">stars</a> .  More stars, a higher position of the project on the repository, which means more publicity and ... the circle is closed.  And in this case, the fact that the circle closes is very good. <br>  <i>Note:</i> If it is not clear who the contributors are, it does not matter.  Here is a <a href="https://guides.github.com/activities/contributing-to-open-source/">link</a> to a short article about the roles of GitHub users.  Contributors are such good people who make a pull request to your project. <br><br>  5. At some point, commercial companies may start using the project.  You need to find out who uses, you need to write the names of companies as advertising - because if a product is used by projects that bring profit to its authors, this means that the product itself is also quite valuable. <br>  And only at this moment it makes sense to create a closed fork from your open repository and you can try to sell it under a commercial license, spicing up the free version with some additional useful and necessary features. <br>  As the owner, you will have access to information that is very useful for commercializing the library: download statistics, frequently asked questions and code use patterns, different offers that can come to you as the project owner from users directly. <br>  In the context of the conversation, Yury answered the question here why the library was not stolen and not plagiarized.  The fact is that, as a founder, you will always understand the project deeper than most contributors.  In order for potential intruders to understand the project and write similar code, they will have to spend a lot of time and energy or - speaking differently - money.  And this, in turn, means that no one will be engaged in such activities until the purchase of a library becomes much more expensive than investing in the development of its clone. <br><br>  6. If the project becomes astronomically famous, and you feel that even some Google wants the same thing as yours - you should try to sell it.  To sell is success, it is good.  Properly bargaining, you can gain from the sale of as much money as you yourself can hardly earn from this library in a lifetime. <br>  Moreover, if you bother, there is a real risk that some Google will write the same library as yours during the week, and you will be left with nothing. <br><br>  On points, it seems, everything.  I will add a few comments from Yuri: <br>  - It is necessary to remember about two turning points in the development of the project: (1) the moment when it makes sense to make a commercial fork, and (2) the moment when it will be more expensive for someone to buy a project than to write it yourself. <br>  - Habra is a really good platform for popularizing the project in the Russian-speaking segment of the Internet.  My interlocutor mentioned here the guys from PVS-studio, who are promoting their product in Habr√©, at the same time telling people useful things. <br>  - It is important to remember about the English segment - and focus largely on him too. <br><br>  In general, I have stated here all the main thoughts that I learned from the conversation.  I hope someone will help the presented algorithm.  And, I hope also, someone will share in the comments their experiences and their thoughts on this issue.  I am sure it will be useful for the whole community. <br><br>  ... yes, I almost forgot.  I wanted to admit one trick. <br><br>  The fact is that this cycle of articles concerns a very small, but, in my opinion, self-sufficient part of the ‚Äúmain library‚Äù, pinched from it and turned into a library.  Using her example, I decided to try what it is to promote and publish open source software.  To follow in this way the way to be followed later for the ‚Äúmain library‚Äù ... At the same time, of course, I am honestly ready to support the cpprt library itself, to which this series of articles is dedicated, if it interests anyone. <br><br>  Perhaps someone can consider my idea of ‚Äã‚Äãmanipulation.  It is possible ... But I justify myself by trying to tell in as much detail as possible about my experience, which can be valuable for people who want to solve similar problems someday. <br>  I hope this pays for the time that you, dear readers, spend on reading this series of articles. <br></div></div><br><br>  This series of articles consists of three parts: <br><br>  <a href="https://habrahabr.ru/post/281993/">The first part, retrospective</a> .  It details the history of the development of the micro-library. <br>  <i>Why read:</i> This part is intended for people who are interested in what kind of bumps can be stuffed in the process of writing code to register information about classes before the start of the main () function.  Serious C ++ programmers may find this part naive and not interesting. <br><br>  <a href="https://habrahabr.ru/post/281995/">The second part, the publication</a> .  Describes the preparation of the library repository for publication: the choice of license, the organization of the repository structure, the study of CMake, etc. <br>  <i>Why read:</i> This part can be useful for people who have their own library gathering dust and want to know how to present this library to people. <br><br>  <a href="https://habrahabr.ru/post/281997/">The third part, the documentation</a> .  Here is a look at the library from the user's point of view: the main use cases of use, the mechanism for registering classes, the API for creating objects using string class names, the API for accessing information about inherited classes through specifying the parent class during program execution.  This part contains sample code as well as future plans. <br>  <i>Why read:</i> This part can be useful for people who want to get the functionality provided by cpprt in their project, and also, again, for those who want to contribute to the development of the library and, perhaps, even to the development of the ‚Äúmain library‚Äù. <br><br>  For this, I finish the cycle, and turn to the essence of this particular article. <br><br><a name="introduction"></a><h3>  0. Introduction </h3><br><br>  The structure of this article: <br><br>  <a href="https://habr.com/ru/post/281993/">Section number 0</a> .  This section.  It tells about the cpprt library analogues and gives some thoughts on why cpprt has a right to exist if there are serious analogues. <br>  <a href="https://habr.com/ru/post/281993/">Section number 1</a> .  Why do I need reflection in C ++. <br>  <a href="https://habr.com/ru/post/281993/">Section number 2</a> .  About finding a solution for the arisen task. <br>  <a href="https://habr.com/ru/post/281993/">Section number 3</a> .  About the first implementation of the class registration mechanism. <br>  <a href="https://habr.com/ru/post/281993/">Section number 4</a> .  About what problems there were in the first decision about how I corrected them. <br>  <a href="https://habr.com/ru/post/281993/">Section number 5</a> .  Adding the ability to register information about inheritance. <br>  <a href="https://habr.com/ru/post/281993/">Section number 6</a> .  Conclusion <br><br>  And now, finally, we start the conversation. <br><br>  At the time of publication of this series of articles, my library allows very little: <br>  1. Create objects by the string name of their classes. <br>  2. Get information about the successors of classes at runtime. <br><br>  Already when working on an article a friend threw a link to <a href="https://habrahabr.ru/post/257071/">this review of</a> existing libraries.  It refers to really powerful projects.  They allow you to equip C ++ classes with a thick layer of meta information and related functionality: create objects using string class names, get a list of fields and methods of classes during program execution, call these methods ... In short, they allow you to bathe in whole oceans of meta information.  My achievements seemed insignificant in the shadow of competitors.  However, having calmed down a bit, I thought: perhaps there is a certain meaning to tell about the work I have done. <br><br>  First, in these articles a lot of attention is paid to retrospective: what difficulties I encountered in the process of work, as I solved them.  This can be useful as an educational material. <br><br>  On the other hand, this cycle talks about how I prepared the library for publication: I researched licenses, dealt with CMake, with the world of open source software, and how it is common to design my projects in this world.  This can also be useful to someone. <br><br>  Well and, finally, yes, let my micro-library really be very limited in its possibilities in comparison with the existing bison of the C ++ reflection.  But perhaps this is its advantage.  The smaller the library, the easier it is for the user to become aware of the features of her work and the easier it is for her to integrate into the project.  Need a heaped reflection - use a powerful library.  We need a set of several simple features - you can try cpprt. <br><br><a name="motivation"></a><h3>  1. Why did I need this functionality </h3><br><br>  C ++ is known for its effectiveness.  The code written on it comes out well optimized primarily due to the possibility of fine-tuning the use of computer resources.  C ++ - really allows you to write very well optimized code.  But you have to pay for it. <br><br>  On the altar of efficiency, among other things, put the possibility of using some metadata during the execution of the program.  Yes, there is <a href="https://en.wikibooks.org/wiki/C%252B%252B_Programming/RTTI">RTTI</a> with its typeid and dynamic_cast.  There are <a href="http://www.boost.org/doc/libs/1_58_0/libs/type_traits/doc/html/index.html">Boost.TypeTraits</a> .  But RTTI is often turned off to save resources ( <a href="http://stackoverflow.com/questions/579887/how-expensive-is-rtti">link about</a> ), and Boost.TypeTraits, being a template-based library, is not particularly friendly with the logic of program execution time and generates a lot of service specializations of its templates. <br><br>  However, sometimes it is impossible to do without the possibility of creating a class by its string name.  For example, I needed such an opportunity within the framework of the serialization mechanism: for saving and loading objects stored by pointers to the parent class.  Sounds maybe not very clear.  I will explain in more detail. <br><br>  Suppose we have a system for maintaining the state of class objects.  Let its use look something like this: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      ISerializable  //   ,    class ISerializable { virtual void save(Serializer *inSerializer) = 0; virtual void load(Deserializer *inDeserializer) = 0; } class Base : public ISerializable { virtual void save(Serializer *inSerializer) { /*     inSerializer */ } virtual void load(Deserializer *inDeserializer) { /*     inDeserializer */ } }; class Derived : public Base { virtual void save(Serializer *inSerializer) { /*     inSerializer */ } virtual void load(Deserializer *inDeserializer) { /*     inDeserializer */ } };</span></span></code> </pre> <br><br>  Test code that saves / loads data: <br><br><pre> <code class="cpp hljs">Base *theBase = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Derived(); . . . <span class="hljs-function"><span class="hljs-function">Serializer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">theSerializer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"save.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; theSerializer.save(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, theBase); theSerializer.flush(); . . . <span class="hljs-function"><span class="hljs-function">Deserializer </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">theDeserializer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"save.txt"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; theBase = theDeserializer.load(<span class="hljs-string"><span class="hljs-string">"name"</span></span>);</code> </pre><br><br>  When saving an object stored by pointer to the parent class, the serializer will call the heir's save (...) method due to polymorphism.  But when loading, the deserializer must somehow find out exactly what class the object had at the time of saving in order to be able to create it. <br><br>  It follows that at the stage of saving you need to have a certain object class identifier, by which at the stage of loading we will be able to find out which class object you need to create and, using this identifier, through a certain API you can create an object of the required class. <br><br>  The same thought in the form of code: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveInt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *inName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> inValue)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *inName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;inValue)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-comment"><span class="hljs-comment">// . . . //      ‚Äì    //  save( )       save(...) void saveObject(ISerializable *inObject) { inObject-&gt;save(this); } }; class Deserializer { int loadInt(const char *inName) { ... } void loadString(const char *inName, std::string &amp;outValue) { ... } // . . . ISerializable *loadObject() { //     -  ,  //     ‚Äì   ,  //    ISerializable *theObject = new &lt; ??? &gt;( ) theObject-&gt;load(this); return theObject; } };</span></span></code> </pre><br><br>  Output: the code of methods for saving objects should be extended using some kind of API.  Time to prototype! <br><br><img src="https://habrastorage.org/files/d27/10f/1d7/d2710f1d72c244ab934e5252f688dd7f.jpg"><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ISerializable *inObject)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  ,     this-&gt;saveObjectType(inObject-&gt;classID()); // &lt;&lt;&lt;--‚Äì classID() inObject-&gt;save(this); }; ISerializable *loadObject() { //         ISerializable *theObject = objectFabric().create( this-&gt;loadObjectType());// &lt;&lt;&lt;--‚Äì objectFabric().create(...) theObject-&gt;load(this); return theObject; };</span></span></code> </pre><br><br>  Throwing in this way the general view of the desired API, I took up the search for a solution that would provide similar functionality. <br><br><a name="first_find"></a><h3>  2. Search for a solution </h3><br><br>  For a start, I googled to find out what people think about the right behavior.  I wanted something lightweight, without a thousand dependencies, without using auxiliary systems like <a href="http://doc.qt.io/qt-4.8/moc.html">Qt MOC</a> (another <a href="https://habrahabr.ru/post/214379/">article</a> on the topic) and, among other things, easy to use.  It was not possible to find a ready-made solution in the form of a library that meets the specified criteria. <br><br><div class="spoiler">  <b class="spoiler_title">Note</b> <div class="spoiler_text">  As I wrote above, already at the time of writing, a link appeared on the review of high-quality existing solutions ( <a href="https://habrahabr.ru/post/257071/">here it</a> is again).  It is very strange that google on the request of ‚Äúc ++ reflection‚Äù gave the first link to the strange article <a href="https://habrahabr.ru/post/243571/">‚ÄúMy bike to reflection in c ++‚Äù</a> , and not to this relevant publication. <br></div></div><br><br>  I started to think how to implement similar functionality on my own. <br><br>  Solutions, by and large, revolved around the description of factory functions and / or classes that were registered and used further through a mechanism that selected the right factory depending on the class name transferred.  In this article, I decided to highlight <a href="http://stackoverflow.com/questions/582331/is-there-a-way-to-instantiate-objects-from-a-string-holding-their-class-name/582456">this answeroverflow</a> answer (by <a href="http://stackoverflow.com/users/34509/johannes-schaub-litb">Johannes Schaub</a> , thanks to him for the idea), since it embodies the main approaches found in the network. <br><br>  The first idea proposed by Johannes Schaub implied the use of a template factory function and the preservation of its specializations in the dictionary.  I didn‚Äôt really like the idea by itself - the mechanism looked somehow incomplete, without a beautiful object wrapper.  However, some echoes of such an implementation can be found in the resulting final cpprt implementation (using factory classes). <br><br>  The second idea from Johannes Schaub: the inclusion of the mechanism for registering factories in class constructors that [constructors] were invoked when creating static objects of these classes.  I liked this idea, especially considering the proposed macros: the macros allowed to hide the details of the registration mechanism, due to which this mechanism could be changed from version to version of the library without side effects for code users. <br><br>  I quote here the solution of Johannes Schaub with minimal changes and with my comments: <br><br><div class="spoiler">  <b class="spoiler_title">Johannes Schaub Solution</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// in base.hpp: //   .    . //     Base,  Johannes,   , //        . //  ,         //  void, ,  , . //        Base,   //       || (    ). template&lt; typename T &gt; Base * createT() { return new T; } //    ""   struct BaseFactory { // ,        //        // .       ,   //   createT    // (      ). typedef std::map&lt; std::string, Base*(*)() &gt; map_type; //         // ... ,     . static Base *createInstance(std::string const&amp; s) { map_type::iterator it = getMap()-&gt;find(s); return (it == getMap()-&gt;end()) ? NULL : it-&gt;second(); } protected: //  ,    - //  map    .   //    ,  //     . static map_type * getMap() { //  Johannes Schaub: // never delete'ed. (exist until program termination) // because we can't guarantee correct destruction order if(!map) { map = new map_type; } return map; } private: static map_type * map; }; // ,      //    . ,   //   ‚Äì  ,  ,    T   //       . template&lt; typename T &gt; struct DerivedRegister : BaseFactory { DerivedRegister(std::string const&amp; s) { getMap()-&gt;insert(std::make_pair(s, &amp;createT&lt; T &gt;)); } }; // in derivedb.hpp //  ,    , //  Johannes Schaub.   , Johannes Schaub //     Base.   : class DerivedB : public Base { ...; private: //       reg. static DerivedRegister&lt; DerivedB &gt; reg; }; // in derivedb.cpp: //  ( ,     DerivedB) //    ,    //       . //        //  DerivedRegister&lt; DerivedB &gt;    //     DerivedB DerivedRegister&lt; DerivedB &gt; DerivedB::reg("DerivedB");</span></span></code> </pre><br></div></div><br><br>  Johannes Schaub also proposed macros to simplify type registration.  They allow you to close the features of the implementation of the registration system and make the code more concise: <br><br><div class="spoiler">  <b class="spoiler_title">Macros from Johannes Schaub</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> REGISTER_DEC_TYPE(NAME) \ static DerivedRegister</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NAME&gt; reg #define REGISTER_DEF_TYPE(NAME) \ DerivedRegister&lt;NAME&gt; NAME::reg(#NAME)</span></span></span></span></code> </pre><br></div></div><br><br>  I took the decision of Johannes Schaub as a basis, slightly changing it to your liking. <br><br><a name="first_impl"></a><h3>  3. First implementation </h3><br><br>  The Johannes Schaub solution had a DerivedRegister template class, whose objects of specializations were created as static fields within the registered classes (static DerivedRegister reg).  First of all, I decided to transfer factory functions to the DerivedRegister class as factory methods.  Due to this, in addition to simplifying the code, it was possible to expand the meta information about the registered classes by simply adding fields to the DerivedRegister class. <br><br>  I also transferred information about the string name of classes to my DerivedRegister counterpart, thus starting to use it as a repository of meta-information (so far only the string name of the class was used as meta-information). <br><br>  There was, in fact, the implementation of the design pattern of an <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25B1%25D1%2581%25D1%2582%25D1%2580%25D0%25B0%25D0%25BA%25D1%2582%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2584%25D0%25B0%25D0%25B1%25D1%2580%25D0%25B8%25D0%25BA%25D0%25B0_(%25D1%2588%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F)">abstract factory</a> with some frills for the possibility of executing the metadata registration code before the start of the main () function: <br><br><div class="spoiler">  <b class="spoiler_title">ClassManager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ( DerivedRegister   // Johannes Schaub).        // .      //  createAbstractObject() // class IClassManager { private: const char *_name; public: IClassManager(const char *inClassName) : _name(inClassName) { } //-‚Äì Workflow const char *name() const { return _name; } virtual IManagedClass *createAbstractObject() = 0; }; //----------------------------------------------------------------- //   .   //          //      . //     . template&lt;typename T_Type&gt; class ClassManager : public IClassManager { public: //   ,     // Johannes Schaub,  ,  : ClassManager(const char *inClassName) : IClassManager(inClassName) { globalRuntime.registerClass(this); } T_Type *createObject() { return new T_Type(); } virtual IManagedClass *createAbstractObject() { return createObject(); } };</span></span></code> </pre><br></div></div><br><br>  The variable globalRuntime is a global object that is dedicated to managing all meta-information machinery.  In fact, just an object wrapper around a vector storing ClassManager specialization objects. <br><br>  Consider the class code whose object is globalRuntime.  I think the essence of his work will be clear without comment: <br><br><div class="spoiler">  <b class="spoiler_title">CPPRuntime.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CPPRuntime</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; IClassManager * &gt; _registries; <span class="hljs-function"><span class="hljs-function">IClassManager *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">managerByName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *inName)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: CPPRuntime() : _registries() { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">registerClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IClassManager *inClass)</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">IManagedClass *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *inClassName)</span></span></span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//----------------------------------------------------------------------------- extern CPPRuntime globalRuntime;</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">CPPRuntime.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">IClassManager *CPPRuntime::managerByName(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *inName) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> theIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>, theSize = _registries.size(); theIndex &lt; theSize; ++theIndex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == <span class="hljs-built_in"><span class="hljs-built_in">strcmp</span></span>(_registries[theIndex]-&gt;name(), inName)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _registries[theIndex]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//-‚Äì Registering void CPPRuntime::registerClass(IClassManager *inClass) { _registries.push_back(inClass); } //-‚Äì Public API IManagedClass *CPPRuntime::createObject(const char *inClassName) { IClassManager *theRegistry = managerByName(inClassName); //</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> Through an exception if no class found return theRegistry-&gt;createAbstractObject(); } //----------------------------------------------------------------------------- CPPRuntime globalRuntime;</span></span></code> </pre><br></div></div><br><br>  It remained to describe the base class IManagedClass (analogue of the Base class from the Johannes Schaub solution) and create macros to simplify the mechanism for registering classes. <br><br>  In connection with the description of the base class IManagedClass, you should recall the API for which everything was started: <br><br>  1. <b>API for loading data</b> .  Ability to create an object by ID: <br>  <i>objectFabric (). create (inObjectID)</i> <br>  This is done by the globalRuntime.createObject ("ClassName") method. <br><br>  2. <b>API for saving data</b> .  Ability to get object class identifier: <br>  <i>object-&gt; classID ()</i> <br>  <i>The solution proposed by Johannes Schaub did not include a similar API.</i>  <i>You have to implement it yourself</i> . <br><br>  I sketched the use case for inheriting IManagedClass using the example of a single class.  I think that here, too, everything will be more or less clear without unnecessary comments: <br><br><div class="spoiler">  <b class="spoiler_title">TestClass.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--------------------------------------------------------------------------------------------------- //  ,     . //        //  . class IClassManager { public: virtual IClassManager *getRegistry() = 0; }; //--------------------------------------------------------------------------------------------------- //  ,   .   //          //          //      . class TestClass : public IClassManager { public: //     .     . static ClassManager&lt; TestClass &gt; gClassManager; virtual IClassManager *getRegistry() { return &amp;gClassManager; } public: };</span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">TestClass.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    gClassManager   //      TestClass   //   .        . ClassManager&lt; TestClass &gt; TestClass::gClassManager("TestClass");</span></span></code> </pre><br></div></div><br><br>  I ran the code using this class, namely, the call to globalRuntime.createObject ("TestClass").  The object is safely created. <br><br>  It remained to describe the macros that would remove from the user the need to manually make copy-paste code for registering classes: <br><br><div class="spoiler">  <b class="spoiler_title">Macros.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CPPRT_DECLARATION(M_ClassName)\ public:\ static ClassManager</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; M_ClassName &gt; gClassManager;\ virtual IClassManager *getClassManager() { return &amp;gClassManager; }\ protected:\ //  ,         ,   namespace. #define CPPRT_IMPLEMENTATION(M_ClassName) ClassManager&lt; M_ClassName &gt; M_ClassName::gClassManager(#M_ClassName);</span></span></span></span></code> </pre><br><br>  <b>Note: The</b> CPPRT prefix is ‚Äã‚Äãfirst mentioned here.  This is short for <i>C Plus Plus Run Time</i> . <br><br></div></div><br><br>  Macro was ready.  The principle of its use did not differ from the principles of using the macro proposed by Johannes Schaub: <br><br><div class="spoiler">  <b class="spoiler_title">The principle of using macro</b> <div class="spoiler_text">  For example, we want to register a class TestClass.  We declare a class: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--‚Äì TestClass.h --- class TestClass : public IClassManager { //         //  ‚Äì      // ,       protected CPPRT_DECLARATION(TestClass) . . . };</span></span></code> </pre><br><br>  Next, create the implementation file.  In the implementation file, we use a macro to describe a static object that stores information about the CPPRT_IMPLEMENTATION class (we recall that we only declared this object through the CPPRT_DECLARATION macro). <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--‚Äì TestClass.cpp --- CPPRT_IMPLEMENTATION(TestClass)</span></span></code> </pre><br></div></div><br><br>  Done!  Trembling with impatience, I wrapped the described macros with a hierarchy of my classes, implemented serialization / deserialization methods using the newly created API, launched the code ... <br><br>  Hooray!  Objects are correctly saved and loaded, keeping their type!  I tested everything thoroughly, saving objects of different classes.  It worked!  I didn‚Äôt expect that everything would start so easily at once ... <br><br><a name="first_problems"></a><h3>  4. The first problems and the fight against them </h3><br><br>  ... and I was absolutely right.  Actually, in the written code there was one dangerous error.  At some point - namely, when I added the next registered class - everything broke.  Some classes stopped registering, and I couldn‚Äôt catch the sign on which the registration of classes fell off.  Random of some kind.  I spent half an hour of time moving from debug to logging and back.  The ClassManager constructor for each class was called.  Registration, respectively, took place ... But when it came to creating an object of a certain class globalRuntime.createObject (‚ÄúSomeHellClass‚Äù), it turned out that there was no ClassManager for the class SomeHellClass in the array of registered class managers. <br><br>  It took me a minute to think that one of the two of us was crazy: either I or C ++.  And, as always, it turned out that I had lost my mind.  Everything fell into place when I tried to add / delete sources for transfer to compilation.  Each time the set of classes changed, the registration of which ‚Äúfell off‚Äù.  That is, it was in the order of compilation of the associates. <br><br>  People who have carefully read the code, I think, have already understood the reason for the error. <br><br>  Notice how the globalRuntime was defined: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--‚Äì CPPRuntime.h --- extern CPPRuntime globalRuntime; //--‚Äì CPPRuntime.cpp --- CPPRuntime globalRuntime;</span></span></code> </pre><br><br>  This is a global object.  Not nested in a function and thus created at the time of the first function call, but simply a global object. <br><br>  In this case, we recall the implementation of the ClassManager template class constructor, in which ClassManager objects of specialization register themselves within the globalRuntime object: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--‚Äì ClassManager.h --- ClassManager(const char *inClassName) : IClassManager(inClassName) { globalRuntime.registerClass(this); }</span></span></code> </pre><br><br>  And we also recall how objects of the ClassManager specializations are created (they are described via macros): <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CPPRT_DECLARATION(M_ClassName)\ public:\ static ClassManager</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; M_ClassName &gt; gClassManager;\ virtual IClassManager *getClassManager() { return &amp;gClassManager; }\ protected:\ #define CPPRT_IMPLEMENTATION(M_ClassName)\ ClassManager&lt; M_ClassName &gt; M_ClassName::gClassManager(#M_ClassName);</span></span></span></span></code> </pre><br><br>  ClassManager specialization objects (for example, SomeHellClass :: gClassManager object) are also global variables! .. They must be global variables: it‚Äôs important that a constructor be executed for each such object before running main (), otherwise the registration of such objects will not be performed. <br><br>  And now let's remember: in what order are the constructors of global and static variables in C ++ called? .. Yes, that's right.  In random order ( <a href="http://stackoverflow.com/questions/1271248/c-when-and-how-are-c-global-static-constructors-called/1271692">stackoverflow</a> , quotation from the Standard is also available there).  What follows from this? <br><br>  And this implies the possibility that the constructor of the globalRuntime object can be called <i>after</i> the constructors of any ClassManager specializations have been called.  The situation is very bad: in the object constructors of the ClassManager specializations (objects with the names gClassManager), the methods of an object that has not yet been created (globalRuntime) can be accessed.  This behavior could lead to some kind of stall, but did not lead - which is even worse in this case.  Typical undefined behavior. <br><br>  Do not do this.  Never. <br><br><div class="spoiler">  <b class="spoiler_title">Optional note</b> <div class="spoiler_text">  The funny thing is that access to the globalRuntime object from somewhere in the ‚Äúnormal‚Äù code, which goes to main () with the rootstock‚Äôs roots, would not be a problem: the standard ensures that the constructor of the global object must be called before the main () call. <br></div></div><br><br>  Fixing the problem was obvious: for correct access to the object, it was necessary to implement one of the variations of the <a href="http://stackoverflow.com/questions/17712001/how-is-meyers-implementation-of-a-singleton-actually-a-singleton">singleton Meyers</a> (a more detailed <a href="https://habrahabr.ru/post/147373/">article on singletons</a> can be found there and about this singleton): <br><br>  <s><i>extern CPPRuntime globalRuntime;</i></s> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--‚Äì CPPRuntime.h --- CPPRuntime &amp;globalRuntime();</span></span></code> </pre><br><br>  <s><i>CPPRuntime globalRuntime;</i></s> <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//--‚Äì CPPRuntime.cpp --- CPPRuntime &amp;globalRuntime() { // , ,      ,  //        ‚Äì     // header only . ,   thread safe... static CPPRuntime sCPPRuntime; return sCPPRuntime; }</span></span></code> </pre><br><br>  Access through the function provides guaranteed creation of an object of the CPPRuntime class at any time, from anywhere in the code. <br><br>  After fixation, all that remained was to make a change to the ClassManager specialization constructor, which accessed the CPPRuntime class object: <br><br><pre> <code class="cpp hljs">ClassManager(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *inClassName) : IClassManager(inClassName) { <span class="hljs-comment"><span class="hljs-comment">//     CPPRuntime  , //   globalRuntime() globalRuntime().registerClass(this); }</span></span></code> </pre><br><br>  I drove a good code through different hierarchies of objects, changing the list of sources sent for compilation - in order to verify exactly that now everything is fine. <br><br>  Everything was really good. <br><br>  As time went on, the main library lived its own life, developed.  And at some point a new functional was needed ... <br><br><a name="inheritance"></a><h3>  5. Genealogy of classes </h3><br><br>  At some point it became necessary to collect information about the heirs of classes during the execution of the program.  I will not go into details, why exactly this was needed - I‚Äôll tell you about it sometime when the time comes to publish the main library.  In order to have a more substantive conversation, suppose that this was necessary for debugging purposes: for the convenience of viewing information about registered classes for especially large projects. <br><br>   boost (is_base_of)          compile time ( <a href="http://stackoverflow.com/questions/2910979/how-does-is-base-of-work"> </a> is_base_of   <a href="http://www.boost.org/doc/libs/1_58_0/libs/type_traits/doc/html/boost_typetraits/reference/is_base_of.html">API</a>     boost). <br><br>   , ‚Ä¶  ! <br><br><img src="https://habrastorage.org/files/d27/10f/1d7/d2710f1d72c244ab934e5252f688dd7f.jpg"><br><br> API  - : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; IClassManager * &gt; theChildManagers; <span class="hljs-comment"><span class="hljs-comment">//      ClassManager // (       IClassManager) //  -  BaseClass. globalRuntime(IClassManager).getChildren(BaseClass::gClassManager, theChildManagers); //     ‚Äì   // -  BaseClass: std::cout &lt;&lt; "Children of class " &lt;&lt; BaseClass::gClassManager.name() &lt;&lt; std::endl; for (size_t theIndex = 0, theSize = theChildManagers.size(); theIndex &lt; theSize; ++theIndex) { std::cout &lt;&lt; theChildManagers[theIndex]-&gt;name() &lt;&lt; std::endl; }</span></span></code> </pre><br><br> ,    API,        ,     . <br><br>      API       ,   ,       API  . <br><br>     :   ClassManager      ClassManager    .   : <br><br><div class="spoiler"> <b class="spoiler_title">ClassManager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClassManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: . . . <span class="hljs-comment"><span class="hljs-comment">//      //    std::vector&lt; IClassManager *&gt; _parents; std::vector&lt; IClassManager *&gt; _children; protected: // ,    ClassManager  //   void setParent(IClassManager *inParent) { _parents.push_back(inParent); inParent-&gt;_children.push_back(this); } . . . }; //----------------------------------------------------------------- template&lt;typename T_Type&gt; class ClassManager : public IClassManager { . . . public: //   , , //    ClassManager(const char *inClassName) : IClassManager(inClassName) { globalRuntime().registerClass(this); } ClassManager(const char *inClassName, IClassManager *inParent0) : IClassManager(inClassName) { globalRuntime().registerClass(this); setParent(inParent0); } ClassManager(const char *inClassName, IClassManager *inParent0, IClassManager *inParent1) : IClassManager(inClassName) { globalRuntime().registerClass(this); setParent(inParent0); setParent(inParent1); } //  ..,      . . . };</span></span></code> </pre><br></div></div><br><br>              : <br><br><div class="spoiler"> <b class="spoiler_title">Macros.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// 0 parents #define CPPRT_IMPLEMENTATION_0(M_Class)\ ClassManager&lt; M_Class &gt; M_Class::gClassManager(#M_Class); // 1 parent #define CPPRT_IMPLEMENTATION_1(M_Class, M_BaseClass0)\ ClassManager&lt; M_Class &gt; M_Class::gClassManager(#M_Class,\ &amp;M_BaseClass0::gClassManager); // 2 parents #define CPPRT_IMPLEMENTATION_2(M_Class, M_BaseClass0, M_BaseClass1)\ ClassManager&lt; M_Class &gt; M_Class::gClassManager(#M_Class,\ &amp;M_BaseClass0::gClassManager,\ &amp;M_BaseClass1::gClassManager); //  ..,     </span></span></code> </pre><br></div></div><br><br>     CPPRuntime ,            ClassManager.      ,      : <br><br><div class="spoiler"> <b class="spoiler_title">CPPRuntime.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CPPRuntime</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ,    void CPPRuntime:: getClassRegistries_internal( IClassManager *inClassManager, std::vector&lt;IClassManager *&gt; &amp;outRegistries) public: // ,     CPPRuntime. //     getClassRegistries_internal(...) //  ,     API  //    . void getChildren(IClassManager *inBaseRegistry, std::vector&lt; IClassManager *&gt; inChildRegistries); . . . }; . . .</span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">CPPRuntime.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">. . . <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> CPPRuntime::getClassRegistries_internal( IClassManager *inRegistry, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;IClassManager *&gt; &amp;outRegistries) { <span class="hljs-comment"><span class="hljs-comment">//   ClassManager    outRegistries.push_back(inRegistry); std::vector&lt; IClassManager * &gt; &amp;theChilds = inRegistry-&gt;_childs; for (size_t theIndex = 0, theSize = theChilds.size(); theIndex &lt; theSize; ++theIndex) { //        //  ClassManager getClassRegistries_internal(theChilds[theIndex], outRegistries); } } void CPPRuntime::getChildren(IClassManager *inBaseRegistry, std::vector&lt; IClassManager *&gt; &amp;outRegistries) { getClassHeirarhieNames_internal(inBaseRegistry, outRegistries); } . . .</span></span></code> </pre><br></div></div><br><br>     -   (   inRegistry-&gt;_childs   CPPRuntime:: getClassRegistries_internal).       ClassManager   _children,     <a href="http://cppstudio.com/post/8423/">friend</a> . ,   ,      : <br><br><div class="spoiler"> <b class="spoiler_title">ClassManager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClassManager</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IClassManager { . . . <span class="hljs-comment"><span class="hljs-comment">//  CPPRuntime    _children. friend class CPPRuntime; . . . };</span></span></code> </pre><br></div></div><br><br>   friend  .  ,   ‚Äî      . <br><br>       .      , /    .    :        ‚Ä¶   _parents  ,   _children ‚Äì .    ? <br><br>    :      .         ClassManager: <br><br><div class="spoiler"> <b class="spoiler_title">Macros.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> CPPRT_IMPLEMENTATION_NO_PREFIX_1(M_Class, M_BaseClass0)\ ClassManager</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; M_Class &gt; M_Class::gClassManager(\ #M_Class,\ &amp;M_BaseClass0::gClassManager);</span></span></span></span></code> </pre><br></div></div><br><br>        ClassManager   ( <i>&amp;M_BaseClass0::gClassManager</i> )    ClassManager   ( <i>M_Class::gClassManager</i> ),       setParent(...): <br><br><div class="spoiler"> <b class="spoiler_title">ClassManager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClassManager</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IClassManager *inParent)</span></span></span><span class="hljs-function"> </span></span>{ _parents.push_back(inParent); inParent-&gt;_children.push_back(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;&lt;--‚Äì   ! } . . . };</span></span></code> </pre><br></div></div><br><br>        ClassManager  ‚Ä¶     ClassManager       ,          ! <br><br>         . <br><br>       .     .   ,      globalRuntime(),    ClassManager <i> </i>    ,    .     <i> </i> :     ClassManager         .         gClassManager    SomeHellClass,     ,   SomeHellClass,   . <br><br><div class="spoiler">  <b class="spoiler_title">Read more</b> <div class="spoiler_text">  ,  ,   ¬´  ¬ª   ClassManager,  ,       CPPRuntime.  , ¬´¬ª           ClassManager (   <i>virtual IClassManager *getRegistry()</i> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//----‚Äì Declaration.h ----- class Base { public: static ClassManager&lt;Base&gt; *getClassManager( ); }; class Child { public: static ClassManager&lt;Child&gt; *getClassManager( ); }; class ChildOfChild { public: static ClassManager&lt;ChildOfChild&gt; *getClassManager( ); };</span></span></code> </pre><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//----‚Äì Declaration.cpp ----- ClassManager&lt;Base&gt; *Base::getClassManager() { static ClassManager&lt;Base&gt; gClassManager("Base"); return &amp;gClassManager; } ClassManager&lt;Child&gt; *Child::getClassManager() { static ClassManager&lt;Child&gt; gClassManager("Child", Base::getClassManager()); return &amp;gClassManager; } ClassManager&lt;ChildOfChild&gt; *ChildOfChild::getClassManager() { static ClassManager&lt;ChildOfChild&gt; gClassManager("ChildOfChild", Child::getClassManager()); return &amp;gClassManager; }</span></span></code> </pre><br><br>    ,  ,      , ,  Child.  ,   ,     ClassManager   .  Like this: <br><br><pre> <code class="cpp hljs">ClassManager&lt;Child&gt; *theManager = Child::getClassManager();</code> </pre><br><br>   getClassManager()    : <br><br><pre> <code class="cpp hljs">. . . <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ClassManager&lt;Child&gt; gClassManager(<span class="hljs-string"><span class="hljs-string">"Child"</span></span>, Base::getClassManager()); <span class="hljs-comment"><span class="hljs-comment">// &lt;&lt;---!!! return &amp;gClassManager; . . .</span></span></code> </pre><br><br>    ,     Base::getClassManager()      ‚Ä¶         !       ChildOfChild::getClassManager().    , ,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   ClassManager . . . globalRuntime().registerClass(this); IClassManager::setParent(inParent0); // &lt;&lt;&lt;--- !!! . . .</span></span></code> </pre><br><br>  Here it is. , -   ,   .          ClassManager <b> -</b> .  getClassManager()     ,   _child          ClassManager  . <br><br>     ,  -      ‚Äì    ,      ++,  ,      . <br></div></div><br><br>  , <i>  </i> ,    ClassManager   ,      ,            ClassManager   ,      CPPRuntime. <br><br> <i>   </i> ,       , ,              ClassManager.         main() ,       dynamic initialization   .  ,     - . <br><br>     ,    :   ,    ,     , ,  . ,         ,    ClassManager    ‚Äì               : <br><br><div class="spoiler"> <b class="spoiler_title">ClassManager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IClassManager</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; _parentsIndexes; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt; _childIndexes; . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setParent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IClassManager *inParent)</span></span></span><span class="hljs-function"> </span></span>{ _parentIndexes.push_back(globalRuntime().indexOf(inParent)); inParent-&gt;_childIndexes.push_back(globalRuntime().indexOf(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>)); } . . . };</code> </pre><br></div></div><br><br><div class="spoiler"> <b class="spoiler_title">CPPRuntime.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CPPRuntime</span></span></span><span class="hljs-class"> {</span></span> . . . <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; IClassManager * &gt; _registries; . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indexOf</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IClassManager *inRegistry)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> theIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>, theSize = _registries.size(); theIndex &lt; theSize; ++theIndex) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_registries[theIndex] == inRegistry) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> theIndex; _registries.push_back(inRegistry); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _registries.size() ‚Äì <span class="hljs-number"><span class="hljs-number">1</span></span>; } . . . };</code> </pre><br></div></div><br><br>          ,  ,    ,       ,      (,    ). <br><br>    ‚Äì     ‚Äì  -  gClassManager.   ,  ,    : <br><br><div class="spoiler"> <b class="spoiler_title">Macros.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs">. . . <span class="hljs-comment"><span class="hljs-comment">// 1 parent #define CPPRT_IMPLEMENTATION_1(M_Class, M_BaseClass0)\ ClassManager&lt; M_Class &gt; *M_Class::getRegistry() { static ClassManager&lt; M_Class &gt; gClassManager(#M_Class, &amp;M_BaseClass0:: getRegistry() ); return &amp;gClassManager; } //   ,       //    ClassManager&lt; M_Class &gt;,  ,  //  .    ,    //        cpp-. // ,           //  .      ‚Äì  , //  ! char __dummy__##M_Class = (char)M_Class::getRegistry(); . . .</span></span></code> </pre><br></div></div><br><br>            .      3.6.2 .  :    <a href="http://stackoverflow.com/questions/22117310/c-global-variable-initialization-order/22117407">stackoverflow</a> ,        <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf"></a> (,  ,       PDF,    3.6.2  ). <br><br><blockquote> Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place </blockquote><br><br>  ,       (): <br><br><pre> <code class="hljs pgsql">getPointer() { //  ,    ,  //  zero-<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ,  //    ,   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!<span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>::gPointer) { <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>::gPointer = initializeValue(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>::gPointer; } <span class="hljs-keyword"><span class="hljs-keyword">Class</span></span>::gPointer = getPointer();</code> </pre><br><br>    ,       .     ClassManager        CPPRuntime,   CPPRuntime    . <br><br>                450  . <br><br><a name="final"></a><h3>  6. Conclusion </h3><br><br>      : <br> 1. <a href="https://bitbucket.org/vsemenyakin/cpprt"></a>  ¬´¬ª  bitbucket.       GitHub.         . <br> 2. <a href="https://github.com/vsemenyakin/cpprt"></a>   GitHub ‚Äî ,         CMake (    <a href="https://habrahabr.ru/post/281995/"> </a> ). <br><br> , .   <i> </i> .  Thanks for attention! <br><br> <i>         ,    </i> <br><br><div class="spoiler"> <b class="spoiler_title"></b> <div class="spoiler_text"> <b> :</b>   <br><br>  <a href="https://habrahabr.ru/users/a1ien_n3t/" class="user_link">a1ien_n3t</a>     .   jpg. <br>  <a href="https://habrahabr.ru/users/sirikid/" class="user_link">Sirikid</a>     (const const)    ClassManager.h. <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/281993/">https://habr.com/ru/post/281993/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281981/index.html">Develop HTML5 games in Intel XDK. Part 7. Design of the game</a></li>
<li><a href="../281983/index.html">Creating a Debian package from scratch</a></li>
<li><a href="../281985/index.html">For the year, Google analyzed 760,000 hacking sites and announced a new tool to alert webmasters.</a></li>
<li><a href="../281989/index.html">Intel security hardware technology: a new word in the protection of biometric applications. Part one</a></li>
<li><a href="../281991/index.html">The PDO MSSQL driver (pdo_sqlsrv) for PHP7 is out</a></li>
<li><a href="../281995/index.html">Droplet of reflection for C ++. Part Two: Posting on GitHub</a></li>
<li><a href="../281997/index.html">A bit of reflection for C ++. Part Three: Documentation</a></li>
<li><a href="../281999/index.html">The experience of automating difficult correspondence (Part 2. Outgoing)</a></li>
<li><a href="../282001/index.html">New course on microcontrollers - a joint project of industry and universities</a></li>
<li><a href="../282003/index.html">Setting up PhpStorm for layout on Windows</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>