<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lines and probability theory</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Everyone who played this game knows: if you now try to pull out the blue ball, which the cursor shows to put a burgundy in its place, then one of the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lines and probability theory</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/b09/676/105/b09676105c43482c831de5d23572ae52.png"><br><br>  Everyone who played this game knows: if you now try to pull out the blue ball, which the cursor shows to put a burgundy in its place, then one of the coming three new balls will most likely ‚Äúshut up‚Äù this place.  If you try to pull it out again, it will shut up again.  Throughout the long years of existence of this effect, my colleagues occasionally had disputes over whether it happened by chance or whether such a ‚Äútrick‚Äù was made on purpose to make it harder to play. <br><br>  Under the terms of the game, it is believed that the balls must fall into random fields.  But for some reason, if there is a free field in the littered part of the board, it is filled first. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, you will be able to go back 20 years ago and see how the reverse engineering process took place then.  We will consider a 16-bit assembler code that chooses a place for the balls.  There will not be modern 32-bit and 64-bit instructions, overgrown with special sets of commands, there will be no calls for dll, streams and other tricks.  Only simple code.  It seems to me that even those who have never seen an assembler will understand it.  Those who wish can correct the algorithm so that it works ‚Äúhonestly‚Äù. <br><a name="habracut"></a><br>  Let's start with the theory.  The simplest obvious algorithm is: choose a random place on the board, and if it is occupied, repeat.  And so on until we get to the free space.  20 years ago, I thought that this was the algorithm chosen by the author of the game and that is why the game is so ‚Äúunfair‚Äù.  I reasoned like this: what is the probability that in such a situation the next ball will fall into the only free field at the top of the board? <br><br><img src="https://habrastorage.org/files/5c0/57b/4f3/5c057b4f35d045ee9ca078a505c2b8a0.png"><br><br>  The probability of hitting the upper and lower halves is the same, but the lower one is almost free, and at the top there is only one free field.  Therefore, if a random number falls into the bottom of the board, the algorithm will end immediately, and if it will drop to the top, it will repeat until it falls into that very single free field.  That's why it turns out that such free fields ‚Äúshut up‚Äù right away, and everything seems to be consistent with the actual behavior of the game. <br><br>  But a person familiar with the theory of probability will immediately say that this is wrong.  It's like a chance to meet a dinosaur on the street.  Or meet, or not.  The probability of a ball hitting any cell is the same, no matter how many and which cells are occupied.  If in the last 10 moves a red ball never fell, then I understand that on the 11th move, most likely, it will still fall, although in fact the probability of falling out is now exactly the same as 10 moves back.  If there is anyone else here who has not seen the " <a href="http://www.youtube.com/watch%3Fv%3DGF7Q4PX-MUQ">god Tetris</a> ", be sure to take a look. <br><br>  Is it really just an incredible set of circumstances or inaccuracies of a pseudo-random number generator?  There is one assumption, but we will not run ahead.  It's time to finally see how everything happens from the inside. <br><br>  Take for example the <a href="http://www.old-games.ru/game/136.html">English floppy version of the</a> game, although you can take any other.  To start you will need an emulator, such as <a href="http://www.dosbox.com/">dosbox</a> .  To study and fix the code, use Hiew.  The author offers to download his <a href="">old DOS version</a> on his website for free. <br><br>  Where to start?  How to find the place in the program where a random number is selected?  The board we have 9x9 cells.  Let's try to look for 16-bit numbers 9 or 81. Nines are many, but 81 is just one.  (81 = 51h) <br><br><img src="https://habrastorage.org/files/054/e5b/342/054e5b3428044596b11932c328c14540.png"><br><br>  That's just the 9s next to him, apparently we attacked the trail.  Let's try to change 51 by 30 at random and see what happens.  We start the game, and she immediately throws the entire field with balls and freezes.  This is unexpected.  Is this 81 irrelevant to the size of the field?  Let's see what kind of cell [343E] where it was written to. <br><br><img src="https://habrastorage.org/files/583/a23/a06/583a23a06fc44b9099d5f27a6260aa4d.png"><br><br>  Well, just below the code the value of this cell is compared with "4C".  Hmmm  76?  What is this?  I do not remember for how long this question put me at a dead end, but suddenly (like everything else in the process) it dawned on me: this is the number of free cells.  At the very beginning of the game, 5 balls appear.  At first the field is empty, there are 81 free cells. Then the balls are thrown out until this number becomes 76. So this is the section of the code where the initial initialization of the board is performed.  One of the subroutines between these operations is to select the position for the ball.  The ‚Äúnot-equal‚Äù transition, labeled as (8), forms a small cycle, in which there are only 2 calls.  Let's see the first one. <br><br><img src="https://habrastorage.org/files/c9d/b86/1a6/c9db861a65944bdb93b7fe62b26c3c3f.png"><br><br>  After the standard operations with the stack, as we see, the number 50h (80) is taken, and is passed as an argument to call some procedure.  The result, it obviously returns in the register AX, which is stored in the variable [bp] [- 2].  Then we take this number, divide it by 9 (div cx), increment it by 1 (inc ax), swap the quotient and the remainder, and store the quotient in the cell [39E4].  Then we do the same, only save the remainder of the same division in the cell [39E6]. <br><br>  Well, yes, it looks like it.  A subroutine is probably a random number.  At the exit, we have a random field number.  Then we divide it by 9, we get two coordinates, X and Y. In a normal language, this could look like this: <br><br><pre><code class="cs hljs">cell = random(<span class="hljs-number"><span class="hljs-number">80</span></span>); x = cell / <span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; y = cell % <span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre> <br>  Go ahead: <br><br><img src="https://habrastorage.org/files/e20/6fe/e46/e206fee4600b40c9b2bb2382cb5a11da.png"><br><br>  Take the previously calculated X and Y. One of them is shifted to the left (shl) by 1 bit (multiplied by 2), memorized in CX.  The other is multiplied by 12 (18), added to CX and used as an array index at [3490].  What could it be?  Well, of course, the contents of the playing field, as a 2-dimensional array of 16-bit numbers.  Therefore, X is multiplied by 2, and Y by 18. That is, we already have: <br><br><pre> <code class="cs hljs"> cell = random(<span class="hljs-number"><span class="hljs-number">80</span></span>); <span class="hljs-comment"><span class="hljs-comment">// .  0  79 x = cell / 9 + 1; y = cell % 9 + 1; if (field[x,y]!=0) ...</span></span></code> </pre><br>  And the next, last section that we need: <br><br><img src="https://habrastorage.org/files/d9b/1fe/56e/d9b1fe56ef954b538eb6f0660f270450.png"><br><br>  The contents of the cell are compared with zero.  If so (apparently the cell is free?), Go ahead to 1E5A.  If not, we increase the cell number (which we have a continuous numbering from 0 to 80).  We compare it with 51 (81), if it is less - again we turn to 1E5A.  If more - write there zero, that is, go to the top of the board.  At this place, all the conditional branches we converge, and what are we doing?  Repeats exactly the code from the previous picture to select the contents of the playing field and once again compared with zero.  If it is not equal, then go back to the address 1E15, but this is not the very beginning, where a random number is selected, but the place where we calculate individual coordinates from it: <br><br><pre> <code class="cs hljs"> cell = random(<span class="hljs-number"><span class="hljs-number">80</span></span>); <span class="hljs-comment"><span class="hljs-comment">// .  0  79 next:x = cell / 9 + 1; y = cell % 9 + 1; if (field[x,y]!=0) { cell++; if(cell==81) cell=0; } if (field[x,y]!=0) goto next;</span></span></code> </pre><br>  Here is a get algorithm.  We select a random cell, and then, if it is occupied, simply move across the field from left to right and from top to bottom and in a circle until we find an empty cell.  That is the reason for the "dishonesty".  Of course, with this algorithm, the probability of selecting cells will be very different, and will depend on the location of the balls already on the board. <br><br>  Let us verify that this part of the code actually works in the game in the way we assume.  Let's change at the beginning 50 to 28. Now, in theory, new balls should fall out only in the upper half of the board.  We start, and nothing changes.  Balls appear all over the board. <br><br>  It turned out that the program has two almost identical subroutines, one of which throws out 5 balls of random color at the beginning of the game, and the other, 3 balls each during the game, but their colors are already known (because they must be shown in advance).  Copy / paste rules!  Well, we change this second subroutine, and make sure that it works. <br><br>  Now, in order for the algorithm to ‚Äúhonestly‚Äù put the balls on random fields, it is enough to change the most recent transition a little higher, so that it goes on the repeated selection of a random number. <br><br><div class="spoiler">  <b class="spoiler_title">For those who have never used hiew, the exact sequence of actions</b> <div class="spoiler_text">  1. Run hiew, select lines.exe <br>  2. Go to disassembler mode (Enter, Enter) <br>  3. We are looking for the beginning of the procedure (F7, type bytes B8 50 00) <br>  4. Shift down to the desired transition (1D51) <br>  5. Change the address of the transition (F3, F2, change 1CF4 to 1CE8) <br>  6. Exit editing and save changes (Esc, F9) <br>  7. We leave from hiew <br></div></div><br>  You can even check the result visually in the game.  If you simply rearrange all the balls in the upper part of the board, then gradually it will become noticeable, as new balls fill first of all the free fields from top to bottom.  This is especially noticeable when almost the entire board is full.  After this modification, this effect disappears, and the balls begin to appear really in random places. <br><br>  It remains to add that cell = random (81) should actually be, not 80. Because of this error, the balls never fall into the rightmost cell.  Unless if all the cells to the left of it are occupied, then he will get there due to this ‚Äúwrong‚Äù algorithm. <br><br>  Oh, and one more thing.  It would certainly be correct to choose a random number from 1 to the number of free cells, and put the ball right to the right place, knowing that it is free, and not to repeat the cycle until it gets to the right place.  After all, if only one last cell remains, who knows how many times it will have to be repeated?  How long will it take a 16-bit processor to perform so many cycles?  And according to the theory of probability, it may happen that he never gets there at all.  But we know that all these theories are nonsense, and sooner or later, and most likely after 80 cycles, the ball will definitely fall into this single cell. </div><p>Source: <a href="https://habr.com/ru/post/261931/">https://habr.com/ru/post/261931/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261913/index.html">Network security Instead of introducing</a></li>
<li><a href="../261921/index.html">PostgreSQL and btrfs - an elephant on an oily diet</a></li>
<li><a href="../261923/index.html">Cezurity's little antivirus test</a></li>
<li><a href="../261925/index.html">Automatic detection of vulnerabilities: description and statistics</a></li>
<li><a href="../261927/index.html">DirectX rendering in WPF window</a></li>
<li><a href="../261935/index.html">Qihoo 360 and Go</a></li>
<li><a href="../261937/index.html">Network media server for PS3</a></li>
<li><a href="../261939/index.html">New PhpStorm 9: constant advance. Postfix code completion for PHP, Inline Debugger, and more.</a></li>
<li><a href="../261941/index.html">Beginner site optimization guide. Part 2</a></li>
<li><a href="../261943/index.html">We pononet a bit: it became clearer what will happen to personal data after September 1, 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>