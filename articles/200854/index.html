<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We study netfilter: we write our match-module based on xt_string to search for several patterns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Recently I noticed that there is little information on the development of kernel modules in Habr√©. Everything I found: 


- Learning to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We study netfilter: we write our match-module based on xt_string to search for several patterns</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Recently I noticed that there is little information on the development of kernel modules in Habr√©.  Everything I found: <br><ul><li>  <a href="http://habrahabr.ru/post/138328/">Learning to write a kernel module (Netfilter) or Transparent Proxy for HTTPS</a> </li><li>  <a href="http://habrahabr.ru/post/26391/">‚ÄúLinux Kernel Hacking is Easy!‚Äù Or ‚ÄúWhere to find the documentation?‚Äù</a> </li><li>  2-3 more articles </li></ul><br><br>  It has always been surprising that people who are more or less familiar with C are afraid and even avoid reading the nuclear code, as if it consists of 60% of an assembler (which in fact is also not so complicated).  Actually, I plan to write a series of articles devoted to the development or refinement of existing netfilter and iptables modules. <br><br>  I hope they will be interesting for novice kernel developers, driver makers or just people who want to try themselves in a new area of ‚Äã‚Äãdevelopment. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  What do we do </h4><br>  As stated in the title of the article - we will write a simple iptables module based on xt_string.  Xt_string is a netfilter module that can search for a sequence of bytes in a packet.  However, he, in my opinion, lacks the ability to search for several sequences of bytes in a given order.  Well, since the GPL license, what prevents him from giving this opportunity? <br><a name="habracut"></a><br><br>  Actually, in this article we will write down such a module, we will call it xt_wildstring, which can be used <s>for thick PR</s> as follows: <br><br><pre><code class="bash hljs">iptables -I FORWARD -p tcp --dport 80 --tcp-flags ACK,PSH ACK,PSH -m wildstring --wildstring <span class="hljs-string"><span class="hljs-string">"reductor*price*carbonsoft.ru"</span></span> -j DROP.</code> </pre> <br>  I will start writing the article simultaneously with the start of development. <br>  Immediately it is worth noting that this module was not written for production, but only as a simple example that allows you to quickly arrange the process of developing and testing kernel modules, as well as get to know a little deeper with netfilter. <br><br><h4>  Briefly about the device netfilter and iptables </h4><br>  As a rule, the iptables module consists of two parts - the kernelspace and userspace.  The kernelspace contains a Linux kernel module that can be dynamically loaded and used.  This is what works with packets when we add a rule to iptables.  In userspace is already a module iptables, which allows you to create rules and transfer them to the Linux kernel. <br><br>  Netfilter modules can be divided into three categories: <br><ul><li>  Hooks are essentially default chains and tables that are substituted into the package path through the kernel. </li><li>  Matches - modules that return true or false, allow you to use conditions, for example, determine which protocol the packet belongs to </li><li>  Targets are modules that produce some kind of action on a package, the most famous are ACCEPT / DROP, although in fact there are many more </li></ul><br><h5>  Where in the source are these modules: </h5><br>  Netfilter is part of the Linux kernel source and in version 2.6.32 it is located in several directories: <br>  / usr / src / linux / net / netfilter / - most of the match modules. <br>  / usr / src / linux / net / ipv4 / netfilter / is part of the target modules. <br>  / usr / src / linux / include / linux / netfilter / - headers and those and other modules. <br><br>  Iptables modules are located in the directory <br>  / usr / src / iptables / extensions / <br><br>  The headers of the kernelspace and userspace modules must be the same, so it‚Äôs better if this is a single file. <br><br><h4>  Now let's move from theory to practice </h4><br>  We will not reinvent the wheel, not for the GPL come up with.  Take the xt_string module from the latest CentOS 6 kernel, as one of the most stable at the moment. <br><br>  There was a lot of information about setting up the module assembly system and the stand, so I hid it under the spoiler.  If there is a misunderstanding or interest in where and what is collected, started and tested - it makes sense to look under it. <br><br><div class="spoiler">  <b class="spoiler_title">Settings of the assembly system and test bench.</b> <div class="spoiler_text"><h5>  Preparing the build and debug system </h5><br>  Yes, many dream of a convenient IDE for developing Linux Kernel.  But, alas, I did not find anything worthwhile.  One of the reasons for this is relatively simple - in the case of a segfolt in the kernel, we get Kernel Panic and spend a lot of time rebooting if panic happens on our working machine.  Therefore, development is usually carried out in a virtual machine, or on a separate stand, if the code is written for a specific hardware.  However, our module is universal, so we install virtuals. <br><br><h5>  We put CentOS on two virtual machines </h5><br>  Actually so that our brain does not stand idle during Kernel Panic in case of failures, and they are guaranteed to be, we proceed as follows.  Install two virtual machines that will have access to the Internet and to each other.  One will be the collector of the module, and the second stand for verification. <br><br><h5>  On the collector we get the source code of linux and iptables </h5><br>  By the way, at the collector, we will need some good and useful programs. <br><br><pre> <code class="bash hljs">yum install git ncurses-devel make gcc rpm-build indent</code> </pre><br><br>  Now we add to our bookmarks one of the most useful repositories for a person developing under CentOS: <br><br>  <a href="http://vault.centos.org/6.4/os/Source/SPackages/">http://vault.centos.org/6.4/os/Source/SPackages/</a> <br><br>  From here we will take src.rpm of the linux kernel and iptables. <br><br><pre> <code class="bash hljs">rpm -i http://vault.centos.org/6.4/os/Source/SPackages/kernel-2.6.32-358.el6.src.rpm rpm -i http://vault.centos.org/6.4/os/Source/SPackages/iptables-1.4.7-9.el6.src.rpm</code> </pre><br><br>  Then go to / root / rpmbuild / SPECS / and deploy the source code with the imposition of patches from CentOS. <br><br><pre> <code class="bash hljs">rpmbuild -bp iptables.spec rpmbuild -bp kernel.spec</code> </pre><br><br>  In / root / rpmbuild / BUILD / we will have folders with the sources of the Linux kernel and iptables. <br><br>  Now we need to build the entire kernel at least once in order to be able to rebuild only the net / netfilter / folder when making changes to our module.  For convenience and familiarity, we will make symlinks: <br><br><pre> <code class="bash hljs">ln -s /root/rpmbuild/BUILD/kernel-2.6.32-358.el6/linux-2.6.32-358.el6.x86_64/ /usr/src/linux ln -s /root/rpmbuild/BUILD/iptables-1.4.7/ /usr/src/iptables/</code> </pre><br><br>  Go to / usr / src / linux.  First, let's generate a config. <br><br><pre> <code class="bash hljs">make menuconfig</code> </pre><br><br>  Save it and collect the whole core.  By the way, maybe on rpmbuild or make there will be a hang on gpg: keyring `./pubring.gpg 'created.  To avoid this, let's say that random with us is urandom. <br><br><pre> <code class="bash hljs">rm -f /dev/random ln -s /dev/urandom /dev/random</code> </pre><br><br>  And the actual assembly: <br><br><pre> <code class="bash hljs">make prepare make -j 3 make modules_install</code> </pre><br><br>  In general, it would be nice to have the source code of the module store everything in the GIT repository, I have it located in ~ / GIT / wildstring /. <br><br><h5>  Stand reboot with kernel panic </h5><br>  You can do it in two ways, in my opinion, the most correct one is to set the / proc / sys / kernel / panic parameter to 2. But panic output is important for us, so if necessary, you can use the script on the host system in the spirit: <br><br><pre> <code class="bash hljs">name=centos_test ip=&lt;ip_&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ! ping -qc 1 <span class="hljs-variable"><span class="hljs-variable">$ip</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> virt-viewer <span class="hljs-variable"><span class="hljs-variable">$name</span></span> sleep 2 scrot virsh destroy <span class="hljs-variable"><span class="hljs-variable">$name</span></span> virsh start <span class="hljs-variable"><span class="hljs-variable">$name</span></span> sleep 60 <span class="hljs-keyword"><span class="hljs-keyword">fi</span></span> <span class="hljs-keyword"><span class="hljs-keyword">done</span></span></code> </pre><br><br><h5>  Check module operation </h5><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash test_wildstring() { iptables -F OUTPUT rmmod xt_wildstring insmod xt_wildstring iptables -I OUTPUT -p tcp ‚Äìdport 80 -m wildstring ‚Äúopensource*carbonsoft‚Äù -j DROP wget -t 1 -T 1 http://carbonsoft.ru/opensource/ Iptables -nvL OUTPUT } test_wildstring if [ ‚Äú$1‚Äù = 'while' ]; then while true; do test_wildstring sleep 1 done fi</span></span></code> </pre><br><br>  Which can be used like this: <br><br>  One-time start: <br><pre> <code class="bash hljs">./test_wildstring.sh</code> </pre><br><br>  Endless cycle: <br><pre> <code class="bash hljs">./test_wildstring.sh <span class="hljs-keyword"><span class="hljs-keyword">while</span></span></code> </pre><br></div></div><br><br><h5>  Copy string from linux and iptables </h5><br>  We find the modules we need and copy them into our repository. <br><br><pre> <code class="bash hljs">cp -v /usr/src/linux/net/netfilter/xt_string.c ~/GIT/wildstring/xt_wildstring.c mkdir -p ~/GIT/wildstring/include/linux/netfilter/ cp -v /usr/src/linux/include/linux/netfilter/xt_string.h ~/GIT/wildstring/include/linux/netfilter/xt_wildstring.h</code> </pre><br><br><h5>  Writing Makefile </h5><br>  We describe the assembly of the kernel module, the iptables module, as well as code alignment, cleanup of the working folder, and a couple more goals. <br><br><pre> <code class="cmake hljs">obj-m += xt_wildstring.o all: module lib module: cp <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/linux/netfilter/xt_wildstring.h /usr/src/linux/<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/linux/netfilter/xt_wildstring.h make -C /lib/modules/<span class="hljs-number"><span class="hljs-number">2.6</span></span>.<span class="hljs-number"><span class="hljs-number">32</span></span>/build M=$(PWD) modules lib: cp libxt_wildstring.c /usr/src//iptables/extensions cp <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/linux/netfilter/xt_wildstring.h /usr/src/iptables/<span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/linux/netfilter/xt_wildstring.h make -C /usr/src/iptables/extensions cp /usr/src/iptables/extensions/libxt_wildstring.so libxt_wildstring.so userspace: gcc userspace_wildstring.c -o userspace ./userspace rm -f userspace <span class="hljs-keyword"><span class="hljs-keyword">install</span></span>: scp xt_wildstring.ko root@<span class="hljs-number"><span class="hljs-number">10.90</span></span>.<span class="hljs-number"><span class="hljs-number">140.160</span></span>: scp libxt_wildstring.so root@<span class="hljs-number"><span class="hljs-number">10.90</span></span>.<span class="hljs-number"><span class="hljs-number">140.160</span></span>:/lib64/xtables-<span class="hljs-number"><span class="hljs-number">1.4</span></span>.<span class="hljs-number"><span class="hljs-number">7</span></span>/ clean: rm -f *~ *.ko *.so *.mod.c *.ko.unsigned *.o modules.order Module.symvers indent: Lindent *.c <span class="hljs-keyword"><span class="hljs-keyword">include</span></span>/linux/netfilter/xt_wildstring.h</code> </pre><br><br>  Comments on the Makefile: <br><ul><li>  2.6.32 - zahardkodili, since uname -r = 2.6.32-358.0.1.el6.x86_64, but I do not have these sources at hand, respectively, and the symlink / lib / modules/2.6.32-358.0.1. el6.x86_64 / build will not work. </li><li>  Since I am not a makefile guru, and did not come up with a beautiful and correct way to compile libxt_wildstring.so like xt_wildstring.ko, I decided not to bother and write this goal with simple bash commands. </li><li>  In order for the scp in the install target to work without a password, you need to generate SSH keys on the build system and drop them to the test bench. </li><li>  The Lindent command is copied from / usr / src / linux / scripts / Lindent to / usr / local / bin, as it is often used.  I recommend to use it always when writing code in the Linux kernel, since with its charter we don‚Äôt go to another monastery.  Better even before each commit. </li></ul><br><br><h5>  We remove the extra in .gitignore </h5><br>  Untracked files in git status are a bit tense, so let's create ~ / GIT / wildstring / .gitignore: <br><br>  * .o <br>  * .so <br>  . * <br>  * .ko <br>  * .ko.unsigned <br>  modules.order <br>  Module.symvers <br>  * .mod.c <br>  ! .gitignore <br><br><h5>  Rename to wildstring </h5><br>  So that the module does not conflict with the original, it makes sense to rename it and all its functions from string to wildstring.  An important point - you need to edit everything: the header, and the userspace module, and the kernelspace module.  In this case, grep will save the father of Russian democracy: <br><br><pre> <code class="bash hljs">grep -ri string xt_wildstring.c | grep -vi wildstring</code> </pre><br><br><h5>  Extending the match info structure </h5><br>  And again a bit of theory: each match-module has its own match-info structure, which is formed on the basis of the parameters passed from userspace.  It is described in the header file ( <a href="">xt_wildstring.h</a> ). <br><br><div class="spoiler">  <b class="spoiler_title">The standard xt_string.h looks like this.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _XT_STRING_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _XT_STRING_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/types.h&gt; #define XT_STRING_MAX_PATTERN_SIZE 128 #define XT_STRING_MAX_ALGO_NAME_SIZE 16 enum { XT_STRING_FLAG_INVERT = 0x01, XT_STRING_FLAG_IGNORECASE = 0x02 }; struct xt_string_info { __u16 from_offset; //      ‚Äì   . __u16 to_offset; //      ‚Äì    . char algo[XT_STRING_MAX_ALGO_NAME_SIZE]; // . char pattern[XT_STRING_MAX_PATTERN_SIZE]; //,   , . __u8 patlen; // ,  . union { struct { __u8 invert; //   ! -m string ‚Äìstring ‚Äúsomething‚Äù } v0; struct { __u8 flags; //    . } v1; } u; /* Used internally by the kernel *   . *     ,     *   java-? *    ,     xml. */ struct ts_config __attribute__((aligned(8))) *config; }; #endif /*_XT_STRING_H*/</span></span></span></span></code> </pre><br><br></div></div><br><br>  Multiply several fields of the xt_wildstring_info structure into xt_wildstring.h <br><br>  To begin, add pointers to the substrings.  It is pointers, not arrays of characters, as in the original, since the second and third pointers can be empty, that is, a template without asterisks will be passed to the module.  By analogy, we add variables for them to store the length of substrings + according to the structure of the text search parameters in the package for each template.  As a result, the structure began to look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> _XT_WILDSTRING_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _XT_WILDSTRING_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;linux/types.h&gt; #define XT_WILDSTRING_MAX_PATTERN_SIZE 128 #define XT_WILDSTRING_MAX_ALGO_NAME_SIZE 16 enum { XT_WILDSTRING_FLAG_INVERT = 0x01, XT_WILDSTRING_FLAG_IGNORECASE = 0x02 }; struct xt_wildstring_info { __u16 from_offset; __u16 to_offset; char algo[XT_WILDSTRING_MAX_ALGO_NAME_SIZE]; char pattern[XT_WILDSTRING_MAX_PATTERN_SIZE]; /*    */ char *pattern_part1; char *pattern_part2; char *pattern_part3; __u8 patlen; /*   */ __u8 patlen_part1; __u8 patlen_part2; __u8 patlen_part3; union { struct { __u8 invert; } v0; struct { __u8 flags; } v1; } u; /* Used internally by the kernel */ /*        */ struct ts_config __attribute__((aligned(8))) *config; struct ts_config __attribute__((aligned(8))) *config_part1; struct ts_config __attribute__((aligned(8))) *config_part2; struct ts_config __attribute__((aligned(8))) *config_part3; }; #endif</span></span></span></span></code> </pre><br><br><h5>  Start using new header fields </h5><br>  Go to <a href="">xt_wildstring.c</a> . <br><br>  Now what we added to the header is time to use.  To begin with, we will bring up the preparation and destruction of search configs. <br><br>  Here again a bit of theory - as a rule, the structure of a match-module contains the following functions and structures: <br><br><ul><li>  init - initialization of the module when it is loaded; </li><li>  exit - destruction of the module when it is loaded; </li><li>  mt is a packet checking function; </li><li>  mt_check is a function that checks the correctness of a module call when a rule is added; </li><li>  mt_destroy is a function that cleans up resources when a rule is deleted; </li><li>  mt_reg - structure of pointers to mt_check, mt and mt_destroy + additional information about the module; </li></ul><br><br>  In the original xt_string, the rule is added and deleted as follows: <br><br>  In string_mt_check (appendix), the ts_config structure is generated based on the string and the search algorithm, (ts - text search).  The package search function (skb_find_text) uses it as a parameter.  The memory cleared by this structure (the string_mt_destroy function) is cleared by the textsearch_destroy function, called when the rule is removed from the chain. <br><br><h5>  Add a pair of textsearch_prepare to xt_wildstring_check </h5><br>  Before changing something, we will comment out the original wildstring_mt function, which actually checks the package as it passes through the rule, because the changes should be made little by little, but this function depends very much on them, but so far we don‚Äôt matter. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wildstring_mt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct sk_buff *skb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct xt_match_param *par)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> 0 ... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> }</span></span></code> </pre><br><br>  First, let's prepare our ts_conf in the xt_wildstring_check function, which is called when the rule is added to iptables.  Copy the pointer to the beginning of the line into a temporary variable, and we will go through it with the function strsep, which splits the line according to a given set of characters.  If the token is found, we calculate its length and use it to prepare text search parameters. <br><br><pre> <code class="cpp hljs">s = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *) conf-&gt;pattern; conf-&gt;pattern_part1 = strsep(&amp;s, delim); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!conf-&gt;pattern_part1) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       conf-&gt;patlen_part1 = strlen(conf-&gt;pattern_part1); ts_conf = textsearch_prepare(conf-&gt;algo, conf-&gt;pattern_part1, conf-&gt;patlen_part1, GFP_KERNEL, flags); if (IS_ERR(ts_conf)) return false; conf-&gt;config_part1 = ts_conf;</span></span></code> </pre><br><br>  The next two ts_confs are filled in by analogy, with the only difference that if the pattern pointer is empty, then this is no longer an error, and we return true, that is, we work with a smaller number of patterns. <br><br><h5>  And destroy them in wildstring_mt_destroy </h5><br>  This function is called when the rule is deleted from iptables.  To destroy the parameters when deleting a rule, we duplicate the destroy. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wildstring_mt_destroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct xt_mtdtor_param *par)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">xt_wildstring_info</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">conf</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WILDSTRING_TEXT_PRIV</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">par</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">matchinfo</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conf-&gt;pattern_part1) textsearch_destroy(conf-&gt;config_part1); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conf-&gt;pattern_part2) textsearch_destroy(conf-&gt;config_part2); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conf-&gt;pattern_part3) textsearch_destroy(conf-&gt;config_part3); }</code> </pre><br><br><h5>  Bring to mind match </h5><br>  And now the module began to successfully load-unload, and the rules are added-deleted, and no Kernel Panic.  Now let's go back to the previously commented wildstring_mt function and add to it a search for all templates passed to the function. <br>  First, we need a variable to save the length of the shift, in which we managed to find the necessary substring. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> skb_find = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><br><br>  Generally not the most successful name, it would be much clearer to have something in the spirit of tmp_from_offset or wildstring_from_offset, but everything is already there in the githaba commits, so, alas, late.  Now, instead of returning the result of the first search, we assign it to our new variable, analyze it and if nothing is found, we return false, and so on until we go through all the specified patterns. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;state, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(struct ts_state)); skb_find = skb_find_text((struct sk_buff *)skb, conf-&gt;from_offset, conf-&gt;to_offset, conf-&gt;config_part1, &amp;state); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skb_find == UINT_MAX) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>;</code> </pre><br><br>  And so we repeat for config_part2 and config_part3, with the difference that the presence of pattern_part2 and pattern_part3 should be checked and in case of absence - return true. <br><br><h5>  We achieve and check </h5><br>  Then we treat all compilation errors.  In general, it is better to compile as often as possible, and with each logical completion, check the operation of the module in an infinite loop until the next part is added or we do not notice what happened to the kernel panic.  It‚Äôs worth doing this because the cost of the error is much higher and it takes much longer between writing code and checking its full functionality than when writing most userspace utilities.  That is why at the very beginning of the article so much attention is paid to the convenience of the assembly and debugging system on the stand, because, as everyone knows, no matter how good the thing is inside, if it is inconvenient to use, it will not be used. <br><br>  We test on a couple of test cases using wget or curl.  When creating a rule, it is important to remember that in the HTTP package GET is before HOST, and the template will have to be written a little backwards: <br><ul><li>  "Something * html * example.com" </li><li>  "Pron * avi * yoursite" </li><li>  "Reductor * scheme * carbonsoft.ru" </li></ul><br><br>  That is, add the rule: <br><br><pre> <code class="bash hljs">iptables -I OUTPUT -p tcp ‚Äìdport 80 -m wildstring ‚Äúreductor*scheme*carbonsoft‚Äù -j DROP</code> </pre><br><br>  and try to download the page: <br><br>  wget -t 1 -t 1 <a href="http://www.carbonsoft.ru/products/reductor/carbon-reductor/">http://www.carbonsoft.ru/products/reductor/carbon-reductor/#scheme</a> <br><br>  Bingo - we broke off and iptables -nvL OUTPUT shows an increased packet count. <br><br><h4>  Why not lists? </h4><br>  An attentive and experienced <a href="http://bash.im/quote/403306">reader may exclaim, yes, there he will bite</a> - they say why such perversions and crutches, when you can use lists and add / remove a structure consisting of pattern, patlen and config into it, and then go through this list for_each_entry.  But - the purpose of the article is to show the device of the netfilter module, and working with lists in the linux kernel would add to the module one more additional entity that should be understood.  Well, and besides, one must leave something to the reader for independent exercises. <br><br><h4>  Completion </h4><br>  Actually, we learned how to make kernel modules for netfilter, isn't that great? <br>  In general, the module can be used not only for HTTP, but also for many other protocols, examples, perhaps, I will add later in the comments. <br><br>  Sources can be taken in <a href="http://habrahabr.ru/">the opensource section on our website</a> . </div><p>Source: <a href="https://habr.com/ru/post/200854/">https://habr.com/ru/post/200854/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../200842/index.html">Five traits of successful innovators</a></li>
<li><a href="../200844/index.html">Google Helpouts - paid video consultation with experts</a></li>
<li><a href="../200846/index.html">The long Gantt road in TeamLab Office. The story from the first persons</a></li>
<li><a href="../200850/index.html">ShotSpotter: Acoustic Surveillance System in Washington, DC localized 39,000 shots since 2006</a></li>
<li><a href="../200852/index.html">Remote debugging of web applications in the cloud with Visual Studio 2013</a></li>
<li><a href="../200856/index.html">India launched a satellite into Mars orbit</a></li>
<li><a href="../200858/index.html">How the NSA implemented a bookmark in a pseudo-random number generator</a></li>
<li><a href="../200866/index.html">Advanced chat on Node.JS</a></li>
<li><a href="../200868/index.html">SRVCC technology in 4th generation mobile networks</a></li>
<li><a href="../200870/index.html">RabbitMQ tutorial 3 - Publish / Subscribe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>