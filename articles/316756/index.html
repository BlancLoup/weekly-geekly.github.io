<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating and testing a firewall in Linux, Part 2.2. Firewall tables. Access to TCP / IP structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content of the first part: 

 Creating a lab, architecture Netfilter, char device, sysfs  1.1 - Creating a virtual lab (so that we have where to work,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating and testing a firewall in Linux, Part 2.2. Firewall tables. Access to TCP / IP structures</h1><div class="post__text post__text-html js-mediator-article">  <b>Content of the first part:</b> <br><br><div class="spoiler">  <b class="spoiler_title">Creating a lab, architecture Netfilter, char device, sysfs</b> <div class="spoiler_text">  <a href="https://habrahabr.ru/post/315340/"><b>1.1</b> - Creating a virtual lab (so that we have where to work, I'll show you how to create a virtual network on your computer. The network will consist of 3 Linux ubuntu machines).</a> <br>  <a href="https://habrahabr.ru/post/315350/"><b>1.2</b> - Writing a simple module in Linux.</a>  <a href="https://habrahabr.ru/post/315350/">Introducing Netfilter and intercepting traffic with it.</a>  <a href="https://habrahabr.ru/post/315350/">We combine everything together, we test.</a> <br>  <a href="https://habrahabr.ru/post/315454/"><b>1.3</b> - Writing a simple char device.</a>  <a href="https://habrahabr.ru/post/315454/">Adding a virtual file system - sysfs.</a>  <a href="https://habrahabr.ru/post/315454/">Writing user interface.</a>  <a href="https://habrahabr.ru/post/315454/">We combine everything together, we test.</a> <br></div></div><br>  <b>The content of the second part:</b> <br><br>  <a href="https://habrahabr.ru/post/316086/"><b>2.1</b> - Introduction to the second part.</a>  <a href="https://habrahabr.ru/post/316086/">We look at the network and protocols.</a>  <a href="https://habrahabr.ru/post/316086/">Wireshark.</a> <br>  <b><b>2.2</b> - Firewall Tables.</b>  <b>Transport Layer.</b>  <b>TCP structures, UDP.</b>  <b>Extend the firewall.</b> <br>  <b>2.3</b> - Expanding functionality.  We process data in user space.  libnetfilter_queue. <br>  <b>2.4</b> - Bonus.  We study the real Buffer Overflow attack and prevent it with the help of our Firewall. <br><a name="habracut"></a><br><h3>  Firewall rules.  Theory. </h3><br>  In this part, we will almost finish learning a base sufficient to implement a simple firewall, but before we do this (it is assumed that the reader has knowledge in networks or read part 2.1), it is necessary to consider how the firewall makes decisions. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/c86/bc9/0ce/c86bc90ce1b84f5fb53ac62cd1bd18f2.png"><br><br><img src="https://habrastorage.org/files/173/94c/7c8/17394c7c85614a20b18f53326769b90a.png"><br><br>  Such a table of rules is loaded by the user (administrator) into the firewall memory.  It is they who determine when receiving packages what to do with them - accept or reject. <br><br>  <i>Important!</i>  When a firewall receives a packet, it necessarily looks at its fields (what we did in lesson 2.1) and compares them with the rules from the table in the order (!), How these rules are written in it (from top to bottom!).  In other words, there is a fundamental difference, which rule will be in the table above, and which one is lower. <br><br>  <i>Important!</i>  Any strange package should not get into the network or device protected by us.  In addition, if we do not know whether it can be skipped or not, the answer is NO.  We only allow packets that are allowed in the firewall rules. <br><br>  Hence the principle of building and operating a firewall: only those packets that we allowed can get into the internal network (we have this host1). <br><br>  Now for example.  The table above defines five rules.  Upon receipt of each packet, we must make sure that only if we have found a suitable rule for it, and it is spelled out in <i>Action</i> - <i>accept</i> , only then we skip it.  If we did not find a suitable rule after checking each of them, then we throw out the package, regardless of its content.  To do this, there is the last default rule, which determines - to throw out any package that does not fall under any of the rules.  It must be at the very end (in fact, all the firewall add it automatically, even if it is not spelled out). <br><br>  Now more about the <i>direction</i> and <i>ack</i> fields. <br><br>  <i>Direction</i> - determines if the packet is in our network or out.  For example, we may want to prohibit all smtp (mail) protocol packets in order to avoid information leakage via e-mail.  Or vice versa - we will want to prohibit any incoming packet via telnet protocol to prohibit any attempt to connect to our network.  We will consider in the practical part how in our case to determine the direction of the packet in the code. <br><br>  The first two rules are called <i>spoof</i> , and they perform trivial defense against trivial attack attempts.  So, <i>spoof1</i> means ‚Äúany incoming packet ( <i>direction = in</i> ) with the address of our network (10.0.1.1 = host1) for any port numbers, protocols, etc.  - throw out.  The logic of this rule is that the packet cannot come to our network on the firewall, and at the same time it indicates that it was sent from our own network ( <i>src ip = 10.0.1.1</i> ).  In other words, this means that someone has faked it and is trying to disguise itself as one of the users (in this case, host1) - we don‚Äôt want to miss this package. <br><br>  Symmetric rule and <i>spoof2</i> - we do not want to release packets from the internal network if it says that it is originally from an IP that is different from the internal addresses (that is, <i>NOT</i> 10.0.1.1).  Most likely, this is also some kind of virus. <br><br>  <i>ACK</i> is a flag (one bit) that is used to establish a connection when using the TCP protocol and further maintaining its ‚Äúreliability‚Äù.  Each TCP connection starts with a triple handshake (3 way handshake, there is no article in Russian, but there is an animation in English here: <a href="https://en.wikipedia.org/wiki/Handshaking">https://en.wikipedia.org/wiki/Handshaking#TCP_three-way_handshake</a> <br><br>  It is important for us to understand that with each new opening of a TCP session, only in the first packet ACK = 0, in all other packets of the created session - ACK&gt; 0 ( <a href="https://ru.wikipedia.org/wiki/TCP">https://ru.wikipedia.org/wiki/TCP</a> ). <br><br>  Thanks to this fact, we can distinguish an already existing compound from an attempt to open it.  If ACK = 0, then this is an attempt to create a TCP connection (the first packet in the triple handshake), if ACK = 1, then the connection should have been created before (and if this is not the case, then it is logical not to allow such packets to go to the network). <br><br>  Now look at the <i>http_in</i> , <i>http_out rule</i> : <br><br><img src="https://habrastorage.org/files/e24/7ff/8aa/e247ff8aa6d143c98e8aa4996b5fbe40.png"><br><br>  <i>http_in</i> means the following: if the packet is incoming ( <i>direction</i> = <i>in</i> ), from any IP ( <i>Src IP = any</i> , note that the spoof rules are higher, at this stage, guarantee us that this is not the IP of the internal network) intended for our network ( <i>Dest IP == host1 == 10.0.1.1</i> ), sent via TCP, to port 80 (that is, the server known to all http), from any port (&gt; 1023 means any non-reserved port that we receive from the operating system when creating a connection and in the future it is used to identify this particular compound, as described in part 2.1), <i>Ack = Any,</i> this means that we  we decide to ask the computer from the outside to open the connection (in the first packet, ack = 0, and the following ack&gt; 0).  And we accept such packets and skip further to the network ( <i>action = accept</i> ). <br><br>  <i>http_out is</i> symmetrical, with the difference that we will not miss packets with ack = 0, only ack&gt; 0, that is, we will not allow to create an http connection from our computer on the internet, but at the same time we will be able to respond to the connection already created in the http . <br><br>  In other words, the http rules allow access to our network via http from the outside, but prohibit users of our network from using http (that is, access to internet sites). <br><br><h3>  Firewall rules.  Practice. </h3><br>  Returning to our module, I remind you that the interception function looks like this: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_func_forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hooknum, struct sk_buff *skb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct net_device *in, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct net_device *out, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*okfn)(struct sk_buff *))</span></span></span></span>;</code> </pre> <br>  Let's look at the parameters: <br><br>  <i>hooknum</i> - interception number, we have already passed it <br>  <i>const struct net_device * in, out</i> - pointers to network interface structures <br>  <i>struct sk_buff * skb</i> is the most interesting for us - a pointer containing the data we need <br>  <i>SKB - socket buffer</i> , this is the basic structure of a linux network.  It has many fields and can be a separate subject for writing an article.  I found a couple of good links for those who want to go deep: <br><br>  <a href="http://vger.kernel.org/~davem/skb.html">http://vger.kernel.org/~davem/skb.html</a> <br>  <a href="https://people.cs.clemson.edu/~westall/853/notes/skbuff.pdf">https://people.cs.clemson.edu/~westall/853/notes/skbuff.pdf</a> <br><br>  We are interested: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tcphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">th</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uh</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">icmphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">icmph</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">igmphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">igmph</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ipiph</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ipv6hdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ipv6h</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *raw; } h; <span class="hljs-comment"><span class="hljs-comment">// Transport header union { struct iphdr *iph; struct ipv6hdr *ipv6h; struct arphdr *arph; unsigned char *raw; } nh; // Network header</span></span></code> </pre> <br>  In the following way <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ip_header</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iphdr</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb_network_header</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb</span></span></span><span class="hljs-class">);</span></span></code> </pre> <br>  we get a pointer to an <i>IP header</i> (in part 2.1 we said that the main information at this level for us is <i>IP source</i> , <i>IP destination</i> ). <br><br>  Definition of <i>skb_network_header</i> from inclue / linux / skbuff.h <br><br><img src="https://habrastorage.org/files/5c6/648/90a/5c664890a7784c6a8a400b51c3bf0b05.png"><br><br>  <a href="">http://lxr.free-electrons.com/source/include/linux/skbuff.h?v=3.0#L1282</a> <br><br>  That is, we see that the function returns the necessary pointer from the ‚Äúnecessary‚Äù place in the <i>struct skbuff</i> structure. <br><br>  And now, when we have access to the <i>IP header</i> , we can get IP addresses: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> src_ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ip_header-&gt;saddr; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dest_ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ip_header-&gt;daddr;</code> </pre> <br>  As well as the protocol number: <br><br>  ip_header-&gt; protocol <br><br><h3>  Access to Transport Layer (TCP / UDP ..) </h3><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udp_header</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udphdr</span></span></span><span class="hljs-class"> *)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb_transport_header</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb</span></span></span><span class="hljs-class">)+20);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tcphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tcp_header</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tcphdr</span></span></span><span class="hljs-class"> *)(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb_transport_header</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb</span></span></span><span class="hljs-class">)+20);</span></span></code> </pre> <br>  For TCP (and similarly for UDP) port numbers: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> src_port = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ntohs(tcp_header-&gt;source); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dest_port = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ntohs(tcp_header-&gt;dest);</code> </pre> <br>  Below, I will provide the complete function code.  An interesting point is the use of the function <i>ntohs</i> .  <i>ntohs</i> is a function that changes the order of bits (the representation of a number).  There are two types of memory representation used ‚Äî <i>little endian</i> and <i>big endian</i> .  The <i>big endian</i> system is used to represent numbers on the network, while the <i>little endian</i> architecture <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">(byte order)</a> <br>  Therefore, to obtain the correct numbers, you must use these translating functions. <br>  Below is the text of the entire function, which, when receiving a packet, prints all the necessary data for deciding on the firewall rules: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hook_func_forward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> hooknum, struct sk_buff *skb, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct net_device *in, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct net_device *out, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*okfn)(struct sk_buff *))</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ip_header</span></span></span><span class="hljs-class"> = (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">iphdr</span></span></span><span class="hljs-class"> *)</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb_network_header</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">udp_header</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tcphdr</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tcp_header</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NULL</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> src_ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ip_header-&gt;saddr; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dest_ip = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ip_header-&gt;daddr; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> src_port = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> dest_port = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> src_ip_str[<span class="hljs-number"><span class="hljs-number">16</span></span>], dest_ip_str[<span class="hljs-number"><span class="hljs-number">16</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ip_header-&gt;protocol == PROT_UDP) { udp_header = (struct udphdr *)(skb_transport_header(skb)+<span class="hljs-number"><span class="hljs-number">20</span></span>); src_port = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ntohs(udp_header-&gt;source); dest_port = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ntohs(udp_header-&gt;dest); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ip_header-&gt;protocol == PROT_TCP) { tcp_header = (struct tcphdr *)(skb_transport_header(skb)+<span class="hljs-number"><span class="hljs-number">20</span></span>); src_port = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ntohs(tcp_header-&gt;source); dest_port = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)ntohs(tcp_header-&gt;dest); <span class="hljs-comment"><span class="hljs-comment">// XMAS packet // FIN, URG, PSH set // if(ip_header-&gt;protocol == PROT_TCP){ // printk("TCP ack = %s\n", tcp_header-&gt;ack == 1 ? "yes" : "no"); // if (tcp_header-&gt;fin &gt; 0 &amp;&amp; tcp_header-&gt;urg &gt; 0 &amp;&amp; tcp_header-&gt;psh &gt; 0 ){ // info("XMAS packet detected, drop"); // } } ip_hl_to_str(ntohl(src_ip), src_ip_str); ip_hl_to_str(ntohl(dest_ip), dest_ip_str); printk("---------------------------\n"); printk("in device = [%s], out_device = [%s]\n", in-&gt;name, out-&gt;name); printk("ip_src = [%s], ip_dest = [%s]\n", src_ip_str, dest_ip_str); printk("src port: [%u], dest port: %u, \n", src_port, dest_port); printk("protocol = %d\n", ip_header-&gt;protocol); if(dest_port == HTTP_PORT || src_port == HTTP_PORT){ printk("HTTP packet\n"); } return NF_ACCEPT; }</span></span></code> </pre> <br><h3>  Compile </h3><br>  Most (if not all) examples of writing modules or using <i>netfilter</i> are limited to one source file and a couple dozen lines of code.  But large projects cannot (and incorrectly) fit in one source file;  and although the example I describe can be crammed into one file, I decided to divide it into module_fw.c ‚Äî all that concerns char device, sysfs, kernel module, and hook_functions.c ‚Äî interception functionality.  When compiling a kernel module consisting of several files, there is a small trick to be aware of, below is an example: <br><br><img src="https://habrastorage.org/files/fb9/367/957/fb9367957d3940518e5db94e7e99e8b4.png"><br><br>  Here you should pay attention to the line: <br><br>  <i>obj-m: = fw.o</i> <br>  There is no such file fw.c, so this is the name of the module that will be created.  Also, this is a prefix for the next line, which describes all the files related to the module. <br>  <i>fw-objs + =</i> <br>  You need to know that, of course, the name of the module and the source code should not be the same.  Otherwise, everything remains the same. <br><br><h3>  Check </h3><br>  For verification, I quickly configured the <i>dhcp</i> interfaces (see part 1) and put it on host1, <i>http server ‚Äî apache2</i> , and on host2 ‚Äî <i>lynx</i> ‚Äî a text browser (although telnet could have been done).  Run <br><br>  lynx 10.0.1.1 <br><br><img src="https://habrastorage.org/files/5a8/167/97a/5a816797a5294ec6b2057dd3d72216e7.png"><br><br>  We look that gives our firewall: <br><br><img src="https://habrastorage.org/files/42d/5ba/1ad/42d5ba1ad8904664b7f72ab9b560da54.png"><br><br>  Well, that's all. <br><br><h3>  Conclusion </h3><br>  In this part, we looked at how the table of rules in the firewall, which determine the policy of protecting and passing traffic to the network.  After that, we disassembled one of the basic network structures of <i>skbuf</i> in Linux and, thanks to this, were able to supplement our program with all the necessary information to supplement the support for the tables in our module.  What is left is to write the load of this table via sysfs, as we did in part 1, and add <i>if {} else if {} else {}</i> ... to the <i>hook_func_forward</i> function.  I‚Äôll leave it to those who want it, as there‚Äôs nothing fundamentally new here ... well, it can only work with the <i>klist</i> , but this is a completely different topic, which is also well covered on the Internet. <br><br>  In the function itself, you can find a bonus, designated as XMAS packet, and read what it is and why on the Internet, and we will begin the next part of this (is this ‚Äúhere‚Äù?) - <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(dest_port == HTTP_PORT || src_port == HTTP_PORT){ printk(<span class="hljs-string"><span class="hljs-string">"HTTP packet\n"</span></span>); }</code> </pre> <br>  <b>References:</b> <br>  <a href="https://en.wikipedia.org/wiki/Handshaking">wikipedia.org/wiki/Handshaking#TCP_three-way_handshake</a> <br>  <a href="https://ru.wikipedia.org/wiki/TCP">ru.wikipedia.org/wiki/TCP</a> <br>  <a href="http://vger.kernel.org/~davem/skb.html">vger.kernel.org/~davem/skb.html</a> <br>  <a href="https://people.cs.clemson.edu/~westall/853/notes/skbuff.pdf">people.cs.clemson.edu/~westall/853/notes/skbuff.pdf</a> <br>  <a href="">lxr.free-electrons.com/source/include/linux/skbuff.h?v=3.0#L1282</a> <br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D1%2580%25D1%258F%25D0%25B4%25D0%25BE%25D0%25BA_%25D0%25B1%25D0%25B0%25D0%25B9%25D1%2582%25D0%25BE%25D0%25B2">Byte order</a> </div><p>Source: <a href="https://habr.com/ru/post/316756/">https://habr.com/ru/post/316756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../316746/index.html">Dual-pane using fragments</a></li>
<li><a href="../316748/index.html">Functional languages ‚Äã‚Äãin hardware design</a></li>
<li><a href="../316750/index.html">Security Week 48: Tech Support Locker, Mirai Mutations, Vulnerability in Firefox and Tor Browser</a></li>
<li><a href="../316752/index.html">The story of a single plugin</a></li>
<li><a href="../316754/index.html">Death transit traffic?</a></li>
<li><a href="../316758/index.html">Linux kernel documentation goes to Python Sphinx</a></li>
<li><a href="../316760/index.html">Enhance your video surveillance system using OpenCV and Telegram bot</a></li>
<li><a href="../316762/index.html">MemC3 - compact Memcache with increased parallelism - due to more stupid caching and smarter hashing</a></li>
<li><a href="../316766/index.html">How Ionic 2 helps me to understand angular 2</a></li>
<li><a href="../316768/index.html">Ludum Dare translation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>