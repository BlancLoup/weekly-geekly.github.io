<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Specification Design Pattern in C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A ‚Äúspecification‚Äù in programming is a design pattern by which the representation of business logic rules can be transformed into a chain of objects co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Specification Design Pattern in C #</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  A ‚Äúspecification‚Äù in programming is a design pattern by which the representation of business logic rules can be transformed into a chain of objects connected by boolean logic operations. </blockquote><br>  I became acquainted with this term in the process of reading <a href="https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">DDD Evans</a> .  On Habr√© there are articles <a href="https://habrahabr.ru/post/171559/">describing the practical application of the pattern</a> and <a href="https://habrahabr.ru/post/260771/">problems encountered in the implementation process</a> . <br><br>  In short, the main advantage of using the ‚Äúspecifications‚Äù is to have one clear place, in which all the filtering rules of the objects of the subject model are concentrated, instead of thousands of spreads on an even layer by the application of lambda expressions. <br><br>  The classic implementation of the design pattern looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ISpecification</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> candidate</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br><h4>  What is wrong with it for C #? </h4><br><ol><li>  There are <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> and <code>Func&lt;T, bool&gt;&gt;</code> , the signature of which coincides with IsSatisfiedBy </li><li>  There are extension methods.  <a href="https://habrahabr.ru/users/alexanderzaytsev/" class="user_link">alexanderzaytsev</a> using them does this: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserQueryExtensions</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> IQueryable&lt;User&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WhereGroupNameIs</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> IQueryable&lt;User&gt; users, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> users.Where(u =&gt; u.GroupName == name); } }</code> </pre><br></li><li>  And you can also implement <a href="https://nblumhardt.com/archives/implementing-the-specification-pattern-via-linq/">this addin over LINQ</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T item</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SatisfyingElementsFrom(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { item }.AsQueryable()).Any(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> IQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SatisfyingElementsFrom</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;T&gt; candidates</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre></li></ol><br><h4>  In the end, the question arises: is it worth using a C # template from the world of Java a decade ago and how to implement it? </h4><a name="habracut"></a><br>  We decided that it was worth it this way: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueryableSpecification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>: <span class="hljs-title"><span class="hljs-title">class</span></span> { <span class="hljs-function"><span class="hljs-function">IQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;T&gt; query</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueryableOrderBy</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">IOrderedQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;T&gt; queryable</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> Satisfy&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj, Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; spec) =&gt; spec(obj); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> SatisfyExpresion&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> T obj, Expression&lt;Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; spec) =&gt; spec.AsFunc()(obj); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsSatisfiedBy&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; spec, T obj) =&gt; spec(obj); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsSatisfiedBy&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Expression&lt;Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; spec, T obj) =&gt; spec.AsFunc()(obj); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IQueryable&lt;T&gt; Where&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;T&gt; source, IQueryableSpecification&lt;T&gt; spec) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> =&gt; spec.Apply(source);</code> </pre><br><h4>  Why not <code>Func&lt;T, bool&gt;</code> ? </h4><br>  From <code>Func</code> very difficult to go to <code>Expression</code> .  Often you need to transfer the filtering to the level of building a query to the database, otherwise you will have to pull out millions of records and filter them in memory, which is not optimal. <br><br><h4>  Why not <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> ? </h4><br>  The transition from <code>Expression</code> to <code>Func</code> , on the contrary, is trivial: <code>var func = expression.Compile()</code> .  However, the layout of the Expression is <a href="https://habrahabr.ru/post/313394/">not a trivial task</a> .  It is no longer pleasant if a conditional assembly of the expression is required (for example, if the specification contains three parameters, two of which are optional).  And really bad <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> does it in cases requiring subqueries like <code>query.Where(x =&gt; someOtherQuery.Contains(x.Id))</code> . <br><br>  Ultimately, this reasoning suggested that the easiest way is to modify the target <code>IQueryable</code> and transmit further through the fluent interface.  Additional Where methods allow code to appear as if it were a normal LINQ transformation chain. <br><br><h4>  Guided by this logic, you can select an abstraction to sort </h4><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IOrderedQueryable&lt;T&gt; OrderBy&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> IQueryable&lt;T&gt; source, IQueryableOrderBy&lt;T&gt; spec) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> =&gt; spec.Apply(source); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IQueryableOrderBy</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; { <span class="hljs-function"><span class="hljs-function">IOrderedQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;T&gt; queryable</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br>  Then, by adding <a href="https://weblogs.asp.net/scottgu/dynamic-linq-part-1-using-the-linq-dynamic-query-library">Dynamic Linq</a> and a bit of <s>special street magic</s> <code>Reflection</code> , you can write a basic object to filter anything in a declarative style.  The code below analyzes the public properties of an <code>AutoSpec</code> and the type to which you want to apply filtering.  If a match is found and the <code>AutoSpec</code> inheritor <code>AutoSpec</code> filled in, a filtering rule by this field will be automatically added to the <code>Queryable</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AutoSpec</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TProjection</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IPaging</span></span>, <span class="hljs-title"><span class="hljs-title">ILinqSpecification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TProjection</span></span>&gt;, <span class="hljs-title"><span class="hljs-title">ILinqOrderBy</span></span>&lt;<span class="hljs-title"><span class="hljs-title">TProjection</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">TProjection</span></span> : <span class="hljs-title"><span class="hljs-title">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IQueryable&lt;TProjection&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;TProjection&gt; query</span></span></span><span class="hljs-function">)</span></span> =&gt; GetType() .GetPublicProperties() .Where(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(TProjection).GetPublicProperties().Any(y =&gt; x.Name == y.Name)) .Aggregate(query, (current, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> val = next.GetValue(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (val == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current.Where(next.PropertyType == <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) ? <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{next.Name}</span></span></span><span class="hljs-string">.StartsWith(@0)"</span></span> : <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{next.Name}</span></span></span><span class="hljs-string">=@0"</span></span>, val); }); IOrderedQueryable&lt;TProjection&gt; ILinqOrderBy&lt;TProjection&gt;.Apply(IQueryable&lt;TProjection&gt; queryable) =&gt; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(OrderBy) ? queryable.OrderBy(OrderBy) : queryable.OrderBy(x =&gt; x.Id); }</code> </pre><br><blockquote>  <code>AutoSpec</code> can be implemented without <code>Dynamic Linq</code> , using only <code>Expression</code> , but the implementation does not fit into ten lines and the code will be much more difficult to understand. <br></blockquote><br><a name="upd"></a><h4>  UPD </h4><br>  <a href="https://habrahabr.ru/users/om2804/" class="user_link">om2804</a> and <a href="https://habrahabr.ru/users/xyzuvw/" class="user_link">xyzuvw</a> rightly pointed out that <code>IQueryableSpec</code> does not meet the layout requirements.  The fact is that I rarely have to deal with the need to do ||, and &amp;&amp; is achieved by a simple <code>query.Where(spec1).Where(spec2)</code> .  I decided to do a little refactoring to make the code cleaner: <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  IQueryableSpecification  IQueryableFilter public interface IQueryableFilter&lt;T&gt; where T: class { IQueryable&lt;T&gt; Apply(IQueryable&lt;T&gt; query); }</span></span></code> </pre> <br>  There is such a <a href="">library</a> : <a href="">LinqSpecs</a> .  I do not like the fact that you need to create separate types of specifications for each of them.  <code>Expression&lt;Func&lt;T, bool&gt;&gt;</code> enough for me <br><br>  We use the Predicate Builder from <a href="https://habrahabr.ru/post/313394/">Pete Montgomery</a> . <br><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Creates a predicate that evaluates to true. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public static Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; True</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">() { return param =&gt; true; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Creates a predicate that evaluates to false. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public static Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; False</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">() { return param =&gt; false; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Creates a predicate expression from the specified lambda expression. </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public static Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; Create</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; predicate) { return predicate; } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Combines the first predicate with the second using the logical "and". </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public static Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; And</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(this Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; first, Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; second) { return first.Compose(second, Expression.AndAlso); } </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> Combines the first predicate with the second using the logical "or". </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> public static Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; Or</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;T&gt;</span></span></span><span class="hljs-comment">(this Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; first, Expression</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;Func&lt;T, bool&gt;</span></span></span><span class="hljs-comment">&gt; second) { return first.Compose(second, Expression.OrElse); }</span></span></code> </pre><br>  Implementation details of the <code>Compose</code> method are explained in the link above.  Now add syntactic sugar so that you can use &amp;&amp; and ||  and <code>IHasId</code> restriction on generic, because I am not interested in creating specifications for the <a href="https://martinfowler.com/bliki/ValueObject.html">Value Object</a> .  This restriction is not necessary, it just seems better to me. <br><a name="spec"></a><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SpecificationExtenions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Specification&lt;T&gt; AsSpec&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> Expression&lt;Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; expr) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Specification&lt;T&gt;(expr); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Specification</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">IQueryableFilter</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; <span class="hljs-title"><span class="hljs-title">where</span></span> <span class="hljs-title"><span class="hljs-title">T</span></span>: <span class="hljs-title"><span class="hljs-title">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression&lt;Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; Expression { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Specification</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression&lt;Func&lt;T, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;&gt; expression</span></span></span><span class="hljs-function">)</span></span> { Expression = expression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (expression == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(expression)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> Expression&lt;Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt;(Specification&lt;T&gt; spec) =&gt; spec.Expression; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">false</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Specification&lt;T&gt; spec</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">true</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Specification&lt;T&gt; spec</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Specification&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &amp;(Specification&lt;T&gt; spec1, Specification&lt;T&gt; spec2) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Specification&lt;T&gt;(spec1.Expression.And(spec2.Expression)); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Specification&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> |(Specification&lt;T&gt; spec1, Specification&lt;T&gt; spec2) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Specification&lt;T&gt;(spec1.Expression.Or(spec2.Expression)); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Specification&lt;T&gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> !(Specification&lt;T&gt; spec) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Specification&lt;T&gt;(spec.Expression.Not()); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IQueryable&lt;T&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Apply</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IQueryable&lt;T&gt; query</span></span></span><span class="hljs-function">)</span></span> =&gt; query.Where(Expression); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsSatisfiedBy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T obj</span></span></span><span class="hljs-function">)</span></span> =&gt; Expression.AsFunc()(obj); }</code> </pre> <br>  I am used to writing down "specification-expressions" with static fields in the entity class to which they belong: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Category</span></span> : <span class="hljs-title"><span class="hljs-title">HasIdBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">int</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Expression&lt;Func&lt;Category, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; NiceRating = x =&gt; x.Rating &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Expression&lt;Func&lt;Category, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; BadRating = x =&gt; x.Rating &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Expression&lt;Func&lt;Category, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;&gt; Active= x =&gt; x.IsDeleted == <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//... } var niceCategories = db.Query&lt;Category&gt;.Where(Category.NiceRating);</span></span></code> </pre> <br>  Given the code above, you can rewrite it like this: <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Category</span></span> : <span class="hljs-title"><span class="hljs-title">HasIdBase</span></span>&lt;<span class="hljs-title"><span class="hljs-title">int</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Specification&lt;Category&gt; NiceRating = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Specification(x =&gt; x.Rating &gt; <span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-comment"><span class="hljs-comment">//... } var niceCategories = db.Query&lt;Category&gt; .Where((Category.NiceRating || Category.BadRating) &amp;&amp; Category.IsActive);</span></span></code> </pre> <br>  Now get rid of <code>DynamicLinq</code> .  We'll have to work a bit with expression trees. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Compose { And, Or } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Spec&lt;T&gt; AsSpec&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> obj, Compose compose = Compose.And) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>, <span class="hljs-title"><span class="hljs-title">IHasId</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filterProps = obj.GetType() .GetPublicProperties() .ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filterPropNames = filterProps .Select(x =&gt; x.Name) .ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> props = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(T) .GetPublicProperties() .Where(x =&gt; filterPropNames.Contains(x.Name)) .Select(x =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Property = x, Value = filterProps.Single(y =&gt; y.Name == x.Name).GetValue(obj) }) .Where(x =&gt; x.Value != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) .Select(x =&gt; { <span class="hljs-comment"><span class="hljs-comment">//     e =&gt; e.Prop == Val var parameter = Expression.Parameter(typeof (T)); var property = Expression.Property(parameter, x.Property); var body = Expression.Equal(property, Expression.Constant(x.Value)); var delegateType = typeof(Func&lt;T, bool&gt;); return (Expression&lt;Func&lt;T, bool&gt;&gt;) Expression.Lambda(delegateType, body, parameter); }) .ToArray(); if (!props.Any()) return new Spec&lt;T&gt;(x =&gt; true); //    ||  &amp;&amp; var expr = compose == Compose.And ? props.Aggregate((c, n) =&gt; c.And(n)) : props.Aggregate((c, n) =&gt; c.Or(n)); return expr.AsSpec(); }</span></span></code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/325280/">https://habr.com/ru/post/325280/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../325270/index.html">Exploiting eXternal Entity XML (XXE) Vulnerabilities</a></li>
<li><a href="../325272/index.html">7 workflow optimization techniques you may not have heard about</a></li>
<li><a href="../325274/index.html">CAPWAP State Machine in the Cisco Unified Wireless Implementation: Join State</a></li>
<li><a href="../325276/index.html">Zabbix for DevOps: how we implemented the monitoring system in the development and testing processes</a></li>
<li><a href="../325278/index.html">Abstract lectures on the design of game mechanics sandbox projects from the creator of Life is Feudal</a></li>
<li><a href="../325282/index.html">Twitter infrastructure: scale</a></li>
<li><a href="../325284/index.html">VR Design: scene content</a></li>
<li><a href="../325286/index.html">Live stream from MoscowJS Superjob office</a></li>
<li><a href="../325288/index.html">GoTech 2017 technological projects competition has started</a></li>
<li><a href="../325290/index.html">How to simplify software development when outsourcing?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>