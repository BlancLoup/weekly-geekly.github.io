<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>USB support in KolibriOS: what's inside? Part 4: Channel Support Level</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The story about the level of interaction with host controllers stretched out into two articles and still left some details behind the scenes - which, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>USB support in KolibriOS: what's inside? Part 4: Channel Support Level</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/882/61a/ae8/88261aae82f0dfcb06d32f7bfd94c4c6.png" align="right">  The story about the level of interaction with host controllers stretched out into <a href="http://habrahabr.ru/company/kolibrios/blog/183184/">two</a> <a href="http://habrahabr.ru/company/kolibrios/blog/183284/">articles</a> and still left some details behind the scenes - which, I hope, the interested reader can fill in directly from the <a href="http://websvn.kolibrios.org/listing.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252F%26">sources</a> .  The channel support level is much simpler and mostly busy in that it translates API calls for higher levels into the necessary sequence of actions, including locks, with the necessary host controller. <br><br><h3>  Channel opening </h3><br>  The <code>USBOpenPipe</code> function from the API, called <code>usb_open_pipe</code> in the <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fpipe.inc">pipe.inc</a> code, opens a new channel according to the specified channel characteristics and the ‚Äúparent‚Äù channel, where the device characteristics are recorded.  For this, she: <br><ul><li>  selects a pair of <code>*hci_pipe+usb_pipe</code> structures describing the channel and aligned with the controller-specific boundary by calling the <code>usb_hardware_func.AllocPipe</code> controller-specific function; </li><li>  selects a pair of <code>*hci_gtd+usb_gtd</code> , describing an empty transfer descriptor and aligned to the controller-specific border, by calling the controller-specific function <code>usb_hardware_func.AllocTD</code> ; </li><li>  fills in pointers: in the channel structure copies the pointer to the controller structure and the pointer to device data common to all channels from the ‚Äúparent‚Äù channel;  between the structure of the channel and the structure of the empty descriptor fills pointers back and forth;  the empty descriptor structure makes it the only element of the doubly linked channel list; </li><li>  initializes a mutex that will guard all operations with this channel.  Although all event handling from USB controllers takes place in the USB stream, one cannot say the same about API calls: an application reading a file from a USB flash drive initiates the transfer setting ‚Äî and not even one ‚Äî in the queue in the context of the application flow.  So that the new transfer does not prevent the USB stream from processing the completion of the old transfer, and this mutex is needed; </li><li>  captures the device channel set mutex and makes sure that the device is not yet disabled; </li><li>  causes controller-specific initialization of <code>usb_hardware_func.InitPipe</code> , protected by a mutex global to the controller; </li><li>  adds a new channel to the device channel set and releases the channel set mutex; </li><li>  in case of an error at one of the stages, all previous stages are rolled back.  Since it is the most difficult to roll back controller-specific initialization, it is done at the last stage, after which there can be no errors. </li></ul><br>  Controller-specific initialization with the last action adds a new channel to the appropriate list.  For control channels, as well as for channels of data arrays, there is only one list, but for interrupt channels you need to choose one of several options. <br><img src="https://habrastorage.org/getpro/habr/post_images/9ce/9a8/977/9ce9a89777b094f5ff515d2154116a32.png"><br>  This is where <a href="http://websvn.kolibrios.org/filedetails.php%3Frepname%3DKolibri%2BOS%26path%3D%252Fkernel%252Ftrunk%252Fbus%252Fusb%252Fscheduler.inc">scheduler.inc</a> comes into play.  He just chooses one of the lists of interrupt channels, and also makes sure that there is ‚Äúenough space‚Äù for the new channel.  I remind you that in every frame of FullSpeed-bus for periodic transmissions you can not use more than 90% of the time, and in every microframe HighSpeed-bus - more than 80% of the time. <br><br>  Here I must note that if for some reason you are writing a USB implementation that should <i>work</i> in your environment, you can save a lot on the scheduler.  In one form or another, you will have to implement everything else that is described in this series of articles, but in the absence of a large load, instead of a full tree, you can do with just one list of interrupt channels processed by each frame / microframe.  A slightly more economical scheme, not too complicating the implementation, is one list of channels for each processing interval of 1, 2, 4, 8, 16, 32 frames.  While it is not necessary to simultaneously process more than one device with large traffic to a single host controller, this approach is not inferior to a full-fledged scheduler.  A simple scheme will ‚Äúbreak‚Äù in some specific configurations with two or more isochronous channels of FullSpeed ‚Äã‚Äãdevices or three or more isochronous channels of HighSpeed ‚Äã‚Äãdevices, but perhaps no one will run your implementation in such specific conditions? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you are writing a USB implementation that should work <i>everywhere and always</i> , you will also have to write a scheduler. <br><a name="habracut"></a><br><br><h3>  Transaction time evaluation </h3><br><div class="spoiler">  <b class="spoiler_title">Data for calculations and the internal structure of transactions</b> <div class="spoiler_text">  One bit at FullSpeed ‚Äã‚Äãspeed is nominally transmitted for 1/12000 part of the frame, which gives a speed of 12 megabits / s.  In other words, the ‚Äúsize‚Äù of a single frame, as measured by the host controller, is 12,000 bits.  Both on the host and on the device, the timer ticking off 1/12000 milliseconds is ticking; according to the timer counts, the host or device starts to send the next bit.  The accuracy requirements of the host timer are quite stringent, and the calculations can be considered the host timer accurate.  For external FullSpeed ‚Äã‚Äãdevices, the specification allows a timer error of ¬± 0.25%, which means that the reception time of 400 bits from the device can correspond to a time from 399 to 401 "nominal FS-bits".  One bit at a speed of LowSpeed ‚Äã‚Äãis nominally transmitted 8 times longer than at FullSpeed ‚Äã‚Äãspeed, which gives a speed of 1.5 megabits / s.  LowSpeed ‚Äã‚Äãwas conceived as a weakened mode for simple devices like a mouse / keyboard, and the error of the LowSpeed ‚Äã‚Äãdevice‚Äôs timer should be within ¬± 1.5%: the reception time of 50 bits from the device can correspond to the time from 394 to 406 "nominal FS-bits". <br><br>  One bit at the speed of HighSpeed ‚Äã‚Äãis nominally transmitted for 1/60000 part of the microframe, which gives a speed of 480 megabits / s.  The accuracy requirements of the HighSpeed ‚Äã‚Äãdevices are raised to ¬± 0.05%, so that when planning transactions, the resulting error due to the discrepancy between the timers can be neglected. <br><br>  Transactions have their own internal structure.  Let's leave aside split transactions for now.  Normal transactions consist of several <i>packets</i> following the USB bus strictly sequentially, not alternating with other packets: a packet with a token (Token), an optional data packet (Data), an optional feedback packet (Handshake).  Before the packets sent from the host to the LowSpeed ‚Äã‚Äãdevice, there is a separate special PRE packet.  The PRE package and the pause after it with a minimum of 4 ‚Äúnominal FS bits‚Äù are needed for the hubs on the bus to have time to unblock the ports to which the LowSpeed ‚Äã‚Äãdevices are connected.  Normal FullSpeed ‚Äã‚Äãtraffic is not transmitted to such ports. <br><br>  Each packet starts with a SYNC sync of 8 bits = 1 byte on Low / Full-Speed ‚Äã‚Äãand 32 bits = 4 bytes on HighSpeed.  Each packet, except for the special PRE packet, ends with a 3-bit EOP (end of packet) sequence for Low / Full-Speed ‚Äã‚Äãand 8 bits for HighSpeed. <br><br>  The token determines the action, direction of transmission, address and end point of the device, receiving / transmitting data.  In normal transactions, three tokens are possible: IN, OUT, and SETUP for receiving data, sending data, and the first stage of the control transfer, respectively.  A packet with a token occupies 3 bytes, not counting SYNC + EOP: 8 bits for the packet type, 7 bits of the device address, 4 bits of the end point and 5 bits of the CRC, confirming that there are no errors in the transmission of the device address and the end point. <br><br>  The data packet contains the actual data sent or received from the device, as well as 3 additional bytes, not counting the SYNC + EOP: 8 bits for the packet type and 16 bits of the CRC data. <br><br>  The feedback packet consists of one byte, not counting the SYNC + EOP: 8 bits for the packet type.  The packet is sent in the opposite direction to the previous packet.  An ACK indicates that all data has been successfully received.  In IN transactions, the NAK packet is sent by the device instead of the data packet and means that there is no data yet.  For example, the mouse will respond this way while the controller polls it regularly, but the state has not changed since the last poll.  In OUT transactions, the NAK packet is sent by the device after the data packet and means that while the device is busy with internal affairs, the host must try again later.  NAK is not an error.  To signal an error, the device may not respond at all, respond with an incorrect package, or respond with a STALL package.  In the first two cases, the controller will consider this an error somewhere on the bus and will try again up to three times, after which it will surrender and report an error.  In the latter case, the controller will report an error immediately. <br>  There is no feedback package in isochronous transactions.  In an interrupt transaction, a feedback packet is required. <br><br>  In the USB data, the zero bit is inserted after every six single bits.  Single bits are encoded so that the bus state does not change when a single bit is used, a timer is used to select individual bits.  The zero bit is inserted so that the tolerable discrepancy in the timers does not create problems.  Therefore, in the worst case, the package delivery time must be multiplied by 7/6.  The multiplier does not apply to SYNC and EOP: they are encoded in a special way, generating guaranteed changes in the state of the bus. <br><br>  If the host controller sends two packets in a row, just a small pause (inter-packet delay) is sufficient, corresponding to transmission of 2 bits in the case of FullSpeed ‚Äã‚Äãand LowSpeed ‚Äã‚Äãand 88 bits in the case of HighSpeed.  If the controller has accepted the packet and must send a reply packet, the pause is reduced to 8 bits in the case of HighSpeed ‚Äã‚Äãand the same 2 bits in the case of FullSpeed ‚Äã‚Äãand LowSpeed.  If the host controller has sent a packet and is waiting for a reply packet, then it is necessary to take into account the delay in passing the packet to the device and the response packet from the device (turn-around time).  For FullSpeed ‚Äã‚Äãand LowSpeed ‚Äã‚Äãtires, the specification defines the maximum delay, including the passage of the signal in both directions and the response of the device, as a transmission time of 18 bits with an appropriate speed.  For HighSpeed, the maximum delay is equivalent to a transfer time of 736 bits. <br></div></div><br>  The host controller hides in itself the implementation of all these transaction details, for planning it is enough just to know how long the transaction will take.  The time depends on the type of transaction, the direction of the transaction and the speed of the device. <br><ul><li>  The interrupt read transaction consists of a packet with a token to the device, waiting for a response from the device, a packet with data from the device, a pause after a received packet, a feedback packet to the device, a pause after the sent packet. <ul><li>  HighSpeed-bus: 68 bits in the first packet, 736 wait bits, 40+ (7/6) * 8 * (data size + 3) bits in the second packet, 8 pause bits, 49 bits in the last packet, 88 more pause bits - total 989 + 8 * (7/6) * (data size + 3) bits maximum. </li><li>  FullSpeed ‚Äã‚Äãbus: 39 bits in the first packet, 18 bits of waiting, (401/400) * (11+ (7/6) * 8 * (data size + 3)) bits in the second packet, 2 bits of pause, 20 bits in the last packet, 2 more pause bits - a total of 93 + 2807/300 * (data size + 3) bits maximum. </li><li>  LowSpeed ‚Äã‚Äãbus: 16 FS-bits of the preamble to the first packet and 4 FS-bits for the hub reaction, 8 * 39 FS-bits in the first packet, 8 * 18 FS-bits of waiting, (406/50) * (11+ (7 / 6) * 8 * (data size + 3)) FS-bits in the second packet, 8 * 2 FS-bits of the pause, 16 FS-bits of the preamble to the last packet and 4 FS-bits for the response of the hubs, 8 * 20 FS- bits in the last packet, another 8 * 2 bits of the pause - total 778 + 5684/75 * (data size + 3) FS-bit maximum. </li></ul></li><li>  The interrupt recording transaction consists of a packet with a token to the device, a pause after the sent packet, a packet with data to the device, waiting for a response from the device, a feedback packet from the device, a pause after the received packet.  Difference from reading, not counting the order of the terms, only in the direction of transmission. <ul><li>  HighSpeed-bus: the same 989 + 8 * (7/6) * (data size + 3) bits maximum. </li><li>  FullSpeed ‚Äã‚Äãbus: The 401/400 multiplier ‚Äúmoves‚Äù from the data packet to the feedback packet, for a total of 93 + 28/3 * (data size + 3) bits maximum. </li><li>  LowSpeed-bus: 406/50 and 8 multipliers in two data packets and feedback are swapped, for a total of 778 + 224/3 * (data size + 3) FS-bit maximum. </li></ul></li><li>  An isochronous read transaction consists of a packet with a token to the device, waiting for a response from the device, a data packet from the device, a pause after the received packet <ul><li>  Highspeed-bus: 68 bits in the first packet, 736 wait bits, 40+ (7/6) * 8 * (data size + 3) bits in the second packet, 8 pause bits - total 852 + 8 * (7/6) * (data size + 3) bits maximum. </li><li>  FullSpeed ‚Äã‚Äãbus: 39 bits in the first packet, 18 bits of waiting, (401/400) * (11+ (7/6) * 8 * (data size + 3)) bits in the second packet, 2 bits of pause - total 71 + 2807/300 * (data size + 3) bits maximum. </li><li>  On a LowSpeed ‚Äã‚Äãbus, isochronous transactions are prohibited by specification. </li></ul></li><li>  An isochronous write transaction consists of a packet with a token to the device, a pause after the sent packet, a packet with data to the device, another pause after the sent packet. <ul><li>  Highspeed-bus: 68 bits in the first packet, 88 bits of the pause, 40+ (7/6) * 8 * (data size + 3) bits in the second packet, another 88 bits of the pause - total 284 + 8 * (7/6) * (data size + 3) bits maximum. </li><li>  FullSpeed ‚Äã‚Äãbus: 39 bits in the first packet, 2 bits of the pause, 11+ (7/6) * 8 * (data size + 3) bits in the second packet, another 2 bits of the pause - a total of 54 + 8 * (7/6) * (data size + 3) bits maximum. </li><li>  On a LowSpeed ‚Äã‚Äãbus, isochronous transactions are prohibited by specification. </li></ul></li></ul>  Split transactions contain three types of ‚Äúelementary‚Äù transactions on two buses: the Start-Split transaction on the HighSpeed ‚Äã‚Äãbus between the host and the TT, the normal transaction on the FullSpeed ‚Äã‚Äã/ LowSpeed ‚Äã‚Äãbus between the TT and the device, the Complete Split transaction on the HighSpeed ‚Äã‚Äãbus between the host and TT.  The transaction time in the middle differs from the time of the same transaction without TT only by the additional pause introduced by the TT and described in the hub descriptor with the TT.  Start-Split and Complete-Split transactions begin with a special SPLIT packet of 4 bytes in size, not counting SYNC + EOP. <ul><li>  Split read interrupt transaction and isochronous read transaction.  The Start-Split transaction consists of a SPLIT packet, a pause after the sent packet, a packet with a token, a pause after the sent packet ‚Äî a total of 321 bits.  The Complete-Split transaction consists of a SPLIT packet, a pause after a sent packet, a packet with a token, waiting for a response from the device, a data packet, a pause after a received packet ‚Äî total 1017 + 8 * (7/6) * (data size + 3) bits . </li><li>  Split interrupt write transaction.  The Start-Split transaction consists of a SPLIT packet, a pause after the sent packet, a packet with a token, a pause after the sent packet, a data packet, a pause after the sent packet ‚Äî a total of 449 + 8 * (7/6) * (data size + 3) bits .  The Complete-Split transaction consists of a SPLIT packet, a pause after the sent packet, a packet with a token, waiting for the device to respond, a packet with feedback, a pause after the received packet ‚Äî a total of 1026 bits. </li><li>  Split isochronous write transaction.  The Start-Split transaction has the same structure as in the case of an interrupt write transaction, 449 + 8 * (7/6) * (data size + 3) bits.  The Complete-Split transaction is missing. </li></ul><br><br><h3>  Scheduler </h3><br>  On a FullSpeed ‚Äã‚Äã/ LowSpeed ‚Äã‚Äãbus, a single frame can have no more than one transaction on a single channel, transfers from more than one transaction are broken up into several frames.  On the HighSpeed ‚Äã‚Äãbus, the maximum number of transactions per microframe can go up to 3 and is one of the channel characteristics along with the maximum transaction size. <br><br>  When opening a channel, the scheduler must reserve a portion of the 90% of the frame / 80% of the microframe for the channel, based on the worst case of channel use - assuming the maximum possible number of longest-running transactions.  The transaction duration is described in the previous section.  If you cannot reserve a part of the channel because everything is already occupied by other channels, the scheduler should return an error.  The driver, having detected an error, may, for example, try to agree with the device about reducing traffic due to something or inform the user (through the control program) that it is impossible to work under such conditions. <br><br>  Split transactions add complexity.  First, you need to reserve and keep records on two tires.  Secondly, microframes appear on the FullSpeed ‚Äã‚Äã/ LowSpeed ‚Äã‚Äãbus: if the Start-Split transaction from host to TT comes in the N microframe, then TT can start this transaction only in the N + 1 microframe, and return the results in the Complete-Split transaction - not earlier microframe N + 2.  Thirdly, although the maximum of 90% of the frame for all periodic transactions remains at worst, planning on the FS / LS bus should proceed from an optimistic estimate without a 7/6 multiplier due to the insertion of bits, the USB2 specification in the face of section 11.18 ‚ÄúPeriodic Split Transaction Pipelining and Buffer Management calls this assessment ‚Äúbest-case budget‚Äù - this reduces the chances that the FS / LS bus will be idle due to the fact that one periodic transaction was completed before the calculated one, the next periodic transaction could not start before the next microframe, because for her  The data of the Start-Split transaction did not come, and there is not enough time for the next non-periodic transaction in the rest of the current microframe.  Finally, the host does not know when the transaction will end exactly, and the TT buffers for storing the results are not rubber, so the Complete-Split transaction needs to be scheduled several times ‚Äî one in each microframe following the microframe in which the transaction can complete.  Specific requirements are voiced in the same section 11.18: as part of an interruption transaction starting from the microframe N, one Start-Split transaction in the N-1 microframe and three Complete-Split transactions in the N + 1, N + 2 microframes should be scheduled. N + 3.  Isochronous read transactions differ only in that they can occupy several N, ..., L microframes in the budget, because of which the Complete-Split transactions should be planned in microframes from N + 1 to L + 3 inclusive.  There are no Complete-Split transactions in the isochronous transactions, but there can be several Start-Split transactions: there is less than 188 bytes on the FS-bus in one microframe, and if there is more data, they will be split into several Start-Split transactions with a limit of 188 bytes in one transaction. <br><br>  The KolibriOS Scheduler tries to achieve as even distribution of the reserved parts as possible in different frames / microframes, trying to ensure that the phrase ‚ÄúX or more free time is in each frame / microframe‚Äù contains the X number as much as possible.  If a channel later appears requiring attention of each frame / microframe, a large X value is necessary for successful backup.  If it does not appear, time is useful for non-periodic broadcasts. <br><br>  First, the scheduler selects the real interval at which the host controller will poll the channel.  This is the easy part of the problem: choose from the numbers 1, 2, 4, 8, 16, 32 maximum, not more than the given one.          .     USB1    8 .   8 :  ,     8k+0, ...,  ,     8k+7.    32 ;  8k+0      4  0,8,16,24,           .    ,      , , 24,        ,  32k+24, 16k+8, 8k+0, 4k+0, 2k+0,  .        0,8,16,24,         8k+0.    ,     ,    8k+1, ..., 8k+7.    ‚Äî ,       ,  , ,  .   ,  ,         90% ,      . <br><br>  HighSpeed-  USB2  USB1   :   8     ;       ,    ,     ,      . <br><br>     USB2    ,    . ,           ,    .          FS-   .      ,    .     ,      HS-,    Start-Split  Complete-Split . <br><br><h3>       </h3><br>  <code>USBClosePipe</code>  API,  <code>usb_close_pipe</code>   pipe.inc,   .        ,   ¬´   ¬ª,      <code>usb_close_pipe_nolock</code> ,        USB-,       . <br><br>    -       <code>usb_device_disconnected</code> ,      ,    ,      <code>usb_close_pipe_nolock</code> ,  ,    ,       .  USB-  ,      ,     . <br><br>   <code>usb_close_pipe_nolock</code> : <ul><li>    (,      ); </li><li> ,     ,    ¬´ ¬ª (         ‚Äî     ); </li><li>   ; </li><li>      ; </li><li>  -  <code>usb_hardware_func.UnlinkPipe</code> ,     ,           scheduler.inc   . </li></ul><br>   -     ,      ,  -    <code>usb_pipe_closed</code> , : <ul><li>     ,  callback-   ¬´ ¬ª     ; </li><li>         ¬´   ¬ª ,    ,    ; </li><li>         ¬´   ¬ª ,       ,  ; </li><li>     ,    <code>DeviceDisconnected</code>   ,     ,    ,  ,  ,    ,       ,  ,   ,   . </li></ul><br><h3>        </h3><br>      ,    <code>USBNormalTransferAsync</code>  API,  <code>usb_normal_transfer_async</code>   pipe.inc, :   , ,     ,    -  <code>usb_hardware_func.AllocTransfer</code> ,   ,      ,    <code>usb_hardware_func.InsertTransfer</code>    . <br><br><h3>   </h3><br>          ,    ,   <code>USBControlTransferAsync</code>  API,  <code>usb_control_async</code>   pipe.inc,   <code>USBNormalTransferAsync</code> . <br><img src="https://habrastorage.org/getpro/habr/post_images/731/181/b82/731181b820cf6796572bf66a380ebd85.png"><br>  -  <code>usb_hardware_func.AllocTransfer</code>    ,   .    .  ,       ‚Äî  Toggle.    USB ¬´    ¬ª   ,  -     .            :       Toggle=0,     Toggle=1  .     Toggle     ,    . <br><br><h3>    </h3><br>  <a href="http://habrahabr.ru/company/kolibrios/blog/181586/">Part 1: general scheme</a> <br>  <a href="http://habrahabr.ru/company/kolibrios/blog/183184/">Part 2: Basics of working with host controllers</a> <br>  <a href="http://habrahabr.ru/company/kolibrios/blog/183284/">Part 3: Host Controller Support Code</a> <br>  4:    <br>  <a href="http://habrahabr.ru/company/kolibrios/blog/200172/">Part 5: logic level</a> <br> <a href="http://habrahabr.ru/company/kolibrios/blog/203918/"> 6:  </a> </div><p>Source: <a href="https://habr.com/ru/post/186276/">https://habr.com/ru/post/186276/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../186266/index.html">Fake ATMs found in Moscow</a></li>
<li><a href="../186268/index.html">Short list of innovations in Oracle 12c</a></li>
<li><a href="../186270/index.html">SparkleShare + SCM-Manager: A very simple alternative to DropBox for local network under Windows</a></li>
<li><a href="../186272/index.html">BeetlePlay - dating</a></li>
<li><a href="../186274/index.html">Over-security</a></li>
<li><a href="../186280/index.html">The whole truth about the Abyss model: Early markets and how to be if you made a mistake</a></li>
<li><a href="../186282/index.html">Tale of the present Internet</a></li>
<li><a href="../186284/index.html">Mikrotik, 3 providers, traffic switching and sharing</a></li>
<li><a href="../186286/index.html">KolibriOS: network, FTP client and Belgian programmer</a></li>
<li><a href="../186288/index.html">According to the Council of Federation, the Google User Agreement is contrary to the Constitution of the Russian Federation.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>