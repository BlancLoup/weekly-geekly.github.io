<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>When the actor framework turns into a ‚Äúblack box‚Äù and what can we do about it?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The actor model is a good approach to solving some types of problems. A ready actor framework, especially in the case of C ++, can make a developer‚Äôs ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>When the actor framework turns into a ‚Äúblack box‚Äù and what can we do about it?</h1><div class="post__text post__text-html js-mediator-article">  The actor model is a good approach to solving some types of problems.  A ready actor framework, especially in the case of C ++, can make a developer‚Äôs life much easier.  The programmer is removed a lot of worries on the management of working contexts, queuing of messages, monitoring the lifetime of messages, etc.  But, as they say, <s>all the good in this life is either illegal, or immoral, or leads to obesity for</s> nothing.  One of the problems of using a ready-made (i.e. alien) actor framework is that it sometimes turns into a black box.  You see that you give into this ‚Äúblack box‚Äù, you see what comes from it (if it comes at all).  But it is not always clear how the second is obtained from the first ... <br><a name="habracut"></a><br><h2>  What is it about? </h2><br>  One of the most common problems that developers encounter when using the <a href="https://habrahabr.ru/post/304386/">SObjectizer framework</a> is the non-receipt of sent messages.  Those.  The message has been sent, but it has not reached the recipient.  Why?  But this is an interesting question. <br><br>  There are several main reasons why a sent message does not reach the recipient: <br><br>  1. The recipient simply does not exist.  No longer exists or does not exist does not matter.  The recipient could be when we call send, but it can cease to exist even before send completes its work.  Or, calling send, we think that the recipient already exists, but in fact it has not yet been created. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      2. The recipient did not subscribe to the message.  That stupidly forgot to make a subscription to a specific message and all.  When a message is sent, it is not even delivered to the agent we need, because  he is simply not signed to the message.  Or, alternatively, they mistakenly signed the recipient to a message from another mailbox. <br><br>  3. The recipient did not subscribe to the message in the desired state.  For example, the agent-turns out there are three states in which he wants to process the message.  But the subscription was made only for two states, and the third was forgotten.  If the receiving agent is in this third state when the message arrives, the message will not be delivered to the recipient. <br><br>  There are other reasons, but these are the most common. <br><br>  According to our observations, causes # 2 and # 3 are the most common.  And everyone is attacking this rake, both beginners and experienced users of SObjectizer.  Even ourselves, the developers of SObjectizer, regularly make these stupid mistakes.  How does this happen?  Yes, very simple. <br><br><h3>  Simple example with the wrong subscription </h3><br>  Here is the code of the simplest example in which the pinger and ponger agents exchange ping and pong signals through a shared multi-producer / multi-consumer mailbox: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; // ,    pinger  ponger. struct ping final : public so_5::signal_t {}; struct pong final : public so_5::signal_t {}; //  pinger,   ping,   ping    pong. class pinger final : public so_5::agent_t { //  ,      . const so_5::mbox_t mbox_; public: //       . pinger(context_t ctx, so_5::mbox_t mbox) : so_5::agent_t{std::move(ctx)} , mbox_{std::move(mbox)} { //      . so_subscribe(mbox_).event([this](mhood_t&lt;pong&gt;) { std::cout &lt;&lt; "pong!" &lt;&lt; std::endl; so_5::send&lt;ping&gt;(mbox_); }); } //         ping. virtual void so_evt_start() override { so_5::send&lt;ping&gt;(mbox_); } }; //  ponger,   pong-    ping-. class ponger final : public so_5::agent_t { //  ,      . const so_5::mbox_t mbox_; public: //       . ponger(context_t ctx, so_5::mbox_t mbox) : so_5::agent_t{std::move(ctx)} , mbox_{std::move(mbox)} { //      . so_subscribe_self().event([this](mhood_t&lt;ping&gt;) { std::cout &lt;&lt; "ping!" &lt;&lt; std::endl; so_5::send&lt;pong&gt;(mbox_); }); } }; int main() { //  SObjectizer       . so_5::launch([](so_5::environment_t &amp; env) { env.introduce_coop([](so_5::coop_t &amp; coop) { //  ,   . const auto mbox = coop.environment().create_mbox(); //  . coop.make_agent&lt;pinger&gt;(mbox); coop.make_agent&lt;ponger&gt;(mbox); }); }); }</span></span></span></span></code> </pre> <br>  There is a small error in this simple code, due to which, when running the example, we will not see the printing of ping / pong messages.  Perhaps someone already understood what was happening.  But, generally speaking, it is not so easy to detect such annoying errors.  Especially when you deal not with examples, <a href="http://eao197.blogspot.com.by/2016/05/progc14-sobjectizer.html">but with real agents</a> , the logic and implementation of which can be much more complicated. <br><br><h2>  The effect of "black box" and what to do with it? </h2><br>  In the example shown above, we are faced with the fact that SObjectizer for us has become a ‚Äúblack box‚Äù.  We give out some control actions to him, but the result we need does not happen.  But why?  What is the reason?  How to get to the bottom of this reason? <br><br>  And here it turns out that getting to the bottom of the cause is not so easy.  We need to somehow debug our small example, but how to do it? <br><br>  If we use debuggers, then we can put breakpoints in several places.  For example: <br><br>  1. In the pinger :: so_evt_start () method to make sure that the first send for the ping is being called. <br><br>  2. In the ping signal handler in the ponger agent, in order to make sure that the first ping arrives and the pong is sent in response. <br><br>  Or, if we are real programmers and we believe that debuggers are for weaklings, then we can arrange debug seals in the same places. <br><br>  And having done these actions, we find that so_evt_start () is called, the first send for ping works, but the handler for pong is not called.  But why?  We made a subscription in the constructor ... <br><br>  Here, just before the developer who uses SObjectizer, the question arises: ‚ÄúBut how can you look inside SObjectizer to understand exactly how the message is delivered?‚Äù <br><br>  The question is not the easiest.  Because, if the programmer decides to send a send call, he will first get into the jungle of the details of the SObjectizer implementation and is unlikely to enjoy it (although some looked and said that they didn‚Äôt see anything wrong, but could they believe?).  Secondly, and most importantly, he will understand that message delivery consists of two parts.  The first part is setting up the message in the order queue for subscribers.  The second part is the maintenance of a specific application, which is retrieved from the queue by a specific dispatcher. <br><br>  And well, if the problem is found in the first part.  For example, the developer will see that there are no subscribers for the message and therefore no requests are generated for the message.  But if the applications were generated, but then the handler was not called, then the programmer will have to dive deeper into the giblets of SObjectizer.  And there he can find out that there are different dispatchers in SObjectizer, some very specific ones, who work differently than others, and it‚Äôs not so easy to find the place where the next application is extracted and analyzed from the queue. <br><br>  In general, if someone wants a debugger to go through the message delivery mechanism in SObjectizer, then this person can only wish good luck.  Since we ourselves are not big fans of this pastime. <br><br>  Is there any alternative? <br><br>  There is.  This is a <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%2520In-depth%2520-%2520Message%2520Delivery%2520Tracing/">mechanism that is officially called message delivery tracing</a> (or msg_tracing for simplicity).  It was added to SObjectizer-5 two and a half years ago.  But, probably, few people have heard about him, although we ourselves use it constantly. <br><br><h2>  Mechanism msg_tracing </h2><br>  When you run SObjectizer, you can enable the msg_tracing mechanism.  If it is enabled, then SObjectizer will generate text messages describing the process of delivering and processing messages.  These messages will be passed to a special tracer object.  The task of the tracer is to save or some other processing of trace messages.  The user can either implement his own tracer himself, or he can use one of the ready tracer from SObjectizer. <br><br>  Let's extend the example shown above by turning on msg_tracing and see what happens.  So, turn on msg_tracing and specify that all trace messages should be displayed on the standard output stream: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  SObjectizer       . so_5::launch([](so_5::environment_t &amp; env) { env.introduce_coop([](so_5::coop_t &amp; coop) { //  ,   . const auto mbox = coop.environment().create_mbox(); //  . coop.make_agent&lt;pinger&gt;(mbox); coop.make_agent&lt;ponger&gt;(mbox); }); }, [](so_5::environment_params_t &amp; params) { //     . //       . params.message_delivery_tracer(so_5::msg_tracing::std_cout_tracer()); }); }</span></span></code> </pre> <br>  Run the modified example and get something like: <br><pre>  [tid = 13728] [mbox_id = 5] deliver_message.no_subscribers [msg_type = struct ping] [signal] [overlimit_deep = 1] </pre><br>  This entry indicates that the deliver_message operation is in progress.  At the same time, a situation was discovered when there are no subscribers for the ping signal sent to the mailbox with such an identifier. <br><br>  So, we see that the message is sent to the mailbox, but nobody has subscribed to it.  But as so, we made a subscription, here it is: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      . so_subscribe_self().event([this](mhood_t&lt;ping&gt;) { std::cout &lt;&lt; "ping!" &lt;&lt; std::endl; so_5::send&lt;pong&gt;(mbox_); });</span></span></code> </pre> <br>  And here we can already see that we did a subscription, but not at all on that mbox.  We needed to call so_subscribe (mbox_), and we called so_subscribe_self ().  An annoying mistake that is made with enviable regularity.  The msg_tracing mechanism allowed us to quickly deal with the problem, without diving into the SObjectizer giblets with the debugger. <br><br><h3>  msg_tracing is a debugging mechanism </h3><br>  The most important thing to remember is that msg_tracing is a debugging, auxiliary mechanism.  It was created to help developers with debugging applications developed on the basis of SObjectizer. <br><br>  In particular, additional overhead costs are associated with msg_tracing, which significantly increases the cost of sending and receiving messages.  That is why msg_tracing needs to be included explicitly, this is done only once and only before starting the SObjectizer.  You cannot disable msg_tracing after SObjectizer has been started with msg_tracing turned on.  Everything is so serious that with msg_tracing enabled, other data structures containing both additional data and additional code are used inside the SObjectizer.  So, inside the SObjectizer, when msg_tracing is turned on, other types of mboxes are created. <br><br>  Therefore, msg_tracing should be considered as an auxiliary tool for debugging SObjectizer applications.  And you should not build on its base any means that will have to work in production. <br><br><h2>  The current state of the msg_tracing mechanism: its disadvantages and possible solutions </h2><br>  The msg_tracing mechanism was added to version 5.5.9 in October 2015.  Even then it was clear that this mechanism itself is in its infancy.  It was necessary to start with something, it was necessary to get something working that one could try in practice, gain experience and understand where to go next. <br><br>  Since that time, two serious miscalculations / deficiencies have been identified in the existing msg_tracing mechanism. <br><br><h3>  No trace filtering </h3><br>  If msg_tracing was enabled at the start of SObjectizer, then SObjectizer created text trace messages for all operations related to message delivery and passed these messages to the tracer object.  This is not a problem when msg_tracing is used to debug a small application, example, or test.  But if you try to use msg_tracing in a large application with hundreds of agents inside that exchange millions of messages, this is a problem.  Since  you need to somehow filter out the unnecessary programmer trace messages, and doing this with text trace messages is not so easy. <br><br>  Correspondingly, from time to time, there was talk of allowing the SObjectizer user to filter trace messages before they are transmitted to the tracer.  Moreover, the filter must deal not with the finalized text message, but with the data that is then converted into text. <br><br><h3>  It is not possible to control the flow of trace messages. </h3><br>  Sometimes I would like to launch a SObjectizer with blocked trace messages, and then, at some point in time, ‚Äúopen the tap‚Äù and allow trace messages to get into the tracer.  And then "turn off the tap." <br><br>  Accordingly, from time to time, there was talk that msg_tracing could be turned on and off during the operation of SObjectizer.  Although the difficulty here was that at its launch, SObjectizer should already know that the developer wants to have msg_tracing.  In this case, the SObjectizer will create other types of mboxes and will use other methods of message delivery (with a trace of what is happening). <br><br><h2>  Upcoming modification msg_tracing in version 5.5.22 </h2><br>  The other day we recorded the first alpha of the new version of SObjectizer.  It has an extension of the msg_tracing mechanism.  The concept of a filter for trace messages has been added. <br><br>  Filter is optional.  If a filter is assigned, before forming a text trace message, SObjectizer first asks the filter if it is necessary to allow further processing of the current trace message.  If the filter says that ‚Äúyes, it is possible‚Äù, then a text trace message is generated and it is given to the tracer object.  If the filter says ‚Äúno, not‚Äù, then the trace message is not generated and does not go anywhere. <br><br>  If there is no filter, then SObjectizer works as before: a text trace message is generated and sent to the tracer object.  Those.  if the programmer does not know about filters or does not want to use filters, then the msg_tracing mechanism works as before for him. <br><br>  In addition, SObjectizer in version 5.5.22 allows you to set and delete msg_tracing-filters during their work. <br><br><h3>  An example of using msg_tracing-filters in version 5.5.22 </h3><br>  To demonstrate the new features of the msg_tracing mechanism, let's take the following example.  There are two agents that work almost equally.  They have three states: first, second and third.  In each of their states, agents must respond to two types of messages.  According to the change_state message, you need to go to the next state (ie, from first to second, from second to third, from third to first).  If the tick message arrives, then the agent needs to simply react to it.  What will be the reaction - it does not matter. <br><br>  The difference between the first and second agents will be that the first agent responds to the tick message in each of its states.  But the second agent subscribed to the message tick in the second state forgot.  Accordingly, the second agent will lose tick messages when it is in the second state.  It is precisely these losses that we want to detect using the msg_tracing mechanism. <br><br>  To do this, we need to install a trace filter of the following form: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,    //  -  .    , //        . so_environment().change_message_delivery_tracer_filter( so_5::msg_tracing::make_filter( [](const so_5::msg_tracing::trace_data_t &amp; td) { //      . const auto handler_ptr = td.event_handler_data_ptr(); if(handler_ptr) { //    trace- . //   ,    . if(nullptr == *handler_ptr) //   .    , //   . Trace-  . return true; } //      trace-. return false; }));</span></span></code> </pre> <br>  It looks probably scary.  But let's try to figure it out. <br><br>  The change_message_delivery_tracer_filter () method allows you to replace the trace filter during SObjectizer operation. <br><br>  The auxiliary function make_filter creates an object of the desired SObjectizer type from a lambda function. <br><br>  A single argument is passed to this lambda function ‚Äî a reference to the trace_data_t interface, from which the filter can extract trace-related data.  In this particular case, we call trace_data_t the only method event_handler_data_ptr ().  This method returns optional &lt;const event_handler_data *&gt;.  Accordingly, inside optional can either be a pointer or not.  If there is no pointer, then the trace message means that we are not interested, since  it does not relate to the search for a message handler.  If there is a pointer, but it is null, then this is exactly the case that we are waiting for: SObjectizer tried to find a handler for the message, but found nothing.  In this and only in this case, we allow the trace message. <br><br>  If we run this example, we see that the following messages appear on the console periodically: <br><pre>  [tid = 11880] [agent_ptr = 0x23be91d7cb0] demand_handler_on_message.find_handler [mbox_id = 6] [msg_type = struct base :: tick] [signal] [state = second] [evt_handler = NONE]
 [tid = 11880] [agent_ptr = 0x23be91d7cb0] demand_handler_on_message.find_handler [mbox_id = 6] [msg_type = struct base :: tick] [signal] [state = second] [evt_handler = NONE]
 [tid = 11880] [agent_ptr = 0x23be91d7cb0] demand_handler_on_message.find_handler [mbox_id = 6] [msg_type = struct base :: tick] [signal] [state = second] [evt_handler = NONE]
 [tid = 11880] [agent_ptr = 0x23be91d7cb0] demand_handler_on_message.find_handler [mbox_id = 6] [msg_type = struct base :: tick] [signal] [state = second] [evt_handler = NONE] </pre><br>  And they are then baked, then not printed.  This is because we have a trace_controller agent, which then "turns on" the stream of trace messages, then "turns off" it. <br><br><div class="spoiler">  <b class="spoiler_title">For those interested here is the full code of the example.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;so_5/all.hpp&gt; //     . class base : public so_5::agent_t { protected: //  ,     //     . struct tick final : public so_5::signal_t {}; //      . struct change_state final : public so_5::signal_t {}; // ,     . state_t st_first{this, "first"}, st_second{this, "second"}, st_third{this, "third"}; //   .    , //      . so_5::timer_id_t tick_timer_; so_5::timer_id_t change_state_timer_; public: base(context_t ctx) : so_5::agent_t{std::move(ctx)} {} //     . virtual void so_define_agent() override { //   . this &gt;&gt;= st_first; //   change_state     . st_first.event([this](mhood_t&lt;change_state&gt;) { this &gt;&gt;= st_second; }); st_second.event([this](mhood_t&lt;change_state&gt;) { this &gt;&gt;= st_third; }); st_third.event([this](mhood_t&lt;change_state&gt;) { this &gt;&gt;= st_first; }); } //  ,    . virtual void so_evt_start() override { using namespace std::chrono_literals; //      250ms. change_state_timer_ = so_5::send_periodic&lt;change_state&gt;(*this, 250ms, 250ms); //    tick. tick_timer_ = so_5::send_periodic&lt;tick&gt;(*this, 0ms, 100ms); } }; //  ,    tick    . class first_agent final : public base { public: using base::base; virtual void so_define_agent() override { base::so_define_agent(); //   . so_subscribe_self() .in(st_first).in(st_second).in(st_third) .event([](mhood_t&lt;tick&gt;){}); } }; //  ,     tick  st_second. class second_agent final : public base { public: using base::base; virtual void so_define_agent() override { base::so_define_agent(); //   . so_subscribe_self() .in(st_first).in(st_third) .event([](mhood_t&lt;tick&gt;){}); } }; // ,      ""  ""  //   trace-. class trace_controller final : public so_5::agent_t { //   /. struct on_off final : public so_5::signal_t {}; // ,      . state_t st_on{this}, st_off{this}; //    on_off. so_5::timer_id_t timer_; public: trace_controller(context_t ctx) : so_5::agent_t{std::move(ctx)} { st_off.event([this](mhood_t&lt;on_off&gt;) { //  . this &gt;&gt;= st_on; //    ,    //  -  .    , //        . so_environment().change_message_delivery_tracer_filter( so_5::msg_tracing::make_filter( [](const so_5::msg_tracing::trace_data_t &amp; td) { //      . const auto handler_ptr = td.event_handler_data_ptr(); if(handler_ptr) { //    trace- . //   ,    . if(nullptr == *handler_ptr) //   .    , //   . Trace-  . return true; } //      trace-. return false; })); }); st_on.event([this](mhood_t&lt;on_off&gt;) { //  . this &gt;&gt;= st_off; //  . so_environment().change_message_delivery_tracer_filter( //       trace-. so_5::msg_tracing::make_disable_all_filter()); }); this &gt;&gt;= st_off; } virtual void so_evt_start() override { using namespace std::chrono_literals; timer_ = so_5::send_periodic&lt;on_off&gt;(*this, 0ms, 1500ms); } }; int main() { //  SObjectizer       . so_5::launch([](so_5::environment_t &amp; env) { env.introduce_coop([](so_5::coop_t &amp; coop) { //         // first_agent  second_agent. coop.make_agent&lt;first_agent&gt;(); coop.make_agent&lt;second_agent&gt;(); //    ,      //   trace-. coop.make_agent&lt;trace_controller&gt;(); }); }, [](so_5::environment_params_t &amp; params) { //     . //       . params.message_delivery_tracer(so_5::msg_tracing::std_cout_tracer()); //   trace-   ,    . params.message_delivery_tracer_filter( so_5::msg_tracing::make_disable_all_filter()); }); }</span></span></span></span></code> </pre> <br></div></div><br><h3>  What is available now via trace_data_t? </h3><br>  Currently, the trace_data_t interface is defined as follows: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">trace_data_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-comment"><span class="hljs-comment">//  ID  ,    . virtual optional&lt;current_thread_id_t&gt; tid() const noexcept = 0; //     ,    . virtual optional&lt;std::type_index&gt; msg_type() const noexcept = 0; //    ,     . virtual optional&lt;msg_source_t&gt; msg_source() const noexcept = 0; //   -,   . virtual optional&lt;const agent_t *&gt; agent() const noexcept = 0; //        . virtual optional&lt;message_or_signal_flag_t&gt; message_or_signal() const noexcept = 0; //      . virtual optional&lt;message_instance_info_t&gt; message_instance_info() const noexcept = 0; //     . virtual optional&lt;compound_action_description_t&gt; compound_action() const noexcept = 0; //        . //    ,      //    . virtual optional&lt;const so_5::impl::event_handler_data_t *&gt; event_handler_data_ptr() const noexcept = 0; };</span></span></code> </pre> <br>  It should be especially emphasized that all this information will not always be available for the trace message.  For example, if a message is sent to a mailbox for distribution to subscribers, then event_handler_data_ptr () will return an empty optional.  If the mailbox does not have subscribers for this type of message, then the agent () method will return an empty optional. <br><br><h2>  Why was all this described? </h2><br>  This article was written in order to enable those interested developers to know in advance about what awaits them in the next version of SObjectizer.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, they can familiarize themselves with the proposed innovations, can feel them, make their impression and express their ‚ÄúPhi‚Äù, if they don‚Äôt like something ( </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">so-5.5.22-alpha1</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is available for download, the </font></font><a href="https://github.com/eao197/so-5-5"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mirror on github</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is also updated </font><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, we, accordingly, will have the opportunity to understand what and how to improve even before fixing the final version 5.5.22. For us, this is important, because we have a leap on the theme of maintaining compatibility between versions and we really do not like to break this very compatibility. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So if someone is interested in this topic, then please speak in the comments. We will try to listen to constructive considerations.</font></font><br><br>  Ps. ,    ,   <a href="https://bitbucket.org/sobjectizerteam/so5_msg_tracing_demo_ru">  </a> . <br><br> PPS.          5.5.22  <a href="http://eao197.blogspot.com/2018/03/progc-sobjectizer.html">        </a> . ,          ,       ,  ,   5.5.22    . </div><p>Source: <a href="https://habr.com/ru/post/352176/">https://habr.com/ru/post/352176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352166/index.html">How is the assessment of the state of the object?</a></li>
<li><a href="../352168/index.html">REST services on ASP.NET Core under Linux in production</a></li>
<li><a href="../352170/index.html">OpenStreetMap News Digest</a></li>
<li><a href="../352172/index.html">Link Building for Bing - Unlike Google and Important Nuances</a></li>
<li><a href="../352174/index.html">FPGA accelerators go to the clouds</a></li>
<li><a href="../352178/index.html">All according to GOST. Information security when using virtualization technologies</a></li>
<li><a href="../352180/index.html">Patch from Meltdown led to a more critical vulnerability Windows 7x64 / 2008R2</a></li>
<li><a href="../352182/index.html">Validation of email addresses to protect against spam bots on the site</a></li>
<li><a href="../352184/index.html">From the installation of AWX to the launch of the first playbook - setting up centralized control Ansible</a></li>
<li><a href="../352186/index.html">Cache problems and solutions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>