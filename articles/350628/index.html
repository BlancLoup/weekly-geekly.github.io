<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Software Transactional Memory on Free Monads</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Realizing that I hadn‚Äôt written anything useful about HF and Haskell for Habr, and that there is quite a good reason for a technical article, I decide...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Software Transactional Memory on Free Monads</h1><div class="post__text post__text-html js-mediator-article">  Realizing that I hadn‚Äôt written anything useful about HF and Haskell for Habr, and that there is quite a good reason for a technical article, I decided to shake the old days.  The article focuses on <i>Software Trasactional Memory (STM)</i> , which I managed to implement on Free Monads with the participation of ADTs (Algebraic Data Types) and MVars (competitive mutable variables).  And, in general, the Proof of Concept turned out to be extremely simple, compared to the ‚Äúreal‚Äù STM.  Let's discuss this. <br><br><h3>  Software Transactional Memory </h3><a name="habracut"></a><br>  STM is an approach for programming a competitive data model.  Competitiveness here is that different parts of the model can be updated in different flows independently of each other, and conflicts on shared resources are resolved with the help of transactions.  Transaction is similar to that in the database, but there are a number of differences.  Suppose you want to change some of the data in your code.  Conceptually, we can assume that your code does not write directly to the model, but works with a copy of the part that it needs.  At the end, the STM engine opens the transaction and first checks that the part of the model you are interested in has not changed.  Did not change?  Well, the new values ‚Äã‚Äãwill be fixed.  Did someone have time before you?  This is a conflict, if you please, restart your calculations on the new data.  Schematically it can be represented as follows: <br><br><div style="text-align:center;"><img width="640" height="380" src="https://habrastorage.org/webt/xd/ew/c9/xdewc96wvwycaskfon4uhg4ytbg.png"></div><br>  Here, atomic operations are performed by threads in parallel, but committed only within transactions that block access to the variable parts of the model. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      There are different variations of STM, but we will talk specifically about the one proposed in the famous work <a href="http%253A%252F%252Fresearch.microsoft.com%252Fen-us%252Fum%252Fpeople%252Fsimonpj%252Fpapers%252Fstm%252Fstm.pdf">‚ÄúComposable Memory Transactions‚Äù</a> , since it is distinguished by a number of remarkable properties: <br><br><ul><li>  the concepts of data model and calculations above it are separated; </li><li>  computations are the STM monad, and they are composable in full accordance with the AF paradigm; </li><li>  there is the notion of manually restarting the calculation (retry); </li><li>  Finally, there is an excellent implementation for Haskell, which, however, I will not consider, but I will focus on my own, interface-like. </li></ul><br>  A model can be any kind of data structure.  You can convert any of your regular model into a transactional one, for this STM-libraries provide various primitives: variables ( <b>TVar</b> ), queues ( <b>TQueue</b> ), arrays ( <b>TArray</b> ) and many others.  One can guess that the transaction variables - TVars ("creatures") - are already minimally sufficient for a full-fledged STM, and everything else is expressed through them. <br><br>  Consider, for example, the <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BE%25D0%25B1_%25D0%25BE%25D0%25B1%25D0%25B5%25D0%25B4%25D0%25B0%25D1%258E%25D1%2589%25D0%25B8%25D1%2585_%25D1%2584%25D0%25B8%25D0%25BB%25D0%25BE%25D1%2581%25D0%25BE%25D1%2584%25D0%25B0%25D1%2585">problem of the dining philosophers</a> .  We can imagine forks as a common resource to which we need to build competitive access: <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ForkState</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Taken</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ForkState</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Forks</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Forks</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork1</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork2</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork3</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork4</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork5</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> }</span></span></code> </pre> <br>  This model is the simplest: each fork is stored in its own transaction variable, and you need to work with them in pairs: <b>(fork1, fork2), (fork2, fork3), ... (fork5, fork1)</b> .  But such a structure would work worse: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Forks</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> [</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ForkState</span></span></span><span class="hljs-class">]</span></span></code> </pre> <br>  Because there is only one shared resource, and if we had five philosophizing streams, they would receive the right to commit in turn.  In the end, only one philosopher would dine, and four others would reflect, and the next time he would have dined another, but also one, although theoretically, with five forks, two could have dinner in parallel.  Therefore, you need to make a competitive model that will give the most expected behavior.  Here is how the calculation in the STM monad could look like for a model with separate forks-creatures: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ForkState</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Taken</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ForkState</span></span></span><span class="hljs-class"> takeFork :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STM</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> takeFork tFork = do forkState &lt;- readTVar tFork when (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forkState</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">writeTVar</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tFork</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Taken</span></span></span><span class="hljs-class">) pure (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forkState</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  The function returns <b>True</b> if the plug was free, and it was successfully ‚Äútaken‚Äù, that is, overwritten by <b>tFork</b> .  False will be if the plug is already in business and cannot be touched.  Now consider a couple of forks.  There can be five situations: <br><br><ul><li>  Both are free </li><li>  Left is busy (left neighbor), right is free </li><li>  Left is free, right is busy (right neighbor) </li><li>  Both are busy (neighbors) </li><li>  Both are busy (our philosopher) </li></ul><br>  We now write the taking of both forks by our philosopher: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">takeForks</span></span> :: (<span class="hljs-type"><span class="hljs-type">TFork</span></span>, <span class="hljs-type"><span class="hljs-type">TFork</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">STM</span></span> <span class="hljs-type"><span class="hljs-type">Bool</span></span> takeForks (tLeftFork, tRightFork) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> leftTaken &lt;- takeFork tLeftFork rightTaken &lt;- takeFork tRightFork pure (leftTaken &amp;&amp; rightTaken)</code> </pre> <br>  You may notice that the code allows you to take one fork (for example, the left one), but do not take another one (for example, the right fork, which was occupied by the neighbor).  The <b>takeForks</b> function, of course, returns <b>False</b> in this case, but what about the fact that one fork did end up in the hands of our philosopher?  He will not be able to eat alone, so it must be put back, and continue to think for some time.  After that, you can try again in the hope that both forks will be free. <br><br>  But ‚Äúput back‚Äù in terms of STM is implemented somewhat differently than in terms of other competitive structures.  We can assume that both the variables <b>tLeftFork</b> and <b>tRightFork</b> are local copies that are not associated with the same resource from other philosophers.  Therefore, you can not "put" the plug back, and tell the calculation that it failed.  Then our one taken fork will not be written into shared resources - it‚Äôs all the same that there was no successful <b>takeFork</b> call.  This is very convenient, and it is the ‚Äúundo‚Äù operation of the current monadic calculation that distinguishes the implementation of the haskel STM from the others.  To cancel, there is a special <b>retry</b> method, let's rewrite <b>takeForks</b> using it: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">takeForks</span></span> :: (<span class="hljs-type"><span class="hljs-type">TFork</span></span>, <span class="hljs-type"><span class="hljs-type">TFork</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">STM</span></span> () takeForks (tLeftFork, tRightFork) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> leftTaken &lt;- takeFork tLeftFork rightTaken &lt;- takeFork tRightFork when (not leftTaken || not rightTaken) retry</code> </pre> <br>  The calculation will be successful when both forks were taken at once by our philosopher.  Otherwise, it will restart over and over at some intervals.  In this version, we do not return <b>Bool</b> , because we do not need to know whether both resources have been successfully captured.  If the function is executed and the calculation is not filled, then it is successful. <br><br>  After taking forks, we will probably need to do something else, for example, to transfer the philosopher to the ‚ÄúEating‚Äù state.  We simply do this after calling <b>takeForks</b> , and the STM monad will take care of the ‚Äúcreature‚Äù states to be consistent: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PhilosopherState</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Thinking</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eating</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Philosopher</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Philosopher</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pState</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PhilosopherState</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pLeftFork</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pRrightFork</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> } changePhilosopherActivity :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Philosopher</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STM</span></span></span><span class="hljs-class"> () changePhilosopherActivity (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Philosopher</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tState</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tLeftFork</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tRightFork</span></span></span><span class="hljs-class">) = do state &lt;- readTVar tState case state of </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Thinking</span></span></span><span class="hljs-class"> -&gt; do taken &lt;- takeForks tFs unless taken retry </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">-- Do not need to put forks if any was taken! writeTVar tAct Eating pure Eating Eating -&gt; error "Changing state from Eating not implemented."</span></span></span></span></code> </pre> <br>  We will leave the full implementation of this method as an exercise, and now consider the last missing link.  So far we only described the logic of the transactional model, but we have not yet created any specific <b>TVar</b> , and have not run anything.  Let's do it: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">philosoperWorker</span></span> :: <span class="hljs-type"><span class="hljs-type">Philosopher</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () philosoperWorker philosopher = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> atomically (changePhilosopherActivity philosopher) threadDelay <span class="hljs-number"><span class="hljs-number">5000</span></span> philosoperWorker philosopher runPhilosophers :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () runPhilosophers = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> tState1 &lt;- newTVarIO <span class="hljs-type"><span class="hljs-type">Thinking</span></span> tState2 &lt;- newTVarIO <span class="hljs-type"><span class="hljs-type">Thinking</span></span> tFork1 &lt;- newTVarIO <span class="hljs-type"><span class="hljs-type">Free</span></span> tFork2 &lt;- newTVarIO <span class="hljs-type"><span class="hljs-type">Free</span></span> forkIO (philosoperWorker (<span class="hljs-type"><span class="hljs-type">Philosopher</span></span> tState1 tFork1 tFork2)) forkIO (philosoperWorker (<span class="hljs-type"><span class="hljs-type">Philosopher</span></span> tState2 tFork2 tFork1)) threadDelay <span class="hljs-number"><span class="hljs-number">100000</span></span></code> </pre> <br>  The <b>atomically :: STM a -&gt; IO a</b> combinator performs the calculation in the <b>STM</b> monad atomically.  From the type it can be seen that the pure part - working with a competitive model - is separated from impure calculations in the <b>IO</b> monad.  STM-code should not have effects.  It‚Äôs better - none at all, otherwise you will get some strange results when you restart, for example, if you wrote to a file, in some situations you may get spurious records, and this error is very difficult to catch.  Therefore, we can assume that in the <b>STM</b> monad there are only pure calculations, and their execution is an atomic operation, which, however, does not block other calculations.  The functions for creating <b>TVar newTVarIO :: a -&gt; IO (TVar a) are also unclean</b> , but nothing prevents you from creating new <b>TVars</b> inside the <b>STM</b> using a clean combinator <b>newTVar :: a -&gt; STM (TVar a)</b> .  We just did not need it.  Attentive ones will notice that only forks are a shared resource here, and the condition of the philosophers themselves is wrapped in <b>TVar</b> for convenience only. <br><br>  Summarize.  The minimum <b>STM</b> implementation should contain the following functions for working with <b>TVar</b> : <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">newTVar</span></span> :: a -&gt; <span class="hljs-type"><span class="hljs-type">STM</span></span> (<span class="hljs-type"><span class="hljs-type">TVar</span></span> a) readTVar :: <span class="hljs-type"><span class="hljs-type">TVar</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">STM</span></span> a writeTVar :: <span class="hljs-type"><span class="hljs-type">TVar</span></span> a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">STM</span></span> ()</code> </pre> <br>  Perform calculations: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">atomically</span></span> :: <span class="hljs-type"><span class="hljs-type">STM</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> a</code> </pre> <br>  Finally, the ability to restart the calculation will be a huge plus: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">retry</span></span> :: <span class="hljs-type"><span class="hljs-type">STM</span></span> a</code> </pre> <br>  Of course, in libraries there are a huge number of other useful constructions, for example, an instance of the class of types <b>Alternative</b> for <b>STM</b> , but let's leave it to self-study. <br><br><h3>  STM on Free Monads </h3><br>  Implementing a correctly working STM is considered difficult, and it is better if there is support from the compiler.  I have heard that the implementations in Haskell and Clojure are by far the best, and in other languages ‚Äã‚ÄãSTM is not quite real.  It can be assumed that monadic STM with the possibility of restarting calculations and controlling effects is not in any imperative language.  But this is all idle reasoning, and I may be wrong.  Unfortunately, I don‚Äôt understand the insides of even the <a href="https://hackage.haskell.org/package/stm">stm</a> hasksel library, not to mention other ecosystems.  However, from the point of view of the interface, it is quite clear how the code should behave in a multi-threaded environment.  And if there is a specification of the interface (domain-specific language) and the expected behavior, this is enough to try to create your own STM using Free-monads. <br><br>  So, <i>free-monads</i> .  Any DSL built on Free-Monads will have the following characteristics: <br><br><ul><li>  Pure DSL, compiled monadically, that is, truly functional; </li><li>  The code on this DSL will not contain anything extra, besides the subject area, which means that it is easier to read and understand; </li><li>  Interface and implementation are effectively separated; </li><li>  There can be several implementations, and they can be replaced in runtime. </li></ul><br>  <i>Free monads</i> are a very powerful tool, and they can be considered the ‚Äúright‚Äù, purely functional approach to implementing <i>Inversion of Control</i> .  According to my feelings, any problem in the subject area can also be solved with the help of Free-monadic DSL.  Since this topic is very extensive and covers many issues of design and software architecture in functional programming, I will leave other details behind the brackets.  Curious people can refer to numerous sources on the Internet or to my half-book <a href="https://www.reddit.com/r/haskell/comments/6ck72h/functional_design_and_architecture/">‚ÄúFunctional Design and Architecture‚Äù</a> , where Free monads are given special attention. <br><br>  And now let's look at the code of my library <a href="https://github.com/graninas/stm-free">stm-free</a> . <br><br>  Since STM is a domain-specific language for creating transactional models, it is pure and monadic, we can assume that for a minimal STM, Free DSL should contain the same methods for working with TVar, and they will be automatically compiled and clean in this very Free-monad.  First, we define what TVar is. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UStamp</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Unique</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVarId</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVarId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UStamp</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVarId</span></span></span></span></code> </pre> <br>  We will need to distinguish between our "beasts", so each instance will be identified by a unique value.  The library user does not need to know this; he is expected to use the <b>TVar a</b> type.  Working with values ‚Äã‚Äãof this type is half the behavior of our little STM.  Therefore, we define <i>ADT</i> with the appropriate methods: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NewTVar</span></span></span><span class="hljs-class"> :: a -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">WriteTVar</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> a -&gt; a -&gt; next -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ReadTVar</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> a -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next</span></span></code> </pre> <br>  And here you need to stay in more detail. <br><br>  Why should we do this?  The bottom line is that a Free-Monad should be built on top of some kind of eDSL.  The easiest way to set it up is to define possible methods in the form of ADT constructors.  The end user will not work with this type, but we will use it to interpret the methods with some effect.  Obviously, the NewTVar method should be interpreted with the result ‚Äúa new TVar is created and returned as a result‚Äù.  But you can make an interpreter that will do something else, for example, write to the database, log, or even make calls to a real STM. <br><br>  These constructors contain all the necessary information to be interpreted.  The <b>NewTVar</b> constructor contains some user-defined value <b>a</b> , and when interpreted we will put this value in the new TVar.  But the problem is that <b>a</b> must be different for each <b>NewTVar</b> call.  If we just wrote <b>STMF next a</b> , <b>a would</b> already be common to the whole code, where several <b>NewTVar</b> calls are <b>tied</b> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next a where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">NewTVar</span></span></span><span class="hljs-class"> :: a -&gt; (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">next</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next</span></span></code> </pre> <br>  But it is meaningless, because we still want to use <b>NewTVar</b> for our arbitrary types, and so that they do not push.  Therefore, we remove <b>a</b> in the local visibility of only a specific method. <br><blockquote>  <i>Note</i>  In fact, to speed up the work on Proof of Concept, I have a restriction on type <b>a</b> so that it can be serialized (an instance of the <b>ToJSON / FromJSON class</b> from the <a href="https://hackage.haskell.org/package/aeson-1.2.4.0/docs/Data-Aeson.html">aeson</a> library).  The fact is that I will need to keep these different types of TVars in a map, but I do not want to bother with <i>Typeable / Dynamic</i> or, especially, with <i>HLists</i> .  In real STM type <b>a</b> can be absolutely any, even functions.  I will also deal with this issue sometime later. </blockquote>  And what is this <b>next</b> field?  Here we step on the demand from the Free-monad.  She needs to store somewhere the continuation of the current method, and just the <b>next</b> field does not suit her, - ADT should be a functor on this field.  So, the <b>NewTVar</b> method should return <b>TVar a</b> , and we see that the continuation <b>(TVar a -&gt; next)</b> is just waiting for our new input variable.  On the other hand, <b>WriteTVar</b> does not return anything useful, so the continuation is of type <b>next</b> , that is, it does not expect anything to enter.  Making a type <b>STMF is</b> easy: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap g (<span class="hljs-type"><span class="hljs-type">NewTVar</span></span> a nextF) = <span class="hljs-type"><span class="hljs-type">NewTVar</span></span> a (g . nextF) fmap g (<span class="hljs-type"><span class="hljs-type">WriteTVar</span></span> tvar a next ) = <span class="hljs-type"><span class="hljs-type">WriteTVar</span></span> tvar a (g next) fmap g (<span class="hljs-type"><span class="hljs-type">ReadTVar</span></span> tvar nextF) = <span class="hljs-type"><span class="hljs-type">ReadTVar</span></span> tvar (g . nextF)</code> </pre> <br>  The more interesting question is, where is our custom monad for STM?  Here she is: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STML</span></span></span><span class="hljs-class"> next = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next</span></span></code> </pre> <br>  We wrapped the <b>STMF</b> type into the <b>Free</b> type, and with it came all the monadic properties we needed.  It remains only to create a series of convenient monadic functions on top of our bare <b>STMF</b> methods: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">newTVar</span></span> :: <span class="hljs-type"><span class="hljs-type">ToJSON</span></span> a =&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">STML</span></span> (<span class="hljs-type"><span class="hljs-type">TVar</span></span> a) newTVar a = liftF (<span class="hljs-type"><span class="hljs-type">NewTVar</span></span> a id) writeTVar :: <span class="hljs-type"><span class="hljs-type">ToJSON</span></span> a =&gt; <span class="hljs-type"><span class="hljs-type">TVar</span></span> a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">STML</span></span> () writeTVar tvar a = liftF (<span class="hljs-type"><span class="hljs-type">WriteTVar</span></span> tvar a ()) readTVar :: <span class="hljs-type"><span class="hljs-type">FromJSON</span></span> a =&gt; <span class="hljs-type"><span class="hljs-type">TVar</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">STML</span></span> a readTVar tvar = liftF (<span class="hljs-type"><span class="hljs-type">ReadTVar</span></span> tvar id)</code> </pre> <br>  As a result, we can already operate with a transactional model in the form of TVars.  In fact, you can take an example with the dining philosophers and simply replace <b>STM</b> with <b>STML</b> : <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ForkState</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Taken</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVar</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ForkState</span></span></span><span class="hljs-class"> takeFork :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TFork</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STML</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bool</span></span></span><span class="hljs-class"> takeFork tFork = do forkState &lt;- readTVar tFork when (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forkState</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class">) (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">writeTVar</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">tFork</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Taken</span></span></span><span class="hljs-class">) pure (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">forkState</span></span></span><span class="hljs-class"> == </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br>  Easy win!  But there are things that we have missed.  For example, the method for terminating computation <b>retry</b> .  It is easy to add: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Retry</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> next instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STMF</span></span></span><span class="hljs-class"> where fmap g </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Retry</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Retry</span></span></span><span class="hljs-class"> retry :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">STML</span></span></span><span class="hljs-class"> () retry = liftF </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Retry</span></span></span></span></code> </pre> <br>  There are some minor differences in my library from the older sister;  in particular, the method of <b>retry</b> here returns <b>Unit</b> , although it must return an arbitrary type <b>a</b> .  This is not a fundamental limitation, but an artifact of rapid development of PoC, and in the future I will fix it.  Nevertheless, even this code will remain without alterations except for replacing the monad itself: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">takeForks</span></span> :: (<span class="hljs-type"><span class="hljs-type">TFork</span></span>, <span class="hljs-type"><span class="hljs-type">TFork</span></span>) -&gt; <span class="hljs-type"><span class="hljs-type">STML</span></span> () takeForks (tLeftFork, tRightFork) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> leftTaken &lt;- takeFork tLeftFork rightTaken &lt;- takeFork tRightFork when (not leftTaken || not rightTaken) retry</code> </pre> <br>  Monadic eDSL is most similar to the basic implementation, but the launch of STML scripts is different.  My <b>atomically atomizer</b> , unlike the base implementation, takes an additional argument ‚Äî the context in which the calculation will run. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">atomically</span></span> :: <span class="hljs-type"><span class="hljs-type">Context</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">STML</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> a</code> </pre> <br>  In context, user data is stored in the form of TVar, so you can have several different contexts.  This can be useful, for example, to separate transactional models ‚Äî so that they do not affect each other.  For example, in one model, a huge amount of user data is created, while in another model, the TVar set does not change at all.  Then it makes sense to separate contexts so that the second model does not have any problems due to the ‚Äúswelling‚Äù neighbor when performing.  In the base implementation, the context is global, and I don‚Äôt really know how to get around this. <br><br>  The philosophers launch code now looks like this: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">philosoperWorker</span></span> :: <span class="hljs-type"><span class="hljs-type">Context</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Philosopher</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> () philosoperWorker ctx philosopher = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> atomically ctx (changePhilosopherActivity philosopher) threadDelay <span class="hljs-number"><span class="hljs-number">5000</span></span> philosoperWorker ctx philosopher runPhilosophers :: <span class="hljs-type"><span class="hljs-type">IO</span></span> () runPhilosophers = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> ctx &lt;- newContext <span class="hljs-comment"><span class="hljs-comment">--  . tState1 &lt;- newTVarIO ctx Thinking tState2 &lt;- newTVarIO ctx Thinking tFork1 &lt;- newTVarIO ctx Free tFork2 &lt;- newTVarIO ctx Free forkIO (philosoperWorker ctx (Philosopher tState1 tFork1 tFork2)) forkIO (philosoperWorker ctx (Philosopher tState2 tFork2 tFork1)) threadDelay 100000</span></span></code> </pre> <br><h3>  Little about interpretation </h3><br>  What happens when we run the script <b>atomically</b> ?  The interpretation of the scenario relative to the real environment begins.  It is at this point that TVars begin to form and change, interrupt conditions are checked, and it is inside the <b>atomically that the</b> transaction will either be fixed in the passed context, or be rolled out and restarted.  The algorithm is as follows: <br><br><ol><li>  Get a unique transaction ID. </li><li>  Atomic remove a local copy from the current context.  This is where a short context lock occurs; this is done using MVar, which acts like a normal mutex. </li><li>  Run the interpretation of the script with a local copy, wait for the result. </li><li>  If the command to restart the calculation is received, put the stream to sleep for a while and go to step 1. </li><li>  If the result is obtained, atomically check for conflicts between the local copy and the context. </li><li>  If conflicts are found, put the stream to sleep for a while and go to step 1. </li><li>  If there is no conflict, everything will also atomically hold the local copy into context. </li><li>  The end. </li></ol><br>  The context may change as long as the given calculation does something with its local copy.  Conflict arises when at least one TVar changed, involved in this calculation.  This will be seen by a unique identifier stored in each instance.  But if the calculation did not use TVar, there will be no conflict. <br><br>  Let our real environment be expressed by a certain <b>Atomic</b> monad, which is a stack of State and IO monads.  The status is a local copy of all TVar: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AtomicRuntime</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AtomicRuntime</span></span></span><span class="hljs-class"> { </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ustamp</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">UStamp</span></span></span><span class="hljs-class"> , </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">localTVars</span></span></span><span class="hljs-class"> :: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TVars</span></span></span><span class="hljs-class"> } </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Atomic</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">StateT</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AtomicRuntime</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">IO</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br>  Inside this monad we will unwind and interpret two mutually nested structures: the <b>STML</b> type, which, as we remember, is built using the <b>Free</b> type, and the <b>STMF</b> type.  The <b>Free</b> type is a little brainwave, since it is recursive.  He has two options: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> fa = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pure</span></span></span><span class="hljs-class"> a | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">f</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Free</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fa</span></span></span><span class="hljs-class">))</span></span></code> </pre> <br>  Interpretation is done by simple pattern-matching.  The interpreter returns either the value of the entire transaction, or a command to restart it. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">interpretStmf</span></span> :: <span class="hljs-type"><span class="hljs-type">STMF</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Atomic</span></span> (<span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">RetryCmd</span></span> a) interpretStmf (<span class="hljs-type"><span class="hljs-type">NewTVar</span></span> a nextF) = <span class="hljs-type"><span class="hljs-type">Right</span></span> . nextF &lt;$&gt; newTVar' a interpretStmf (<span class="hljs-type"><span class="hljs-type">ReadTVar</span></span> tvar nextF) = <span class="hljs-type"><span class="hljs-type">Right</span></span> . nextF &lt;$&gt; readTVar' tvar interpretStmf (<span class="hljs-type"><span class="hljs-type">WriteTVar</span></span> tvar a next) = const (<span class="hljs-type"><span class="hljs-type">Right</span></span> next) &lt;$&gt; writeTVar' tvar a interpretStmf <span class="hljs-type"><span class="hljs-type">Retry</span></span> = pure $ <span class="hljs-type"><span class="hljs-type">Left</span></span> <span class="hljs-type"><span class="hljs-type">RetryCmd</span></span> interpretStml :: <span class="hljs-type"><span class="hljs-type">STML</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Atomic</span></span> (<span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">RetryCmd</span></span> a) interpretStml (<span class="hljs-type"><span class="hljs-type">Pure</span></span> a) = pure $ <span class="hljs-type"><span class="hljs-type">Right</span></span> a interpretStml (<span class="hljs-type"><span class="hljs-type">Free</span></span> f) = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> eRes &lt;- interpretStmf f <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eRes <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Left</span></span> <span class="hljs-type"><span class="hljs-type">RetryCmd</span></span> -&gt; pure $ <span class="hljs-type"><span class="hljs-type">Left</span></span> <span class="hljs-type"><span class="hljs-type">RetryCmd</span></span> <span class="hljs-type"><span class="hljs-type">Right</span></span> res -&gt; interpretStml res runSTML :: <span class="hljs-type"><span class="hljs-type">STML</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Atomic</span></span> (<span class="hljs-type"><span class="hljs-type">Either</span></span> <span class="hljs-type"><span class="hljs-type">RetryCmd</span></span> a) runSTML = interpretStml</code> </pre><br>  The functions <b>newTVar ', readTVar', writeTvar '</b> work with a local copy of the transaction variables, and can change them freely.  The <b>runSTML</b> call is made from another function, <b>runSTM</b> , which checks for locally modified TVars for conflicts with the global copy from the context, and decides whether to restart the transaction. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">runSTM</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Context</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">STML</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">IO</span></span> a runSTM delay ctx stml = <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> (ustamp, snapshot) &lt;- takeSnapshot ctx (eRes, <span class="hljs-type"><span class="hljs-type">AtomicRuntime</span></span> _ stagedTVars) &lt;- runStateT (runSTML stml) (<span class="hljs-type"><span class="hljs-type">AtomicRuntime</span></span> ustamp snapshot) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> eRes <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-type"><span class="hljs-type">Left</span></span> <span class="hljs-type"><span class="hljs-type">RetryCmd</span></span> -&gt; runSTM (delay * <span class="hljs-number"><span class="hljs-number">2</span></span>) ctx stml <span class="hljs-type"><span class="hljs-type">Right</span></span> res -&gt; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> success &lt;- tryCommit ctx ustamp stagedTVars <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> success <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> return res <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> runSTM (delay * <span class="hljs-number"><span class="hljs-number">2</span></span>) ctx stml</code> </pre> <br>  I will leave this function without explanation, and I will not <b>dive</b> into the details of how the <b>tryCommit</b> function is <b>implemented</b> .  Not very optimal, to be honest, but this is a topic for a separate article. <br><br><h3>  Conclusion </h3><br>  In my implementation there are a number of subtle points that I still need to realize.  There may still be unobvious bugs, and more cases need to be checked ‚Äúfor adequacy of behavior‚Äù, but it‚Äôs not clear what is considered adequate STM behavior.  But at least, I didn‚Äôt reveal any external differences on the task of the dining philosophers, which means that the idea works, and it can be brought to mind.  In particular, you can greatly optimize runtime, make smarter conflict resolution and make a local copy more intelligent.  The approach with interpretation and Free-monad is quite flexible, and the code, as you can see, is much smaller, and in general it is very straightforward.  And this is good, because it opens another way for the implementation of STM in other languages. <br><br>  For example, now I port Free-monad STM in C ++, which is associated with my own unique difficulties for this language.  As a result of the work, I will give a talk at the April <a href="http://cppconf.ru/">C ++ Russia 2018</a> conference, and if anyone is going to visit it, then we can discuss this topic in more detail. </div><p>Source: <a href="https://habr.com/ru/post/350628/">https://habr.com/ru/post/350628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350618/index.html">Hackaton MentorHack: Inside out</a></li>
<li><a href="../350620/index.html">Change of profession: from graphic designer to front-end developer</a></li>
<li><a href="../350622/index.html">Eternally Open Sesame, or Several Loopholes in Your IT Landscape</a></li>
<li><a href="../350624/index.html">Neural network that determines the age of the blood test - the development of scientists of the ITMO University</a></li>
<li><a href="../350626/index.html">Flask Mega-Tutorial, Part XIV: Ajax</a></li>
<li><a href="../350630/index.html">Unleash the game code using the Command pattern, and debugging while flying on the time machine</a></li>
<li><a href="../350632/index.html">Security Week 7: Dating through a coder and spam updates</a></li>
<li><a href="../350636/index.html">Cooking Juniper Network with Ansible</a></li>
<li><a href="../350638/index.html">Hardcore Java / JVM puzzles</a></li>
<li><a href="../350640/index.html">Bathroom mosaic and Diophantine equations</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>