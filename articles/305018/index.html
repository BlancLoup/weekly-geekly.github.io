<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Functors (chapter of the book "Category Theory for Programmers")</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the seventh article from the series "Theory of Categories for Programmers." Previous articles have already been published on Habr√©: 


- Categ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Functors (chapter of the book "Category Theory for Programmers")</h1><div class="post__text post__text-html js-mediator-article"><p>  <i>This is the seventh article from the series "Theory of Categories for Programmers."</i>  <i>Previous articles have already been published on Habr√©:</i> </p><br><ul><li>  <a href="https://habrahabr.ru/post/245797/">Category Theory for Programmers: Preface</a> </li><li>  <a href="https://habrahabr.ru/post/246009/">Category: essence of composition</a> </li><li>  <a href="https://habrahabr.ru/post/247765/">Types and functions</a> </li><li>  <a href="https://habrahabr.ru/post/248257/">Categories big and small</a> </li><li>  <a href="https://habrahabr.ru/post/249113/">Categories</a> </li><li>  <a href="https://habrahabr.ru/post/271927/">Works and Copies</a> </li><li>  <a href="https://habrahabr.ru/post/274103/">Simple algebraic data types</a> </li></ul><br><h4>  Functors </h4><br><p>  There is a very simple but powerful idea behind the notion of a functor (no matter how bad it sounds).  Just the theory of categories is full of simple and powerful ideas.  A functor is a mapping between categories.  Let two categories C and D be given, and the functor F maps objects from C to objects from D ‚Äî this is a function above the objects.  If <em>a</em> is an object from C, then we will denote its image from D as <em>F a</em> (without parentheses).  But a category is not only objects, but also morphisms connecting them.  The functor also displays morphisms - this is a function over morphisms.  But morphisms are not displayed as horrible, but in order to maintain connections.  Namely, if the morphism <em>f</em> of C binds the object <em>a</em> with the object <em>b</em> , </p><br><pre><code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: a -&gt; b</code> </pre> <br><p>  then the image of <em>f</em> in D, <em>F f</em> , connects the image of <em>a</em> with the image of <em>b</em> : </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">F</span></span> f :: <span class="hljs-type"><span class="hljs-type">F</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">F</span></span> b</code> </pre> <br><p>  (We hope that such a mixture of mathematical notation and Haskell syntax is understandable to the reader. We will not write brackets when applying functors to objects or morphisms.) </p><br><img src="https://habrastorage.org/files/441/189/bfa/441189bfab3d46a3943f7a4a41b2882c.jpg"><a name="habracut"></a><br><p>  As you can see, the functor preserves the structure: what was connected in the input category will be connected in the output.  But this structure is not exhausted: it is also necessary to support the composition of morphisms.  If <code>h</code> is a composition of <code>f</code> and <code>g</code> : </p><br><p>  then we require that its image under the action of F be the composition of the images of <em>f</em> and <em>g</em> : </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">F</span></span> h = <span class="hljs-type"><span class="hljs-type">F</span></span> g . <span class="hljs-type"><span class="hljs-type">F</span></span> f</code> </pre> <br><img src="https://habrastorage.org/files/d64/047/df8/d64047df852549c98a655bf58c48c034.jpg"><br><p>  Finally, we require that all single (identical) morphisms from C be mapped to single morphisms from D: </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">F</span></span> id(a) = id(<span class="hljs-type"><span class="hljs-type">F</span></span> a)</code> </pre> <br><p>  Here <em>id <sub>a</sub></em> is the unit morphism of object <em>a</em> , and <em>id <sub>F a</sub></em> is the unit morphism of object <em>F a</em> . </p><br><img src="https://habrastorage.org/files/b38/112/1a2/b381121a2c8f44958972efbba6029c05.jpg"><br><p>  Note that all these conditions significantly limit the range of functions suitable as morphisms.  Functors must preserve the structure of a category.  If we imagine a category as a set of objects intertwined with morphisms, then the functor has no right to tear off any thread of this lace.  It can combine several objects, it can glue morphisms into one, but it never breaks ties.  This limitation is analogous to the concept of continuity from mathematical analysis.  In this sense, functors are "continuous" (although there is an even more restrictive definition of the continuity of functors).  Like any function, a functor can be both gluing and nesting.  The nesting aspect is most pronounced when the source category is much smaller than the target.  In the limiting case, the initial category is a category <strong>1</strong> , consisting of one object and one (single) morphism.  A functor from category <strong>1</strong> to any other category simply selects a particular object from this category.  There is a complete analogy with singleton morphisms that select elements from target sets.  The gluing aspect, reduced to the point of absurdity, is observed in the constant functor Œî <sub>c</sub> .  It maps each object of the source category to a specific object <em>c of the</em> target category, and any morphism into a single morphism <em>id <sub>c</sub></em> .  It's like a black hole sucking everything at a singularity point.  We will return to the consideration of this functor when discussing limits and values. </p><br><h5>  Functors in programming </h5><br><p>  Let's go back to earth, to the world of programming.  So, we have a category of types and functions.  Consider functors that map this category into themselves ‚Äî the so-called endofunctors.  What is the endofunctor in the type category?  First of all, it compares one type with another.  Such mappings are in fact familiar to us; they are types that are parameterized by other types.  Consider a few examples. </p><br><h5>  Maybe Functor </h5><br><p>  The definition of Maybe is a mapping of type <code>a</code> to type <code>Maybe</code> a: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Just</span></span></span><span class="hljs-class"> a</span></span></code> </pre> <br><p>  An important detail: <code>Maybe</code> by itself is not a type, but <em>a type constructor</em> .  It takes a type, such as <code>Int</code> or <code>Bool</code> , as an argument, and returns a different type.  <code>Maybe</code> without arguments is a function on types.  But is <code>Maybe</code> functor?  (Hereinafter, speaking of functors in the context of programming, endofunctors are almost always meant.) After all, a functor is not only a representation of objects (here, types), but also a display of morphisms (here, functions).  For any function from <code>a</code> to <code>b</code> </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f</span></span> :: a -&gt; b</code> </pre> <br><p>  I would like to get a function from <code>Maybe a</code> to <code>Maybe b</code> .  To determine such a function, you need to consider two cases corresponding to the two <code>Maybe</code> constructors.  In the case of <code>Nothing</code> we simply return <code>Nothing</code> back.  If the argument is <code>Just</code> , then apply the function <code>f</code> to its contents.  So, the image of <code>f</code> under the action of <code>Maybe</code> is a function </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">f'</span></span> :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> b f' <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> f' (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (fx)</code> </pre> <br><p>  (By the way, in Haskell it is allowed to use apostrophes in variable names, which is very convenient in such cases.) In Haskell, the appearance of a functor responsible for the display of morphisms is implemented by a higher-order <code>fmap</code> .  For <code>Maybe</code> it has the following signature: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> b)</code> </pre> <br><img src="https://habrastorage.org/files/139/f3e/9ae/139f3e9aed5e4740a952f019997d88f9.jpg"><br><p>  It is often said that <code>fmap</code> <em>elevates</em> (lifts) the function.  Sublime function works on <code>Maybe</code> values.  As usual, due to currying, this signature can be interpreted in two ways: either as a function of one variable, which is itself a function <code>(a-&gt;b)</code> , which returns a function <code>(Maybe a -&gt; Maybe b)</code> , or as a function of two variables, which returns <code>Maybe b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> b</code> </pre> <br><p>  Following the above, we give the definition of <code>fmap</code> for <code>Maybe</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> _ <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> fmap f (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (fx)</code> </pre> <br><p>  To show that the <code>Maybe</code> type constructor together with the function <code>fmap</code> make up the functor, it remains to prove that <code>fmap</code> preserves single morphisms and composition.  These statements are called "functorial laws", but they simply certify the preservation of the structure of the category. </p><br><h5>  Equivalent Transformation Method </h5><br><p>  We prove functorial laws <em>by the method of equivalent transformations</em> , which is a typical technique of proofs in Haskell.  The method relies on the fact that functions in Haskell are defined by a set of equalities: the left side is equal to the right, both of them can be substituted for each other (it is possible that you need to rename variables during substitution to avoid conflicts).  You can either substitute the body of the function instead of calling it (inline), or calling the function instead of its body (refactoring).  Consider as an example the identical function: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">id</span></span> x = x</code> </pre> <br><p>  If we meet somewhere, say <code>id y</code> , then it can always be replaced by <code>y</code> (inline).  In general, any occurrence of <code>id</code> applied to an expression, for example, <code>id (y + 2)</code> , can be replaced by the expression itself <code>(y + 2)</code> .  In the opposite direction: any expression <code>e</code> can be replaced by <code>id e</code> (refactoring).  In the case of functions defined by pattern matching, each definition can be used independently.  For example, according to the above definition of <code>fmap</code> you can replace <code>fmap f Nothing</code> with <code>Nothing</code> or vice versa.  Consider this approach in practice.  Let's start with the preservation of identity: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> id = id</code> </pre> <br><p>  Two cases should be considered: <code>Nothing</code> and <code>Just</code> .  Let's start with <code>Nothing</code> (I describe the transformation of the left side of the equality to the right side using pseudo-Haskell): </p><br><pre> <code class="haskell hljs"> fmap id <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = {   fmap } <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = {   id } id <span class="hljs-type"><span class="hljs-type">Nothing</span></span></code> </pre> <br><p>  Notice that in the second step we substituted <code>id Nothing</code> instead of <code>Nothing</code> , using the <code>id</code> definition in the opposite direction.  In practice, such proofs are made by the method of ‚Äúigniting the wick from two ends,‚Äù up to a meeting in the middle on the same expression, <code>Nothing</code> in this case.  The second case is also simple: </p><br><pre> <code class="haskell hljs"> fmap id (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) = {   fmap } <span class="hljs-type"><span class="hljs-type">Just</span></span> (id x) = {   id } <span class="hljs-type"><span class="hljs-type">Just</span></span> x = {   id } id (<span class="hljs-type"><span class="hljs-type">Just</span></span> x)</code> </pre> <br><p>  Now we will show that <code>fmap</code> saves the composition: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> (g . f) = fmap g . fmap f</code> </pre> <br><p>  Let's start with the case of <code>Nothing</code> : </p><br><pre> <code class="haskell hljs"> fmap (g . f) <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = {   fmap } <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = {   fmap } fmap g <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = {   fmap } fmap g (fmap f <span class="hljs-type"><span class="hljs-type">Nothing</span></span>)</code> </pre> <br><p>  Now it's time to <code>Just</code> : </p><br><pre> <code class="haskell hljs"> fmap (g . f) (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) = {   fmap } <span class="hljs-type"><span class="hljs-type">Just</span></span> ((g . f) x) = {    } <span class="hljs-type"><span class="hljs-type">Just</span></span> (g (fx)) = {   fmap } fmap g (<span class="hljs-type"><span class="hljs-type">Just</span></span> (fx)) = {   fmap } fmap g (fmap f (<span class="hljs-type"><span class="hljs-type">Just</span></span> x)) = {    } (fmap g . fmap f) (<span class="hljs-type"><span class="hljs-type">Just</span></span> x)</code> </pre> <br><p>  It is worth emphasizing that for functions with side effects in the C ++ style, the equivalent transformation method does not work.  Consider an example: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">square</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * x; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">counter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c++; } <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y = square(counter());</code> </pre> <br><p>  The equivalent transformation method would allow <code>square</code> to be expanded and get </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y = counter() * counter();</code> </pre> <br><p>  Definitely, such a transformation is incorrect and changes the result of the expression.  Despite this, if you define <code>square</code> as a macro, the C ++ preprocessor will use the equivalent transformation method with a catastrophic result. </p><br><h5>  Maybe again </h5><br><p>  Functors are easily expressed in Haskell, but they can be described in any language that supports generic programming and higher-order functions.  Consider the C ++ analogue Maybe, the template type is <code>optional</code> .  Here is a sketch of the implementation (the full implementation is much more complicated, since it explicitly describes different ways of passing arguments, copying semantics and other issues specific to C ++ resource management): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> _isValid; <span class="hljs-comment"><span class="hljs-comment">// the tag T _v; public: optional() : _isValid(false) {} // Nothing optional(T x) : _isValid(true) , _v(x) {} // Just bool isValid() const { return _isValid; } T val() const { return _v; } };</span></span></code> </pre> <br><p>  The above pattern provides half the functor description: a type mapping.  It maps the new type <code>optional&lt;T&gt;</code> each type <code>T</code>  Now we describe its action on the functions: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:function&lt;optional&lt;B&gt;(optional&lt;A&gt;)&gt; fmap(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;B(A)&gt; f) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [f](optional&lt;A&gt; opt) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!opt.isValid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> optional&lt;B&gt;{}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> optional&lt;B&gt;{ f(opt.val()) }; }; }</code> </pre> <br><p>  This is a higher order function that takes a function as an argument and returns a function.  And here is another option, without currying: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class">&lt;B&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:function&lt;B(A)&gt; f, optional&lt;A&gt; opt) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!opt.isValid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> optional&lt;B&gt;{}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> optional&lt;B&gt;{ f(opt.val()) }; }</code> </pre> <br><p>  On the other hand, <code>fmap</code> can be implemented as the <code>optional</code> template method.  Such ambiguity in the choice makes the abstraction of the pattern "functor" in C ++ a problem.  Should the functor be an interface in order to be inherited from it (unfortunately, the template functions cannot be virtual)?  Or maybe a free template function, curried or not?  Can the C ++ compiler correctly infer the missing types, or should they be specified explicitly?  Imagine that the input function <code>f</code> converts an <code>int</code> into a <code>bool</code> .  How the compiler will determine the <code>g</code> type: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> g = fmap(f);</code> </pre> <br><p>  especially if in the future there will be a lot of functors with their versions of <code>fmap</code> ?  (We will get acquainted with other kinds of functors soon.) </p><br><h5>  Type Classes </h5><br><p>  How is the functor abstraction implemented in Haskell?  The type class mechanism is used.  A type class defines a family of types that support a single interface.  For example, the class of objects comparable to equality is defined as: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (==) :: a -&gt; a -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Here it is stated that type <code>a</code> belongs to class Eq if it supports the operator <code>(==)</code> , which takes two arguments of type <code>a</code> and returns <code>Bool</code> .  To convince Haskell that a particular type belongs to <code>Eq</code> , you need to declare it an <em>instance</em> (instance, implementation) of a class, and provide an implementation <code>(==)</code> .  For example, having the following definition of a point on a plane (type-product of two <code>Float</code> ): </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Pt</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Float</span></span></span></span></code> </pre> <br><p>  You can determine the equality of points: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Point</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> (<span class="hljs-type"><span class="hljs-type">Pt</span></span> xy) == (<span class="hljs-type"><span class="hljs-type">Pt</span></span> x' y') = x == x' &amp;&amp; y == y'</code> </pre> <br><p>  Here the defined operator <code>(==)</code> is located infixno, between two samples <code>(Pt xy)</code> and <code>(Pt x' y')</code> .  The body of the function is placed to the right of the <code>=</code> sign.  After <code>Point</code> declared as an instance of <code>Eq</code> , you can directly compare points for equality.  Note that, unlike C ++ or Java, you are not required to provide a class or even an <code>Eq</code> interface at the time the <code>Point</code> defined ‚Äî this can be done later.  Note that type classes are the only mechanism for overloading functions (and operators) in Haskell.  We will need it to overload <code>fmap</code> for different functors.  There is one subtlety: a functor is defined not as a type, but as a function over types, a type constructor.  Our type class should describe a family of type constructors, not just types, as was the case with <code>Eq</code> .  Fortunately, the Haskell type class mechanism works with type constructors as well as with simple types ( <em>PP: a good example of following a functional paradigm ‚Äî even in the world of function types is no worse than objects</em> ).  The following is the definition of the <code>Functor</code> class: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> f </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br><p>  It states that <code>f</code> is a Functor if there is a function <code>fmap</code> with this signature.  Here <code>f</code> - t <em>and new</em> variable are of the same kind as m <em>and new</em> variables <code>a</code> and <code>b</code> .  But the compiler is able to understand that <code>f</code> is a type constructor, tracking its use: applying to other types, here <code>fa</code> and <code>fb</code> .  Accordingly, it is the type constructor that we declare as an instance of the functor, as in the case of Maybe: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap _ <span class="hljs-type"><span class="hljs-type">Nothing</span></span> = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> fmap f (<span class="hljs-type"><span class="hljs-type">Just</span></span> x) = <span class="hljs-type"><span class="hljs-type">Just</span></span> (fx)</code> </pre> <br><p>  I note that the class <code>Functor</code> , as well as declarations of many commonly used types, including <code>Maybe</code> its instances, are included in the standard Prelude library. </p><br><h5>  Functors in C ++ </h5><br><p>  Can we apply the same approach in C ++?  The type constructor corresponds to a template class, such as <code>optional</code> , respectively, we need to parameterize <code>fmap</code> <em>twice with the template</em> parameter <code>F</code>  This is written like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">F</span></span></span><span class="hljs-class">&lt;B&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:function&lt;B(A)&gt;, F&lt;A&gt;);</code> </pre> <br><p>  But how do we specialize this template for different functors?  Unfortunately, partial specialization of C ++ template functions is prohibited.  You can not write: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class">&lt;B&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class">&lt;optional&gt;(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:function&lt;B(A)&gt; f, optional&lt;A&gt; opt)</code> </pre> <br><p>  Instead, we have to return to overloading the functions, as a result we return to the original definition of <code>fmap</code> (without currying): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">optional</span></span></span><span class="hljs-class">&lt;B&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:function&lt;B(A)&gt; f, optional&lt;A&gt; opt) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!opt.isValid()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> optional&lt;B&gt;{}; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> optional&lt;B&gt;{ f(opt.val()) }; }</code> </pre> <br><p>  This definition works, but a second argument is required for proper overload.  The more general definition of <code>fmap</code> simply ignored. </p><br><h5>  List functor </h5><br><p>  For a better understanding of the importance of functors in programming, more examples are worth considering.  Any type that is parameterized by another type is a candidate for the role of a functor.  For example, generic containers are parameterized by the type of their elements, consider a list, a very simple container: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nil</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Cons</span></span></span><span class="hljs-class"> a (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre> <br><p>  Here we have a <code>List</code> type constructor representing a mapping of any type <code>a</code> to type <code>List a</code> .  To show that <code>List</code> is a functor, we need to define the lifting of functions along the functor.  For a given function <code>a-&gt;b</code> we define <code>List a -&gt; List b</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; (<span class="hljs-type"><span class="hljs-type">List</span></span> a -&gt; <span class="hljs-type"><span class="hljs-type">List</span></span> b)</code> </pre> <br><p>  The function acting on the <code>List</code> should consider two cases, according to the two list constructors.  The case of <code>Nil</code> is trivial, - and <code>Nil</code> is returned, you cannot squeeze much from the empty list.  <code>Cons</code> trickier because it affects recursion.  Let's think: so, we have a list <code>a</code> , a function <code>f</code> turns <code>a</code> into <code>b</code> , and we want to get a list <code>b</code> .  Obviously, you need to use <code>f</code> to convert each list item from <code>a</code> to <code>b</code> .  What exactly needs to be done if our (non-empty) list is defined as <code>Cons</code> head and tail?  Apply <code>f</code> to the head and apply the raised (fmap) <code>f</code> to the tail.  This definition is recursive, we define raised <code>f</code> through raised <code>f</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> f (<span class="hljs-type"><span class="hljs-type">Cons</span></span> xt) = <span class="hljs-type"><span class="hljs-type">Cons</span></span> (fx) (fmap ft)</code> </pre> <br><p>  It is important that on the right side <code>fmap f</code> is applied to the list shorter than what we define - namely, to the tail of the latter.  We apply recursion to increasingly shorter lists, so we inevitably arrive at an empty list, or <code>Nil</code> .  But as we have already defined, <code>fmap f</code> from <code>Nil</code> gives <code>Nil</code> , thus completing the recursion.  The final result is obtained by combining a new head ( <code>fx</code> ) with a new tail ( <code>fmap ft</code> ) using the Cons constructor.  As a result, here‚Äôs our declaration of the list as an instance of a functor completely: </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap _ <span class="hljs-type"><span class="hljs-type">Nil</span></span> = <span class="hljs-type"><span class="hljs-type">Nil</span></span> fmap f (<span class="hljs-type"><span class="hljs-type">Cons</span></span> xt) = <span class="hljs-type"><span class="hljs-type">Cons</span></span> (fx) (fmap ft)</code> </pre> <br><p>  If you are used to C ++, it makes sense to consider <code>std::vector</code> , in fact, the basic C ++ container.  The <code>fmap</code> implementation for <code>std::vector</code> is just a wrapper around <code>std::transform</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;B&gt; fmap(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;B(A)&gt; f, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;A&gt; v) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;B&gt; w; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(v) , <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(v) , <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter(w) , f); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> w; }</code> </pre> <br><p>  With its help, we can, for example, square a row of numbers: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v{ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> w = fmap([](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> i*i; }, v); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::copy( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(w) , <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(w) , <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream_iterator(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-string"><span class="hljs-string">", "</span></span>));</code> </pre> <br><p>  Most C ++ containers are essentially functors.  This is ensured by the presence of iterators that can be passed to <code>std::transform</code> , to a primitive relative of <code>fmap</code> .  Unfortunately, the simplicity of the functor is lost under the rubbish of iterators and temporal variables (as in the <code>fmap</code> implementation above).  From the good news, the planned (planned) for inclusion in C ++ library of intervals (ranges) significantly reveals them, intervals, functional nature. </p><br><h5>  Reader functor </h5><br><p>  Now that we have developed some kind of intuition, in particular that functors are containers of a kind, here is an example that looks completely different at first glance.  Consider a mapping of type <code>a</code> onto the type of functions returning <code>a</code> .  We have not yet reached the discussion of functional types at the proper category-theoretic level, but we, as programmers, have a certain understanding of them.  In Haskell, functional types are constructed using a type constructor ‚Äî an arrow <code>(-&gt;)</code> , which takes two types: the type of the argument and the type of the result.  You have already met it in the infix notation, <code>a-&gt;b</code> , but with the help of parentheses, you can use the prefix notation just as well: </p><br><pre> <code class="haskell hljs">(-&gt;) ab</code> </pre> <br><p>  As well as usual functions, m <em>and new</em> functions of several arguments can be applied partially.  And when we give the arrow one argument, it is still waiting for another.  I.e, </p><br><pre> <code class="haskell hljs">(-&gt;) a</code> </pre> <br><p>  is a type constructor;  we need another type <code>b</code> to make a full type <code>a-&gt;b</code> .  Thus, the arrow defines a whole family of type constructors parameterized <code>a</code> .  Let's find out if it is also a family of functors.  Not to confuse the two parameters, rename them, emphasizing the role.  In accordance with our previous definitions of functors, the type of the argument is called <code>r</code> , and the type of the result is <code>a</code> .  So, our constructor takes any type <code>a</code> , and maps it to type <code>r-&gt;a</code> .  To justify functoriality, we need to raise the function <code>a-&gt;b</code> to a function that accepts <code>r-&gt;a</code> and returns <code>r-&gt;b</code> .  These are the types created by the constructor action <code>(-&gt;) r</code> on <code>a</code> and <code>b</code> respectively.  This is the signature of <code>fmap</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code> </pre> <br><p>  We get a kind of puzzle: having functions <code>f::a-&gt;b</code> and functions <code>g::r-&gt;a</code> , create <code>r-&gt;b</code> .  There is only one way to compose them, and the result is just what we need.    <code>fmap</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> ((-&gt;) r) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap fg = f . g</code> </pre> <br><p>  It worked!     ,   : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> fg = (.) fg</code> </pre> <br><p>    ,    : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> = (.)</code> </pre> <br><p>    <code>(-&gt;) r</code>    <code>fmap</code>  "reader". </p><br><h5>    </h5><br><p>             ,    ,  -   ,   .  reader  ,         .    ,    ,       .    .   ,  Haskell ,          . , ,     ,    : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">nats</span></span> :: [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] nats = [<span class="hljs-number"><span class="hljs-number">1.</span></span>.]</code> </pre> <br><p>      , ‚Äî   <em></em>   Haskell  .         . ,       .     ,   <code>Integer</code> -  . Haskell       :    ,     ,   .    ,  ,    ,    .    <code>strlen</code>       ,     .     ,         .      ,    ,  ,   ,     !        (     )      ( ),       .    C++, ‚Äî <code>std::future</code> ,   -   ,  ;      , ,    ,     .     <code>IO</code>  Haskell,     ,       ‚ÄúHello World!‚Äù   .   ,   ,       ,   .      .   ,       , ‚Äî       .    , ‚Äî       .    , ‚Äî        ,  ,   ,    ,        .   ,         ,   ,      <code>a</code> : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Const</span></span></span><span class="hljs-class"> ca = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Const</span></span></span><span class="hljs-class"> c</span></span></code> </pre> <br><p>  <em></em>   <code>Const</code>   , <code>c</code>  <code>a</code> .   ,     ,  ,       <code>(-&gt;)</code> . </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; <span class="hljs-type"><span class="hljs-type">Const</span></span> ca -&gt; <span class="hljs-type"><span class="hljs-type">Const</span></span> cb</code> </pre> <br><p>       <em></em>  ,     <code>fmap</code>   , ‚Äî     : </p><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Functor</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">c</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> fmap _ (<span class="hljs-type"><span class="hljs-type">Const</span></span> v) = <span class="hljs-type"><span class="hljs-type">Const</span></span> v</code> </pre> <br><p>  C++     (   ,   !),        <em></em>  ,     ,  ,    . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Const</span></span></span><span class="hljs-class"> {</span></span> Const(C v) : _v(v) {} C _v; };</code> </pre> <br><p> C++ - <code>fmap</code>    ,      <code>Const</code> ,   . </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Const</span></span></span><span class="hljs-class">&lt;C, B&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fmap</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:function&lt;B(A)&gt; f, Const&lt;C, A&gt; c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Const&lt;C, B&gt;{c._v}; }</code> </pre> <br><p>    ,  <code>Const</code>      .        Œî <sub>c</sub> ,   ‚Äî    .       . </p><br><h5>   </h5><br><p>  ,         ,     .   ,    ,      ,      .     ,    ,         .  Nothing special.  ,   .   <code>maybeTail</code> ( <em>:   </em> )?   ,     Haskell: </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">maybeTail</span></span> :: [a] -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> [a] maybeTail [] = <span class="hljs-type"><span class="hljs-type">Nothing</span></span> maybeTail (x:xs) = <span class="hljs-type"><span class="hljs-type">Just</span></span> xs</code> </pre> <br><p> (  ,    <code>Nil</code>      <code>[]</code> .  <code>Cons</code>    <code>:</code> ().)  <code>maybeTail</code>     , <code>Maybe</code>  <code>[]</code> ,   <code>a</code> .        <code>fmap</code> ,         <code>f</code>   : <code>Maybe list</code> ?      .  <code>fmap</code>    , <code>Maybe</code> .      <code>f</code>  <code>Maybe</code> ,  <code>f</code>    .    ( <code>fmap f</code> ),     . ,      <code>Maybe list</code>  : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square</span></span> x = x * x mis :: <span class="hljs-type"><span class="hljs-type">Maybe</span></span> [<span class="hljs-type"><span class="hljs-type">Int</span></span>] mis = <span class="hljs-type"><span class="hljs-type">Just</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>] mis2 = fmap (fmap square) mis</code> </pre> <br><p> ,   ,    <code>fmap</code>      <code>Maybe</code> ,   , ‚Äî    <code>list</code> . ,   ,      : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">mis2</span></span> = (fmap . fmap) square mis</code> </pre> <br><p>  ,   <code>fmap</code>       : </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: (a -&gt; b) -&gt; (fa -&gt; fb)</code> </pre> <br><p>   ,  <code>fmap</code>  <code>(fmap . fmap)</code>    </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">square</span></span> :: <span class="hljs-type"><span class="hljs-type">Int</span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Int</span></span></code> </pre> <br><p>     </p><br><pre> <code class="haskell hljs">[<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; [<span class="hljs-type"><span class="hljs-type">Int</span></span>]</code> </pre> <br><p>   <code>fmap</code>         </p><br><pre> <code class="haskell hljs"><span class="hljs-type"><span class="hljs-type">Maybe</span></span> [<span class="hljs-type"><span class="hljs-type">Int</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Maybe</span></span> [<span class="hljs-type"><span class="hljs-type">Int</span></span>]</code> </pre> <br><p>       <code>mis</code> .  ,     ,  <code>fmap</code>    <code>fmap</code> .    :  ,     (   ,   ).  ,      ,       ,     .  ,        .      ?    ,     ,    .   .        ,       ,      . ,      <code>Cat</code> ( ,      ). ""   ,    ,   -, ,  . ,          "". ,     ,   ,           .   ,     . </p><br><h5>  </h5><br><ol><li>      `Maybe`  ,  <br> fmap _ _ = Nothing <br>     ? (:   ) </li><li>      `reader` (:   ). </li><li>   reader      (, , Haskell). </li><li>     .   ,        (   ). </li></ol><br><h5>  Thanks </h5><br><p>      .        . <br> <a href="https://habrahabr.ru/users/leshabirukov/" class="user_link">leshabirukov</a> :         <a href="https://habrahabr.ru/users/bodigrim/" class="user_link">Bodigrim</a> ,       .       . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/305018/">https://habr.com/ru/post/305018/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305000/index.html">We are looking for vulnerabilities in code: theory, practice and prospects of SAST</a></li>
<li><a href="../305002/index.html">CMYK closed-loop search algorithm on a two-dimensional matrix</a></li>
<li><a href="../305006/index.html">Wired: How blockchain threatens the financial market, and why companies on Wall Street develop this technology</a></li>
<li><a href="../305014/index.html">Review of Quanta servers: interesting solutions, rack-sized blade baskets, microserver hives and HPC farms</a></li>
<li><a href="../305016/index.html">Differences in the modeling of planned and actual operations</a></li>
<li><a href="../305022/index.html">How to work correctly with virtual machine snapshots</a></li>
<li><a href="../305026/index.html">Kaggle: A story about how we learned to predict the relevance of search queries and took 3rd place</a></li>
<li><a href="../305034/index.html">Changes in data centers: Technological solutions</a></li>
<li><a href="../305048/index.html">Comparison of DLMS / COSEM, SML and IEC 61850 communication protocols for smart metering applications</a></li>
<li><a href="../305050/index.html">Little special container magic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>