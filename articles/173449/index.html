<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make a simple multiplayer game through Game Center. Part 1: connecting Game Center to the application</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Translation of a wonderful tutorial on integrating multiplayer using Game Center in an iOS game. On the author's website there are many lessons design...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make a simple multiplayer game through Game Center. Part 1: connecting Game Center to the application</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/e4a/2fb/3ed/e4a2fb3ed4f0049e934ab73205d8b782.png"><br><br>  <i>Translation of a wonderful tutorial on integrating multiplayer using Game Center in an iOS game.</i>  <i>On <a href="http://www.raywenderlich.com/">the</a> author's <a href="http://www.raywenderlich.com/">website</a> there are many lessons designed to help novice game developers.</i> <br><br>  The game you will be working on is very simple.  This is a race whose participants are a dog and a child.  Tap as fast as possible to win! 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This tutorial assumes that you are familiar with the basics of Cocos2D.  Otherwise, I advise you to familiarize yourself with other Cocos2D lessons that you can find <a href="http://www.raywenderlich.com/tutorials">here</a> . <a name="habracut"></a><br><br>  <b>Note:</b> in order to test Game Center in the application, you must be a registered iOS developer.  You also need at least one physical iOS device (in order for one copy of the application to work in the simulator, and another on the device).  In the end, you need at least two different Game Center accounts for testing (do not worry, you can create them for free, only you need another e-mail address). <br><br>  Ready?  Then let's go! <br><br><h5>  So, let's begin </h5><br>  This lesson demonstrates the addition of a multiplayer component to a simple game.  Since the creation of the logic of the gameplay is not part of the goal of this lesson, I prepared a <a href="">piece</a> that contains the game code without working with the network. <br><br>  Download the code and run the project.  You should see something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/70f/195/a7b/70f195a7b173eaf49c0e3aa18d490335.jpg" alt="image"><br><br>  The game is very simple, and the code is well commented.  Review it and make sure you understand everything. <br><br><h5>  Turn on Game Center </h5><br>  At the moment you have a simple game that you can play, except that it is very boring to play it alone!  It would be much more fun to use Game Center to invite friends to play with you or use match search to play with random people.  But before you start using Game Center, you need to do two things: <br><br><ol><li>  Create and configure App ID; </li><li>  Register the application in iTunes Connect. </li></ol><br>  Let's get started. <br><br><h5>  Create and configure App ID </h5><br>  The first step is to create and configure the App ID.  To do this, log in to <a href="http://developer.apple.com/devcenter/ios/index.action">iOS Dev Center</a> , and from there to iOS Provisioning Portal.  Open the App IDs tab and create a new App ID for the application, just like in the screenshot: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3fa/8c6/2e6/3fa8c62e64e7b2fbb529ab9d62eacfa4.jpg" alt="image"><br><br>  The most important part is the Bundle Identifier.  It must be a unique string (that is, it cannot match the one that I use!) A good way is to use your domain name followed by a unique string to avoid matching the names. <br><br>  When you are done, click Submit.  Then open the Cat Race project, select Resources \ Info.plist ( <i>note lane:</i> in later versions of Xcode, this file is located in the Supporting Files folder and is named% Project_name% -Info.plist) and change the Bundle Identifier to the one you entered in iOS Provisioning Portal as shown below (of course, you will enter a different value): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0b1/502/225/0b1502225ddd9aa81c161a59983c25e4.jpg" alt="image"><br><br>  And the last thing.  To prevent Xcode from trouble, follow these steps: <br><br><ul><li>  Delete all copies of the application from your device or simulator; </li><li>  Exit the simulator if it is running; </li><li>  Run Project \ Clean. </li></ul><br>  Congratulations, you now have an App ID for the app, and it is configured to use!  Now you can register the application in iTunes Connect and enable Game Center. <br><br><h5>  Register the application in iTunes Connect </h5><br>  The next step is to enter <a href="">iTunes Connect</a> and register a new application. <br><br>  Once you are logged into iTunes Connect, select Manage Your Applications, then click on the blue Add New App button in the upper left.  Enter the name of the application, the SKU Number and select the Bundle ID, in the likeness of an early pattern, as well as in the screenshot: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/830/ee6/c5e/830ee6c5e99a1b40433a7d005f344745.jpg" alt="image"><br><br>  Click Continue and complete the basic information about the application.  Do not worry about correctness, as long as it is not so important, because you can change it later.  And now you just need to add something (including an icon and a screenshot) to make iTunes Connect happy. <br><br>  When you're done, click Save, and if everything is done as it should, the application status will be ‚ÄúPrepare for Upload‚Äù, as in the screenshot: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3fa/1a6/9d5/3fa1a69d57a1f50acf0214d0931a63be.jpg" alt="image"><br><br>  Click the blue ‚ÄúManage Game Center‚Äù button on the top right, then click ‚ÄúEnable‚Äù.  After that click ‚ÄúDone‚Äù.  That's it, Game Center is enabled for your application, and you can start writing code! <br><br>  By the way, in the ‚ÄúManage Game Center‚Äù section, you can also manage leaderboards and, of course, achievements.  In this lesson, work with them will not be dismantled. <br><br><h5>  Local Player Authorization: Theory </h5><br>  When the game starts, the first thing is to authorize the local player.  It is very simple.  You only need to call authenticateWithCompletionHandler.  Optionally, you can make sure that a certain block of code is executed immediately after the user is authorized. <br><br>  But there is one trick.  There is another authentication method.  To do this, switch to the Game Center application, log in from there and go back to your application. <br><br>  Your application needs to know when the authorization status changes.  You can find out about this by registering for ‚Äúauthentication changed‚Äù notifications.  So, to authorize a player you need: <br><br><ul><li>  Create a singleton object ( <i>note:</i> Singleton is a design pattern that ensures that a class has only one instance and provides global access to that instance) to keep the Game Center code in one place; </li><li>  When a single object is created, it will register to receive the ‚Äúauthentication changed‚Äù notification; </li><li>  The game will call the singleton object method to authorize the player; </li><li>  When a player logs in or out, the ‚Äúauthentication changed‚Äù function will be called back; </li><li>  The callback function will track whether a player is currently authorized. </li></ul><br><h5>  Local player authorization: implementation </h5><br>  In the Cat Race project, create a new file, select the iOS \ Cocoa Touch \ Objective-C class and click Next.  Enter NSObject in the Subclass field, click Next and name the new class as GCHelper, click Finish.  Next, replace the contents of GCHelper.h with the following: <br><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;GameKit/GameKit.h&gt;</span></span></span><span class="hljs-meta"> @interface GCHelper : NSObject { BOOL gameCenterAvailable; BOOL userAuthenticated; } @property (assign, readonly) BOOL gameCenterAvailable; + (GCHelper *)sharedInstance; - (void)authenticateLocalUser; @end</span></span></code> </pre> <br>  This code imports the GameKit header file and creates an object with two boolean variables.  One of them is necessary to monitor the availability of Game Center'a, and the second to determine when a player is authorized. <br><br>  Also created: a property so that the game can report that the Game Center is available;  a static method to maintain the uniqueness of an object instance and another method for authorizing a local user (which will be called when the application starts). <br><br>  Next, go to GCHelper.m and add the following code inside @implementation: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@synthesize</span></span> gameCenterAvailable; <span class="hljs-meta"><span class="hljs-meta">#pragma mark Initialization static GCHelper *sharedHelper = nil; + (GCHelper *) sharedInstance { if (!sharedHelper) { sharedHelper = [[GCHelper alloc] init]; } return sharedHelper; }</span></span></code> </pre><br>  Here the gameCenterAvailable property is synthesized, which sets the method for creating a single instance of the class.  I note that there are many options for writing singleton methods, but this is the easiest way when you don‚Äôt need to worry about multiple threads trying to initialize a singlelton at the same time. <br><br>  Next, add the following method immediately after the sharedInstance method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)isGameCenterAvailable { <span class="hljs-comment"><span class="hljs-comment">// check for presence of GKLocalPlayer API Class gcClass = (NSClassFromString(@"GKLocalPlayer")); // check if the device is running iOS 4.1 or later NSString *reqSysVer = @"4.1"; NSString *currSysVer = [[UIDevice currentDevice] systemVersion]; BOOL osVersionSupported = ([currSysVer compare:reqSysVer options:NSNumericSearch] != NSOrderedAscending); return (gcClass &amp;&amp; osVersionSupported); }</span></span></code> </pre><br>  This method was taken directly from the <a href="http://developer.apple.com/library/ios/">Apple Guide on using the Game Kit</a> .  This method checks the availability of the Game Kit on a specific device.  Due to this, the application will be able to run on iOS 4.0 or earlier (only without multiplayer). <br><br>  Next, add the following code immediately after the previous method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>)init { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> = [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> init])) { gameCenterAvailable = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> isGameCenterAvailable]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gameCenterAvailable) { <span class="hljs-built_in"><span class="hljs-built_in">NSNotificationCenter</span></span> *nc = [<span class="hljs-built_in"><span class="hljs-built_in">NSNotificationCenter</span></span> defaultCenter]; [nc addObserver:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> selector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(authenticationChanged) name:GKPlayerAuthenticationDidChangeNotificationName object:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)authenticationChanged { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([GKLocalPlayer localPlayer].isAuthenticated &amp;&amp; !userAuthenticated) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Authentication changed: player authenticated."</span></span>); userAuthenticated = <span class="hljs-literal"><span class="hljs-literal">TRUE</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (![GKLocalPlayer localPlayer].isAuthenticated &amp;&amp; userAuthenticated) { <span class="hljs-built_in"><span class="hljs-built_in">NSLog</span></span>(<span class="hljs-string"><span class="hljs-string">@"Authentication changed: player not authenticated"</span></span>); userAuthenticated = <span class="hljs-literal"><span class="hljs-literal">FALSE</span></span>; } }</code> </pre><br>  The init method checks the availability of the Game Center, and in the case of a positive result is registered for the ‚Äúauthentication changed‚Äù notification.  It is important that the application is registered for this notification before attempting to authorize the user, so it works after the authorization is completed. <br><br>  The authenticationChanged callback function is very simple: it checks to see if the user is authorized during the state transition, and changes the flag accordingly. <br><br>  I note that for training purposes, a function can be called several times in a row for authorization or exit, to make sure that the userAuthenticated flag is different from the current status, and only shows if there have been any changes after some time. <br><br>  Finally, add a method to authorize the local player immediately after the authenticationChanged method: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#pragma mark User functions - (void)authenticateLocalUser { if (!gameCenterAvailable) return; NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Authenticating local user..."</span></span></span><span class="hljs-meta">); if ([GKLocalPlayer localPlayer].authenticated == NO) { [[GKLocalPlayer localPlayer] authenticateWithCompletionHandler:nil]; } else { NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Already authenticated!"</span></span></span><span class="hljs-meta">); } }</span></span></code> </pre><br>  Here you call the authenticateWithCompletionHandler method, which will be mentioned later.  It serves to inform the Game Kit of the need to authorize a player.  Note that it does not pass the completion handler.  Since you signed up for the ‚Äúauthentication changed‚Äù notification, this is optional. <br><br>  Ok, now GCHelper contains all the code needed to authorize a player, so now it only remains to use it!  Switch to AppDelegate.m and make the following changes: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//     #import "GCHelper.h" //   applicationDidFinishLaunching,   //  ,   runWithScene: [[GCHelper sharedInstance] authenticateLocalUser];</span></span></code> </pre><br>  This will create a single instance (which will register for the ‚Äúauthentication changed‚Äù callback during the initialization process), then call the authenticateLocalUser method. <br><br>  Almost done!  The final step is to add the Game Kit framework to the project.  To do this, select the Cat Race project at the top left of the Groups &amp; Files tab, go to the Build Phases tab, expand ‚ÄúLink Binary with Libraries‚Äù and click on the ‚Äú+‚Äù button.  Select GameKit.framework and click Add.  Change the type from Required to Optional, and your screen should look like the following: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c12/2dc/04f/c122dc04f1ee8f8e10669075036c6439.jpg" alt="image"><br><br>  You did it!  Build and run the project, and if you are logged in to the Game Center, then you should see something like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8ff/128/581/8ff128581695689c9e1b687bd06b42da.jpg" alt="image"><br><br>  Now that you have authorized a player, you can start having fun, for example, find someone to play with! <br><br><h5>  Game Center, Game Center, make me a match </h5><br>  There are two ways to find someone to play with through the Game Center.  This is a program match search or use the built-in match creation interface. <br><br>  In this lesson you will learn the built-in interface for creating matches.  The idea is that when you want to find a match, you pass some parameters to the GKMatchRequest object, then create and display an instance of GKMatchmakerViewController. <br><br>  Let's see how it works.  First, let's make some edits to CGHelper.h: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//     @protocol GCHelperDelegate - (void)matchStarted; - (void)matchEnded; - (void)match:(GKMatch *)match didReceiveData:(NSData *)data fromPlayer:(NSString *)playerID; @end //   @interface      @interface GCHelper : NSObject &lt;GKMatchmakerViewControllerDelegate, GKMatchDelegate&gt; { //   @interface UIViewController *presentingViewController; GKMatch *match; BOOL matchStarted; id &lt;GCHelperDelegate&gt; delegate; //   @interface @property (retain) UIViewController *presentingViewController; @property (retain) GKMatch *match; @property (assign) id &lt;GCHelperDelegate&gt; delegate; - (void)findMatchWithMinPlayers:(int)minPlayers maxPlayers:(int)maxPlayers viewController:(UIViewController *)viewController delegate:(id&lt;GCHelperDelegate&gt;)theDelegate;</span></span></code> </pre><br>  Let's quickly go through this code. <br><br><ul><li>  You define the GCHelperDelegate protocol, which is used to notify another object about important events, such as: the beginning of a match, the end or the receipt of data.  In this game, your Cocos2D layer will implement this protocol; </li><li>  The GCHelper object implements two protocols.  The first is to allow the match creation interface to notify this object when a match is found or not.  And the second is for the Game Center to notify this object when data is received or the connection status has changed; </li><li>  New variables and instance properties are created to monitor the view controller, which will display the match creation interface.  As well as a link to the match, a variable that lets you know whether the match started or not, and the delegate; </li><li>  A new method is being created so that Cocos2D layer can find someone to play with. </li></ul><br>  Now switch to GCHelper.m and make the following changes: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//    @synthesize presentingViewController; @synthesize match; @synthesize delegate; //   ,   authenticateLocalUser - (void)findMatchWithMinPlayers:(int)minPlayers maxPlayers:(int)maxPlayers viewController:(UIViewController *)viewController delegate:(id&lt;GCHelperDelegate&gt;)theDelegate { if (!gameCenterAvailable) return; matchStarted = NO; self.match = nil; self.presentingViewController = viewController; delegate = theDelegate; [presentingViewController dismissModalViewControllerAnimated:NO]; GKMatchRequest *request = [[[GKMatchRequest alloc] init] autorelease]; request.minPlayers = minPlayers; request.maxPlayers = maxPlayers; GKMatchmakerViewController *mmvc = [[[GKMatchmakerViewController alloc] initWithMatchRequest:request] autorelease]; mmvc.matchmakerDelegate = self; [presentingViewController presentModalViewController:mmvc animated:YES]; }</span></span></code> </pre><br>  This method will be called by the Cocos2D layer to search for a match.  If the Game Center is not available, then this method does nothing. <br><br>  It initializes the match as not yet started and the match object as nil.  It saves the outside view controller and delegate for future use and cancels any view controller that existed before it (in case the GKMatchmakerViewController is currently displayed). <br><br>  Then comes the important part.  The GKMatchRequest object allows you to specify the type of match you are looking for, such as the minimum and maximum number of players.  This method establishes them as they were transferred to it (for this game at least - 2 players, maximum - also 2 players). <br><br>  Next, it creates a new instance of GKMatchmakerViewController with the received request ( <i>note: the</i> instance of GKMatchRequest), sets the GCHelper object as a delegate and displays the transmitted view controller to the screen. <br><br>  From this point on, control is transferred to GKMatchmakerViewController, which allows the user to find a random player and start the game.  After that, some callback functions will be called, so let's add them: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#pragma mark GKMatchmakerViewControllerDelegate //     - (void)matchmakerViewControllerWasCancelled:(GKMatchmakerViewController *)viewController { [presentingViewController dismissModalViewControllerAnimated:YES]; } //      - (void)matchmakerViewController:(GKMatchmakerViewController *)viewController didFailWithError:(NSError *)error { [presentingViewController dismissModalViewControllerAnimated:YES]; NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Error finding match: %@"</span></span></span><span class="hljs-meta">, error.localizedDescription); } //  ,    - (void)matchmakerViewController:(GKMatchmakerViewController *)viewController didFindMatch:(GKMatch *)theMatch { [presentingViewController dismissModalViewControllerAnimated:YES]; self.match = theMatch; match.delegate = self; if (!matchStarted &amp;&amp; match.expectedPlayerCount == 0) { NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Ready to start match!"</span></span></span><span class="hljs-meta">); } }</span></span></code> </pre><br>  If the player cancels the match search, or an error occurs, the match creation view will simply close. <br><br>  And if a match is found, it will save the match object and set the delegate of the match to the GCHelper delegate so that it can be notified of incoming data and a change in the connection status. <br><br>  He also checks if it's time to start the match.  The match object stores the number of players that need to be found in the variable expectedPlayerCount.  If it is 0, then everyone is ready to start.  Now we just put it in the log, later we will do something interesting here. <br><br>  Next, add the implementation of the GKMatchDelegate callback functions: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#pragma mark GKMatchDelegate //       - (void)match:(GKMatch *)theMatch didReceiveData:(NSData *)data fromPlayer:(NSString *)playerID { if (match != theMatch) return; [delegate match:theMatch didReceiveData:data fromPlayer:playerID]; } //    (, , ) - (void)match:(GKMatch *)theMatch player:(NSString *)playerID didChangeState:(GKPlayerConnectionState)state { if (match != theMatch) return; switch (state) { case GKPlayerStateConnected: // handle a new player connection. NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Player connected!"</span></span></span><span class="hljs-meta">); if (!matchStarted &amp;&amp; theMatch.expectedPlayerCount == 0) { NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Ready to start match!"</span></span></span><span class="hljs-meta">); } break; case GKPlayerStateDisconnected: // a player just disconnected. NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Player disconnected!"</span></span></span><span class="hljs-meta">); matchStarted = NO; [delegate matchEnded]; break; } } //        -  - (void)match:(GKMatch *)theMatch connectionWithPlayerFailed:(NSString *)playerID withError:(NSError *)error { if (match != theMatch) return; NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Failed to connect to player with error: %@"</span></span></span><span class="hljs-meta">, error.localizedDescription); matchStarted = NO; [delegate matchEnded]; } //     -  - (void)match:(GKMatch *)theMatch didFailWithError:(NSError *)error { if (match != theMatch) return; NSLog(@</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"Match failed with error: %@"</span></span></span><span class="hljs-meta">, error.localizedDescription); matchStarted = NO; [delegate matchEnded]; }</span></span></code> </pre><br>  match: didReceiveData: fromPlayer is called when another player sends you data.  This method simply forwards the data to the delegate (in this game it will be the Cocos2D layer), so the game engine can use it. <br><br>  match: player: didChangState is used when connecting a player to check if all players are connected so that you can start the match.  Otherwise, if a player disconnects, the match ends and a notification is sent to the delegate. <br><br>  OK, now we have the code to create a match, let's use it in our HelloWorldLayer.  Switch to HelloWorldLayer.h and make the following changes: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//     #import "GCHelper.h" //  @interface   GCHelperDelegate @interface HelloWorldLayer : CCLayer &lt;GCHelperDelegate&gt;</span></span></code> </pre><br>  Now switch to HelloWorldLayer.m and make the following corrections: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">//     #import "AppDelegate.h" #import "RootViewController.h" //     init,   setGameState AppDelegate * delegate = (AppDelegate *) [UIApplication sharedApplication].delegate; [[GCHelper sharedInstance] findMatchWithMinPlayers:2 maxPlayers:2 viewController:delegate.viewController delegate:self]; //       #pragma mark GCHelperDelegate - (void)matchStarted { CCLOG(@"Match started"); } - (void)matchEnded { CCLOG(@"Match ended"); } - (void)match:(GKMatch *)match didReceiveData:(NSData *)data fromPlayer:(NSString *)playerID { CCLOG(@"Received data"); }</span></span></code> </pre><br>  The most important part here is the init method.  It gets the RootViewController from the App Delegate, because this view controller will display the match creation view controller.  Further, the method for match search is called by displaying the view controller of the match creation.  This is the method you just wrote in GCHelper. <br><br>  Next come the preparations for the functions of the beginning or end of the matches, which you implement later. <br><br>  Last thing.  By default, the Cocos2D template does not contain a property for the RootViewController in the App Delegate, so you must add it.  Switch to AppDelegate.h and add the following: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@property</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">nonatomic</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">retain</span></span>) RootViewController *viewController;</code> </pre><br>  Synthesize it in AppDelegate.m: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">@synthesize</span></span> viewController;</code> </pre><br>  Done!  Build and run the application, and you should see the match creation view controller appear: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c3/3bf/788/7c33bf788a43a90f4c65f8b4a44103de.jpg" alt="image"><br><br>  Now run the application on another device so that you have two running copies at the same time (for example, it can be a simulator and your iPhone). <br><br>  <b>Important:</b> make sure you use different Game Center accounts on each device, otherwise it will not work. <br><br>  Click "Play Now" on both devices and, after some time, the match creation view controller will disappear, and you should see something like this in the log: <br><br><pre> <code class="objectivec hljs">CatRace[<span class="hljs-number"><span class="hljs-number">16440</span></span>:<span class="hljs-number"><span class="hljs-number">207</span></span>] Authentication changed: player authenticated. CatRace[<span class="hljs-number"><span class="hljs-number">16440</span></span>:<span class="hljs-number"><span class="hljs-number">207</span></span>] Player connected! CatRace[<span class="hljs-number"><span class="hljs-number">16440</span></span>:<span class="hljs-number"><span class="hljs-number">207</span></span>] Ready to start match!</code> </pre><br>  Congratulations!  You created a match between two devices!  Now you are on the way to creating a network game! <br><br><h5>  Landscape orientation and GKMatchmakerViewController </h5><br>  You should have noticed that by default the GKMatchmakerViewController appears in a portnet orientation.  Obviously, this is very annoying, because this Cocos2D game in landscape! <br><br>  Fortunately, you can fix this by forcing GKMatchmakerViewController to accept only landscape orientations.  To do this, create a new file, select the iOS \ Cocoa Touch \ Objective-C class and create a subclass of NSObject under the name GKMatchmakerViewController-LandscapeOnly. <br><br>  Replace the contents of GKMatchmakerViewController-LandscapeOnly.h with the following: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;Foundation/Foundation.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;GameKit/GameKit.h&gt;</span></span></span><span class="hljs-meta"> @interface GKMatchmakerViewController(LandscapeOnly) - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation; @end</span></span></code> </pre><br>  And then the contents of GKMatchmakerViewController-LandscapeOnly.m: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"GKMatchmakerViewController-LandscapeOnly.h"</span></span></span><span class="hljs-meta"> @implementation GKMatchmakerViewController (LandscapeOnly) - (BOOL)shouldAutorotateToInterfaceOrientation:(UIInterfaceOrientation)interfaceOrientation { return ( UIInterfaceOrientationIsLandscape( interfaceOrientation ) ); } @end</span></span></code> </pre><br>  And that's it!  Build the application and run it.  Now the view controller should appear in the landscape view: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/413/66f/319/41366f3194d908f4df11bd4d5bd573bc.jpg" alt="image"><br><br><h5>  What next? </h5><br>  Here is <a href="">an example of a project</a> with all the code that was discussed in this lesson. <br><br>  In the second part, we will learn how to transfer data between devices, and turn the game into a wonderful cat-child race! </div><p>Source: <a href="https://habr.com/ru/post/173449/">https://habr.com/ru/post/173449/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../173433/index.html">Development Prospects: Singularity and "Reasonable Governance"</a></li>
<li><a href="../173437/index.html">Creating a single Exchange Address Book for two or more Active Directory forests</a></li>
<li><a href="../173443/index.html">Cacti: Monitoring SMART</a></li>
<li><a href="../173445/index.html">Russian look at Tech Peaks: how to get the opportunity to run your startup in Trento</a></li>
<li><a href="../173447/index.html">JavaScript tail recursion emulation</a></li>
<li><a href="../17345/index.html">Image test</a></li>
<li><a href="../173453/index.html">Git for Photos. Large Git Repositories</a></li>
<li><a href="../173455/index.html">Poll on the specifics of testing when developing applications for Android?</a></li>
<li><a href="../173457/index.html">Interview with Igor Scheufot - Berkeley teacher and representative of TMT Investments in Silicon Valley</a></li>
<li><a href="../173459/index.html">Tumbler Sites, or Welcome to the FailOver Conference on April 4</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>