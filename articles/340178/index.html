<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Monoids, semigroups and all-all-all</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you use OOP in practice, you are well-versed in such things as ‚Äúdesign patterns‚Äù . Do you know that there are many useful patterns that do not fit ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Monoids, semigroups and all-all-all</h1><div class="post__text post__text-html js-mediator-article"><p><img width="230" align="left" src="https://habrastorage.org/webt/59/e4/7f/59e47f8185310590612122.png">  If you use OOP in practice, you are well-versed in such things as <a href="https://ru.wikipedia.org/wiki/%25D0%25A8%25D0%25B0%25D0%25B1%25D0%25BB%25D0%25BE%25D0%25BD_%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B5%25D0%25BA%25D1%2582%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D1%258F">‚Äúdesign patterns‚Äù</a> .  Do you know that there are many useful patterns that do not fit into this standard list?  Unfortunately, many of them are associated with "functional programming", which, according to legend, is complex and abstruse.  If you say the word "monoid" ten times, you can call the Devil. </p><br><p>  <em>Mark Seeman</em> talks about functional programming quickly and easily.  To do this, he began writing a series of articles on the relationship between <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory/">design patterns and category theory</a> .  Any OOshnik, which has 15 minutes of free time, will be able to get into their own hands a fundamentally new set of ideas and insights related not only to the functional area, but also to the correct object-oriented design.  The crucial factor is that <strong>all the examples are real C #, F #, and Haskell code</strong> .  This habraposte is a translation of the very beginning of the cycle, the first three articles, merged for convenience of understanding. </p><br><p>  In addition, you can talk with Mark <strong>live</strong> by visiting the <a href="https://dotnext.ru/">DotNext 2017 Moscow</a> conference, which will be held on November 12-13, 2017 in Moscow, at Slavyanskaya Radisson.  Mark will read a report on the topic <a href="https://dotnext-moscow.ru/2017/msk/talks/20wwzs2qeuuykg86cc6ams/">‚ÄúFrom dependency injection to dependency rejection‚Äù</a> .  Tickets are available <a href="https://dotnext-moscow.ru/tickets/">here</a> . </p><a name="habracut"></a><br><h1 id="vstuplenie-monoidy-polugruppy-i-vse-vse-vsehttpblogploehdk20171005monoids-semigroups-and-friends">  <a href="http://blog.ploeh.dk/2017/10/05/monoids-semigroups-and-friends/">Introduction.</a>  <a href="http://blog.ploeh.dk/2017/10/05/monoids-semigroups-and-friends/">Monoids, semigroups and all-all-all</a> </h1><br><p>  This text is part of a new series on the relationship between <a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory">design patterns and category theory</a> . <br>  Functional programming is usually criticized for a special abstruse jargon.  Terms like <strong>zygohistomorphic prepromorphism</strong> do not help to bring the essence to beginners.  But before we throw stones, we must first go out of our own glass house.  In object-oriented design, names such as <a href="https://en.wikipedia.org/wiki/Bridge_pattern">Bridge</a> , <a href="https://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a> , <a href="https://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B2%25D1%258F%25D0%25B7%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D1%258C_(%25D0%25BF%25D1%2580%25D0%25BE%25D0%25B3%25D1%2580%25D0%25B0%25D0%25BC%25D0%25BC%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5)">connectivity,</a> and others are used.  The words sound familiar, but can you explain or implement the Visitor pattern in the code or describe what ‚Äúconnectivity‚Äù is? </p><br><p>  The word "bridge" does not in itself make object-oriented terminology any better.  It may even make it worse.  In the end, the word became multivalued: do we mean a real physical object, uniting two different places, or talking about a design pattern?  Of course, in practice, we will understand this from the context, but this does not cancel the fact - if someone talks about the bridge pattern, you will understand absolutely nothing if you have not learned it beforehand.  The fact that the word sounds familiar does not make it useful. </p><br><p>  Many object-oriented programmers have discovered the usefulness of "an operation that returns the same type as it received as an argument."  But nevertheless, such a description, such a dictionary is very inconvenient.  Wouldn't it be better to describe this operation in one word?  Maybe it is a <em>monoid</em> or a <em>semigroup</em> ? </p><br><h2 id="obektno-orientirovannye-ozareniya">  Object Oriented Insights </h2><br><p> In <a href="http://amzn.to/WBCwx7">Domain-Driven Design,</a> Eric Evans talks about the concept of <em>Closure of Operations</em> .  As the name implies, this is an ‚Äúoperation, the return type of which coincides with the types of arguments‚Äù.  In C #, this may be a method with the signature <code>public Foo Bar(Foo f1, Foo f2)</code> .  The method takes two <code>Foo</code> objects as input and returns the <code>Foo</code> object too. </p><br><p>  As Evans noted, objects designed in this way begin to look as if they formed arithmetic.  If there is an operation that accepts <code>Foo</code> and returns <code>Foo</code> , what could it be?  Maybe addition?  Multiplication?  Any other mathematical operation? </p><br><p>  Some <a href="http://blog.ploeh.dk/2012/12/18/RangersandZookeepers">enterprise developers</a> just want to "do business and move on," they are not at all worried about mathematics.  For them, the idea of ‚Äã‚Äãmaking the code more ‚Äúmathematical‚Äù seems very controversial.  Nevertheless, even if you ‚Äúdislike mathematics,‚Äù you clearly understand the meaning of addition, multiplication, etc.  Arithmetic is a powerful metaphor, as all programmers understand it. </p><br><p>  In his famous book <a href="http://bit.ly/tddbe">, Test-Driven Development: By Example,</a> Kent Beck seemed to be exploiting the same idea.  Although I do not think that he wrote about this somewhere directly. </p><br><p>  What Evans wrote about is monoids, semigroups and similar concepts from abstract algebra.  In fairness, I recently spoke with him, and now he is well versed in all these things.  I didn‚Äôt know if he understood them in 2003, when DDD was written, but I definitely don‚Äôt.  My task here is not to poke fingers, but to show that very smart people derived principles that can be used in the PLO, long before these principles got their own names. </p><br><h2 id="kak-vse-eto-svyazano">  How is all this related </h2><br><p>  Monoids and semigroups belong to a larger group of operations called magmas.  We will talk about this later, but now we start with monoids, continue with semigroups, and only then proceed to the magmas.  All monoids are semigroups, the reverse is not true.  In other words, monoids form a subset of semigroups. </p><br><p><img src="https://habrastorage.org/webt/59/e4/6e/59e46e9a28766827469132.png"></p><br><p>  They describe binary operations in the form: an operation that takes two values ‚Äã‚Äãof <code>Foo</code> as input and returns a value of type <code>Foo</code> at the output.  Both categories are described by (intuitive) laws.  The difference is that the laws of monoids are stricter than the laws of semigroups.  Do not hang out on terminology: the word "law" may sound as if serious complicated mathematics is involved, but these "laws" are simple and intuitive.  We will talk about them in the following parts (of which there will be about 15 pieces). </p><br><p>  Despite the fact that they are all closely related to mathematics, they are intended to, among other things, give a lot of ideas for a good object-oriented design. </p><br><h2 id="rezyume">  Summary </h2><br><p>  For an ordinary object-oriented programmer, terms such as a <em>monoid</em> or <em>semigroup</em> a mile away smell math, academy, and ivory towers inhabited by architectural astronauts.  But in fact, these are simple and convenient ideas that can be understood by anyone who feels like 15 minutes to do it. </p><br><h1 id="chast-1-monoidyhttpblogploehdk20171006monoids">  <a href="http://blog.ploeh.dk/2017/10/06/monoids/">Part 1. Monoids</a> </h1><br><p>  <strong>The bottom line: an introduction to monoids for OOP programmers.</strong> <br>  This section is part of a <a href="http://blog.ploeh.dk/2017/10/05/monoids-semigroups-and-friends">series of articles on monoids, semigroups, and related concepts</a> .  Having studied this section, you will understand what a monoid is and how it differs from a semigroup. </p><br><p><img src="https://habrastorage.org/webt/59/e4/56/59e456899daae784572470.png"></p><br><p>  Monoids form a subset of semigroups.  The rules by which monoids work are stricter than for semigroups.  It may even be decided that it is better to first deal with semigroups and move on to monoids based on them.  Strictly speaking, in terms of hierarchy, this makes sense.  But I think monoids are much more intuitive.  Having seen the first example of a monoid, you immediately understand that they describe <strong>things from everyday life</strong> .  It is easy to find an example for a monoid, but to find a good example of a semigroup - you have to try.  Therefore, we begin precisely with monoids. </p><br><h2 id="zakony-monoida">  The laws of the monoid </h2><br><p>  What does addition ( <code>40 + 2</code> ) and multiplication ( <code>6 * 7</code> ) have in common? <br>  Both of these operations </p><br><ul><li>  associative </li><li>  are binary operations </li><li>  have a neutral element </li></ul><br><p>  This is all that is needed to form a monoid.  Associativity and existence of a neutral element are called ‚Äúmonoid laws‚Äù or ‚Äúmonoid laws‚Äù (in English, <em>monoid laws</em> ).  It should be noted that a monoid is a combination of data type and operation.  That is, it is not just a type, but rather a function (or method) that works on this type.  For example, addition and multiplication are two different monoids working on numbers. </p><br><h2 id="binarnost">  Binary </h2><br><p>  Let's start with the simplest.  An operation is ‚Äúbinary‚Äù if it works on two values.  Perhaps when the word ‚Äúbinary‚Äù is mentioned, you are primarily presented with binary data, such as 101010, but this word came from the Latin language, and means something related to ‚Äúarity two‚Äù.  Astronomers also sometimes talk about binary stars (binary stars), but now this word is mainly used in the context of computers: aside from binary data, you most likely have heard of binary trees.  Speaking of binary operations, we mean that both incoming values ‚Äã‚Äãare of the same type, and that the return type also coincides with the incoming type.  In other words, in C #, a method like this is the correct binary operation: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-type"><span class="hljs-type">Foo</span></span> <span class="hljs-type"><span class="hljs-type">Op</span></span>(<span class="hljs-type"><span class="hljs-type">Foo</span></span> x, <span class="hljs-type"><span class="hljs-type">Foo</span></span> y)</code> </pre> <br><p>  Sometimes, if <code>Op</code> is an instance method of the <code>Foo</code> class, it may look like this: </p><br><pre> <code class="hljs lisp">public Foo Op (<span class="hljs-name"><span class="hljs-name">Foo</span></span> foo)</code> </pre> <br><p>  On the other hand, this is no longer a binary operation: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-type"><span class="hljs-type">Baz</span></span> <span class="hljs-type"><span class="hljs-type">Op</span></span>(<span class="hljs-type"><span class="hljs-type">Foo</span></span> f, <span class="hljs-type"><span class="hljs-type">Bar</span></span> b)</code> </pre> <br><p>  Although it takes two incoming arguments, they are of different types, and the return type is also different. </p><br><p>  Since all the arguments and return values ‚Äã‚Äãare the same type, the binary operation is what Eric Evans in <a href="http://amzn.to/WBCwx7">Domain-Driven Design</a> called <em>Closure of Operations</em> . </p><br><h2 id="associativnost">  Associativity </h2><br><p>  To form a monoid, a binary operation must necessarily be <em>associative</em> .  It simply means that the order of the calculations is not important.  For example, to add it means that: </p><br><pre> <code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span> + (<span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>) = <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">3</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span> = <span class="hljs-number"><span class="hljs-number">9</span></span></code> </pre> <br><p>  Similarly for multiplication: </p><br><pre> <code class="hljs lisp">(<span class="hljs-number"><span class="hljs-number">2</span></span> * 3) * <span class="hljs-number"><span class="hljs-number">4</span></span> = <span class="hljs-number"><span class="hljs-number">2</span></span> * (3 * <span class="hljs-number"><span class="hljs-number">4</span></span>) = <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span> * <span class="hljs-number"><span class="hljs-number">4</span></span> = <span class="hljs-number"><span class="hljs-number">24</span></span></code> </pre> <br><p>  If we talk about the <code>Op</code> method described above, associativity requires that <code>areEqual</code> is <code>true</code> for the following code: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> areEqual = foo1.<span class="hljs-type"><span class="hljs-type">Op</span></span>(foo2).<span class="hljs-type"><span class="hljs-type">Op</span></span>(foo3) == foo1.<span class="hljs-type"><span class="hljs-type">Op</span></span>(foo2.<span class="hljs-type"><span class="hljs-type">Op</span></span>(foo3));</code> </pre> <br><p>  On the left side, <code>foo1.Op(foo2)</code> calculated first, and then the result is applied to <code>foo3</code> .  On the right, <code>foo2.Op(foo3)</code> evaluated first, and the result will be the argument for <code>foo1.Op</code>  Since the left and right sides are compared using the == operator, associativity requires that <code>areEqual</code> be equal to <code>true</code> . </p><br><p>  In order for this whole construct to work in C #, if there is some self-made monoid <code>Foo</code> , it will have to reload <code>Equals</code> and implement the <code>==</code> operator. </p><br><h2 id="neytralnyy-element">  Neutral element </h2><br><p>  The third rule of a monoid is that a neutral element must exist.  Usually it is called a <em>unit</em> (not the most appropriate name, but better than the cumbersome "neutral element").  In the future we will call him that. </p><br><p>  A unit is a value that "does nothing."  For example, for addition it is <code>0</code> , because adding zero does nothing with the original value, does not change it: </p><br><pre> <code class="hljs">0 + 42 = 42 + 0 = 42</code> </pre> <br><p>  Simple exercise: guess what the unit is for multiplication. </p><br><p>  In the above sum entry, it is implied that the unit should be neutral and when it is used on the left and when it is used on the right.  For our <code>Foo</code> objects, this can be written as: </p><br><pre> <code class="hljs pgsql">var hasIdentity = Foo.<span class="hljs-keyword"><span class="hljs-keyword">Identity</span></span>.Op(foo) == foo.Op(Foo.<span class="hljs-keyword"><span class="hljs-keyword">Identity</span></span>) &amp;&amp; foo.Op(Foo.<span class="hljs-keyword"><span class="hljs-keyword">Identity</span></span>) == foo;</code> </pre> <br><p>  There are a pair of monoids working on Boolean values: <em>all</em> and <em>any</em> .  What do you think, how do they work?  What are their units? </p><br><p>  You can ponder over <code>all</code> and <code>any</code> (or google them) as an exercise.  In the following sections, I will show other, more interesting monoids.  In this article, only strings, lists and sequences are considered - the rest of the articles are still being written. </p><br><p>  In essence, if there is a data type that ‚Äúbehaves like a number,‚Äù you can most likely make a monoid of it.  Addition is one of the best candidates, because it is easiest to understand, and you don‚Äôt need to get involved with things like units.  For example, in the .NET Base Class Library there is a <a href="https://msdn.microsoft.com/en-us/library/system.timespan">TimeSpan</a> structure that has an <a href="">Add</a> method.  Operator <code>==</code> she also has.  On the other hand, <code>TimeSpan</code> does not have the <code>Multiply</code> method, since - what will be the result of multiplying two periods?  <a href="https://en.wikipedia.org/wiki/Time_Squared_(Star_Trek:_The_Next_Generation)">Square time</a> ? </p><br><h2 id="rezyume-1">  Summary </h2><br><p>  A monoid (not to be confused with a monad) is a binary operation that satisfies two laws of a monoid: the operation must be associative and there must exist a neutral element (one).  The main examples of a monoid are addition and multiplication, but there are many others. </p><br><p>  (By the way, the unit for multiplication is unit (1), <code>all</code> is boolean <code>and</code> , and <code>any</code> is boolean <code>or</code> .) </p><br><h1 id="chast-2-monoid-strok-spiskov-i-posledovatelnosteyhttpblogploehdk20171010strings-lists-and-sequences-as-a-monoid">  <a href="http://blog.ploeh.dk/2017/10/10/strings-lists-and-sequences-as-a-monoid/">Part 2. A monoid of strings, lists, and sequences.</a> </h1><br><p>  <strong>Essence: strings, lists and sequences, in fact, are one and the same monoid.</strong> <br>  This section is part of a <a href="http://blog.ploeh.dk/2017/10/06/monoids">series of articles about monoids</a> . <br>  In short, a <em>monoid</em> is an associative binary operation with a neutral element (known as a <em>unit</em> , or in English terminology, <em>identity</em> ). </p><br><h2 id="posledovatelnosti">  Sequences </h2><br><p>  In C #, lazy sequences of values ‚Äã‚Äãare modeled using <code>IEnumerable&lt;T&gt;</code> .  You can combine a couple of sequences by adding one to the other: </p><br><pre> <code class="hljs pgsql">xs.Concat(ys)</code> </pre> <br><p>  Here, <code>xs</code> and <code>ys</code> are <code>IEnumerable&lt;T&gt;</code> instances.  The <a href="https://msdn.microsoft.com/en-us/library/bb302894">Concat</a> extension <a href="https://msdn.microsoft.com/en-us/library/bb302894">method</a> combines sequences.  It has the following signature: <code>IEnumerable&lt;T&gt; Concat&lt;T&gt;(IEnumerable&lt;T&gt;, IEnumerable&lt;T&gt;)</code> , therefore it is a binary operation.  If we find out that it is associative and has a unit, then we prove that it is a monoid. </p><br><p>  Sequences are associative, because the sequence of calculation does not change the result.  Associativity is a <em>property of a</em> monoid, so one of the ways to demonstrate it is to use <a href="https://www.pluralsight.com/courses/fsharp-property-based-testing-introduction%3Futm_medium%3Daffiliate%26utm_source%3D1017843">property-based testing</a> . </p><br><pre> <code class="hljs pgsql">[Property(QuietOnSuccess = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> ConcatIsAssociative(<span class="hljs-type"><span class="hljs-type">int</span></span>[] xs, <span class="hljs-type"><span class="hljs-type">int</span></span>[] ys, <span class="hljs-type"><span class="hljs-type">int</span></span>[] zs) { <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.Equal( xs.Concat(ys).Concat(zs), xs.Concat(ys.Concat(zs))); }</code> </pre> <br><p>  This autotest uses <a href="https://fscheck.github.io/FsCheck">FsCheck</a> (yes, in C # it also works!) To demonstrate <code>Concat</code> associativity.  To simplify matters, <code>xs</code> , <code>ys</code> and <code>zs</code> declared as <em>arrays</em> .  This is necessary because FsCheck natively knows how to create arrays, but has no built-in support for <code>IEnumerable&lt;T&gt;</code> .  Of course, you could create <code>iEnumerable&lt;T&gt;</code> yourself, using the FsCheck API, but this will complicate the example and not add anything new.  The associativity property holds for other <a href="https://en.wikipedia.org/wiki/Pure_function">pure</a> implementations of <code>IEnumerable&lt;T&gt;</code> .  If you do not believe it, try it. </p><br><p>  Operation <code>Concat</code> has a unit.  A unit is an empty sequence, as evidenced by the following test: </p><br><pre> <code class="hljs pgsql">[Property(QuietOnSuccess = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> ConcatHasIdentity(<span class="hljs-type"><span class="hljs-type">int</span></span>[] xs) { <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.Equal( Enumerable.Empty&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;().Concat(xs), xs.Concat(Enumerable.Empty&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;())); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.Equal( xs, xs.Concat(Enumerable.Empty&lt;<span class="hljs-type"><span class="hljs-type">int</span></span>&gt;())); }</code> </pre> <br><p>  In other words, if a blank sequence is glued to the beginning or end of any sequence, then the original sequence will not change. </p><br><p>  Since <code>Concat</code> is an associative binary operation with a unit, it is a monoid.  Proven.  ‚óº </p><br><h2 id="svyaznye-spiski-i-drugie-kollekcii">  Linked lists and other collections </h2><br><p>  The above tests using FsCheck showed that <code>Concat</code> is a monoid over arrays.  This property holds for all pure <code>IEnumerable&lt;T&gt;</code> implementations. </p><br><p>  In <a href="https://www.haskell.org/">Haskell,</a> lazy sequences are modeled as linked lists.  They are lazy because all the expressions in Haskell are those by default.  The laws of monoids are fulfilled for lists in Haskell: </p><br><pre> <code class="hljs css">Œª&gt; (<span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3]</span></span> ++ <span class="hljs-selector-attr"><span class="hljs-selector-attr">[4,5,6]</span></span>) ++ <span class="hljs-selector-attr"><span class="hljs-selector-attr">[7,8,9]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3,4,5,6,7,8,9]</span></span> Œª&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3]</span></span> ++ (<span class="hljs-selector-attr"><span class="hljs-selector-attr">[4,5,6]</span></span> ++ <span class="hljs-selector-attr"><span class="hljs-selector-attr">[7,8,9]</span></span>) <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3,4,5,6,7,8,9]</span></span> Œª&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> ++ <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3]</span></span> Œª&gt; <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3]</span></span> ++ <span class="hljs-selector-attr"><span class="hljs-selector-attr">[]</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[1,2,3]</span></span></code> </pre> <br><p>  In Haskell, the <code>++</code> operator is about the same as <code>Concat</code> in C #, but this operation is called addition or <em>appending</em> ( <em>append</em> ), and not concatenation ( <em>concat</em> ). </p><br><p>  In <a href="http://fsharp.org/">F #,</a> linked lists are initialized aggressively (not lazily), since all expressions in F # are default ones.  Lists, however, continue to be monoids, since all the properties of a monoid are still valid: </p><br><pre> <code class="hljs cpp">&gt; ([<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>] @ [<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>]) @ [<span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-number"><span class="hljs-number">9</span></span>];; val it : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-number"><span class="hljs-number">9</span></span>] &gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>] @ ([<span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>] @ [<span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-number"><span class="hljs-number">9</span></span>]);; val it : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-number"><span class="hljs-number">7</span></span>; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-number"><span class="hljs-number">9</span></span>] &gt; [] @ [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>];; val it : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>] &gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>] @ [];; val it : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>]</code> </pre> <br><p>  In F #, the concatenation operator is <code>@</code> , not <code>++</code> , but its behavior is exactly the same as in Haskell.  ‚óº </p><br><h2 id="stroki">  Strings </h2><br><p>  Have you ever wondered why text values ‚Äã‚Äãare called <code>string</code> in most programming languages?  After all, a <em>string</em> in English is a <em>rope</em> , such a long flexible thing made of fibers. </p><br><p>  In programming, text is usually presented in memory as a sequential block of characters.  Usually the program reads such sequential blocks of memory until it reaches something that is a sign of the end of a line.  Thus, the character strings are ordered.  They look like sequences or lists. </p><br><p>  In fact, in Haskell, the <code>String</code> type is not something tricky, but a synonym for <code>[Char]</code> (meaning: a list of <code>Char</code> values).  Therefore, everything that you can do with lists of any other types can also be done with a <code>String</code> : </p><br><pre> <code class="hljs objectivec">Œª&gt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ++ [] <span class="hljs-string"><span class="hljs-string">"foo"</span></span> Œª&gt; [] ++ <span class="hljs-string"><span class="hljs-string">"foo"</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span> Œª&gt; (<span class="hljs-string"><span class="hljs-string">"foo"</span></span> ++ <span class="hljs-string"><span class="hljs-string">"bar"</span></span>) ++ <span class="hljs-string"><span class="hljs-string">"baz"</span></span> <span class="hljs-string"><span class="hljs-string">"foobarbaz"</span></span> Œª&gt; <span class="hljs-string"><span class="hljs-string">"foo"</span></span> ++ (<span class="hljs-string"><span class="hljs-string">"bar"</span></span> ++ <span class="hljs-string"><span class="hljs-string">"baz"</span></span>) <span class="hljs-string"><span class="hljs-string">"foobarbaz"</span></span></code> </pre> <br><p>  Obviously, <code>++</code> for <code>String</code> is a monoid in Haskell. </p><br><p>  Similarly, in .NET, <code>System.String</code> implements <code>IEnumerable&lt;char&gt;</code> .  By analogy, you can guess that they will be monoids - and this is <em>almost the</em> case.  Let's see, they are exactly associative: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">Property(QuietOnSuccess = true)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PlusIsAssociative</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> z</span></span></span><span class="hljs-function">)</span></span> { Assert.Equal( (x + y) + z, x + (y + z)); }</code> </pre> <br><p>  In C #, the <code>+</code> operator is indeed defined for <code>string</code> , and, as can be seen from this test on FsCheck, it is associative.  And he almost has a unit.  What is the equivalent of an empty list in the string world?  Of course, the empty string: </p><br><pre> <code class="hljs pgsql">[Property(QuietOnSuccess = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)] <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> <span class="hljs-type"><span class="hljs-type">void</span></span> PlusHasIdentity(NonNull&lt;string&gt; x) { <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.Equal("" + x.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>, x.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> + ""); <span class="hljs-keyword"><span class="hljs-keyword">Assert</span></span>.Equal(x.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>, x.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span> + ""); }</code> </pre> <br><p>  I had to manually explain FsCheck that you do not need to use <code>null</code> .  As always, <code>null</code> inserts sticks into the wheels in any arguments about the code. </p><br><p>  The problem here is that <code>"" + null</code> and <code>null + ""</code> return the same value - <code>""</code> , and it is not equal to the incoming value ( <code>null</code> ).  In other words, <code>""</code> not a real unit for the <code>+</code> operator, because this special case exists.  (And by the way, <code>null</code> also not a unit, since <code>null + null</code> returns ... <code>""</code> ! Well, of course, it returns exactly this ...).  However, this is a feature of implementation.  As an exercise, try to come up with a method (extensions) in C # that would make <code>string</code> regular monoid, despite the presence of <code>null</code> .  As soon as you come up with it, it will immediately show that string concatenation is a monoid in .NET in the same way as in Haskell.  ‚óº </p><br><h2 id="svobodnyy-monoid">  Free monoid </h2><br><p>  Remember how in previous articles we showed that both addition and multiplication of numbers are monoids.  There is at least one more monoid over the numbers, and this is a sequence.  If there is a generic sequence ( <code>IEnumerable&lt;T&gt;</code> ), it can contain anything, including numbers. </p><br><p>  Imagine that there are two numbers, <code>3</code> and <code>4</code> , and you want to combine them, but it is not yet clear how you will combine them.  To postpone a decision, you can put both numbers in a single array (in English, this is called a <em>singleton array</em> ‚Äî a single element array, and this has nothing to do with the Singleton pattern): </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> three = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> four = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-number"><span class="hljs-number">4</span></span> };</code> </pre> <br><p>  As we have previously proved, sequences are monoids, so you can safely combine them: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> combination = three.<span class="hljs-type"><span class="hljs-type">Concat</span></span>(four);</code> </pre> <br><p>  The result is a sequence containing both numbers.  At the moment, we have not yet lost any information, so as soon as the way to combine these numbers is clear, it will just be necessary to <em>calculate the</em> previously collected data.  This is called a <a href="https://bartoszmilewski.com/2015/07/21/free-monoids">free monoid</a> . </p><br><p>  For example, we decided to get the sum of numbers: </p><br><pre> <code class="hljs coffeescript">var sum = combination.Aggregate(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> =&gt;</span></span> x + y);</code> </pre> <br><p>  (Yes, I am aware that there is a <a href="https://msdn.microsoft.com/en-us/library/bb338442">Sum</a> method, but now our goal is to understand the details).  This <a href="https://msdn.microsoft.com/en-us/library/bb549218">Aggregate</a> takes the <code>seed</code> value as the first argument, and the function for the combination as the second. </p><br><p>  And this is how you can get the product: </p><br><pre> <code class="hljs coffeescript">var product = combination.Aggregate(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function"> =&gt;</span></span> x * y);</code> </pre> <br><p>  Note that in both cases the <code>seed</code> value is a unit for the corresponding monoidal operation: <code>0</code> for addition, <code>1</code> for multiplication.  Similarly, the aggregation function uses the binary operation that belongs to the corresponding monoid. </p><br><p>  Interestingly, this is called a ‚Äúfree monoid‚Äù, similar to the <a href="http://blog.ploeh.dk/2017/07/10/pure-interactions">‚Äúfree monad‚Äù</a> .  In both cases, it is possible to collect all the data, interpreting them not immediately, but later - and then download all this data into one of the many pre-prepared ‚Äúcalculators‚Äù. </p><br><h2 id="rezyume-2">  Summary </h2><br><p>  Many types of collections, such as sequences and arrays in .NET or lists in F # and Haskell, are monoids over concatenation.  In Haskell, strings <em>are</em> lists, so string concatenation is automatically a monoid.  In .NET, the <code>+</code> operator for strings is a monoid, but only if you pretend that <code>null</code> does not exist.  However, they are all variations of the same monoid. </p><br><p>  It's good that C # uses <code>+</code> for string concatenation, because, as shown in the previous section, addition is the most intuitive and ‚Äúnatural‚Äù of all monoids.  You know school arithmetic, so you can instantly understand the metaphor of addition.  However, a monoid is more than a metaphor.  This is an abstraction that describes special binary operations, one of which (as it happens) is addition.  This is a <em>generalization of the</em> concept - and this is an abstraction that you already know. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  This concludes this article.  There is still a lot of information ahead that will be published in the same way as in the original - in the form of consecutive posts on Habr√©, linked by backward links.  Hereinafter: original articles - ¬© Mark Seemann 2016, translations are made by the JUG.ru Group, translator - Oleg Chirukhin. </p><br><p>  We remind you that you can talk with the author <strong>live</strong> by visiting the <a href="https://dotnext.ru/">DotNext 2017 Moscow</a> conference, which will be held on November 12-13, 2017 in Moscow, in ‚ÄúSlavyanskaya Radisson‚Äù.  Mark will read a report on the topic <a href="https://dotnext-moscow.ru/2017/msk/talks/20wwzs2qeuuykg86cc6ams/">‚ÄúFrom dependency injection to dependency rejection‚Äù</a> .  Tickets are available <a href="https://dotnext-moscow.ru/tickets/">here</a> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/340178/">https://habr.com/ru/post/340178/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340166/index.html">How Android Converts Resource Sizes</a></li>
<li><a href="../340168/index.html">How did we choose Graylog2</a></li>
<li><a href="../340170/index.html">Rust 1.21 release</a></li>
<li><a href="../340172/index.html">Analysis of the latest version of the Dridex malware for identity theft</a></li>
<li><a href="../340176/index.html">The whole web on 60+ FPS: how a new renderer in Firefox got rid of jerks and slowdowns</a></li>
<li><a href="../340180/index.html">Wi-Fi security is compromised due to multiple vulnerabilities found in WPA2</a></li>
<li><a href="../340182/index.html">Critical vulnerabilities detected in WPA2 - Key Reinstallation Attacks (KRACK)</a></li>
<li><a href="../340184/index.html">Introduction to Neural Network Architectures</a></li>
<li><a href="../340186/index.html">How to create a competitive advantage and value of a technological product</a></li>
<li><a href="../340188/index.html">Our cloud-based JS is now ES2017, and this reduces the code by several times.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>