<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SSRF DoS Relaying</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In 2012, SSRF attacks turned from something exotic into a very real threat. The works of Alexander Polyakov, Vladimir Vorontsov and other researchers ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SSRF DoS Relaying</h1><div class="post__text post__text-html js-mediator-article">  In 2012, SSRF attacks turned from something exotic into a very real threat.  The works of Alexander Polyakov, Vladimir Vorontsov and other researchers in this field have made almost a complete picture of the various mechanisms of such attacks and possible consequences.  Nevertheless, since the development of this topic began relatively recently, there is still room for research. <br><br>  This article will examine a small feature of the FTP protocol, thanks to which a vulnerability allowing an SSRF attack to be carried out can be used not only to obtain information or develop an attack vector, but also to relay DoS attacks to both external and internal systems (in including a system with a vulnerability that allows DoS-attack). <br><br><a name="habracut"></a><h4>  A bit of theory from the last century (you can skip) </h4>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      One of the oldest DoS attacks is a SYN-flood.  The attacker falls asleep to the attacked service with SYN packets, ignoring SYN / ACK responses.  Thus, a host of half-open connections appear on the victim's host, and in the end the victim simply becomes unable to respond even to a completely normal and legitimate request to connect to the service.  This method of attack is as old as the Internet itself, and the first official classification, authored by researchers at CERT, appeared as early as 1996.  At the moment there are many ways to deal with SYN-flood, such as SYN-cookies, SYN-caching, filtering and adaptive processing on gateways.  Using a half-open and not fully open connection in a SYN-flood is beneficial not only because the attacked side does not process the responses, but also because any IP address can be substituted into the sent SYN requests, thus hiding the attacker.  Despite the fact that an attack with open connections may be more effective in terms of countering defenses, its correct implementation is much more difficult (if, of course, this is not a DDoS attack).  With SSRF, you can emulate a DoS attack with open connections, and the attacker's IP address will be hidden from the victim in the same way. <br><br><h4>  The essence of the vulnerability </h4><br><br>  Suppose we have a host with a vulnerability that allows an SSRF attack to be performed.  This could be a XXE injection, incorrect server redirect, CRLF splitting of the request, or the simplest file_get_contents () with a user parameter in PHP.  By transferring a URI to the host, we can force it to execute the request using the appropriate protocol.  The first thing that comes to mind regarding DoS relaying is to pass an HTTP-URI of the type <code><a href="http://xn--dos-5cdaanvcjt1bxdjp1a0ak5e1gyc/"></a> dos:/</code>  <code><a href="http://xn--dos-5cdaanvcjt1bxdjp1a0ak5e1gyc/"></a> dos:/</code> .  But, since the HTTP protocol implies that the client sends the request first, the connection between the relay host and the victim host will end quickly.  The choice of other types of URIs is small: except for HTTP, only FTP is supported by almost all common technologies in which SSRF is possible.  At first glance, passing a URI of type <code><a href=""></a> dos:/</code>  <code><a href=""></a> dos:/</code> looks promising, as the FTP client waits for the server greeting (‚Äú220 FTP server ready‚Äù) before sending commands.  But, unfortunately, most FTP clients have a short connection timeout and, without receiving a response from the server within 5‚Äì10 seconds, simply disconnect.  Most server technologies with ‚Äúsupport‚Äù for SSRF will break the connection with a potential victim if the connection within which an SSRF attack occurs is broken.  Another obstacle - the client will instantly disconnect from the server if it receives a message that is different from the standard greeting.  But all is not lost - FTP via SSRF can still be used as a DoS relay.  To do this, just remember about some properties of the protocol. <br><br>  When working with an FTP server, the client uses two connections - control and data transfer.  The first is used to exchange commands and the results of their execution between the client and the server, the second - to directly transfer data (directory listings, text and binary files, etc.).  FTP can operate in two modes - active or passive, the mode of setting up a data connection depends on the mode. <br><br>  In active mode, the FTP client creates a control connection to the server and sends it its IP address and a new port number (different from the client port number of the control connection), and then waits until the server starts a connection to this address and port number. <br><br>  In modern networks, passive mode is most often used, since the client may be behind NAT or a firewall.  The client sends a passive mode command to the server and, having received its IP address and port number from the server, opens a data connection from an arbitrary client port to the received address and port.  The most interesting feature of the passive mode is that, having connected to the data transfer channel of the server, the client will wait until the server starts transmitting the data.  At the same time, the timeouts for this connection in most FTP clients are comparable to the timeouts for TCP connections.  In the past, active mode on an FTP server was widely used to conduct ‚ÄúFTP BOUNCE‚Äù type scans and open connection DoS attacks.  SSRF allows you to use an FTP client in passive mode for conducting open connection DoS attacks. <br><br>  Since, in the data transfer connection mode, the client always waits for data from the server, the following attack pattern can be implemented (see Figure 1).  The attacker raises somewhere the fake FTP server <strong>(0)</strong> , which will transmit the victim's address as the address of the data connection.  In turn, in the SSRF attack as a URI, you can pass <code><a href=""></a> ftp/file.txt</code>  <code><a href=""></a> ftp/file.txt</code> <strong>(1).</strong>  Then the host subject to SSRF (host relay) connects to the fake FTP server and when trying to download a file <strong>(2), it</strong> will receive the address and port of the victim <strong>(3)</strong> as the address and port of the passive connection.  The established connection <strong>(4)</strong> between the relay host and the victim will be active for at least 60 seconds (if the service on the victim host waits for some data from the client, for example, HTTP and LDAP behave this way).  A nice addition: after establishing a data connection, the control connection between the fake FTP server and the host relay <strong>can be broken.</strong>  <strong>The data connection will not be affected until the end of the data transfer or timeout.</strong>  Thus, when an SSRF attack is repeatedly carried out by transferring the fake FTP server address to the host victim, a stream of connections will collapse, <strong>depending</strong> entirely <strong>on the power and settings</strong> of the host relay web server.  At the same time, the load on the fake server is not that big.  If our fake server can process 100 requests per second, by the end of the first minute of the attack, 6000 connections will be established with the victim host.  In addition, the victim host will never know the attacker's IP address. <br><br>  It remains to solve the last problem - how can we transfer the victim's address to the client (relay host)? <br><br><img src="https://habrastorage.org/storage2/e71/18d/1ba/e7118d1baa287f9c63e926d4e29821ff.png"><br>  Attack pattern <br><br>  In the current implementation of FTP, two commands PASV and EPSV are responsible for establishing the passive mode.  Their main difference is in the answer. <br><br>  PASV response syntax: <br>  227 Entering Passive Mode (a1, a2, a3, a4, p1, p2) <br>  (where a1-a4 are the IP address octets in decimal notation, and the port is represented as 256 * p1 + p2) <br>  The syntax of the EPSV command is slightly different: <br>  229 Entering Extended Passive Mode (||| p |) <br>  (where p is the port) <br><br>  Thus, the newer EPSV command (described in RFC 2428) prohibits specifying a different IP address to establish a data connection, and the default FTP client considers this address to be equal to the server address in the control connection.  It would seem that the slim idea of ‚Äã‚Äãattack collapses.  But in reality, if the server responds to the EPSV command ‚Äú500 Command not implemented‚Äù, then the vast majority of implementations of FTP clients will offer the server a PASV command.  And already in it you can send the address and port of the service of the victim.  In most cases, immediately after receiving the RETR (receiving file) command from the FTP client, you can break the connection with the client. <br><br>  Example: Suppose we have a JSP servlet that is vulnerable to XXE and is running Java 1.6.x.  By sending it as an external ENTITY, for example, "&lt;! ENTITY J SYSTEM" <code><a href=""></a> fakeftp.adress/file"&gt;</code>  <code><a href=""></a> fakeftp.adress/file"&gt;</code> ", you can initiate its connection to fake FTP.  That, in turn, for the implementation of the attack should produce the following series of responses to commands: <br><br><blockquote>  220 i58 FTP server ready. <br>  USER anonymous <br>  331 Guest login ok send your email address as password. <br><br>  PASS Java1.6.0_01 @ <br>  230 Guest login ok, access restrictions apply. <br><br>  TYPE I <br>  200 Type set to I. <br><br>  EPSV ALL <strong>(2)</strong> <br>  <strong>500 Command not implemented, superfluous at this site.</strong>  <strong>(2)</strong> <br><br>  PASV <strong>(2)</strong> <br>  <strong>227 Entering Passive Mode (vic, tim, server, ip, 0.80).</strong>  <strong>(3)</strong> <br><br>  RETR file <br>  <strong>150 Opening BINARY mode data connection for 'file' (5,000,000 bytes).</strong> </blockquote><br>  [here the fake FTP server can easily break the connection] <br><br><img src="https://habrastorage.org/storage2/7ad/c55/33c/7adc5533c333e9681bf4d3a58e179c40.png"><br><br>  How it looks in WireShark (192.168.200.138 - fake FTP, 192.168.200.128 - relay, 46.4.xx - victim) <br><br>  A certain subtlety lies in the fact that fake FTP needs to respond with an error to any active mode commands (eg EPRT) and passive mode new formation commands (EPSV, EPSV ALL) so that the FTP client has no choice but to use the old PASV command.  In addition, a sufficient file size must be specified in the response to the RETR command in order for the FTP client to continue to maintain the connection, even if the attacked service sends it some data. <br><br>  Different web technologies exposed to SSRF attacks have different implementations of FTP clients.  These implementations have their own properties, which impose a restriction on the use of DoS-relaying by means of the <code>ftp://</code> URI scheme.  Summary characteristics of customers are presented in the table: <br><br><br><table border="1"><tbody><tr><td>  Php </td><td>  <strong>+</strong> <strong>*</strong> </td></tr><tr><td>  cURL </td><td>  <strong>+</strong> </td></tr><tr><td>  Java 1.6 </td><td>  <strong>+</strong> <strong>*</strong> </td></tr><tr><td>  Java 1.7 </td><td>  <strong>Data connections only</strong> <strong><br></strong>  <strong>with 127.0.0.1 and the address of the FTP server</strong> <strong>*</strong> </td></tr><tr><td>  Lwp </td><td>  <strong>+</strong> <strong>*</strong> </td></tr><tr><td>  ASP.Net </td><td>  <strong>-</strong> <strong>**</strong> </td></tr><tr><td>  Python </td><td>  <strong>+</strong> </td></tr></tbody></table><br><br>  * In some cases, there is no need for a fake FTP server, since the controlling FTP connection in this technology has a timeout of 60 seconds, and if the attacked service does not return (incorrect) data, then you can send the URI to the SSRF attack directly <code><a href=""></a> /file.txt</code>  <code><a href=""></a> /file.txt</code> .  If you are lucky, the FTP connection will not be terminated, even if the connection within which the SSRF attack occurred is closed. <br><br>  ** In ASP.Net with XXE injection, a controlling FTP connection to a remote host is established with a timer of 60 seconds.  In addition, when the connection is broken, within which the SSRF attack occurred, the connection with the victim remains.  So, despite the lack of support for PASV, a direct attack with a relay is possible. <br><br>  It's funny, but in Java 1.7 it is forbidden to establish a data connection with an address other than the address of the control connection, even if the PASV command is used.  But, making this edit, the developers <em>forgot</em> about the local loop, that is, you can use this technique for DoS'a internal host services, even closed by a firewall.  As a real example, one of the old versions of SAP Portal, in which an SSRF attack through XXE was possible, can be cited.  The portal went down with = &lt;50 requests with SSRF and relaying the attack on the local SAP web server using URIs with the FTP protocol. <br><br><h4>  Protection </h4><br><br>  How can you protect against this kind of attack?  It is clear that if there are no vulnerabilities leading to SSRF, then this technique will not work.  If we omit the reasoning on the fact that in the modern world there are no FTP servers left without RFC 2428 support and that all developers of FTP client libraries should mandately prohibit the use of the PASV command, then ... You can do it the way Oracle developers did in the latest version of Java - prohibit the establishment of data transfer connections with hosts other than the local loop and the FTP server itself.  But, as you can see, this ‚Äúedit‚Äù does not provide complete protection against DoS relaying.  Some kind of guarantee against such attacks is provided only by strict filtering of outgoing connections, and in this case it can be done by the server administrator or the information security engineer, but this is a situation where the medication may be more dangerous than the disease.  But it still doesn't save from relaying DoS through a local loop. <br><br>  Nothing absolutely new or previously unrevealed has been described above, but it is doubly amusing to see how the discovery of new types of attacks on systems allows reviving long-forgotten techniques. <br><br>  <i>The author of the article is Digital Security analyst Alexander Bolshev, unfortunately, not yet having an account on Habr√©.</i> <i><br></i>  <i>UPD: thanks <a href="https://habrahabr.ru/users/genome_x/" class="user_link">Genome_X</a> account appeared - meet the user <a href="https://habrahabr.ru/users/dark_k3y/" class="user_link">dark_k3y</a> !</i> </div><p>Source: <a href="https://habr.com/ru/post/171549/">https://habr.com/ru/post/171549/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171539/index.html">Plugin to extract data from sites</a></li>
<li><a href="../171541/index.html">New geolocation service Maptrix: feel the difference</a></li>
<li><a href="../171543/index.html">About JSDB Benefits</a></li>
<li><a href="../171545/index.html">Software Requirements: Collection and Documentation Guidelines</a></li>
<li><a href="../171547/index.html">All in 1: Fujitsu ESPRIMO X913-T Monoblock</a></li>
<li><a href="../171551/index.html">Hackathon for mobile developers in Moscow</a></li>
<li><a href="../171555/index.html">Windows Azure VMs: Data Disk, Virtual Networks, and Availability Set</a></li>
<li><a href="../171557/index.html">Using XSLT to Prevent XSS by Filtering Custom Content</a></li>
<li><a href="../171559/index.html">Design Pattern "Specification"</a></li>
<li><a href="../171561/index.html">Frequently asked questions about asm.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>