<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write a serializer for a network game in C ++ 11</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I was inspired to write this post by the wonderful article in the Gaffer on Games blog ‚ÄúReading and Writing Packets‚Äù and the irrepressible urge to aut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write a serializer for a network game in C ++ 11</h1><div class="post__text post__text-html js-mediator-article"><img align="right" width="250" src="https://habrastorage.org/files/e5e/306/680/e5e30668003f4348a50a52e174b0c5db.png">  I was inspired to write this post by the wonderful <a href="http://gafferongames.com/building-a-game-network-protocol/reading-and-writing-packets/">article in the Gaffer on Games blog ‚ÄúReading and Writing Packets‚Äù</a> and the irrepressible urge to automate everything (especially writing code in C ++!). <br><br>  Let's start with the problem statement.  We write a network game (and immediately MMORPG, of course!), And regardless of the architecture, we have the need to constantly send and receive data over the network.  Most likely, we will need to send several different types of packages (actions of players, updates of the game world, simply authentication, in the end!), And for everyone we should have a read function and a write function.  It would seem that it is not a question to sit down and write calmly these two functions and not be nervous, however, we immediately have a number of problems. <br><br><ul><li>  The choice of format.  If we were writing a simple JavaScript game, we would be satisfied with JSON or any samopisny relative of it.  But we are writing a serious multiplayer game that is demanding for traffic;  we cannot afford to send ~ 16 bytes to float instead of four.  So, we need a raw binary format.  However, binary data complicates debugging;  It would be great if we could change the format at any time, without rewriting all our read / write functions. </li><li> Security issues.  The first rule of the network game: <i>do not trust the data sent by the client</i> !  The reading function should be able to terminate at any time and return <code>false</code> if something went wrong.  However, using exceptions is considered a bad idea, since they are too slow.  Mamkin hacker even if it does not break your server, but it can quite significantly slow down its continuous exept.  But manually writing code consisting of ifs and returns is unpleasant and unaesthetic. </li><li>  Duplicate code.  The functions of reading and writing are similar, but not quite.  The need to change the structure of the package leads to the need to change <i>two</i> functions, which sooner or later will lead to the fact that you forget to change one of them or change them differently, which will lead to difficult bugs to be caught.  As Gaffer on Games rightly notes, <i>it is</i> </li></ul><br>  All interested in how Bender fulfilled his promise and at the same time solved the indicated problems, please under the cat. <br><a name="habracut"></a><br><h2>  Read and write streams </h2><br>  Let's start with the initial assumptions.  We want to be able to write and read text and binary formats;  Let the text format be read and written from / to standard STL streams ( <code>std::basic_istream</code> and <code>std::basic_ostream</code> , respectively).  For a binary format, we will have our own <code>BitStream</code> class that supports the same STL <code>BitStream</code> interface (at least the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators, the <a href="http://en.cppreference.com/w/cpp/io/basic_ios/rdstate"><code>rdstate()</code></a> method, which returns 0 if there are no read / write errors and not 0 otherwise, and the ability to eat <a href="http://en.cppreference.com/w/cpp/io/manip">manipulators</a> ) ;  It would also be great if he could write and read data lengths that are not a multiple of eight bits. <br><div class="spoiler">  <b class="spoiler_title">Possible interface BitStream class</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> byte = <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BitStream</span></span></span><span class="hljs-class"> {</span></span> byte* bdata; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> length, allocated; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mode; <span class="hljs-comment"><span class="hljs-comment">// 0 = read, other = write int state; // 0 = OK void reallocate(size_t); public: static const int MODE_READ = 0; // ,  ,   static const int MODE_WRITE = 1; // enum class,    inline int get_mode(void) const noexcept { return mode; } BitStream(void); //   BitStream(void*, uint64_t); //   ~BitStream(void); int rdstate(void) const; //   how_much : void write_bits(char how_much, uint64_t bits); //  how_much     : uint64_t read_bits(char how_much); void* data(void); BitStream&amp; operator&lt;&lt;(BitStream&amp;(*func)(BitStream&amp;)); //  BitStream&amp; operator&gt;&gt;(BitStream&amp;(*func)(BitStream&amp;)); //  }; template&lt;typename Int&gt; typename std::enable_if&lt;std::is_integral&lt;Int&gt;::value, BitStream&amp;&gt;::type operator&lt;&lt;(BitStream&amp; out, const Int&amp; arg); //  8*sizeof(Int)    template&lt;typename Int&gt; typename std::enable_if&lt;std::is_integral&lt;Int&gt;::value, BitStream&amp;&gt;::type operator&gt;&gt;(BitStream&amp; in, Int&amp; arg); //  8*sizeof(Int)   </span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Why enable_if here and how does it work?</b> <div class="spoiler_text">  <a href="http://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if&lt;condition, T&gt;</code></a> checks the condition <code>condition</code> and, if it is satisfied (that is, non-zero), determines the type <code>std::enable_if&lt;...&gt;::type</code> equal to the user-specified type <code>T</code> or (by default) <code>void</code> .  If the condition is not met, a call to <code>std::enable_if&lt;...&gt;::type</code> produces undefined;  such an error will prevent our template from compiling, but it will not prevent the program from compiling, since <a href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">substitution failure is not an error (SFINAE)</a> - an error during the substitution of arguments into the template is not a compilation error.  The program will compile successfully if another implementation of <code>operator&lt;&lt;</code> with a suitable signature is defined somewhere, or it says that there is simply no suitable function to call (the smart compiler may specify that he tried, but SFINAE happened). <br></div></div><br></div></div><br><h2>  Serializer interface </h2><br>  It is clear that now we need the basic ‚Äúbuilding blocks‚Äù of the serializer: functions or objects that can serialize and parse whole or floating point numbers.  However, we (of course!) Want extensibility, i.e.  so that the programmer could write a ‚Äúbrick‚Äù to serialize any of his data types and use it in our serializer.  How should such a brick look?  I suggest the simplest format: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntegerField</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutputStream</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">serialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutputStream</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">out</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">int</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">t</span></span></span><span class="hljs-class">) {</span></span> out &lt;&lt; t; <span class="hljs-comment"><span class="hljs-comment">//      ! } //       bool,    template&lt;class InputStream&gt; static bool deserialize(InputStream&amp; in, int&amp; t) { in &gt;&gt; t; //      ! return !in.rdstate(); //  true,       } };</span></span></code> </pre><br>  Just a class with two static methods and, possibly, an unlimited number of their overloads.  (So, instead of one template method, it is allowed to write several: one for <code>std::basic_ostream</code> , one for <code>BitStream</code> , an unlimited number for any other stream to the taste of the programmer.) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For example, for serialization and parsing of a dynamic array of elements, the interface might look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ArrayField</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutputStream</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">serialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutputStream</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">out</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">* </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutputStream</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">void</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">serialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutputStream</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">out</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;&amp; data); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputStream</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deserialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputStream</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">size_t</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">n</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">*&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputStream</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">static</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bool</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">deserialize</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InputStream</span></span></span><span class="hljs-class">&amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">in</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;T&gt;&amp; data); };</code> </pre><br><h2>  Auxiliary templates <code>can_serialize</code> and <code>can_deserialize</code> </h2><br>  Next, we need to be able to check if such and such a field can start serialization / parsing with such and such arguments.  Here we come to a more detailed discussion of the variadic tempates and SFINAE. <br><br>  Let's start with the code: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TypeList</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//   ,  ¬´ ¬ª static const size_t length = sizeof...(Types); }; template&lt;typename F, typename L&gt; class can_serialize; template&lt;typename F, typename... Ts&gt; class can_serialize&lt;F, TypeList&lt;Ts...&gt;&gt; { template &lt;typename U&gt; static char func(decltype(U::serialize(std::declval&lt;Ts&gt;()...))*); template &lt;typename U&gt; static long func(...); public: static const bool value = ( sizeof(func&lt;F&gt;(0)) == sizeof(char) ); };</span></span></code> </pre><br>  <b>What is it?</b>  This is a structure that, at the compilation stage, determines, given a class <code>F</code> and a list of types <code>L = TypeList&lt;Types...&gt;</code> , whether it is possible to call the function <code>F::serialize</code> with arguments of these types.  For example, <pre> <code class="cpp hljs">can_serialize&lt;IntegerField, TypeList&lt;BitStream&amp;, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; &gt;::value</code> </pre>  equals 1, like <pre> <code class="cpp hljs">can_serialize&lt;IntegerField, TypeList&lt;BitStream&amp;, <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&amp;&gt; &gt;::value</code> </pre>  (because <code>char&amp;</code> converts nicely to <code>int</code> ), however <pre> <code class="cpp hljs">can_serialize&lt;IntegerField, TypeList&lt;BitStream&amp;&gt; &gt;::value</code> </pre>  equal to 0, since <code>IntegerField</code> does not provide a <code>serialize</code> method that accepts only output stream as input. <br><br>  <b>How it works?</b>  A more subtle question, let's figure it out. <br><br><img align="right" width="250" src="https://habrastorage.org/files/ba0/ff6/3db/ba0ff63db38d4256b46d0452d5a75ac9.png">  Let's start with the <code>TypeList</code> class.  Here we use the <i>variadic templates</i> promised by Bender, that is, <i>templates with a variable number of arguments</i> .  The <code>TypeList</code> class <code>TypeList</code> accepts an arbitrary number of type arguments, which are placed in the <i>parameter pack</i> under the name <code>Types</code> .  (I wrote more about how to use parameter packs in the <a href="https://habrahabr.ru/post/248897/">previous article</a> .) Our <code>TypeList</code> class <code>TypeList</code> n‚Äôt do anything useful, but in general we can do quite a lot with the parameter pack.  For example, the design <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;Ts&gt;()...</code> </pre>  for the parameter pack of length 4 containing the types <code>T1, T2, T3, T4</code> , will open when compiled into <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;T1&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;T2&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;T3&gt;(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;T4&gt;()</code> </pre><br>  Further.  We have a <code>can_serialize</code> template that accepts a class <code>F</code> and a list of types <code>L</code> , and partial specialization giving us access to the types themselves in the list.  (If you request <code>can_serialize&lt;F, L&gt;</code> , where <code>L</code> not a list of types, the compiler will complain about an undefined template (undefined template), and it will be divided.) In this partial specialization, all the magic goes. <br><br>  In its code, there is a call to <code>func&lt;F&gt;(0)</code> inside <code>sizeof</code> .  The compiler will have to determine which of the function overloads <code>func</code> is called to calculate the size returned in bytes, but it will not try to compile it, and therefore we are not waiting for errors like ‚ÄúI don‚Äôt find your function‚Äù (as well as "There is some kind of crap in the function body", if this body were).  First, he will try to use the first definition of <code>func</code> , a very intricate look: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( U::serialize( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;Ts&gt;()... ) )* )</span></span></span></span>;</code> </pre><br>  The <code>decltype</code> construct <code>decltype</code> type of the expression in brackets;  for example, <code>decltype(10)</code> is the same as <code>int</code> .  But, like <code>sizeof</code> , it does not compile it;  this allows the focus to work with <code>std::declval</code> .  <code>std::declval</code> is a function that <i>pretends</i> to return an rvalue reference of the desired type;  it makes the expression <code>U::serialize( std::declval&lt;Ts&gt;()... )</code> meaningful and mimicking a real call to <code>U::serialize</code> , even if half of the arguments do not have a default constructor and we cannot simply write <code>U::serialize( Ts()... )</code> (not to mention that this function may require lvalue-references! <code>declval</code> way, in this case <code>declval</code> will <code>declval</code> lvalue-reference, because according to the rules of C ++, <code>T&amp; &amp;&amp;</code> is <code>T&amp;</code> ).  It, of course, has no realization;  write in plain code <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::declval&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;();</code> </pre>  - bad idea. <br><br><img align="right" width="200" src="https://habrastorage.org/files/f2b/d81/759/f2bd8175914d4d90a8eb5c4b41bb3ca5.png">  So here.  If a call inside <code>decltype</code> impossible (there is no function with such a signature or its substitution causes an error for some reason) - the compiler considers that a substitution failure error has occurred, which, as we know, is not an error (SFINAE).  And he calmly goes on, trying to use the following definition of <code>func</code> , in which no problems are already foreseen.  However, another function returns a result of a different size, which can be easily caught using <code>sizeof</code> .  (In fact, not so easy, and <code>sizeof(long)</code> may well be equal to <code>sizeof(char)</code> on exotic platforms, but omitting these details is all fixable.) <br><br>  As food for self-reflection, I will also give the code of the <code>can_deserialize</code> template, which is a little bit more complicated: it not only checks whether <code>F::deserialize</code> can be called with the specified argument types, but also makes sure that the type of result is equal to <code>bool</code> . <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> L&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">can_deserialize</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Ts&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">can_deserialize</span></span></span><span class="hljs-class">&lt;F, TypeList&lt;Ts...&gt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::enable_if&lt; </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_same&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">(U::deserialize(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::declval&lt;Ts&gt;()...)), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;::value &gt;::type* )</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> U&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = can_deserialize; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> value = ( <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(func&lt;F&gt;(<span class="hljs-number"><span class="hljs-number">0</span></span>)) == <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) ); };</code> </pre><br><h2>  We collect packages from bricks </h2><br>  Finally, time to do the content part of the serializer.  In short, we want to get the <code>Schema</code> template class, which would provide the <code>serialize</code> and <code>deserialize</code> functions built from ‚Äú <code>deserialize</code> blocks‚Äù: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyPacket = Schema&lt;IntegerField, IntegerField, FloatField, ArrayField&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt;&gt;; MyPacket::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">0.3</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> da, db; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fc; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>&gt; my_vector; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> success = MyPacket::deserialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cin</span></span>, da, db, fc, my_vector);</code> </pre><br>  Let's start with a simple one - declarations of a template class (with a variable number of arguments, nya!) And the end of recursion. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Fields&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Schema</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Schema</span></span></span><span class="hljs-class">&lt;&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputStream&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutputStream&amp;)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ! } template&lt;typename InputStream&gt; static bool deserialize(InputStream&amp;) { return true; //   --  ! } };</span></span></code> </pre><br>  But what should the code of the function <code>serialize</code> look like in a scheme with a non-zero number of fields?  We cannot calculate the types accepted by the <code>serialize</code> functions of all these fields in advance, and we cannot combine them: this would require the not yet included standard <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3866.html">invocation type traits</a> .  It remains only to make a function with a variable number of arguments and send as many of them to each field as it can eat - this is where the <code>can_serialize</code> born in torment will come in handy for <code>can_serialize</code> . <br><br>  For such a recursion by the number of arguments, we need an auxiliary class (the main <code>Schema</code> class will deal with recursion by the number of fields).  Define it without stint on the arguments: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-comment"><span class="hljs-comment">//  , serialize     typename NextSerializer, //    ¬´¬ª  typename OS, //    typename TL, //  ,     F::serialize bool can_serialize //       &gt; struct SchemaSerializer;</span></span></code> </pre><br>  Then <code>Schema</code> partial specialization, which finally implements recursion by the number of fields, takes the form <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Fields&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Schema</span></span></span><span class="hljs-class">&lt;F, Fields...&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputStream, <span class="hljs-comment"><span class="hljs-comment">//    typename... Types //      &gt; static void serialize(OutputStream&amp; out, Types&amp;&amp;... args) { //   serialize  : SchemaSerializer&lt; F, //   Schema&lt;Fields...&gt;, //     OutputStream&amp;, //    TypeList&lt;Types...&gt;, //     can_serialize&lt;F, TypeList&lt;OutputStream&amp;, Types...&gt;&gt;::value // !!! &gt;::serialize(out, std::forward&lt;Types&gt;(args)...); } // . . . (    deserialize) };</span></span></code> </pre><br>  Now we will write a recursion for <code>SchemaSerializer</code> .  Let's start with a simple - from the end: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NextSerializer, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OS&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SchemaSerializer</span></span></span><span class="hljs-class">&lt;F, NextSerializer, OS, TypeList&lt;&gt;, false&gt; {</span></span> <span class="hljs-comment"><span class="hljs-comment">//      ,    . //   (  )  F::serialize //   .  ,     //  --  - ,   //  no such function serialize(...)   . }; template&lt;typename F, typename NextSerializer, typename OS&gt; struct SchemaSerializer&lt;F, NextSerializer, OS, TypeList&lt;&gt;, true&gt; { //        --  ! -- F::serialize //     ! (   ) template&lt;typename... TailArgs&gt; //   static void serialize(OS&amp; out, TailArgs&amp;&amp;... targs) { F::serialize(out); //    ,  // (    out - ) //      : NextSerializer::serialize(out, std::forward&lt;TailArgs&gt;(targs)...); } };</span></span></code> </pre><br><img align="right" width="200" src="https://habrastorage.org/files/7f4/c82/c06/7f4c82c06c8b4e3081c115605b923f8b.png">  Here we come to the second concept promised by Bender - <i>perfect forwarding</i> .  We received extra arguments (maybe zero arguments, but most likely not), and we want to send them further to <code>NextSerializer::serialize</code> .  In the case of templates, this is a problem known as the perfect forwarding problem. <br><br><h2>  Perfect forwarding </h2><br>  Suppose you want to write a wrapper around a template function <code>f</code> that takes one argument.  For example, <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">better_f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"I'm so much better..."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; f(arg); }</code> </pre>  It looks good, however, it breaks immediately if <code>f</code> takes an input <code>T&amp;</code> lvalue as input, and not just <code>T</code> : the original function <code>f</code> will receive a reference to the temporary object as the type T will be calculated (deduced) as a type without a link.  The solution is simple: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">better_f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"I'm so much better..."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; f(arg); }</code> </pre>  And again, it breaks immediately if <code>f</code> takes an argument by value: literals and other rvalues ‚Äã‚Äãcould be sent to the original function, but not to the new function. <br>  We'll have to write both options so that the compiler can choose and full compatibility is present in both cases: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">better_f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp; arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"I'm so much better..."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; f(arg); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">better_f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&amp; arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"I'm so much better..."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; f(arg); }</code> </pre>  And this whole circus is for one function with one argument.  As the number of arguments grows, the number of required overloads for a full wrapper will grow exponentially. <br><br>  To combat this, C ++ 11 introduces rvalue reference and new type calculation rules.  Now you can write just <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">better_f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"I'm so much better..."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-comment"><span class="hljs-comment">// ? . . }</span></span></code> </pre>  The &amp;&amp; modifier in the context of type evaluation has a special meaning (although it can be easily confused with a regular rvalue reference).  If an lvalue-reference to an object of type <code>type</code> is passed to the function, type T will now be guessed as <code>type&amp;</code> ;  if an rvalue of type <code>type</code> is passed, type T will be guessed as <code>type&amp;&amp;</code> .  The last thing left to do for pure perfect forwarding without copying the default arguments is to use <code>std::forward</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">better_f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T&amp;&amp; arg)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"I'm so much better..."</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; f(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;T&gt;(arg)); }</code> </pre>  <code>std::forward</code> does not touch regular links and turns objects passed by value into rvalue links;  thus, after the first wrapper, a rvalue-link will go further along the chain of wrappers (if any), instead of the object itself, eliminating unnecessary copies. <br><br><h2>  We continue the serializer </h2><br>  So, the design <br><pre> <code class="cpp hljs">NextSerializer::serialize(out, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TailArgs&gt;(targs)...);</code> </pre>  performs perfect forwarding, sending all the "extra" arguments unchanged further down the chain of serializers. <br><br>  Continue writing recursion for the <code>SchemaSerializer</code> .  Recursion step for <code>can_serialize = false</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NextSerializer, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OS, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SchemaSerializer</span></span></span><span class="hljs-class">&lt;F, NextSerializer, OS, TypeList&lt;Types...&gt;, false&gt;:</span></span> <span class="hljs-comment"><span class="hljs-comment">//     F::serialize   -- //    ;  ,   //   serialize public SchemaSerializer&lt;F, NextSerializer, OS, typename Head&lt;TypeList&lt;Types...&gt;&gt;::Result, //  ,   can_serialize&lt;F, typename Head&lt;TypeList&lt;OS, Types...&gt;&gt;::Result&gt;::value // !!! &gt; { //      ¬Ø\_(„ÉÑ)_/¬Ø };</span></span></code> </pre><div class="spoiler">  <b class="spoiler_title">The implementation of the auxiliary class Head, which cuts the last element from the type list</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Head</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-comment"><span class="hljs-comment">//      ... template&lt;typename... Ts&gt; struct Concatenate; //       ! template&lt;&gt; struct Concatenate&lt;&gt; { using Result = EmptyList; }; template&lt;typename... A&gt; struct Concatenate&lt;TypeList&lt;A...&gt;&gt; { using Result = TypeList&lt;A...&gt;; }; template&lt;typename... A, typename... B&gt; struct Concatenate&lt;TypeList&lt;A...&gt;, TypeList&lt;B...&gt;&gt; { using Result = TypeList&lt;A..., B...&gt;; }; template&lt;typename... A, typename... Ts&gt; struct Concatenate&lt;TypeList&lt;A...&gt;, Ts...&gt; { using Result = typename Concatenate&lt; TypeList&lt;A...&gt;, typename Concatenate&lt;Ts...&gt;::Result &gt;::Result; }; //  ,  ++   // template&lt;typename T, typename... Ts&gt; // struct Head&lt;TypeList&lt;Ts..., T&gt;&gt;,   //      template&lt;typename T, typename... Ts&gt; struct Head&lt;TypeList&lt;T, Ts...&gt;&gt; { using Result = typename Concatenate&lt;TypeList&lt;T&gt;, typename Head&lt;TypeList&lt;Ts...&gt;&gt;::Result&gt;::Result; }; template&lt;typename T, typename Q&gt; struct Head&lt;TypeList&lt;T, Q&gt;&gt; { using Result = TypeList&lt;T&gt;; }; template&lt;typename T&gt; struct Head&lt;TypeList&lt;T&gt;&gt; { using Result = TypeList&lt;&gt;; }; template&lt;&gt; struct Head&lt;TypeList&lt;&gt;&gt; { using Result = TypeList&lt;&gt;; };</span></span></code> </pre></div></div><br>  Recursion step for <code>can_serialize = true</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NextSerializer, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OS, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SchemaSerializer</span></span></span><span class="hljs-class">&lt;F, NextSerializer, OS, TypeList&lt;Types...&gt;, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... TailTypes&gt; <span class="hljs-comment"><span class="hljs-comment">//   static void serialize(OS&amp; out, Types... args, TailTypes&amp;&amp;... targs) { F::serialize(out, std::forward&lt;Types&gt;(args)...); // (    out - ) //      : NextSerializer::serialize(out, std::forward&lt;TailTypes&gt;(targs)...); } };</span></span></code> </pre><br><img align="right" width="200" src="https://habrastorage.org/files/fcf/2da/004/fcf2da0046ed4e12bb0ddc069703e323.gif">  Iiiii ... that's all!  On this our serializer (in the most general terms) is ready, and the simplest code <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyPacket = Schema&lt; IntegerField, IntegerField, CharField &gt;; MyPacket::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-number"><span class="hljs-number">777</span></span>, <span class="hljs-number"><span class="hljs-number">6666</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>);</code> </pre>  successfully displays <br><pre> <code class="bash hljs">7776666a</code> </pre>  But how is deserialized?  You still need to add spaces.  A decent (that is, fairly abstract for tru-C ++) way to do this is to gash a field separator: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CharT</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Traits</span></span></span><span class="hljs-class"> &gt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">std</span></span></span><span class="hljs-class">:</span></span>:basic_ostream&lt;CharT, Traits&gt;&amp; delimiter( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::basic_ostream&lt;CharT, Traits&gt;&amp; os ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> os &lt;&lt; CharT(<span class="hljs-string"><span class="hljs-string">' '</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   std::ostream   } template&lt; class CharT, class Traits &gt; std::basic_istream&lt;CharT, Traits&gt;&amp; delimiter( std::basic_istream&lt;CharT, Traits&gt;&amp; is ) { return is; //         } BitStream&amp; delimiter(BitStream&amp; bs) { return bs; //     --   ,   ! // (       , //     ) }</span></span></code> </pre>  <code>std::basic_ostream</code> can eat functions that accept and return a reference to it (how do you think <code>std::endl</code> , <code>std::flush</code> ? is arranged), so now all the serialization code is rewritten as <pre> <code class="cpp hljs">serialize(OS&amp; out, ...) { F::serialize(out, ...); out &lt;&lt; delimiter; <span class="hljs-comment"><span class="hljs-comment">//    NextSerializer::serialize(out, ...); }</span></span></code> </pre>  After which we get the regular (and ready for deserialization) <pre> <code class="bash hljs">777 6666 a</code> </pre>  But still there is a small detail ... <br><br><h2>  Nesting </h2><br>  Since our circuits have the same interface as simple fields, why not make a circuit from circuits? <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyBigPacket = Schema&lt;MyPacket, IntegerField, MyPacket&gt;; MyBigPacket::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-number"><span class="hljs-number">44</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>);</code> </pre>  Compile iii ... we get no matching function for call to 'serialize'.  What's the matter? <br><br>  The fact is that <code>Schema::serialize</code> eats up all the arguments that are given to it.  The external scheme sees that <code>Schema::serialize</code> can be called with all the arguments thrown, well, it calls.  The compiler compiles and sees that the last four arguments are out of work ( <i>candidate function template not viable: requires 1 argument, but 5 were provided</i> ), well, it reports an error. <br><br>  The advantage of SFINAE has crawled out here as a disadvantage.  The compiler does not compile the function before determining whether it can be called with the specified arguments or not;  he just looks at her type.  To eliminate this undesirable behavior, we must force <code>Schema::serialize</code> be of an invalid type if inappropriate arguments are passed to it. <br><br>  We will do this immediately for the <code>Schema</code> and <code>SchemaSerializer</code> - it's easier.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suppose that </font></font><code>Schema</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">it has already been done </font><font style="vertical-align: inherit;">for </font><font style="vertical-align: inherit;">this, and its function </font></font><code>serialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">is of invalid type with invalid arguments. </font><font style="vertical-align: inherit;">We modify some specialties of our class </font></font><code>SchemaSerializer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NextSerializer, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OS&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SchemaSerializer</span></span></span><span class="hljs-class">&lt;F, NextSerializer, OS, TypeList&lt;&gt;, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... TailArgs&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OS&amp; out, TailArgs&amp;&amp;... targs)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NextSerializer::serialize(out, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;TailArgs&gt;(targs)...))</span></span></span><span class="hljs-function"> </span></span>{ F::serialize(out); out &lt;&lt; delimiter; NextSerializer::serialize(out, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TailArgs&gt;(targs)...); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> NextSerializer, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OS, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Types&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SchemaSerializer</span></span></span><span class="hljs-class">&lt;F, NextSerializer, OS, TypeList&lt;Types...&gt;, true&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... TailTypes&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OS&amp; out, Types... args, TailTypes&amp;&amp;... targs)</span></span></span><span class="hljs-function"> -&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decltype</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(NextSerializer::serialize(out, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::forward&lt;TailTypes&gt;(targs)...))</span></span></span><span class="hljs-function"> </span></span>{ F::serialize(out, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Types&gt;(args)...); out &lt;&lt; delimiter; NextSerializer::serialize(out, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;TailTypes&gt;(targs)...); } };</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What happened? </font><font style="vertical-align: inherit;">First, we used the new syntax. </font><font style="vertical-align: inherit;">Starting from C ++ 11, the following methods are equivalent to specifying the type of the function result:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">type </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ ... } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> -&gt; type </span></span>{ .. }</code> </pre><br>  Why do you need it?     . ,    ,      <code>std::declval</code> ,          <code>type</code>  <i>  </i>  ,    ‚Äî . <br><br>   , , ?   :     <code>NextSerialize::serialize</code>     ,  <code>NextSerialize::serialize(out, std::forward&lt;TailTypes&gt;(targs)...)</code>      .    ( ,    )   ;      <code>SchemaSerializer::serialize</code>   .   ,          ,   <code>Schema::serialize</code>  -  , <i>    </i> .     <code>Schema</code> : <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> F, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Fields&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Schema</span></span></span><span class="hljs-class">&lt;F, Fields...&gt; {</span></span> <span class="hljs-comment"><span class="hljs-comment">//  using ( , ++11!) template&lt;class OutputStream, typename... Types&gt; using Serializer = SchemaSerializer&lt; F, //   Schema&lt;Fields...&gt;, //     OutputStream&amp;, //    TypeList&lt;Types...&gt;, //     can_serialize&lt;F, TypeList&lt;OutputStream&amp;, Types...&gt;&gt;::value // !!! &gt;; template&lt; typename OS, //    typename... Types //      &gt; static auto serialize(OS&amp; out, Types&amp;&amp;... args) -&gt; decltype(Serializer&lt;OS, Types...&gt;::serialize(out, std::forward&lt;Types&gt;(args)...) ) { Serializer&lt;OS, Types...&gt;::serialize(out, std::forward&lt;Types&gt;(args)...); } // . . . };</span></span></code> </pre><br>  Fine!      <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyPacket = Schema&lt; IntegerField, IntegerField, CharField &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyBigPacket = Schema&lt; MyPacket, IntegerField, MyPacket &gt;; MyBigPacket::serialize(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span>, <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-number"><span class="hljs-number">22</span></span>, <span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-number"><span class="hljs-number">33</span></span>, <span class="hljs-number"><span class="hljs-number">44</span></span>, <span class="hljs-number"><span class="hljs-number">55</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>);</code> </pre><br><img align="right" width="200" src="https://habrastorage.org/files/232/5e1/7b3/2325e17b3ce54244a6c79ed72d146e52.jpg">     <pre> <code class="bash hljs">11 22 a 33 44 55 b</code> </pre><br><br>   ! <br><br><h2>  Conclusion </h2><br> C++   ,   C++11    .       ,      ,    .        ,         <code>serialize</code>   ;       ; ,    ‚Äî     ,       .  ,     <code>SchemaDeserializer</code> ,   <code>deserialize</code> ‚Äî     .     ‚Äî          ( ,    ,             ..),       /. <br><br>      <a href="https://github.com/Saluev/cxx11_serializer">  Github</a> . <br><br>          ()  . ,           !  Thanks for attention. </div><p>Source: <a href="https://habr.com/ru/post/303368/">https://habr.com/ru/post/303368/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303358/index.html">Russia's place in the global digital transformation</a></li>
<li><a href="../303360/index.html">We work with a budget institution. Part 1</a></li>
<li><a href="../303362/index.html">Why do those who work a little have higher productivity?</a></li>
<li><a href="../303364/index.html">As an sql query, retrieve information from the database that is not there.</a></li>
<li><a href="../303366/index.html">REST API on Symfony, FOSRestBundle + GlavwebDatagridBundle</a></li>
<li><a href="../303370/index.html">Tony Robbins seminar review ‚ÄúFree your inner strength‚Äù. Day 4. The power of clean energy (part 2)</a></li>
<li><a href="../303372/index.html">Connect MATLAB to Wolfram Mathematica</a></li>
<li><a href="../303374/index.html">2-3-tree. Naive implementation</a></li>
<li><a href="../303376/index.html">CodeRush for Roslyn: Part 2 - feature overview for better code</a></li>
<li><a href="../303378/index.html">Determine the Phantom bots</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>