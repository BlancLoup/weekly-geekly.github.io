<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We realize video calls in an iOS application (by the example of a children's monitor and without WebRTC)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this post we will talk about how to write an application - baby monitor, when you install one device (tablet) near the child‚Äôs crib, and take the s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We realize video calls in an iOS application (by the example of a children's monitor and without WebRTC)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/1a0/e69/183/1a0e691830058df490b05fb3876189e6.png" alt="image" align="left">  In this post we will talk about how to write an application - baby monitor, when you install one device (tablet) near the child‚Äôs crib, and take the second (phone) with you, say to the kitchen, and occasionally look after the child through the screen . <br><br>  As a new parent, I want to say that such an application saves a lot of nerves - no need to listen to every rustle or children's cry from the street, you can make sure with a glance that everything is in order with the child.  A little about the technical part: the application uses our <a href="http://quickblox.com/developers/SimpleSample-videochat-ios">iOS video chat</a> library, including the server part (signaling and TURN server for NAT traversal), this is all in the public domain.  The video stream will work both through Wi-Fi, and through 2G / 3G / 4G.  Until recently, in the appstore, there was no application for a children's video monitor that would work via the mobile Internet (apparently due to difficulties with NAT traversal), but while we <s>prograstirovali</s> prepared the post, one of the application leaders released a paid version with support for this functionality.  In any case, the article will be useful to you if you want to file video monitoring or two-way video call in your iOS application.  We specifically indicate that this is a version without WebRTC, because we are going to write about the web-compatible version (as well as about Android) separately, there are some nuances. <br><br><a name="habracut"></a>  TK: <br>  In our case, the application is a monitoring of young children (infants) through a mobile device running iOS.  At the start, the application had to find a neighboring device, synchronize with it, and then make a video call.  During the connection, the parent sees the child, and can also control the device on that side - turn on the light (flash), play a lullaby, talk there in the microphone. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Actually, the project is not difficult, the main difficulties lay in the implementation of 2 points: <br><ul><li>  search and sync devices </li><li>  video link </li></ul><br>  Consider these points in more detail: <br><br><h4>  Search and sync devices </h4><br>  Synchronization occurs via Wi-Fi or Bluetooth.  Googling, found 4 ways to do it.  Here is a brief description, advantages and disadvantages: <br><br><ol><li>  <a href="https://developer.apple.com/bonjour/">Bonjour service</a> - synchronization via Wi-Fi.  It is easy to find such a sample on the Internet.  Works on iOS 6-7 </li><li>  <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternetWeb/Conceptual/CoreBluetooth_concepts/AboutCoreBluetooth/Introduction.html">Core Bluetooth</a> - works, no matter how unexpectedly it sounds, via Bluetooth with iOS 5 or higher.  But here's the nuance - only Bluetooth 4 LE is supported. </li><li>  <a href="https://developer.apple.com/library/ios/documentation/NetworkingInternet/Conceptual/GameKit_Guide/Matchmaking/Matchmaking.html">GameKit</a> .  Cool stuff.  In principle, everything is just like a door.  It works fine on ordinary bluetooth (for iPhone 4 devices and even lower).  Also works Bonjour - and for WiFi networks.  But there is a small drawback - deprecated since iOS 7. </li><li>  <a href="https://developer.apple.com/library/ios/documentation/MultipeerConnectivity/Reference/MultipeerConnectivityFramework/Introduction/Introduction.html">Multipeer Connectivity</a> - a new framework added in iOS 7. In fact, for us it looked like an analogue of GameKit, only for iOS 7. We used it in the future. </li></ol><br>  We were able to encapsulate these services under one interface and it does not matter which of these four services we chose to use in the end.  It turned out to be very convenient. <br><br>  The general interface of such a service looks like this (the ‚ÄúBB‚Äù prefix is ‚Äã‚Äãfrom our application name, you can, of course, call it something different): <br><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"BBDeviceModel.h"</span></span></span><span class="hljs-meta"> typedef enum CommonServieType { CommonServiceTypeBonjour = 0, CommonServiceTypeBluetoothLE, CommonServiceTypeGameKitWiFi, CommonServiceTypeGameKitBluetooth, CommonServiceTypeMultipeer, }CommonServieType; @protocol BBCommonServiceDelegate; @interface BBCommonService : NSObject @property (nonatomic, weak) id</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;BBCommonServiceDelegate&gt;</span></span></span><span class="hljs-meta"> delegate; -(void) setConnectionType:(CommonServieType)type; -(void) startServerSide; -(void) stopServerSide; -(void) startSearchDevices; -(void) stopSearchDevices; -(void) selectDevice:(BBDeviceModel *)deviceModel; -(void) clean; @end @protocol BBCommonServiceDelegate </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;NSObject&gt;</span></span></span><span class="hljs-meta"> @optional -(void) service:(BBCommonService *)servie didFindDevice:(BBDeviceModel *)device; -(void) service:(BBCommonService *)servie didRemoveDevice:(BBDeviceModel *)device; -(void) service:(BBCommonService *)servie serverDidFinishedSync:(BOOL)isFinished; -(void) service:(BBCommonService *)servie clientDidFinishedSync:(BOOL)isFinished; @end @interface BBDeviceModel : NSObject @property (nonatomic, strong) id device; -(NSString *)deviceName; -(void)setDeviceName:(NSString *)name; -(BOOL) isDeviceEqualTo:(id)otherDevice; @end</span></span></code> </pre> <br>  Then we inherit from the BBCommonService depending on the type of connection and override the start- and stop-, clean methods, and then in the right places we call the delegate methods. <br><br><h4>  Video chat </h4><br>  For video, we used QuickBlox.  First you need to <a href="http://admin.quickblox.com/signin">register</a> - as a result you will get access to the admin panel.  In it, you create your application.  Then download the framework itself from the <a href="http://quickblox.com/developers/IOS">official site</a> .  Connection is described in more detail here - <a href="http://quickblox.com/developers/IOS-how-to-connect-Quickblox-framework">http://quickblox.com/developers/IOS-how-to-connect-Quickblox-framework</a> .  In short, then: <br><br>  1) Download Quickblox.framework, add to the project, connect 15 pieces of libraries - they are listed in the tutorial <br>  2) After that, you need to return to the admin panel, select your application and copy three parameters - Application id, Authorization key and Authorization secret to the project settings: <br><br><pre> <code class="objectivec hljs">[QBSettings setApplicationID:APP_ID]; [QBSettings setAuthorizationKey:AUTH_KEY]; [QBSettings setAuthorizationSecret:AUTH_SECRET];</code> </pre><br>  Everything, now it is possible to work. <br><br><h5>  1. Session </h5><br>  In order to make client-server interactions with QuickBlox, you need to create a session.  This is done very simply: <br><br><pre> <code class="objectivec hljs">[QBAuth createSessionWithDelegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>];</code> </pre><br>  Thus, a request to create a session is sent and the response comes to the delegate method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)completedWithResult:(Result *)result { QBAAuthResult *authResult = (QBAAuthResult *)result; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([authResult isKindOfClass:[QBAAuthResult <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>]]) { <span class="hljs-comment"><span class="hljs-comment">// do something } }</span></span></code> </pre><br><br><h5>  2. Create a user or login. </h5><br>  For further work, we need a user.  Without it, nowhere.  This is also done quite simply: <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// registration QBUUser *user = [QBUUser new]; user.password = aPass; user.login = aLogin; [QBUsers signUp:user delegate:self];</span></span></code> </pre><br>  or <br><br><pre> <code class="objectivec hljs"><span class="hljs-comment"><span class="hljs-comment">// login [QBUsers logInWithUserLogin:aLogin password:aPass delegate:self];</span></span></code> </pre><br>  For these and all requests, a response from the server comes to the <code>completedWithResult:</code> delegate method <code>completedWithResult:</code> <br><br>  Accordingly, the username / password can be taken from UITextFields if desired.  In our case, in order not to force the user to add anything else, we did a hidden authorization, so we created a login and password based on vendorID. <br><br><h5>  3. Storing pair information </h5><br>  After synchronization, we decided to create the Pair entity in which to store our id and opponent (second device synchronized with this one).  Also, it did not prevent to send it somewhere to the server in order not to do synchronization in the future.  The <a href="http://quickblox.com/developers/SimpleSample-customObjects-ios">Custom Objects</a> module, which is essentially a database with custom fields, helped us with this.  So, it looked like this: <br><br><pre> <code class="objectivec hljs">QBCOCustomObject *customObject = [QBCOCustomObject customObject]; customObject.className = <span class="hljs-string"><span class="hljs-string">@"Pair"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// Object fields [customObject.fields setObject:@(userID) forKey:@‚ÄúopponentID‚Äù]; customObject.userID = self.currentUser.ID; // permissions QBCOPermissions *permissions = [QBCOPermissions permissions]; permissions.readAccess = QBCOPermissionsAccessOpen; permissions.updateAccess = QBCOPermissionsAccessOpen; customObject.permissions = permissions; [QBCustomObjects createObject:customObject delegate:self]; - (void)completedWithResult:(Result *)result { QBCOCustomObjectResult *coResult = (QBCOCustomObjectResult *)result; if ([authResult isKindOfClass:[QBCOCustomObjectResult class]]) { // do something QBCOCustomObjectResult *customObjectResult = (QBCOCustomObjectResult *)result; BBPair *pair = [BBPair createEntityFromData:customObjectResult.object]; self.currentPair = pair; // .. } }</span></span></code> </pre><br>  The only thing - here you need to go to the admin panel and in the Custom Objects tab create the corresponding model with fields.  Everything is very simple and intuitive there, so I‚Äôll not give an example (what you need to pay attention to - the supported data types for the fields are integer, float, boolean, string, file). <br><br>  If you need to get some entities from the database, this is done as follows - <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *getRequest = [<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> dictionary]; [getRequest setObject:@(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.currentUser.ID) forKey:<span class="hljs-string"><span class="hljs-string">@"user_id[or]"</span></span>]; [getRequest setObject:@(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.currentUser.ID) forKey:<span class="hljs-string"><span class="hljs-string">@"opponentID[or]"</span></span>]; [QBCustomObjects objectsWithClassName:<span class="hljs-string"><span class="hljs-string">@"Pair"</span></span> extendedRequest:getRequest delegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>];</code> </pre><br>  This request searches for all entities where this user is either the current user or opponent. <br><br>  Delete a custom object is even easier - you just need to know its ID. <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *className = <span class="hljs-string"><span class="hljs-string">@"Pair"</span></span>; [QBCustomObjects deleteObjectWithID:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.currentPair.pairID className:className delegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>];</code> </pre><br>  For us, this is necessary when the user wants to unsynchronize his ipad / ipod / iphone then, for example, to connect him later with another device.  In the application, we have provided for this the ‚ÄúUnpair‚Äù button in the Settings interface. <br><br><h5>  4. Video broadcast </h5><br>  Here is a little more complicated.  First of all, we must, besides creating the session and login, also log in to the chat, because  chat server is used for video signaling.  This is done as follows - <br><br><pre> <code class="objectivec hljs">[QBChat instance].delegate = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>; [[QBChat instance] loginWithUser:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.currentUser]; <span class="hljs-comment"><span class="hljs-comment">// self.currentUser - QBUUser</span></span></code> </pre><br>  thus, we take the current user and log in to the chat, after setting the delegate.  If everything is good, then almost immediately one of the methods will work: <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)chatDidLogin { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.presenceTimer = [<span class="hljs-built_in"><span class="hljs-built_in">NSTimer</span></span> scheduledTimerWithTimeInterval:<span class="hljs-number"><span class="hljs-number">30</span></span> target:[QBChat instance] selector:<span class="hljs-keyword"><span class="hljs-keyword">@selector</span></span>(sendPresence) userInfo:<span class="hljs-literal"><span class="hljs-literal">nil</span></span> repeats:<span class="hljs-literal"><span class="hljs-literal">YES</span></span>]; } -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)chatDidNotLogin { } -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)chatDidFailWithError:(<span class="hljs-built_in"><span class="hljs-built_in">NSInteger</span></span>)code { }</code> </pre><br>  depending on the outcome.  We also immediately send a presence to the timer in case of a successful login.  Without them, we will automatically go offline in about a minute. <br><br>  If everything went well, then you can proceed to the hardest part.  To work with video calls, we are offered the QBVideoChat class. <br><br>  The ‚Äúcalling party‚Äù first creates an instance using <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat = [[QBChat instance] createAndRegisterVideoChatInstance];</code> </pre> <br>  To do this, set up a view for yourself and your opponent, if necessary, the sound state (on / off) and additional settings - for example, useBackCamera: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat.viewToRenderOwnVideoStream = myView; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat.viewToRenderOwnVideoStream = opponentView; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat.useHeadphone = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat.useBackCamera = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat.microphoneEnabled = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>;</code> </pre><br>  and make a call: <br><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat callUser:currentPair.opponentID conferenceType:QBVideoChatConferenceTypeAudioAndVideo];</code> </pre><br><br>  The next step is implementing delegate methods according to behavior.  If everything is successful, the opponent should work out the following method: <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) chatDidReceiveCallRequestFromUser:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)userID withSessionID:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)_sessionID conferenceType:(<span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> QBVideoChatConferenceType)conferenceType { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat = [[QBChat instance] createAndRegisterVideoChatInstanceWithSessionID:_sessionID]; <span class="hljs-comment"><span class="hljs-comment">// video chat setup self.videoChat.viewToRenderOwnVideoStream = nil; self.videoChat.useHeadphone = NO; self.videoChat.useBackCamera = NO; if (self.videoSide == BBVideoParentSide) { self.videoChat.viewToRenderOpponentVideoStream = self.renderView; self.videoChat.viewToRenderOwnVideoStream = nil; self.videoChat.microphoneEnabled = NO; }else if (self.videoSide == BBVideoChildSide) { self.videoChat.viewToRenderOpponentVideoStream = nil; self.videoChat.viewToRenderOwnVideoStream = self.renderView; self.videoChat.microphoneEnabled = NO; } BBPair *currentPair = [QBClient shared].currentPair; [self.videoChat acceptCallWithOpponentID:currentPair.opponentID conferenceType:QBVideoChatConferenceTypeAudioAndVideo]; }</span></span></code> </pre><br>  or <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) chatCallUserDidNotAnswer:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)userID { }</code> </pre><br>  We hope for a successful outcome :) In our case, we specifically set the view and sound from our side.  Here everything is the same as at the beginning, with the only difference being that at the end we send accept to the initiator of the call. <br><br>  His method should work. <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) chatCallDidAcceptByUser:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)userID { }</code> </pre><br>  And then on both sides it will work. <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)chatCallDidStartWithUser:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)userID sessionID:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)sessionID { }</code> </pre><br>  this method is useful for UI - for example, you spin the spinner until the whole thing happens, and then you hide it in this method.  From now on, video calling should work. <br><br>  When you need to end the session and "hang up" - call <br><br><pre> <code class="objectivec hljs">[<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.videoChat finishCall];</code> </pre><br>  after which the delegate method is triggered on the opposite side <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)chatCallDidStopByUser:(<span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>)userID status:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)status { }</code> </pre><br>  There is also a version of this method with parameters, in case you need to transfer something else. <br><br>  In this case, a standard audio-video session is used.  Depending on the TK - if you need to record video and audio, for example, and then do something with it, you should use custom audio-video sessions.  SDK allows it.  This article does not cover this, but you can read more here: <a href="http://quickblox.com/developers/SimpleSample-videochat-ios">http://quickblox.com/developers/SimpleSample-videochat-ios#Use_custom_capture_session</a> <br><br>  So, the video link is established.  Now the last thing to do is to realize the inclusion of a lullaby on the child‚Äôs device, change the camera, take a screenshot, etc ... <br>  All this is done quite simply.  Remember we logged in addition to the chat?  so - this is another module, it is called Chat :) <br>  It can send messages.  What we will do is just send different messages, and on the opponent‚Äôs side, parse them and, depending on the message, perform some actions - turn on the flash for example or something else. <br><br>  Sending a message is done simply (we carried out in a separate method) - <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) sendServiceMessageWithText:(<span class="hljs-built_in"><span class="hljs-built_in">NSString</span></span> *)text parameters:(<span class="hljs-built_in"><span class="hljs-built_in">NSMutableDictionary</span></span> *)parameters{ BBPair *currentPair = [QBClient shared].currentPair; QBChatMessage *message = [QBChatMessage new]; message.text = text; message.senderID = currentPair.myID; message.recipientID = currentPair.opponentID; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parameters) message.customParameters = parameters; [[QBChat instance] sendMessage:message]; }</code> </pre><br>  Text is our message type in this case. <br><br>  The message comes here - <br><br><pre> <code class="objectivec hljs">-(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)chatDidReceiveMessage:(QBChatMessage *)message { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([message.text isEqualToString:kRouteFlashMessage]) { <span class="hljs-comment"><span class="hljs-comment">// .. do something }else if ([message.text isEqualToString:kRouteCameraMessage]) { // .. } }</span></span></code> </pre><br>  All the rest is UI and some additional features.  In general, everything turned out well.  In the end I would like to draw attention to two nuances: <br><br>  1) the life of the session - 2 hours.  It is automatically renewed after each request executed.  But if for example the user turned the application for half a day, then it needs to be somehow restored.  This is done easily - using extended request: <br><br><pre> <code class="objectivec hljs">QBASessionCreationRequest *extendedRequest = [QBASessionCreationRequest new]; extendedRequest.userLogin = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.currentUser.login; extendedRequest.userPassword = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.currentUser.password; [QBAuth createSessionWithExtendedRequest:extendedRequest delegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>];</code> </pre><br>  you can run, for example, in the <code>applicationWillEnterForeground</code> . <br><br>  2) Method <code>- (void)completedWithResult:(Result *)result</code> grows very quickly, which becomes rather inconvenient.  Almost every method is in 2 versions - simple and with context.  Alternatively, you can use blocks - pass them as context.  Here is what it looks like on the example of session creation: <br><br><pre> <code class="objectivec hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (^qbSessionBlock)(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span> isCreated, <span class="hljs-built_in"><span class="hljs-built_in">NSError</span></span> *anError); -(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) createSessionWithBlock:(qbSessionBlock)aBlock { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (^block)(Result *) = ^(Result *result) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result.success) { aBlock(<span class="hljs-literal"><span class="hljs-literal">NO</span></span>, [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> errorWithQBResult:result]); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { aBlock(<span class="hljs-literal"><span class="hljs-literal">YES</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>); } }; [QBAuth createSessionWithDelegate:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> context:(__bridge_retained <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)(block)]; } - (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>)completedWithResult:(Result *)result context:(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)contextInfo { <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(^myBlock)(Result *result) = (__bridge <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (^)(Result *__<span class="hljs-keyword"><span class="hljs-keyword">strong</span></span>))(contextInfo); myBlock(result); Block_release(contextInfo); }</code> </pre><br>  So much easier. <br><br>  On this, in principle, everything.  If something is not clear - write in a personal or comments.  Here you can add that the application, which was discussed in this article, was recommended by Apple, came out in the US Appstore in the first place and of the three paid in-app purchase, the video monitor function turned out to be the most demanded.  We work a lot on applications related to video calls for iOS, Android, Web - usually this is dating / social or security / video surveillance, so I will be happy to help with advice or code examples if you do something like that. </div><p>Source: <a href="https://habr.com/ru/post/221091/">https://habr.com/ru/post/221091/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../221087/index.html">Habra Analytics Tools: Compare Hubs</a></li>
<li><a href="../221095/index.html">J-sort</a></li>
<li><a href="../221097/index.html">Samsung Galaxy Tab Pro 10.1: tested in humans</a></li>
<li><a href="../221105/index.html">About cutting corners</a></li>
<li><a href="../221107/index.html">‚ÄúCars instead of people!‚Äù</a></li>
<li><a href="../221111/index.html">Proper use of promise in angular.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>