<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Javascript as the embodiment of evil</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="JavaScript developers often complain that their programming language is unjustly scolded for having too many overly complicated, tangled features. Man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Javascript as the embodiment of evil</h1><div class="post__text post__text-html js-mediator-article">  JavaScript developers often complain that their programming language is unjustly scolded for having too many overly complicated, tangled features.  Many are struggling with this attitude toward JS, talking about why criticizing this language for what it is is wrong.  The author of the material, the translation of which we are publishing today, decided not to defend JS, turning instead to the dark side of the language.  However, here he does not want to talk, for example, about those pitfalls that JavaScript sets for inexperienced programmers.  He is interested in the question of what will happen if we try to confirm the bad reputation of the language with a code that could be written by someone who does not care about others at all. <br><br> <a href="https://habr.com/company/ruvds/blog/417263/"><img src="https://habrastorage.org/webt/fy/w2/lv/fyw2lvruoubpwmlwluamnw0ye-o.jpeg"></a> <br><br>  In the examples for this material a variety of language mechanisms will be used.  A lot of what you see here, by the way, works in other languages, therefore, with due diligence, you can find their dark sides.  But JavaScript, of course, has a real gift for all kinds of bullying, and with it in this area is very difficult for other languages.  If you write code with which other people will need to work, JS gives you an inexhaustible amount of opportunities to annoy, confuse, torment and deceive these people.  As a matter of fact, here we will consider only a small part of such techniques. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Getter modifiers</font> </h2><br>  JavaScript supports getters ‚Äî functions that allow you to work with what they return as with a regular property.  Under normal use, it looks like this: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs pgsql">let greeter = {  <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Bob'</span></span>,  <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> hello() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> `Hello ${this.name}`} } console.log(greeter.hello) // Hello Bob greeter.name = <span class="hljs-string"><span class="hljs-string">'World'</span></span>; console.log(greeter.hello) // Hello World</code> </pre> <br>  If we use getters, plotting evil, then, for example, you can create self-destructive objects: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {  foo: <span class="hljs-number"><span class="hljs-number">1</span></span>,  bar: <span class="hljs-number"><span class="hljs-number">2</span></span>,  baz: <span class="hljs-number"><span class="hljs-number">3</span></span>,  <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">get</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evil</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keys = Object.keys(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keys) {        delete <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>[keys[<span class="hljs-number"><span class="hljs-number">0</span></span>]]     }     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Nothing to see here'</span></span>;  } }</code> </pre> <br>  Here, each time <code>obj.evil</code> , one of the other properties of the object will be deleted.  At the same time, the code working with <code>obj.evil</code> will not know that something very strange is happening right under his nose.  However, this is only the beginning of a conversation about the harmful side effects that can be achieved using JavaScript mechanisms. <br><br><h2>  <font color="#3AC1EF">Unexpected proxies</font> </h2><br>  Getters are great, but they have been around for years, many developers know about them.  Now, thanks to the proxy, we have at our disposal a much more powerful tool for entertainment with objects.  Proxy is an ES6 feature that allows you to create wrappers around objects.  With their help, you can control what happens when the user tries to read or write the properties of proxied objects.  This allows, for example, to create an object that, in one third of attempts to access a certain key of such an object, will return a value according to a randomly selected key. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> obj = {<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">b</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">c</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> handler = {   <span class="hljs-attr"><span class="hljs-attr">get</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, prop</span></span></span><span class="hljs-function">) </span></span>{     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.33</span></span>) {       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[prop];     } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> keys = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.keys(obj);       <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key = keys[<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()*keys.length)]       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[key];     }   } }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> evilObj = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(obj, handler); <span class="hljs-comment"><span class="hljs-comment">//          console.log(evilObj.a); // 1 console.log(evilObj.b); // 1 console.log(evilObj.c); // 3 console.log(evilObj.a); // 2 console.log(evilObj.b); // 2 console.log(evilObj.c); // 3</span></span></code> </pre> <br>  Unfortunately, our developer‚Äôs tools, which identify <code>evilObj</code> as an object of the <code>Proxy</code> type, partially unfold our meanness.  However, the above-described construction, before its lowly essence is revealed, is capable of delivering many pleasant moments to those who will work with it. <br><br><h2>  <font color="#3AC1EF">Contagious functions</font> </h2><br>  So far, we have been talking about how objects can modify themselves.  But we, in addition, can create innocent-looking functions that infect objects passed to them, changing their behavior.  For example, suppose we have a simple <code>get()</code> function that allows you to perform a secure property search in the object passed to it, given that such an object may not exist: <br><br><pre> <code class="hljs kotlin">let <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> = (obj, property, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!obj) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;  }  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[property]; }</code> </pre> <br>  Such a function is easy to rewrite so that it infects the objects passed to it, slightly modifying them.  For example, you can make it so that the property to which it helped gain access would no longer be displayed when trying to iterate over the keys of an object: <br><br><pre> <code class="hljs pgsql">let <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> = (obj, property, defaultValue) =&gt; {  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!obj || !property <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> obj) {     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> defaultValue;  }  let <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = obj[property];  <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj[property];  <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.defineProperty(obj, property, {     <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>,     enumerable: <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>  })  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj[property]; } let x = {a: <span class="hljs-number"><span class="hljs-number">1</span></span>, b:<span class="hljs-number"><span class="hljs-number">2</span></span> }; console.log(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(x)); // [<span class="hljs-string"><span class="hljs-string">'a'</span></span>, <span class="hljs-string"><span class="hljs-string">'b'</span></span>] console.log(<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>(x, <span class="hljs-string"><span class="hljs-string">'a'</span></span>)); console.log(<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>.keys(x)); // [<span class="hljs-string"><span class="hljs-string">'b'</span></span>]</code> </pre> <br>  This is a sample of very subtle interference with the behavior of an object.  The enumeration of the keys of an object is not the most conspicuous operation, since it is not very rare, but it is used not too often.  Since errors that can be caused by such a modification of objects cannot be tied to their code, they can exist in a project for quite some time. <br><br><h2>  <font color="#3AC1EF">Prototype mess</font> </h2><br>  Above, we discussed the various possibilities of JS, including quite fresh ones.  However, sometimes there is nothing better than the old, time-tested technology.  One of the features of JS, due to which it criticizes most, is the possibility of modifying embedded prototypes.  This feature was used in the early years of JS to extend embedded objects, for example, arrays.  Here's how to extend the standard capabilities of arrays, say, by adding the <code>contains</code> method to the prototype of the <code>Array</code> object: <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.contains = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.indexOf(item) !== <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br>  As it turns out, if you do something similar in a real-life library, this can <a href="http://2ality.com/2016/02/array-prototype-includes.html">disrupt the</a> work with the basic mechanisms of the language in the entire application that uses this library.  Therefore, the inclusion of additional useful methods in the prototypes of standard objects can be considered a very good move for patient developers who seek to do other things nasty.  However, if we are talking about impatient sociopaths, they can offer something quick-acting, but no less interesting.  A prototype modification has one very useful feature, which is that the modification affects all code that runs in some environment, even the one that is loaded from modules or is in closures.  As a result, if you issue the following code in the form of a third-party script (for example, it may be an ad network script or an analytical service), then the entire site using this script will be prone to minor errors. <br><br><pre> <code class="hljs javascript"><span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.map = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr2 = arr.reduce(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">acc, val, idx</span></span></span><span class="hljs-function">) =&gt;</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() &gt; <span class="hljs-number"><span class="hljs-number">0.95</span></span>) {        idx = idx + <span class="hljs-number"><span class="hljs-number">1</span></span>     }     <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> index = acc.length - <span class="hljs-number"><span class="hljs-number">1</span></span> === idx ? (idx - <span class="hljs-number"><span class="hljs-number">1</span></span> ) : idx     acc[index] = fn(val, index, arr);     <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> acc;  },[]);  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> arr2; }</code> </pre> <br>  Here we have redefined the standard <code>Array.prototype.map</code> method so that it, in general, works fine, but in 5% of cases it swaps two elements of the array.  Here is what you can get after several calls to this method: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> arr = [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">4</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>,<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">7</span></span>,<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">9</span></span>,<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">11</span></span>,<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">13</span></span>,<span class="hljs-number"><span class="hljs-number">14</span></span>,<span class="hljs-number"><span class="hljs-number">15</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> square = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function"> =&gt;</span></span> x * x; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(arr.map(square)); <span class="hljs-comment"><span class="hljs-comment">// [1,4,9,16,25,36,49,64,100,81,121,144,169,196,225 console.log(arr.map(square)); // [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225] console.log(arr.map(square)); // [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225]</span></span></code> </pre> <br>  Here we launched it three times.  What came out of his first use is slightly different from the next two results of his call.  This is a minor change, it will not always cause some kind of failure.  And the most pleasant thing here is that it is impossible to understand the cause of rarely occurring errors caused by this method without reading its source code, which is the cause of these errors.  Our function is not noticeable when working with developer tools; it does not produce errors when working in strict mode.  In general, with the help of something like this it is quite possible to drive someone crazy. <br><br><h2>  <font color="#3AC1EF">Difficult names</font> </h2><br>  The naming of entities, as is known, is one of the two most difficult tasks of computer science.  Therefore, bad names come up with not only those who consciously seek to harm others.  Of course, it can be hard to believe experienced linuksoids.  They had years at their disposal to link the most terrible IT naming violator (Microsoft) with the deepest forms of evil.  But unsuccessful names do not directly harm programs.  We will not talk about small things like names that are misleading and about comments that have lost relevance.  For example, about such: <br><br><pre> <code class="hljs pgsql">//   let arrayOfNumbers = { userid: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Darth Vader'</span></span>};</code> </pre> <br>  In order to understand this and understand that there is something wrong with the comment, and with the name of a variable, the person who reads the code in which such a thing occurs will have to slow down and think a little.  But this is nonsense.  Let's talk about really interesting things.  Did you know that most Unicode characters can be used to name variables in JavaScript?  If you, in the matter of assigning variable names, are set to positive, then you will like the idea of ‚Äã‚Äãusing names in the form of icons ( <b>Habr cut out emoji, although in the original here after <code>let</code> was emoji kakahi</b> ): <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> = { postid: <span class="hljs-number"><span class="hljs-number">123</span></span>, postName: <span class="hljs-string"><span class="hljs-string">'Evil JavaScript'</span></span>}</code> </pre> <br>  Although, after all, we are talking about real nasty things, so let's turn to the symbols that are similar to those usually used for naming variables, but they are not.  For example, let's do this: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> oÔΩÇj = {}; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// Error!</span></span></code> </pre> <br>  The letter <code>ÔΩÇ</code> in the name <code>oÔΩÇj</code> may look almost normal, but this is not a lowercase Latin letter b.  This is the so-called full-width lowercase Latin letter b.  The characters are different, so anyone who tries to enter the name of such a variable manually will most likely be very confused. <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  Despite the story about various nasty things that can be created with the help of JavaScript, this material is intended to warn programmers from using techniques similar to those described, and convey to them the fact that this can cause real harm.  The author of the material says that it is always useful to know what problems may appear in poorly written code.  He believes that something similar can be found in real projects, but he hopes that there it exists in a less destructive form.  However, the fact that a programmer who wrote such a code did not seek to harm others does not make it easier to work with such code and debug it.  At the same time, the knowledge of what targeted attempts to harm can bring, can broaden the programmer‚Äôs horizons and help him find the source of similar errors.  No one can be completely sure that there is no mistake in the code with which it works.  Perhaps someone, aware of his penchant for excessive suspicion, will try to reassure himself that anxiety about such mistakes is only a figment of his imagination.  However, this will not prevent such errors, possibly, intentionally introduced into a certain code, once it will manifest itself. <br><br>  <b>Dear readers!</b>  Have you encountered in practice something similar to what was discussed in this article? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/webt/xh/-2/n8/xh-2n8h-0cldicbple6-6dque3c.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/417263/">https://habr.com/ru/post/417263/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417251/index.html">Using the Fish eye camera on a Raspberry Pi 3 with ROS - part 1</a></li>
<li><a href="../417255/index.html">Lego Mindstorms cuckoo clock</a></li>
<li><a href="../417257/index.html">C pointers as a linguistic paradox</a></li>
<li><a href="../417259/index.html">Digital events in Moscow from July 16 to July 22</a></li>
<li><a href="../417261/index.html">Uber after the accident with the participation of his mobile phone decided to reduce the staff of operators of smart machines in Pittsburgh</a></li>
<li><a href="../417265/index.html">Top 10: best reports DotNext 2017 Moscow</a></li>
<li><a href="../417269/index.html">Where to go to the designer: prestigious international awards</a></li>
<li><a href="../417271/index.html">Can a hacker block the English Channel?</a></li>
<li><a href="../417273/index.html">The implementation of the voice directory based on YandexSpeechKit</a></li>
<li><a href="../417275/index.html">7 skills of effective designers. Powerful development tools in the profession</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>