<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>APS technology: control panel frontend and JS SDK features</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Last time, we talked about APS (Application Packaging Standard) - our open technology for integrating applications into the OaDin Automation (SaaS mar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>APS technology: control panel frontend and JS SDK features</h1><div class="post__text post__text-html js-mediator-article">  Last time, we <a href="https://habrahabr.ru/company/odin_ingram_micro/blog/324422/">talked about APS</a> (Application Packaging Standard) - our open technology for integrating applications into the <b>OaDin Automation</b> (SaaS marketplace) cloud services platform.  Our platform connects developers and consumers of cloud services through the infrastructure of major service providers (providers of telecommunications and hosting services), while simultaneously providing an entry point for end users: a control panel or portal, with which you can create a website, set up mail, buy antivirus or virtual car in the cloud.  In this post, we will discuss in more detail how the frontend of the control panel and APS applications is arranged and what features the APS JavaScript SDK provides. <br><br><img src="https://habrastorage.org/files/229/468/33d/22946833d33b4faeab4a93de7d84e5cd.jpg"><br><a name="habracut"></a><br><h2>  <font color="#0070CD">Control panel and application screens</font> </h2><br>  For application management, additional purchases (upsell) and cross-sell (cross-sell) services, end users can use the control panel.  It provides a common interface into which APS application developers embed their user interface. <br><br>  Each service provider brand Odin Automation installation in their own colors.  Therefore, we abandoned the use of proprietary markup and use the popular Twitter Bootstrap markup with the LESS CSS preprocessor.  Since all applications use the APS JS SDK, the theme developer only needs to specify a few parameters in order to obtain a design corresponding to the brand book of the service provider or reseller. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In support of mobile devices, we did not limit ourselves to adaptive markup and a grid from Bootstrap, which an application developer can use to determine the size of widgets on various devices, but went further.  Some complex widgets completely change their display on mobile devices.  For example, a table is displayed as tiles;  and a slider with a slider, which is obviously inconvenient to use on touch devices, turns into a spinner consisting of an input and the "+" / "-" buttons. <br><br><img src="https://habrastorage.org/files/530/860/260/5308602608b644048a8a89027e76d59a.jpg"><br><br>  The panel itself, and each application are Single Page Applications.  In the simplest case, each APS application is isolated in its IFrame, which the control panel‚Äôs router does not remove, but hides and shows.  Similarly, inside the IFrame, the screens are not removed during the change, but are hidden and shown.  Iframe needed to isolate applications from each other, because  Applications are written by various vendors.  At the same time, the isolation between the screens of one application is weaker: each screen is just a JavaScript module inherited from the corresponding class, and its display widgets are placed in a div.  Thus, we have a SPA over SPA. <br><br><h3>  <font color="#0070CD">Single page application</font> </h3><br>  Let us consider in more detail our SPA.  Each APS application is described by a special APP-Meta file.  In particular, this file contains a description of all the screens of the application and its associated data.  It also describes the relationship of applications.  For example, if application A provides a wizard into which application B wants to integrate, application A declares support for embedding, declaring a so-called placeholder, and application B declares a desire to embed its screen into this placeholder. <br><br><pre><code class="javascript hljs">&lt;!‚Äî  --&gt; &lt;wizard id="addUser" label="Add New Users" ‚Ä¶&gt; &lt;placeholder id="http://www.aps-standard.org/ui/service/suwizard.new/2"/&gt; ‚Ä¶ &lt;/wizard&gt; &lt;!‚Äî B --&gt; &lt;view id="signupfilesharing" label="File Sharing" ‚Ä¶ &gt; &lt;plugs-to id="http://www.aps-standard.org/ui/service/suwizard.new/2"/&gt; &lt;/view&gt;</code> </pre> <br>  In this case, the placeholder is not tied to a specific application.  Multiple applications can declare the same placeholder, and then the application B screen will be embedded in all these applications. <br><br>  Let's go back to the browser and explain how the SPA works on a small example. <br><br><ol><li>  The user opens the application <i>view-11</i> screen in the control panel. </li><li>  The router of the control panel creates an IFrame and loads into it the starting bootstrapApp.html, common for all applications.  Then connects the module <i>view A1</i> .  The instance of this module will remain in the IFrame, even if the user switches to another screen. </li><li>  In the same application, the user switches to the <i>view A2</i> screen. </li><li>  The router connects the <i>view A2</i> module to the IFrame.  Now all transitions between these screens will occur in one IFrame. </li><li>  The user switches to the <i>view B1</i> screen of the application <i>B.</i> </li><li>  The router creates a new IFrame and loads bootstrapApp.html into it with the source code <i>view B1</i> .  Now this code will remain in the IFrame, even if the user switches to another screen. </li></ol><br>  Then everything is exactly the same as in Appendix <i>A.</i> <br><br><img src="https://habrastorage.org/files/538/9b8/bc9/5389b8bc9acb4cea916b3b66a5bd5017.jpg"><br><br>  Let us dwell on the life cycle of the application screen.  It consists of the following phases: <br><br><ul><li>  Initialization (init method).  In it, the application must declare the widgets and associate them with the model. </li><li>  Preparing for the show (onShow method).  Here the application can perform preparatory actions that do not require data acquisition. </li><li>  Show (onContext method).  In this phase, the screen received data from the control panel that was previously described in the APP-Meta file.  Of course, the screen can go to the server itself for the data, but we advise you to use the declaration, as this saves loading time.  The fact is that to show each screen, the front-end makes a request to the server, because the structure of the screens could change.  If the data was previously described, they will be received in the same request.  If the screen itself goes after the data, then the end user will have to wait until the first request is received, and then wait for the second and subsequent ones.  After the screen has received data, it puts them in the model, and the widgets change their state. </li><li>  Hiding (onHide method).  Here the application clears the widgets and returns them to the neutral state.  For this, the screen has a special method. </li></ul><br>  Above was described the simplest method of integration.  But there are more difficult situations.  Take this example: there is a dashboard application A, and application B wants to display some information using the widget.  For such point integration, we have developed view-plugins.  Embedding the view plugin is completely analogous to the placeholder mechanism described above.  To maintain the isolation between A and B, all communication between them is carried out through a mediator.  This is a special object that contains the description of the API view-plugin as a JSON-scheme, and first checks the plugin for all the required properties and methods, and then controls all communication between the host screen and the view plugin. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/45e/336/0c8/45e3360c85324f939cc9a4e6f94ce875.jpg"></div><br><br>  Let us consider an example.  The mediator provides <code>resourceUsage</code> data and a custom getWidget operation, which takes an optional argument in the form of a boolean value: <br><br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"properties"</span></span>: { <span class="hljs-string"><span class="hljs-string">"resourceUsage"</span></span>: { <span class="hljs-comment"><span class="hljs-comment">// type    ,      resourceUsage // URI-    APS ,    post-noSQL   APS,        "type": "http://aps-standard.org/types/core/subscription/1.0#SubscriptionResource", } }, "operations": { "getWidget": { "parameters": { "withData": { "type": "boolean", "required": false } }, "response": { "type": "string", "required": false } } } }</span></span></code> </pre> <br>  View plug-ins can provide not only UI, but also logic.  In this case, a certain API is placed in the mediator, which hides the logic from the external system, for example, the billing system.  The application should not know which billing system is deployed with the service provider.  Therefore, the specifics of working with it is hidden behind the unified API described in the standard, and the implementation of this API in each specific system is done in the form of a plug-in view plugin. <br><br><h2>  <font color="#0070CD">Sdk</font> </h2><br>  The first version of the APS JS SDK was developed more than five years ago and has since been continuously developed along with the APS standard.  The framework was taken Dojo framework.  Now it may seem strange, but by the standards of the Web-world it was a whole era ago.  Then Angular was just beginning, and React didn‚Äôt exist at all. <br><br>  What we liked about Dojo: <br><br><ul><li>  ready loader and modular system based on AMD; </li><li>  native support for classes with multiple inheritance; </li><li>  implementation of promises; </li><li>  a large number of different auxiliary modules; </li><li>  well thought-out APIs and extensive documentation. </li></ul><br>  Now our framework provides APS application developers with the following modules: <br><br><ul><li>  a large number of different widgets (spinner, slider, grid, password, etc.); </li><li>  modules for working with data (both client and server storages) and modules for two-way data binding and display; </li><li>  various auxiliary modules: API for working with billing systems, localization and internationalization utilities, a password generator for a given security policy, and much more. </li></ul><br>  Also, developers can connect third-party libraries either directly in the AMD-format, or as ES2015 modules, which will be converted to AMD. <br><br><h3>  <font color="#0070CD">Widgets</font> </h3><br>  Widgets are the building blocks of a user interface.  In the APS JS SDK, they are logically separated from the HTML representation and can: <br><br><ul><li>  dynamically change the values ‚Äã‚Äãof their properties; </li><li>  inherit from each other; </li><li>  include other widgets at the template level. </li></ul><br>  It is possible to add child widgets, both dynamically and in the description of the screen.  There are two ways to describe widgets, and as needed, these methods can be combined on one screen in any combination.  Consider these methods in more detail. <br><br>  <b>Creating widgets using constructors</b> .  First, you need to connect the required modules using the <code>require()</code> function or use the <code>import</code> keyword if you are using a transpiler, and then create widgets by calling the constructor with the necessary parameters.  Their hierarchy is determined by the <code>addChild</code> method, which adds child widgets. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"aps/Button"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> btn = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Button({ <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"example1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-string"><span class="hljs-string">"I am simple button"</span></span> });</code> </pre> <br>  Creating widgets using the declaration.  The hierarchy of widgets and their properties are defined as a JSON-like structure, which is passed to the load function.  The declaration of each widget is a JavaScript array, which can contain three elements: <br><br><ul><li>  widget name; </li><li>  (optional) widget property set, </li><li>  (optional) an array containing child elements. </li></ul><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> load <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"aps/load"</span></span>; load([ <span class="hljs-string"><span class="hljs-string">"aps/ProgressBar"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">"35%"</span></span> } ]);</code> </pre> <br>  The <code>load</code> method itself connects the required modules, so it works asynchronously and returns a promise that will be resolved by the widget declared in the root of the passed structure. <br><br><pre> <code class="javascript hljs">load([ <span class="hljs-string"><span class="hljs-string">"aps/ProgressBar"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"myProgBar"</span></span>, <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span> } ]) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pb</span></span></span><span class="hljs-function">) </span></span>{ pb.set(<span class="hljs-string"><span class="hljs-string">"value"</span></span>, <span class="hljs-number"><span class="hljs-number">41</span></span>); });</code> </pre> <br>  When using <code>load</code> -a, the code is more logical and readable: first comes the parent widget, and then the children.  Large structures can be divided into sections and decomposed into separate variables with understandable names, and then combined into one structure. <br><br><h3>  <font color="#0070CD">Work with data</font> </h3><br>  Obviously, widgets may not be enough to create a UI - they need data.  Data sources for widgets come in the form of two types of modules: modules of type Model and modules of type Store. <br><br>  <b>Modules of the <code>Model</code> type</b> - a set of modules for two-way or one-sided linking of widgets and data.  Using the <code>at()</code> method, a link is executed with the widget.  The <code>watch()</code> method is used to track changes to the Model.  To work with <code>Model</code> properties, <code>get()</code> and <code>set()</code> methods are used. <br><br>  An example of initializing a <code>Model</code> from a JSON representation: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>([ <span class="hljs-string"><span class="hljs-string">"dojox/mvc/getStateful"</span></span>, ... <span class="hljs-string"><span class="hljs-string">"aps/json!./newoffer.json"</span></span> ], <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getStateful, ..., newOffer</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* Declare the data source */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> model = getStateful(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(newOffer)); ... });</code> </pre> <br>  Binding <code>Model</code> to widgets: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> widgets = [<span class="hljs-string"><span class="hljs-string">"aps/PageContainer"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"page"</span></span>}, [ [<span class="hljs-string"><span class="hljs-string">"aps/FieldSet"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">title</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, [ [<span class="hljs-string"><span class="hljs-string">"aps/TextBox"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"offerName"</span></span>, <span class="hljs-attr"><span class="hljs-attr">label</span></span>: _(<span class="hljs-string"><span class="hljs-string">"Offer Name"</span></span>), <span class="hljs-attr"><span class="hljs-attr">value</span></span>: at(model, <span class="hljs-string"><span class="hljs-string">"name"</span></span>), <span class="hljs-attr"><span class="hljs-attr">required</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }], [<span class="hljs-string"><span class="hljs-string">"aps/TextBox"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">label</span></span>: _(<span class="hljs-string"><span class="hljs-string">"Description"</span></span>), <span class="hljs-attr"><span class="hljs-attr">value</span></span>: at(model, <span class="hljs-string"><span class="hljs-string">"description"</span></span>) }] ]], ... ]]; load(widgets);</code> </pre> <br>  <b><code>Store</code> type modules are</b> designed to work with various data sources.  Sources are local when all data is on the client and remote when data is on the backend.  Since the remote source is usually an APS controller, the module for working with it provides the transfer of authentication information and supports properties associated with the specificity of the APS, for example, apsType.  Regardless of the type of data source, interaction with widgets that display data goes unilaterally.  To reflect changes in widgets, you must explicitly trigger data updates. <br><br>  Queries to any data sources are ultimately made using the Resource Query Language (RQL).  RQL is a query language developed for use in URIs for working with object-like data structures.  In more detail we will tell about it in the following posts. <br><br>  Sample <code>Store</code> ad: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Store <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"aps/ResourceStore"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> offerStore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Store({ <span class="hljs-attr"><span class="hljs-attr">apsType</span></span>: <span class="hljs-string"><span class="hljs-string">"http://aps-standard.org/samples/vpscloud/offer/1.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">target</span></span>: <span class="hljs-string"><span class="hljs-string">"/aps/2/resources/"</span></span> + aps.context.vars.cloud.aps.id + <span class="hljs-string"><span class="hljs-string">"/offers"</span></span> ... });</code> </pre> <br>  Binding <code>Store</code> to a table displaying widget: <br><br><pre> <code class="javascript hljs">load([<span class="hljs-string"><span class="hljs-string">"aps/PageContainer"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"page"</span></span> }, [ [<span class="hljs-string"><span class="hljs-string">"aps/Grid"</span></span>, { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-string"><span class="hljs-string">"grid"</span></span>, <span class="hljs-attr"><span class="hljs-attr">columns</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">field</span></span>: <span class="hljs-string"><span class="hljs-string">"offername"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Name"</span></span>, <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">"resourceName"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">field</span></span>: <span class="hljs-string"><span class="hljs-string">"hardware.memory"</span></span>, <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"RAM, MB"</span></span> }, ... ], <span class="hljs-attr"><span class="hljs-attr">store</span></span>: offerStore }, ... ] ]]);</code> </pre><br><h2>  <font color="#0070CD">Documentation and sandbox</font> </h2><br>  Our APS platform is focused on third-party developers, so we must ensure stability and ease of development.  Without well-developed documentation that would be impossible. <br><br>  We have created a portal for developers, on which <a href="http://doc.apsstandard.org/2.2/frontend/">all the necessary documentation</a> for creating a UI with code samples is available.  This is a complete reference book: first, a certain general description of the interface, module or method is given, and in the nested levels more detailed information is given.  In this part of the documentation is generated automatically based on the current code of our platform.  Inside, properties, methods, and return values ‚Äã‚Äãare described. <br><br>  Another "chip" is a sandbox, integrated into the portal for developers.  To get into it is very simple: click the ‚ÄúRun demo‚Äù button, which is in each code example: <br><br><img src="https://habrastorage.org/files/3c3/77b/935/3c377b9358384569b5449c38db888fa0.png"><br><br>  Our APS Fiddle: <br><br><ul><li>  knows all the APIs of our widgets and can prompt the names of properties and method signatures; </li><li>  allows you to compare the behavior of the code in different versions of the standard APS; </li><li>  can switch from mobile to desktop view; </li><li>  provides links to code snippets that can be sent to your colleagues or support service (Share); </li><li>  allows you to work on code together (Collab); </li><li>  can generate a finished file with your code, as if it were a separate application screen, and this file can be immediately thrown into a real project and tested. </li></ul><br><img src="https://habrastorage.org/files/084/c04/3ab/084c043ab5c44a3a96eae593bfa3add7.jpg"><br><br>  A detailed description of working with the sandbox is available here: <a href="http://doc.apsstandard.org/2.2/tools/ui-design/">Development Tools -&gt; APS Fiddle</a> . <br><br><h2>  <font color="#0070CD">Finally</font> </h2><br>  We provide a public API on which the performance of over 500 applications with a total audience of several million users depends.  This is a great responsibility.  To facilitate the work of third-party developers and simplify the work with our platform as much as possible, we have made detailed documentation and a sandbox.  And in order to not accidentally break anything, we provided a very high code coverage with tests.  How we achieved this - read about it in the next post. </div><p>Source: <a href="https://habr.com/ru/post/326232/">https://habr.com/ru/post/326232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../326218/index.html">SMS history: how to transfer text via voice channel</a></li>
<li><a href="../326220/index.html">Pampering Writing Telegram bot on Google script</a></li>
<li><a href="../326222/index.html">When GitHub shoots you in the head, a new framework is created. The idea, concept and implementation of "Rutetider"</a></li>
<li><a href="../326226/index.html">IP and IT: the eternal dispute about the main thing</a></li>
<li><a href="../326230/index.html">How I was a developer, and now Timlid</a></li>
<li><a href="../326234/index.html">New version of Windows 10: sysadmin view</a></li>
<li><a href="../326236/index.html">Centrifugo - 3.5 million rpm</a></li>
<li><a href="../326238/index.html">RStudio Connect - Shiny "facelift" for corporate use</a></li>
<li><a href="../326240/index.html">Office in 100 machines, or a story about how I transferred the server from Windows to Centos 7. Prologue</a></li>
<li><a href="../326242/index.html">Performance is a holiday</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>