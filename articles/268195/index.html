<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Blocks. The internal structure of the Cach√© database file. Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This publication is a continuation of my article , in which I described how the Cach√© database is designed from the inside. In it, I described the typ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Blocks. The internal structure of the Cach√© database file. Part 2</h1><div class="post__text post__text-html js-mediator-article">  This publication is a continuation of my <a href="http://habrahabr.ru/company/intersystems/blog/267951/">article</a> , in which I described how the Cach√© database is designed from the inside.  In it, I described the types of blocks, how they are related, and how they relate to the global.  That article had a theory.  I created a project that allows you to visualize the tree of blocks - and in this article you will see all this.  Welcome under cat. <br><br> <a href="http://habrahabr.ru/company/intersystems/blog/268195/"><img src="https://habrastorage.org/files/65a/263/1ca/65a2631ca90840e1b1153abeff540c12.png"></a> <br><a name="habracut"></a><br>  To demonstrate, I created a new database and cleared all globals that Cach√© initializes by default for the newly created database.  Create a simple global: <br><br><pre><code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^colors(<span class="hljs-number"><span class="hljs-number">1</span></span>)=<span class="hljs-string"><span class="hljs-string">"red"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^colors(<span class="hljs-number"><span class="hljs-number">2</span></span>)=<span class="hljs-string"><span class="hljs-string">"blue"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^colors(<span class="hljs-number"><span class="hljs-number">3</span></span>)=<span class="hljs-string"><span class="hljs-string">"green"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^colors(<span class="hljs-number"><span class="hljs-number">4</span></span>)=<span class="hljs-string"><span class="hljs-string">"yellow"</span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/55e/a72/06e/55ea7206e0a34e82b338ee268538318d.png"><br><br>  Pay attention to the picture illustrating the blocks of the created global.  The global is simple, so we, of course, see its description in a block of type 9 (block of the catalog of globals).  Then the ‚Äúupper and lower pointer‚Äù block (type 70) goes right away, since the global tree is still shallow, and you can immediately point to the link to the data block that still fits into one 8KB block. <br><br>  Now we write to another global value in such a quantity that they could not fit in one block anymore - and we will see how new nodes appear in the block of pointers, which will refer to new data blocks that did not fit in the first block. <br><br>  We will write down 50 values ‚Äã‚Äãwith a length of 1000 characters.  Recall that the block size of our database is 8192 bytes. <br><br><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1000</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>=str_<span class="hljs-string"><span class="hljs-string">"1"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(i)=<span class="hljs-keyword"><span class="hljs-keyword">str</span></span> } quit</code> </pre><br>  Pay attention to the following picture: <br><br><img src="https://habrastorage.org/files/df1/d2a/00b/df1d2a00bea14e9092b2c6041f9eb6c5.png"><br><br>  At the block pointer level, we now have several nodes that reference data blocks.  Each data block has links to the next block (‚Äúright link‚Äù).  Offset - indicates the number of bytes used in this block of data. <br><br>  Now we will try to model block splitting.  We add to the first block so many values ‚Äã‚Äãthat the total block size of 8KB is exceeded, which will result in this block being split into two. <br><br><div class="spoiler">  <b class="spoiler_title">Code example</b> <div class="spoiler_text"><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1000</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>=str_<span class="hljs-string"><span class="hljs-string">"1"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>)=<span class="hljs-keyword"><span class="hljs-keyword">str</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>)=<span class="hljs-keyword"><span class="hljs-keyword">str</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>)=<span class="hljs-keyword"><span class="hljs-keyword">str</span></span></code> </pre></div></div><br>  The result can be seen below: <br><br><img src="https://habrastorage.org/files/ef8/a4b/1cc/ef8a4b1cceea45c4ae391f20c92ccce4.png"><br><br>  Block 50 was split, it was supplemented with new data, and the values ‚Äã‚Äãthat were pushed out of it are now in block 58. The link to this block appeared in the block of pointers.  Other blocks have not changed. <br><br><h2>  Example with long lines </h2><br>  When writing lines longer than 8KB (data block size) we get ‚Äúlong data‚Äù blocks.  We can simulate such a situation, for example, by writing lines of 10,000 bytes in size. <br><br><div class="spoiler">  <b class="spoiler_title">Code example</b> <div class="spoiler_text"><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">10000</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>=str_<span class="hljs-string"><span class="hljs-string">"1"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">50</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(i)=<span class="hljs-keyword"><span class="hljs-keyword">str</span></span> }</code> </pre></div></div><br>  Let's look at the result: <br><br><img src="https://habrastorage.org/files/aa7/411/e04/aa7411e04474410eaa94ec9c38bc41dd.png"><br><br>  As a result, the structure of the blocks in the picture is preserved, because  we did not add new nodes of the global, but only changed the values.  But the Offset value (the number of bytes occupied) for all blocks has changed.  For example, for block No. 51, the new value of Offset was 172, against 7088 the previous time.  It is clear that now, when the new value cannot fit in the block, the pointer to the last data byte should have changed, but where are our data now stored?  At the moment, my project has not yet implemented the ability to display information about "big blocks".  Let's turn to the ^ REPAIR utility to display information about the new content of block No. 51. <br><br><img src="https://habrastorage.org/files/ede/a9d/c69/edea9dc690da4eb5a51165804744f1b1.png"><br><br>  I will dwell in more detail on what this utility shows us.  We see a link to the right block number 52, the same number was specified in the parent block of pointers at the next node.  Global sorting is type 5. The number of nodes with large lines is 7. In some cases, a block may contain both data values ‚Äã‚Äãfor some nodes, and long lines for others, all within one block.  We also see which global link should be expected at the beginning of the next block (Next Pointer Reference). <br><br>  About blocks of long lines: here we see that the keyword BIG is specified as the value for the global, which tells us that the data is actually in ‚Äúlarge blocks‚Äù.  Further on the same line we see the total length of the contained line, and the list of blocks that store this value.  We can try to look at the "block of long lines", at number 73. <br><br><img src="https://habrastorage.org/files/b2c/aba/aa2/b2cabaaa274140abbeb023c1eb82279c.png"><br><br>  Unfortunately, this block is output unencrypted.  But here we can notice that after the overhead information from the block header (which is always 28 bytes long), the data entered is used.  And knowing what data, it is easy to decipher what is indicated in the title: <br><table><tbody><tr><td>  Position </td><td>  Value </td><td>  Description </td><td>  Read more </td></tr><tr><td>  0-3 </td><td>  E4 1F 00 00 </td><td>  offset indicates end of data </td><td>  it turns out 8164 plus 28 bytes of the header is 8192 bytes, <br>  unit is full. </td></tr><tr><td>  four </td><td>  18 </td><td>  block type </td><td>  the value 24, as we <a href="http://habrahabr.ru/company/intersystems/blog/267951/">remember</a> , is the type for a block of large strings. </td></tr><tr><td>  five </td><td>  05 </td><td>  sorting </td><td>  Sort 5, this is "standard cach√©" </td></tr><tr><td>  8-11 </td><td>  4A 00 00 00 </td><td>  right connection </td><td>  it turned out 74, <br>  as we remember our value is stored in block 73 and 74 </td></tr></tbody></table><br>  Let me remind you that the data in block 51 occupy only 172 bytes.  It happened at the moment when we kept great values.  It turns out that the block has become almost empty - the payload is 172 bytes, and it takes 8kb!  It is clear that in such a situation, the free space will eventually be filled with new values, but also Cach√© gives us the opportunity to compress such a global one.  To do this, the <a href="">% Library.GlobalEdit</a> class has a CompactGlobal method.  In order to make sure that this method is effective, we will repeat our example, but with a large amount of data, for example, having created 500 nodes. <br><br><div class="spoiler">  <b class="spoiler_title">That's what we did.</b> <div class="spoiler_text"><pre> <code class="hljs sql"> <span class="hljs-keyword"><span class="hljs-keyword">kill</span></span> ^<span class="hljs-keyword"><span class="hljs-keyword">test</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> l=<span class="hljs-number"><span class="hljs-number">1000</span></span>,<span class="hljs-number"><span class="hljs-number">10000</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>=<span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>:l { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> <span class="hljs-keyword"><span class="hljs-keyword">str</span></span>=str_<span class="hljs-string"><span class="hljs-string">"1"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i=<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">500</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ^<span class="hljs-keyword"><span class="hljs-keyword">test</span></span>(i)=<span class="hljs-keyword"><span class="hljs-keyword">str</span></span> } } quit</code> </pre><br>  Below we have shown not all the blocks, but the meaning should be clear.  We have a lot of data blocks, but with a small number of nodes. <br><br><img src="https://habrastorage.org/files/001/4f4/e35/0014f4e35e4d48b89c690089ccc88739.png"></div></div><br>  Execute the CompactGlobal method: <br><br><pre> <code class="hljs kotlin">w ##<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span></span>(%GlobalEdit).CompactGlobal(<span class="hljs-string"><span class="hljs-string">"test"</span></span>,<span class="hljs-string"><span class="hljs-string">"c:\intersystems\ensemble\mgr\habr"</span></span>)</code> </pre> <br>  Let's look at the result.  The block of pointers we now have only 2 nodes, i.e.  our values ‚Äã‚Äãall went into two data blocks, whereas earlier we had 72 nodes in a pointer block.  Thus, we got rid of 70 blocks, reducing, thus, the time to access the data with a full crawl of the global, as less reads are required on the blocks. <br><br><img src="https://habrastorage.org/files/2ec/f42/4db/2ecf424dbe53459cb8436e4315720111.png"><br><br>  CompactGlobal accepts several parameters for input, such as the name of the global, the database and the percentage of filling that we want to receive, with a default value of 90. And now we see that Offset (the number of bytes used) became equal to 7360, which is approximately the most 90% filling.  Several parameters of the output function: how many megabytes are processed and the number of megabytes after compression.  Previously, globals were compressed using the ^ GCOMPACT utility, which is currently considered obsolete. <br><br>  It is worth noting that the situation in which the blocks may remain incompletely filled is quite normal.  Moreover, global compression may not always be desirable.  For example, if your global is more readable and practically does not change, then compression can help.  But if the global is actively changing, then a certain sparsity in the data blocks will help to split the blocks less often, and the recording of new data will occur faster. <br><br>  In the next part I will talk about another possibility of my project, which was implemented in the framework of the recently passed <a href="http://habrahabr.ru/company/intersystems/blog/267459/">hackathon</a> at InterSystems school - about the distribution map of base blocks and its practical application. </div><p>Source: <a href="https://habr.com/ru/post/268195/">https://habr.com/ru/post/268195/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268183/index.html">BabylonJS Tutorial - Camera and Lighting</a></li>
<li><a href="../268187/index.html">Accelerate debugging and prototyping of mobile QML applications on a live device</a></li>
<li><a href="../268189/index.html">Silex skeleton + Gulp + LiveReload</a></li>
<li><a href="../268191/index.html">ZF2 + Blitz templates</a></li>
<li><a href="../268193/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ179 (September 28 - October 4, 2015)</a></li>
<li><a href="../268197/index.html">Home server on Intel Atom platform and Centos 7 OS</a></li>
<li><a href="../268199/index.html">Moscow metro map. SVG version</a></li>
<li><a href="../268203/index.html">PHP Digest number 71 - interesting news, materials and tools (September 21 - October 5, 2015)</a></li>
<li><a href="../268207/index.html">What is the difference between Snort and Cisco FirePOWER?</a></li>
<li><a href="../268211/index.html">What I learned about interfaces in the real world in China</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>