<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PyGTK: threads and magic wrappers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="GTK + is good for everyone, but there is a big problem when working with it in multi-threaded applications. GTK itself is thread-safe, but requiring f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PyGTK: threads and magic wrappers</h1><div class="post__text post__text-html js-mediator-article">  GTK + is good for everyone, but there is a big problem when working with it in multi-threaded applications.  GTK itself is thread-safe, but requiring forced blocking by the user.  The second problem is that the blocking is implemented through the mutexes, and you must block it strictly one time, otherwise your code will ‚Äúhang‚Äù on linux while working fine on windows. <br><a name="habracut"></a><br>  Experience has shown that the access method ‚ÄúAny stream appeals to the GUI, the main thing to cause blocking‚Äù was a failure: after some time, you can catch the core dump in the depths of GTK for a variety of reasons, which are useless to catch. <br><br>  <b>UP</b> : The code is uploaded to <a href="https://github.com/datacompboy/pygtk-gui">Github</a> , and slightly updated with the latest version of the code for the ‚Äúmain‚Äù project.  Cosmetic changes (Period instead of Seconds, and logging of the use of an erroneous flow for finding problem areas has been added. <br><br>  In this connection, in my small project I came to the following method of organizing the most trouble-free work with threads: <br><ol><li>  Any GTK calls are produced by only one thread.  All changes to the GUI are made by dedicated status update features. </li><li>  All locks are maintained through a common reentrant blocker. </li><li>  The lock also monitors the GUI from the "wrong" thread, logging it. </li></ol><br><h3>  General structure of the GUI part </h3><br>  The main part consists of a module gui.py, exporting the following "good": <br><pre><code class="python hljs">GtkLocker = CGtkLocker() <span class="hljs-comment"><span class="hljs-comment">#  def GtkLocked(f): #    gui,        def IdleUpdater(f): #    ,      gui def SecondUpdater(f): #    ,       def GUIstop(): #       GUI def GuiCall(Func): #    GUI ""  def GuiIdleCall(Func): #    GUI       def GuiSecondCall(Func): #       def GUI(): #    </span></span></code> </pre> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And the work of the application looks like this: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gui, gtk <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> GtkLocker: window = gtk.Window(gtk.WINDOW_TOPLEVEL) window.set_title(<span class="hljs-string"><span class="hljs-string">u"  "</span></span>) window.connect(<span class="hljs-string"><span class="hljs-string">"destroy"</span></span>, gui.GUIstop) window.realize() vbox = gtk.VBox() window.add(vbox) label = gtk.Label(<span class="hljs-string"><span class="hljs-string">"Text label"</span></span>) vbox.add(label) window.show_all() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__main__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> gui.GuiCall( InitApp ) gui.GUI() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: __main__() sys.exit(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><br>  This application does nothing but show a text box with the text label.  Let's do it humanly: we will move all the application code to the class and add a button. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CMyApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.label = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.times = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateGui</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> gui.GtkLocker: window = gtk.Window(gtk.WINDOW_TOPLEVEL) window.set_title(<span class="hljs-string"><span class="hljs-string">u"  "</span></span>) window.connect(<span class="hljs-string"><span class="hljs-string">"destroy"</span></span>, gui.GUIstop) window.realize() vbox = gtk.VBox() window.add(vbox) label = gtk.Label(<span class="hljs-string"><span class="hljs-string">"Welcome to our coool app!"</span></span>) vbox.pack_start(label) label = gtk.Label(<span class="hljs-string"><span class="hljs-string">"Here will be counter"</span></span>) self.label = label vbox.pack_start(label) button = gtk.Button(<span class="hljs-string"><span class="hljs-string">"Press me!"</span></span>) button.connect(<span class="hljs-string"><span class="hljs-string">"clicked"</span></span>, self.Click) vbox.pack_start(button) window.show_all() @gui.GtkLocked <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, widget)</span></span></span><span class="hljs-function">:</span></span> self.times += <span class="hljs-number"><span class="hljs-number">1</span></span> self.label.set_text(<span class="hljs-string"><span class="hljs-string">"You pressed button %d times"</span></span> % self.times) MyApp = CMyApp() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       """</span></span> MyApp.CreateGui()</code> </pre><br><br>  So what have we done?  They created an object whose <code>__init__</code> method simply prepared the future fields of the method, and all the actual creation is done in the <code>CreateGui</code> function, which will be called already from the general processing cycle of the event events. <br><br>  Now for the magic that the <code>Click</code> method is subject to: notice that it is marked with the <code>gui.GtkLocked</code> wrapper.  This means that this method is a method for handling GUI events, and is called strictly via connect, which means that at the time the method is called, it already has a GTK lock.  This wrapper implements the GUI state of the Locker Already Locked, so using a lock inside the function will not cause any problems. <br><br>  Add a second button that also makes the sea useful: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CMyApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateGui</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> gui.GtkLocker: .... button = gtk.Button(<span class="hljs-string"><span class="hljs-string">"Or me!"</span></span>) button.connect(<span class="hljs-string"><span class="hljs-string">"clicked"</span></span>, gui.GtkLocked(self.Count)) vbox.pack_start(button) .... @gui.GtkLocked <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, widget)</span></span></span><span class="hljs-function">:</span></span> self.Count() gui.GuiSecondCall( self.Count ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Count</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> gui.GtkLocker: self.times += <span class="hljs-number"><span class="hljs-number">1</span></span> self.label.set_text(<span class="hljs-string"><span class="hljs-string">"You pressed button %d times"</span></span> % self.times)</code> </pre><br><br>  So, we changed the <code>Click</code> method of the previous button to call the general <code>Count</code> method, and to the deferred call it with a delay of up to a second, which counts and updates the code regardless of the weather on Mars, and hung up on the second button <code>Count</code> . <br>  Since the <code>Count</code> method involves calling it not only via <code>connect</code> , we cannot hang <code>@gui.GtkLocked</code> on it - the method can be called from a context that is not yet blocked (for example, it is simply called in the idle event), therefore we mark <code>gui.GtkLocked</code> directly into moment of <code>connect</code>  As a result, the <code>Count</code> method can be called from an unblocked context and it will take the lock itself, but it is also bound to an event and another event handler calls it.  Due to the magic with <code>GtkLocker</code> and <code>GtkLocked</code> no deadlock happens, everything works. <br><br>  Now let's add His Highness Progress Bar, and a complex background process that updates its contents in the process: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CMyApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateGui</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> gui.GtkLocker: .... progress = gtk.ProgressBar() self.progress = progress vbox.pack_start(progress) T = threading.Thread(name=<span class="hljs-string"><span class="hljs-string">"Background work"</span></span>, target=self.Generate) T.setDaemon(<span class="hljs-number"><span class="hljs-number">1</span></span>) T.start() @gui.GtkLocked <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateProgress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.progress.pulse() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): time.sleep(<span class="hljs-number"><span class="hljs-number">0.3</span></span>) gui.GuiIdleCall( self.UpdateProgress )</code> </pre><br><br>  So, our <code>Generate</code> method works on the background, and every 0.3 seconds it wants to update progress, for which it adds <code>UpdateProgress</code> execution <code>UpdateProgress</code> .  Since <code>UpdateProgress</code> runs in the context of a thread's GUI, everything works.  That is just what will happen if we do not know the time required for implementation?  Update on every sneeze?  Replace 0.3 with 0.001 - and admire the result.  No, this is not an option.  Add time measurements and artificially slow down the update?  Generally not an option.  Maybe instead of <code>GuiIdleCall</code> do <code>GuiSecondCall</code> ?  Let's try ... M-yes.  Every second there is a sharp update of all events executed during this second.  Horror. <br><br>  Let's add one more background process, and to it a ‚Äúsmart‚Äù update method: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CMyApp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateGui</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> gui.GtkLocker: .... fastprogress = gtk.ProgressBar() self.fastprogress = fastprogress vbox.pack_start(fastprogress) T = threading.Thread(name=<span class="hljs-string"><span class="hljs-string">"Heavy background work"</span></span>, target=self.GenerateFast) T.setDaemon(<span class="hljs-number"><span class="hljs-number">1</span></span>) T.start() @gui.SecondUpdater <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SingleUpdateProgress</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.fastprogress.pulse() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateFast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>): time.sleep(<span class="hljs-number"><span class="hljs-number">0.001</span></span>) self.SingleUpdateProgress()</code> </pre><br><br>  Magic, delight!  We simply declare the state update function and hang the necessary wrapper on it: <code>@gui.SecondUpdater</code> or <code>@gui.IdleUpdater</code> , and the method will be automatically called in the context of the GUI stream no more than once per second or in free time.  Due to the wrappers, the double launch of the method in a row is excluded, it does not require an extra accounting code whether it was called and there is no need to think about folding into the execution queue. <br><h3>  Under the hood </h3><br>  So let's take a close look at what's inside the gui.py. <br><br>  The common code is nothing complicated, just initialization: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> __future__ <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> with_statement <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> logging, traceback logging.basicConfig(level=logging.DEBUG, filename=<span class="hljs-string"><span class="hljs-string">'debug.log'</span></span>, filemode=<span class="hljs-string"><span class="hljs-string">'a'</span></span>, format=<span class="hljs-string"><span class="hljs-string">'%(asctime)s %(levelname)-8s %(module)s %(funcName)s %(lineno)d %(threadName)s %(message)s'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pygtk pygtk.require(<span class="hljs-string"><span class="hljs-string">'2.0'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gtk gtk.gdk.threads_init() <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> gobject, gtk.glade, Queue, sys, configobj, threading, thread <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> functools <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wraps <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time, os.path gtk.gdk.threads_enter() IGuiCaller = Queue.Queue() IGuiIdleCaller = Queue.Queue() IGuiSecondsCaller = Queue.Queue() IdleCaller = [ <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> ] IdleCallerLock = threading.Lock() gtk.gdk.threads_leave() <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGtkLocker</span></span></span><span class="hljs-class">:</span></span> .... <span class="hljs-comment"><span class="hljs-comment">#    GtkLocker = CGtkLocker() #   GUI  --   main_quit,   GUI  @IdleUpdater def GUIstop(*args, **kwargs): gtk.main_quit() # ,     . #    (gobject)  , #  threading.Queue,     . def GuiCall(Func): IGuiCaller.put(Func) with IdleCallerLock: if IdleCaller[0] == False: gobject.idle_add(GUIrun) IdleCaller[0] = True def GuiIdleCall(Func): IGuiIdleCaller.put(Func) with IdleCallerLock: if IdleCaller[0] == False: gobject.idle_add(GUIrun) IdleCaller[0] = True def GuiSecondCall(Func): IGuiSecondsCaller.put(Func) #    GUI  def GUIrun(): #     GuiCaller try: Run = IGuiCaller.get(0) #   idle ,  GTK   # ,   ,    #      "with GtkLocker:" ,  @GtkLocked with GtkLocker: Run() except Queue.Empty: #    --  GuiIdleCaller try: Run = IGuiIdleCaller.get(0) with GtkLocker: Run() except Queue.Empty: #     -- ,   with GtkLocker: IdleCaller[0] = False return False return True #   :     #     def GUIrunSeconds(): try: with GtkLocker: while (True): Run = IGuiSecondsCaller.get(0) Run() except Queue.Empty: pass return True #    def GUI(): #   gobject.idle_add(GUIrun) IdleCaller[0] = True gobject.timeout_add(1000, GUIrunSeconds) #     gtk.main gtk.gdk.threads_enter() #    GtkLocker, #   gtk.main    GtkLocker.FREE() #     GUI  gtk.main() #   main_quit,   main    gtk.gdk.threads_leave()</span></span></code> </pre><br><br>  Now look at the most interesting: wrappers.  So, the most important of them is the implementation of a reentrant lock: <br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CGtkLocker</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#       self.lock = threading.Lock() self.locked = 1 # ,      self.thread = thread.get_ident() #   ,     GUI    self.mainthread = self.thread self.warn = True #   ,   N  # ,     with  def __enter__(self): #       with self.lock: DoLock = (thread.get_ident()!=self.thread) #   ,   -       if self.warn and self.mainthread != thread.get_ident(): logging.error("GUI accessed from wrong thread! Traceback: "+"".join(traceback.format_stack())) #        with  ,      if DoLock: #        gtk.gdk.threads_enter() #             with self.lock: self.thread = thread.get_ident() #  __enter__    self.locked += 1 return None #     with  (  -- ,   ..) def __exit__(self, exc_type, exc_value, traceback): #      ,       with self.lock: self.locked -= 1 if self.thread!=thread.get_ident(): print "!ERROR! Thread free not locked lock!" logging.error("Thread free not locked lock!") sys.exit(0) else: if self.locked == 0: self.thread = None gtk.gdk.threads_leave() return None #    :      . def FREE(self): self.locked -= 1 self.thread = None if self.locked != 0: print "!ERROR! Main free not before MAIN!" logging.error("Main free not before MAIN!") sys.exit(0) GtkLocker = CGtkLocker()</span></span></code> </pre><br><br>  It should be understood that in " <code>with GtkLocker</code> " any piece that works with the GUI should be wrapped. <br>  And in most cases, it will work, even if all calls go from different threads, for that <code>threads_enter</code> / <code>threads_leave</code> and created.  But only sometimes everything works for the time being, and suddenly falls into the crust somewhere in the depths of GTK. <br><br>  <code>GtkLocker</code> wrapper <code>GtkLocker</code> that allows you to mark event methods that are called by the GTK kernel already inside the lock.  Being called at the zero level increases the level of the blocking level, thus ensuring that we do not call <code>threads_enter</code> / <code>threads_leave</code> . <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GtkLocked</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span><span class="hljs-function">:</span></span> @wraps(f) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwds)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> GtkLocker.lock: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GtkLocker.thread == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> GtkLocker.thread==thread.get_ident(): GtkLocker.thread = thread.get_ident() GtkLocker.locked += <span class="hljs-number"><span class="hljs-number">1</span></span> WeHold = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"!ERROR! GtkLocked for non-owned thread!"</span></span> logging.error(<span class="hljs-string"><span class="hljs-string">"GtkLocked for non-owned thread!"</span></span>) WeHold = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> ret = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(*args, **kwds) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> WeHold: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> GtkLocker.lock: GtkLocker.locked -= <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> GtkLocker.locked == <span class="hljs-number"><span class="hljs-number">0</span></span>: GtkLocker.thread = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wrapper</code> </pre><br><br>  Well, the last magical pass: <code>IdleUpdater</code> / <code>SecondUpdater</code> : <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IdleUpdater</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f)</span></span></span><span class="hljs-function">:</span></span> @wraps(f) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*args, **kwds)</span></span></span><span class="hljs-function">:</span></span> self = len(args)&gt;<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> isinstance(args[<span class="hljs-number"><span class="hljs-number">0</span></span>], object) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> args[<span class="hljs-number"><span class="hljs-number">0</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-string"><span class="hljs-string">'_idle_wrapper'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.__dict__: self._idle_wrapper = {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runner</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._idle_wrapper[f]: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f(*args, **kwds) <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>: self._idle_wrapper[f] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self._idle_wrapper <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self._idle_wrapper[f]: self._idle_wrapper[f] = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-comment"><span class="hljs-comment">#  SecondUpdater   GuiSecondCall GuiIdleCall( runner ) return wrapper</span></span></code> </pre><br><br>  In the object whose method we are calling, a <code>_idle_wrapper</code> dictionary is <code>_idle_wrapper</code> , in which the tracking is carried out, whether this method has already been queued for execution or not, and if not, we remember that we have inserted and added a launch wrapper that will execute this method and reset the flag .  As a result, the first method call will add its launch to the <code>GuiIdleCall</code> (or <code>*Seconds*</code> ) queue, and repeated calls until its execution will be simply ignored. <br><h3>  Download codes and useful information </h3><br>  All sources of the example are available: <a href="">pygtk-demo.tar.bz2</a> . <br>  For useful information on PyGTK known issues in its official <a href="http://faq.pygtk.org/">FAQ</a> . <br>  For writing under PyGTK, I often refer to the <a href="http://www.pygtk.org/tutorial.html">tutorial</a> and <a href="http://www.pygtk.org/docs/pygtk/index.html">manual</a> . </div><p>Source: <a href="https://habr.com/ru/post/120668/">https://habr.com/ru/post/120668/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120661/index.html">PDO: serialization, late initialization and PHPUnit</a></li>
<li><a href="../120662/index.html">Runtime Magic: Inspect Objective-C Objects</a></li>
<li><a href="../120663/index.html">News from Sony: two more corporation sites hacked</a></li>
<li><a href="../120664/index.html">1000 targeted visitors with Facebook for $ 10</a></li>
<li><a href="../120665/index.html">10 "one-liners" that will impress your friends</a></li>
<li><a href="../120669/index.html">QIWI Wallet today is 5 years old</a></li>
<li><a href="../120670/index.html">Automation of highways through the eyes of an IT person</a></li>
<li><a href="../120671/index.html">Android Emulator and local web server (Denwer)</a></li>
<li><a href="../120673/index.html">Creating a private NuGet package tape using an online service</a></li>
<li><a href="../120674/index.html">.NET Micro Framework: Porting in Brief</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>