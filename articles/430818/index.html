<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Accelerate SQLAlchemy for architectural astronauts</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Habr, this is a report by software engineer Alexey Starkov at the Moscow Python Conf ++ 2018 conference in Moscow. Video at the end of the post.  Hell...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Accelerate SQLAlchemy for architectural astronauts</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/nk/mr/3o/nkmr3o45oaha-8h6n1elhxx3nai.png"><br><blockquote>  Habr, this is a report by software engineer Alexey Starkov at the Moscow Python Conf ++ 2018 conference in Moscow.  Video at the end of the post. </blockquote> Hello!  My name is Alexey Starkov - I, in my best years, work at the plant. <br>  Now I work at Qrator Labs.  Basically, all my life, I have been involved in C and C ++ - I love Alexandrescu, ‚ÄúGang of Four‚Äù, the principles of SOLID - that‚Äôs all.  Which makes me an architectural astronaut.  The last couple of years I've been writing in Python, because I like it. <br><br>  Actually, who are the ‚Äúarchitectural astronauts‚Äù?  The first time I met this term was Joel Spolsky, you probably read it.  He describes "astronauts" as people who want to build an ideal architecture, who hang an abstraction, above an abstraction, above an abstraction that is becoming more and more common.  In the end, these levels go so high that they describe all possible programs, but they do not solve any practical problems.  At this point, the "astronaut" (this is the last time this term is surrounded by quotes) ends the air and he dies. <br><br>  I also have a tendency towards architectural cosmonautics, but in this report I will talk a little about how it bit me and did not allow me to build a system with the necessary performance.  The main thing - how I overcame it. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The summary of my report: was / became. <br><a name="habracut"></a><br><img src="https://habrastorage.org/webt/wj/_u/7c/wj_u7c0h2uaody3dj48xsbytsb4.png"><br><br>  An increase of thousands and millions of times.  When I made this slide, the only thought I had was, ‚ÄúHow?‚Äù <br><br><img src="https://habrastorage.org/webt/of/cb/q_/ofcbq_bd033u4wh31hzexjkstfc.png"><br><br>  Where could I have done so much?  If you do not want to mess up just like me - read on. <br><br><img src="https://habrastorage.org/webt/md/ni/gt/mdnigtyu3igzmlqmcf89isptecc.png"><br><br>  I will talk about the system configuration.  The configuration system is an internal tool in Qrator Labs that stores the configuration for Software Defined Network (SDN), our filtering network.  It is committed to synchronizing the configuration between components and keeping track of its state. <br><br><img src="https://habrastorage.org/webt/xz/kg/zr/xzkgzr2wrphmvslxnx3v2qezxta.png"><br><br>  What does it briefly consist of?  We have a database that stores a replica of our configuration for the entire network, and there is a server that processes the commands that come to it and in some way changes the configuration. <br><br>  Our technical administrators and clients come to this server and using the console, through end-API endpoints, REST API, JSON RPC and other issues commands to the server, as a result of which it changes our configuration. <br><br>  Commands can be as simple as they are more difficult.  Then, we have a certain set of receivers that make up our SDN and the server pushes the configuration to these receivers.  Sounds pretty simple.  Basically, I will talk about this part here. <br><br><img src="https://habrastorage.org/webt/yp/uq/c7/ypuqc7pzaeqvmbzsrksb9gefq-w.png"><br><br>  Because it is related to the database and to alchemy. <br><br><img src="https://habrastorage.org/webt/qg/sz/np/qgsznprvrp4smdpbuoxopevxxt4.png"><br><br>  What is the peculiarity of this system?  It is quite small - mediocre.  Hundreds of thousands, to millions, of entities are stored in this database.  The peculiarity is that the graph of relationships between entities is rather complicated.  There are several hierarchies of inheritance between entities, there are inclusions, there are simply dependencies between them.  All these restrictions are due to business logic and we must comply with them. <br><br>  The ratio of write requests to read requests is approximately 15: 1.  Here it is clear: a lot of commands come to change the configuration and once in a long period of time we push the configuration to the end points. <br><br>  MySQL is used internally - it is also available in other products of our company, we have quite a serious expertise on this database, there are people who know how to work with it: build a data scheme, design queries and everything else.  Therefore, we took MySQL as a universal relational database. <br><br><img src="https://habrastorage.org/webt/x0/xs/ae/x0xsae3wqaqw4dfth-y8q7i3tqk.png"><br><br>  What was the problem after we designed this system?  The execution of one command took from one to thirty seconds, depending on the complexity of the command.  Accordingly, the delay of execution reached five minutes.  One team came - 30 seconds, the second and so on, a pile of accumulated - a delay of 5 minutes. <br><br>  The delay in applying the configuration is up to ten minutes.  It was decided that this is not enough for us and it is necessary to carry out optimization. <br><br><img src="https://habrastorage.org/webt/ah/6t/fj/ah6tfjmleq-fzvoecldzw5qxxu0.png"><br><br>  The first is that before carrying out any optimization, it is necessary to investigate and find out what the matter is. <br><br><img src="https://habrastorage.org/webt/nu/wf/g6/nuwfg6v2hg2jangw6agmu9i6bw0.png"><br><br>  As it turned out, we lacked the most important component to investigate - we did not have telemetry.  Therefore, if you are designing a system, first, at the design stage, lay telemetry into it.  Even if the system is initially small, then a little more, then even more - as a result, everyone comes to a situation where you need to watch the traces, but there is no telemetry. <br><br><img src="https://habrastorage.org/webt/eh/ws/3t/ehws3tezqmrdlvfcljs1pxbttgm.png"><br><br>  What can be done next if you do not have telemetry?  You can analyze the logs.  Here, quite simple scripts go through our logs and turn them into such a table, illustrating the fastest, slowest and average command execution time.  Starting from here, we already see in which places we have gaps: which commands are executed longer, which ones are faster. <br><br><img src="https://habrastorage.org/webt/m6/0a/gc/m60agccykga4hl82ktrjfjglzqq.png"><br><br>  The only thing that should be noted - analyzing the logs, we consider only the execution time of these commands on the server.  This is the first stage - the one that is marked as t2.  t1 is how the client sees the execution time of our team: getting into the queue, waiting, execution on the server.  This time will be longer, so we optimize the time t2, and then use the time t1 to determine whether we have reached the goal. <br><br>  t1 is the metric of the quality of our speed. <br><br><img src="https://habrastorage.org/webt/dx/dd/05/dxdd05sisxq1ciu6nu-na0zons8.png"><br><br>  Respectively, this is how we all teams repurposed - that is, we took a log from the server, drove it through our scripts, looked at it and identified the components that work most slowly.  The server is built quite modularly, a separate component is responsible for each command, and we can profile the components individually - and make benchmarks for them.  We had such a class - for each problem component we wrote, in which we did some activity in code_under_test (), depicting the combat use of the component.  And there were two methods: profile () and bench ().  The first one calls cProfile, showing how many times what is called, where the bottlenecks are. <br><br>  bench () was run several times and considered us different metrics - this is how we evaluated the performance. <br><br>  But it turned out that the problem is not that! <br><br><img src="https://habrastorage.org/webt/wz/r8/-p/wzr8-pc9epal61cjoraog7bkvxc.png"><br><br>  The main problem was in the number of queries to the database.  There were a lot of requests and, in order to understand why there were so many of them, let's look at how everything was organized. <br><br><img src="https://habrastorage.org/webt/bg/r0/rz/bgr0rzhohcouyykpc3raznbi4rq.png"><br><br>  Before us is a piece of a simple circuit representing our receivers, represented in the form of the Reciever class.  They are united in some group - receiver group.  And, accordingly, there are some configuration patterns ‚Äî configuration slices, which are a subset of configurations that are responsible for one ‚Äúrole‚Äù of this receiver.  For example, for routing - the routing plane.  Plains with receivers can be connected in any order - that is, this attitude is ‚Äúmany to many‚Äù. <br><br>  This is a piece of a large scheme, which I give here so that further examples are clear. <br><br>  What does every architectural astronaut want to do when he sees someone else's API?  He wants to hide it, to abstract and write its own interface, in order to be able to remove this API, or rather hide it. <br><br><img src="https://habrastorage.org/webt/nq/zq/7-/nqzq7-zlnbxkkmy7mywbp8lqvq4.png"><br><br>  Accordingly, there is a ‚Äúdirty‚Äù API of alchemy, in which there are, in fact, mappers and our ‚Äúclean‚Äù class - Receiver, in which some configuration is stored and there are methods: load (), save (), delete ().  And all the other related classes.  We have a graph of Python objects that are somehow related to each other - each of them has a load (), save (), delete () method, which refers to the mapper of alchemy, which, in turn, refers to the API. <br><br><img src="https://habrastorage.org/webt/cs/bo/lr/csbolr6uozuvbxhimmqik_llgak.png"><br><br>  The implementation here is very simple.  We have a load method that makes a query into the database and for each received object creates its own Python object.  There is a save method that does the reverse operation ‚Äî it looks if there is an object in the database, using the primary key, if not, it creates, adds, and then we save the state of this object.  delete by the primary key gets and deletes an object from the database. <br><br><img src="https://habrastorage.org/webt/fl/hq/lp/flhqlp2vg6srgo7wswpbowrlq6e.png"><br><br>  The main problem is immediately visible - this is mapping.  At first we do it once from the Python object to the mapper, then the mapper mappit to the base.  Additional mapping is one or two calls, which may not be so scary.  The main problem was the manual synchronization.  We have two objects of our "clean" interface and one of them has an attribute change - how do we see that the attribute has changed in the other?  No  You need to merge the changes into the database and get the attribute in another object.  Of course, if we know that objects are present in the same context, we can somehow track this.  But if we have two sessions in different places - only through the base, or to base the base in memory, which we did not do. <br><br>  This load / save / delete is another mapper that completely duplicates the guts of alchemy, which is well written, tested.  This tool has been around for many years, a lot of help is available on the Internet and duplicating it is also not very good. <br><br>  See the icon in the upper right corner?  So I will mark the slides, on which something is done for ‚Äúpurity‚Äù, for increasing the level of abstraction, for architectural cosmonautics.  That is, slides without this icon are pragmatic and boring, uninteresting and can be not read. <br><br>  What to do if a lot of requests are slow.  How many?  Actually a lot.  Imagine a chain of inheritance: one object, it has one parent, that one has another parent.  We synchronize the child object - in order to do this, you first need to synchronize the parents.  In order to synchronize the parent, you need to synchronize and his parent.  Well, all synchronized.  Actually, depending on how we built the graph, we could walk and synchronize all these objects a hundred times - hence a large number of requests. <br><br><img src="https://habrastorage.org/webt/zo/n7/uh/zon7uhhtngwjd5rnaztxexuatsu.png"><br><br>  What have we done?  We took all our business logic and put it in the mapper.  All other objects we have also merged with mappers and all of our API, the entire data abstraction layer, turned out to be "dirty." <br><br><img src="https://habrastorage.org/webt/qn/4a/fz/qn4afzy7q6yrh0t-yw4r4m6c9se.png"><br><br>  This is how it looks in Python - our mapper has some kind of business logic, and there is a declarative description of this table.  Columns are listed, relationships.  Here is such a class. <br><br><img src="https://habrastorage.org/webt/ez/ud/sg/ezudsgqk1b9domctg8sdvzh4uj8.png"><br><br>  Of course, from the point of view of any astronaut, a dirty API is a disadvantage.  Business logic in the declarative description of the database.  Schemes mixed with business logic.  Fu  Ugly. <br><br>  The description of the scheme is cluttered.  This is actually a problem - if we do not have two lines of business logic, but a larger volume, then we need to scroll or search for a long time in this class in order to get to specific descriptions.  Before that, everything was beautiful: in one place the description of the base, the declarative description of the schemes, in another place the business logic.  And then the scheme is cluttered. <br><br>  But, on the other hand, we immediately get the mechanisms of alchemy: unit of work, which allows us to track which objects are dirty and which relays need to be updated;  we receive the relationship, allowing to get rid of additional questions in a database, without watching that the corresponding collections were filled;  and the identity map that helped us the most.  The Identity map guarantees that two Python objects will be the same Python object if they have a primary key. <br><br>  Accordingly, we immediately dropped the difficulty to linear. <br><br><img src="https://habrastorage.org/webt/j4/ek/x8/j4ekx8dvwphpdavetrxejd1uvxg.png"><br><br>  These are intermediate results.  The speed immediately increased 10 times, the number of queries to the database fell by about 40-80 times and the RPS rose to 1-5.  Oh well.  But the API is dirty.  What to do? <br><br><img src="https://habrastorage.org/webt/kj/po/hs/kjpohswqs8svlzroeizbub0tpmk.png"><br><br>  Mixins  We take business logic, again we take it out of our mapper, but so that again there is no mapping, we will inherit our mapper inside alchemy from our mixin.  Why not in the opposite direction?  In alchemy, this will not work, she will curse and say: "You have two different classes referring to the same tablet, there is no polyformism - go here."  Is that allowed. <br><br>  Thus, we have a declarative description in the mapper, which is inherited from the mixin and gets all the business logic.  Very comfortably.  And the rest of the classes are exactly the same.  It would seem - cool, everything is clean.  But there is one caveat - connections and relays remain inside alchemy, and when we have, say, join through an intermediate table secondary table, then the mapper of this label will somehow be present in the client code, which is not very beautiful. <br><br>  Alchemy would not be such a good, famous, framework if it did not give an opportunity to compete with it. <br><br><img src="https://habrastorage.org/webt/g6/dz/gg/g6dzggup-pvokdl7h4mguhedazc.png"><br><br>  What does mixin look like?  He has business logic, mappers separately, a declarative description of the table.  Communications remain within alchemy, but business logic is separate. <br><br>  What does the general scheme look like? <br><br><img src="https://habrastorage.org/webt/xl/1c/eh/xl1cehyjtaoqytk_gz5h-wbc5we.png"><br><br>  We have a schema file that contains all of our declarative classes ‚Äî let's call it schema.py.  And we have entities in business logic, separately.  And, these entities are inherited inside the schema file - we write a separate class for each entity, and inherit it in the schema.  Thus, the business logic lies in one pile, the scheme is in the other, and they can be independently changed. <br><br><img src="https://habrastorage.org/webt/rj/cl/ql/rjclqll79e8wcjwkjfxova8hhpe.png"><br><br>  As an example of improvement, we will consider a simple scheme of two plates: receivers (Receiver table) and configuration slices (ReceiverPlanes table).  The configuration slices with the many-to-one relationship are associated with the receivers label.  There is nothing especially complicated. <br><br>  In order to hide the relationships inside the ‚Äúdirty‚Äù interface of alchemy, we use relationships and collections. <br><br><img src="https://habrastorage.org/webt/mz/ih/qg/mzihqg-lfqb8vhflbkxjpf8igp8.png"><br><br>  They allow us to hide our mappers from client code. <br><br><img src="https://habrastorage.org/webt/y8/qc/v1/y8qcv1qj8_jq3y_pn-2xw-t6bji.png"><br><br>  In particular, two very useful collections are association_proxy and attribute_mapped_collection.  We use them together.  How a classic relationship works in alchemy: we have a relationship - this is a kind of collection, list, mappers.  Mappers objects are the far end of the relationship.  Attribute_mapped_collection allows you to replace this list with a dict, the keys in which are some of the attributes of the mappers, and the values ‚Äã‚Äãare the mappers themselves. <br><br>  This is the first step. <br><br><img src="https://habrastorage.org/webt/ho/tj/tt/hotjtty0hmg99f_kquecwyo4ms4.png"><br><br>  The second step, we are doing association_proxy over this relation.  It allows us not to transfer the mapper to the collection, but to transfer some value that will later be used to initialize our mapper, ReceiverPlanes. <br><br>  Here we have a lambda, in which we give the key and value.  The key turns into the name of the configuration slice, and the value becomes the value of the configuration slice.  As a result, in the client code, everything looks like this. <br><br><img src="https://habrastorage.org/webt/ko/00/s7/ko00s71bgaxu6i-h_baocnnqz-w.png"><br><br>  We just put some dictation in some dictionary.  Everything works: no mappers, no alchemy, no databases. <br><br>  True, there are pitfalls. <br><br><img src="https://habrastorage.org/webt/ux/ji/uy/uxjiuybsymdbtrvqlazqhckdv8c.png"><br><br>  If we assign two different keys to one key, or even one, values ‚Äã‚Äã‚Äî for each such set item lambda is called, an object is created - a mapper.  And, depending on how the scheme is arranged, this can lead to different consequences, from ‚Äújust violation of constraints‚Äù to unpredictable consequences.  For example, you sort of object removed from the collection, but he still remained there: you only deleted one.  When I first started, I killed a lot of time for such things. <br><br>  And a bit implicit sync.  Association_proxy and attribute_mapped_collection may be slightly delayed: when we create a mapper object, it is added to the database, but it is not yet present in the collection attribute.  It will appear there only when the attribute expires in this session.  When it is expired, a new synchronization with the database will occur and it will get there. <br><br>  To fight this, we used our own, self-written, collections.  This is not even alchemy - you can simply create your own collection to overcome all this. <br><br><img src="https://habrastorage.org/webt/bk/l6/ya/bkl6yaerwagttjp6qprlfbsdpaw.png"><br><br>  There is more code and the most important section is highlighted.  We have a certain collection that inherits from muteble mapping - this is a dictation, in the keys of which you can change values.  And there is the _get_plane_obj method - to get the configuration slice object. <br><br>  Here we do simple things - we try to get it by name, by some primary key and, if not, then we create and return this object. <br><br>  Further we redefine only two methods: __setitem__ and __getitem__ <br>  In __setitem__, we put these objects in our collection, in a relationship.  The only thing is that we assign the value at the very end.  Thus, we implement the same mechanism as association_proxy - we pass there the value, the dict, and it is assigned to the corresponding attribute. <br><br>  __getitem__ does reverse manipulation.  It receives a key from an object from a relay and returns its attribute.  There is also a small underwater stone here - if you cache a collection inside our mapping, it is possible to slightly out of sync.  Because when alchemy has a collection attribute, then the collection is replaced with another one after it expires.  Therefore, we can save the reference for the old collection and not know that the old has expired and a new one has already appeared.  Therefore, in the last part we go straight to the alchemy instance, again we get the collection through __getattr__ and we do __getitem__ from it.  That is, we cannot cache the Planes collection here. <br><br><img src="https://habrastorage.org/webt/_0/l6/tt/_0l6tt3pcdjmsxlwy2hivf1b4ty.png"><br><br>  How does this collection spike on our mixins?  As usual - we get a collection attribute.  The only interesting place is that when we load an instance from the database, the __init__ method is not called.  All attributes are substituted after the fact. <br><br>  Alchemy gives the standard decorator reconstructor, which allows you to mark a method as callee after loading an object from the base.  And just at boot time we have to initialize our collection.  Self - just this instance.  The use is exactly the same as in the previous example. <br><br><img src="https://habrastorage.org/webt/qe/yr/h4/qeyrh4fd3cmfpm8-exbfd1rwpkw.png"><br><br>  But we still have the database ears visible in the schema - this is the configuration.  What type of configuration?  Is it varchar or is it a blob?  In fact, the client is not interested.  He has to work with abstract entities of his level.  For this, alchemy provides type decoration. <br><br><img src="https://habrastorage.org/webt/ds/lc/ic/dslcicbf3yrljfchfwbxhcucleq.png"><br><br>  A simple example.  Our database stores IPAddress as a varchar.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We use the TypeDecorator class, which is included in alchemy, which allows, first, to specify which underlying database type will be used for this type and, second, to define two parameters: process_bind_param that converts the value to the database type and process_result_value, when we value from the database type, we translate into a Python object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The attribute from address acquires the Python type IPAddress. And we can both call methods of this type and assign objects of this type to it and everything works for us. And the database is stored ... I do not know what is stored, varchar (45), but we can replace that line and the blob will be stored. Or if some native type supports IP addresses, then you can use it. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The client code does not depend on it, it does not need to be rewritten.</font></font><br><br><img src="https://habrastorage.org/webt/xb/m5/uu/xbm5uu_ryeji94kthsv0rp2ogdw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another interesting thing - we have a version. We want that as soon as we change our object, the version is immediately increased. We have some version counter, we have changed the object - it has changed, the version has increased. We do this automatically, so as not to forget. </font></font><br><br><img src="https://habrastorage.org/webt/zy/g5/ro/zyg5rofkv1ibi-yb-kuv3kikbww.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this we used the event. Events are events that occur at different stages of a mapper's life and they can be triggered when attributes change, when an entity transitions from one state to another, for example, ‚Äúcreated‚Äù, ‚Äúsaved to base‚Äù, ‚Äúloaded from base‚Äù, ‚Äúdeleted‚Äù; and also - at session level events, before the sql-code is issued to the database, before the commit, after the commit, also after the rollback.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alchemy allows us to assign handlers for all these events, but the order of execution of handlers for the same event is not guaranteed. That is, it is certain, but it is not known what. Therefore, if the order of execution is important to you, then you need to make a registration mechanism. </font></font><br><br><img src="https://habrastorage.org/webt/wb/h2/w1/wbh2w1k4s4y6jqemt4oatlknwug.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is an example. Three events are used here:</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">on_before_flush - before the sql-code is emitted to the database, we go through all the objects that alchemy has marked as dirty in this session and check if this object is modified or not. Why is this necessary if alchemy has already marked everything? Alchemy marks an object as dirty as soon as an attribute has changed. If we assign this attribute the same value that it had, it will be marked as dirty. For this, there is a session method is_modified - it is used internally, I have not drawn it. Further, from the point of view of our semantics, from the point of view of our business logic, even if the attribute has changed - the object can still remain unmodified. For example, there is a certain list, in which two elements were swapped - from the alchemy point of view, the attribute has changed, but for business logic it doesn‚Äôt matter if the list contains, say,some kind of.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And, as a result, we call another method specific to each object in order to understand whether the object is actually modified or not. And we add them to a certain variable associated with the session that we created ourselves - this is our dirty_instances variable to which we add this object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The next event occurs before the commit - before_commit. Here, too, there is a small pitfall: if for the entire transaction we did not have a single flush, then flush will be called before the commit ‚Äî in my case, the handler before the commit was called before the flush. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As you can see, what we have done in the previous paragraph may not help us and session.dirty_instances will be empty. Therefore, inside the handler, we once again do the flush, so that all the handlers before the flush volunteer and just increment the version by one.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after_commit, after_soft_rollback - after a commit just clean, so that the next time there are no excesses. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So you see, this install_handler method installs handlers for three events at once. As a class, we pass the session here, as this is an event of its level.</font></font><br><br><img src="https://habrastorage.org/webt/oi/w8/pk/oiw8pkhgdpx7shz7rqrovfmg6lk.png"><br><br>  Here you go.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I will remind you what we have achieved - the speed of 30-40 seconds for complex and large teams. Not at all, some were performed in a second, others in 200 milliseconds, as you can see from the RPS. Requests in the database began to number in the hundreds. </font></font><br><br><img src="https://habrastorage.org/webt/7p/wk/qo/7pwkqo4-g_hksl5m_cqoo3xph5y.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The result was a fairly balanced system. There was, however, one nuance. Some requests come from us in batches, emissions. That is, 30 requests arrive, and each of them is such! (the speaker shows a thumb) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we process them in one second, the last request in the queue will work for 30 seconds. The first is one, the second is two, and so on. </font></font><br><br><img src="https://habrastorage.org/webt/ut/br/gl/utbrglrwurgv0uux2yk8eme4owg.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, we need to accelerate.</font></font> What do we do? <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, alchemy consists of two parts. The first is an abstraction over the sql database called SQLAlchemy Core. The second is the ORM, the actual mapping between the relational database and the object representation. Accordingly, the alchemy core approximately one to one coincides with the sql - if you know the latter, then you will not have problems with the core. If you do not know sql - learn sql. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition, the core represents the smallest overhead. There is practically no pumping - requests are generated using a request generator, and then executed. Overhead over dbapi minimum.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can build queries of any complexity, of any type, we can optimize them for the task. That is, if in the general case ORM doesn't care how we build the database schema, there is a certain description of the tables, it generates some queries, not knowing what in this case will, for example, optimally remove from here, in the other - from there, here apply the filter, and there it is different, then we can make requests for the task. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The disadvantage is that we again came to manual synchronization. All events, relays - all this in the core does not work. We made a select, objects came to us, we did something with them, then an update, an insert ... you need to increment the version, check the constraints yourself. Core does not allow all this to be done conveniently, at a high level. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Well, we are not living the first day.</font></font><br><br><img src="https://habrastorage.org/webt/qx/kk/bx/qxkkbxwleeqwvdukaghimiat7sw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A simple example of use. Each mapper inside contains an __table__ object that is used in the core. Next, you see - we take the usual select, we list the columns, join two plates, indicate the left and right, indicate by what condition we join it, well, for taste we add an order by. Next we feed this generated query into the session and it returns us an iterable, in which the objects like the index are indexed both by the column name and by number. The number corresponds to the order in which they are listed in the select. </font></font><br><br><img src="https://habrastorage.org/webt/r2/uq/f4/r2uqf4wn-wa-cvigivokusan6um.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It became much better. The speed in the worst case dropped to 2-4 seconds, the most complex and the longest query contained 14 teams and RPS 10-15. Solid. </font></font><br><br><img src="https://habrastorage.org/webt/m9/8d/mw/m98dmwpmo0trjpw3vta7dylmryw.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What I would like to say in conclusion.</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Do not procreate entities where they are not needed - do not wind up your own where there is a ready. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Use SQLA ORM is a very convenient tool that allows you to track events at a high level, respond to various events associated with the database, hide all the ears of alchemy. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If all else fails, the speed is not enough - use SQLA Core. </font><font style="vertical-align: inherit;">This is still better than using pure raw SQL, because it provides a relational abstraction over the database. </font><font style="vertical-align: inherit;">It automatically escapes the parameters, does the binding correctly, it doesn‚Äôt matter what database is under it - you can change it and Core supports different dialects. </font><font style="vertical-align: inherit;">It is very convenient. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all I wanted to tell you today.</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/flA2lEl2a0M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div><p>Source: <a href="https://habr.com/ru/post/430818/">https://habr.com/ru/post/430818/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430804/index.html">Tesla / Panasonic batteries are the most affordable batteries for electric vehicles on the market.</a></li>
<li><a href="../430806/index.html">We started to learn English - we wrote the application: EWM - the experience of creating a learning project</a></li>
<li><a href="../430808/index.html">Theory of acoustic systems: 16 materials about how the speakers and speakers are arranged</a></li>
<li><a href="../430810/index.html">Load testing with locust. Part 2</a></li>
<li><a href="../430812/index.html">What does developer.android.com say about RecyclerView</a></li>
<li><a href="../430820/index.html">Black Friday 2018 - VDS in Moscow and Amsterdam</a></li>
<li><a href="../430822/index.html">Information security of the Internet of things: who is the thing and who is the owner?</a></li>
<li><a href="../430824/index.html">Search for a damaged object by the number of the damaged page in MS SQL Server 2005</a></li>
<li><a href="../430826/index.html">How to develop a development manager</a></li>
<li><a href="../430828/index.html">Experience of using LCD displays based on MELT products</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>