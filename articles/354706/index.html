<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Twirp vs. gRPC. Is it worth it?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you are using a micro-service architecture, then you most likely know that the overhead of communication between services often becomes a significa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Twirp vs. gRPC. Is it worth it?</h1><div class="post__text post__text-html js-mediator-article">  If you are using a micro-service architecture, then you most likely know that the overhead of communication between services often becomes a significant problem and if you encountered this problem, you most likely started using one of the RPC frameworks over <a href="https://developers.google.com/protocol-buffers/docs/proto3">Protobuf</a> , for example, Google‚Äôs <a href="https://github.com/google/protobuf">gRPC</a> or <a href="https://gokit.io/">Go-Kit</a> from Peter Bourgon or something else.  Retelling what it is and how to use it makes no sense, everything is well described before me.  I myself actively use gRPC in my projects, but here <a href="https://dev.twitch.tv/products">Twich</a> decided to release my protobuf <a href="https://github.com/twitchtv/twirp">Twirp</a> implementation.  If you are wondering why they needed it or how it differs, go under the cat. <br><a name="habracut"></a><br>  First of all, let's look at the reasons for making Twich release its own version of ProtoBuf: <br><br><ul><li>  No HTTP 1.1 support.  gRPS relies on HTTP trailers and full duplex streams.  Twirp supports both HTTP 1.1 and HTTP / 2, which is very important because a large number of load-balancers (both hardware and software) only support HTTP 1.1 ‚Äî including AWS Elastic Load Balancer.  But unlike gRPC, Twirp does not support <a href="http://guides/concepts.html">streaming RPC</a> , which is not required if your API is built on the principle of Request-Response. </li><li>  The complexity of the implementation of the <a href="https://github.com/grpc/grpc-go">grpc-go</a> library.  The library includes a full implementation of HTTP / 2, independent of the standard libraries, which makes it difficult to understand and analyze errors. </li><li>  Compatibility of gRPC versions.  Due to the fact that gRPC is rather complicated, the code generated by Go is quite simple and all requests are redirected to <a href="https://github.com/grpc/grpc-go">grpc-go</a> .  Such connectivity causes the client to use the same version as the server.  And if you have a large number of customers and service interact with each other, then the version between them should be identical.  It is clear that this leads to difficulties in the deployment and deployment of microservices. </li><li>  Twitch also indicates that grpc-go requires a specific protobuf version - <a href="http://github.com/golang/protobuf">github.com/golang/protobuf</a> .  But for me, this problem seems to be far-fetched, since protobuf has only one release of version v1.0.0, which is used by all versions of grpc-go. </li><li>  gRPC only supports the binary form of messages and the sniffing of messages is very difficult to analyze.  Twirp supports both binary protobuf messages and non-binary JSON messages.  This gives you an advantage, say, if you want to interact with the service through a regular HTTP Request using JSON </li></ul><br>  As you can see, simplicity is the main reason why Twich decided to write its own implementation of Protobuf. <br><br>  Now let's see how to use this library. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you already have a Go development environment, then you need to install the following packages. <br><br><pre><code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get github.com/twitchtv/twirp/protoc-gen-twirp <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> get github.com/golang/protobuf/protoc-gen-<span class="hljs-keyword"><span class="hljs-keyword">go</span></span></code> </pre> <br>  For example, we write a simple service that increments the value passed as a parameter. <br><br><pre> <code class="hljs cs">syntax = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; service Service { <span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Increment</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Request</span></span></span><span class="hljs-function">) </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Response</span></span></span><span class="hljs-function">)</span></span>; } message Request { int32 valueToIncrement = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">// must be &gt; 0 } message Response { int32 IncrementedValue = 1; // must be &gt; 0 }</span></span></code> </pre><br>  Generate code for our client by executing the following command <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">protoc</span></span> --proto_path=<span class="hljs-variable"><span class="hljs-variable">$GOPATH</span></span>/src:. --twirp_out=. --go_out=. ./paperclips.proto</code> </pre> <br>  As a result, two files will be created. <br><br><ul><li>  Increment.pb.go - contains code generation for messages </li><li>  Increment.twirp.go - contains the interfaces and functions of the service </li></ul><br>  Next, add the implementation of our service <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> pb <span class="hljs-string"><span class="hljs-string">"TwirpSample/Server/Twirp"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Server implements the Increment service type Server struct { value int32 } // NewServer creates an instance of our server func NewServer() *Server { return &amp;Server{ value: 1, } } // Increment returns the incremented value of request.ValueToIncrement func (s *Server) Increment(ctx context.Context, request *pb.Request) (*pb.Response, error) { return &amp;pb.Response{ IncrementedValue: request.ValueToIncrement + 1, }, nil } func main() { fmt.Printf("Starting Increment Service on :6666") server := NewServer() twirpHandler := pb.NewServiceServer(server, nil) log.Fatal(http.ListenAndServe(":6666", twirpHandler)) }</span></span></code> </pre><br>  Now, if you start the client with the command <b>go run main.go,</b> the service can be accessed as via HTTP: <br><br><pre> <code class="hljs kotlin">curl --request <span class="hljs-string"><span class="hljs-string">"POST"</span></span> \ --location <span class="hljs-string"><span class="hljs-string">"http://localhost:6666/Service/Increment"</span></span> \ --header <span class="hljs-string"><span class="hljs-string">"Content-Type:application/json"</span></span> \ --<span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-string"><span class="hljs-string">'{ValueToIncrement: 0}'</span></span> \ --verbose Output: {<span class="hljs-string"><span class="hljs-string">"IncrementedValue"</span></span>:<span class="hljs-number"><span class="hljs-number">1</span></span>}</code> </pre><br>  Or in binary format <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> rpc <span class="hljs-string"><span class="hljs-string">"TwirpSample/Server/Twirp"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fmt.Println(<span class="hljs-string"><span class="hljs-string">"Twirp Client Example."</span></span>) client := rpc.NewServiceProtobufClient(<span class="hljs-string"><span class="hljs-string">"http://localhost:6666"</span></span>, &amp;http.Client{}) v, err := client.Increment(context.Background(), &amp;rpc.Request{ValueToIncrement: <span class="hljs-number"><span class="hljs-number">11</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err.Error()) } fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Value: %d"</span></span>, v.IncrementedValue) } Output: Twirp Client Example. Value: <span class="hljs-number"><span class="hljs-number">11</span></span></code> </pre><br>  In general, the framework itself is almost identical in approach with gRPC, but it is simple to implement and with simultaneous support for HTTP 1.1.  In my opinion, its applicability, if you need an RPC service, with which you plan to simultaneously interact with the UI via HTTP and between services via Protobuf. <br><br>  References: <br><br><ul><li>  <a href="https://blog.twitch.tv/twirp-a-sweet-new-rpc-framework-for-go-5f2febbf35f">Twirp: a sweet new RPC framework for Go</a> </li><li>  <a href="https://news.ycombinator.com/item%3Fid%3D16162094">Hacker News Twirp discussion</a> </li><li>  <a href="https://www.reddit.com/r/golang/comments/7qvi0w/twirp_a_sweet_new_rpc_framework_for_go_twitch_blog/">Reddit Twirp discussion</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/354706/">https://habr.com/ru/post/354706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354696/index.html">Riddles resume. Part 1. Choosing a form</a></li>
<li><a href="../354698/index.html">A brief history of information security in China: how to build the Great Chinese firewall</a></li>
<li><a href="../354700/index.html">Is there life without architecture?</a></li>
<li><a href="../354702/index.html">The solution to the problem of detecting the center line of the vessel</a></li>
<li><a href="../354704/index.html">ScadaPy Creator for python</a></li>
<li><a href="../354708/index.html">Transparent HTTPS proxy to bypass Roskomnadzor‚Äôs locks</a></li>
<li><a href="../354710/index.html">MikroTik & OpenWRT & DNSCrypt</a></li>
<li><a href="../354712/index.html">Hosting VPS: Windows or Linux?</a></li>
<li><a href="../354714/index.html">Bioyino - a distributed, scalable metric aggregator</a></li>
<li><a href="../354716/index.html">Tracing and Javascript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>