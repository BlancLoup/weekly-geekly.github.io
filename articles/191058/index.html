<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ARMs for the smallest: subtleties of compilation and linker</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing the series of articles about ARM development from scratch, today I will touch on the topic of writing linker scripts for GNU ld . This topi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ARMs for the smallest: subtleties of compilation and linker</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/438/be0/c60/438be0c60295fa01fbec0ec54947c008.jpg"><br>  Continuing the series of articles about ARM development from scratch, today I will touch on the topic of writing linker scripts for GNU <i>ld</i> .  This topic can be useful not only for those who work with embedded systems, but also for those who want to better understand the structure of executable files.  Although the examples are somehow based on the arm-none-eabi toolchain, the layout is the same for the Visual Studio linker, for example. <br><br>  Previous articles: <br><ul><li>  <a href="http://habrahabr.ru/post/189484/">ARMs for the smallest</a> </li><li>  <a href="http://habrahabr.ru/post/190032/">ARMs for the little ones: what time is it?</a> </li></ul><br><br>  Code examples from the article: <a href="https://github.com/farcaller/arm-demos">https://github.com/farcaller/arm-demos</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><br>  When we compile a source file, we get an object file at the output, which typically contains several data sections.  The four most common sections are: <br><ul><li>  <b>.text</b> - compiled machine code; </li><li>  <b>.data</b> - global and static variables; </li><li> <b>.rodata</b> - analogue <code>.data</code> for immutable data; </li><li>  <b>.bss</b> - global and static variables that, when started, contain a zero value. </li></ul><br><br>  In the binary files with which we work during this cycle, two more sections will often come across: <br><br><ul><li>  <b>.comment</b> - information about the version of the compiler; </li><li>  <b>.ARM.attributes</b> - ARM-specific file attributes. </li></ul><br><br>  In addition to sections, there is another important entity in the object file: the symbol table.  This is a kind of hash: name - address (and optional attributes).  In the symbol table, for example, all exported functions and their addresses (which will indicate somewhere in the .text section) are indicated. <br><br>  After we have gotten a few of these files, the linker takes up the business, who, according to the rules, will assemble all the sections, discard the unnecessary ones and make the final executable file.  For the "standard" OS, the rules are defined where everything should be, but in the case of microcontrollers, we usually need to be engaged in pushing everything by flash and RAM manually. <br><br><h4>  Look inside </h4><br>  As a first example, we will examine the following C code: <code>module_a.c</code> : <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">local_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_counter; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> preset_counter = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> constant = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">3</span></span> + constant; ++external_counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> local_function() * i; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">local_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ++counter; ++preset_counter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> counter + preset_counter; }</code> </pre><br><br>  Compile it and see which sections we got: <br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:sections[a]'</span></span> arm-none-eabi-gcc -mthumb -O2 -mcpu=cortex-m0 -c module_a.c -o build/module_a.o arm-none-eabi-objdump build/module_a.o -h build/module_a.o: file format elf32-littlearm Sections: Idx Name Size VMA LMA File off Algn 0 .text 00000034 00000000 00000000 00000034 2**2 CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE 1 .data 00000004 00000000 00000000 00000068 2**2 CONTENTS, ALLOC, LOAD, DATA 2 .bss 00000004 00000000 00000000 0000006c 2**2 ALLOC 3 .rodata 00000004 00000000 00000000 0000006c 2**2 CONTENTS, ALLOC, LOAD, READONLY, DATA 4 .comment 00000071 00000000 00000000 00000070 2**0 CONTENTS, READONLY 5 .ARM.attributes 00000031 00000000 00000000 000000e1 2**0 CONTENTS, READONLY</code> </pre><br><br>  As we see, there are six sections, the purpose of which is already more or less known to us.  The second line is the section attributes, they will be more interesting later when linking.  Let's see which characters are defined in these sections: <br><br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:symbols:text[a]'</span></span> arm-none-eabi-objdump build/module_a.o -j .text -t build/module_a.o: file format elf32-littlearm SYMBOL TABLE: 00000000 ld .text 00000000 .text 00000000 g F .text 00000034 public_function</code> </pre><br><br>  Open man on objdump for consultation.  In this section, we see two characters: <code>.text</code> is a debugging symbol that indicates the beginning of a section, <code>public_function</code> is a symbol that indicates our function.  There is <code>local_function</code> symbol for <code>local_function</code> , since the function is declared as <code>static</code> , i.e., it is not exported outside the object file. <br><br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:symbols:data[a]'</span></span> arm-none-eabi-objdump build/module_a.o -j .data -j .bss -t build/module_a.o: file format elf32-littlearm SYMBOL TABLE: 00000000 ld .data 00000000 .data 00000000 ld .bss 00000000 .bss 00000000 l O .data 00000004 preset_counter 00000000 l O .bss 00000004 counter</code> </pre><br><br>  In the <code>.data</code> and <code>.bss</code> sections there are two of our counters - <code>preset_counter</code> and <code>counter</code> .  They are in different sections, since <code>preset_counter</code> has an initial value, which is stored in <code>.data</code> : <br><br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:contents[a,.data]'</span></span> arm-none-eabi-objdump build/module_a.o -j .data -s build/module_a.o: file format elf32-littlearm Contents of section .data: 0000 05000000</code> </pre><br><br>  <code>counter</code> no value, so it is initialized to zero and falls into the <code>.bss</code> section.  The <code>.bss</code> section itself is not physically present in the file, since its contents are always fixed - these are zeros.  If you declared <code>char buffer[1024]</code> in the code, then the compiler would have to write a kilobyte of empty space into the object file, which makes no sense. <br><br>  At this point you may have a question - where did <code>external_counter</code> go? <br><br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:symbols:all[a]'</span></span> arm-none-eabi-objdump build/module_a.o -t build/module_a.o: file format elf32-littlearm SYMBOL TABLE: 00000000 l df *ABS* 00000000 module_a.c 00000000 ld .text 00000000 .text 00000000 ld .data 00000000 .data 00000000 ld .bss 00000000 .bss 00000000 ld .rodata 00000000 .rodata 00000000 l O .data 00000004 preset_counter 00000000 l O .bss 00000004 counter 00000000 ld .comment 00000000 .comment 00000000 ld .ARM.attributes 00000000 .ARM.attributes 00000000 g F .text 00000034 public_function 00000004 O *COM* 00000004 external_counter 00000000 g O .rodata 00000004 constant</code> </pre><br><br>  <code>external_counter</code> went to the <code>*COM*</code> section.  In this case, this means that it may be outside of this object file.  Already at the layout stage, <i>ld</i> will figure out whether a character is declared in another file, or whether it should create it itself - in this case, in the <code>.bss</code> section.  Also note that <code>const int constant</code> got into <code>.rodata</code> .  The compiler ensures that the code does not need to change the value at this address, so that the linker can easily place it in flash memory. <br><br>  We can look at <code>.comment</code> : <br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:contents[a,.comment]'</span></span> arm-none-eabi-objdump build/module_a.o -j .comment -s build/module_a.o: file format elf32-littlearm Contents of section .comment: 0000 00474343 3a202847 4e552054 6f6f6c73 .GCC: (GNU Tools 0010 20666f72 2041524d 20456d62 65646465 <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ARM Embedde 0020 64205072 6f636573 736f7273 2920342e d Processors) 4. 0030 372e3320 32303133 30333132 20287265 7.3 20130312 (re 0040 6c656173 6529205b 41524d2f 656d6265 lease) [ARM/embe 0050 64646564 2d345f37 2d627261 6e636820 dded-4_7-branch 0060 72657669 73696f6e 20313936 3631355d revision 196615] 0070 00</code> </pre><br><br>  There really is a compiler version.  We can also take a look at <code>.ARM.attributes</code> , though for this you should not use <i>objdump</i> , but <i>readelf</i> : <br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:attrs[a]'</span></span> arm-none-eabi-readelf build/module_a.o -A Attribute Section: aeabi File Attributes Tag_CPU_name: <span class="hljs-string"><span class="hljs-string">"Cortex-M0"</span></span> Tag_CPU_arch: v6S-M Tag_CPU_arch_profile: Microcontroller Tag_THUMB_ISA_use: Thumb-1 Tag_ABI_PCS_wchar_t: 4 Tag_ABI_FP_denormal: Needed Tag_ABI_FP_exceptions: Needed Tag_ABI_FP_number_model: IEEE 754 Tag_ABI_align_needed: 8-byte Tag_ABI_align_preserved: 8-byte, except leaf SP Tag_ABI_enum_size: small Tag_ABI_optimization_goals: Aggressive Speed</code> </pre><br><br>  Documentation on public tags can be viewed at the <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0045d/IHI0045D_ABI_addenda.pdf">ARM information center</a> . <br><br><h4>  Putting it all together </h4><br>  Now that we‚Äôve looked inside the object files, let's see how <i>ld</i> collects them into one successful application. <br><br>  The main work <i>ld</i> revolves around the memory card, which we saw in the first part.  If to simplify greatly, the layout is the process of tearing out sections from object files, unfolding them to the specified addresses and correcting cross-references.  In the "standard" OS, the kernel can read the output file and load sections into memory at the expected virtual addresses.  The dynamic linker also performs similar work by loading external libraries to certain memory locations and setting cross-references to them. <br><br>  With embedded systems it is easier, the firmware program takes your binary file and uploads it to the USB flash drive as is.  He does not care neither macho nor elves, he works with binary dumps. <br><br>  Take a simple linker script and sort by piece. <code>layout.ld:</code> <br><pre> <code class="hljs haskell"><span class="hljs-type"><span class="hljs-type">MEMORY</span></span> { rom(<span class="hljs-type"><span class="hljs-type">RX</span></span>) : <span class="hljs-type"><span class="hljs-type">ORIGIN</span></span> = <span class="hljs-number"><span class="hljs-number">0x00000000</span></span>, <span class="hljs-type"><span class="hljs-type">LENGTH</span></span> = <span class="hljs-number"><span class="hljs-number">0x8000</span></span> ram(<span class="hljs-type"><span class="hljs-type">WAIL</span></span>) : <span class="hljs-type"><span class="hljs-type">ORIGIN</span></span> = <span class="hljs-number"><span class="hljs-number">0x10000000</span></span>, <span class="hljs-type"><span class="hljs-type">LENGTH</span></span> = <span class="hljs-number"><span class="hljs-number">0x2000</span></span> } <span class="hljs-type"><span class="hljs-type">ENTRY</span></span>(public_function) <span class="hljs-type"><span class="hljs-type">SECTIONS</span></span> { .text : { *(.text) } &gt; rom _data_start = .; .<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> : { *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">) } &gt; ram </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AT</span></span></span><span class="hljs-class">&gt; rom _bss_start = .; .bss : { *(.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bss</span></span></span><span class="hljs-class">) } &gt; ram _bss_end = .; }</span></span></code> </pre><br><br>  The default configuration of the linker allows it to use all available memory (somewhere around 0xFFFFFFFF bytes in the case of 32-bit ARM).  To begin with, we define memory regions that can be used: <code>rom</code> and <code>ram</code> .  The letters in parentheses define the attributes: access to read, write, execute, allocate memory.  Sections that are not explicitly indicated in the script will be scattered across regions with matching attributes automatically.  If there is no space for a section, the linker will refuse to work, arguing its behavior in some way: <code>error: no memory region specified for loadable section `.data'</code> . <br><br>  The two parameters, <code>ORIGIN</code> and <code>LENGTH</code> , specify the beginning and length of the region, respectively, <code>org</code> , <code>o</code> , <code>len</code> and <code>l</code> can be found, they are equivalent.  Value is an expression, i.e., it is possible to perform arithmetic operations or use the suffixes <code>K</code> , <code>M</code> , etc.  The recording <code>LENGTH = 0x8000</code> , for example, can alternatively be done like this: <code>l = 32K</code> . <br><br>  The second part of the file is the section configuration.  In general, this means copying <s>from one protobuff into another protoboaf of</s> given source sections into output sections. <br><br>  The source sections are specified in the form <code>_(_)</code> , the symbol <code>*</code> behaves in a standard way, so the entry <code>*(.text)</code> means: the <code>.text</code> sections from all files. <br><br>  The section has two addresses: LMA (Load Memory Address) - from where it loads, and VMA (Virtual Memory Address) - at what address it is available in virtual memory.  Explaining is easier, LMA is where it will appear in the binary file, and VMA is where the characters will be redirected, i.e., the pointer to the character in the code will refer to the VMA address. <br><br>  We are interested in three sections - code, data and data, which are null by default.  Thus, we copy code ( <code>.text</code> ) into flash memory, data ( <code>.data</code> ) into flash memory, but on the basis that they will be available in RAM, and <code>.bss</code> into RAM. <br><br>  For <code>.bss</code> , in general, initialization is not required ( <b>UPD</b> : I‚Äôm prompted in the gill that is required, we must ensure that there are zeros, and not garbage, which appeared for some reason), since the microcontroller‚Äôs operational memory and so probably reset.  But with <code>.data</code> will have to tinker separately, the problem is due to the dual nature.  On the one hand, specific data is stored there (the <code>preset_counter</code> starting value), so it should be in flash memory.  On the other hand, this is a writeable section, so it should be in RAM.  This problem is solved by different LMA and VMA, as well as an additional C code, which, when launched, will copy content from LMA to VMA.  For constant data, which usually resides in the <code>.rodata</code> section, such a procedure, for example, is not needed, we can safely read from straight from the flash memory. <br><br>  The linker has the concept of a cursor - this is the current LMA.  At the beginning of the SECTIONS block, the cursor is zero and gradually increases as new sections are added.  The current value of the cursor is stored in a variable <code>.</code>  (point). <br><br>  Let's run the linker and see the result of its work: <br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:map[a]'</span></span> arm-none-eabi-ld -T layout.ld -M -o build/out.elf build/module_a.o Allocating common symbols Common symbol size file external_counter 0x4 build/module_a.o Memory Configuration Name Origin Length Attributes rom 0x0000000000000000 0x0000000000008000 xr ram 0x0000000010000000 0x0000000000002000 awl *default* 0x0000000000000000 0xffffffffffffffff</code> </pre><br>  First, we see how the linker places the "common" symbol <code>external_counter</code> into a separate category.  Next, we see that our memory configuration has been loaded and added to the default configuration (which allocates the entire address space). <br><pre> <code class="bash hljs">Linker script and memory map .text 0x0000000000000000 0x34 *(.text) .text 0x0000000000000000 0x34 build/module_a.o 0x0000000000000000 public_function 0x0000000000000034 _data_start = .</code> </pre><br>  Next, the linker places in memory the sections that we specified, primarily <code>.text</code> . <br><pre> <code class="bash hljs">.rodata 0x0000000000000034 0x4 .rodata 0x0000000000000034 0x4 build/module_a.o 0x0000000000000034 constant .glue_7 0x0000000000000038 0x0 .glue_7 0x0000000000000000 0x0 linker stubs .glue_7t 0x0000000000000038 0x0 .glue_7t 0x0000000000000000 0x0 linker stubs .vfp11_veneer 0x0000000000000038 0x0 .vfp11_veneer 0x0000000000000000 0x0 linker stubs .v4_bx 0x0000000000000038 0x0 .v4_bx 0x0000000000000000 0x0 linker stubs .iplt 0x0000000000000038 0x0 .iplt 0x0000000000000000 0x0 build/module_a.o .rel.dyn 0x0000000000000038 0x0 .rel.iplt 0x0000000000000000 0x0 build/module_a.o</code> </pre><br>  Next are sections that we did not explicitly indicate - <code>.rodata</code> , <code>.glue_7</code> , <code>.glue_7t</code> , <code>.vfp11_veneer</code> , <code>.v4_bx</code> , <code>.iplt</code> , <code>.rel.dyn</code> .  With <code>.rodata</code> everything is clear, our constant <code>constant</code> is stored in four bytes.  As for the rest of the sections, their existence is obliged to full support of efficiency, for example, the jumps from ARM to Thumb.  All of these sections are <b>empty</b> and do not fall into the final image. <br><pre> <code class="bash hljs">.data 0x0000000010000000 0x4 load address 0x0000000000000038 *(.data) .data 0x0000000010000000 0x4 build/module_a.o 0x0000000010000004 _data_end = .</code> </pre><br>  This is our <code>.data</code> section, as you see, it is located at <code>0x10000000</code> , although it is physically stored at <code>0x38</code> (that is, immediately after <code>.rodata</code> ).  Here we see the value of our variable, read from the cursor, <code>_data_end</code> . <br><pre> <code class="bash hljs">.igot.plt 0x0000000010000004 0x0 load address 0x000000000000003c .igot.plt 0x0000000000000000 0x0 build/module_a.o .bss 0x0000000010000004 0x8 load address 0x000000000000003c *(.bss) .bss 0x0000000010000004 0x4 build/module_a.o COMMON 0x0000000010000008 0x4 build/module_a.o 0x0000000010000008 external_counter 0x000000001000000c _bss_end = .</code> </pre><br>  Another empty section, followed by <code>.bss</code> . <br><pre> <code class="bash hljs">LOAD build/module_a.o OUTPUT(build/out.elf elf32-littlearm) .comment 0x0000000000000000 0x70 .comment 0x0000000000000000 0x70 build/module_a.o 0x71 (size before relaxing) .ARM.attributes 0x0000000000000000 0x31 .ARM.attributes 0x0000000000000000 0x31 build/module_a.o</code> </pre><br>  Finally, <i>ld</i> generates the output file and discards unnecessary sections.  Look like that's it? <br><br><pre> <code class="bash hljs"> 0x0000000000000034 _data_start = . ... .data 0x0000000010000000 0x4 load address 0x0000000000000038</code> </pre><br>  The variable pointing to the beginning of the <code>.data</code> actually indicates the wrong place!  But the truth is, the cursor after <code>.text</code> indicates its end.  To set a variable correctly, it must be moved inside the description of the output section: <br><br><pre> <code class="bash hljs">.data : { _data_start = .; *(.data) _data_end = .; } &gt; ram AT&gt; rom</code> </pre><br><br>  Compose and see what has changed: <br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:map[a]'</span></span> SCRIPT=layout2.ld arm-none-eabi-ld -T layout2.ld -M -o build/module_a.elf build/module_a.o ... .data 0x0000000010000000 0x4 load address 0x0000000000000038 0x0000000010000000 _data_start = . *(.data) .data 0x0000000010000000 0x4 build/module_a.o 0x0000000010000004 _data_end = . ...</code> </pre><br>  Great, now everything is in place. <br><br>  You may wonder - what is the matter for us, where is the <code>.data</code> ?  As you remember, the data is physically stored in a flash, and working with them will be from RAM.  For this reason, we will have to write a boot code that will copy the <code>.data</code> into RAM, and these variables will help us find out the specific addresses where the section should be moved. <br><br><h4>  Complicate the task </h4><br>  We dealt with one module.  Let's add the second file and see what changes.  The second file will contain the already-known <code>external_counter</code> and some C ++ code: <code>module_b.cpp</code> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> external_counter; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ external_counter += public_function(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_c</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_d</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ }</code> </pre><br><br>  As you know, when compiling C ++ code, the names of functions and methods go through "mangling", when the types of arguments, the names of classes and namespaces are encoded in the name: <br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:symbols:text[b]'</span></span> arm-none-eabi-gcc -fno-exceptions -fno-unwind-tables -fno-asynchronous-unwind-tables -mthumb -O2 -mcpu=cortex-m0 -c module_b.cpp -o build/module_b.o arm-none-eabi-objdump build/module_b.o -j .text -t build/module_b.o: file format elf32-littlearm SYMBOL TABLE: 00000000 ld .text 00000000 .text 00000000 g F .text 00000014 _Z10function_bv 00000014 g F .text 00000002 _Z10function_cv 00000018 g F .text 00000002 _Z10function_dv</code> </pre><br><br>  We compile code with the <code>-fno-exceptions -fno-unwind-tables -fno-asynchronous-unwind-tables</code> flags to avoid additional sections related to exception handling.  The names of the functions were coded accordingly. <br><br>  We cannot generate a map for this module, since it cannot be composed independently, it depends on the <code>public_function</code> function from module <code>a</code> .  We compose both modules at once: <br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:map[a|b]'</span></span> SCRIPT=layout2.ld arm-none-eabi-ld -T layout2.ld -M -o build/out.elf build/module_a.o build/module_b.o ... .text 0x0000000000000000 0x34 build/module_a.o 0x0000000000000000 public_function .text 0x0000000000000034 0x1c build/module_b.o 0x0000000000000034 function_b() 0x0000000000000048 function_c() 0x000000000000004c function_d() ...</code> </pre><br>  The block of common symbols is missing, all symbols are found in the corresponding modules.  Sections <code>.text</code> , as well as others, are arranged one after another. <br><br><h4>  Collect trash! </h4><br><br>  For embedded applications, the size of the output file is more relevant than ever, so you should take care that the maximum amount of unnecessary data and dead code is removed.  The linker is able to get rid of sections that are not referenced and which were not explicitly indicated as necessary in the layout script.  This is done quite simply - with the help of the <code>--gc-sections</code> flag: <br><br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:map[a|b]'</span></span> SCRIPT=layout2.ld GC=1 arm-none-eabi-ld --gc-sections -T layout2.ld -M -o build/out.elf build/module_a.o build/module_b.o Discarded input sections .rodata 0x0000000000000000 0x4 build/module_a.o COMMON 0x0000000000000000 0x0 build/module_a.o .text 0x0000000000000000 0x1c build/module_b.o .data 0x0000000000000000 0x0 build/module_b.o ... .text 0x0000000000000000 0x34 *(.text) .text 0x0000000000000000 0x34 build/module_a.o 0x0000000000000000 public_function ...</code> </pre><br>  As you can see, the <code>.text</code> section of <code>build/module_b.o</code> was removed completely, as it contained useless functions!  At the same time, the linker threw out unused constants from the first module. <br><br>  In fact, this optimization is not complete, as we can easily see with a simple experiment, see <code>module_c.cpp</code> <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">function_b</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">public_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ function_b(); }</code> </pre><br><br>  We will replace module <code>a</code> with module <code>c</code> and see if the linker can delete the section. <br><br><pre> <code class="bash hljs">% rake <span class="hljs-string"><span class="hljs-string">'show:map[b|c]'</span></span> SCRIPT=layout2.ld GC=1 arm-none-eabi-gcc -fno-exceptions -fno-unwind-tables -fno-asynchronous-unwind-tables -mthumb -O2 -mcpu=cortex-m0 -c module_c.cpp -o build/module_c.o arm-none-eabi-ld --gc-sections -T layout2.ld -M -o build/out.elf build/module_b.o build/module_c.o Discarded input sections .data 0x0000000000000000 0x0 build/module_b.o .data 0x0000000000000000 0x0 build/module_c.o .bss 0x0000000000000000 0x0 build/module_c.o ... .text 0x0000000000000000 0x24 *(.text) .text 0x0000000000000000 0x1c build/module_b.o 0x0000000000000000 function_b() 0x0000000000000014 function_c() 0x0000000000000018 function_d() .text 0x000000000000001c 0x8 build/module_c.o 0x000000000000001c public_function</code> </pre><br><br>  Although part of the sections (by the way, empty ones) were thrown away, we still lose invaluable bytes on the <code>function_c()</code> and <code>function_d()</code> , which ended up in the same section as the <code>function_b()</code> that we need.  Compiler flags will come to the rescue, which break functions and data into different sections: <code>-ffunction-sections</code> and <code>-fdata-sections</code> : <br><pre> <code class="cpp hljs">% rake clean &amp;&amp; rake <span class="hljs-string"><span class="hljs-string">'show:symbols:all[b]'</span></span> SPLIT_SECTIONS=<span class="hljs-number"><span class="hljs-number">1</span></span> arm-none-eabi-gcc -fno-exceptions -fno-unwind-tables -fno-asynchronous-unwind-tables -ffunction-sections -fdata-sections -mthumb -O2 -mcpu=cortex-m0 -c module_b.cpp -o build/module_b.o arm-none-eabi-objdump build/module_b.o -t build/module_b.o: file format elf32-littlearm SYMBOL TABLE: <span class="hljs-number"><span class="hljs-number">00000000</span></span> l df *ABS* <span class="hljs-number"><span class="hljs-number">00000000</span></span> module_b.cpp <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .text <span class="hljs-number"><span class="hljs-number">00000000</span></span> .text <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .data <span class="hljs-number"><span class="hljs-number">00000000</span></span> .data <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .bss <span class="hljs-number"><span class="hljs-number">00000000</span></span> .bss <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .text._Z10function_bv <span class="hljs-number"><span class="hljs-number">00000000</span></span> .text._Z10function_bv <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .text._Z10function_cv <span class="hljs-number"><span class="hljs-number">00000000</span></span> .text._Z10function_cv <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .text._Z10function_dv <span class="hljs-number"><span class="hljs-number">00000000</span></span> .text._Z10function_dv <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .bss.external_counter <span class="hljs-number"><span class="hljs-number">00000000</span></span> .bss.external_counter <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .comment <span class="hljs-number"><span class="hljs-number">00000000</span></span> .comment <span class="hljs-number"><span class="hljs-number">00000000</span></span> ld .ARM.attributes <span class="hljs-number"><span class="hljs-number">00000000</span></span> .ARM.attributes <span class="hljs-number"><span class="hljs-number">00000000</span></span> g F .text._Z10function_bv <span class="hljs-number"><span class="hljs-number">00000014</span></span> _Z10function_bv <span class="hljs-number"><span class="hljs-number">00000000</span></span> *UND* <span class="hljs-number"><span class="hljs-number">00000000</span></span> public_function <span class="hljs-number"><span class="hljs-number">00000000</span></span> g F .text._Z10function_cv <span class="hljs-number"><span class="hljs-number">00000002</span></span> _Z10function_cv <span class="hljs-number"><span class="hljs-number">00000000</span></span> g F .text._Z10function_dv <span class="hljs-number"><span class="hljs-number">00000002</span></span> _Z10function_dv <span class="hljs-number"><span class="hljs-number">00000000</span></span> g O .bss.external_counter <span class="hljs-number"><span class="hljs-number">00000004</span></span> external_counter</code> </pre><br>  Now that each function and object is placed in independent sections, the linker can get rid of them: <br><pre> <code class="cpp hljs">% rake clean &amp;&amp; rake <span class="hljs-string"><span class="hljs-string">'show:map[b|c]'</span></span> SCRIPT=layout2.ld GC=<span class="hljs-number"><span class="hljs-number">1</span></span> SPLIT_SECTIONS=<span class="hljs-number"><span class="hljs-number">1</span></span> arm-none-eabi-gcc -fno-exceptions -fno-unwind-tables -fno-asynchronous-unwind-tables -ffunction-sections -fdata-sections -mthumb -O2 -mcpu=cortex-m0 -c module_b.cpp -o build/module_b.o arm-none-eabi-gcc -fno-exceptions -fno-unwind-tables -fno-asynchronous-unwind-tables -ffunction-sections -fdata-sections -mthumb -O2 -mcpu=cortex-m0 -c module_c.cpp -o build/module_c.o arm-none-eabi-ld --gc-sections -T layout2.ld -M -o build/out.elf build/module_b.o build/module_c.o Discarded input sections .text <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> build/module_b.o .data <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> build/module_b.o .bss <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> build/module_b.o .text._Z10function_cv <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x4</span></span> build/module_b.o .text._Z10function_dv <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x4</span></span> build/module_b.o .text <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> build/module_c.o .data <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> build/module_c.o .bss <span class="hljs-number"><span class="hljs-number">0x0000000000000000</span></span> <span class="hljs-number"><span class="hljs-number">0x0</span></span> build/module_c.o ...</code> </pre><br><br><h4>  Instead of conclusion </h4><br>  And again the volume of the article is growing, now it is twice the size of the first part.  Unfortunately, the layout is a complex topic, and it is difficult to master the ‚Äúinlet‚Äù.  In a week, we will continue to explore the linker and make a full-fledged layout script for our embedded applications. <br><br>  PS As always, many thanks <a href="https://habrahabr.ru/users/pfactum/" class="user_link">pfactum</a> for reading the text. <br><br><h6> <a rel="license" href=""><img alt="Creative Commons License" src="https://habrastorage.org/getpro/habr/post_images/a58/dd6/778/a58dd6778494eefb36a9b5ccee5d6187.png"></a>  This work is available under <a rel="license" href="">the Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported license</a> .  The program text of the examples is available under <a rel="license" href="http://unlicense.org/">the Unlicense license</a> (unless otherwise indicated in the file headers).  This work is written solely for educational purposes and is not affiliated in any way with the current or previous employers of the author. </h6></div><p>Source: <a href="https://habr.com/ru/post/191058/">https://habr.com/ru/post/191058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../19104/index.html">Jevix 0.9.5</a></li>
<li><a href="../191044/index.html">Rootkit Avatar and HiddenFsReader</a></li>
<li><a href="../191048/index.html">IBM Unveils New Wind and Solar Prediction System</a></li>
<li><a href="../191052/index.html">Nginx has a paid version - Nginx Plus</a></li>
<li><a href="../191054/index.html">STM32 vs Arduino</a></li>
<li><a href="../19106/index.html">Lotus Symphony now in Russian</a></li>
<li><a href="../191060/index.html">Minimalistic RSS reader for the Yandex.Following service</a></li>
<li><a href="../191066/index.html">Cowon AE1: another unusual recorder from the manufacturer of players</a></li>
<li><a href="../19107/index.html">Legal and physical person: a bit of responsibility</a></li>
<li><a href="../191072/index.html">Jolla: pre-order over, design updated</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>