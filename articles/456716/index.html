<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Not very big data</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article will look at the features provided by inline or declarative partitioning in PostgreSQL version 12. The demonstration is prepared for the ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Not very big data</h1><div class="post__text post__text-html js-mediator-article">  This article will look at the features provided by inline or declarative partitioning in PostgreSQL version 12.  The demonstration is prepared for the <a href="https://www.highload.ru/siberia/2019/abstracts/5361">report of the</a> same name at the HighLoad ++ Siberia 2019 conference. <br><br>  All examples are performed on the recently appeared beta version: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> version();</code> </pre> <pre> <code class="plaintext hljs"> version ------------------------------------------------------------------------------------------------------------------ PostgreSQL 12beta1 on i686-pc-linux-gnu, compiled by gcc (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609, 32-bit (1 row)</code> </pre> <a name="habracut"></a><br>  The examples use the tables bookings and tickets for the demo database.  The booking table contains records for three months from June to August 2017 and has the following structure: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="pgsql hljs">=&gt; \d bookings</code> </pre> <pre> <code class="plaintext hljs">Table "bookings.bookings" Column | Type | Collation | Nullable | Default --------------+--------------------------+-----------+----------+--------- book_ref | character(6) | | not null | book_date | timestamp with time zone | | not null | total_amount | numeric(10,2) | | not null | Indexes: "bookings_pkey" PRIMARY KEY, btree (book_ref) Referenced by: TABLE "tickets" CONSTRAINT "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref)</code> </pre><br>  Reservations may include multiple tickets.  The structure of the table with tickets: <br><br><pre> <code class="pgsql hljs">=&gt; \d tickets</code> </pre> <pre> <code class="plaintext hljs"> Table "bookings.tickets" Column | Type | Collation | Nullable | Default ----------------+-----------------------+-----------+----------+--------- ticket_no | character(13) | | not null | book_ref | character(6) | | not null | passenger_id | character varying(20) | | not null | passenger_name | text | | not null | contact_data | jsonb | | | Indexes: "tickets_pkey" PRIMARY KEY, btree (ticket_no) Foreign-key constraints: "tickets_book_ref_fkey" FOREIGN KEY (book_ref) REFERENCES bookings(book_ref) Referenced by: TABLE "ticket_flights" CONSTRAINT "ticket_flights_ticket_no_fkey" FOREIGN KEY (ticket_no) REFERENCES tickets(ticket_no)</code> </pre><br>  This information should be sufficient to understand the examples in which we will try to make the tables partitioned. <br><br>  ‚Üí You can learn more about the demo database <a href="https://postgrespro.ru/education/demodb">here.</a> <br><br><h2>  Range Partitioning </h2><br>  At the beginning, we will try to make the bookings table partitioned by date range.  In this case, the table would be created like this: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range ( book_ref <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>), book_date <span class="hljs-type"><span class="hljs-type">timestamptz</span></span>, total_amount <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY RANGE</span></span>(book_date);</code> </pre><br>  Separate sections for each month: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_201706 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-06-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-07-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_201707 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-07-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-08-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>);</code> </pre><br>  To specify the boundaries of the section, you can use not only constants, but also expressions, such as a function call.  The value of the expression is calculated at the moment of creating the section and stored in the system catalog: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_201708 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.08.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.09.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>));</code> </pre><br>  Table Description: <br><br><pre> <code class="pgsql hljs">=&gt; \d+ bookings_range</code> </pre> <pre> <code class="plaintext hljs">Partitioned table "bookings.bookings_range" Column | Type | Collation | Nullable | Default | Storage | Stats target | Description --------------+--------------------------+-----------+----------+---------+----------+--------------+------------- book_ref | character(6) | | | | extended | | book_date | timestamp with time zone | | | | plain | | total_amount | numeric(10,2) | | | | main | | Partition key: RANGE (book_date) Partitions: bookings_range_201706 FOR VALUES FROM ('2017-06-01 00:00:00+03') TO ('2017-07-01 00:00:00+03'), bookings_range_201707 FOR VALUES FROM ('2017-07-01 00:00:00+03') TO ('2017-08-01 00:00:00+03'), bookings_range_201708 FOR VALUES FROM ('2017-08-01 00:00:00+03') TO ('2017-09-01 00:00:00+03')</code> </pre> <br>  That's enough.  No trigger is required to insert records, no CHECK restrictions are needed.  The CONSTRAINT_EXCLUSION parameter is also not needed, it can even be disabled: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> constraint_exclusion = <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>;</code> </pre><br>  Filling with automatic layout in sections: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings;</code> </pre> <pre> <code class="plaintext hljs">INSERT 0 262788</code> </pre> <br>  The declarative syntax still hides inherited tables, so the distribution of rows by sections can be viewed by the query: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tableoid;</code> </pre> <pre> <code class="plaintext hljs"> tableoid | count -----------------------+-------- bookings_range_201706 | 7303 bookings_range_201707 | 167062 bookings_range_201708 | 88423 (3 rows)</code> </pre> <br>  And in the parent table there is no data: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> bookings_range;</code> </pre><pre> <code class="plaintext hljs"> book_ref | book_date | total_amount ----------+-----------+-------------- (0 rows)</code> </pre> <br>  Let's check section exclusion in terms of query: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = <span class="hljs-string"><span class="hljs-string">'2017-07-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------- Seq Scan on bookings_range_201707 Filter: (book_date = '2017-07-01 00:00:00+03'::timestamp with time zone) (2 rows)</code> </pre> <br>  Scan only one section, as expected. <br><br>  The following example uses the to_timestamp function with the category of variability STABLE instead of a constant: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.07.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Append Subplans Removed: 2 -&gt; Seq Scan on bookings_range_201707 Filter: (book_date = to_timestamp('01.07.2017'::text, 'DD.MM.YYYY'::text)) (4 rows)</code> </pre> <br>  The value of the function is calculated during the initialization of the query plan and part of the sections is excluded from viewing (the Subplans Removed line). <br><br>  But this only works for SELECT.  When changing data, the exclusion of sections based on the values ‚Äã‚Äãof the STABLE functions is not yet implemented: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.07.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------ Delete on bookings_range Delete on bookings_range_201706 Delete on bookings_range_201707 Delete on bookings_range_201708 -&gt; Seq Scan on bookings_range_201706 Filter: (book_date = to_timestamp('01.07.2017'::text, 'DD.MM.YYYY'::text)) -&gt; Seq Scan on bookings_range_201707 Filter: (book_date = to_timestamp('01.07.2017'::text, 'DD.MM.YYYY'::text)) -&gt; Seq Scan on bookings_range_201708 Filter: (book_date = to_timestamp('01.07.2017'::text, 'DD.MM.YYYY'::text)) (10 rows)</code> </pre> <br>  Therefore, you should use constants: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = <span class="hljs-string"><span class="hljs-string">'2017-07-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------------- Delete on bookings_range Delete on bookings_range_201707 -&gt; Seq Scan on bookings_range_201707 Filter: (book_date = '2017-07-01 00:00:00+03'::timestamp with time zone) (4 rows)</code> </pre> <br><h2>  Sort by index </h2><br>  To perform the following query, it is necessary to sort the results obtained from different sections.  Therefore, in the query plan, we see the SORT node and the high initial cost of the plan: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_date;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------ Sort (cost=24649.77..25077.15 rows=170952 width=52) Sort Key: bookings_range_201706.book_date -&gt; Append (cost=0.00..4240.28 rows=170952 width=52) -&gt; Seq Scan on bookings_range_201706 (cost=0.00..94.94 rows=4794 width=52) -&gt; Seq Scan on bookings_range_201707 (cost=0.00..2151.30 rows=108630 width=52) -&gt; Seq Scan on bookings_range_201708 (cost=0.00..1139.28 rows=57528 width=52) (6 rows)</code> </pre> <br>  Create an index by book_date.  Instead of one global index, indexes are created in each section: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bookings_range(book_date);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \di bookings_range*</code> </pre> <pre> <code class="plaintext hljs"> List of relations Schema | Name | Type | Owner | Table ----------+-------------------------------------+-------+---------+----------------------- bookings | bookings_range_201706_book_date_idx | index | student | bookings_range_201706 bookings | bookings_range_201707_book_date_idx | index | student | bookings_range_201707 bookings | bookings_range_201708_book_date_idx | index | student | bookings_range_201708 (3 rows)</code> </pre> <br>  The previous query with sorting can now use the index by partitioning key and return the result from different sections at once in sorted form.  The SORT node is not needed and the minimum cost is required to issue the first result line: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_date;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------------------------------------------------------------- Append (cost=1.12..14880.88 rows=262788 width=52) -&gt; Index Scan using bookings_range_201706_book_date_idx on bookings_range_201706 (cost=0.28..385.83 rows=7303 width=52) -&gt; Index Scan using bookings_range_201707_book_date_idx on bookings_range_201707 (cost=0.42..8614.35 rows=167062 width=52) -&gt; Index Scan using bookings_range_201708_book_date_idx on bookings_range_201708 (cost=0.42..4566.76 rows=88423 width=52) (4 rows)</code> </pre> <br>  The indexes thus created on the sections are maintained centrally.  When you add a new section on it will automatically create an index.  And you cannot delete an index of only one section: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> bookings_range_201706_book_date_idx;</code> </pre><pre> <code class="plaintext hljs">ERROR: cannot drop index bookings_range_201706_book_date_idx because index book_date_idx requires it HINT: You can drop index book_date_idx instead.</code> </pre> <br>  Only whole: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx;</code> </pre><pre> <code class="plaintext hljs">DROP INDEX</code> </pre> <br><h2>  CREATE INDEX ... CONCURRENTLY </h2><br>  When creating an index on a partitioned table, you cannot specify CONCURRENTLY. <br><br>  But you can do the following.  At first we create an index only on the main table, it will receive the invalid status: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ONLY</span></span> bookings_range(book_date);</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indisvalid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">'book_date_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> indisvalid ------------ f (1 row)</code> </pre><br>  Then we create indexes on all sections with the CONCURRENTLY option: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONCURRENTLY</span></span> book_date_201706_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bookings_range_201706 (book_date); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONCURRENTLY</span></span> book_date_201707_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bookings_range_201707 (book_date); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONCURRENTLY</span></span> book_date_201708_idx <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bookings_range_201708 (book_date);</code> </pre><br>  Now we connect local indexes to global: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ATTACH PARTITION</span></span> book_date_201706_idx; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ATTACH PARTITION</span></span> book_date_201707_idx; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> book_date_idx <span class="hljs-keyword"><span class="hljs-keyword">ATTACH PARTITION</span></span> book_date_201708_idx;</code> </pre><br>  This is similar to connecting table-sections, which we will look at later.  As soon as all index sections are connected, the main index will change its status: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indisvalid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> = <span class="hljs-string"><span class="hljs-string">'book_date_idx'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> indisvalid ------------ t (1 row)</code> </pre> <br><h2>  Connecting and disconnecting sections </h2><br>  Automatic creation of sections is not provided.  Therefore, they need to be created in advance, before records with new values ‚Äã‚Äãof the partitioning key begin to be added to the table. <br><br>  We will create a new section while other transactions are working with the table, at the same time we will look at the locks: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_date = to_timestamp(<span class="hljs-string"><span class="hljs-string">'01.07.2017'</span></span>,<span class="hljs-string"><span class="hljs-string">'DD.MM.YYYY'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> count ------- 5 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>, mode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid() <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'bookings%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relation | mode -----------------------+----------------- bookings_range_201708 | AccessShareLock bookings_range_201707 | AccessShareLock bookings_range_201706 | AccessShareLock bookings_range | AccessShareLock (4 rows)</code> </pre> <br>  The AccessShareLock lock is imposed on the main table, all sections and indexes at the beginning of the statement.  The calculation of the to_timestamp function and the elimination of sections occurs later.  If a constant were used instead of a function, only the main table and the section bookings_range_201707 would be locked.  Therefore, if it is possible to specify constants in the request, this should be done, otherwise the number of lines in pg_locks will increase in proportion to the number of sections, which may result in the need to increase max_locks_per_transaction. <br><br>  Without completing the previous transaction, create the following section for September in a new session: <br><br><pre> <code class="pgsql hljs"> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_201709 (<span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> bookings_range); || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ATTACH PARTITION</span></span> bookings_range_201709 <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-09-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> (<span class="hljs-string"><span class="hljs-string">'2017-10-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>); || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>, mode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = pg_backend_pid() <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'bookings%'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relation | mode -------------------------------------+-------------------------- bookings_range_201709_book_date_idx | AccessExclusiveLock bookings_range | ShareUpdateExclusiveLock bookings_range_201709 | ShareLock bookings_range_201709 | AccessExclusiveLock (4 rows)</code> </pre><br>  When creating a new section, a ShareUpdateExclusiveLock lock compatible with AccessShareLock is imposed on the main table.  Therefore, the operations of adding sections do not conflict with requests to a partitioned table. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br><pre> <code class="pgsql hljs"> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre> <br>  The sections are disabled by the ALTER TABLE ... DETACH PARTITION command.  The section itself is not deleted, but becomes an independent table.  From it, you can unload data, you can delete it, and if necessary, reconnect (ATTACH PARTITION). <br><br>  Another shutdown option is to delete a section with the DROP TABLE command. <br><br>  Unfortunately, both DROP TABLE and DETACH PARTITION use AccessExclusiveLock lock on the main table. <br><br><h2>  Default section </h2><br>  If you try to add an entry for which a section has not yet been created, an error will occur.  If this behavior is undesirable, you can create a default section: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range_default <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">DEFAULT</span></span>;</code> </pre> <br>  Suppose that adding a record confused the date without specifying the millennium: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span>(<span class="hljs-string"><span class="hljs-string">'XX0000'</span></span>, <span class="hljs-string"><span class="hljs-string">'0017-09-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, *;</code> </pre><pre> <code class="plaintext hljs"> tableoid | book_ref | book_date | total_amount ------------------------+----------+------------------------------+-------------- bookings_range_default | XX0000 | 0017-09-01 00:00:00+02:30:17 | 0.00 (1 row) INSERT 0 1</code> </pre> <br>  Note that the phrase RETURNING returns a new line that falls into the default section. <br><br>  After setting the current date (changing the partitioning key), the record is automatically moved to the desired section, no triggers are needed: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> book_date = <span class="hljs-string"><span class="hljs-string">'2017-09-01'</span></span>::<span class="hljs-type"><span class="hljs-type">timestamptz</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'XX0000'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, *;</code> </pre><pre> <code class="plaintext hljs"> tableoid | book_ref | book_date | total_amount -----------------------+----------+------------------------+-------------- bookings_range_201709 | XX0000 | 2017-09-01 00:00:00+03 | 0.00 (1 row) UPDATE 1</code> </pre> <br><h2>  Listing of values </h2><br>  In the demo database, the primary key of the bookings table should be the column book_ref.  However, the selected partitioning scheme does not allow creating such a key: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>(book_ref);</code> </pre><pre> <code class="plaintext hljs">ERROR: insufficient columns in PRIMARY KEY constraint definition DETAIL: PRIMARY KEY constraint on table "bookings_range" lacks column "book_date" which is part of the partition key.</code> </pre> <br>  The partition key must be included in the primary key. <br><br>  To break down by months and still include book_ref in the primary key, let's try a different partitioning scheme for the bookings table - according to the list of values.  To do this, add the redundant column book_month as the partitioning key: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_list ( book_ref <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>), book_month <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>), book_date <span class="hljs-type"><span class="hljs-type">timestamptz</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, total_amount <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> (book_ref, book_month) ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY LIST</span></span>(book_month);</code> </pre> <br>  We will form sections dynamically based on data from the bookings table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dates <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,min(book_date)) min_date, date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,max(book_date)) max_date <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings ), <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> to_char(g.month, <span class="hljs-string"><span class="hljs-string">'YYYYMM'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> book_month <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dates, generate_series(dates.min_date, dates.max_date, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(month) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> format(<span class="hljs-string"><span class="hljs-string">'CREATE TABLE %I PARTITION OF bookings_list FOR VALUES IN (%L)'</span></span>, <span class="hljs-string"><span class="hljs-string">'bookings_list_'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>.book_month, <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>.book_month) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>\gexec</code> </pre><pre> <code class="plaintext hljs">CREATE TABLE CREATE TABLE CREATE TABLE</code> </pre> <br>  Here's what happened: <br><br><pre> <code class="pgsql hljs">=&gt; \d+ bookings_list</code> </pre><pre> <code class="plaintext hljs"> Partitioned table "bookings.bookings_list" Column | Type | Collation | Nullable | Default | Storage | Stats target | Description --------------+--------------------------+-----------+----------+---------+----------+--------------+------------- book_ref | character(6) | | not null | | extended | | book_month | character(6) | | not null | | extended | | book_date | timestamp with time zone | | not null | | plain | | total_amount | numeric(10,2) | | | | main | | Partition key: LIST (book_month) Indexes: "bookings_list_pkey" PRIMARY KEY, btree (book_ref, book_month) Partitions: bookings_list_201706 FOR VALUES IN ('201706'), bookings_list_201707 FOR VALUES IN ('201707'), bookings_list_201708 FOR VALUES IN ('201708')</code> </pre> <br>  Filling with the layout of the sections: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_list(book_ref,book_month,book_date,total_amount) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> book_ref,to_char(book_date, <span class="hljs-string"><span class="hljs-string">'YYYYMM'</span></span>),book_date,total_amount <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 262788</code> </pre><br>  As a retreat.  For automatic filling of book_month, it is tempting to use the new functionality of version 12 - GENERATED ALWAYS columns.  But, unfortunately, they cannot be used as a partitioning key.  Therefore, the task of filling the month should be solved in other ways. <br><br>  Integrity constraints such as CHECK and NOT NULL can be created on a partitioned table.  As with inheritance, specifying INHERIT / NOINHERIT tells you whether the constraint should be inherited in all partition tables.  Default INHERIT: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_range <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> book_date <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d bookings_range</code> </pre><pre> <code class="plaintext hljs"> Partitioned table "bookings.bookings_range" Column | Type | Collation | Nullable | Default --------------+--------------------------+-----------+----------+--------- book_ref | character(6) | | | book_date | timestamp with time zone | | not null | total_amount | numeric(10,2) | | | Partition key: RANGE (book_date) Indexes: "book_date_idx" btree (book_date) Number of partitions: 5 (Use \d+ to list them.)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d bookings_range_201706</code> </pre><pre> <code class="plaintext hljs"> Table "bookings.bookings_range_201706" Column | Type | Collation | Nullable | Default --------------+--------------------------+-----------+----------+--------- book_ref | character(6) | | | book_date | timestamp with time zone | | not null | total_amount | numeric(10,2) | | | Partition of: bookings_range FOR VALUES FROM ('2017-06-01 00:00:00+03') TO ('2017-07-01 00:00:00+03') Indexes: "book_date_201706_idx" btree (book_date)</code> </pre> <br>  The EXCLUDE constraint can only be created locally on sections. <br><br>  Searching for book_ref will look in all sections, but by index, thanks to the fact that book_ref is listed first: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'00000F'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN -------------------------------------------------------------------------- Append -&gt; Index Scan using bookings_list_201706_pkey on bookings_list_201706 Index Cond: (book_ref = '00000F'::bpchar) -&gt; Index Scan using bookings_list_201707_pkey on bookings_list_201707 Index Cond: (book_ref = '00000F'::bpchar) -&gt; Index Scan using bookings_list_201708_pkey on bookings_list_201708 Index Cond: (book_ref = '00000F'::bpchar) (7 rows)</code> </pre> <br>  Search by book_ref and section range should look only within the specified range: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> book_ref = <span class="hljs-string"><span class="hljs-string">'00000F'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> book_month = <span class="hljs-string"><span class="hljs-string">'201707'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------- Index Scan using bookings_list_201707_pkey on bookings_list_201707 Index Cond: ((book_ref = '00000F'::bpchar) AND (book_month = '201707'::bpchar)) (2 rows)</code> </pre> <br>  The INSERT ... ON CONFLICT command correctly finds the required section and performs the update: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_list <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XX0001'</span></span>,<span class="hljs-string"><span class="hljs-string">'201708'</span></span>,<span class="hljs-string"><span class="hljs-string">'2017-08-01'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, *;</code> </pre><pre> <code class="plaintext hljs"> tableoid | book_ref | book_month | book_date | total_amount ----------------------+----------+------------+------------------------+-------------- bookings_list_201708 | XX0001 | 201708 | 2017-08-01 00:00:00+03 | 0.00 (1 row) INSERT 0 1</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_list <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XX0001'</span></span>,<span class="hljs-string"><span class="hljs-string">'201708'</span></span>,<span class="hljs-string"><span class="hljs-string">'2017-08-01'</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONFLICT</span></span>(book_ref,book_month) <span class="hljs-keyword"><span class="hljs-keyword">DO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> total_amount = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, *;</code> </pre><pre> <code class="plaintext hljs"> tableoid | book_ref | book_month | book_date | total_amount ----------------------+----------+------------+------------------------+-------------- bookings_list_201708 | XX0001 | 201708 | 2017-08-01 00:00:00+03 | 100.00 (1 row) INSERT 0 1</code> </pre> <br><h2>  Foreign keys </h2><br>  In the demo database, the tickets table refers to bookings. <br><br>  To make a foreign key possible, we add a column book_month, and at the same time we divide into sections by months, like bookings_list. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> tickets_list ( ticket_no <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">13</span></span>), book_month <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>), book_ref <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, passenger_id <span class="hljs-type"><span class="hljs-type">varchar</span></span>(<span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, passenger_name <span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, contact_data <span class="hljs-type"><span class="hljs-type">jsonb</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span> (ticket_no, book_month), <span class="hljs-keyword"><span class="hljs-keyword">FOREIGN KEY</span></span> (book_ref, book_month) <span class="hljs-keyword"><span class="hljs-keyword">REFERENCES</span></span> bookings_list (book_ref, book_month) ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY LIST</span></span> (book_month);</code> </pre><br>  The FOREIGN KEY constraint is worth a closer look.  On the one hand, this is the foreign key <i>from the</i> partitioned table (tickets_list), and on the other hand it is the key <i>to the</i> partitioned table (bookings_list).  Thus, foreign keys for partitioned tables are supported in both directions. <br><br>  Create sections: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> dates <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,min(book_date)) min_date, date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>,max(book_date)) max_date <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings ), <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> to_char(g.month, <span class="hljs-string"><span class="hljs-string">'YYYYMM'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> book_month <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dates, generate_series(dates.min_date, dates.max_date, <span class="hljs-string"><span class="hljs-string">'1 month'</span></span>::<span class="hljs-type"><span class="hljs-type">interval</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> g(month) ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> format(<span class="hljs-string"><span class="hljs-string">'CREATE TABLE %I PARTITION OF tickets_list FOR VALUES IN (%L)'</span></span>, <span class="hljs-string"><span class="hljs-string">'tickets_list_'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>.book_month, <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>.book_month) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>\gexec</code> </pre><pre> <code class="plaintext hljs">CREATE TABLE CREATE TABLE CREATE TABLE</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ tickets_list</code> </pre><pre> <code class="plaintext hljs"> Partitioned table "bookings.tickets_list" Column | Type | Collation | Nullable | Default | Storage | Stats target | Description ----------------+-----------------------+-----------+----------+---------+----------+--------------+------------- ticket_no | character(13) | | not null | | extended | | book_month | character(6) | | not null | | extended | | book_ref | character(6) | | not null | | extended | | passenger_id | character varying(20) | | not null | | extended | | passenger_name | text | | not null | | extended | | contact_data | jsonb | | | | extended | | Partition key: LIST (book_month) Indexes: "tickets_list_pkey" PRIMARY KEY, btree (ticket_no, book_month) Foreign-key constraints: "tickets_list_book_ref_book_month_fkey" FOREIGN KEY (book_ref, book_month) REFERENCES bookings_list(book_ref, book_month) Partitions: tickets_list_201706 FOR VALUES IN ('201706'), tickets_list_201707 FOR VALUES IN ('201707'), tickets_list_201708 FOR VALUES IN ('201708')</code> </pre> <br>  Fill in: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> tickets_list (ticket_no,book_month,book_ref,passenger_id,passenger_name,contact_data) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> t.ticket_no,b.book_month,t.book_ref, t.passenger_id,t.passenger_name,t.contact_data <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> tickets t <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (b.book_ref = t.book_ref);</code> </pre><pre> <code class="plaintext hljs">INSERT 0 366733</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> tickets_list;</code> </pre><br>  The distribution of lines in sections: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span>, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> tickets_list <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tableoid;</code> </pre><pre> <code class="plaintext hljs"> tableoid | count ---------------------+-------- tickets_list_201706 | 10160 tickets_list_201707 | 232755 tickets_list_201708 | 123818 (3 rows)</code> </pre> <br><h2>  Join and Aggregation Requests </h2><br>  Join two tables partitioned in the same way: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> tickets_list t <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (b.book_ref = t.book_ref <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.book_month = t.book_month);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ---------------------------------------------------------------------------- Hash Join Hash Cond: ((t.book_ref = b.book_ref) AND (t.book_month = b.book_month)) -&gt; Append -&gt; Seq Scan on tickets_list_201706 t -&gt; Seq Scan on tickets_list_201707 t_1 -&gt; Seq Scan on tickets_list_201708 t_2 -&gt; Hash -&gt; Append -&gt; Seq Scan on bookings_list_201706 b -&gt; Seq Scan on bookings_list_201707 b_1 -&gt; Seq Scan on bookings_list_201708 b_2 (11 rows)</code> </pre> <br>  Before starting a join in each table, sections are first combined that fall into the query condition. <br><br>  But it would be possible to first join the sections of both tables corresponding to the months, and then combine the result.  This can be achieved by enabling the enable_partitionwise_join parameter: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_partitionwise_join = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> b.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list b <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> tickets_list t <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (b.book_ref = t.book_ref <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> b.book_month = t.book_month);</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------ Append -&gt; Hash Join Hash Cond: ((t.book_ref = b.book_ref) AND (t.book_month = b.book_month)) -&gt; Seq Scan on tickets_list_201706 t -&gt; Hash -&gt; Seq Scan on bookings_list_201706 b -&gt; Hash Join Hash Cond: ((t_1.book_ref = b_1.book_ref) AND (t_1.book_month = b_1.book_month)) -&gt; Seq Scan on tickets_list_201707 t_1 -&gt; Hash -&gt; Seq Scan on bookings_list_201707 b_1 -&gt; Hash Join Hash Cond: ((t_2.book_ref = b_2.book_ref) AND (t_2.book_month = b_2.book_month)) -&gt; Seq Scan on tickets_list_201708 t_2 -&gt; Hash -&gt; Seq Scan on bookings_list_201708 b_2 (16 rows)</code> </pre> <br>  Now, the corresponding sections of the two tables are joined first, and then the results of the joins are combined. <br><br>  Similar situation with aggregation: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------- Finalize Aggregate -&gt; Gather Workers Planned: 2 -&gt; Partial Aggregate -&gt; Parallel Append -&gt; Parallel Seq Scan on bookings_list_201707 -&gt; Parallel Seq Scan on bookings_list_201708 -&gt; Parallel Seq Scan on bookings_list_201706 (8 rows)</code> </pre> <br>  Note that scanning sections can be performed in parallel.  But at first sections are united, only then aggregation begins.  Alternatively, you can aggregate in each section, then combine the result: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_partitionwise_aggregate = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_list;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------- Finalize Aggregate -&gt; Gather Workers Planned: 2 -&gt; Parallel Append -&gt; Partial Aggregate -&gt; Parallel Seq Scan on bookings_list_201707 -&gt; Partial Aggregate -&gt; Parallel Seq Scan on bookings_list_201708 -&gt; Partial Aggregate -&gt; Parallel Seq Scan on bookings_list_201706 (10 rows)</code> </pre> <br>  These features are especially important if part of the sections are external tables.  By default, both are disabled, because  The corresponding parameters affect the time of building the plan, but can not always be used. <br><br><h2>  Hash partitioning </h2><br>  The third way to partition a table is hash partitioning. <br><br>  Creating a table: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_hash ( book_ref <span class="hljs-type"><span class="hljs-type">character</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, book_date <span class="hljs-type"><span class="hljs-type">timestamptz</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, total_amount <span class="hljs-type"><span class="hljs-type">numeric</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY HASH</span></span>(book_ref);</code> </pre><br>  In this embodiment, book_ref, as a partitioning key, can be immediately declared a primary key. <br><br>  Splitting into three sections: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_hash_p0 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MODULUS <span class="hljs-number"><span class="hljs-number">3</span></span>, REMAINDER <span class="hljs-number"><span class="hljs-number">0</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_hash_p1 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MODULUS <span class="hljs-number"><span class="hljs-number">3</span></span>, REMAINDER <span class="hljs-number"><span class="hljs-number">1</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> bookings_hash_p2 <span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OF</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MODULUS <span class="hljs-number"><span class="hljs-number">3</span></span>, REMAINDER <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  Filling with automatic layout in sections: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings;</code> </pre><pre> <code class="plaintext hljs">INSERT 0 262788</code> </pre> <br>  The distribution of lines in sections occurs evenly: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> tableoid;</code> </pre><pre> <code class="plaintext hljs"> partition | count ------------------+------- bookings_hash_p0 | 87649 bookings_hash_p1 | 87651 bookings_hash_p2 | 87488 (3 rows)</code> </pre> <br>  New command to view partitioned objects: <br><br><pre> <code class="pgsql hljs">=&gt; \dP+</code> </pre><pre> <code class="plaintext hljs"> List of partitioned relations Schema | Name | Owner | Type | Table | Total size | Description ----------+--------------------+---------+-------------------+----------------+------------+------------- bookings | bookings_hash | student | partitioned table | | 13 MB | bookings | bookings_list | student | partitioned table | | 15 MB | bookings | bookings_range | student | partitioned table | | 13 MB | bookings | tickets_list | student | partitioned table | | 50 MB | bookings | book_date_idx | student | partitioned index | bookings_range | 5872 kB | bookings | bookings_hash_pkey | student | partitioned index | bookings_hash | 5800 kB | bookings | bookings_list_pkey | student | partitioned index | bookings_list | 8120 kB | bookings | tickets_list_pkey | student | partitioned index | tickets_list | 19 MB | (8 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> bookings_hash;</code> </pre><br><h2>  Subqueries and nested loop join </h2><br>  The elimination of sections at runtime is possible when connecting nested loops. <br><br>  Distribution of the first 10 bookings in sections: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_ref <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, count(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs"> partition | count ------------------+------- bookings_hash_p0 | 3 bookings_hash_p1 | 3 bookings_hash_p2 | 4 (3 rows)</code> </pre> <br>  Let's look at the query execution plan with the connection of the bookings_hash table and the previous subquery: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">TIMING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_ref <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bh.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash bh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bh.book_ref = top10.book_ref;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------------------- Nested Loop (actual rows=10 loops=1) -&gt; Limit (actual rows=10 loops=1) -&gt; Index Only Scan using bookings_pkey on bookings (actual rows=10 loops=1) Heap Fetches: 0 -&gt; Append (actual rows=1 loops=10) -&gt; Index Scan using bookings_hash_p0_pkey on bookings_hash_p0 bh (actual rows=1 loops=3) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p1_pkey on bookings_hash_p1 bh_1 (actual rows=1 loops=3) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p2_pkey on bookings_hash_p2 bh_2 (actual rows=1 loops=4) Index Cond: (book_ref = bookings.book_ref) Planning Time: 0.632 ms Execution Time: 0.278 ms (13 rows)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Connection is performed using the nested loops method. </font><font style="vertical-align: inherit;">The outer loop in a common table expression is executed 10 times. </font><font style="vertical-align: inherit;">But pay attention to the number of calls to the table-sections (loops). </font><font style="vertical-align: inherit;">For each value of the external loop's book_ref, only the section is viewed where this value is stored in the bookings_hash table. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Compare with disabled section exclusion:</font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> enable_partition_pruning <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">TIMING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_ref <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bh.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash bh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> top10 <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bh.book_ref = top10.book_ref;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ------------------------------------------------------------------------------------------------------ Nested Loop (actual rows=10 loops=1) -&gt; Limit (actual rows=10 loops=1) -&gt; Index Only Scan using bookings_pkey on bookings (actual rows=10 loops=1) Heap Fetches: 0 -&gt; Append (actual rows=1 loops=10) -&gt; Index Scan using bookings_hash_p0_pkey on bookings_hash_p0 bh (actual rows=0 loops=10) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p1_pkey on bookings_hash_p1 bh_1 (actual rows=0 loops=10) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p2_pkey on bookings_hash_p2 bh_2 (actual rows=0 loops=10) Index Cond: (book_ref = bookings.book_ref) Planning Time: 0.886 ms Execution Time: 0.771 ms (13 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">RESET</span></span> enable_partition_pruning;</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> If you reduce the sample to one reservation, then two sections will not be viewed at all: </font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">TIMING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> top <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> tableoid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partition</span></span>, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> book_ref <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> bh.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash bh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> top <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bh.book_ref = top.book_ref;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN --------------------------------------------------------------------------------------------------- Nested Loop (actual rows=1 loops=1) -&gt; Limit (actual rows=1 loops=1) -&gt; Index Only Scan using bookings_pkey on bookings (actual rows=1 loops=1) Heap Fetches: 0 -&gt; Append (actual rows=1 loops=1) -&gt; Index Scan using bookings_hash_p0_pkey on bookings_hash_p0 bh (actual rows=1 loops=1) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p1_pkey on bookings_hash_p1 bh_1 (never executed) Index Cond: (book_ref = bookings.book_ref) -&gt; Index Scan using bookings_hash_p2_pkey on bookings_hash_p2 bh_2 (never executed) Index Cond: (book_ref = bookings.book_ref) Planning Time: 0.250 ms Execution Time: 0.090 ms (13 rows)</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Instead of a subquery, you can use the function returning the set with the category of variability STABLE: </font></font><br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> get_book_ref(top <span class="hljs-type"><span class="hljs-type">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SETOF</span></span> bookings <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BEGIN</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">RETURN QUERY</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">EXECUTE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'SELECT * FROM bookings ORDER BY book_ref LIMIT $1'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">USING</span></span></span><span class="pgsql"> top; </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql">;$$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql <span class="hljs-keyword"><span class="hljs-keyword">STABLE</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">COSTS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">TIMING</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bookings_hash bh <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> get_book_ref(<span class="hljs-number"><span class="hljs-number">10</span></span>) f <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> bh.book_ref = f.book_ref;</code> </pre><pre> <code class="plaintext hljs"> QUERY PLAN ----------------------------------------------------------------------------------------------------- Nested Loop (actual rows=10 loops=1) -&gt; Function Scan on get_book_ref f (actual rows=10 loops=1) -&gt; Append (actual rows=1 loops=10) -&gt; Index Scan using bookings_hash_p0_pkey on bookings_hash_p0 bh (actual rows=1 loops=3) Index Cond: (book_ref = f.book_ref) -&gt; Index Scan using bookings_hash_p1_pkey on bookings_hash_p1 bh_1 (actual rows=1 loops=3) Index Cond: (book_ref = f.book_ref) -&gt; Index Scan using bookings_hash_p2_pkey on bookings_hash_p2 bh_2 (actual rows=1 loops=4) Index Cond: (book_ref = f.book_ref) Planning Time: 0.175 ms Execution Time: 0.843 ms (11 rows)</code> </pre> <br><h2>  Results </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Summarizing, we can say that the built-in or declarative partitioning in PostgreSQL 12 has received a rich set of features and can be safely recommended to replace partitioning through inheritance. </font></font></div><p>Source: <a href="https://habr.com/ru/post/456716/">https://habr.com/ru/post/456716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456700/index.html">GeekUniversity opens recruitment to the faculty of product management</a></li>
<li><a href="../456704/index.html">Six ways testers can benefit (in addition to functional testing)</a></li>
<li><a href="../456710/index.html">What is low-code / no-code platform and CRM, CRM +, ERP</a></li>
<li><a href="../456712/index.html">Selective logging of traffic for SOAP services</a></li>
<li><a href="../456714/index.html">Understanding floating point numbers (part 0)</a></li>
<li><a href="../456722/index.html">PostgreSQL Recipes: Asynchronous Task Scheduler</a></li>
<li><a href="../456724/index.html">5 extremely simple ways to significantly increase the speed of your VueJS-application</a></li>
<li><a href="../45673/index.html">Everything we dreamed of for so long is the first official release of MySQL 5.1.</a></li>
<li><a href="../456732/index.html">To be a mentor</a></li>
<li><a href="../456736/index.html">PostgreSQL recipes: cURL: get, post and ... email</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>