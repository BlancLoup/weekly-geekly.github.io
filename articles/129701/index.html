<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Clipping algorithms</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With the growth of computer power, more and more people are trying to work with graphics. At first glance, many algorithms seem intuitive, but if you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Clipping algorithms</h1><div class="post__text post__text-html js-mediator-article">  With the growth of computer power, more and more people are trying to work with graphics.  At first glance, many algorithms seem intuitive, but if you want your application to work at an acceptable speed, you will have to learn classical algorithms. <br><br>  This post is devoted to the analysis of several algorithms aimed at the same task, the task of cutting off segments.  When generating images, figures of arbitrary shape and size can be obtained.  Often, monitors cannot display the generated images entirely.  Also sometimes there are situations when it is necessary to set the image area on the screen and display images only inside this area.  To solve these problems, cut-off algorithms were invented. <a name="habracut"></a><br><br><h4>  Segment cut </h4><br>  The simplest clipping problem is the line clipping problem.  We formulate it on a specific example.  We assume that the output region is given by the rectangle ABCD.  Consider an example, and take the triangle PRQ as a cut figure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage1/3d4a2a3d/add803e3/3b199bcd/700983e0.png"><br><br>  The clipping process should be performed fully automatically.  Those.  for the drawing of the triangle PRQ, only the commands for drawing the segments PQ; PP '; Q' Q must be executed. At the same time, the coordinates of the points P '; Q' are not known in advance. <br>  In practice, a large number of mutual locations of the points of the segment and the output area are possible.  This variety makes the clipping operation very non-trivial from an algorithmic point of view.  To solve these problems, cut-off algorithms have been created. <br><br><h5>  Sutherland-Cohen Algorithm </h5><br>  Quite interesting is the clipping algorithm proposed by Sutherland and Cohen.  The essence of the algorithm is that a four-bit code is assigned to the ends of a segment: b <sub>0</sub> , b <sub>1</sub> , b <sub>2</sub> , b <sub>3</sub> .  This four-bit code contains information about the position of a point relative to the output area.  In practice, there are 9 combinations: <br><img src="https://habrastorage.org/storage1/3c2c6270/1b84a4bf/4230d083/16babc35.png"><br>  We explain these codes: <br>  We explain these codes: <br><ul><li>  b <sub>0</sub> = 0, if x‚â•x <sub>min</sub> ; </li><li>  b <sub>0</sub> = 1 if x &lt;x <sub>min</sub> ; </li><li>  b <sub>1</sub> = 0, if x‚â§x <sub>max</sub> ; </li><li>  b <sub>1</sub> = 1, if x&gt; x <sub>max</sub> ; </li><li>  b <sub>2</sub> = 0, if y‚â•y <sub>min</sub> ; </li><li>  b <sub>2</sub> = 1, if y &lt;y <sub>min</sub> ; </li><li>  b <sub>3</sub> = 0, if y‚â§y <sub>max</sub> ; </li><li>  b <sub>3</sub> = 1, if y&gt; y <sub>max</sub> ; </li></ul><br><br>  After the codes are received, the following options are possible: <br><ol><li>  Codes contain only 0, which means the segment is entirely inside the window and must be drawn entirely; </li><li>  Codes contain a single bit in the same position, which means that the segment lies outside the window and will not be drawn; </li><li>  In all other cases, the window is only part of the segment, and this means that there is a need for clipping. </li></ol><br>  The first two cases are easily verified using bitwise logical operations.  Of greatest interest is the third case.  Consider it on a small specific example. <br><br><img src="https://habrastorage.org/storage1/8edb4373/ac566ac3/936d0d49/61b447d8.png"><br><br>  If the code of any of the ends contains a single bit, then either P <sub>1</sub> or P <sub>2</sub> moves from outside the window to one of its borders (or to its continuation).  Those.  point P <sub>1</sub> moves to point R, and P <sub>2</sub> moves to point U. For new points, we again calculate four-bit codes.  In our case, the ends of the segment still lie outside the window, i.e.  we need one more movement: point R move to point S, and point U move to point T. It turns out that the clipping process is iterative.  Since at each step the distance between the ends of the segment decreases, we can say that the algorithm will converge.  As a result, a segment will be obtained (in our case (S; T), which should be displayed). <br>  Consider the work of this algorithm on another example. <br><br><img src="https://habrastorage.org/storage1/addc7338/a08b92c9/ae836a29/c2ea562c.png"><br><br>  The location of the segment (P <sub>1</sub> ; P <sub>2</sub> ) does not meet either the conditions of full visibility or the conditions of complete invisibility, so in this case, too, resort to the operation of transfer of points. <br><img src="https://habrastorage.org/storage1/fd002792/2dcb4e1b/6e127dd7/0f546984.png"><br>  After the carried out transfers, the codes of the ends of the segment satisfy the second condition, i.e.  the entire segment will not be displayed on the screen. <br><h5>  Midpoint algorithm </h5><br>  In the Sutherland-Cohen algorithm, the search for the point of intersection of the segment with the window border can take several iterations.  This can be avoided if you implement a search for an intersection point using a binary search.  This idea was proposed by Sprull and Sutherland.  The software implementation of this algorithm is slower than the Sutherland-Cohen algorithm, but the hardware implementation is faster, since the basic operations of the algorithm are very efficiently implemented in hardware. <br><img src="https://habrastorage.org/storage1/b366579a/80efea6a/b3cd8b70/21f0aaa3.png"><br><br>  This method also uses the four-bit code described above.  With the help of these codes, cases of trivial visibility (a) and trivial invisibility (b) are easily identified.  The remaining (non-trivial) segments are divided into two equal parts, and checks are performed for two newly obtained segments.  Division and checks will be performed until an intersection with the side of the window is detected, or until the segment degenerates into a point.  After the segment has degenerated, we determine its visibility and, depending on the result, either draw the current or not. <br>  Consider the segment c.  Obviously, this segment lies entirely outside the window, but it cannot be rejected immediately.  That is why we perform half divisions and exclude some parts of the segment.  The division ends at the moment when the segment turns into a point.  Making sure that the resulting point is invisible, we conclude that the entire segment should not be drawn. <br>  The segment d is also not defined trivially.  Its division into two halves (point 3) leads to the same results for both halves.  The segment (3; 2) is split in half by a point 4. Theoretically, you can draw a segment (3; 4), but this is not very effective.  It is more correct to remember point 4 as the visible point furthest from point 1, and continue the segment (4; 2) to break up to the intersection with the lower border of the window.  The resulting point and will be considered the most distant from point 1 visible point.  Similarly, the interval 3; 1 is processed, and the visible point is the farthest from point 2. Then, between these two points, the drawing takes place. <br>  For d-type segments, it is necessary to perform two binary searches for visible points furthest from the ends of the segment.  For segments of type e, the need for one of the binary searches is eliminated. <br><br><h5>  Algorithm of Cyrus Beck </h5><br>  In the work of the Cyrus-Beck algorithm, a parametric representation of the segment is used: P <sub>s</sub> (t) = P <sub>1</sub> + (P <sub>2</sub> -P <sub>1</sub> ) * t; t‚àà [0; 1].  This algorithm allows clipping not only with a rectangular window, but also with any convex polygon. <br>  Consider a separate edge E <sub>i of the</sub> cutting polygon.  Orient the normal to this edge to the outer side of the cutting polygon.  We also assume that the cutting polygon is counterclockwise.  Then, if the edge is the vector P <sub>(E <sub>(i <sub>1</sub> )</sub> )</sub> P <sub>E <sub>i <sub>2</sub></sub></sub> , then the normal N <sub>E <sub>i</sub></sub> will be proportional to (y <sub>E <sub>i <sub>2 -</sub></sub></sub> y <sub>E <sub>i <sub>1</sub></sub></sub> ; x <sub>E <sub>i <sub>1 -</sub></sub></sub> x <sub>E <sub>i <sub>2</sub></sub></sub> ). <br>  Denote the line on which the edge lies by L <sub>i</sub> .  Then the area cut off by the line L <sub>i</sub> corresponds to points P for which the scalar product of the vectors (PP <sub>E <sub>i</sub> )</sub> ) and N <sub>E <sub>i is</sub></sub> greater than 0 (P <sub>E <sub>i</sub></sub> is any point on the edge of E <sub>i</sub> ).  The point of intersection of the line on which the segment lies with the cutting line L <sub>i</sub> is found from the equation ((P <sub>s</sub> (t) -P <sub>E <sub>i</sub></sub> , N <sub>E <sub>i</sub></sub> = 0). Solving this equation, we find t. <br>  For the described algorithm, it is also important in what direction (inside or out of the window) a point passes when moving along the segment from P <sub>1</sub> to P <sub>2</sub> .  This is determined by the sign ((P <sub>2</sub> -P <sub>1</sub> ), N <sub>E <sub>i</sub></sub> . We will denote such intersection points as: <br><br><img src="https://habrastorage.org/storage1/48337b4b/d2049468/b04eba10/fded1f74.png"><br><br>  After calculating the coordinates of t for all possible intersections with straight lines L <sub>i</sub> , you should choose the maximum coordinate of the potentially incoming and the minimum of the potentially outgoing (t <sub>BxMax</sub> ; t <sub>Outmin</sub> ).  If the line, on which the segment P <sub>1</sub> P <sub>2</sub> lies, intersects the cutting polygon, then t <sub>BxMax</sub> &lt;t <sub>Outmin</sub> .  In this case, if the intersection [t <sub>1</sub> , t <sub>2</sub> ] = [t <sub>BMax</sub> , t <sub>OutMin</sub> ] ‚à© [0,1] is non-empty, then P <sub>s</sub> (t <sub>1</sub> ) P <sub>s</sub> (t <sub>2</sub> ) will be the required cut segment, otherwise In this case, the segment is completely outside the clipping region. <br><br>  On these algorithms, the topic of clipping, of course, does not end there.  A separate question is polygon clipping algorithms.  If the topic is interesting to the community, I will definitely reveal this topic. </div><p>Source: <a href="https://habr.com/ru/post/129701/">https://habr.com/ru/post/129701/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../129696/index.html">StoreBirds - the main competitor for LastPass</a></li>
<li><a href="../129697/index.html">One-button video hosting - Vimple</a></li>
<li><a href="../129698/index.html">Manifesto "kakbe-Agile" software development</a></li>
<li><a href="../129699/index.html">Buying Motorola will not affect the competition of the Android market - Eric Schmidt</a></li>
<li><a href="../129700/index.html">Lawsuits for ... patents on Wi-Fi</a></li>
<li><a href="../129706/index.html">Apple Developers Community # 9. Taste WP7</a></li>
<li><a href="../129707/index.html">YouTube is going to fill with professional video content</a></li>
<li><a href="../129708/index.html">Leadership Philosophy</a></li>
<li><a href="../129711/index.html">Experience of transition to the DNS-server NSD</a></li>
<li><a href="../129712/index.html">Oracle NoSQL database</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>