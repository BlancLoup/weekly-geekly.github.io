<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Squeeze the maximum out of DDMS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="DDMS (Dalvik Debug Monitor Server) is an incredibly useful tool for debugging applications that comes bundled with the Android SDK, which for some rea...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Squeeze the maximum out of DDMS</h1><div class="post__text post__text-html js-mediator-article">  <a href="http://developer.android.com/tools/debugging/ddms.html">DDMS</a> (Dalvik Debug Monitor Server) is an incredibly useful tool for debugging applications that comes bundled with the Android SDK, which for some reason is not specifically mentioned in Habr√©, however, as in the google examples, it is presented in a very modest form.  I would like to reveal his opportunities and show what he is capable of.  In short: <br><ul><li>  examine information about running threads; </li><li>  analyze heap on the amount of free and used memory; </li><li>  analyze which objects are created more often, their size and another (Allocation tracker); </li><li>  find problem areas of the code that work for a long time and require optimization (Method profiling).  This I advise everyone to know. </li></ul><br>  These things will be discussed in this article.  And for reference, less interesting, which is rather trivial and what will NOT be covered in this article: <br><ul><li>  work with the emulator or device file system; </li><li>  find information about errors (hello <a href="http://developer.android.com/tools/debugging/debugging-log.html">logcat</a> ); </li><li>  emulate calls / sms / location; </li><li>  use the network statistics tool. </li></ul><br><br><a name="habracut"></a><br><h5>  Threads </h5><br>  DDMS contains a tool that allows us to analyze information on each process and its threads.  It is enough to select the necessary process of our application and click "update threads". <br><img src="https://habrastorage.org/getpro/habr/post_images/21d/814/8cc/21d8148cc351260db4c4a512915be5e0.jpg"><br><br>  On the right, you can see the ‚ÄúThreads‚Äù tab and the working threads of the selected process.  The following information is available for each stream: <br><ul><li>  Id - unique identifier of the stream assigned by the virtual machine.  If there is an asterisk next to it, then it is a daemon thread; </li><li>  Tid - stream id in Linux.  The main process thread will contain the process id; </li><li>  Status - current status of the stream; </li><li>  Utime is the total time the thread spent executing custom code.  The units of measurement are <a href="http://www.makelinux.net/books/lkd2/ch10lev1sec3">jiffies</a> , the duration of which is determined by the system and is usually 10ms; </li><li>  Stime - the time spent on the execution of the system code.  The units of measurement are also jiffies; </li><li>  Name - the name of the stream.  Do not forget to give meaningful names when creating a stream. </li></ul><br>  Thus, we can understand which thread consumes the most CPU time.  Here it is necessary to say a few words about some streams. <br>  GC - as everyone thinks guessed, this is a garbage collector stream.  Until Android 3, it is not available for viewing in streams. <br>  <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jpda/jdwp-spec.html">JDWP</a> (Java Debug Wire Protocol) - protocol of interaction between a debager and a virtual machine. <br><img src="https://habrastorage.org/getpro/habr/post_images/b80/845/f6d/b80845f6db3a9ed84a0f912677ee1a08.png"><br>  This is actually its flow.  Do not worry about its appearance, it is created only when debugging the application. <br>  You can also monitor your current streams and detect a memory leak if one of your streams is listed in two copies (of course, if not so intended).  Suppose you turned the screen, but you forgot to correctly handle the closing of the stream, and then created a copy of it.  In the list you will see both such streams.  I started the normal stream in onCreate () and turned the screen without stopping the past, and got such a picture. <br><img src="https://habrastorage.org/getpro/habr/post_images/057/5c4/3d3/0575c43d383e3961d74ec888aa5560aa.jpg"><br>  Perhaps, on the tab with the streams everything.  But this information is closely related to the continuation of the article. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Heap </h5><br>  We have a tool for debugging a heap.  To do this, also select the required process and select the ‚Äúupdate heap‚Äù. <br><img src="https://habrastorage.org/getpro/habr/post_images/590/db5/9d8/590db59d8ddf55a299304ad2e75f2951.jpg"><br><br>  Now we have access to information about the distribution of dynamic memory in our process.  Start the garbage collection (Cause GC) and see what remains. <br><img src="https://habrastorage.org/getpro/habr/post_images/f6c/2d9/894/f6c2d9894adbe7950f6e3f057d4e4185.jpg"><br><br>  It's all pretty simple: <br><ul><li>  Heap size is the total heap size that Android allocated for this process; </li><li>  Allocated - used memory; </li><li>  Free - free memory; </li><li>  Used - used as a percentage of memory; </li><li>  Objects - the total number of objects that make up the allocated size. </li></ul><br>  At the bottom of the screenshot, shows the distribution of objects by size and type. <br>  Heap Size can be increased as needed by the virtual machine itself.  Sometimes a few minutes of tracking him are enough to understand that you have a memory leak. <br>  I will give an example.  In one of the projects I use the listener Broadcast messages.  I commented unregisterReceiver in onPause <br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// LocalBroadcastManager.getInstance(this).unregisterReceiver(receiver);</span></span></code> </pre> <br>  BroadcastReceiver itself is registered via <a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html">LocalBroadcastManager</a> <br><pre> <code class="java hljs">LocalBroadcastManager.getInstance(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>).registerReceiver(receiver, intentFilter);</code> </pre><br>  It allows you to throw messages only in one process.  This will hold the Activity, which will definitely affect the heap.  Since I work in my project with a map service, this will lead to the retention of the map and all the tiles that have been zipped, so the result will be quickly noticeable. <br><img src="https://habrastorage.org/getpro/habr/post_images/351/d9f/8f3/351d9f8f3daccb5e62a819a3c4378e36.jpg"><br><br>  At the top of the figure, the first start of the application is shown.  Then I turned the screen 11 times, after which the heap increased quite a lot.  The application stopped responding 12 times.  An increasing heap is a double-edged sword.  On the one hand, it‚Äôs good that it can increase so slightly (depending on free memory), on the other hand, the application can stay there for a long time and will slowly work, annoying the user.  Of course, the analysis of the heap will not show where you have a leak, but will make it clear that it is still there, and this is not bad. <br><br><h5>  Allocation tracker </h5><br>  <a href="http://android-developers.blogspot.ru/2009/02/track-memory-allocations.html">Allocation tracker</a> can give us much more information.  It allows you to track which objects were created for a selected process in a selected period of time, where you can see which objects were created more often, their size, the thread that created them and the call stack. <br><img src="https://habrastorage.org/getpro/habr/post_images/b7d/527/a0a/b7d527a0a69b9e138d1f5f6d0afc8fd1.jpg"><br><br>  Select ‚ÄúStart track‚Äù, after which we perform actions with the application that we want to analyze, then click ‚ÄúGet Allocations‚Äù.  A list of objects that were created during this period of time will appear below. <br>  In this screenshot, the objects are sorted by the order of their initialization or by the time of creation, I do not know how to put it better.  You can sort your objects in any convenient way by simply clicking on the column name.  Available information: <br><ul><li>  Alloc order - the number of the created object; </li><li>  Allocation Size - the size of the object; </li><li>  Allocated Class - object type; </li><li>  Thread Id - the thread id assigned by the virtual machine (not to be confused with Tid); </li><li>  Allocated Id - the class and method in which the object was created. </li></ul><br>  We can select any object and see its entire call stack.  Thus, you can get information about where objects are created, how often, their size and take appropriate measures, because many people know that the creation of an object is an expensive operation and should be avoided. <br><br><h5>  Method profiling </h5><br>  I finally got to my favorite code analysis tool, ‚ÄúMethod Profiling‚Äù.  This tool allows you to analyze the time that was spent methods on their work.  Thereby, we can understand the bottlenecks in our code and optimize them. <br>  I will show a simple example.  In one of our projects, we had to deal with the NMEA protocol.  This is a maritime protocol that provides so-called ‚Äúraw‚Äù GPS data.  I parsed this data.  This is one of the lines I need. <br><blockquote>  $ GPGGA, 123519,4807.038, N, 01131.000, E, 1.08.0.9.545.4, M, 46.9, M ,, * 47 </blockquote><br>  Split by comma and everything is fine.  Or not?  Select the required process and run Method Profiling. <br><img src="https://habrastorage.org/getpro/habr/post_images/20b/734/c26/20b734c2650aaa09b5669c30ad06c6f4.jpg"><br><br>  After 1-2 minutes (you yourself choose the time that you consider necessary), stop Method Profiling, after which we get a trace of our methods, as shown in the figure below. <br><img src="https://habrastorage.org/getpro/habr/post_images/b1e/85f/ea2/b1e85fea2f1f3ee598b81dfccac7a8c4.jpg"><br><br>  The upper part shows the time schedule of work flows.  Here you can find the id of the stream, its name and a graphic representation of the time of its work.  Much more interesting is the lower part of the treys.  At the left, from top to bottom, methods are shown which consume the maximum number of processor time; <br><ul><li>  Incl Cpu Time% - time spent on executing own code in a method, plus the time spent on executing other methods in this method (%); </li><li>  Excl Cpu Time% - time spent on the execution of own code in the method (%); </li><li>  Incl Cpu Time and Excl Cpu Time are the same, only units of millisecond; </li><li>  Calls + Recur Calls / Total - the number of calls and their recurrences; </li><li>  Time / Call - total elapsed time (ms). </li></ul><br>  In this table, noticeably, my method spends 23.5% of the total time.  By clicking on it, I got this picture <br><img src="https://habrastorage.org/getpro/habr/post_images/06e/a49/fb3/06ea49fb3a3f1cff57f580c9478fac85.jpg"><br><br>  Obviously, the split method, which spends 72% of the time of the total time of the method in which it was called, is to blame.  The usual transition to substring allowed us to optimize this method by 2 times. <br><img src="https://habrastorage.org/getpro/habr/post_images/a4b/941/ff5/a4b941ff506c7a7495d627564b28f75d.jpg"><br><br>  Our method went down by the workload to the 15th position, and the others went upstairs, where you can also look at the information, what time is spent on, look at the call stack and figure out how to optimize it.  Also here is the implicit optimization.  Since split produces an array with strings, now the load on the GC has become less, hence the number of calls of the collector will, by definition, be less, which will have a favorable effect on both the speed and responsiveness of the application.  GC can also be found in this trace, if it was launched by the system during the code analysis. <br>  You can sort the methods, as well as with the allocation tracker, just click on the column name. <br>  It is possible to analyze only certain sections of code in the application.  For this, Android provides us with two methods: <br><pre> <code class="java hljs">android.os.Debug.startMethodTracing(‚Äútrace_name‚Äù);  android.os.Debug.stopMethodTracing();</code> </pre><br>  After the stopMethodTracing is completed, the trace will be available in /sdcard/trace_name.trace.  This can be very useful if we want to optimize certain parts of the code, or, for example, improve the speed of the start of the application. <br><br>  Perhaps this is all for now.  Behind the scene was a heap dump analysis ( <b>Dump HPROF File</b> ).  If you are interested, I will try to write an article in the same spirit about such a wonderful tool as <b>MAT</b> , which allows you to analyze the heap dump for leaks and other things.  He just shows all instances of my activity, which were held in a heap when you rotate the screen. <br>  I also avoided the tool Hierarchy Viewer, which already has <a href="http://habrahabr.ru/post/173109/">an article</a> on Habr√©.  I hope this article is helpful and helps you optimize your applications. <br><br>  Happy debugging! </div><p>Source: <a href="https://habr.com/ru/post/222199/">https://habr.com/ru/post/222199/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../222187/index.html">PocketBook Reader - we read on phones comfortably</a></li>
<li><a href="../222189/index.html">We start the Weekend contest ‚ÄúI want to DevConf 2014!‚Äù With the draw of free passes on the main day of DevConf 2014</a></li>
<li><a href="../222191/index.html">Testing Web UI with Vika in pleasure or Virtual Intellect in testing</a></li>
<li><a href="../222193/index.html">Idea, team, technology, money, methodology - what really depends on the success of the project?</a></li>
<li><a href="../222195/index.html">A coward does not play air hockey: how to win when there is no chance</a></li>
<li><a href="../222201/index.html">Arduino Pro Mini Firmware via Nano</a></li>
<li><a href="../222207/index.html">Survey: what methodology is used in your project or how much we have through it?</a></li>
<li><a href="../222209/index.html">New scanning business cards in Evernote with LinkedIn</a></li>
<li><a href="../222211/index.html">The smallest comics in the world "painted" on the tip of the hair</a></li>
<li><a href="../222213/index.html">HealthWatch seeks FDA approval for its T-shirt tracking ECG</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>