<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Direct SQL in EntityFramework. Now with strong typing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 


 Today we will talk a little about EntityFramework. A little bit. Yes, I know that it can be treated differently, many people spit from him,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Direct SQL in EntityFramework. Now with strong typing</h1><div class="post__text post__text-html js-mediator-article"><h2 id="privet">  Hello! </h2><br><p>  Today we will talk a little about EntityFramework.  A little bit.  Yes, I know that it can be treated differently, many people spit from him, but in the absence of a better alternative, they continue to use it. </p><br><p>  So here.  Do you often use direct SQL queries to the database in your C # project with a customized ORM?  Oh, yes, quit, do not shun.  Use.  Otherwise, how would you implement the deletion / update of the entities in batches <del>  and remained alive </del>  ... </p><br><p> What do we love most about live SQL?  Speed ‚Äã‚Äãand simplicity.  Where "in the best traditions of ORM" it is necessary to unload the wagon of objects into memory and make everyone <code>context.Remove</code> (well, or manipulate Attach), you can do with one small SQL query. <br>  What do we most dislike about live SQL?  Right.  Lack of typification and explosiveness.  Direct SQL is usually done through <code>DbContext.Database.ExecuteSqlCommand</code> , and it accepts only a string as input.  Therefore, Find Usages in the studio will never show you which fields your direct SQL has touched on which entities, and, among other things, you have to rely on your memory in the question of the exact names of all the tables / columns you are feeling.  And also to pray that no head shooter digs into your model and will not rename everything in the course of refactoring or by means of EntityFramework while you are sleeping. </p><br><p>  So rejoice, adherents of small raw SQL queries!  In this article, I will show you how to combine them with EF, not to lose in mining safety and not to produce detonators.  Dive under the cat soon! </p><a name="habracut"></a><br><h3 id="a-chego-konkretno-hotim-dostich">  And what exactly do we want to achieve? </h3><br><p>  So, in this article, I will show you a great approach that will once and for all save you from worrying about the problems that direct SQL usually causes in tandem with EntityFramework.  Your requests will acquire a human appearance, will be located through Find Usages and will become resistant to refactoring (deletion / renaming of fields in entities), <del>  and your feet will get warmer, the sores will dissolve, karma will clear </del>  . </p><br><p>  We will need: C # 6.0 (well, the one in which the interpolation of strings is implemented), lambda expressions and a few straight hands.  I called this technique "SQL Stroke".  Ultimately, we will write several extension-methods for <code>DbContext</code> , which allow sending to the SQL database with strongly typed inserts.  To do this, we need to talk with the metadata of EntityFramework, parse the lambda expressions and fix all the bugs and corner cases that arise along the way. </p><br><p>  Here is what your direct SQL will look like after reading this article: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyDbContext()) { <span class="hljs-comment"><span class="hljs-comment">//---------- dc.Stroke&lt;Order&gt;(x =&gt; $"DELETE FROM {x} WHERE {x.Subtotal} = 0"); // ^ IntelliSense! //---------- var old = DateTime.Today.AddDays(-30); dc.Stroke&lt;Customer&gt;(x =&gt; $"UPDATE {x} SET {x.IsActive} = 0 WHERE {x.RegisterDate} &lt; {old}"); //---------- dc.Stroke&lt;Item, Order&gt;((i, o) =&gt; $@" UPDATE {i} SET {i.Name} = '[FREE] ' + {i.Name} FROM {i} INNER JOIN {o} ON {i.OrderId} = {o.Id} WHERE {o.Subtotal} = 0" , true); }</span></span></code> </pre><br><p>  <strong>TL; DR</strong> : in <a href="https://github.com/reinforced/Reinforced.Stroke">short, here it is on the githab, there is more vivid</a> </p><br><p>  Here we see that when we call <code>.Stroke</code> type-parameters, we specify the entities (mapped on the table) with which we will work.  They become arguments in the subsequent lambda expression.  In short, <code>Stroke</code> passes the lambda passed to it through the parser, turning <code>{x}</code> into tables, and <code>{x.Property}</code> into the corresponding column name. </p><br><p>  Something like this.  Now let's review the details. </p><br><h3 id="sopostavlenie-klassov-i-svoystv-s-tablicami-i-kolonkami">  Mapping classes and properties with tables and columns </h3><br><p>  Let's refresh your knowledge of Reflection: imagine that you have a class (more precisely <code>Type</code> ) and you have a string with the name property from this class.  There is also a heir to the EF- <code>DbContext</code> .  Having these two forks and sneakers, you need to get the name of the table on which your class is mapped and the name of the column in the database your proper map is on.  Immediately make a reservation: the solution to this problem will be different in EF Core, but this does not affect the main idea of ‚Äã‚Äãthe article.  So I suggest the reader to independently implement / google the solution to this problem. </p><br><p>  So, EF 6. The required can be obtained through the very popular magic of casting an EF context to an <code>IObjectContextAdapter</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTableName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DbContext context, Type t</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     ObjectContext- var objectContext = ((IObjectContextAdapter)context).ObjectContext; //   var metadata = objectContext.MetadataWorkspace; //        CLR- var objectItemCollection = ((ObjectItemCollection)metadata.GetItemCollection(DataSpace.OSpace)); //      .  EF-    var entityType = metadata.GetItems&lt;EntityType&gt;(DataSpace.OSpace) .FirstOrDefault(x =&gt; objectItemCollection.GetClrType(x) == t); //        var container = metadata .GetItems&lt;EntityContainer&gt;(DataSpace.CSpace) .Single() .EntitySets .Single(s =&gt; s.ElementType.Name == entityType.Name); //       - var mapping = metadata.GetItems&lt;EntityContainerMapping&gt;(DataSpace.CSSpace) .Single() .EntitySetMappings .Single(s =&gt; s.EntitySet == container); // ,      () var tableEntitySet = mapping .EntityTypeMappings.Single() .Fragments.Single() .StoreEntitySet; //    var tableName = tableEntitySet.MetadataProperties["Table"].Value ?? tableEntitySet.Name; //   return tableName; }</span></span></code> </pre><br><p>  And please, do not ask me what the EntityFramework developers are. <del>  smoked </del>  had in mind, creating such labyrinths of abstractions and what it means in every cornerstone.  Honestly, I myself can get lost in this labyrinth and I didn‚Äôt write a piece above, I just <a href="https://romiller.com/2015/08/05/ef6-1-get-mapping-between-properties-and-columns/">found it</a> and gutted it. </p><br><p>  So, with the table sort of sorted out.  Now the name of the column.  Fortunately, it lies nearby, in the entity container mapping: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTableName</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> DbContext context, Type t, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//      ,  var mappings = ... //       var columnName = mapping .EntityTypeMappings.Single() .Fragments.Single() .PropertyMappings .OfType&lt;ScalarPropertyMapping&gt;() .Single(m =&gt; m.Property.Name == propertyName) .Column .Name; // ,   ? return columnName; }</span></span></code> </pre> <br><p>  So, and here I immediately warn the reader <strong>in</strong> large letters: <strong>delving into EF-metadata is slow!</strong>  Other than jokes.  Therefore, in general, cache everything you can reach.  The article has a link to my code - there I was already preoccupied with caching - you can use.  But still keep in mind: the real conceptual models of EF are stozoi monsters that keep platoons and divisions of various objects.  If you need only the relation type-name of the table and type / property ‚Äî the name of the column, then it is better to remove and cache once (just don‚Äôt force a memory leak there - do not store anything from <code>DbContext</code> ).  In EF Core, they say, this is better. </p><br><h3 id="vyrazheniya">  Expressions </h3><br><p>  The most boring behind.  Now - lambda expressions.  Suppose we want to have a <code>Stroke</code> method, so that it could be called like this: </p><br><pre> <code class="cs hljs">context.Stroke&lt;MyEntity&gt;(x =&gt; <span class="hljs-string"><span class="hljs-string">$"UPDATE </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x}</span></span></span><span class="hljs-string"> WHERE </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{x.Age}</span></span></span><span class="hljs-string"> &gt; 10"</span></span>)</code> </pre> <br><p>  The <code>Stroke</code> method itself is simple: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Stroke&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> DbContext s, Expression&lt;Func&lt;T, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;&gt; stroke) { <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] pars = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sql = Parse(context, stroke, <span class="hljs-keyword"><span class="hljs-keyword">out</span></span> pars); context.Database.ExecuteSqlCommand(sql, pars); }</code> </pre> <br><p>  It is based on the <code>Parse</code> method, which does all the basic work.  As you might guess, this method should parse the lambda expression obtained from the interpolation of a string.  It's no secret that the sharp interpolation of strings is syntactic sugar for <code>String.Format</code> .  Therefore, when you write <code>$"String containing {varA} and {varB}"</code> , the compiler converts this construct into a call to <code>String.Format("String containing {0} and {1}", varA, varB)</code> .  The first parameter of this method <em>is the format string</em> .  In it, we see placeholders with the naked eye - <code>{0}</code> , <code>{1}</code> and so on.  <code>Format</code> simply replaces these placeholders with what comes after the format string, in the order indicated by the numbers in placeholders.  If there are more placeholders than 4, then the interpolated string is compiled into a call to the <code>String.Format</code> overload from two parameters: the format string itself and the array, into which all sufferers get into the resulting string parameters are packed. </p><br><p>  So what are we going to do in the <code>Parse</code> method now?  We will tick out the original format string with tongs, and recalculate the formatting arguments, replacing where necessary with the names of tables and columns.  Then we will call <code>Format</code> , and then we will assemble the original format string and the processed arguments into the resulting SQL string.  Honestly, it is much easier to code than to explain :) </p><br><p>  So, let's begin: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">DbContext context, LambdaExpression query, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] parameters</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       const string err = ",  !"; var bdy = query.Body as MethodCallExpression; //     ? if (bdy == null) throw new Exception(err); //    -  String.Format? if (bdy.Method.DeclaringType != typeof(String) || bdy.Method.Name != "Format") { throw new Exception(err); }</span></span></code> </pre> <br><p>  As you know, lambda expressions in C # are literally expressions.  That is, everything that goes after <code>=&gt;</code> should be one and only one expression.  In delegates, you can push operators and separate them with a semicolon.  But when you write <code>Expression&lt;&gt;</code> - everything.  From now on, you limit the input data to one and only one expression.  This is what happens in our <code>Stroke</code> method.  <code>LambdaExpression</code> is an ancestor of <code>Expression&lt;&gt;</code> , only without generics unnecessary to us.  Therefore, it would be necessary to make sure that the only expression that is contained in our <code>query</code> is the call to <code>string.Format</code> and nothing else that we did.  Now we will look with what arguments it caused.  Well, with the first argument, everything is clear - this is a format string.  We extract it to the joy of all honest people: </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//     var fmtExpr = bdy.Arguments[0] as ConstantExpression; if (fmtExpr == null) throw new Exception(err); // ...    var format = fmtExpr.Value.ToString();</span></span></code> </pre> <br><p>  Next you need to make a small feint with your ears: as mentioned above, if the interpolated string has more than 4 placeholders, it is translated into a call to <code>string.Format</code> with two parameters, the second of which is an array (in the form <code>new [] { ... }</code> ).  Let's process this situation: </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  ,        // 1 -     -   int startingIndex = 1; //    var arguments = bdy.Arguments; bool longFormat = false; //       if (bdy.Arguments.Count == 2) { var secondArg = bdy.Arguments[1]; // ...    - new[] {...} if (secondArg.NodeType == ExpressionType.NewArrayInit) { var array = secondArg as NewArrayExpression; //          arguments = array.Expressions; //   startingIndex = 0; //  ,        longFormat = true; } }</span></span></code> </pre> <br><p>  Now let's go through the resulting <code>arguments</code> collection and, finally, convert each argument that is associated with our lambda parameters into a table / column name, and anything that is not a reference to tables and columns, we calculate and drop it into the parameter list of the query, leaving the parameters format <code>{i}</code> , where <code>i</code> is the index of the corresponding parameter.  Nothing new for experienced users of <code>ExecuteSqlCommand</code> . </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//        //   string.Format List&lt;string&gt; formatArgs = new List&lt;string&gt;(); //   -   List&lt;object&gt; sqlParams = new List&lt;object&gt;();</span></span></code> </pre><br><p>  The first thing to do is a small technical feature of C # -powers lambdas: in view of strict typing, when you write, for example, <code>x =&gt; "a" + 10</code> , the compiler wraps your ten in <code>Convert</code> - type conversion (obviously, to a string).  Essentially, everything is correct, but during parsing lambdas this circumstance is very complicated.  Therefore, here we will make a small <code>Unconvert</code> method that will check our argument for wrapping in <code>Convert</code> and, if necessary, expand: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unconvert</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression ex</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex.NodeType == ExpressionType.Convert) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cex = ex <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> UnaryExpression; ex = cex.Operand; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ex; }</code> </pre> <br><p>  Wonderful.  Next, we need to understand whether the next argument is related to the parameters of the expression.  Well, that is, it has the form <code>p.Field1.Field2...</code> , where <code>p</code> is a parameter of our expression (what is put before the lambda operator <code>=&gt;</code> ).  Because if it does not, then this argument must be simply calculated, and the result remembered as a parameter of the SQL query, for subsequent feeding of the EF.  The easiest and most clumsy way to determine whether we are referring to a field of any of the parameters is the following two methods: </p><br><p>  In the first, we simply iterate over the chain of calls to members until we reach the root (I called it <code>GetRootMember</code> ): </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Expression </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRootMember</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MemberExpression expr</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> accessee = expr.Expression <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberExpression; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> current = expr.Expression; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (accessee != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { accessee = accessee.Expression <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (accessee != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) current = accessee.Expression; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> current; }</code> </pre> <br><p>  In the second, we actually check the conditions required by us: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsScopedParameterAccess</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Expression expr</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -    {x},  ,   if (expr.NodeType == ExpressionType.Parameter) return true; var ex = expr as MemberExpression; //        -   if (ex == null) return false; //     var root = GetRootMember(ex); // ,    if (root == null) return false; //     -  if (root.NodeType != ExpressionType.Parameter) return false; //       return true; }</span></span></code> </pre> <br><p>  Is done.  Go back to sorting the arguments: </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//  for (int i = startingIndex; i &lt; arguments.Count; i++) { //   Convert var cArg = Unconvert(arguments[i]); //      / if (!IsScopedParameterAccess(cArg)) { //   - var lex = Expression.Lambda(cArg); //  var compiled = lex.Compile(); //  var result = compiled.DynamicInvoke(); //     {i},  i -   formatArgs.Add(string.Format("{{{0}}}", sqlParams.Count)); //     SQL- sqlParams.Add(result); //     continue; }</span></span></code> </pre> <br><p>  Fine.  We cut off all the parameters that are guaranteed not to be links to our tables / columns.  The <code>sqlParams</code> list <code>sqlParams</code> be returned later via the <code>out</code> parameter - we will <code>sqlParams</code> it along with the result string to the <code>context.Database.ExecuteSqlCommand</code> second argument.  In the meantime, we will process the links to the tables: </p><br><pre> <code class="cs hljs"> <span class="hljs-comment"><span class="hljs-comment">//   {x},  if (cArg.NodeType == ExpressionType.Parameter) { //     ,    formatArgs.Add(string.Format("[{0}]", context.GetTableName(cArg.Type))) //      continue; }</span></span></code> </pre> <br><p>  Here we will have to cut off the opportunity to turn to the aggregates, because how this will lead to the need to re-collectiveize the query <code>JOIN</code> -ami, which we technically can not do.  So - alas and ah.  If our argument is an access to a member, but not to a member of the expression parameter itself, then jingle, we can do nothing to help: </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> argProp = cArg <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> MemberExpression; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (argProp.Expression.NodeType != ExpressionType.Parameter) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = GetRootMember(argProp); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">",     {0}"</span></span>, root.Type)); }</code> </pre> <br><p>  And finally, we can get our column name and add it to the revised format argument list. </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> colId = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"[{0}]"</span></span>, context.GetColumnName(argProp.Member.DeclaringType, argProp.Member.Name)); formatArgs.Add(colId); <span class="hljs-comment"><span class="hljs-comment">//     - }</span></span></code> </pre> <br><p>  Now that all the arguments have been enumerated, we can finally do the <code>string.Format</code> own and get a SQL string and an array of parameters ready for feeding <code>ExecuteSqlCommand</code> . </p><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sqlString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Format(format, formatArgs.ToArray()); parameters = sqlParams.ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sqlString; }</code> </pre> <br><h3 id="gotovo">  Is done </h3><br><p>  Something like that.  For the article, I intentionally simplified the code.  In particular, the full version automatically substitutes table aliases, normally caches the names of tables and columns, and also contains overloads of <code>.Stroke</code> up to 8 parameters.  You can read the full source code <a href="https://github.com/reinforced/Reinforced.Stroke">on my github</a> .  Behind this, I say goodbye and wish you every success in development. </p><br><p>  Oh, and finally the polls: </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347820/">https://habr.com/ru/post/347820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347806/index.html">20+ resources to start freelancing</a></li>
<li><a href="../347808/index.html">fx - jq alternative for command line JSON processing</a></li>
<li><a href="../347810/index.html">Learning to reliably manage Kubernetes</a></li>
<li><a href="../347812/index.html">For your attention - Webpack 4</a></li>
<li><a href="../347816/index.html">Learning the Spring Framework is 100% through practice. Active Tutorials and KML Markup Language. Project KciTasks (beta)</a></li>
<li><a href="../347822/index.html">Phone Keyboard vs. Keyword Algorithms vs. Protection of personal information</a></li>
<li><a href="../347824/index.html">Actions on Google: Start developing applications for Google Assistant, which will soon be launched in Russia</a></li>
<li><a href="../347826/index.html">Chromium typos</a></li>
<li><a href="../347828/index.html">IOS App Development: Start Your Career</a></li>
<li><a href="../347830/index.html">100 interviews per hour, virtual space and 23 million rubles: the results of the pilots in the MEGA Accelerator 2017</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>