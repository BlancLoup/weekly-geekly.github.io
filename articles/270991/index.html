<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How Badoo generates images for ‚Äúsharing‚Äù in social networks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Social networks are an important source of traffic. It is beneficial for us when users share content, and we give them the opportunity - we have sever...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How Badoo generates images for ‚Äúsharing‚Äù in social networks</h1><div class="post__text post__text-html js-mediator-article">  Social networks are an important source of traffic.  It is beneficial for us when users share content, and we give them the opportunity - we have several types of content that can be shared: <br><br><ul><li>  your profile; </li><li>  someone else's profile (if its owner allowed it); </li><li>  its rating reflecting the popularity of the user on the site; </li><li>  awards received by the user for their actions or the actions of other users. </li></ul><br>  To make the user want to share all this, we generate special images, which we call badges.  Here is an example of a badge that a user can receive: <br><br><img src="https://habrastorage.org/files/2e2/920/d07/2e2920d07e2f499eba28ee18a27e5c7f.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The feature of the badges is that there are photos of the users themselves, so everyone sees and shares unique images.  In this article I will tell you how we generate such images, what problems we faced and how they were solved. <br><a name="habracut"></a><br><h2>  Image generation </h2><br>  We generate images for badges in real time at the request of users or bots from social networks.  We can not cook them in advance, because  This would require a lot of storage space and server resources to generate absolutely all the images that may be needed (but not the fact that they really will be needed). <br>  We took as the basis of the generation scheme the one according to which our photos work, but changed it a little.  From the server‚Äôs point of view, the generation is as follows: <br><br><img src="https://habrastorage.org/files/04b/f49/a5a/04bf49a5af3345568b753519b5dec599.png"><br><br><ol><li>  The HTTP request to generate a badge comes to the Photocache server, the purpose of which is to receive requests, to keep the response cache </li><li>  and thereby reduce the load on the servers that store the photos themselves; </li><li>  nginx on Photocache searches for an image in its cache, and if it is, it gives it to the client.  Here comes the first difference of badges:  there are relatively few requests; the standard nginx cache is used here, rather than a self-written module, as when working with regular photos; </li><li>  If there is nothing in the cache, the request is proxied to Bphotos - the server on which the photos of the user whose badge we generate are stored; </li><li>  nginx to Bphotos sends the request to a PHP script that loads all the necessary resources, starts the generation and gives the finished image.  This is the second difference: nginx gives ordinary user photos without the help of any php scripts; </li><li>  Photocache gives the received badge image to the client and caches it. </li></ol><br>  Each type of badge has its own URL format, in which we include identifiers of user photos and other resources (for example, awards) that are needed for generation;  service parameters that affect the transfer of the request to the correct server;  codes of the language and social network for which this badge is generated. <br><br>  The language code in the URL is very important, because Badoo is a project localized for several languages.  In normal queries, to obtain tokens we use a localization object based on the settings of the current user.  In badges it does not work, because  about a third of requests come from social networking bots, which our system treats as unauthorized users and tries to guess their language by IP address.  At first we didn‚Äôt think about it and it turned out that on our website or in the application the user saw a picture with the text in one language, added it to his facebook and saw it as well, but with the text in English. <br><br>  Social network code is needed, because different social networks have different preferences for image sizes.  For example, for Facebook you need 1200x630 images, and for Instagram - 640x640.  If we know for whom we are generating the image, then we can adapt to the recipient: <br><br><img src="https://habrastorage.org/files/d0f/e7a/87e/d0fe7a87ee534793b2b393ddc75dafc5.png"><br><br>  In addition to all this, we usually leave in the URL a place under the bit mask of modifications, which will be used if some functionality in the generator needs to be included only in some cases.  For example, we used this field when Apple asked not to distribute photos with a rating of users of an iOS application.  Then we added a flag to hide the rating, which allowed, on the one hand, not to quarrel with Apple, and on the other, to keep the existing badge where it is possible.  You can do without this field, but then you have to create a new URL format for each modified version of the badge, which will lead to the growth of these formats and will over time complicate support. <br><br>  From a code point of view, the image generation script looks like this: <br><br><ol><li>  There is a single controller that receives requests from the server, determines the necessary type of badge by the URL format and creates a pair of objects, one of which is the generator that creates the image of the badge, and the second is the data source for the generator. </li><li>  Parameters from URLs are transferred to the source object, by which it understands what resources are needed to create a badge and loads them. </li><li>  The source object is ‚Äúsetted‚Äù into the generator object, which allows the generator to be engaged only in assembling an image from already loaded resources. </li><li>  The controller receives the result of the generator object and returns it with the necessary headers. </li></ol><br>  The structure of data source objects, as a rule, differs greatly depending on the type of badge, and the generator objects have a similar structure, therefore there is an abstract class from which they are inherited.  It looks like this: <br><br><pre><code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AbstractBadgeGenerator</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *      false    * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool|\FastImageEditor */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getImage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;startPinbaTimer(<span class="hljs-string"><span class="hljs-string">'isAvailable'</span></span>); $is_available = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;isAvailable(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;stopPinbaTimer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!$is_available) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;startPinbaTimer(<span class="hljs-string"><span class="hljs-string">'generate'</span></span>); $Result = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;generate(); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;stopPinbaTimer(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $Result; } <span class="hljs-comment"><span class="hljs-comment">/** *  ,       . *   ‚Äî   ,    , *            * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isAvailable</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } <span class="hljs-comment"><span class="hljs-comment">/** *      false,      * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> bool|\FastImageEditor */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    }</span></span></code> </pre> <br>  The most important thing here is the getimage method, which is ‚Äútwitching‚Äù from the controller.  If it does not return the image object, the controller returns an error 404. Calls to the methods for checking availability and assembling the image are overlaid by Pinba-timers, and we substitute the names of specific classes in the names, which gives us information about the time required to generate each type of badge.  In addition, we try to enclose all the manipulations with images in specific generator classes in timers and collect information on the total operating time of the source and generator in the controller, then write it to the database using our statistics collection system (On Habr√©, you can find a <a href="http://habrahabr.ru/company/badoo/blog/238153/">video</a> with its description ). <br><br>  When working with images, we use a very limited number of operations: rotation at an arbitrary angle, resize and crop images, overlay layers (including with transparency) and add text.  To accomplish them, we use the <a href="http://www.leptonica.com/">Leptonica</a> library, the wrapper for which was written by Anton Dovgal (the old version can be found <a href="https://github.com/tony2001/leptonica">on his github</a> ).  It was her chosen a few years ago for the fact that she worked faster than competitors.  To demonstrate this, I did a small GD, ImageMagick and Leptonica benchmarking test. <br><br>  For each of the libraries, I wrote a script that creates a new image of 1000x1000 in size, onto which another image is loaded, loaded from disk (analogue of the resource).  To bring the code closer to what is used when generating badges, I added a few more operations on the loaded image - it will be reduced and rotated.  The result of the manipulations will be saved to disk in JPEG format.  This scenario allows us to estimate the speed of almost all operations that we use when generating badges.  I will not give the code in the article because of its large size, but for those interested I will <a href="https://github.com/pryazhnikov/php-image-processing-tests">post the source code on GitHub</a> . <br><br>  I made 100 consecutive launches of these scripts on our server and got the following results: <br><br><img src="https://habrastorage.org/files/5a2/8aa/867/5a28aa86780b45898a88f326bc187579.png"><br><br>  According to the test results, it turned out that in this scenario, Leptonica was almost twice as fast as GD and Imagemagick, which showed a total time close to each other. <br>  Of course, much more image manipulation is used in the generation of real badges than in this test, so you should not hope that Leptonica works quickly anyway, but try to minimize the number of required operations.  To do this, we try to optimize the preparation of resources, combining as many layers as possible into one image. <br><br><h2>  Testing Generation Results </h2><br>  Gradually, badges became more and more and we wanted to be sure that all badges work correctly after making changes to the code or resources.  To do this, we decided to use functional tests: we created the user's stubs, his photos and awards, formed the badge URLs and passed them to the generator.  The main difficulty was precisely in checking the results.  The obvious way is to compare the image generated in the test with the existing sample ‚Äî we really didn‚Äôt like it, because  He either demanded manual assembly of all possible samples of badges (whose number reached 50) for any change and deprived us of the charms of automation, or did not give a guarantee that all badges work if we took only a part of the options. <br><br>  After some thoughts and experiments, we began to use two simplified types of checks: <br><br><ol><li>  Basic verification of the generation results: we verify that the generator returned exactly the image of the expected size and it contains several colors at the control points; </li><li>  Comparison of several generation results: we generate in the test URL for two badges that are similar to each other in almost everything, but differing only in one parameter (language code, output text, reward, etc.) and we expect that we get two images different from each other.  The difference we define as the presence of a discrepancy in colors in at least one control point. </li></ol><br>  The concept of control points appears in both checks.  Under it, I mean a set of points in the image, obtained by some rule.  Specifically, we divide the image into 10 equal parts horizontally and vertically, with the result that at the intersection of the lines we get 81 control points for which we collect a color map with the help of a similar code: <br><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getImageColorsMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($Image, $color_grid_size = self::COLOR_GRID_SIZE)</span></span></span><span class="hljs-function"> </span></span>{ $image_info = $Image-&gt;getInfo(); $dx = ceil($image_info[<span class="hljs-string"><span class="hljs-string">'width'</span></span>] / $color_grid_size); $dy = ceil($image_info[<span class="hljs-string"><span class="hljs-string">'height'</span></span>] / $color_grid_size); $colors_map = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($row = <span class="hljs-number"><span class="hljs-number">1</span></span>; $row &lt; $color_grid_size; $row++) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> ($cell = <span class="hljs-number"><span class="hljs-number">1</span></span>; $cell &lt; $color_grid_size; $cell++) { $x = $dx * $cell; $y = $dy * $row; $color = $Image-&gt;getOnePixel($x, $y); $colors_map[$color][] = [$x, $y]; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $colors_map; }</code> </pre><br>  The coincidence of all points in the two images does not mean that these images completely coincide, but this is a reason to be alert and either to increase the number of such points or to change the rules for their selection in the case of frequent false positives.  In practice, with 81 points, we have never encountered false positives. <br><br>  Of course, such simple checks do not guarantee that the badges will show exactly what we expect.  But they allow you to quickly check that all the badges work, and helped us catch a number of bugs before they hit production, and some of them were allowed not even in the PHP generation code, but a lower level - in the "sishnoy" image library . <br><br><h2>  Issues with text output </h2><br>  Although the article is devoted to the generation of images, the problems, the solution of which was spent the most time, were associated with texts. <br><br><h4>  Alphabet Definition by Text </h4><br>  We display texts in different languages.  Some languages ‚Äã‚Äãuse alphabets other than Cyrillic and Latin, and not all fonts support them.  Therefore, it is important to understand which alphabet we need for output in order to use the appropriate font.  Where we print predefined lexemes, this is very easy to do - we know the language in which the text is written.  But in some places we display user text (for example, when a person‚Äôs ‚Äúsharing‚Äù on the badge is shown in the Instagram name), we don‚Äôt know what language it is written in. <br><br>  This problem was solved quite easily, because it is possible to find the belonging of a symbol to a group directly <a href="http://www.unicode.org/charts/index.html">on the site unicode.org</a> .  All we had to do was download the tables and reduce the ranges of groups of characters into a single table.  Having such a table, you can check all the characters in a row, get a list of used groups and select a font that supports all these groups of characters. <br><br>  The main thing you need to remember: the codes on the site are given in UCS-4, and not in the usual UTF-8. <br><br><h4>  Fit the text to the designated size </h4><br>  Badges use texts in different languages, and the same phrase in different languages ‚Äã‚Äãwill have different lengths (and therefore require different places).  To fit text sizes we use two algorithms: font size fitting and text splitting into lines. <br><br>  <b>Font size fitting.</b>  We have some ‚Äúperfect‚Äù font size and maximum width that we can use under the text.  We check if the text fits in this width (for example, in GD there are functions imagettfbbox and imageftbbox for this) and if so, we just output the text.  If the text takes up more space, then reduce the font size and repeat the check.  The code that implements the size selection looks like this: <br><br><pre> <code class="php hljs">$font_size = $initial_font_size; $max_x = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ($font_size &gt; $min_font_size) { $text_size = $Image-&gt;getTextBox($font_size, $angle, $font, $text); $max_x = max($text_size[<span class="hljs-number"><span class="hljs-number">2</span></span>], $text_size[<span class="hljs-number"><span class="hljs-number">4</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($max_width &gt;= $max_x) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } $font_size -= <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre><br>  This algorithm is good in its simplicity, but it can be used only for a small variation in the length of the output text.  Larger texts may require a significant reduction in font size, which will make them unreadable.  For such cases, we use split by rows. <br><br>  <b>Splitting by lines</b> works quite simply: we determine the number of characters that can be output, after which we first break the text into words, and then we put the words into strings, each of which does not exceed our maximum number of characters.  Here it must be remembered that there are long words that can be longer than the number of characters in a string (then the font size will need to be applied to the split results), and some languages ‚Äã‚Äãdo not use standard separators (for example, <a href="https://en.wikipedia.org/wiki/Japanese_punctuation">Japanese</a> ). <br><br>  Splitting by strings does not work well when only a few characters do not fit on one line.  As a result of this situation, there is usually one long line and one short, with one or two short words.  To correct this situation, we are trying to split the text into two as close as possible to each other along the length of the line.  To do this, when splitting, we focus not on the maximum length of the line, but on half the actual length of the text.  To solve the problem of long words that break the perfect split, we make two options: from the beginning of the text to the end and from the end of the text to the beginning, and then choose the one that has less discrepancy between the lengths of the lines. <br><br><pre> <code class="php hljs">$len = mb_strlen($text); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($len &lt;= <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;max_line_size) { $ideal_line_len = ceil($len / <span class="hljs-number"><span class="hljs-number">2</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>; $lexems_list = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getTextLexems($text); $direct_order_lines = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getDirectOrderLines($lexems_list, $ideal_line_len); $reversed_order_lines = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getReversedOrderLines($lexems_list, $ideal_line_len); $delta_direct = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getLinesDelta($direct_order_lines); $delta_reversed = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;getLinesDelta($reversed_order_lines); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ($delta_direct &lt; $delta_reversed) ? $direct_order_lines : $reversed_order_lines; }</code> </pre><br>  Funny fact about the texts.  In our experience, most places required lexemes in Greek and Swahili.  Texts in German are usually shorter, but they are difficult to break into lines because of the presence of long words. <br><br><h4>  Right-to-left word processing </h4><br>  Texts that use right-to-left spelling (RTL languages) cannot be displayed as they are - they will be completely unreadable.  This is due to the fact that such languages ‚Äã‚Äãhave two orders of characters: a logical one, which is used during storage, and a visual one, which we see. <br><br>  For the conversion of one order to another, the so-called Unicode Bidirectional Algorithm (abbreviated BIDI) is responsible.  You can learn more about this at <a href="http://habrahabr.ru/post/181123/">habr</a> ( <a href="http://habrahabr.ru/post/181123/">BIDI (unicode bidding algorithm)</a> ), W3C website ( <a href="http://www.w3.org/International/questions/qa-visual-vs-logical">Visual vs. Logical Ordering of Text</a> , <a href="http://www.w3.org/International/articles/inline-bidi-markup/uba-basics">Unicode Bidirectional Algorithm Basics</a> ) and unicode.org ( <a href="http://www.unicode.org/reports/tr9/">Unicode Bidirectional Algorithm</a> ).  Modern clients working with Unicode contain an implementation of this algorithm, and when writing texts on images, you have to take care of this yourself. <br><br>  There are several RTL languages, but our users specifically use only two - Arabic and Hebrew, which in total give slightly less than 1% of the total number of badge generation requests. <br><br>  The problem with Hebrew was solved very quickly: in PHP there is a hebrev function for converting logical text into visual, and the first comment on the page with the documentation of this function <a href="http://php.net/manual/en/function.hebrev.php">shows</a> how to use it for texts in UTF-8: <br><br><pre> <code class="php hljs">$visual_hebrew_text = iconv(<span class="hljs-string"><span class="hljs-string">"ISO-8859-8"</span></span>, <span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>, hebrev(iconv(<span class="hljs-string"><span class="hljs-string">"UTF-8"</span></span>, <span class="hljs-string"><span class="hljs-string">"ISO-8859-8"</span></span>, $logical_hebrew_text)));</code> </pre><br>  With Arabic, everything was more complicated.  We were lucky that our remote Arabic translator had encountered such a problem before and participated in the creation of <a href="http://www.ar-php.org/project-php-arabic.html">the Ar-PHP library</a> .  The library contains a lot of functionality, but the last couple of years have not been very actively developed.  Her site is periodically unavailable, although the code can be found in forks on GitHub: 1, <a href="https://github.com/tawfekov/ar-php">2</a> , <a href="https://github.com/Johntaa/ar-php">3</a> .  In the original version, the text conversion is as follows: <br><br><pre> <code class="php hljs">$ArabicGlyphs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> \I18N_Arabic_Glyphs(); $visual_arabic_text = $ArabicGlyphs-&gt;utf8Glyphs($logical_arabic_text, $max_characters_count);</code> </pre><br>  If the texts are processed in this way, they can be displayed using ordinary functions like imagettftext.  Here is what it will look like: <br><br><img src="https://habrastorage.org/files/ccd/a64/0a9/ccda640a96a3468ca4950f01077e1c71.png"><br><br><ol><li>  In addition to processing, there are a couple of nuances that need to be remembered when working with RTL texts: </li><li>  When outputting text using graphic library functions, the coordinate of the left border of the text is indicated, while in RTL, as a rule, you need to know the right one.  Therefore, before the conclusion itself, it is necessary to first calculate the width of the text and then, knowing it and the coordinate of the right border of the text, it will be possible to calculate the coordinate of the left border. </li><li>  If you display text split into several lines, you must first invert their order.  We break the text from left to right and get an array of strings in which the text on the left is stored in the first element.  For RTL texts, this will be the end, not the beginning, and it turns out that the text is written from the bottom up, which is wrong. </li></ol><br><h3>  Conclusion </h3><br>  Working with images in php is not the most popular topic and it can be difficult to find solutions to problems on the Internet.  I hope that thanks to my article it will become a little easier.  If something in my article seemed incomprehensible to you and you have any questions - ask them in the comments, I will try to answer them. <br><br>  More articles and materials can be found in our TechBadoo <a href="https://tech.badoo.com/">tech blog</a> . <br><br>  <b>Victor Pryazhnikov, Developer, Features</b> </div><p>Source: <a href="https://habr.com/ru/post/270991/">https://habr.com/ru/post/270991/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../270977/index.html">Be in the "working group" from the very beginning</a></li>
<li><a href="../270979/index.html">Automatic calculation of computable properties of view models in .NET</a></li>
<li><a href="../270981/index.html">Better or worse</a></li>
<li><a href="../270985/index.html">MBLTdev Live Broadcast</a></li>
<li><a href="../270989/index.html">Faster, wider, stronger: plans for the development of Bluetooth in 2016</a></li>
<li><a href="../270995/index.html">Outlook Add-Ins or where does 25% of working time go and is it possible to return it?</a></li>
<li><a href="../270999/index.html">Design for Dyslexics, Part Two</a></li>
<li><a href="../271001/index.html">Big data as art</a></li>
<li><a href="../271003/index.html">Pro Parboiled (Part 4 final)</a></li>
<li><a href="../271005/index.html">Cloud Platform Localization: Software Developer's Guide</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>