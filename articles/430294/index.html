<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>10 unobvious benefits of using Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust is a young and ambitious system programming language. It implements automatic memory management without garbage collection and other execution ti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>10 unobvious benefits of using Rust</h1><div class="post__text post__text-html js-mediator-article"><p>  Rust is a young and ambitious system programming language.  It implements automatic memory management without garbage collection and other execution time overhead.  In addition, in the Rust language, the semantics of the default movement is used, there are unprecedented rules for accessing the data being changed, and the lifetimes of the links are also taken into account.  This allows him to guarantee the safety of memory and facilitates multi-threaded programming, due to the lack of data races. </p><br><p><img src="https://habrastorage.org/webt/4q/db/t-/4qdbt-1pfubt4paba4gojjth7zs.jpeg"></p><br><p>  All this is already well known to everyone who is at least a little watching the development of modern programming technologies.  But what if you are not a system programmer, and there is not a lot of multi-threaded code in your projects, but you are still attracted by the performance of Rust.  Will you get any additional benefits from its use in applied tasks?  Or all that he will give you in addition is a bitter struggle with the compiler, which will force you to write a program so that it consistently follows the rules of the language for borrowing and owning? </p><br><p>  This article contains a dozen of unobvious and not particularly advertised advantages of using Rust, which I hope will help you decide on the choice of this language for your projects. </p><a name="habracut"></a><br><h2 id="1-universalnost-yazyka">  1. Universality of language </h2><br><p>  Despite the fact that Rust is positioned as a language for system programming, it is also suitable for solving high-level applied problems.  You do not have to work with raw pointers if this is not necessary for your task.  The standard language library has already implemented most of the types and functions that may be needed in application development.  You can also easily connect external libraries and use them.  The type system and generalized programming in Rust make it possible to use abstractions of a sufficiently high level, although there is no direct support for OOP in the language. </p><br><p>  Let's look at some simple examples of using Rust. </p><br><p>  An example of combining two iterators into one iterator over pairs of elements: </p><br><pre><code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> zipper: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;_&gt; = (<span class="hljs-number"><span class="hljs-number">1</span></span>..).zip(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars()).collect(); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'f'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>((<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">'o'</span></span>), zipper[<span class="hljs-number"><span class="hljs-number">2</span></span>]);</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3Daaad7ce772030a46a77f25e2b55f23cc"><em>Launch</em></a> </p><br><blockquote>  Note: the call of the format <code>name!(...)</code> is a call to the function macro.  The names of such macros in Rust always end with a symbol <code>!</code>  so that they can be distinguished from function names and other identifiers.  The advantages of using macros will be discussed below. </blockquote><p>  An example of using the <a href="https://docs.rs/regex/*/regex/"><code>regex</code></a> external library for working with regular expressions: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> regex; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> regex::Regex; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> re = Regex::new(<span class="hljs-string"><span class="hljs-string">r"^\d{4}-\d{2}-\d{2}$"</span></span>).unwrap(); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(re.is_match(<span class="hljs-string"><span class="hljs-string">"2018-12-06"</span></span>));</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D4dfeba7516eed468efcd4a0f4651055c"><em>Launch</em></a> </p><br><p>  An example of the implementation of the <code>Add</code> type for its own <code>Point</code> structure to overload the addition operator: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::ops::Add; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Add <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> Point { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Output</span></span></span></span> = Point; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, other: Point) -&gt; Point { Point { x: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.x + other.x, y: <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.y + other.y } } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p1 = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p2 = Point { x: <span class="hljs-number"><span class="hljs-number">2</span></span>, y: <span class="hljs-number"><span class="hljs-number">3</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p3 = p1 + p2;</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D8baae4ee6c8a0530b388968ba0e972ea"><em>Launch</em></a> </p><br><p>  An example of using a generic type in a structure: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span>&lt;T&gt; { x: T, y: T, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> int_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> float_origin = Point { x: <span class="hljs-number"><span class="hljs-number">0.0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0.0</span></span> };</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D3d2523301614291336352d4eaa1b9b6a"><em>Launch</em></a> </p><br><p>  On Rust, you can write effective system utilities, large desktop applications, microservices, web applications (including the client part, since Rust can be compiled into Wasm), mobile applications (although the ecosystem of the language is poorly developed in this direction).  Such versatility can be an advantage for multi-project teams, because it allows the use of the same approaches and the same modules in many different projects.  If you are accustomed to the fact that each tool is designed for its narrow scope, then try to look at Rust as a box with tools of the same reliability and convenience.  Perhaps this is what you lacked. </p><br><h2 id="2-udobnye-instrumenty-sborki-i-upravleniya-zavisimostyami">  2. Convenient build and dependency management tools </h2><br><p>  This is clearly not advertised, but many notice that Rust implements one of the best build and dependency management systems available today.  If you programmed in C or C ++, and the issue of using the external libraries painlessly was acute for you, using Rust with its build tool and Cargo dependency manager would be a good choice for your new projects. </p><br><p>  Besides the fact that Cargo will download dependencies for you and manage their versions, build and run your applications, run tests and generate documentation, in addition it can be extended with plugins for other useful functions.  For example, there are extensions that allow Cargo to identify outdated dependencies of your project, perform static analysis of source code, build and redefine client parts of web applications, and more. </p><br><p>  The Cargo configuration file uses the friendly and minimalist markup language toml to describe the project settings.  Here is an example of a typical <code>Cargo.toml</code> configuration <code>Cargo.toml</code> : </p><br><pre> <code class="plaintext hljs">[package] name = "some_app" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] [dependencies] regex = "1.0" chrono = "0.4" [dev-dependencies] rand = "*"</code> </pre> <br><p>  And below are three typical commands for using Cargo: </p><br><pre> <code class="plaintext hljs">$ cargo check $ cargo test $ cargo run</code> </pre> <br><p>  They will be used to check source code for compilation errors, build the project and run tests, build and run the program, respectively. </p><br><h2 id="3-vstroennye-testy">  3. Built-in tests </h2><br><p>  It is so easy and simple to write unit tests in Rust that you want to do it again and again.  :) Often it will be easier for you to write a unit test than to try to test the functionality in another way.  Here is an example of the functions and tests for them: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { !a } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { a + <span class="hljs-number"><span class="hljs-number">2</span></span> } <span class="hljs-meta"><span class="hljs-meta">#[cfg(test)]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> test { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> super::*; <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_false_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(is_false(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(!is_false(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); } <span class="hljs-meta"><span class="hljs-meta">#[test]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_two_works</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>, add_two(-<span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">0</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>, add_two(<span class="hljs-number"><span class="hljs-number">2</span></span>)); } }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D40b983dd13fec95d33ec7217915c50c7"><em>Launch</em></a> </p><br><p>  Functions in the <code>test</code> module, labeled with the <code>#[test]</code> attribute, are unit tests.  They will be executed in parallel when you call the <code>cargo test</code> command.  The conditional compilation attribute <code>#[cfg(test)]</code> , which marks the entire module with tests, will result in the module being compiled only when executing the tests, and will not fall into the normal assembly. </p><br><p>  It is very convenient to place the tests in the same module as the tested functionality, simply by adding the <code>test</code> submodule to it.  And if you need integration tests, then simply place your tests in the <code>tests</code> directory in the project root, and use your application in them as an external package.  A separate <code>test</code> module and conditional compilation directives in this case do not need to be added. </p><br><p>  The examples of documentation executed as tests deserve special attention, but this will be discussed below. </p><br><p>  Built-in performance tests (benchmarks) are also available, but they are not yet stabilized, so they are only available in the compiler‚Äôs nightly builds.  In stable Rust for this type of testing will have to use external libraries. </p><br><h2 id="4-horoshaya-dokumentaciya-s-aktualnymi-primerami">  4. Good documentation with current examples. </h2><br><p>  The standard Rust library is very well documented.  Html documentation is automatically generated from source code with markdown descriptions in doc comments.  Moreover, the dock comments in the Rust code contain code examples that are executed during the test run.  This guarantees the relevance of the examples: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">/// Returns a byte slice of this `String`'s contents. /// /// The inverse of this method is [`from_utf8`]. /// /// [`from_utf8`]: #method.from_utf8 /// /// # Examples /// /// Basic usage: /// /// ``` /// let s = String::from("hello"); /// /// assert_eq!(&amp;[104, 101, 108, 108, 111], s.as_bytes()); /// ``` #[inline] #[stable(feature = "rust1", since = "1.0.0")] pub fn as_bytes(&amp;self) -&gt; &amp;[u8] { &amp;self.vec }</span></span></code> </pre> <br><p>  <a href="https://doc.rust-lang.org/std/string/struct.String.html"><em>Documentation</em></a> </p><br><p>  Here is an example of using the <code>as_bytes</code> method of the <code>String</code> type. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> s = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>::from(<span class="hljs-string"><span class="hljs-string">"hello"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">assert_eq!</span></span>(&amp;[<span class="hljs-number"><span class="hljs-number">104</span></span>, <span class="hljs-number"><span class="hljs-number">101</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">108</span></span>, <span class="hljs-number"><span class="hljs-number">111</span></span>], s.as_bytes());</code> </pre> <br><p>  will be executed as a test during the test run. </p><br><p>  In addition, for Rust libraries, it is common practice to create examples of their use in the form of small independent programs located in the <code>examples</code> directory at the root of the project.  These examples are also an important part of the documentation and they are also compiled and executed during the test run, but they can be run independently of the tests. </p><br><h2 id="5-umnoe-avtovyvedenie-tipov">  5. Smart type autocast </h2><br><p>  In the Rust program, you can not explicitly specify the type of expression if the compiler is able to output it automatically, based on the context of use.  And this applies not only to those places where variables are declared.  Let's look at this example: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D4173c8504b7333eee1554ec6fe4bc4b4"><em>Launch</em></a> </p><br><p>  If we arrange the type annotations, this example will look like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> vec: <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>&lt;&amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>&gt; = <span class="hljs-built_in"><span class="hljs-built_in">Vec</span></span>::new(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span> = <span class="hljs-string"><span class="hljs-string">"Message"</span></span>; vec.push(text);</code> </pre> <br><p>  That is, we have a vector of string slices and a variable of type string slice.  But in this case, it is completely unnecessary to specify the types, since the compiler can output them himself (using the extended version of the <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D0%25B2%25D0%25BE%25D0%25B4_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25BE%25D0%25B2">Hindley ‚Äì Milner</a> algorithm).  The fact that <code>vec</code> is a vector is already clear from the type of the return value from <code>Vec::new()</code> , but it is not yet clear what the type of its elements will be.  The fact that the type <code>text</code> is a string slice is understandable by the fact that it is assigned a literal of this type.  Thus, after <code>vec.push(text)</code> , the type of vector elements becomes obvious.  Note that the type of the <code>vec</code> variable was fully determined by its use in the execution thread, and not during the initialization phase. </p><br><p>  Such a type auto-derivation system eliminates code noise and makes it as concise as any code in a dynamically typed programming language.  And this while maintaining strict static typing! </p><br><p>  Of course, we cannot completely get rid of specifying types in a statically typed language.  The program must have points at which the types of objects are guaranteed to be known, so that in other places these types can be displayed.  Such points in Rust are declarations of user-defined data types and function signatures, in which the types used cannot be indicated.  But you can enter "metavariable types" in them, when using generic programming. </p><br><h2 id="6-sopostavlenie-s-obrazcom-v-mestah-obyavleniya-peremennyh">  6. Pattern matching in variable declaration spaces. </h2><br><p>  <code>let</code> operation </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> p = Point::new();</code> </pre> <br><p>  in fact, it is not limited to declaring new variables.  What she actually does is to match the expression to the right of the equal sign with the sample to the left.  And new variables can be introduced in the sample (and only this way).  Take a look at the following example, and it will become clearer to you: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Point { x, y } = Point::new();</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3Dfece8eeb94cec08d82e8d3329fe52e68"><em>Launch</em></a> </p><br><p>  This is where the restructuring is done: such a mapping will introduce the variables <code>x</code> and <code>y</code> , which will be initialized by the value of the <code>x</code> and <code>y</code> fields of the object of the <code>Point</code> structure, which is returned by calling <code>Point::new()</code> .  In this case, the mapping is correct, since the type of the expression on the right <code>Point</code> corresponds to the type of <code>Point</code> on the left.  Similarly, you can take, for example, the first two elements of an array: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [a, b, _] = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br><p>  And do a lot more.  The most remarkable thing is that such comparisons are made in all places where new variable names can be entered in Rust, namely: in the <code>match</code> , <code>let</code> , <code>if let</code> , <code>while let</code> operators, in the <code>for</code> loop header, in the arguments of functions and closures.  Here is an example of the elegant use of pattern matching in a <code>for</code> loop: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i, ch) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">"foo"</span></span>.chars().enumerate() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Index: {}, char: {}"</span></span>, i, ch); }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D235de879d710ebfaf727435f8faa8808"><em>Launch</em></a> </p><br><p>  The <code>enumerate</code> method, called by the iterator, constructs a new iterator that will iterate through not the initial values, but the tuples, the "ordinal index, initial value" pairs.  During iterations of the cycle, each of these tuples will be matched with the specified sample <code>(i, ch)</code> , as a result of which the variable <code>i</code> will receive the first value from the tuple ‚Äî the index, and the variable <code>ch</code> ‚Äî the second, that is, the character of the string.  Later in the body of the loop, we can use these variables. </p><br><p>  Another popular example of using a sample in a <code>for</code> loop is: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   5  }</span></span></code> </pre> <br><p>  Here we just ignore the iterator value using the <code>_</code> pattern.  Because we do not use the iteration number in the loop body.  The same can be done, for example, with a function argument: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(a: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, _: <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//      }</span></span></code> </pre> <br><p>  Or when matching in the <code>match</code> statement: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> p { Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x == 1 detected"</span></span>), Point { y: <span class="hljs-number"><span class="hljs-number">2</span></span>, .. } =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Point with x != 1 and y == 2 detected"</span></span>), _ =&gt; (), <span class="hljs-comment"><span class="hljs-comment">//        }</span></span></code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D8fb1b52ff1be40427041e756f061b5d0"><em>Launch</em></a> </p><br><p>  Pattern matching makes the code very compact and expressive, and in the <code>match</code> statement it is generally indispensable.  The <code>match</code> operator is a full variable analysis operator, so you will not be able to accidentally forget to check one of the possible matches for the analyzed expression. </p><br><h2 id="7-rasshirenie-sintaksisa-i-polzovatelskie-dsl">  7. Syntax Extension and User DSL </h2><br><p>  The syntax of the Rust language is limited, largely due to the complexity of the type system used in the language.  For example, in Rust there are no named arguments of functions and functions with a variable number of arguments.  But you can get around these and other limitations with macros.  There are two types of macros in Rust: declarative and procedural.  With declarative macros, you will never have the same problems as with macros in C, because they are hygienic and work not at the level of textual substitution, but at the level of substitution in an abstract syntax tree.  Macros allow you to create abstractions at the level of syntax of the language.  For example: </p><br><pre> <code class="rust hljs"><span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello, {name}! Do you know about {}?"</span></span>, <span class="hljs-number"><span class="hljs-number">42</span></span>, name = <span class="hljs-string"><span class="hljs-string">"User"</span></span>);</code> </pre> <br><p>  In addition to the fact that this macro expands the syntactic possibilities of calling the ‚Äúfunction‚Äù of printing a formatted string, it will also, in its implementation, check whether the input arguments match the specified format string at compile time, not at run time.  Using macros, you can enter a concise syntax for your own design needs, create and use DSL.  Here is an example of using JavaScript code inside a Rust program compiled in Wasm: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = js! { var msg = <span class="hljs-string"><span class="hljs-string">"Hello from JS, "</span></span> + @{name} + <span class="hljs-string"><span class="hljs-string">"!"</span></span>; console.log(msg); alert(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>; }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"2 + 2 = {:?}"</span></span>, result);</code> </pre> <br><p>  Macro <code>js!</code>  is defined in the <a href="https://docs.rs/stdweb/*/stdweb/"><code>stdweb</code></a> package and it allows you to embed full JavaScript code into your program (with the exception of strings in single quotes and operators that are not terminated by a semicolon) and use Rust code objects in it using the <code>@{expr}</code> syntax. </p><br><p>  Macros offer tremendous opportunities to adapt the syntax of Rust programs to the specific tasks of a specific subject area.  They will save your time and attention when developing complex applications.  Not by increasing the runtime overhead, but by increasing the compile time.  :) </p><br><h2 id="8-avtogeneraciya-zavisimogo-koda">  8. Auto-generation of the dependent code </h2><br><p>  Procedural derive macros in Rust are widely used for automatic implementation of types and other code generation.  Here is an example: </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, }</code> </pre> <br><p>  Since all these types ( <code>Copy</code> , <code>Clone</code> , <code>Debug</code> , <code>Default</code> , <code>PartialEq</code> and <code>Eq</code> ) from the standard library are implemented for the field type of the <code>i32</code> structure, then for the entire structure as a whole, their implementation can be derived automatically.  Another example: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_derive; <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">crate</span></span> serde_json; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> serde_derive::{Serialize, Deserialize}; <span class="hljs-meta"><span class="hljs-meta">#[derive(Serialize, Deserialize)]</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Point</span></span></span></span> { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> point = Point { x: <span class="hljs-number"><span class="hljs-number">1</span></span>, y: <span class="hljs-number"><span class="hljs-number">2</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//  Point  JSON . let serialized = serde_json::to_string(&amp;point).unwrap(); assert_eq!("{\"x\":1,\"y\":2}", serialized); //  JSON   Point. let deserialized: Point = serde_json::from_str(&amp;serialized).unwrap();</span></span></code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D3a4b24e9600f46c71672c93a04766fdf"><em>Launch</em></a> </p><br><p>  Here, using the <code>Serialize</code> and <code>Deserialize</code> derive macros from the <a href="https://docs.rs/serde/*/serde/"><code>serde</code></a> library for the <code>Point</code> structure, methods for its serialization and deserialization are automatically generated.  Then you can transfer an instance of this structure to various serialization functions, for example, converting it to a JSON string. </p><br><p>  You can create your own procedural macros that will generate the code you need.  Or use the many already created macros by other developers.  In addition to saving the programmer from writing the template code, macros have the advantage that you do not need to maintain different parts of the code in a consistent state.  For example, if a third field <code>z</code> is added to the <code>Point</code> structure, then to ensure its correct serialization, if you derive, you don‚Äôt need to do anything more.  If we ourselves implement the necessary types for serialization of <code>Point</code> , then we will have to ensure that this implementation is always consistent with the latest changes in the <code>Point</code> structure. </p><br><h2 id="9-algebraicheskiy-tip-dannyh">  9. Algebraic data type </h2><br><p>  The algebraic data type, to put it simply, is a composite data type that is a union of structures.  More formally, this is a type-sum of product types.  In Rust, this type is defined using the <code>enum</code> keyword: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Message</span></span></span></span> { Quit, ChangeColor(<span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>), Move { x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> }, Write(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>), }</code> </pre> <br><p>  The type of a specific value of a variable of the <code>Message</code> type can only be one of the structure types listed in the <code>Message</code> .  This is either a unit-like <code>Quit</code> borderless structure, or one of the <code>ChangeColor</code> or <code>Write</code> tuple structures with unnamed fields, or the usual <code>Move</code> structure.  A traditional enumerated type can be represented as a special case of an algebraic data type: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span></span> { Red, Green, Blue, White, Black, Unknown, }</code> </pre> <br><p>  It is possible to figure out which type really took a value in a specific case using pattern matching: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color: Color = get_color(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> color { Color::Red =&gt; <span class="hljs-string"><span class="hljs-string">"Red"</span></span>, Color::Green =&gt; <span class="hljs-string"><span class="hljs-string">"Green"</span></span>, Color::Blue =&gt; <span class="hljs-string"><span class="hljs-string">"Blue"</span></span>, _ =&gt; <span class="hljs-string"><span class="hljs-string">"Other color"</span></span>, }; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, text); ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_message</span></span></span></span>(msg: Message) { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> msg { Message::Quit =&gt; quit(), Message::ChangeColor(r, g, b) =&gt; change_color(r, g, b), Message::Move { x, y } =&gt; move_cursor(x, y), Message::Write(s) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, s), }; }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3D991050b17837dc9500f4598e5e21d34e"><em>Launch</em></a> </p><br><p>  In the form of algebraic data types, Rust implements such important types as <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> and <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> , which are used to represent the missing value and the correct / erroneous result, respectively.  Here is how <code>Option</code> is defined in the standard library: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Option</span></span></span></span>&lt;T&gt; { <span class="hljs-literal"><span class="hljs-literal">None</span></span>, <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(T), }</code> </pre> <br><p>  In Rust, there is no null-value, exactly like the annoying errors of unexpected access to it.  Instead, where it is really necessary to indicate the possibility of missing a value, <code>Option</code> used: </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">divide</span></span></span></span>(numerator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>, denominator: <span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">Option</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">f64</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> denominator == <span class="hljs-number"><span class="hljs-number">0.0</span></span> { <span class="hljs-literal"><span class="hljs-literal">None</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(numerator / denominator) } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = divide(<span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> result { <span class="hljs-literal"><span class="hljs-literal">Some</span></span>(x) =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Result: {}"</span></span>, x), <span class="hljs-literal"><span class="hljs-literal">None</span></span> =&gt; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot divide by 0"</span></span>), }</code> </pre> <br><p>  <a href="https://play.rust-lang.org/%3Fversion%3Dstable%26mode%3Ddebug%26edition%3D2015%26gist%3Db165d1d1d5b59c09098a62dfa6231492"><em>Launch</em></a> </p><br><p>  The algebraic data type is quite a powerful and expressive tool that opens the door to Type-Driven Development.  A competently written program in this paradigm imposes on the type system most of the checks on the correctness of its work.  Therefore, if you lack some Haskell in everyday industrial programming, Rust can be your outlet.  :) </p><br><h2 id="10-legkiy-refaktoring">  10. Easy refactoring </h2><br><p>  Developed a strict static type system in Rust and an attempt to perform as many checks as possible during compilation, leads to the fact that modifying and refactoring the code becomes quite simple and safe.  If, after the changes, the program is assembled, it means that only logical errors remain in it that are not related to the functionality, the check of which was assigned to the compiler.  Combined with the ease of adding unit tests to verify the logic, this leads to serious guarantees for the reliability of programs and an increase in programmer's confidence in the correct operation of his code after making changes. </p><br><hr><br><p>  Perhaps this is all I wanted to talk about in this article.  Of course, Rust has many other advantages, and there are a number of drawbacks (some dampness of the language, lack of the usual programming idioms, "non-literary" syntax), which are not mentioned here.  If you have something to tell about them - write in the comments.  In general, try Rust in practice.  And maybe his merits for you will outweigh all his faults, as happened in my case.  And you finally get exactly the set of tools that you have needed for a long time. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/430294/">https://habr.com/ru/post/430294/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../430282/index.html">9 out of 10 people agree to earn less on more meaningful work</a></li>
<li><a href="../430284/index.html">The digest of interesting materials for the mobile # 275 developer (November 12 - 18)</a></li>
<li><a href="../430286/index.html">Details of the promiscuous and dark side of pirated games for the Nintendo Switch</a></li>
<li><a href="../430290/index.html">Attempt to predict the fourth iteration of the SpaceX BFR project</a></li>
<li><a href="../430292/index.html">Electronic Frontier Foundation: network performance of police car license scanners in the US - 0.5%</a></li>
<li><a href="../430296/index.html">Make your ideas come app. Serverless application - step by step instructions</a></li>
<li><a href="../430300/index.html">Microservices on Go with the Go kit: Introduction</a></li>
<li><a href="../430302/index.html">Introduction to ptrace or code injection in sshd for fun</a></li>
<li><a href="../430304/index.html">Wonderful outpost in orbit</a></li>
<li><a href="../430306/index.html">Drilled the first tunnel Boring Company Ilona Mask</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>