<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Key transparency & Coniks to protect data structures</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alexey Ermishkin ( Scratch ) 


 Before, I would like to explain a little bit about my attitude to the blockchain topic. I really love blockchain tech...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Key transparency & Coniks to protect data structures</h1><div class="post__text post__text-html js-mediator-article"><h2>  Alexey Ermishkin ( <a href="https://habrahabr.ru/users/scratch/" class="user_link">Scratch</a> ) </h2><br><img src="https://habrastorage.org/webt/3t/wd/hs/3twdhs7xzx8npm5othezg8hyl3c.jpeg"><br><br>  Before, I would like to explain a little bit about my attitude to the blockchain topic.  I really love blockchain technology, recently everything that revolves around - SEO, cryptocurrency, smart contracts - everything is fine and excellent, but this is not all that a blockchain can do, and this is not all of its philosophy. <br><br>  <strong>Blockchain is not only smart contracts and cryptocurrencies</strong> , which generally began to be reduced to the word "crypto".  For me, as a cryptographer, this is especially hard on the ears. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <strong>Blockchain - not necessarily distributed systems.</strong>  If you look at the definition of the word "Blockchain", this is a distributed database with consensus and everything else.  No, it is absolutely not. <br><br>  <strong>Blockchain technology existed 4 years before Bitcoin</strong> .  You probably also use it, but do not realize that this is a blockchain.  This is <strong>Git</strong> , and I will prove it very easily. <br><a name="habracut"></a><br>  Below we present to your attention the decoding of the report by Alexey Ermishkin ( <a href="https://habrahabr.ru/users/scratch/" class="user_link">Scratch</a> ) on the <strong>use of the blockchain, as a mathematical concept, for organizing a database with control of the integrity of the content</strong> . <br><br>  The topic of this article we consider the example of communication between traditional Alice and Bob.  In this case, these are not people, but robots, because when they want to communicate via a secure channel, for example, some sensors or small devices, they have far fewer opportunities to fully use everything that is already written for people for example, TLS certificates, SSH, VPN and everything else. <br><br>  So Alice wants to talk to Bob.  Unfortunately, she only knows his name or some kind of identifier, for example, mail or phone.  To enable it to obtain its public key, a key server is used.  But storing keys in a simple key-value-storage is absolutely insecure, since they can be removed from there, replaced or returned to the existing key answer 404, as if it is not there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/04d/dcd/ff7/04ddcdff71f5c70cd446214fbd49dad0.jpg"><br><br>  Therefore, the server must have several very important and unique properties: <br><br><h4>  1. Presence / absence of a key </h4><br>  The server, of course, must be able to return the keys that are in it, but in addition to this, it must strictly prove that there is no key in it.  Until today, this task has not been solved by anyone. <br><br><h4>  2. Key history </h4><br>  Bob and Alice should be able to track the history of the keys.  That is, when Bob changes his key to a new one, he has to make sure that, over time, no one did anything with his keys: he did not replace, did not delete. <br><br><h4>  3. One result for all </h4><br>  Alice and Bob should see the same state in which the database is located.  A malicious server (if it is one) can show one key history to Bob, and Alice a completely different one, which will have a completely different key.  This is completely unacceptable from a security point of view. <br><br><h4>  4. Obfuscation of Identity </h4><br>  And the last, though not the most important thing, we want hackers and just people who look at it from outside, for example, auditors, could not know anything about whose identifiers and what data lie in the database.  But at the same time, the server is obliged to strictly prove everything to customers who use its services. <br><br>  Of course, after Alice and Bob learned each other‚Äôs keys, a secure communication protocol is needed.  Today, if you only have public keys, you are left alone.  You will have to write some crutches.  They are good and bad, but most often people write them themselves. <br><br><h2>  Blockchain </h2><br>  Let us return to the blockchain topic, so the blockchain existed 4 years before the advent of Bitcoin. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f5c/742/ab4/f5c742ab440dcfb3e650be3557567d72.jpg"><br><br>  If you look at how git works and the commit tree, you can clearly see that each commit is, in principle, a block.  It has a hash link to the previous commit.  Please, here is the <strong>Block</strong> and here is the <strong>chain</strong> ! <br><br>  For example, if we talk about smart contracts, then <strong>Git Hooks</strong> is their prototype, that is, it is the logic that works in the blockchain and influences how it is formed.  Enthusiasts even wrote a comic cryptocurrency - <strong>gitcoin</strong> .  This is just a git repository with Git Hooks, which adds coins to someone who launches a commit whose hash is smaller than the hash of a previous commit ‚Äî a sort of proof-of-work a la Bitcoin. <br><br>  Thus, for me, the blockchain is more of a mathematical concept: <strong>a database, not necessarily distributed, but necessarily c monitoring the integrity of the content.</strong> <br><br><h2>  Key transparency &amp; Coniks </h2><br>  Today we will talk about the technology that was born at the junction of the other two, Coniks and Certificate transparency. <br><br>  <strong>Coniks</strong> is an academic project by researchers from Princeton and Stanford who have decided to help people safely store, in particular, public keys (and not only). <br><br>  Then Google took a closer look at this project, and at the stage of a not very realized concept, he forked and crossed with his technology <strong>Certificate transparency</strong> , which is a large log containing all the certificates ever issued so that some employee could The certification authority would not issue a test certificate for the Google.com domain. <br><br>  These technologies solve the problem of secure storage of public keys, which are tied to user IDs, but in addition to public keys, you can actually store anything. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/781/7ef/732/7817ef732afc93ed9d648b603913d842.jpg"><br><br><h2>  Merkle tree </h2><br>  Next, let's talk about a single algorithmic structure, about which those who are already familiar with the blockchain, have probably heard - this is the Merkle tree.  Of course, this structure has nothing to do with the German Chancellor.  Ralph Merkle is a mathematician. <br><br>  Few people know that the popular Diffie-Hellman public key exchange protocol actually has a full name ‚Äî the Diffie-Hellman-Merkle protocol.  Merkle came up with the whole theoretical basis for him, and Diffie and Hellman wrote a practical implementation.  The protocol is named after them, but they themselves say that this is still the Diffie-Hellman-Merkle protocol. <br><br><h3>  What did Merkle come up with? </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/b45/8e6/3d1/b458e63d1933c68b15cf349a8d4bb2b9.jpg"><br><br>  For example, there is an array of transactions (files).  Each of these files (here 16) are considered hashes.  Then they are taken in pairs and each pair is once again considered hashes.  This is repeated until one hash is obtained, which is called the root of the tree and depends on all the hashes that were below. <br><br>  This structure is remarkable in that in order to prove that a file is in this tree, you need only 4 intermediate hashes (blue blocks in the diagram).  When we provide them to the client, he hashes them in pairs in pairs and as a result gets the same root.  This root usually lies in the block header, and all transactions together with the tree can be located, in principle, separately. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1c1/74b/773/1c174b77391b3fbd747e8165564198df.jpg"><br><br>  Another great feature of this tree is that, no matter how large, the root (since this is a hash) is always the same size.  If the hash is 256 bits, the root will always be 32 bytes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e9/915/d70/3e9915d70c16458d009876e5705e8904.jpg"><br><br>  Therefore, most often light Bitcoin nodes or some other blockchain simply exchange trees.  This is enough to trace the integrity of the blocks.  If you need any specific transaction from the block, you need to download this block entirely and check if it is there, such a tree works fine to prove that there is something in it. <br><br><h4>  But what would we think of to prove the absence? </h4><br>  Let's expand our consciousness a bit and imagine that the tree contains all possible hashes from zero to the very last, consisting of all binary ones. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b97/c70/ee5/b97c70ee5774e10eac446cf304d140d0.jpg"><br><br>  If the hash is 256 bits, then all the hashes from 0 to 2,256-1 are in the tree. This is such a large number that I think that not a single person, even engaged in HighLoad, is able to cheat such a tree.  What to do, how to use it. <br><br><h3>  Sparse Merkle Tree </h3><br>  In fact, almost all the leaves of such a tree will be empty, that is, nothing will lie in them.  Level 2 hashes will most often be two-0 hashes, level-3 hashes will be two hashes from two 0 hashes. Such a tree can be emulated, despite its huge size, and only those parts that really contain data are used. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/82b/8bf/699/82b8bf699f0a904b248a3dd6dd1d1c35.jpg"><br><br><h3>  Presence / absence of a key </h3><br>  As shown in the diagram, parts that are not used are simply not stored.  Instead of nodes that are empty parts of the tree, a stub is put ‚Äî for example, a node marked as empty.  When we reach it, we understand that there is nothing there.  Since this is a balanced binary tree, and places for all hashes are reserved in it, the path to each hash will be that same hash.  For example, the first bit 1 - we go to the left, 0 - to the right, etc. <br><br>  The fact that the path to each hash is the hash itself makes it possible to strictly prove not only the presence but also the absence of information in the database.  We can provide a path to the nearest empty node, and say: ‚ÄúWe have such a path and such a root of the tree, there is nothing further - you can check everything!‚Äù This will be strict evidence of the absence of information in this node. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fe6/3ea/78d/fe63ea78d0dce3ad680cb14457b27ee9.jpg"><br><br>  Since the tree is huge, but at the same time there is nothing in it, it is called a discharged Merkle tree and, as we have said, allows us to prove the presence and absence of information in the database.  <strong>Now it‚Äôs just not fair to answer 404 to a public key request!</strong> <br><br>  You can put some information into this tree and work with it over time.  <strong>The blockchain will help us with this, of course</strong> . <br><br><h3>  Key history </h3><br>  Let's break time into epochs.  For example, once every 5 minutes we will: <br><br><ul><li>  collect all the changes that users want to make to this tree, </li><li>  apply them, re-counting the root of the tree, </li><li>  sign this root and previous. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/1ce/169/d9c/1ce169d9c47431cb2c667e2516c8cb16.jpg"><br><br>  We get the same blockchain, it's just not based on a lot of blocks, each of which has a small tree, but on one big Merkle tree.  This allows you to build a key history that cannot be retroactively changed. <br><br><h3>  One result at all </h3><br>  Now we need to make sure that Alice and Bob see the same thing, i.e.  so that the server does not provide different stories to different users.  Make it very easy.  First, you can get third-party auditors who would check the base.  The database contains impersonal data, so there are no problems with it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f7/b99/ed9/0f7b99ed999d409a27e8cd7961c07768.jpg"><br><br>  But you can also use public blockchains and, for example, simply put hashs from each epoch into the same Bitcoin, Ethereum, etc.  The epoch behind the epoch we will put them there.  This technology is called <strong>anchorage</strong> (anchoring). <br><br>  We provide Alice with proof that at time X we had such a tree.  She checks his hash in a public blockchain, and makes sure that everything is fine.  And we achieve that all users at any time see the same thing. <br><br><h3>  Obfuscation Identity </h3><br>  We need not only to prove that everyone sees everything the same, but we also need to protect the user data that lies in our database.  First of all, we protect the public keys themselves. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/860/7a3/65b/8607a365b97cecca76f2e2d3eb6365d3.jpg"><br><br>  When Bob puts a key into the database, we add it to a random set of bytes, run it through a hash, and what happens is called an <strong>add-on</strong> (or commitment).  It lies in a tree, and when someone asks us to prove that the structure of the tree is properly built, we provide him with this addition. <br><br>  But when Alice asks us for the data of Bob, we show her the ‚Äúrandom salt‚Äù, give the public key, she performs the same operations and makes sure that the place where the key lies in the database contains exactly what Bob put there, not someone else. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/a82/47f/7c1a8247f5dc674ba036e4bc611a2acc.jpg"><br><br>  So, if someone cunning looks at this base and decides to find out what lies there, he will not see anything. <br><br>  But this is not all, we must be able to hide the very name of Bob from the base.  We can‚Äôt do this simply with the help of hashing, because every student can go through usernames with brute force.  Therefore, they invented such a wonderful thing as the <strong>Verifiable Random Function</strong> . <br><br>  Alice asks the server: <br><br><blockquote>  - Give me, please, the key of Bob, and tell me what index you put in this tree. <br><br>  The server responds to it with some kind of absolute rubbish, from which Alice‚Äôs hair stands on end: <br><br>  - What did you give me, server?  How can you even say that? <br><br>  - All OK!  Here is my proof! <br></blockquote><br><img src="https://habrastorage.org/getpro/habr/post_images/7af/d7b/81b/7afd7b81beaede19f3a0c4c0c4e958e1.jpg"><br><br>  In essence, the server reads a digital signature on Bob‚Äôs name.  But this is not an ordinary digital signature that we use every day, but <strong>deterministic</strong> .  If you take any OpenSSL or crypto library and read the digital signature from any line 10 times, we get 10 different digital signatures.  Here it is always the same.  There are still a few added elements, but in principle it works that way. <br><br>  Then the hash of this digital signature is used as an index in the tree for Bob.  Thus, without having a private key, we don‚Äôt have a theoretical possibility at all (except the one that asymmetric cryptography is ever cracked) to find out whose name is on this index. <br><br>  We can even at each iteration (for each epoch) add simply random, absolutely random hashes to the database and thus hide the true number of users that are in the database.  Of course, the one who watches the database will know the maximum number, but it will be impossible to know exactly how many users came, and which of them changed which data. <br><br>  Thus, Alice is happy, and Bob is safe, and we have learned how to protect the user data that we have in the database. <br><br>  This key server is already there.  You can download it by requesting <strong>Key transparency</strong> in GitHub Google.  Of course, it is still in the ‚ÄúProof of concept‚Äù stage, but this is already a working version.  We are already starting to use it for storing users' public keys. <br><br><h3>  Summary </h3><br>  Key Transparency and Coniks allow you to: <br><br><ul><li>  Prove <strong>both the presence and absence of</strong> records in the database. </li><li>  <strong>Monitor the integrity of information</strong> to account holders and their interlocutors. </li><li>  <strong>Hide data</strong> using Verifiable Random Function. </li><li>  <strong>Audit third parties</strong> without compromising user data. </li><li>  Unlike traditional blockchains, they have a very <strong>small proof size</strong> . </li></ul><br>  The maximum audit path, consisting of the hashes needed to prove the presence of an element in the tree, is 256 hashes.  This is a couple of kilobytes, in contrast to those 150-200 GB that need to be downloaded in Bitcoin in order to make sure that the transaction is in such and such a block. <br><br>  <strong>I think this is a truly unique thing that is worth exploring, developing and, of course, enjoying.</strong> <br><br>  True, as I said, today everyone who has to work with clean private public keys has to write his crutches.  Therefore, when WhatsApp rolled out its cryptography update, they, in addition to the messaging protocol, also implemented the protocol for the transport layer called Noise.  We liked it very much, and we made an add-on over the Noise Protocol framework, which we called NoiseSocket.  We will probably talk about it in future reports and articles. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0f/61c/62d/d0f61c62d13b42276eb81cb48b3c8723.jpg"><br><h2>  <em>About the speaker and his team</em> </h2><br>  <em>Alexey Ermishkin represents the company Virgil Security, which develops cryptographic solutions for developers and businesses, in particular, on an industrial scale implements E2E encryption.</em>  <em>This is point-to-point encryption, when the sender knows the recipient's public key in advance, and in their opinion, this is the only correct way to ensure the security of the transmitted data.</em> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d0b/20e/1f8/d0b20e1f8c86480aa29ef649c1992ec7.jpg"><br><br><h3>  Contacts: </h3><br>  ¬ª <a href="https://virgilsecurity.com/">Virgilsecurity.com</a> <br>  ¬ª <a href="https://github.com/virgilsecurity">Github.com/virgilsecurity</a> <br>  ¬ª <a href="https://twitter.com/virgilsecurity">Twitter.com/virgilsecurity</a> <br><br><hr><br>  Alexey will continue the topic at the upcoming <a href="http://tokenconf.ru/">DeCenter TokenConf</a> , which will have twenty more no less steep reports and speakers.  Have time to <a href="http://conf.ontico.ru/conference/join/tc2018.html%3Fpopup%3Dtc2018">join</a> , the train has almost moved. </div><p>Source: <a href="https://habr.com/ru/post/349448/">https://habr.com/ru/post/349448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349438/index.html">Moscow JS 40 in Avito - announcement</a></li>
<li><a href="../349440/index.html">Creating a game on Lua and L√ñVE - 2</a></li>
<li><a href="../349442/index.html">JBreak 2018 Java Conference Program Overview: Absolute Balance</a></li>
<li><a href="../349444/index.html">"Do not fit, kill!" Or the whole truth about the security of automated process control systems</a></li>
<li><a href="../349446/index.html">DevDay about .NET: lazy authorization & DSL and C # union</a></li>
<li><a href="../349450/index.html">Microsoft Office Security: Document Formats</a></li>
<li><a href="../349452/index.html">[bookmark] Tools for testing javascript projects</a></li>
<li><a href="../349454/index.html">Ring bar graphs in stock</a></li>
<li><a href="../349456/index.html">Digital events in Moscow from February 19 to 25</a></li>
<li><a href="../349458/index.html">Interesting facts about Python or "Happy Birthday, Python!"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>