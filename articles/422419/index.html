<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Don't panic in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear readers Habrahabra. While a possible new error handling design is being discussed and disputes are underway about the advantages of explic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Don't panic in Go</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello, dear readers Habrahabra.  While a possible new error handling design is being discussed and disputes are underway about the advantages of explicit error handling, I suggest considering some features of errors, panic and their recovery in Go, which will be useful in practice. <br><img src="https://habrastorage.org/getpro/habr/post_images/dcd/416/6fb/dcd4166fbfbe6deeb07163d4aa4b5665.gif" alt="image"></p><a name="habracut"></a><br><h1 id="error">  error </h1><br><p>  <em>error</em> is an interface.  And like most interfaces in Go, the definition of an <em>error is</em> short and simple: </p><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> error <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Error() <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br><p>  Any type that has an Error method is obtained can be used as an error.  As Rob Pike taught, <a href="https://blog.golang.org/errors-are-values">Errors are values</a> , and values ‚Äã‚Äãcan be manipulated and programmed by various logic. </p><br><p>  The standard Go library has two functions that are convenient to use for creating errors.  The <a href="">errors.New</a> function <a href="">is</a> good for creating simple errors.  The <a href="">fmt.Errorf</a> function allows using standard formatting. </p><br><pre> <code class="go hljs">err := errors.New(<span class="hljs-string"><span class="hljs-string">"emit macho dwarf: elf header corrupted"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> name, id = <span class="hljs-string"><span class="hljs-string">"bimmler"</span></span>, <span class="hljs-number"><span class="hljs-number">17</span></span> err := fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"user %q (id %d) not found"</span></span>, name, id)</code> </pre> <br><p>  Usually, to work with errors, type error is sufficient.  But sometimes it may be necessary to transmit additional information with an error, in such cases you can add your type of errors. <br>  A good example is the type of <em>PathError</em> from the <a href="https://golang.org/pkg/os/">os</a> package. </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// PathError records an error and the operation and file path that caused it. type PathError struct { Op string Path string Err error } func (e *PathError) Error() string { return e.Op + " " + e.Path + ": " + e.Err.Error() }</span></span></code> </pre> <br><p>  The value of such an error will contain an operation, a path and an error. </p><br><p>  They are initialized this way: </p><br><pre> <code class="go hljs">... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, &amp;PathError{<span class="hljs-string"><span class="hljs-string">"open"</span></span>, name, syscall.ENOENT} ... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, &amp;PathError{<span class="hljs-string"><span class="hljs-string">"close"</span></span>, file.name, e}</code> </pre> <br><p>  Processing can have a standard view: </p><br><pre> <code class="go hljs">_, err := os.Open(<span class="hljs-string"><span class="hljs-string">"---"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ fmt.Println(err) } <span class="hljs-comment"><span class="hljs-comment">// open ---: The system cannot find the file specified.</span></span></code> </pre> <br><p>  But if there is a need to get additional information, then you can unpack the error in * <em>os.PathError</em> : </p><br><pre> <code class="go hljs">_, err := os.Open(<span class="hljs-string"><span class="hljs-string">"---"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> pe, ok := err.(*os.PathError);ok{ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Err: %s\n"</span></span>, pe.Err) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Op: %s\n"</span></span>, pe.Op) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Path: %s\n"</span></span>, pe.Path) } <span class="hljs-comment"><span class="hljs-comment">// Err: The system cannot find the file specified. // Op: open // Path: ---</span></span></code> </pre> <br><p>  The same approach can be used if the function can return several different types of errors. <br>  <a href="https://play.golang.org/p/RdexaAnKB17">play</a> </p><br><p>  Declaring several types of errors, each has its own data: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ErrTimeout <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Time time.Duration Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *ErrTimeout)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Time.String() + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ErrPermission <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Status <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *ErrPermission)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Status + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() }</code> </pre> </div></div><br><p>  A function that can return these errors: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ErrTimeout{Time: time.Second * <span class="hljs-number"><span class="hljs-number">10</span></span>, Err: errors.New(<span class="hljs-string"><span class="hljs-string">"timeout error"</span></span>)} } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &gt;= <span class="hljs-number"><span class="hljs-number">10</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ErrPermission{Status: <span class="hljs-string"><span class="hljs-string">"access_denied"</span></span>, Err: errors.New(<span class="hljs-string"><span class="hljs-string">"permission denied"</span></span>)} } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> </div></div><br><p>  Error handling through type conversions: </p><br><div class="spoiler">  <b class="spoiler_title">code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ err := proc(<span class="hljs-number"><span class="hljs-number">11</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> e := err.(<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ErrTimeout: fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Timeout: %s\n"</span></span>, e.Time.String()) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Error: %s\n"</span></span>, e.Err) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> *ErrPermission: fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Status: %s\n"</span></span>, e.Status) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Error: %s\n"</span></span>, e.Err) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(<span class="hljs-string"><span class="hljs-string">"hm?"</span></span>) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } } }</code> </pre> </div></div><br><p>  In the case when errors do not need special properties, in Go it is a good practice to create variables to store errors at the packet level.  Examples include errors such as io.EOF, io.ErrNoProgress, and so on. </p><br><p>  In the example below, we interrupt the reading and continue the operation of the application when the error is io.EOF or close the application for any other errors. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ reader := strings.NewReader(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>) p := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err := reader.Read(p) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == io.EOF { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } log.Fatal(err) } } }</code> </pre> <br><p>  This is effective because errors are generated only once and are reused many times. </p><br><h1 id="stack-trace">  stack trace </h1><br><p>  The list of functions called at the moment the stack is captured.  Tracing the stack helps to get a better idea of ‚Äã‚Äãwhat is happening in the system.  Saving traces in logs can seriously help with debugging. </p><br><p>  Having this information in error for Go is often not enough, but fortunately getting a dump of the stack in Go is not difficult. </p><br><p>  To output traces to standard outputs, you can use <em>debug.PrintStack ()</em> : </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ foo() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ bar() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ debug.PrintStack() }</code> </pre> <br><p>  As a result, the following information will be written to Stderr: </p><br><div class="spoiler">  <b class="spoiler_title">stack</b> <div class="spoiler_text"><pre> <code class="hljs go">goroutine <span class="hljs-number"><span class="hljs-number">1</span></span> [running]: runtime/debug.Stack(<span class="hljs-number"><span class="hljs-number">0x1</span></span>, <span class="hljs-number"><span class="hljs-number">0x7</span></span>, <span class="hljs-number"><span class="hljs-number">0xc04207ff</span></span>78) .../Go/src/runtime/debug/stack.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> +<span class="hljs-number"><span class="hljs-number">0xae</span></span> runtime/debug.PrintStack() .../Go/src/runtime/debug/stack.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span> +<span class="hljs-number"><span class="hljs-number">0x29</span></span> main.bar() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">13</span></span> +<span class="hljs-number"><span class="hljs-number">0x27</span></span> main.foo() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> +<span class="hljs-number"><span class="hljs-number">0x27</span></span> main.main() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">6</span></span> +<span class="hljs-number"><span class="hljs-number">0x27</span></span></code> </pre></div></div><br><p>  <em>debug.Stack ()</em> returns a slice of bytes with a stack dump, which can later be displayed in a log or in another place. </p><br><pre> <code class="go hljs">b := debug.Stack() fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Trace:\n %s\n"</span></span>, b)</code> </pre> <br><p>  There is one more thing if we do this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> bar()</code> </pre> <br><p>  then at the output we get the following information: </p><br><pre> <code class="hljs go">main.bar() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span> +<span class="hljs-number"><span class="hljs-number">0x2d</span></span> created by main.foo .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">14</span></span> +<span class="hljs-number"><span class="hljs-number">0x3c</span></span></code> </pre> <br><p>  Each gorutina has a separate stack, respectively, we only get its dump.  By the way, about their stacks at Gorutin, the work of recover is still associated with this, but more on that later. <br>  And so, to see the information on all the gorutines, you can use <em>runtime.Stack ()</em> and pass the second argument true. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { n := runtime.Stack(buf, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } buf = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf)) } fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Trace:\n %s\n"</span></span>, buf) }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">stack</b> <div class="spoiler_text"><pre> <code class="hljs go">Trace: goroutine <span class="hljs-number"><span class="hljs-number">5</span></span> [running]: main.bar() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span> +<span class="hljs-number"><span class="hljs-number">0xbc</span></span> created by main.foo .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">14</span></span> +<span class="hljs-number"><span class="hljs-number">0x3c</span></span> goroutine <span class="hljs-number"><span class="hljs-number">1</span></span> [sleep]: time.Sleep(<span class="hljs-number"><span class="hljs-number">0x77359400</span></span>) .../Go/src/runtime/time.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">102</span></span> +<span class="hljs-number"><span class="hljs-number">0x17b</span></span> main.foo() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span> +<span class="hljs-number"><span class="hljs-number">0x49</span></span> main.main() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">10</span></span> +<span class="hljs-number"><span class="hljs-number">0x27</span></span></code> </pre></div></div><br><p>  We add this information to the error and thereby greatly increase its information content. <br>  For example: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ErrStack <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { StackTrace []<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *ErrStack)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.Buffer fmt.Fprintf(&amp;buf, <span class="hljs-string"><span class="hljs-string">"Error:\n %s\n"</span></span>, e.Err) fmt.Fprintf(&amp;buf, <span class="hljs-string"><span class="hljs-string">"Trace:\n %s\n"</span></span>, e.StackTrace) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf.String() }</code> </pre> <br><p>  You can add a function to create this error: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewErrStack</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(msg </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ErrStack</span></span></span></span> { buf := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">1024</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { n := runtime.Stack(buf, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } buf = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(buf)) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;ErrStack{StackTrace: buf, Err: errors.New(msg)} }</code> </pre> <br><p>  Then you can work with it: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span>{ err := NewErrStack(<span class="hljs-string"><span class="hljs-string">"error"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">stack</b> <div class="spoiler_text"><pre> <code class="hljs go">Error: error Trace: goroutine <span class="hljs-number"><span class="hljs-number">1</span></span> [running]: main.NewErrStack(<span class="hljs-number"><span class="hljs-number">0x4c021f</span></span>, <span class="hljs-number"><span class="hljs-number">0x5</span></span>, <span class="hljs-number"><span class="hljs-number">0x4a92e0</span></span>) .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">41</span></span> +<span class="hljs-number"><span class="hljs-number">0xae</span></span> main.bar(<span class="hljs-number"><span class="hljs-number">0xc04207ff</span></span>38, <span class="hljs-number"><span class="hljs-number">0xc04207ff</span></span>78) .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">24</span></span> +<span class="hljs-number"><span class="hljs-number">0x3d</span></span> main.foo(<span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x48ebff</span></span>) .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">21</span></span> +<span class="hljs-number"><span class="hljs-number">0x29</span></span> main.main() .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">11</span></span> +<span class="hljs-number"><span class="hljs-number">0x29</span></span></code> </pre></div></div><br><p>  Accordingly, the error and the trace can be broken: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> st, ok := err.(*ErrStack);ok{ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Error:\n %s\n"</span></span>, st.Err) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Trace:\n %s\n"</span></span>, st.StackTrace) } }</code> </pre> <br><p>  And of course there is already a ready solution.  One of them is the <a href="https://github.com/pkg/errors">https://github.com/pkg/errors</a> package.  It allows you to create a new error that will already contain a stack of traces, or you can add a trace and / or additional messages to an already existing error.  Plus convenient formatting output. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ err := foo() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"%+v"</span></span>, err) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span>{ err := bar() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"error2"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>) }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">stack</b> <div class="spoiler_text"><pre> <code class="hljs go">error main.bar .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">20</span></span> main.foo .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">16</span></span> main.main .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> runtime.main .../Go/src/runtime/proc.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">198</span></span> runtime.goexit .../Go/src/runtime/asm_amd64.s:<span class="hljs-number"><span class="hljs-number">2361</span></span> error2 main.foo .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">17</span></span> main.main .../main.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">9</span></span> runtime.main .../Go/src/runtime/proc.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">198</span></span> runtime.goexit .../Go/src/runtime/asm_amd64.s:<span class="hljs-number"><span class="hljs-number">2361</span></span></code> </pre> </div></div><br><p>  % v will display only messages </p><br><pre> <code class="hljs vbscript">error2: <span class="hljs-keyword"><span class="hljs-keyword">error</span></span></code> </pre> <br><h1 id="panicrecover">  panic / recover </h1><br><p>  Panic (aka accident, aka panic), as a rule, indicates the presence of problems due to which the system (or a particular subsystem) cannot continue to function.  In the case of a panic call, Go runtime scans the stack, trying to find a handler for it. </p><br><p>  Untreated panic stops the application.  This fundamentally distinguishes them from errors that make it possible not to process themselves. </p><br><p>  Any argument can be passed to the panic function call. </p><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(v <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{})</code> </pre> <br><p>  Conveniently in panic to pass an error, of the type that will simplify recovery and help debugging. </p><br><pre> <code class="go hljs"><span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>))</code> </pre> <br><p>  <em>Disaster</em> recovery in Go is based on a deferred function call, also <em>defer</em> .  This function is guaranteed to be executed at the time of return from the parent function.  Regardless of the reason - the operator return, end of the function or panic. </p><br><p>  But the <em>recover</em> function already provides an opportunity to get information about the accident and stop the unwinding of the call stack. <br>  A typical example of a panic call and handler is: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"panic: %s"</span></span>, err) } }() foo() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) }</code> </pre> <br><p>  recover returns interface {} (the one that is passed to panic) or nil if there was no panic call. </p><br><p>  Consider another example of handling emergency situations.  We have a certain function in which we transfer, for example, a resource and which, in theory, can cause a panic. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(f *os.File)</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) }</code> </pre> <br><p>  First, it may be necessary to always perform some actions at the end, for example, cleaning up resources, in our case it is closing the file. </p><br><p>  Secondly, the incorrect execution of such a function should not lead to the completion of the entire program. </p><br><p>  Such a problem can be solved with the help of defer, recover and closure: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { file, _ := os.Open(<span class="hljs-string"><span class="hljs-string">"file"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> r := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); r != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = r.(error) <span class="hljs-comment"><span class="hljs-comment">//   ,   ,     // err := errors.New("trapped panic: %s (%T)", r, r) //     } file.Close() //   }() bar(file) return err }</span></span></code> </pre> <br><p>  We allow the closure to address the above declared variables, thanks to which it is guaranteed to close the file and in case of an accident, extract the error from it and transfer it to the usual error handling mechanism. </p><br><p>  There are reverse situations where a function with certain arguments should always work correctly and if this does not happen, then what went really bad. </p><br><p>  In such cases, a wrapper function is added in which the target function is called and panic is called in case of an error. </p><br><p>  In Go, usually such functions with the prefix <em>Must</em> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// MustCompile is like Compile but panics if the expression cannot be parsed. // It simplifies safe initialization of global variables holding compiled regular // expressions. func MustCompile(str string) *Regexp { regexp, error := Compile(str) if error != nil { panic(`regexp: Compile(` + quote(str) + `): ` + error.Error()) } return regexp }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Must is a helper that wraps a call to a function returning (*Template, error) // and panics if the error is non-nil. It is intended for use in variable initializations // such as // var t = template.Must(template.New("name").Parse("html")) func Must(t *Template, err error) *Template { if err != nil { panic(err) } return t }</span></span></code> </pre> <br><p>  It is worth remembering about one more moment related to panic and gorutines. </p><br><p>  Part of the theses from what was discussed above: </p><br><ul><li>  For each gorutina a separate stack is allocated. </li><li>  When calling panic, recover is looked for in the stack. </li><li>  In the case when recover does not find, the entire application is terminated. </li></ul><br><p>  The handler in main will not intercept the panic from foo and the program will crash: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span>{ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"panic: %s"</span></span>, err) } }() <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> foo() time.Sleep(time.Minute) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) }</code> </pre> <br><p>  This will be a problem if, for example, a handler is called to connect to the server.  In the event of a panic in any of the handlers, the entire server will terminate.  And for some reason, you cannot control the handling of accidents in these functions. <br>  In the simple case, the solution might look something like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> f <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Def</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fn f)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := <span class="hljs-built_in"><span class="hljs-built_in">recover</span></span>(); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Println(<span class="hljs-string"><span class="hljs-string">"panic"</span></span>) } }() fn() }() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Def(foo) time.Sleep(time.Minute) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(errors.New(<span class="hljs-string"><span class="hljs-string">"error"</span></span>)) }</code> </pre> <br><h1 id="handlecheck">  handle / check </h1><br><p>  Perhaps in the future we are waiting for changes in error handling.  You can get acquainted with them by the links: <br>  <a href="">go2draft</a> <br>  <a href="https://habr.com/post/422049/">Error handling in Go 2</a> </p><br><p>  That's all for today.  Thank! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/422419/">https://habr.com/ru/post/422419/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422409/index.html">Python: metaprogramming in production. Part one</a></li>
<li><a href="../422411/index.html">New roles in companies in the era of servitization</a></li>
<li><a href="../422413/index.html">Application Arm Mbed OS. Fine tuning</a></li>
<li><a href="../422415/index.html">Python: metaprogramming in production. Part two</a></li>
<li><a href="../422417/index.html">Slavik and GMT + 3 or benefits for people</a></li>
<li><a href="../422421/index.html">Microsoft is going to drastically improve Skype</a></li>
<li><a href="../422423/index.html">Python and DataScience: exploring the capabilities of the universal library Numpy</a></li>
<li><a href="../422425/index.html">Review of post-processing methods for FDM 3D-printed models</a></li>
<li><a href="../422427/index.html">Dagaz: Out of the Fog</a></li>
<li><a href="../422429/index.html">Accelerate the process of developing complex projects. Without chaos and nerves</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>