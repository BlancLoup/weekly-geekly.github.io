<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to switch to gRPC, saving REST</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Many are familiar with gRPC - Google‚Äôs open RPC framework, which supports 10 languages ‚Äã‚Äãand is actively used within Google, Netflix, Kubernetes, Dock...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to switch to gRPC, saving REST</h1><div class="post__text post__text-html js-mediator-article"><p>  Many are familiar with gRPC - Google‚Äôs open RPC framework, which supports 10 languages ‚Äã‚Äãand is actively used within Google, Netflix, Kubernetes, Docker and many others.  If you are writing microservices, gRPC provides a lot of advantages over the traditional REST + JSON approach, but on existing projects it is often not so easy to make the transition due to the presence of already used REST clients that cannot be updated at once.  Often speaking on the topic of gRPC, you can hear "yes, we in our company are also looking at gRPC, but we won‚Äôt try." </p><br><p>  Well, this problem has a good solution called grpc-rest-gateway, which does just that - autogenerating a REST-gRPC proxy with support for all the major benefits of gRPC plus support for Swagger.  In this article, I will show you with an example of how it looks and works, and, I hope, this will help you to switch to gRPC without losing existing REST clients. </p><br><p><img src="https://habrastorage.org/web/a5d/52e/bf2/a5d52ebf2e2048ac9eb1efd893ffbdf5.png"></p><a name="habracut"></a><br><p>  But, for a start, let's decide what situations we are talking about.  The two most common options are: </p><br><ul><li>  backend (Go / Java / C ++ / node.js / whatever) and frontend (JS / iOS / Kotlin / Java / etc) communicate using REST API </li><li>  microservices (in different languages) communicate with each other also via REST-like API (HTTP and JSON protocol for serialization) </li></ul><br><p>  For small projects, this is an absolutely normal choice, but as projects and the number of people grow on it, the problems of the REST API begin to become very clear and take the lion's share of the developers' time. </p><br><h1 id="chem-ploh-rest">  What's wrong with REST? </h1><br><p>  Of course, REST is used everywhere and everywhere because of its simplicity and even a vague understanding of what REST is.  In general, REST began as a dissertation from one of the creators of HTTP, Roy Fielding, entitled ‚ÄúArchitectural Styles and Design of Network Software Architectures‚Äù.  Actually, REST is just an architectural style, not some kind of clearly described specification. </p><br><p>  But this is the root of some significant problems.  There is no single agreement on which HTTP method to use, when which code to return, what to send to the URI, and what is in the body of the request, etc.  There are attempts to reach a general agreement, but, unfortunately, they are not very successful. </p><br><p> Further, with the REST approach, you have too many entities that carry meaning - the HTTP method (GET / POST / PUT / DELETE), the request URI ( <code>/users</code> , <code>/user/1</code> ), the request body ( <code>{id: 1}</code> ) plus headers ( <code>X-User-ID: 1</code> ).  All this adds unnecessary complexity and the possibility of misinterpretation, which becomes a big problem as the API begins to be used between different services that write different commands and the synchronization of all these entities begins to take a significant portion of the command time. </p><br><p>  This leads us to the next problem - the complexity of the declarative description of APIs and the description of data types.  The OpenAPI Specification (known as Swagger), RAML, and the Blueprint API partially solve this problem, but at the cost of adding another complexity.  Someone writes YAML files with handles for each new request, someone uses web-based frameworks with autogeneration, inflating code with descriptions of parameters and request types, and support for the swagger specification in sync with the actual implementation of the API still lies on the shoulders of responsible developers, takes time away from solving, in fact, the tasks that these APIs have to solve. </p><br><p>  A separate complexity lies in the API, which develops and changes, and the synchronization of clients and servers can take a lot of time and resources. </p><br><h1 id="grpc">  gRPC </h1><br><p>  gRPC solves these problems with code generation and declarative type declaration language and RPC methods.  The default Google Protobuf 3 is used as IDL, and HTTP / 2 for transport.  Kodogenerators are in 10 languages ‚Äã‚Äã- Go, Java, C ++, Python, Ruby, Node.js, C #, PHP, Android.Java, Objective-C.  There are also unofficial implementations for Rust, Swift and others. </p><br><p>  In gRPC, you only have one place where you define how the fields will be named, what are the requests, what to accept and what to return.  This is described in the .proto file.  For example: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> library; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> LibraryService { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> AddBook(AddBookRequest) returns (AddBookResponse) } message AddBookRequest { <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Author { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> name = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> surname = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> isbn = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">repeated</span></span> Author authors = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> AddBookResponse { <span class="hljs-attribute"><span class="hljs-attribute">int64</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><p>  From this proto-file, using the <code>protoc</code> compiler, the code of clients and servers in all supported languages ‚Äã‚Äã(well, those that you specify to the compiler) is generated.  Further, if you change something in types or methods, restart the code generation and get the updated code for both the client and the server. </p><br><p>  If you have ever resolved conflicts in field names like <code>UserID</code> vs <code>user_id</code> , you will enjoy working with gRPC. </p><br><p>  But I will not dwell on the principles of working with gRPC in great detail, and I‚Äôll go over the question of what to do if you want to use gRPC, but you have clients that still have to work through the REST API and will not just be translated / rewrite to gRPC.  This is especially true, given that there is no official support for gRPC in the browser yet (JS is only Node.js officially), and the implementation for Swift is also not yet on the official list. </p><br><h1 id="grpc-rest-gateway">  GRPC REST Gateway </h1><br><p>  The <a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a> project, like almost everything in the grpc-ecosystem, is implemented as a plug-in for the <code>protoc</code> compiler.  It allows you to add annotations to rpc definitions in a protobuf file, which will be described by the REST equivalent of this method.  For example: </p><br><pre> <code class="hljs java"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"google/api/annotations.proto"</span></span>; ... service LibraryService { <span class="hljs-function"><span class="hljs-function">rpc </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddBook</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AddBookRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">returns</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(AddBookResponse)</span></span></span><span class="hljs-function"> </span></span>{ option (google.api.http) = { post: <span class="hljs-string"><span class="hljs-string">"/v1/book"</span></span> body: <span class="hljs-string"><span class="hljs-string">"*"</span></span> }; } }</code> </pre> <br><p>  After running protoc with the specified plugin, you will receive an auto-generated code that will transparently redirect POST HTTP requests to the specified URI to the real grpc server and also transparently convert and send the response. </p><br><p>  Ie formally, this is the API Proxy, which is launched as a separate service and makes a transparent conversion of REST HTTP requests to gRPC communication between services. </p><br><h1 id="primer-ispolzovaniya">  Usage example </h1><br><p>  Let's continue the example above - say, our book service should be able to work with the old iOS frontend, which so far can only work with REST HTTP.  You have already transferred other services to gRPC and enjoy less headaches as your APIs grow or change.  By adding the above annotations, we create a new service ‚Äî for example, <code>rest_proxy</code> and autogenerate the reverse proxy code in it: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">protoc</span></span> -I/usr/local/include -I. \ -I<span class="hljs-variable"><span class="hljs-variable">$GOPATH</span></span>/src \ -I<span class="hljs-variable"><span class="hljs-variable">$GOPATH</span></span>/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis \ --grpc-gateway_out=logtostderr=<span class="hljs-literal"><span class="hljs-literal">true</span></span>:. \ library.proto</code> </pre> <br><p>  The code of the service itself may look something like this: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/myuser/rest-proxy/library"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> main() { gw := runtime.NewServeMux(muxOpt) opts := []grpc.DialOption{grpc.WithInsecure()} err := library.RegisterLibraryServiceHandlerFromEndpoint(ctx, gw, <span class="hljs-string"><span class="hljs-string">"library-service.dns.name"</span></span>, opts) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { log.Fatal(err) } mux := http.NewServeMux() mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, gw) log.Fatal(http.ListenAndServe(<span class="hljs-string"><span class="hljs-string">":80"</span></span>, mux)) }</code> </pre> <br><p>  This code will launch our proxy on port 80, and will send all requests to the gRPC server, available at <code>library-service.dns.name</code> .  <code>RegisterLibraryServiceHandlerFromEndpoint</code> is an automatically generated method that does all the magic. </p><br><p>  Obviously, this proxy can serve as an entry point for all your other services on gRPC, which need fallback in the form of a REST API - just plug in the rest of auto-generated packages and register them on the same gw-object: </p><br><pre> <code class="hljs vbscript"> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> = users.RegisterUsersServiceHandlerFromEndpoint(ctx, gw, <span class="hljs-string"><span class="hljs-string">"users-service.dns.name"</span></span>, opts) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">err</span></span> != nil { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Fatal(<span class="hljs-built_in"><span class="hljs-built_in">err</span></span>) }</code> </pre> <br><p>  and so on. </p><br><h1 id="preimuschestva">  Benefits </h1><br><p>  Auto-generated proxy supports automatic reconnect to the service, with an exponential backoff delay, as in conventional grpc services.  Similarly, TLS support is out of the box, timeouts and everything that is available in grpc services is also available in proxy. </p><br><h3 id="middlewares">  Middlewares </h3><br><p>  Separately want to write about the possibility of using the so-called  middlewares are request handlers that should automatically work before or after a request.  A typical example - your HTTP requests contain a special header that you want to pass on to grpc services. </p><br><p>  For example, I will take an example with a standard JWT token that you want to decrypt and transfer the value of the UserID field to grpc services.  This is done as simply as the usual http-middlewares: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkJWT</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(h http.Handler)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">http</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handler</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> http.HandlerFunc(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span></span></span> { bearer := r.Header.Get(<span class="hljs-string"><span class="hljs-string">"Authorization"</span></span>) ... <span class="hljs-comment"><span class="hljs-comment">// parse and extract value from token ... ctx = context.WithValue(ctx, "UserID", claims.UserID) h.ServeHTTP(w, r.WithContext(ctx)) }) }</span></span></code> </pre> <br><p>  and wrap our mux object in this middleware function: </p><br><pre> <code class="go hljs"> mux.Handle(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, checkJWT(gw))</code> </pre> <br><p>  Now on the services side (all gRPC methods in the Go implementation are taken by the first parameter of the context), you just get this value out of context: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">func</span></span> (<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">LIbrary</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">AddBook</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">ctx</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">context</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Context</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">req</span></span> *<span class="hljs-selector-tag"><span class="hljs-selector-tag">library</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AddBookRequest</span></span>) (*<span class="hljs-selector-tag"><span class="hljs-selector-tag">library</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.AddBookResponse</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">error</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">userID </span></span>:= ctx.<span class="hljs-built_in"><span class="hljs-built_in">Value</span></span>(<span class="hljs-string"><span class="hljs-string">"UserID"</span></span>).(int64) ... }</code> </pre> <br><h3 id="dopolnitelnyy-funkcional">  Additional functionality </h3><br><p>  Of course, nothing limits your rest-proxy from the implementation of additional functionality.  This is the usual http-server, after all.  You can forward some HTTP requests to another legacy REST service: </p><br><pre> <code class="go hljs"> legacyProxy := httputil.NewSingleHostReverseProxy(legacyUrl) mux.Handle(<span class="hljs-string"><span class="hljs-string">"/v0/old_endpoint"</span></span>, legacyProxy)</code> </pre><br><h3 id="swagger-ui">  Swagger ui </h3><br><p>  A separate cherry in the approach with grpc-gateway is the automatic generation of the <code>swagger.json</code> file.  It can then be used with online UI, and can also be given directly from our own service. </p><br><p>  With the help of small manipulations with SwaggerUI and go-bindata, you can add another endpoint <br>  to our service, which will render a beautiful and, most importantly, up-to-date and auto-generated UI for the REST API. </p><br><p>  Generating swagger.json </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">protoc</span></span> -I/usr/local/include -I<span class="hljs-variable"><span class="hljs-variable">$GOPATH</span></span>/src -I<span class="hljs-variable"><span class="hljs-variable">$GOPATH</span></span>/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis --swagger_out=logtostderr=<span class="hljs-literal"><span class="hljs-literal">true</span></span>:swagger-ui/ path/to/library.proto</code> </pre> <br><p>  Create handlers that will give out static and generate index.html (in the example, static is added directly to the code using <a href="https://github.com/jteeuwen/go-bindata">go-bindata</a> ): </p><br><pre> <code class="go hljs"> mux.HandleFunc(<span class="hljs-string"><span class="hljs-string">"/swagger/index.html"</span></span>, SwaggerHandler) mux.Handle(<span class="hljs-string"><span class="hljs-string">"/swagger/"</span></span>, http.StripPrefix(<span class="hljs-string"><span class="hljs-string">"/swagger/"</span></span>, http.FileServer(assetFS()))) ... <span class="hljs-comment"><span class="hljs-comment">// init indexTemplate at start func SwaggerHandler(w http.ResponseWriter, r *http.Request) { indexTemplate.Execute(w, nil) }</span></span></code> </pre> <br><p>  and you get a Swagger UI like this, with up-to-date information and the ability to test right there: <br><img src="https://habrastorage.org/web/93a/876/a0f/93a876a0fa72478dbf3cfa2ee35dcd5c.png"></p><br><h1 id="problemy">  Problems </h1><br><p>  In general, my experience with grpc-gateway can be described by one phrase - ‚Äúit just works out of the box‚Äù.  Of the problems encountered, for example, I can note the following. </p><br><p>  Go for serialization in JSON uses so-called "structure tags" - meta information for fields.  In <code>encoding/json</code> there is such an <code>omitempty</code> tag - it means that if the value is zero (zero value for this type), then it should not be added to the resulting JSON.  The grpc-gateway plugin for Go adds this tag to the structures, which sometimes leads to incorrect behavior. </p><br><p>  For example, you have a variable of type <code>bool</code> in the structure, and you give this structure in the response - both <code>true</code> and <code>false</code> values ‚Äã‚Äãare equally important in the response, and the frontend expects to receive this field.  The answer is, the generated grpc-gateway will contain this field only if the value is <code>true</code> , otherwise it will simply be omitted (omitempty). </p><br><p>  Fortunately, this is easily solved using the configuration options: </p><br><pre> <code class="go hljs"> customMarshaller := &amp;runtime.JSONPb{ OrigName: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, EmitDefaults: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-comment"><span class="hljs-comment">// disable 'omitempty' } muxOpt := runtime.WithMarshalerOption(runtime.MIMEWildcard, customMarshaller) gw := runtime.NewServeMux(muxOpt)</span></span></code> </pre> <br><p>  One more thing that I would like to share is the non-obvious semantics of working with the <code>protoc</code> compiler itself.  Call commands are very long, hard to read, and, most importantly, the logic of where protobuf comes from and where output is generated (+ what directories are created) is very unclear.  For example, you want to use a proto-file from another project and generate some plugin code, putting it in the current project in the folder <code>swagger-ui/</code> .  I had to try for 15 minutes a lot of protoc call options before it became clear how to make the generator work that way.  But, again, nothing unsolvable. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  gRPC can speed up the productivity and efficiency of working with microservice architecture many times, but often the requirement is backward compatibility and REST API support.  <code>grpc-gateway</code> provides a simple and effective way to solve this problem by automatically generating a reverse proxy server translating REST / JSON requests to gRPC calls.  The project is being actively developed and used in production in many companies. </p><br><h1 id="ssylki">  Links </h1><br><ul><li>  <a href="https://grpc.io/">https://grpc.io</a> </li><li>  <a href="https://github.com/grpc-ecosystem/grpc-gateway">https://github.com/grpc-ecosystem/grpc-gateway</a> </li><li>  <a href="https://coreos.com/blog/grpc-protobufs-swagger.html">https://coreos.com/blog/grpc-protobufs-swagger.html</a> </li><li>  <a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a> </li><li>  <a href="https://github.com/google/protobuf">https://github.com/google/protobuf</a> <br></li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/337716/">https://habr.com/ru/post/337716/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../337704/index.html">Moving Java forward faster</a></li>
<li><a href="../337708/index.html">DevOps with Kubernetes and VSTS. Part 2: Cloud History</a></li>
<li><a href="../337710/index.html">History 13 places on Highload Cup 2017</a></li>
<li><a href="../337712/index.html">Parrot Security OS - an alternative to Kali Linux</a></li>
<li><a href="../337714/index.html">The book "Security Audit Information Systems"</a></li>
<li><a href="../337718/index.html">Creating and normalizing dictionaries. Choose the best, remove too much</a></li>
<li><a href="../337720/index.html">10 years of Computer Science club</a></li>
<li><a href="../337722/index.html">How to understand that your predictive model is useless</a></li>
<li><a href="../337724/index.html">Guide to understanding between customer and contractor</a></li>
<li><a href="../337728/index.html">4% of efforts - 64% of the result, or 5 simple ways to increase the effectiveness of the sales department</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>