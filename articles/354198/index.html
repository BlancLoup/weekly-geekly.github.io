<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to transfer a polymorphic object to the STL algorithm</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As we can read in the first chapter of the book Effective C ++ , the C ++ language is essentially a union of 4 different parts: 



- The procedural p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to transfer a polymorphic object to the STL algorithm</h1><div class="post__text post__text-html js-mediator-article">  As we can read in the first chapter of the book <a href="https://www.amazon.com/gp/product/0321334876/ref%3Das_li_tl%3Fie%3DUTF8%26camp%3D1789%26creative%3D9325%26creativeASIN%3D0321334876%26linkCode%3Das2%26tag%3Dfluentcpp-20%26linkId%3Dc827183fcb052e6a805d39ee7d66095">Effective C ++</a> , the C ++ language is essentially a union of 4 different parts: <br><br><ul><li>  The procedural part, inherited from the language C </li><li>  Object oriented part </li><li>  STL trying to follow the functional paradigm </li><li>  Templates </li></ul><br>  These four, in essence, sublanguages ‚Äã‚Äãmake up what we call the unified C ++ language.  Since all of them are united in one language, this gives them the opportunity to interact.  This interaction sometimes generates interesting situations.  Today we look at one of them - the interaction of the object-oriented model and STL.  It can take various forms and in this article we will consider the transfer of polymorphic functional objects to STL algorithms.  These two worlds are not always well contacted, but we can build a fairly good bridge between them. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f96/00d/7b4/f9600d7b47e439e1c18c94c1afc181d6.png" alt="image"><br><a name="habracut"></a><br><h3>  Polymorphic functional objects - what is it? </h3><br>  By a functional object in C ++, I mean an object that can call operator ().  This can be a lambda function or a functor.  Polymorphism can mean different things depending on the programming language and context, but here I will call polymorphic objects of those classes that use inheritance and virtual methods.  That is, a polymorphic functional object is something like: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ method(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Base class called.\n"</span></span>; } };</code> </pre> <br>  This functional object does nothing useful, but it is even good, because the implementation of its methods will not distract us from the main task - to transfer its successor to the STL algorithm.  And the heir will override the virtual method: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Derived class called.\n"</span></span>; } };</code> </pre> <br>  Let's try to pass a successor to the STL algorithm in a trivial way, like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Base </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; base)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(begin(v), end(v), begin(v), base); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Derived d; f(d); }</code> </pre> <br>  What would you think would output this code? <br><br><div class="spoiler">  <b class="spoiler_title">This</b> <div class="spoiler_text">  Base class called. <br>  Base class called. <br>  Base class called. <br></div></div><br>  Strange, right?  We passed a Derived class object to the algorithm, with an overloaded virtual method, but the algorithm decided to call the base class method instead.  To understand what happened, let's take a look at the prototype of the std :: transform function: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> InputIterator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> OutputIterator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Function&gt; <span class="hljs-function"><span class="hljs-function">OutputIt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">transform</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(InputIterator first, InputIterator last, OutputIterator out, Function f)</span></span></span></span>;</code> </pre> <br>  Look carefully at its last parameter (Function f) and note that it is passed by value.  As explained in Chapter 20 of the same book, Effective C ++, polymorphic objects are ‚Äúcut off‚Äù when we pass them by value: even if the reference to Base const &amp; points to an object of type Derived, creating a copy of base creates an object of type Base rather than an object of type Derived. <br><br>  Thus, we need a way to pass a reference to the polymorphic object, and not to its copy, to the STL algorithm. <br><br>  How to do it? <br><br><h3>  Let's wrap our object in one more. </h3><br>  This thought generally comes first: ‚ÄúThe problem?  Let's solve it by adding indirection! ‚ÄùIf our object must first be passed by reference, and the STL algorithm accepts only objects by value, then we can create an intermediate object that will store a reference to the polymorphic object we need, but this one the object can already be passed by value. <br><br>  The easiest way to do this is to use the lambda function: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(begin(v), end(v), begin(v), [&amp;base](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base(n); }</code> </pre> <br>  Now the code displays the following: <br><br> <code>Derived class called. <br> Derived class called. <br> Derived class called.</code> <br> <br>  It works, but it burdens the code of the lambda function, which, although rather short, is still not written for the grace of the code, but only for technical reasons. <br>  In addition, in real code it may look much longer: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(begin(v), end(v), begin(v), [&amp;base](<span class="hljs-keyword"><span class="hljs-keyword">module</span></span>::domain::component myObject){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base(myObject); }</code> </pre> <br>  Redundant code using the functional paradigm as a crutch. <br><br><h3>  Compact solution: use std :: ref </h3><br>  There is another way to transfer a polymorphic object by value, and it is to use std :: ref <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform(begin(v), end(v), begin(v), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ref(base));</code> </pre> <br>  The effect will be the same as for the lambda function: <br><br> <code>Derived class called. <br> Derived class called. <br> Derived class called.</code> <br> <br>  Perhaps now you have the question "Why?".  For example, I have it.  First, how did it compile at all?  std :: ref returns an object of type std :: reference_wrapper, which models the link (with the only exception that it can be reassigned to another object using operator =).  So how can std :: reference_wrapper play the role of a functional object?  I looked at the documentation for std :: reference_wrapper at <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper/operator()">cppreference.com</a> and found this: <br><blockquote>  std :: reference_wrapper :: operator () <br><br>  Calls the Callable object, reference to which is stored.  Callable object. </blockquote>  That is, it is such a special feature in std :: reference_wrapper: if std :: ref accepts a functional object of type F, then the returned simulator object of the link will also be of functional type and its operator () will call operator () of type F. Exactly what we needed. <br><br>  This solution seems to me better than the use of lambda functions, because the same result is achieved with a simpler and more concise code.  Perhaps there are other solutions to this problem - I will be glad to see them in the comments. </div><p>Source: <a href="https://habr.com/ru/post/354198/">https://habr.com/ru/post/354198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354188/index.html">Prefetch and preload webpack directives</a></li>
<li><a href="../354190/index.html">Using the principles of gestalt psychology in web design</a></li>
<li><a href="../354192/index.html">Moscow SPA ‚Ññ4: summary, video, presentations, photo report</a></li>
<li><a href="../354194/index.html">Building a network for data storage systems of the small and medium business sector Part 2. Practical issues of organizing small infrastructures</a></li>
<li><a href="../354196/index.html">Creating the main menu of the game</a></li>
<li><a href="../354200/index.html">Unified Scalable Remuneration System: Our Experience</a></li>
<li><a href="../354204/index.html">Morrowind speedran planning using simulated annealing</a></li>
<li><a href="../354206/index.html">Start with full stack and not regret: from senior developer to head of department for six years</a></li>
<li><a href="../354208/index.html">Learn OpenGL. Lesson 5.4 - Omnidirectional Shadow Maps</a></li>
<li><a href="../354210/index.html">The announcement of the mitap ThinkPHP # 16 in Kharkov</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>