<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Erlang and its processes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0 Preamble 
 Model is not the world. As humans, we cannot fully understand reality. We can only build its model and through it study and use the real ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Erlang and its processes</h1><div class="post__text post__text-html js-mediator-article"><h4>  0 Preamble </h4><br>  Model is not the world.  As humans, we cannot fully understand reality.  We can only build its model and through it study and use the real world.  The completeness, success, vitality of a part of reality in the information space (or in our head) depends on which model we choose. <br><br>  Each programming language has its own paradigm of building reality.  In functional languages, the calculation process is interpreted as calculating the values ‚Äã‚Äãof functions, in imperative languages, on the contrary, the computational process is described in the form of instructions that change the state of the program. <br><br>  In this article, the author will highlight the functional programming language Erlang, the paradigm of which may sound like this: ‚Äúeverything is a process‚Äù.  In the first part of this article, introductory information will be given on the creation and communication of processes between each other, in the second we will focus on planning processes inside the Erlang virtual machine and on specification of processes.  The article is intended for beginners who want to start building complex, multi-threaded and fault tolerant applications in the Erlang language. <br><a name="habracut"></a><br><h4>  1 Work with processes </h4><br>  Erlang language implements a lightweight model of processes that run in a virtual machine - BEAM (Bogdan / Bj√∂rn's Erlang Abstract Machine), this model allows you to: <br><ul><li>  quickly create, destroy processes; </li><li>  the only way interprocess communication is through messaging; </li><li>  processes do not share memory and are completely independent; </li><li>  You can create a huge number of processes; </li><li>  easy scaling of applications on SMP. </li></ul><br><h5>  1.1 Creating processes </h5><br>  The following functions are used to create processes (the number of arguments that the function can take is indicated through slash): <br><ul><li>  erlang: spawn / 1/2/3/4 - creating a normal process; </li><li>  erlang: spawn_link / 1/2/3/4 - creating a process and associating it with the calling process; </li><li>  erlang: spawn_monitor / 1/3; </li><li>  pool: pspawn / 3 - creating a process on one of the nodes (minimally loaded) in the pool; </li><li>  pool: pspwn_link / 3 is the same as the previous item, only a link is created between the calling process and the one being created. </li></ul><br>  In addition to these functions in the documentation [1] you can find many functions intended for maintenance and manipulation of processes. <br>  Now let's create a simple process and run it.  We launch the interactive shell and execute the following commands: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
     <code>Eshell V5.8 (abort with ^G) <br> 1&gt; Fun = fun() -&gt; receive after infinity -&gt; ok end end. <br> #Fun&lt;erl_eval.20.67289768&gt; <br> 2&gt; Pid = spawn(Fun). <br> &lt;0.33.0&gt; <br> 3&gt;</code> <br> <br>  In the first line, we create a function that will be the body of the process, then we create the process itself using the spawn / 1 function, the process has been created and assigned the identifier &lt;0.33.0&gt;.  Now let's call the function c: i / 0 (c is the module in which the functions for interactive work in the Erlang shell are collected): <br><br> <code>3&gt; i(). <br> Pid Initial Call Heap Reds Msgs <br> Registered Current Function Stack <br> &lt;0.0.0&gt; otp_ring0:start/2 987 2581 0 <br> ... <br> &lt;0.33.0&gt; erlang:apply/2 233 18 0 <br> erl_eval:receive_clauses/8 10</code> <br> <br>  We see that our process works.  Also, to monitor the processes, you can run the graphical utility pman: <br><br> <code>5&gt; pman:start(). <br> &lt;0.37.0&gt; <br> 6&gt;</code> <br> <br><img src="https://habrastorage.org/storage/99f434c4/da4596ae/8f9ecbe2/db28bd41.png"><br><br><h5>  1.2 Inter-process communication </h5><br>  Now let's look at the simplest example of how processes can communicate with each other.  To do this, we will write a small module (for writing and debugging programs on Erlang, the author uses a bunch of Emacs + Erlang mode + distel): <br><blockquote><ol><li>  -module (proc). </li><li>  -export ([start / 0, p / 0]). </li><li></li><li>  start () -&gt; </li><li>  spawn (proc, p, []). </li><li></li><li>  p () -&gt; </li><li>  receive </li><li>  {Pid, Msg} when is_pid (Pid) -&gt; </li><li>  io: format ( <font color="#A31515">"Hello from proc: ~ p, mesg: ~ p ~ n"</font> , [Pid, Msg]), </li><li>  Pid!  Msg </li><li>  p (); </li><li>  stop -&gt; </li><li>  ok; </li><li>  _ -&gt; </li><li>  io: format ( <font color="#A31515">"Unknown type of message ~ n"</font> , []), </li><li>  p () </li><li>  end. </li></ol></blockquote><br>  The structure of the module is quite simple, the first line describes the name of the module, it must match the file name (in this case, the file is called proc.erl), in the second line we export two functions, the first is for creating the process, and the second describes body function.  To create a process, we use a version of the spawn function with three arguments, they can be described by a tuple {M, F, A}, where M is the module that contains the function F called with argument list A (in this case, the function has no arguments) .  For the process body, the construction is used: <br><blockquote> <code><font color="black">Receive <br> Pattern1 when Guard1 -&gt; exp-11,...exp-1n; <br> ... <br> Pattern1 when Guard1 -&gt; exp-m1,...exp-mn <br> after Time -&gt; exp-k1,...exp-kh <br> End</font></code> </blockquote> <br><br>  Where Pattern is a pattern for matching the received message, Guard additional conditions, Time is a timer, specified in ms, it works if the queue is empty for a specified time. <br><br>  Now we compile our module and try to create a process. <br><br> <code>1&gt; c("proc"). <br> {ok,proc} <br> 2&gt; Pid = proc:start(). <br> &lt;0.37.0&gt; <br> 3&gt; Pid ! {self(), "Hello from shell"}. <br> Hello from proc: &lt;0.30.0&gt;, mesg: "Hello from shell" <br> {&lt;0.30.0&gt;,"Hello from shell"} <br> 4&gt; flush(). <br> Shell got "Hello from shell" <br> ok <br> 5&gt;</code> <br> <br>  In the first line, we compile our module, then create a process.  The Pid variable stores the process identifier to which, using the! Operator, a message is sent in the form of the tuple {self (), "..."}, where the self / 0 function returns the identifier of the process in which we are located - an interactive shell process. <br><br>  The created process, having received the message, takes it out of the queue and matches it with one of the templates in this case with {Pid, Msg}, and then sends the received message back.  The flush / 0 function in this case is needed to reset all messages sent to the interactive shell, this is necessary because this process does not have a receive block. <br><br>  As a practice, I suggest that readers create two independent processes that exchange processes, for example, at the command of the Eralang shell, the first sends a pair of numbers to the second, which summarizes them and sends them back to the first, and it already outputs the answer to the shell. <br><br><h4>  2 Digging deeper </h4><br><br>  Let's look at a few more questions about processes: first, how the process scheduler works, and second, let's see what information you can learn about the process. <br><br><h5>  2.1 Process Planner </h5><br><br>  Planning erlang processes is based on reductions.  Reduction in logic and mathematics is a logical-methodological method of reducing complex to simple (Wikipedia).  One reduction is approximately equivalent to a function call.  The process is allowed to run until it is suspended pending input (messages from another process, in this case the suspended process is in the receive block) or until it consumes N reductions (I'm not sure with the exact number, but found somewhere that it is 1000 reductions). <br><br>  There are functions with which you can influence the planning process (erlang: yield / 0, erlang: bump_reductions / 1), but they should be used only in rare cases (as stated in the documentation [1], these functions can be changed / deleted in future releases ).  A process waiting for a message will be rescheduled as soon as a message appears in its queue or a timer in the receive block is triggered, after which it is placed last in the scheduler queue. <br><br>  Erlang has 4 queues with different priorities: maximum (max), high (high), normal (normal) and low (low).  The scheduler will first look for processes in the queue with a max priority and run them until the queue is empty, then the same with processes in the high queue.  Then, provided that max and high no more processes, the scheduler will start processes with normal priority, until the queue becomes empty, or until the process performs a certain number of reductions, after which the scheduler processes the processes with low priority. <br><br>  The priority of normal and low can change places, for example: you have hundreds of processes with normal priority and several with low, in this case, the scheduler can first execute processes with low priority and only then with normal. <br><br><h5>  2.2 Internal process information </h5><br><br>  Among the many functions for working with processes, there is one very interesting one: erlang: process_info / 1 or erlang: process_info / 2, using this function you can get detailed information about the process dictionary, garbage collector, heap size, linked processes and other interesting things (full see the list in the documentation [1]). <br><br>  The first variant of the function (with one argument) is recommended to be used only for debugging purposes - it gives the complete specification of the process, for the rest it is better to use the second variant. <br><br>  Let's write a simple function that will display the following information about the process: the registered name;  the function by which the process was spawned;  list of linked processes. <br><br><blockquote><ol><li>  -module (test). </li><li>  -export ([info / 1]). </li><li></li><li>  info (pid) -&gt; </li><li>  Spec = [registered_name, initial_call, links], </li><li>  <font color="#000000">case</font> process_info (Pid, Spec) of </li><li>  undefined -&gt; </li><li>  undefined; </li><li>  Result -&gt; </li><li>  [{pid, pid} | Result] </li><li>  end. </li></ol></blockquote><br><br>  In line 5 we create a specification according to which information about the process will be obtained.  Run the shell, compile the module and test. <br><br> <code>3&gt; processes(). <br> [&lt;0.0.0&gt;,&lt;0.3.0&gt;,&lt;0.5.0&gt;,&lt;0.6.0&gt;,&lt;0.8.0&gt;,&lt;0.9.0&gt;,&lt;0.10.0&gt;, <br> &lt;0.11.0&gt;,&lt;0.12.0&gt;,&lt;0.13.0&gt;,&lt;0.14.0&gt;,&lt;0.15.0&gt;,&lt;0.16.0&gt;, <br> &lt;0.17.0&gt;,&lt;0.18.0&gt;,&lt;0.19.0&gt;,&lt;0.20.0&gt;,&lt;0.21.0&gt;,&lt;0.23.0&gt;, <br> &lt;0.24.0&gt;,&lt;0.25.0&gt;,&lt;0.26.0&gt;,&lt;0.30.0&gt;] <br> 4&gt; test:info(pid(0,0,0)). <br> [{pid,&lt;0.0.0&gt;}, <br> {registered_name,init}, <br> {initial_call,{otp_ring0,start,2}}, <br> {links,[&lt;0.5.0&gt;,&lt;0.6.0&gt;,&lt;0.3.0&gt;]}] <br> 5&gt;</code> <br> <br>  In line 3 we get a list of all running processes, then we call our function, which shows that the registered name of the process is &lt;0.0.0&gt; - init, it is generated by calling otp_ring0: start / 2 and three other processes are linked to it. <br><br>  In the next article, we will look at how to link processes with each other and track their status. <br><br><h4>  Bibliography </h4><br>  1. <a href="http://erldocs.com/">Excellent online documentation</a> . <br>  2. <a href="http://www.erlang.org/doc/efficiency_guide/processes.html">Basic information about the processes</a> . <br>  3. <a href="http://habrahabr.ru/blogs/erlang/50561/">On the advanced design of virtual machines</a> . <br>  4. ERLANG Programming by Francesco Cesarini and Simon Thompson <br>  5. <a href="http://www.erlang.org/pipermail/erlang-questions/2001-April/003131.html">About process planning</a> . </div><p>Source: <a href="https://habr.com/ru/post/114232/">https://habr.com/ru/post/114232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114218/index.html">iPADrom - S02E04. IPad Software Review</a></li>
<li><a href="../114224/index.html">Broadcast of the Opera company master class</a></li>
<li><a href="../114225/index.html">London: the pitfalls of buying Apple devices in the UK</a></li>
<li><a href="../114227/index.html">How to torture your project manager</a></li>
<li><a href="../114230/index.html">Cross compilation tools for ARM</a></li>
<li><a href="../114233/index.html">Interface for selecting a location without using directories using Google maps</a></li>
<li><a href="../114234/index.html">Layout mailing: debriefing</a></li>
<li><a href="../114235/index.html">Reactable for iPhone and iPad</a></li>
<li><a href="../114237/index.html">Steering wheel for PC based on Wii Remote</a></li>
<li><a href="../114238/index.html">BIT-2011: Make an investor believe in you!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>