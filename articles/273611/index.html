<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Scalding: a reason to switch from Java to Scala</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about Twitter Scalding - a framework for describing the processing of data in Apache Hadoop. I'll start from afar, with th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Scalding: a reason to switch from Java to Scala</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/743/fd5/585/743fd55850664037b19bb8672aa54b31.png"><br><br>  In this article I will talk about <b>Twitter Scalding</b> - a framework for describing the processing of data in Apache Hadoop.  I'll start from afar, with the history of frameworks over Hadoop.  Then I will give an overview of the possibilities of Scalding.  In conclusion, I‚Äôll show examples of code that can be understood by those who know Java, but are barely familiar with Scala. <br><br>  Interesting?  Go! <br><a name="habracut"></a><br><h2>  Easier than MapReduce </h2><br>  When the MapReduce paradigm was in its infancy, it was a breakthrough step to simplify the development of distributed computing.  However, it soon came to realize that it was very tiring to write mappers and reducer manually.  To speed up development, high-level superstructures appeared above Map / Reduce - Pig, Hive and Cascading, and then others.  Let us dwell on the latter. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Cascading is a Java-framework for describing data processing, the so-called.  workflow.  After the description, Cascading analyzes the workflow like the query analyzers in the DBMS, builds the execution plan as a sequence of map / reduce tasks and sends them to the Hadoop cluster, independently managing their launch and intermediate data.  Unfortunately, Cascading operates with rather low-level abstractions; therefore, for a long time, in terms of popularity, it lost to other data processing mechanisms. <br><br>  From this situation, there was a successful way out.  Twitter adapted Cascading to fit its needs and wrapped its abstractions in traditional Scala tools.  This is how Scalding - Scala framework on top of Cascading was born.  Here you can make a digression and talk about Scala. <br><br><div class="spoiler">  <b class="spoiler_title">Lyrical digression about Scala</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/post/127727/">Scala is complicated</a> .  On the topic of its applicability in industrial development are <a href="http://habrahabr.ru/post/134897/">terrible battles</a> .  In this sensitive issue, I will probably join the conservative supporters of Java.  But I have to admit that there are things that Scala turns out to do better than in other languages, namely, to process data streams and build interflow interaction.  For javista not familiar with Scala, I should note that <a href="http://habrahabr.ru/company/tcsbank/blog/184310/">working with collections</a> , inline processing and functionalism are done in Scala easily and naturally.  The Java Stream API and java.util.functional familiar to you are a dull pale copy of standard Scala tools. <br></div></div><br>  So, the attempt to apply the standard approaches of Scala to the description of the workflow of data processing was crowned with success, and Scalding has a chance to catch up with Hive, Pig and their many new-fashioned analogues.  It turned out so good that for the sake of it it even makes sense to learn Scala, which we now do. <br><br><h2>  Introduction to Scalding </h2><br>  Now I deliberately miss all that concerns the internal structure of Scalding and Cascading.  We assume that this is a black box with a nice interface that counts some data for us.  If everything works out, then there will be another article about the internal structure of these frameworks. <br><br><div class="spoiler">  <b class="spoiler_title">For those who are not familiar with Scala</b> <div class="spoiler_text">  A type declaration goes through the colon after the name of a variable or function. <br><br>  A tuple is a few objects held together.  A classic example of a tuple is Pair, Triple, etc.  In Scala, they are part of the language.  Tuples are written in brackets, separated by commas. <br><br>  Generics are written in square brackets, not in the corner ones. <br><br><pre><code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> longConstant: <span class="hljs-type"><span class="hljs-type">Long</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>L <span class="hljs-comment"><span class="hljs-comment">// final long longConstant = 0L; var list: List[Int] // List&lt;Integer&gt; list; (String, Int) // Pair&lt;String, Integer&gt;</span></span></code> </pre> <br></div></div><br><h3>  Flat operations </h3><br>  The main concept in Scalding is <b>Pipe</b> .  Pipe is a pipeline from which data flows to the programmer.  In fact, this is similar to the Stream from Java 8. The first implementation of Pipe did not support typing, but it did not last long.  Fans of strict typing came up with <b>TypedPipe</b> - a pipeline with objects of a strictly specified type, generic, in terms of Java. <br><br>  For TypedPipe, some standard stream operations are defined ‚Äî <b>map</b> , <b>flatMap</b> , <b>filter</b> , <b>limit,</b> and others.  These are all flat stream operations; theoretically, they can be effectively performed with unlimited parallelism and on any amount of data. <br><br>  Data in TypedPipe should be read from somewhere.  For this, in Scalding there is a <b>Source</b> - data source.  Its only purpose is to spawn Pipe or TypedPipe.  There are several ready-made sources, most of them are reading from files in various formats, but there is also the ability to read from an arbitrary iterator (and, therefore, from a collection in memory) and, of course, the ability to determine its sources.  Importantly, the same Cascading and Scalding code works on both the Hadoop cluster and local data, and it is very convenient for testing. <br><br>  When all operations are done, it is time to save the data.  Sink, the final part of the pipeline, is responsible for writing to the disk in Scalding.  Sinks are similar to Source's, often the same class that implements two interfaces. <br><br><h3>  Grouping operations </h3><br>  MapReduce allows us to reorganize the stream represented by TypedPipe.  First of all, it is the <b>groupBy</b> grouping <b>operation</b> , which groups records from the entire stream by key, analogous to GROUP BY in SQL.  After grouping, TypedPipe [V] takes on a special form <b>Grouped [K, V]</b> , over which additional operations become available. <br><br>  First, using the <b>mapGroup</b> and <b>mapValuesStream methods,</b> you can get Grouped [K, V] elements in the form of a pair from the key K, which was grouped, and an iterator for all V values ‚Äã‚Äãthat came to this key.  Any functions of the Scala collections are applicable to the iterator by values.  But usually this is not even required, because  Grouped has many shortcut functions that cover the most popular cases. <br><br>  Secondly, Grouped can be sorted by the <b>sortBy</b> operation.  After that, the mapGroup, mapValuesStream and all their derivatives are also applicable to it. <br><br>  Thirdly, Grouped [K, V1] can be joined (join) with another Grouped [K, V2].  Here the same rules work as in relational databases - <b>leftJoin</b> , <b>rightJoin</b> , <b>join</b> (inner), <b>outerJoin</b> (full) are available.  The output is Grouped [K, (V1, V2)]. <br><br>  It is worth noting that when an ungrouped stream contains <b>TypedPipe [(K, V)]</b> pairs, the <b>hashJoin</b> operation can be applied to it.  It is similar to the usual Grouped.join, but is done in memory.  This works well for enriching data from small directories, but for large tables it can lead to OOM. <br><br>  Grouped can be converted back to TypedPipe with toTypedPipe, keys or values ‚Äã‚Äãoperations.  The first will save both the key and the value, the rest will return one thing. <br><br><h2>  Scalding by example </h2><br>  Now, after reviewing the main features of the framework, let's see how this works, using an example. <br><br>  Suppose we are an RTB site, and we have a history of our users clicking on URLs on observed sites.  The story is presented in a huge TSV file with three columns - URL, Timestamp and UserId. <br><br>  We also have a layout of sites on topics.  We do not have a lot of sites, maximum, thousands.  All markup is placed in a small TSV file with columns - Domain and Topic. <br><br>  We want to understand how often the user switches between topics.  To do this, we need to leave in the history of clicks only those events when the user navigates from the site of one subject to another site. <br><br>  Let's write the code that will do this transformation for us.  Launch infrastructure will not be considered.  If interested, the full sample code is available <a href="https://github.com/fediq/example-scalding">on github</a> . <br><br>  In Scala, you can set aliases for types.  This is convenient because  will allow us to distinguish one String from another in type declarations. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Domain</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserId</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Topic</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Url</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Timestamp</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Long</span></span></code> </pre><br>  Now we will declare classes from the domain model: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Click</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">url: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Url</span></span></span></span><span class="hljs-class"><span class="hljs-params">, ts: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Timestamp</span></span></span></span><span class="hljs-class"><span class="hljs-params">, userId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">UserId</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SiteInfo</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">domain: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Domain</span></span></span></span><span class="hljs-class"><span class="hljs-params">, topic: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Topic</span></span></span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Case class in Scala is a convenient way to describe classes for immutable values.  A constructor, getters, and other similar code are automatically generated from it. <br><br>  Let's read the table with clicks: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clicksPipe: <span class="hljs-type"><span class="hljs-type">TypedPipe</span></span>[<span class="hljs-type"><span class="hljs-type">Click</span></span>] = <span class="hljs-type"><span class="hljs-type">TypedPipe</span></span>.from(<span class="hljs-type"><span class="hljs-type">TypedTsv</span></span>[(<span class="hljs-type"><span class="hljs-type">Url</span></span>, <span class="hljs-type"><span class="hljs-type">Timestamp</span></span>, <span class="hljs-type"><span class="hljs-type">UserId</span></span>)](pathToClicks)) .map(tuple =&gt; <span class="hljs-type"><span class="hljs-type">Click</span></span>.tupled(tuple))</code> </pre><br>  Here we announced the source - typed TSV with columns of type (String, Long, UserId).  Then we wrapped this source in TypedPipe.  Further, for convenience, we converted tuples from three columns (Url, Timestamp, UserId) into objects of the class Click. <br><br>  It turned out TypedPipe [Click]. <br><br>  Let's leave only domains from urlov. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">url2domain</span></span></span></span>(url: <span class="hljs-type"><span class="hljs-type">Url</span></span>): <span class="hljs-type"><span class="hljs-type">Domain</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">URL</span></span>(url).getHost } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> domainsPipe: <span class="hljs-type"><span class="hljs-type">TypedPipe</span></span>[<span class="hljs-type"><span class="hljs-type">Click</span></span>] = clicksPipe .map(click =&gt; click.copy(url = url2domain(click.url)))</code> </pre><br>  Let's read the directory where the domains are divided by topics, and immediately group it in a form suitable for hashJoin. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> sitesGroupByDomain: <span class="hljs-type"><span class="hljs-type">Grouped</span></span>[<span class="hljs-type"><span class="hljs-type">Domain</span></span>, <span class="hljs-type"><span class="hljs-type">SiteInfo</span></span>] = <span class="hljs-type"><span class="hljs-type">TypedPipe</span></span>.from(<span class="hljs-type"><span class="hljs-type">TypedTsv</span></span>[(<span class="hljs-type"><span class="hljs-type">Domain</span></span>, <span class="hljs-type"><span class="hljs-type">Topic</span></span>)](pathToSites)) .map(tuple =&gt; <span class="hljs-type"><span class="hljs-type">SiteInfo</span></span>.tupled(tuple)) .groupBy(siteInfo =&gt; siteInfo.domain)</code> </pre><br>  Add to the flow of clicks information about the subjects of sites.  To do this, join the stream of clicks from the directory of domains. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clicksWithSiteInfo: <span class="hljs-type"><span class="hljs-type">TypedPipe</span></span>[(<span class="hljs-type"><span class="hljs-type">Domain</span></span>, (<span class="hljs-type"><span class="hljs-type">Click</span></span>, <span class="hljs-type"><span class="hljs-type">SiteInfo</span></span>))] = domainsPipe .map(click =&gt; (click.url, click)) .hashJoin(sitesGroupByDomain)</code> </pre><br>  Group the flow of clicks by users and sort by click timestamp.  In addition, we are no longer interested in information about the domain, just enough information about the subject of the site.  To do this, we introduce an auxiliary class that reflects the user's active interest in the topic at a time. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TopicActivity</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">topic: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Topic</span></span></span></span><span class="hljs-class"><span class="hljs-params">, ts: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Timestamp</span></span></span></span><span class="hljs-class"><span class="hljs-params">, userId: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">UserId</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">topicActivityStreamPerUser</span></span></span></span>: <span class="hljs-type"><span class="hljs-type">SortedGrouped</span></span>[<span class="hljs-type"><span class="hljs-type">UserId</span></span>, <span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>] = clicksWithSiteInfo .map(tuple =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (domain, (click, siteInfo)) = tuple <span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>(siteInfo.topic, click.ts, click.userId) }) .groupBy(activity =&gt; activity.userId) .sortBy(activity =&gt; activity.ts)</code> </pre><br>  The most difficult moment - in the stream of user activities you need to catch the moments of switching topics.  To catch switching we will write a function on Scala in Java-style.  It accumulates the result in an ArrayBuffer (analogous to an ArrayList), which can potentially lead to OOM on very long stories. <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topicSwitches</span></span></span></span>(userId: <span class="hljs-type"><span class="hljs-type">UserId</span></span>, activities: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>[<span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>]): <span class="hljs-type"><span class="hljs-type">Iterator</span></span>[<span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> result = <span class="hljs-type"><span class="hljs-type">ArrayBuffer</span></span>[<span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>]() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> firstTs = <span class="hljs-number"><span class="hljs-number">0</span></span>l <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastTopic = <span class="hljs-literal"><span class="hljs-literal">null</span></span>.asInstanceOf[<span class="hljs-type"><span class="hljs-type">Topic</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (activity &lt;- activities) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (firstTs == <span class="hljs-number"><span class="hljs-number">0</span></span>l || lastTopic != activity.topic) { result.append(activity) firstTs = activity.ts lastTopic = activity.topic } } result.toIterator } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstTopicActivitiesPipe: <span class="hljs-type"><span class="hljs-type">TypedPipe</span></span>[<span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>] = topicActivityStreamPerUser .mapGroup((userId, activities) =&gt; topicSwitches(userId, activities)) .values</code> </pre><br>  Only the first activities of each interest remained in the stream.  By them it is possible to trace how the user's interest focus changed over time.  It remains to write the result to the file. <br><br><pre> <code class="scala hljs">firstTopicActivitiesPipe .map(activity =&gt; (activity.topic, activity.ts, activity.userId)) .write(<span class="hljs-type"><span class="hljs-type">TypedTsv</span></span>(args.required(<span class="hljs-string"><span class="hljs-string">"output"</span></span>)))</code> </pre><br>  That's all.  We have described a nontrivial transformation of data literally in 40 lines. <br><br><h2>  The final code in scala-way </h2><br>  If you follow the canonical scala-way, then the code will turn out even shorter.  In addition, you can rewrite the search function switching between topics from an iterative approach to a functional one by removing the use of the buffer.  Now the process does not fall even at the endless entrance.  In theory‚Ä¶ <br><br><pre> <code class="scala hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">topicSwitches</span></span></span></span>(userId: <span class="hljs-type"><span class="hljs-type">UserId</span></span>, activities: <span class="hljs-type"><span class="hljs-type">Iterator</span></span>[<span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>]): <span class="hljs-type"><span class="hljs-type">Iterator</span></span>[<span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>] = { activities.scanLeft(<span class="hljs-type"><span class="hljs-type">Helper</span></span>())((helper, activity) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (helper.topic.isEmpty || helper.topic.get != activity.topic) { <span class="hljs-type"><span class="hljs-type">Helper</span></span>(<span class="hljs-type"><span class="hljs-type">Some</span></span>(activity.topic), activity.ts, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-type"><span class="hljs-type">Helper</span></span>(helper.topic, helper.firstTs, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) } }).filter(_.firstVisit).map(helper =&gt; <span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>(helper.topic.get, helper.firstTs, userId)) } <span class="hljs-type"><span class="hljs-type">TypedPipe</span></span>.from(<span class="hljs-type"><span class="hljs-type">TypedTsv</span></span>[(<span class="hljs-type"><span class="hljs-type">Url</span></span>, <span class="hljs-type"><span class="hljs-type">Timestamp</span></span>, <span class="hljs-type"><span class="hljs-type">UserId</span></span>)](pathToClicks)) .map(tuple =&gt; <span class="hljs-type"><span class="hljs-type">Click</span></span>.tupled(tuple)) .map(click =&gt; click.copy(url = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-type"><span class="hljs-type">URL</span></span>(click.url).getHost)) .map(click =&gt; (click.url, click)) .hashJoin( <span class="hljs-type"><span class="hljs-type">TypedPipe</span></span>.from(<span class="hljs-type"><span class="hljs-type">TypedTsv</span></span>[(<span class="hljs-type"><span class="hljs-type">Domain</span></span>, <span class="hljs-type"><span class="hljs-type">Topic</span></span>)](pathToSites)) .map(tuple =&gt; <span class="hljs-type"><span class="hljs-type">SiteInfo</span></span>.tupled(tuple)) .groupBy(_.domain) ) .map({<span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (_, (click, siteInfo)) =&gt; <span class="hljs-type"><span class="hljs-type">TopicActivity</span></span>(siteInfo.topic, click.ts, click.userId)}) .groupBy(_.userId) .sortBy(_.ts) .mapGroup(topicSwitches) .values .write(<span class="hljs-type"><span class="hljs-type">TypedTsv</span></span>(outputPath))</code> </pre><br>  In the following articles, I will deal with the organization of the streaming code and its testing.  And, in the end, I will tell you how it all works from the inside. <br><br><div class="spoiler">  <b class="spoiler_title">Disclaimer</b> <div class="spoiler_text">  I wrote the example code as clear as possible to a Java programmer, avoiding any magic transformations and not saving on bytes.  This is to show that you can add a little Scala to ETL processes quickly and painlessly.  The code is not optimal.  If you know a way to write more effectively - you are well done. <br></div></div><br><hr><br><h2>  Resources </h2><br>  <a href="https://github.com/fediq/article-2015-scalding-example">Full github example code</a> <br>  <a href="https://github.com/twitter/scalding/wiki">Scalding wiki</a> <br>  <a href="http://www.amazon.com/Programming-MapReduce-Scalding-Antonios-Chalkiopoulos/dp/1783287012">Book ‚ÄúProgramming MapReduce with Scalding‚Äù</a> </div><p>Source: <a href="https://habr.com/ru/post/273611/">https://habr.com/ru/post/273611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../273599/index.html">Capital Projects: from idea to specifications and drawings</a></li>
<li><a href="../273601/index.html">Stephen Wolfram‚Äôs Book An Elementary Introduction to the Wolfram Language</a></li>
<li><a href="../273603/index.html">Results of 2015: mobile solutions market</a></li>
<li><a href="../273605/index.html">Recipes from CHEF: automated deployment of business application environments using HPE OneView</a></li>
<li><a href="../273607/index.html">Data Driven Realtime Rule Engine in Wargaming: Data Collection</a></li>
<li><a href="../273613/index.html">Price of using frameworks</a></li>
<li><a href="../273615/index.html">Developing applications on Yii2 without experience - a direct path to AD</a></li>
<li><a href="../273617/index.html">Remote registration of SPD (FOP) in Ukraine - 2.0</a></li>
<li><a href="../273619/index.html">Powershell String Optimization</a></li>
<li><a href="../273621/index.html">Playing in the hospital or as we studied and tested the work of the health care system in a European country</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>