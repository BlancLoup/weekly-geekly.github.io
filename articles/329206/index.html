<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>You measure CPU usage incorrectly.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="That metric that we call ‚Äúprocessor load‚Äù is actually understood by some people not quite right. What is the "CPU load"? Is this how busy our processo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>You measure CPU usage incorrectly.</h1><div class="post__text post__text-html js-mediator-article">  That metric that we call ‚Äúprocessor load‚Äù is actually understood by some people not quite right.  What is the "CPU load"?  Is this how busy our processor is?  No, it is not.  Yes, yes, I'm talking about the very same CPU usage that all performance analysis utilities show, from Windows Task Manager to top Linux command. <br><br>  This is what ‚Äú90% processor is loaded now‚Äù?  Perhaps you think it looks something like this: <br><br><img src="https://habrastorage.org/web/7f9/8c1/bfe/7f98c1bfeaf742c3a8f7b4b0cf040a19.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But in fact it looks like this: <br><br><img src="https://habrastorage.org/web/f35/af4/3af/f35af43aff7e4633b5c7fe85410cfab4.png"><br><br>  ‚ÄúRunning idle‚Äù means that the processor is able to execute some instructions, but does not, because it is expecting something ‚Äî for example, input / output of data from the main memory.  The percentage of real and ‚Äúidle‚Äù work in the figure above is what I see day after day in the work of real applications on real servers.  There is a substantial probability that your program spends its time in much the same way, and you don‚Äôt know about it. <br><a name="habracut"></a><br>  What does this mean to you?  Understanding how much time the processor actually performs some operations, and how much it just waits for data, sometimes it gives you the opportunity to change your code, reducing the exchange of data with RAM.  This is especially true in the current realities of cloud platforms, where the policies of automatic scaling are sometimes directly tied to the CPU load, which means that every extra tact of ‚Äúidle‚Äù work costs us real money. <br><br><h3>  What is the CPU load really? </h3><br>  That metric that we call ‚Äúprocessor load‚Äù actually means something like ‚Äúnon-idle time‚Äù: that is, this is the amount of time that the processor spent in all threads except the special ‚ÄúIdle‚Äù stream.  The kernel of your operating system (whatever it is) measures this amount of time when switching context between threads of execution.  If the flow of command execution has been switched to a non-idle thread that has worked for 100 milliseconds, then the OS kernel regards this time as the time spent by the CPU on performing real work in this thread. <br><br>  This metric first appeared in this form simultaneously with the advent of time-sharing operating systems.  The computer programmer‚Äôs manual in the lunar module of the Appolon spacecraft (the advanced time-sharing system) called its idle stream with the special name DUMMY JOB and the engineers compared the number of commands executed by this thread to the number of commands executed by the worker threads. gave them an understanding of CPU usage. <br><br>  So what's wrong with this approach? <br><br>  Today, processors are much faster than RAM, and waiting for data has taken up the lion's share of the time that we used to call "CPU time."  When you see a high percentage of CPU utilization in the output of the top command, you can decide that the processor is a bottleneck (the piece of hardware on the motherboard under the radiator and cooler), although in reality it will be a completely different device - memory banks. <br><br>  The situation even worsens with time.  For a long time, processor manufacturers managed to increase the speed of their cores faster than memory manufacturers increased their access speed and reduced delays.  Somewhere in 2005, processors with a frequency of 3 Hz appeared on the market and manufacturers concentrated on increasing the number of cores, hyper trading, multi-socket configurations - and all this put even greater demands on the speed of data exchange!  Processor manufacturers have tried to somehow solve the problem by increasing the size of the processor caches, faster tires, etc.  This, of course, helped a little, but did not change the situation drastically.  We are already waiting for the memory most of the time "CPU load" and the situation is only getting worse. <br><br><h3>  How to understand what the processor actually does </h3><br>  Using hardware performance counters.  On Linux, they can be read with <a href="http://www.brendangregg.com/perf.html">perf</a> and other similar tools.  Here, for example, measuring the performance of the entire system for 10 seconds: <br><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># perf stat -a -- sleep 10 Performance counter stats for 'system wide': 641398.723351 task-clock (msec) # 64.116 CPUs utilized (100.00%) 379,651 context-switches # 0.592 K/sec (100.00%) 51,546 cpu-migrations # 0.080 K/sec (100.00%) 13,423,039 page-faults # 0.021 M/sec 1,433,972,173,374 cycles # 2.236 GHz (75.02%) &lt;not supported&gt; stalled-cycles-frontend &lt;not supported&gt; stalled-cycles-backend 1,118,336,816,068 instructions # 0.78 insns per cycle (75.01%) 249,644,142,804 branches # 389.218 M/sec (75.01%) 7,791,449,769 branch-misses # 3.12% of all branches (75.01%) 10.003794539 seconds time elapsed</span></span></code> </pre> <br>  The key metric here is the " <b>number of instructions per cycle</b> " (insns per cycle: IPC), which shows how many instructions the processor has executed on average for each of its cycles.  Simplified: the more this number, the better.  In the example above, this number is equal to 0.78, which, at first glance, does not seem to be such a bad result (78% of the time the useful work was done?).  But no, on this processor, the maximum possible IPC value could be 4.0 (this is related to the method of receiving and executing instructions by modern processors).  That is, our IPC value (equal to 0.78) is only 19.5% of the maximum possible speed of executing instructions.  And in Intel processors starting from Skylake, the maximum IPC value is already 5.0. <br><br><h4>  In the clouds </h4><br>  When you work in a virtual environment, you may not have access to real performance counters (this depends on the hypervisor used and its settings).  Here is an article on how it works in <a href="http://www.brendangregg.com/blog/2017-05-04/the-pmcs-of-ec2.html">Amazon EC2</a> . <br><br><h3>  Data Interpretation and Response </h3><br>  If you have <b>IPC &lt;1.0</b> , then I congratulate you, your application is idle while waiting for data from RAM.  Your strategy for optimizing performance in this case will not be a reduction in the number of instructions in the code, but a reduction in the number of memory accesses, more active use of caches, especially on NUMA systems.  From a hardware point of view (if you can influence this) it is wise to choose processors with larger cache sizes, faster memory and bus. <br><br>  If you have <b>IPC&gt; 1.0</b> , then your application suffers not so much from waiting for data, but from an excessive amount of instructions being executed.  Look for more efficient algorithms, do not do unnecessary work, cache the results of repeated operations.  Using <a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html">Flame Graphs</a> build and analysis tools can be a great way to figure out the situation.  From a hardware point of view, you can use faster processors and increase the number of cores. <br><br>  As you can see, I drew a line on the IPC value of 1.0.  Where did I get this number?  I calculated it for my platform, and you, if you do not trust my estimate, can calculate it for yours.  To do this, write two applications: one must load the processor 100% in the execution flow of instructions (without actively accessing large blocks of RAM), and the other must conversely actively manipulate the data in RAM, avoiding heavy calculations.  Measure the IPC for each of them and take the average.  This will be an approximate turning point for your architecture. <br><br><h3>  What performance monitoring tools really should show </h3><br>  I believe that every performance monitoring tool should show the IPC value next to the processor load.  This is done, for example, in the Linux tiptop tool: <br><br><pre> <code class="bash hljs">tiptop - [root] Tasks: 96 total, 3 displayed screen 0: default PID [ %CPU] %SYS P Mcycle Minstr IPC %MISS %BMIS %BUS COMMAND 3897 35.3 28.5 4 274.06 178.23 0.65 0.06 0.00 0.0 java 1319+ 5.5 2.6 6 87.32 125.55 1.44 0.34 0.26 0.0 nm-applet 900 0.9 0.0 6 25.91 55.55 2.14 0.12 0.21 0.0 dbus-daemo</code> </pre> <br><h3>  Other reasons for the misinterpretation of the term "CPU usage" </h3><br>  The processor can perform its work more slowly, not only because of the loss of time waiting for data from RAM.  Other factors may be: <br><br><ul><li>  CPU temperature drops </li><li>  Variable frequency processor technology Turboboost </li><li>  CPU core frequency variation </li><li>  The problem of average calculations: 80% of the average load on the measurement period per minute may not be catastrophic, but they can hide in themselves jumps up to 100% </li><li>  Spin-locks: the processor is loaded with instructions and has a high IPC, but in fact the application is in spin-locks and does not perform any real work </li></ul><br><h3>  findings </h3><br>  The processor load has now become a substantially misunderstood metric: it includes the time it takes to wait for data from RAM, which can take even more time than executing real commands.  You can determine the actual CPU usage by using additional metrics, such as the number of instructions per cycle (IPC).  Values ‚Äã‚Äãsmaller than 1.0 indicate that you are resting on the speed of data exchange with memory, and large values ‚Äã‚Äãindicate that the processor is very busy with instructions.  Performance measurement tools need to be improved to display IPC (or something similar) directly next to the processor load, which will give the user a complete understanding of the situation.  Having all these data, developers can take some measures to optimize their code in precisely those aspects where it will bring the greatest benefit. </div><p>Source: <a href="https://habr.com/ru/post/329206/">https://habr.com/ru/post/329206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../329196/index.html">How to quickly set up autoposting for Facebook and Twitter</a></li>
<li><a href="../329198/index.html">We invite you to a meeting of ThinkJava # 5 in Kharkov</a></li>
<li><a href="../329200/index.html">ArcaOS 5.0 - a new version of OS / 2 has become available to the public.</a></li>
<li><a href="../329202/index.html">Nimble Storage on HPE: How InfoSight allows you to see the invisible in your infrastructure</a></li>
<li><a href="../329204/index.html">Performance comparison of hierarchical models of Django and PostgreSQL</a></li>
<li><a href="../329208/index.html">Issue # 2: IT training - current issues and challenges from leading companies</a></li>
<li><a href="../329212/index.html">Play music on RIT ++</a></li>
<li><a href="../329214/index.html">Korean colleagues: understand and forgive</a></li>
<li><a href="../329216/index.html">The reverse side of recruitment: what HR technologies have changed for candidates</a></li>
<li><a href="../329218/index.html">Beyond the clouds: what is serverless and why do we misunderstand it?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>