<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lambda: from C ++ 11 to C ++ 20. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good afternoon friends. Today we have prepared for you a translation of the first part of the article ‚ÄúLambdas: From C ++ 11 to C ++ 20‚Äù . The publica...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lambda: from C ++ 11 to C ++ 20. Part 1</h1><div class="post__text post__text-html js-mediator-article"> Good afternoon friends.  Today we have prepared for you a translation of the first part of the article <a href="https://www.bfilipek.com/2019/02/lambdas-story-part1.html%3Fm%3D1">‚ÄúLambdas: From C ++ 11 to C ++ 20‚Äù</a> .  The publication of this material is timed to the launch of the <a href="https://otus.pw/d3Uc/">‚ÄúDeveloper C ++‚Äù</a> course, which starts tomorrow. <br><br>  Lambda expressions are one of the most powerful additions in C ++ 11 and continue to evolve with each new language standard.  In this article, we will go through their history and look at the evolution of this important part of modern C ++. <br><br><img src="https://habrastorage.org/webt/s8/xa/l8/s8xal8zqrhmjeh-omwslxujvsmw.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The second part is available at the link: <br>  <a href="https://www.bfilipek.com/2019/03/lambdas-story-part2.html">Lambdas: From C ++ 11 to C ++ 20, Part 2</a> <br><a name="habracut"></a><br>  <b>Introduction</b> <br><br>  At one of the local meetings of the C ++ User Group, we had a live programming session on the ‚Äúhistory‚Äù of lambda expressions.  The conversation was conducted by a C ++ expert Tomasz Kami≈Ñski ( <a href="https://www.linkedin.com/in/tomasz-kami%25C5%2584ski-208572b1/">see Thomas‚Äôs LinkedIn profile</a> ).  Here is the event: <br><br>  <a href="https://www.meetup.com/pl-PL/C-User-Group-Cracow/events/258795519/">Lambdas: From C ++ 11 to C ++ 20 - C ++ User Group Krakow</a> <br><br>  I decided to take the code from Thomas (with his permission!), Describe it and create a separate article. <br><br>  We begin by learning C ++ 03 and the need for compact local functional expressions.  Then we move on to C ++ 11 and C ++ 14.  In the second part of the series, we will see changes in C ++ 17 and even take a look at what happens in C ++ 20. <br><br>  <b>Lambda in C ++ 03</b> <br><br>  From the very beginning, STL <code>std::algorithms</code> , such as <code>std::sort</code> , could accept any callable object and call it on container elements.  However, in C ++ 03, this involved only pointers to functions and functors. <br><br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; struct PrintFunctor { void operator()(int x) const { std::cout &lt;&lt; x &lt;&lt; std::endl; } }; int main() { std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); std::for_each(v.begin(), v.end(), PrintFunctor()); }</span></span></span></span></code> </pre> <br>  Launch code: <a href="https://wandbox.org/permlink/7OGJzJlfg40SSQUG">@Wandbox</a> <br><br>  But the problem was that you had to write a separate function or functor in a different scope, and not in the scope of the algorithm call. <br><br>  As a potential solution, you might consider writing a local class of functors - since C ++ always supports this syntax.  But it does not work ... <br><br>  Look at this code: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PrintFunctor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; v; v.push_back(<span class="hljs-number"><span class="hljs-number">1</span></span>); v.push_back(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(v.begin(), v.end(), PrintFunctor()); }</code> </pre> <br>  Try compiling it with <code>-std=c++98</code> , and you will see the following error in GCC: <br><br><pre> <code class="cpp hljs">error: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-string"><span class="hljs-string">'template&lt;class _IIter, class _Funct&gt; _Funct std::for_each(_IIter, _IIter, _Funct)'</span></span> uses local type <span class="hljs-string"><span class="hljs-string">'main()::PrintFunctor'</span></span></code> </pre> <br>  In fact, in C ++ 98/03 you cannot create an instance of a template with a local type. <br>  Due to all these restrictions, the Committee began to develop a new feature, which we can create and call "on the spot" ... "lambda expressions"! <br><br>  If we look at <a href="https://timsong-cpp.github.io/cppwp/n3337/">N3337</a> - the final version of C ++ 11, we will see a separate section for lambda: <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">[expr.prim.lambda]</a> . <br><br>  <b>Coming to C ++ 11</b> <br><br>  I think that lambdas have been added to the language wisely.  They use the new syntax, but then the compiler "extends" it to a real class.  Thus, we have all the advantages (and sometimes disadvantages) of a real strongly typed language. <br><br>  Here is a basic code example that also shows the corresponding local functor object: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; int main() { struct { void operator()(int x) const { std::cout &lt;&lt; x &lt;&lt; '\n'; } } someInstance; std::vector&lt;int&gt; v; v.push_back(1); v.push_back(2); std::for_each(v.begin(), v.end(), someInstance); std::for_each(v.begin(), v.end(), [] (int x) { std::cout &lt;&lt; x &lt;&lt; '\n'; } ); }</span></span></span></span></code> </pre> <br>  Example: <a href="https://wandbox.org/permlink/86wzD14LVEnMiO2Y">@WandBox</a> <br><br>  You can also check out CppInsights, which shows how the compiler extends the code: <br><br>  Take a look at this example: <br><br>  <a href="https://cppinsights.io/lnk%3Fcode%3DI2luY2x1ZGUgPGlvc3RyZWFtPgojaW5jbHVkZSA8YWxnb3JpdGhtPgojaW5jbHVkZSA8dmVjdG9yPgoKaW50IG1haW4oKQp7ICAgCiAgICBzdGQ6OnZlY3RvcjxpbnQ%2BIHY7CiAgICB2LnB1c2hfYmFjaygxKTsKICAgIHYucHVzaF9iYWNrKDIpOwogIAlhdXRvIGxhbSA9IFtdIChpbnQgeCkgIHsgc3RkOjpjb3V0IDw8IHggPDwgc3RkOjplbmRsOyB9OwogICAgLy9kZWNsdHlwZShsYW0pIHR0dDsKICAgIHN0ZDo6Zm9yX2VhY2godi5iZWdpbigpLCB2LmVuZCgpLCBsYW0pOyAgICAKfQ%3D%3D%26std%3Dcpp11%26rev%3D1.0">CppInsighs: lambda test</a> <br><br>  In this example, the compiler converts: <br><br><pre> <code class="cpp hljs">[] (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }</code> </pre> <br><br>  In something like this (simplified form): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } } someInstance;</code> </pre> <br>  Syntax lambda expression: <br><br><pre> <code class="cpp hljs">[] () { ; } ^ ^ ^ | | | | | : <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span>, exception, trailing <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, ... | | |   |     </code> </pre><br>  Some definitions before we begin: <br><br>  From <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">[expr.prim.lambda # 2]</a> : <br><br>  Calculating lambda expressions results in a temporary prvalue.  This temporary object is called a <i>closure object</i> . <br><br>  And from <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">[expr.prim.lambda # 3]</a> : <br><br>  The type of lambda expression (which is also the type of the closure object) is a unique nameless non-union class type, which is called the <i>closure type</i> . <br><br>  Some examples of lambda expressions are: <br><br>  For example: <br><br><pre> <code class="cpp hljs">[](<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> f, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a*f; } [](MyClass t) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = t.compute(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a &lt; b; }</code> </pre> <br>  <b>Lambda type</b> <br><br>  Since the compiler generates a unique name for each lambda, it is not possible to recognize it in advance. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myLambda = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">2.0</span></span> * a; }</code> </pre> <br>  Moreover <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">[expr.prim.lambda]</a> : <br>  The type of closure associated with a lambda expression has a remote ([dcl.fct.def.delete]) default constructor and an assignment operator. <br><br>  Therefore you cannot write: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [&amp;x, &amp;y]() { ++x; ++y; }; <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(foo) fooCopy;</code> </pre> <br>  This will result in the following error in GCC: <br><br><pre> <code class="cpp hljs">error: use of deleted function <span class="hljs-string"><span class="hljs-string">'main()::&lt;lambda()&gt;::&lt;lambda&gt;()'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(foo) fooCopy; ^~~~~~~ note: a lambda closure type has a deleted <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> constructor</code> </pre> <br>  <b>Call operator</b> <br><br>  The code that you put in the body of the lambda is ‚Äútranslated‚Äù into the operator () code of the corresponding type of closure. <br><br>  By default, this is a built-in constant method.  You can change it by specifying mutable after declaring parameters: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> myLambda = [](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a) <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a; }</code> </pre> <br>  Although the constant method is not a ‚Äúproblem‚Äù for lambda without an empty capture list ... it matters when you want to capture something. <br><br>  <b>Capture</b> <br><br>  [] not only introduces lambda, but also contains a list of captured variables.  This is called a "capture list." <br><br>  By capturing a variable, you create a member copy of this variable in the closure type.  Then inside the body of the lambda you can access it. <br><br>  The basic syntax is: <br><br><ul><li>  [&amp;] - capture by reference, all variables in automatic storage are declared in scope </li><li>  [=] - capture by value, value is copied </li><li>  [x, &amp; y] - clearly captures x by value, and y by reference </li></ul><br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [&amp;x, &amp;y]() { ++x; ++y; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  You can play around with a complete example here: <a href="https://wandbox.org/permlink/da9ltcv53ECxnoEk">@Wandbox</a> <br><br>  Although specifying <code>[=]</code> or <code>[&amp;]</code> may be convenient - since it captures all variables in automatic storage, it is more obvious to capture variables explicitly.  Thus, the compiler can warn you about unwanted effects (see, for example, notes on global and static variables) <br><br>  You can also read more in paragraph 31 of Scott Meyers Effective Modern C ++: ‚ÄúAvoid default capture modes.‚Äù <br><br>  And an important quote: <br><blockquote>  C ++ closures do not increase the lifetime of captured links. </blockquote><br><br>  <b>Mutable</b> <br><br>  By default, operator () of the closure type is constant, and you cannot change the captured variables inside the body of the lambda expression. <br>  If you want to change this behavior, you need to add the mutable keyword after the parameter list: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [x, y]() <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { ++x; ++y; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">" "</span></span> &lt;&lt; y &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre> <br>  In the example above, we can change the values ‚Äã‚Äãof x and y ... but these are only copies of x and y from the attached scope. <br><br>  <b>Global variable capture</b> <br><br>  If you have a global value, and then you use [=] in lambda, you might think that the global value is also captured by value ... but it is not. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> global = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [=] () <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { ++global; }; foo(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; [] { ++global; } (); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; global &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; [global] { ++global; } (); }</code> </pre> <br>  Play with the code here: <a href="https://wandbox.org/permlink/hsS8K0I6PrRyX45Z">@Wandbox</a> <a href="https://wandbox.org/permlink/hsS8K0I6PrRyX45Z"><br></a> <br>  Only variables in automatic storage are captured.  GCC may even issue the following warning: <br><br><pre> <code class="cpp hljs">warning: capture of variable <span class="hljs-string"><span class="hljs-string">'global'</span></span> with non-automatic storage duration</code> </pre> <br>  This warning will appear only if you explicitly capture a global variable, so if you use <code>[=]</code> , the compiler will not help you. <br>  The Clang compiler is more useful because it generates an error: <br><br><pre> <code class="cpp hljs">error: <span class="hljs-string"><span class="hljs-string">'global'</span></span> cannot be captured because it does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> have automatic storage duration</code> </pre> <br>  See <a href="https://wandbox.org/permlink/p5Ro10V3l0tLcYkk">@Wandbox</a> <br><br>  <b>Capturing Static Variables</b> <br><br>  Capturing static variables is similar to capturing global variables: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; void bar() { static int static_int = 10; std::cout &lt;&lt; static_int &lt;&lt; std::endl; auto foo = [=] () mutable { ++static_int; }; foo(); std::cout &lt;&lt; static_int &lt;&lt; std::endl; [] { ++static_int; } (); std::cout &lt;&lt; static_int &lt;&lt; std::endl; [static_int] { ++static_int; } (); } int main() { bar(); }</span></span></span></span></code> </pre> <br>  Play with the code here: <a href="https://wandbox.org/permlink/YSF2px6Sjy7z5GqF">@Wandbox</a> <br><br>  Conclusion: <br><br><pre> <code class="cpp hljs"><span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span></code> </pre> <br>  Again, a warning will appear only if you explicitly capture a static variable, so if you use <code>[=]</code> , the compiler will not help you. <br><br>  <b>Class member grabbing</b> <br><br>  Do you know what will happen after executing the following code: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; struct Baz { std::function&lt;void()&gt; foo() { return [=] { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } std::string s; }; int main() { auto f1 = Baz{"ala"}.foo(); auto f2 = Baz{"ula"}.foo(); f1(); f2(); }</span></span></span></span></code> </pre><br>  The code declares a Baz object, and then calls <code>foo()</code> .  Note that <code>foo()</code> returns a lambda (stored in <code>std::function</code> ) that captures a member of the class. <br><br>  Since we use temporary objects, we cannot be sure what will happen when we call f1 and f2.  This is a hanging link problem that gives rise to undefined behavior. <br><br>  Similarly: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function">&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; }; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp;&amp; f1 = Bar{<span class="hljs-string"><span class="hljs-string">"ala"</span></span>}.foo(); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre> <br>  Play with the <a href="https://wandbox.org/permlink/ntaWn7p4MVVT6fZj">@Wandbox</a> code <br><br>  Again, if you specify the capture explicitly ([s]): <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>()&gt; foo() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s] { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; }</code> </pre><br>  The compiler will prevent your error: <br><br><pre> <code class="cpp hljs">In member function <span class="hljs-string"><span class="hljs-string">'std::function&lt;void()&gt; Baz::foo()'</span></span>: error: capture of non-variable <span class="hljs-string"><span class="hljs-string">'Baz::s'</span></span> error: <span class="hljs-string"><span class="hljs-string">'this'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> captured <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> lambda function ...</code> </pre> <br>  See an example: <a href="https://wandbox.org/permlink/VrQzw8xJgihA0M18">@Wandbox</a> <br><br>  <b>Move-able-only objects</b> <br><br>  If you have an object that can only be moved (for example, unique_ptr), then you cannot put it in the lambda as a captured variable.  Capture by value does not work, so you can only capture by reference ... however, this will not give you possession, and probably this is not what you wanted. <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; p(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">10</span></span>}); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [p] () {}; <span class="hljs-comment"><span class="hljs-comment">//  ....</span></span></code> </pre><br>  <b>Saving constants</b> <br><br>  If you capture a constant variable, then the constancy is preserved: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [x] () <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_const&lt;<span class="hljs-keyword"><span class="hljs-keyword">decltype</span></span>(x)&gt;::value &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; x = <span class="hljs-number"><span class="hljs-number">11</span></span>; }; foo();</code> </pre> <br>  See code: <a href="https://wandbox.org/permlink/pbnGo223HNdOoNLQ">@Wandbox</a> <br><br>  <b>Return type</b> <br><br>  In C ++ 11, you can skip the <code>trailing</code> return type of lambda, and then the compiler will output it for you. <br><br>  Initially, the output of the return type was limited to lambdas containing a single return statement, but this restriction was quickly removed, since there were no problems with implementing a more convenient version. <br><br>  See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html">C ++ Standard Core Language Defect Reports and Accepted Issues</a> (thanks to Thomas for finding the right link!) <br><br>  Thus, starting with C ++ 11, the compiler can infer the type of the return value if all return operators can be converted to the same type. <br><blockquote>  If all return statements return an expression and the types of expressions returned after the conversion, lvalue-to-rvalue (7.1 [conv.lval]), array-to-pointer (7.2 [conv.array]), and function-to-pointer (7.3 [conv. func]) is the same as the general type; <br></blockquote><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> baz = [] () { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( x &lt; <span class="hljs-number"><span class="hljs-number">20</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">1.1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * <span class="hljs-number"><span class="hljs-number">2.1</span></span>; };</code> </pre><br>  Play around with the code here: <a href="https://wandbox.org/permlink/kVKjlBObC9futJNV">@Wandbox</a> <br><br>  There are two <code>return</code> in the above lambda, but they all indicate <code>double</code> , so the compiler can infer the type. <br><br>  <b>IIFE - Immediately Called Expressions (Immediately Invoked Function Expression)</b> <br><br>  In our examples, I defined a lambda, and then called it using the closure object ... but it can also be called immediately: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">1</span></span>, y = <span class="hljs-number"><span class="hljs-number">1</span></span>; [&amp;]() { ++x; ++y; }(); <span class="hljs-comment"><span class="hljs-comment">// &lt;-- call () std::cout &lt;&lt; x &lt;&lt; " " &lt;&lt; y &lt;&lt; std::endl;</span></span></code> </pre> <br>  Such an expression can be useful for complex initialization of constant objects. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> val = []() { <span class="hljs-comment"><span class="hljs-comment">/*   ... */</span></span> }();</code> </pre> <br>  I wrote more about this in post <a href="https://www.bfilipek.com/2016/11/iife-for-complex-initialization.html">IIFE for Complex Initialization</a> . <br><br>  <b>Conversion to function pointer</b> <br><blockquote>  The closure type for a non-capture lambda expression has an open non-virtual implicit constant conversion function to a pointer to a function that has the same parameter and return types as the closure type function call operator.  The value returned by this conversion function must be the address of a function that, when called, has the same effect as calling a function operator of a type similar to a closure type. </blockquote>  In other words, you can convert lambda without captures to a function pointer. <br><br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; void callWith10(void(* bar)(int)) { bar(10); } int main() { struct { using f_ptr = void(*)(int); void operator()(int s) const { return call(s); } operator f_ptr() const { return &amp;call; } private: static void call(int s) { std::cout &lt;&lt; s &lt;&lt; std::endl; }; } baz; callWith10(baz); callWith10([](int x) { std::cout &lt;&lt; x &lt;&lt; std::endl; }); }</span></span></span></span></code> </pre> <br>  Play around with the code here: <a href="https://wandbox.org/permlink/tSZDkOpqQl4EdTp6">@Wandbox</a> <br><br>  <b>Improvements in C ++ 14</b> <br><br>  Standard <a href="https://timsong-cpp.github.io/cppwp/n4140/">N4140</a> and lambda: <a href="https://timsong-cpp.github.io/cppwp/n4140/expr.prim.lambda">[expr.prim.lambda]</a> . <br><br>  C ++ 14 added two significant improvements to lambda expressions: <br><br><ul><li>  Captures with initializer </li><li>  Common lambda </li></ul><br>  These features solve several problems that were visible in C ++ 11. <br><br>  <b>Return type</b> <br><br>  The output type of the return value of the lambda expression has been updated to conform to the automatic inference rules for functions. <br><br>  <a href="https://timsong-cpp.github.io/cppwp/n4140/expr.prim.lambda">[expr.prim.lambda # 4]</a> <br><blockquote>  The lambda return type is auto, which is replaced by the trailing return type if it is provided and / or derived from return statements, as described in [dcl.spec.auto]. </blockquote>  <b>Captures with initializer</b> <br><br>  In short, we can create a new member variable of closure type and then use it inside a lambda expression. <br><br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y = <span class="hljs-number"><span class="hljs-number">11</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [z = x+y]() { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; z &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }; foo(); }</code> </pre> <br>  This can solve several problems, for example, with types that are only available for movement. <br><br>  <b>Move</b> <br><br>  Now we can move the object to the closure type member: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; int main() { std::unique_ptr&lt;int&gt; p(new int{10}); auto foo = [x=10] () mutable { ++x; }; auto bar = [ptr=std::move(p)] {}; auto baz = [p=std::move(p)] {}; }</span></span></span></span></code> </pre> <br>  <b>Optimization</b> <br><br>  Another idea is to use it as a potential optimization technique.  Instead of calculating some value each time we call a lambda, we can calculate it once in the initializer: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { using namespace std::string_literals; std::vector&lt;std::string&gt; vs; std::find_if(vs.begin(), vs.end(), [](std::string const&amp; s) { return s == "foo"s + "bar"s; }); std::find_if(vs.begin(), vs.end(), [p="foo"s + "bar"s](std::string const&amp; s) { return s == p; }); }</span></span></span></span></code> </pre> <br>  <b>Member variable capture</b> <br><br>  The initializer can also be used to capture a member variable.  Then we can get a copy of a member variable and not worry about hanging links. <br><br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Baz</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [s=s] { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }; } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> s; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f1 = Baz{<span class="hljs-string"><span class="hljs-string">"ala"</span></span>}.foo(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> f2 = Baz{<span class="hljs-string"><span class="hljs-string">"ula"</span></span>}.foo(); f1(); f2(); }</code> </pre> <br>  Play around with the code here: <a href="https://wandbox.org/permlink/zIzWARqYIGnFz3jN">@Wandbox</a> <a href="https://wandbox.org/permlink/zIzWARqYIGnFz3jN"><br></a> <br><br>  In <code>foo()</code> we capture a member variable by copying it into a closure type.  In addition, we use auto to output the entire method (previously, in C ++ 11 we could use <code>std::function</code> ). <br><br>  <b>Generalized lambda expressions</b> <br><br>  Another significant improvement is generalized lambda. <br>  Starting with C ++ 14 you can write: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> foo = [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; }; foo(<span class="hljs-number"><span class="hljs-number">10</span></span>); foo(<span class="hljs-number"><span class="hljs-number">10.1234</span></span>); foo(<span class="hljs-string"><span class="hljs-string">"hello world"</span></span>);</code> </pre> <br>  This is equivalent to using a pattern declaration in a closure type call statement: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T x)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; x &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } } someInstance;</code> </pre><br>  Such a generalized lambda can be very useful when it is difficult to infer a type. <br><br>  For example: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; numbers { { <span class="hljs-string"><span class="hljs-string">"one"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span> }, {<span class="hljs-string"><span class="hljs-string">"two"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> }, { <span class="hljs-string"><span class="hljs-string">"three"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> } }; <span class="hljs-comment"><span class="hljs-comment">//      pair&lt;const string, int&gt;! std::for_each(std::begin(numbers), std::end(numbers), [](const std::pair&lt;std::string, int&gt;&amp; entry) { std::cout &lt;&lt; entry.first &lt;&lt; " = " &lt;&lt; entry.second &lt;&lt; '\n'; } );</span></span></code> </pre><br>  Am I mistaken here?  Does entry have the correct type? <br>  . <br>  . <br>  . <br>  Probably not, since the value type for std :: map is <code>std::pair&lt;const Key, T&gt;</code> .  So my code will make extra copies of the lines ... <br>  This can be fixed with <code>auto</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::for_each(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::begin(numbers), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::end(numbers), [](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; entry) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; entry.first &lt;&lt; <span class="hljs-string"><span class="hljs-string">" = "</span></span> &lt;&lt; entry.second &lt;&lt; <span class="hljs-string"><span class="hljs-string">'\n'</span></span>; } );</code> </pre> <br>  You can play around with the code here: <a href="https://wandbox.org/permlink/jUxlrWasTCBDVEYr">@Wandbox</a> <br><br>  <b>Conclusion</b> <br><br>  What a story! <br><br>  In this article, we started from the first days of lambda expressions in C ++ 03 and C ++ 11 and moved on to an improved version in C ++ 14. <br><br>  You saw how to create a lambda, what is the basic structure of this expression, what a capture list is and much more. <br><br>  In the next part of the article, we will move on to C ++ 17 and get acquainted with the future features of C ++ 20. <br><br>  The second part is available here: <br><br>  <a href="https://www.bfilipek.com/2019/03/lambdas-story-part2.html">Lambdas: From C ++ 11 to C ++ 20, Part 2</a> <a href="https://www.bfilipek.com/2019/03/lambdas-story-part2.html"><br></a> <br><br>  Links <br><br>  C ++ 11 - <a href="https://timsong-cpp.github.io/cppwp/n3337/expr.prim.lambda">[expr.prim.lambda]</a> <br>  C ++ 14 - <a href="https://timsong-cpp.github.io/cppwp/n4140/expr.prim.lambda">[expr.prim.lambda]</a> <br>  <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp%3Fview%3Dvs-2017">Lambda Expressions in C ++ |</a>  <a href="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp%3Fview%3Dvs-2017">Microsoft docs</a> <br>  <a href="https://blog.feabhas.com/2014/03/demystifying-c-lambdas/">Demystifying C ++ lambdas - Sticky Bits - Powered by FeabhasSticky Bits - Powered by Feabhas</a> <a href="https://blog.feabhas.com/2014/03/demystifying-c-lambdas/"><br></a> <br><br>  We are waiting for your comments and invite all interested to the course <a href="https://otus.pw/d3Uc/">"Developer C ++"</a> . </div><p>Source: <a href="https://habr.com/ru/post/444524/">https://habr.com/ru/post/444524/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444514/index.html">Webinar "Machine Learning Security: Natural Problems of Artificial Intelligence"</a></li>
<li><a href="../444516/index.html">Wolfenstein 3D: ray tracing with WebGL1</a></li>
<li><a href="../444518/index.html">Towards a fundamental theory of consciousness</a></li>
<li><a href="../444520/index.html">2. Check Point Getting Started R80.20. Solution Architecture</a></li>
<li><a href="../444522/index.html">Apocalypse is canceled</a></li>
<li><a href="../444526/index.html">DOTS stack: C ++ & C #</a></li>
<li><a href="../444528/index.html">Situation: Japan may limit downloading content from the network - we understand and discuss</a></li>
<li><a href="../444530/index.html">The future of dependency injection in Android</a></li>
<li><a href="../444534/index.html">Vulnerability scanning and secure development. Part 1</a></li>
<li><a href="../444540/index.html">Intel is ready to start producing MRAM memory</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>