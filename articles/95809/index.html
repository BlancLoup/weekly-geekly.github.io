<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MEF book</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="With this article I begin a cycle, the purpose of which is to create the most complete guide to the Managed Extensibility Framework (MEF) in Russian. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MEF book</h1><div class="post__text post__text-html js-mediator-article"><img alt="image" src="https://habrastorage.org/getpro/habr/post_images/bce/c94/8ee/bcec948ee6dbbf10123d7a5140fe067e.png" align="left">  With this article I begin a cycle, the purpose of which is to create the most complete guide to the <strong>Managed Extensibility Framework</strong> (MEF) in Russian.  The result of the cycle, in my plans, will be the creation of a free e-book about MEF.  If you have any thoughts or suggestions on this, let me know in the comments.  I hope that together we can create excellent leadership. <br><br>  This article is based on my reports on MEF at various meetings, including at the DevConf conference. <br><br>  I'm looking for co-authors, critics, just people who want to help, including with the layout of the document. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><h1>  Chapter 1. Introduction </h1><br><h3>  What is MEF? </h3><br>  Managed Extensibility Framework is the fruit of the work of several people at <strong>Microsoft</strong> to develop a tool for solving the problem of application extensibility.  The project was originally developed under the open source <strong>MS-PL</strong> license.  MEF developed as a separate library for <strong>.NET 3.5</strong> and was included in <strong>.NET 4.0</strong> as a full-fledged part of the framework.  Inclusion of MEF in the standard .NET libraries is an important step and recognition of the value of this tool. <br><br>  The purpose of MEF is to provide the developer with the opportunity to add functionality to his application at run time.  A very common version of this task is to create plug-ins for a program.  Using MEF, you can easily define the extension points of your code, and a third-party developer will just as easily write separate extensions for your application. <br><br>  The main ideologue and activist of MEF is <strong>Glenn Block</strong> (Glenn Block) - the head of the unit in the .NET Framework team at Microsoft.  You can find a lot of material on the framework on Glen‚Äôs blog at <a href="http://codebetter.com/blogs/glenn.block/" rel="nofollow">http://codebetter.com/blogs/glenn.block/</a> . <br><br>  The main source of information on the framework and the place where the source code of the project is located is the site <a href="http://mef.codeplex.com/" rel="nofollow">http://mef.codeplex.com/</a> .  Here you will find a developer guide, a description of the MEF architecture, links to useful resources and training videos, forums, and a bugtracker.  The latest version of MEF for .NET 3.5 is Preview 9. <br><br>  MEF is a young tool, but despite this, there are already many products that use it.  The most significant product from the list is <strong>Visual Studio 2010</strong> , which uses MEF both internally (designers of UML and the Entity Framework), and to provide extension APIs to third-party developers.  Other examples of using MEF are: <a href="http://msaf.codeplex.com/" rel="nofollow">Silverlight Analytics Framework</a> , <a href="http://smf.codeplex.com/" rel="nofollow">Silverlight Media Framework</a> , <a href="http://site.typemock.com/test-lint" rel="nofollow">TypeMock Test Lint</a> , <a href="http://ravendb.net/" rel="nofollow">RavenDB</a> , <a href="http://caliburn.codeplex.com/" rel="nofollow">Caliburn</a> , <a href="http://commonservicelocator.codeplex.com/" rel="nofollow">Common Service Locator</a> . <br><br>  It is worth noting that due to the fact that MEF is a free-licensed project, the framework was successfully transferred to <a href="http://www.mono-project.com/Main_Page" rel="nofollow">Mono</a> , an alternative open-source implementation of .NET from <strong>Novell</strong> . <br><br><h3>  MEF destination </h3><br>  What tasks is MEF supposed to solve?  To date, in the .net environment there was no uniform tool for solving application expansion tasks.  Therefore, when such problems arose, each developer solved it in his own way, to the best of his knowledge, skills, and requirements of the problem.  It is quite obvious that this situation leads to the creation of code that is architecturally (or fundamentally) incompatible with each other.  That is, by moving from one company to another, you can find a completely different approach in solving the same problem.  Figure 1 presents the following result: many projects with different options and configuration extensions. <br><br><img title="image" alt="image" src="https://habrastorage.org/getpro/habr/post_images/d9c/864/618/d9c864618ec781fd05f0f76b17ee73bd.png" width="659" height="397"><br>  <strong>Fig.1.</strong>  Problem <br><br>  MEF aims to overcome this problem.  The framework included in .NET 4.0 offers a single way to solve architectural problems of extensibility of an application.  Achieving the goal of MEF - the spread of a uniform approach - will allow us to simplify the life of developers and make the maintenance of someone else's code or writing extensions to other people's applications much easier and in a familiar (regular) manner (Fig. 2). <br><br> <a href="" rel="nofollow"><img title="image" alt="image" src="https://habrastorage.org/getpro/habr/post_images/f7d/671/38a/f7d67138a3f229099effa06b73bf4f23.png" width="300" height="166"></a> <br>  <strong>Fig.2.</strong>  Decision <br><br>  In an ideal perspective, a developer who has studied MEF will be able (without much difficulty and a lengthy study of architecture) to develop components for all sorts of projects on the .NET platform, written by any other companies or individuals.  And thus, MEF is able to solve the problem of mutual understanding between developers, offering a common language of communication. <br><br><h3>  The basics </h3><br>  The key to the success of MEF as a tool lies in its simplicity.  MEF is built on just three functional parts: import, export and composition.  Using imports, you characterize parts of your application as extensible.  A third-party developer, using the export functions, creates a separate component (part, plugin) designed for your application.  And, in the course of execution, you use the composition functions to connect parts of the import with parts of the export.  Consider these steps in more detail. <br><br><h4>  Import </h4><br>  In fig.  Table 3 shows the definition of some part of the code imported using MEF. <br><br><img title="image" alt="image" src="https://habrastorage.org/getpro/habr/post_images/498/e4b/620/498e4b620e546ad0f4245ba69acdf470.png" width="584" height="241"><br>  <strong>Fig.</strong>  <strong>3.</strong> Imported part <br><br>  This is where the auto property is defined, the type of which is determined by some kind of interface IPlugin.  Using the Import attribute, which is part of the MEF infrastructure, a property is marked as imported.  The property itself thus becomes part of the import, and the part type will be the IPlugin interface. <br><br>  Note the parameter Import: typeof (IPlugin) in this case defines the so-called MEF contract.  A contact is a unique identifier that uniquely identifies a part of the import, a part of the export, and thus allows the MEF to connect both parts in the composition process.  Simply put, when defining a contract, you provide a certain password, which must be called part of the extension in order to join the point of import.  Later in this chapter, contracts will be discussed in more detail. <br><br><h4>  Export </h4><br>  In fig.  4 gives the definition of a class that implements the exported portion of the extension in MEF. <br><br><img title="image" alt="image" src="https://habrastorage.org/getpro/habr/post_images/8e1/c9b/e56/8e1c9be5670bd35da82468ea61cf16c6.png" width="629" height="243"><br>  <strong>Fig.</strong>  <strong>4.</strong> Exported part <br><br>  Here is defined a certain class FirstPlugin, which implements the IPlugin interface (part of the import in the previous topic is defined using the same one).  Using the Export attribute from the MEF infrastructure, the class is marked as exported (you can say ‚Äúplugin‚Äù).  Note that the Export attribute parameter is a contract declared as typeof (IPlugin).  Exactly the same contract was defined in terms of imports in the previous topic. <br><br>  Defining the same contract when importing and exporting allows MEF to find parts destined to one another. <br><br><h4>  Composition </h4><br>  After determining the imported and exported parts, it is necessary to produce them (Fig. 5).  Composition refers to the process of finding all defined parts of a MEF, instantiating them, and assigning instances of exported parts to parts of an import.  In other words, in the process of composition, the plugins marked with the export attribute are connected to parts of yours when they are marked with the import attributes. <br><br><img title="image" alt="image" src="https://habrastorage.org/getpro/habr/post_images/904/c90/5d9/904c905d90678e27b1bb9d3db8a392b7.png" width="732" height="99"><br>  <strong>Fig.</strong>  <strong>5.</strong> Composition <br><br>  An instance of the composition container is created here (the container is part of the MEF infrastructure, which will be discussed in more detail later).  After that, the container calls the ComposeParts method, whose parameters are an enumeration of the elements in which the MEF should look for parts for the composition.  In this case, this is an instance of the current class and new FirstPlugin () is an instantiated plug-in, which we marked in the previous section with the Export attribute. <br><br>  After calling ComposeParts, the this and FirstPlugin instances will be recorded in the container container, and the imported part of the Plugin (Fig. 3) will receive the value of the FirstPlugin instance (Fig. 4).  A little further we will look at the whole process together in the sample code. <br><br>  An important role in the composition process is played by contracts, which allow us to indicate exactly which parts of exports we expect in a particular part of imports. <br><br><h4>  Contracts </h4><br>  Contracts in the MEF infrastructure play an important connecting role between parts of imports and exports.  Contracts are necessarily explicitly or implicitly defined when parts are imported or exported.  In fig.  3, the contract uses the typeof expression (IPlugin), which uniquely identifies the type of the IPlugin interface. <br>  In fact, the MEF infrastructure contains several options for defining a contract during import (Table 1). <br><br>  <strong>Table 1.</strong> Options for defining contracts when importing <br><table border="1" cellpadding="2" width="802"><tbody><tr><td width="200">  ImportAttribute (Type) </td><td width="600">  by specifying the transfer type (as we have considered) </td></tr><tr><td width="200"> ImportAttribute (String) </td><td width="600">  by passing the contract name as a string - in this case, you must ensure that such a string is unique among other contracts </td></tr><tr><td width="200">  ImportAttribute (String, Type) </td><td width="600">  by passing both the contract name as a string and its type ‚Äî this can be useful when there is a need to create several different contracts for the same type </td></tr><tr><td width="200">  ImportAttribute () </td><td width="600">  if the type of contract was not transferred to the import attributes (Import and others), then it will be determined automatically based on the type to which this attribute is applied.  Thus, you can omit the typeof parameter (IPlugin) in the example in fig.  3 </td></tr></tbody></table>  In cases where the contract name was not transferred, it is generated automatically using the GetContractName method, which returns the full string type definition including its namespace.  As already mentioned, if the type of contract is not specified, it is also automatically obtained. <br><br>  For export attributes, the same rules apply as for import.  But when defining export using the attributes of Export and others, it is important to understand the following behavior: if the type and name of the contract are not specified, they will be obtained automatically based on the type of element to which the attribute is applied.  In other words, if in the example in fig.  4 omit the typeof parameter (IPlugin), then the MEF infrastructure will automatically determine the contract based on the FirstPlugin type, but not IPlugin, as required by us.  This means that if you build an exported part based on basic interfaces or classes, then you need to explicitly specify its type for the contract. <br><br><h3>  Hello, MEF! </h3><br>  It is time to collect all the knowledge of this chapter and implement it in a concrete example.  To demonstrate, let's create a project based on ASP.NET MVC Framework 2 and define the following interface in it: <br><br> <a href="" rel="nofollow"><img title="image" alt="image" src="http://www.gotdotnet.ru/upload/blog/XaocCPS/4e8/image_thumb_1.png" width="304" height="115"></a> <br><br><br>  This interface will determine the type of our imported and exported parts. <br>  Then, in the HomeController controller, we define the import point: <br><br> <a href="" rel="nofollow"><img title="image" alt="image" src="http://www.gotdotnet.ru/upload/blog/XaocCPS/13b/image_thumb_2.png" width="321" height="119"></a> <br><br>  Note that we have defined an import point with a typeof contract (IPlugin).  However, in this case, we may well omit this contract definition, entrusting its automatic definition to the MEF infrastructure. <br><blockquote>  However, the author of this text strongly recommends that you specify contracts whenever you define imported and exported parts.  Such a definition will help you to quickly understand the text of the code in the future. </blockquote>  The next step is to define the exported part, you can call its plugin, which will ‚Äúconnect‚Äù to the import defined above. <br><br> <a href="" rel="nofollow"><img title="image" alt="image" src="http://www.gotdotnet.ru/upload/blog/XaocCPS/77e/image_thumb_3.png" width="354" height="214"></a> <br><br>  Please note that if in the case of defining imports we could have omitted the contract, then in this case with exports, we cannot omit the contract, because we implement the exported part from the interface that participates in the contract.  If we omit the contract definition in this code, we will get an exception at run time from the MEF infrastructure, which cannot find a suitable export part for the import point with the typeof contract (IPlugin). <br><br>  Our final step is to write the composition code, which we put in the HomeController constructor. <br><br> <a href="" rel="nofollow"><img title="image" alt="image" src="http://www.gotdotnet.ru/upload/blog/XaocCPS/e25/image_thumb_4.png" width="405" height="197"></a> <br><br>  After running the received code, we can observe the expected result (Fig. 6). <br><br><img title="image" alt="image" src="https://habrastorage.org/getpro/habr/post_images/ab9/ace/55d/ab9ace55d8aabf464670d735f37aee15.png" width="602" height="244"><br>  <strong>Fig.</strong>  <strong>6.</strong> MEF Result <br><br>  As you can see, after running ComposeParts, the Plugin property accepted the value of an instance of the FirstPlugin class, as intended. <br><br><h3>  Conclusion </h3><br>  In this chapter, we learned about the MEF framework, its purpose and the problems it addresses.  We considered the basic concepts of MEF and some of their features: import, export, composition, contracts.  We built the first example on the basis of the information received, which demonstrated the work of MEF in practice. <br><br>  In the next chapter, we dive into the framework, consider a more complex example with several plugins, and introduce the concept of directories in MEF. </div><p>Source: <a href="https://habr.com/ru/post/95809/">https://habr.com/ru/post/95809/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../95801/index.html">Safari 5 released</a></li>
<li><a href="../95802/index.html">Telephony on Cisco (Call Manager Express) - Part 1</a></li>
<li><a href="../95803/index.html">What should be the leader? Profession Secrets</a></li>
<li><a href="../95805/index.html">Apple introduced a new version of iOS 4</a></li>
<li><a href="../95806/index.html">Safari browser updated to version 5</a></li>
<li><a href="../95810/index.html">Is multitasking a myth?</a></li>
<li><a href="../95818/index.html">Internet Explorer 9 and Safari 5 - hardware acceleration</a></li>
<li><a href="../95820/index.html">Smoothing curve</a></li>
<li><a href="../95821/index.html">Password recovery on Habr√© on a box that no longer belongs to me on mail.ru</a></li>
<li><a href="../95824/index.html">Babylonian Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>