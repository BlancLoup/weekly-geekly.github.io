<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>DHCP server on multiple VLANs</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Formulation of the problem. 

 The term ‚Äúclient‚Äù means the area of ‚Äã‚Äãresponsibility for a set of network devices. 

 It is required to provide access ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>DHCP server on multiple VLANs</h1><div class="post__text post__text-html js-mediator-article">  Formulation of the problem. <br><br>  The term ‚Äúclient‚Äù means the area of ‚Äã‚Äãresponsibility for a set of network devices. <br><br>  It is required to provide access for several hundred clients to certain shared resources in such a mode so that: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li><a name="1"></a>  Each client did not see the traffic of other clients. </li><li><a name="2"></a>  Malfunctions of one client (broadcast-storm, IP address conflicts, unauthorized client DHCP servers, etc.) should not affect the operation of other clients as well as the system as a whole. </li><li><a name="3"></a>  Each client should not directly access the resources of other clients (although, as a special case, it is possible to provide for the permission of this traffic, but with its centralized control and / or control). </li><li><a name="4"></a>  Clients should be able to gain access to shared external resources (which can be both individual servers and the Internet as a whole). </li><li><a name="5"></a>  Shared resources should also be able to access client resources (of course, provided that the shared resource knows the IP address of the client resource). </li><li><a name="6"></a>  The address space for clients is allocated centrally and its administration should not be overly complex. </li></ol><br>  As examples of practical application, one can name isolation of local area networks in large organizations, organization of VoIP communications or Internet access for several independent consumers, etc. <br><a name="habracut"></a><br><img src="https://habrastorage.org/files/8f2/2a1/b5c/8f22a1b5c5a34faeac9946293c412a24.png" alt="Description"><br>  Conditions <a href="https://habr.com/ru/post/268331/">1</a> and <a href="https://habr.com/ru/post/268331/">2 are</a> achieved by allocating each client its own VLAN.  Conditions <a href="https://habr.com/ru/post/268331/">3-5</a> can be accomplished by combining client VLANs with the prohibition of direct traffic between them.  In some sources, this technology is called ‚Äúprivate VLAN‚Äù, in some ‚Äúport isolation‚Äù, and its meaning is this: from each client VLAN you can easily get into some common VLAN (and, accordingly, back), but traffic between the client VLAN is prohibited .  Well, to fulfill condition <a href="https://habr.com/ru/post/268331/">6,</a> we will allocate for all clients a common address space of the form 10.12.8.0/23, and we will issue specific IP addresses upon request using DHCP. <br><br>  Thus, when a client gets a new device, the address for it will be issued automatically (and we will have no problems due to the fact that one client can use units of IP addresses for his needs, and another will need tens or hundreds of them), and when adding a new client, we will simply create another VLAN and add it to our common group.  Even if, due to the large number of client devices, the address space we initially allocated is exhausted, we can always expand it by changing the settings in just two places (on the DHCP server and on the interface that unites all client VLANs). <br><br>  Technically, the above solution can be implemented only by hardware on L3 switches or by firmware on L2 switches (as long as they understand 802.1q) and on any computer with a linux-like operating system.  Since I already had a server (which, besides, was a target for clients), it would be logical to stop at the hardware-software version. <br><br>  So, we program the switch so that on each client VLAN there is one physical port of the switch in the ‚Äúaccess mode‚Äù, and one common port in 802.1q mode (our server will be connected to this port).  In detail, the technology settings do not sign, because  it is rather trivial and depends on the specific model of switch used. <br><br>  Next, proceed to creating a configuration for the server.  Let the physical interface that connects to the 802.1q port of the switch be named eth0.  For my specific task, it took 200 client VLANs with a VLAN ID from 600 to 799, inclusive, so we will create them: <br><br>  General configuration of types of names of VLAN-interfaces.  I want the VLAN interface names to be ‚ÄúvlanXXX‚Äù, where XXX is the VLAN ID: <br><br><pre> vconfig set_name_type VLAN_PLUS_VID_NO_PAD
</pre><br>  Directly create a VLAN based on the interface eth0: <br><br><pre> vconfig add eth0 600
 ifconfig vlan600 up
 vconfig add eth0 601
 ifconfig vlan601 up
 ...
 vconfig add eth0 799
 ifconfig vlan799 up
</pre><br>  Create a bridge into which we will merge the created vlans: <br><br><pre> brctl addbr br1
 ifconfig br1 up
</pre><br>  We unite the created interfaces in the bridge: <br><br><pre> brctl addif br1 vlan600
 brctl addif br1 vlan601
 ...
 brctl addif br1 vlan799
</pre><br>  Now we write the address br1 on the interface, which will act as a default gateway for all our clients: <br><br><pre> ifconfig br1 10.12.8.1/23
</pre><br>  And prohibit traffic between client VLANs using ebtables: <br><br><pre> ebtables -A FORWARD --logical-in br1 --logical-out br1 -j DROP
</pre><br>  (in this case, the ebtables 'filter' table is used, which prohibits the transfer of traffic between interfaces entering the bridge in the form of logical ports).  If it is nevertheless necessary to allow the possibility of transferring traffic between clients under our control (see clause 3 of the technical assignment), then instead of the above rule, we establish the following: <br><br><pre> ebtables -t broute -A BROUTING -p ipv4 --logical-in -j DROP
 ebtables -t broute -A BROUTING -p arp --logical-in -j DROP
</pre><br>  Here we work with the 'broute' table.  It does not have standard actions for the purposes of ACCEPT and DROP.  The ACCEPT target allows forwarding traffic with specified conditions (ie, traffic is transmitted at the L2 level), and the DROP target denies forwarding traffic and ensures its transmission to the routing (and, accordingly, we will be able to manage it through iptables).  However, since  all addresses belong to the same IP subnet but can be in different client VLANs, on the br1 interface you will need to enable arp proxy: <br><br><pre> sysctl -w net.ipv4.conf.br1.proxy_arp = 1
</pre><br>  I note that I did not have the task of passing traffic between customers, so the extension described above is purely speculative and has not been tested in practice! <br><br>  It remains only to configure the DHCP server and settle it on the interface br1.  This operation is also trivial, therefore it is not described in this article. <br><br>  Well, does it work?  But as if not so: <br><br><pre> # tcpdump -e -v -n -i br1 udp port 67 or port 68
 tcpdump: listening on br1, link-type EN10MB (Ethernet), capture size 65535 bytes
 14: 26: 38.164169 00: 0b: 82: 3b: 9c: 96&gt; ff: ff: ff: ff: ff: ff, ethertype IPv4 (0x0800), length 590: (tos 0x0, ttl 64, id 0, offset 0 , flags [none], proto UDP (17), length 576)
     0.0.0.0.68&gt; 255.255.255.255.67: BOOTP / DHCP, Request from 00: 0b: 82: 3b: 9c: 96, length 548, xid 0x3c12d61a, Flags [none]
           Client-Ethernet-Address 00: 0b: 82: 3b: 9c: 96
           Vendor-rfc1048 Extensions
             Magic Cookie 0x63825363
             DHCP-Message Option 53, length 1: Discover
             Client-ID Option 61, length 7: ether 00: 0b: 82: 3b: 9c: 96
             Vendor-Class Option 60, length 16: "GXV dslforum.org"
             T125 Option 125, length 36: 3561,520160816,808469048,838994992,808469048,842220089,11272851,122116182.858862640
             Parameter-Request Option 55, length 11: 
               Subnet-Mask, Time-Zone, Default-Gateway, Domain-Name-Server
               Hostname, Domain Name, BR, NTP
               Vendor-Option, TFTP, Option 125
 14: 26: 38.171041 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype IPv4 (0x0800), length 336: (tos 0x0, ttl 64, id 0, offset 0 , flags [none], proto UDP (17), length 322)
     12/10/8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294, xid 0x3c12d61a, Flags [none]
           Your-IP 10.12.8.200
           Client-Ethernet-Address 00: 0b: 82: 3b: 9c: 96
           Vendor-rfc1048 Extensions
             Magic Cookie 0x63825363
             DHCP-Message Option 53, length 1: Offer
             Server-ID Option 54, length 4: 10.12.8.1
             Lease-Time Option 51, length 4: 7200
             Subnet-Mask Option 1, length 4: 255.255.254.0
             Default-Gateway Option 3, length 4: 10.12.8.1
</pre><br><br>  Everything is fine here: we received one broadcast DHCPDISCOVER request, responded with one broadcast-response DHCPOFFER. <br><br>  And now let's see what happens on the physical interface: <br><br><pre> # tcpdump -e -n -i eth0 udp port 67 or port 68
 tcpdump: WARNING: eth0: no IPv4 address assigned
 tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
 listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
 14: 31: 07.829289 00: 0b: 82: 3b: 9c: 96&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 594: vlan 603, p 0, ethertype IPv4, 0.0. 0.0.68&gt; 255.255.255.255.67: BOOTP / DHCP, Request from 00: 0b: 82: 3b: 9c: 96, length 548
 14: 31: 07.834962 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 340: vlan 799, p 0, ethertype IPv4, 10.12. 8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294
 14: 31: 07.834966 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 340: vlan 798, p 0, ethertype IPv4, 10.12. 8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294
 14: 31: 07.834968 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 340: vlan 797, p 0, ethertype IPv4, 10.12. 8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294
 14: 31: 07.834970 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 340: vlan 796, p 0, ethertype IPv4, 10.12. 8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294
 14: 31: 07.834972 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 340: vlan 795, p 0, ethertype IPv4, 10.12. 8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294
 14: 31: 07.834974 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 340: vlan 794, p 0, ethertype IPv4, 10.12. 8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294
 14: 31: 07.834976 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 340: vlan 793, p 0, ethertype IPv4, 10.12. 8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294
 14: 31: 07.834978 00: 25: 90: d3: 5e: fa&gt; ff: ff: ff: ff: ff: ff, ethertype 802.1Q (0x8100), length 340: vlan 792, p 0, ethertype IPv4, 10.12. 8.1.67&gt; 255.255.255.255.68: BOOTP / DHCP, Reply, length 294
 ...
</pre><br><br>  What happened?  Yes, everything as we configured: <br><ul><li>  DHCPDISCOVER was received from VLAN 603; </li><li>  the request was transmitted via the br1 interface to our DHCP server; </li><li>  the server responded to it by sending a DHCPOFFER response to the br1 interface; </li><li>  The br1 interface propagated this response (since it, according to the DHCP standard, is broadcast in both L3 and L2 levels) across all client VLANs. </li></ul><br><br>  Not only did we spotlight the MAC / IP addresses of one of them to all our clients, but we also received an unpretentious broadcast storm on the physical switch.  By the way, from such a storm, some switches just have a roof: QTECH, working for us, not only couldn‚Äôt miss a broadcast to all the declared 200 client VLANs (i.e., the final client with an arbitrary probability either received its address from a DHCP server, or did not wait for no response at all), but even forgot the table of MAC addresses known to it (at least in the console it showed only one MAC address for all ports).  But the ASOTEL switch handled this load and clients could get addresses from our DHCP server. <br><br>  Well, we will correct the situation.  It is necessary to force the server to send a broadcast only to the VLAN from which the initial request came, and not to propagate it to all available places. <br>  Module DHCP tracking broadcast-s I have not found.  As it turned out later, he would not have helped in this case anyway, since  The broadcast response by the DHCP server is generated using a system call. <br>  socket (PF_PACKET, SOCK_DGRAM, htons (ETH_P_IP)) <br>  which does not pass through any of the ebtables or iptables tables.  Those.  if it is still possible to catch incoming broadcast, then the answers are transmitted to the driver bypassing the protocol stack.  And this is logical: if we ourselves form an ethernet header, then what's the point of additionally processing it with the kernel? <br><br>  Okay, let's try to hang on each client VLAN via DHCP Relay Agent and already send requests from it to the DHCP server for processing.  However, it turned out that the Relay Agent does not catch requests from the interfaces entering the bridge (well, this is also probably logical).  As soon as the interface was removed from the bridge, the Relay Agent started to retrieve requests, send them to the server and send the answers back to the VLAN to which you need.  When you re-add the VLAN to the bridge, the agent‚Äôs performance was again broken and DHCP became unavailable to clients. <br>  ‚ÄúWell, okay!‚Äù Said the harsh Siberian men.  We will do everything in an adult way. <br><br>  First, remember that modern linux kernels have goodies such as the Virtual Ethernet Device (you can make good pipes to distill ethernet traffic inside our computer) and Network Namespace (a means to isolate the network stack. In hardware routers, this is usually called VRF).  In principle, only Virtual Ethernet (veth) can be done for this task, but for the beauty of the solution (and simplification of the DHCP Server bundle - DHCP Relay Agent) we will also use the Network Namespace (netns). <br><br>  After network initialization in linux, by default there is only one root netns, which contains a single copy of the network stack, routing tables, interfaces, etc.  In the following description, for definiteness, we will use the following terminology: <br>  Network Namespace is called a ‚Äúlayer‚Äù (layer); <br>  root netns is called the ‚Äúbackplate‚Äù layer (although in reality this netns has a name in the form of an empty string); <br><br>  Our idea is: <br><br>  We add each client VLAN to a separate bridge, on the interface of which we will hang the DHCP Relay Agent.  Through this interface, customers can send broadcast requests to the agent and receive broadcast responses from it. <br>  from each client bridge we make an ethernet pipe to our main br1.  Through the link ‚Äúcustomer vlan‚Äù - ‚Äúcustomer vlan bridge‚Äù - ‚Äúvirtual ethernet‚Äù - ‚Äùbr1‚Äù there will pass the useful traffic between the customer service and the common external resources. <br><br>  The DHCP Relay Agent itself lives in one instance (it can listen to several client interfaces) on a special ethernet pipe, on the other side of which is our DHCP Server. <br>  the entire application layer (i.e., everything that does not concern DHCP) is located at the backplate level; <br>  everything connected with the DHCP Relay Agent is located at the level called ‚Äúrelay‚Äù; <br>  the DHCP server itself must be available both for the DHCP Relay Agent (for processing messages distributed as broadcast and converted by the agent to unicast and back), as well as directly for DHCP clients (for handling special cases: DHCPRELEASE messages sent by unicast client directly to the DHCP volume -server that gave this address). <br><br>  Taking into account these requirements, the DHCP server itself is located at the backplate level on the br1 interface, but to prevent them from receiving broadcast requests from the end clients, special filters will be applied to the interface. <br><br><img src="https://habrastorage.org/files/eea/7a4/ac6/eea7a4ac6c1c475a806ab436327b22ad.png" alt="Solution"><br><br>  Well, let's go ... Create a ‚Äúrelay‚Äù layer <br><br><pre> ip netns add relay
</pre><br>  Create a virtual pipe on the backplate layer, designed for communication between the DHCP Relay Agent and the DHCP Server: <br><br><pre> ip link add relay type veth peer name dhcpd
</pre><br>  Transfer the dhcpd tail (the interface on which the Relay Agent will work) to the relay layer: <br><br><pre> ip link set dhcpd netns relay
</pre><br>  Configure the dhcpd interface in the relay layer: <br><br><pre> ip netns exec relay ifconfig dhcpd 10.12.8.2/23
 ip netns exec relay ifconfig dhcpd up
</pre><br>  We create our main bridge br1: <br><br><pre> brctl addbr br1
</pre><br>  Let this bridge work as a smart switch (i.e., it keeps a table of MAC addresses and performs forwarding to a specific port depending on the presence of a target address on it).  To do this, set the learning time to 30 seconds: <br><br><pre> brctl setfd br1 30
</pre><br>  Well, clients are peculiar personalities, they can quite create rings.  If anyone does this, then let him suffer himself, without affecting others.  Those.  run on our virtual STP switch: <br><br><pre> brctl stp br1 on
</pre><br>  Since  Since this bridge is also the default gateway for clients, then hang up the IP address (along with the grid) and directly raise the interface itself: <br><br><pre> ifconfig br1 10.12.8.1/23
 ifconfig br1 up
</pre><br>  Add an interface to the bridge over which the DHCP server will communicate with the agent: <br><br><pre> brctl addif br1 relay
</pre><br>  Forbid traffic between client VLANs using ebtables: <br><br><pre> ebtables -A FORWARD --logical-in br1 --logical-out br1 -j DROP
</pre><br>  We prohibit the DHCP server to process broadcast requests (they must be caught by the agent and sent to the server as unicast): <br><br><pre> ebtables -A INPUT --log-in br1 --pkttype-type broadcast --protocol IPv4 --ip-protocol udp --ip-destination-port 67 -j DROP
</pre><br>  For security, we allow the use of the address allocated for the DHCP Relay Agent only on the interface named relay: <br><pre>
 ebtables -A INPUT --in-interface!  relay --protocol IPv4 --ip-source 10.12.8.2/32 -j DROP
</pre><br>  Okay, last brushstroke.  Since I categorically do not trust clients, let the kernel make sure that the IP packets coming from them have the source address of the type 10.12.8.0/23 (and not, for example, 192.168.1.1).  For this we enable on the rp filter interface: <br><br><pre> sysctl -w net.ipv4.conf.br1.rp_filter = 1
</pre><br>  We will not transfer the eth0 physical interface from the backplate to the relay layer (well, let's say we will need to hang on it some other application VLANs that are not related to this scheme).  Therefore, we will first create VLAN interfaces on the backplate layer, and then transfer them to the relay layer: <br><br>  General configuration of the types of names of VLAN-interfaces.  I want the VLAN interface names to be ‚ÄúvlanXXX‚Äù, where XXX is the VLAN ID: <br><br><pre> vconfig set_name_type VLAN_PLUS_VID_NO_PAD
</pre><br>  Directly create a VLAN based on the interface eth0: <br><br><pre> vconfig add eth0 600
</pre><br>  Transfer the created vlan600 interface from the backplate layer to the relay layer: <br><br><pre> ip link set vlan600 netns relay
</pre><br>  We lift the vlan600 interface, but already in the relay layer: <br><br><pre> ip netns exec relay ifconfig vlan600 up
</pre><br>  Create a bridge in the relay layer for this client VLAN (to which we will hang the DHCP Relay Agent). <br><br><pre> ip netns exec relay brctl addbr br600
</pre><br>  We want this bridge to work as a hub (i.e., perform the broadcast of the packet immediately after receiving it, without using the period for collecting MAC address information).  To do this, before adding the first interface to the bridge, set its parameters: <br><br><pre> ip netns exec relay brctl setfd br600 0
</pre><br>  In addition, we clearly do not need STP on this bridge: <br><br><pre> ip netns exec relay brctl stp br600 off
</pre><br>  Raise the bridge interface: <br><br><pre> ip netns exec relay ifconfig br600 up
</pre><br>  And add the client VLAN to it: <br><br><pre> ip netns exec relay brctl addif br600 vlan600
</pre><br>  Create a backplate on the layer (well, it will come there anyway) ethernet pipe for the br600 client bridge and our main bridge br1: <br><br><pre> ip link add dhcp600 type veth peer name backplate600
</pre><br>  Transfer the second end of the pipe to the relay layer: <br><br><pre> ip link set backplate600 netns relay
</pre><br>  And add this end of the pipe to the bridge: <br><br><pre> ip netns exec relay brctl addif br600 backplate600
</pre><br>  Well, add the end of the pipe remaining in the backplate layer to the bridge br1: <br><br><pre> brctl addif br1 dhcp600
</pre><br>  Repeat in the cycle of creating client VLANs in the required quantity. <br><br>  Now it is enough to start the DHCP server itself in the backplate layer and the DHCP Relay Agent in the relay layer.  In my case, I use an assembly from BusyBox, which in this case is not critical.  The use of an ISC agent and server should not cause much difficulty. <br><br>  So, we start the agent.  The client interfaces are the br600-br799, the dhcpd interface is used as the interface for communicating with the DHCP server, and the DHCP server itself has the address 10.12.8.1: <br><br><pre> ip netns exec relay / usr / sbin / dhcprelay br600, br601, ..., br799 dhcpd 10.12.8.1
</pre><br>  And finally, we start the DHCP server: <br><br><pre> / usr / sbin / udhcpd /etc/udhcpd.conf
</pre><br><br>  The file /etc/udhcpd.conf is the only line that relates to this schema: <br><br><pre> # The name of the interface on which we have a DHCP server
 interface br1
</pre><br>  All, now the broadcast requests in the user VLAN are caught by the DHCP Relay Agent via the corresponding br interface, after which the unicast request is transmitted to the server via the dhcpd interface.  The server sends a unicast response via the relay interface, which the agent receives from the dhcpd interface and transmits the broadcast to the source VLAN. <br><br>  Clients began to receive addresses through DHCP, broadcast-storm disappeared.  And the client can send DHCPRELEASE directly to the server to the address 10.12.8.1 <br><br>  ¬© Copiright 2015 by <a href="https://habrahabr.ru/users/vedga/" class="user_link">Vedga</a> .  Copying text to other resources without the consent of the author is prohibited. <br><hr><br>  What to look at this article: <br><br><ol><li>  <a href="https://ru.wikipedia.org/wiki/DHCP">DHCP - Dynamic Host Configuration Protocol</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Private_VLAN">Private VLAN (WikipediA)</a> </li><li>  <a href="http://habrahabr.ru/post/114646/">A bit about private vlan</a> (@amario) </li><li>  <a href="http://www.opennet.ru/tips/info/2683.shtml">Using multiple network stacks in Linux</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/268331/">https://habr.com/ru/post/268331/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268317/index.html">We invite you to RAD Studio 10 Seattle webinars and slides for performances in Moscow and Almaty</a></li>
<li><a href="../268319/index.html">Two tasks HeadHunter on Data Science Week: try to solve it yourself</a></li>
<li><a href="../268325/index.html">What can be not ready, becoming a team lead</a></li>
<li><a href="../268327/index.html">AI, BigData & HPC Digest # 2</a></li>
<li><a href="../268329/index.html">Intel sold Microsoft's Havok</a></li>
<li><a href="../268333/index.html">Office as Platform Issue 5 - Introducing the OneNote REST API</a></li>
<li><a href="../268335/index.html">(Archive) Matreshka.js ECMAScript.next boilerplate</a></li>
<li><a href="../268337/index.html">Welcome to OWASP EEE October 11</a></li>
<li><a href="../268339/index.html">Adding a new processor family to IDA pro</a></li>
<li><a href="../268341/index.html">We are looking for stability in retail, XYZ analysis of the range</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>