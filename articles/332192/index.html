<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Canvas - almost like SVG</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Link to canvas ninju at the end. 

 Specifically, we will focus on the Path element and how to implement it on canvas. 

 As we remember the path in s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Canvas - almost like SVG</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/web/c5a/a74/33d/c5aa7433d71749f798208296ae8d27b7.png"></div><br>  Link to canvas ninju at the end. <br><br>  Specifically, we will focus on the Path element and how to implement it on canvas. <br><br>  As we remember the path in svg can draw bezier curves, splines of these curves, as well as circles.  The canvas in this area have far less possibilities, so we will work with it.  To begin, learn to draw curves.  In svg, as in canvas, curves are limited to only 3 degrees, this is done for the sake of optimization, we will use the canonical equation to calculate them, so we will have curves of any order. <br><a name="habracut"></a><br>  There is nothing complicated in the calculation of the curves.  Below, the function code that returns an array of the form [x, y] is a point on the curve.  The input parameters for the function are: an array of control points and an offset coefficient relative to the beginning of the curve.  The offset is a value in percent from 0% to 100% (0 is the beginning of the curve, 100 is the end), I hope this point is clear. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      function factorial (number) { var result = 1; while(number){ result *= number--; } return result; } function getPointOnCurve (shift, points) { var result = [0,0]; var powerOfCurve = points.length - 1; shift = shift/100; for(var i = 0;points[i];i++){ var polynom = (factorial(powerOfCurve)/(factorial(i)*factorial(powerOfCurve - i))) * Math.pow(shift,i) * Math.pow(1-shift,powerOfCurve - i); result[0] += points[i][0] * polynom; result[1] += points[i][1] * polynom; } return result; } getPointOnCurve(60, [[0,0],[100,0],[100,100]]); // -&gt; [84, 36]</span></span></code> </pre> <br>  The trick here is the polynomial, which plays the role of a coefficient for calculating a point.  I once wrote about curves, only calculated them through recursion ( <a href="https://habrahabr.ru/post/249103/">here</a> ). <br><br>  Next stop is the splines. <br><br>  In general, using the previous function, you can draw an arbitrary section of a curve, but with splines it is more and more difficult, in order to draw only a part of the spline, you need to know its length and, accordingly, the lengths of its curves.  This is not required if we display the entire spline, but who is looking for easy ways? <br><br>  Now the array of control points will look like this: <br><br><pre> <code class="javascript hljs">[[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-literal"><span class="hljs-literal">true</span></span>],[<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>],[<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]]</code> </pre> <br>  Points with true flag are reference points. <br><br><div class="spoiler">  <b class="spoiler_title">Function code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getCenterToPointDistance</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">coordinates</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sqrt(<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(coordinates[<span class="hljs-number"><span class="hljs-number">0</span></span>],<span class="hljs-number"><span class="hljs-number">2</span></span>) + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(coordinates[<span class="hljs-number"><span class="hljs-number">1</span></span>],<span class="hljs-number"><span class="hljs-number">2</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLengthOfCurve</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">points, step</span></span></span><span class="hljs-function">) </span></span>{ step = step || <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastPoint = points[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sift = <span class="hljs-number"><span class="hljs-number">0</span></span>;sift &lt;= <span class="hljs-number"><span class="hljs-number">100</span></span>;sift += step){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> coord = getPointOnCurve(sift,points); result += getCenterToPointDistance([ coord[<span class="hljs-number"><span class="hljs-number">0</span></span>] - lastPoint[<span class="hljs-number"><span class="hljs-number">0</span></span>], coord[<span class="hljs-number"><span class="hljs-number">1</span></span>] - lastPoint[<span class="hljs-number"><span class="hljs-number">1</span></span>] ]); lastPoint = coord; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMapOfSpline</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">points, step</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = [[]]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;points[i];i++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> curvePointsCount = map[index].length; map[index][+curvePointsCount] = points[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(points[i][<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; i != points.length - <span class="hljs-number"><span class="hljs-number">1</span></span>){ map[index] = getLengthOfCurve(map[index],step); index++; map[index] = [points[i]]; } } map[index] = getLengthOfCurve(map[index],step); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPointOnSpline</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shift, points, services</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shiftLength = services.length / <span class="hljs-number"><span class="hljs-number">100</span></span> * shift; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(shift &gt;= <span class="hljs-number"><span class="hljs-number">100</span></span>){ shiftLength = services.length; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastControlPoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controlPointsCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> checkedCurve = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; services.map[lastControlPoint] &amp;&amp; counter + services.map[lastControlPoint] &lt; shiftLength; lastControlPoint++ ){ counter += services.map[lastControlPoint]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pointIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; points[pointIndex] &amp;&amp; controlPointsCounter &lt;= lastControlPoint; pointIndex++ ){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(points[pointIndex][<span class="hljs-number"><span class="hljs-number">2</span></span>] === <span class="hljs-literal"><span class="hljs-literal">true</span></span>){ controlPointsCounter++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(controlPointsCounter &gt;= lastControlPoint){ checkedCurve.push(points[pointIndex]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPointOnCurve( (shiftLength - counter) / (services.map[lastControlPoint] / <span class="hljs-number"><span class="hljs-number">100</span></span>), checkedCurve ); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> points = [[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-literal"><span class="hljs-literal">true</span></span>],[<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>],[<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> services = {}; services.map = getMapOfSpline(points); services.length= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> services.map){ services.length += services.map[key]; } getPointOnSpline(<span class="hljs-number"><span class="hljs-number">60</span></span>, points, services); <span class="hljs-comment"><span class="hljs-comment">// -&gt; [136, 95.(9)]</span></span></code> </pre><br></div></div><br>  Well, it remains the case for small, learn to include in our splines arc of ellipses.  Here it is worth telling about the native SVG algorithm and how we will differ from it. <br><br>  For the arc in the path SVG provides 7 parameters, which in my opinion is unnecessary, these parameters: <br> <code>A rx ry x-axis-rotation large-arc-flag sweep-flag xy</code> <br> <br>  Decryption: <br><br><ul><li>  The first two parameters are quite obvious - these are semi-axes of ordinates and abscissas. </li><li>  the third is the slope of the ellipse, given in degrees </li><li>  the fourth and fifth is the arc drawing direction </li><li>  the sixth and seventh coordinates of the end point </li></ul><br>  The arc can also be completely controlled by a smaller number of parameters; moreover, in practice, the coordinates of the end point are not always known.  In addition, an incorrectly specified end coordinate deforms the ellipse and, if its value is too large, the parameters of the semi-axes no longer correspond to the given ones. <br><br>  For the arc, we need to know: <br><ul><li>  ellipse axis </li><li>  angles of the beginning and end of the arc </li><li>  ellipse slope </li></ul><br><br>  Only 5 parameters. <br><br>  So the logic will be like this, we follow the hands.  The beginning of our arc of an ellipse (not to be confused with its center) will be the previous point in the array or the origin if there is no previous point.  The end of the arc is the reference point for further construction of the path.  With the help of parameters, the arc takes any form and goes anywhere, everything is grand.  Again, you need to calculate the length of all segments to build only part of the path. <br><br>  Here is what a set of points will look like with an ellipse included in it: <br><br><pre> <code class="hljs json">[ [x1,y1], [x2,y2], [x3,y3], [radiusX,radiusY,startRadian,endRadian,tilt], // tilt - optional [x5,y5], ... [xN,yN] ]</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Code</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPointOnEllipse</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radiusX,radiusY,shift,tilt,centerX,centerY</span></span></span><span class="hljs-function">)</span></span>{ tilt = tilt || <span class="hljs-number"><span class="hljs-number">0</span></span>; tilt *= <span class="hljs-number"><span class="hljs-number">-1</span></span>; centerX = centerX || <span class="hljs-number"><span class="hljs-number">0</span></span>; centerY = centerY || <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x1 = radiusX*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.cos(+shift), y1 = radiusY*<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(+shift), x2 = x1 * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.cos(tilt) + y1 * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(tilt), y2 = -x1 * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.sin(tilt) + y1 * <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.cos(tilt); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x2 + centerX,y2 + centerY]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLengthOfEllipticArc</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">radiusX, radiusY, startRadian, endRadian, step</span></span></span><span class="hljs-function">) </span></span>{ step = step || <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> length = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastPoint = getPointOnEllipse(radiusX,radiusY,startRadian); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> radianPercent = (endRadian - startRadian) / <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;=<span class="hljs-number"><span class="hljs-number">100</span></span>;i+=step){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> radian = startRadian + radianPercent * i; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> point = getPointOnEllipse(radiusX,radiusY,radian); length += getCenterToPointDistance([point[<span class="hljs-number"><span class="hljs-number">0</span></span>]-lastPoint[<span class="hljs-number"><span class="hljs-number">0</span></span>],point[<span class="hljs-number"><span class="hljs-number">1</span></span>]-lastPoint[<span class="hljs-number"><span class="hljs-number">1</span></span>]]); lastPoint = point; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> length; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getMapOfPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">points, step</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> map = [[]]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastPoint = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>;points[i];i++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> point = points[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(point.length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>){ map[index] = getLengthOfEllipticArc(point[<span class="hljs-number"><span class="hljs-number">0</span></span>], point[<span class="hljs-number"><span class="hljs-number">1</span></span>], point[<span class="hljs-number"><span class="hljs-number">2</span></span>], point[<span class="hljs-number"><span class="hljs-number">3</span></span>], step); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!points[i+<span class="hljs-number"><span class="hljs-number">1</span></span>]){<span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centerOfArc = getPointOnEllipse(point[<span class="hljs-number"><span class="hljs-number">0</span></span>], point[<span class="hljs-number"><span class="hljs-number">1</span></span>], point[<span class="hljs-number"><span class="hljs-number">2</span></span>] + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, point[<span class="hljs-number"><span class="hljs-number">4</span></span>], lastPoint[<span class="hljs-number"><span class="hljs-number">0</span></span>], lastPoint[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endOfArc = getPointOnEllipse(point[<span class="hljs-number"><span class="hljs-number">0</span></span>], point[<span class="hljs-number"><span class="hljs-number">1</span></span>], point[<span class="hljs-number"><span class="hljs-number">3</span></span>], point[<span class="hljs-number"><span class="hljs-number">4</span></span>], centerOfArc[<span class="hljs-number"><span class="hljs-number">0</span></span>], centerOfArc[<span class="hljs-number"><span class="hljs-number">1</span></span>]); index++; map[index] = [endOfArc]; lastPoint = endOfArc; <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } map[index].push(point); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(point[<span class="hljs-number"><span class="hljs-number">2</span></span>] === <span class="hljs-literal"><span class="hljs-literal">true</span></span> || (points[i+<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; points[i+<span class="hljs-number"><span class="hljs-number">1</span></span>].length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>)){ map[index] = getLengthOfCurve(map[index],step); index++; map[index] = [point]; } lastPoint = point; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> map[index] !== <span class="hljs-string"><span class="hljs-string">'number'</span></span>){map[index] = getLengthOfCurve(map[index],step);} <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPointOnPath</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">shift, points, services</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> shiftLength = services.length / <span class="hljs-number"><span class="hljs-number">100</span></span> * shift; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(shift &gt;= <span class="hljs-number"><span class="hljs-number">100</span></span>){ shiftLength = services.length; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastControlPoint = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> controlPointsCounter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> checkedCurve = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; services.map[lastControlPoint] &amp;&amp; counter + services.map[lastControlPoint] &lt; shiftLength; lastControlPoint++){ counter += services.map[lastControlPoint]; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lastPoint = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pointIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; points[pointIndex] &amp;&amp; controlPointsCounter &lt;= lastControlPoint; pointIndex++){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> point = points[pointIndex]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(point.length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> centerOfArc = getPointOnEllipse(point[<span class="hljs-number"><span class="hljs-number">0</span></span>], point[<span class="hljs-number"><span class="hljs-number">1</span></span>], point[<span class="hljs-number"><span class="hljs-number">2</span></span>] + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI, point[<span class="hljs-number"><span class="hljs-number">4</span></span>], lastPoint[<span class="hljs-number"><span class="hljs-number">0</span></span>], lastPoint[<span class="hljs-number"><span class="hljs-number">1</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(controlPointsCounter === lastControlPoint){ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> percent = (shiftLength - counter) / (services.map[lastControlPoint] / <span class="hljs-number"><span class="hljs-number">100</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> resultRadian = point[<span class="hljs-number"><span class="hljs-number">2</span></span>] + ((point[<span class="hljs-number"><span class="hljs-number">3</span></span>] - point[<span class="hljs-number"><span class="hljs-number">2</span></span>])/<span class="hljs-number"><span class="hljs-number">100</span></span>*percent); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPointOnEllipse(point[<span class="hljs-number"><span class="hljs-number">0</span></span>], point[<span class="hljs-number"><span class="hljs-number">1</span></span>], resultRadian, point[<span class="hljs-number"><span class="hljs-number">4</span></span>], centerOfArc[<span class="hljs-number"><span class="hljs-number">0</span></span>], centerOfArc[<span class="hljs-number"><span class="hljs-number">1</span></span>]); } lastPoint = getPointOnEllipse(point[<span class="hljs-number"><span class="hljs-number">0</span></span>], point[<span class="hljs-number"><span class="hljs-number">1</span></span>], point[<span class="hljs-number"><span class="hljs-number">3</span></span>], point[<span class="hljs-number"><span class="hljs-number">4</span></span>], centerOfArc[<span class="hljs-number"><span class="hljs-number">0</span></span>], centerOfArc[<span class="hljs-number"><span class="hljs-number">1</span></span>]); controlPointsCounter++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(controlPointsCounter === lastControlPoint){ checkedCurve.push(lastPoint); } <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(point[<span class="hljs-number"><span class="hljs-number">2</span></span>] === <span class="hljs-literal"><span class="hljs-literal">true</span></span> || (points[pointIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; points[pointIndex+<span class="hljs-number"><span class="hljs-number">1</span></span>].length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>)){ controlPointsCounter++; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(controlPointsCounter &gt;= lastControlPoint){ checkedCurve.push(point); } lastPoint = point; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getPointOnCurve( (shiftLength - counter) / (services.map[lastControlPoint] / <span class="hljs-number"><span class="hljs-number">100</span></span>), checkedCurve ); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> points = [[<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>],[<span class="hljs-number"><span class="hljs-number">100</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>],[<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.PI],[<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">100</span></span>],[<span class="hljs-number"><span class="hljs-number">200</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> services = {}; services.map = getMapOfPath(points); services.length= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> services.map){ services.length += services.map[key]; } getPointOnPath(<span class="hljs-number"><span class="hljs-number">60</span></span>, points, services); <span class="hljs-comment"><span class="hljs-comment">// -&gt; [96.495, 98.036]</span></span></code> </pre><br></div></div><br>  Well, now we are cool dudes, a lot of things we can do. <br>  Link to examples <a href="http://takovoy.github.io/excessor/">here</a> . <br>  UPD.  Do not be intimidated by the extra lines in the example - this is the path with the ellipses included in it, since  Ninja is drawn only by splines. </div><p>Source: <a href="https://habr.com/ru/post/332192/">https://habr.com/ru/post/332192/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../332182/index.html">How to quickly remove multiple rows from a large database in MySQL</a></li>
<li><a href="../332184/index.html">Six Myths about Big Data</a></li>
<li><a href="../332186/index.html">4 popular mistakes in business card design</a></li>
<li><a href="../332188/index.html">Three days like all ticket offices in the country should become online (in fact, not)</a></li>
<li><a href="../332190/index.html">The tale of how an Android developer spammers, and that came out of it</a></li>
<li><a href="../332194/index.html">ArrayBuffer and SharedArrayBuffer in JavaScript, part 3: race streams and Atomics</a></li>
<li><a href="../332196/index.html">How to organize secure access using VPN</a></li>
<li><a href="../332198/index.html">Introduction to procedural animation: inverse kinematics</a></li>
<li><a href="../332200/index.html">VeeamON 2017: what marketers do not write in blogs</a></li>
<li><a href="../332202/index.html">About analytics and silver bullets or ‚ÄúWhat does Rambler / Top 100 have to do with it?‚Äù</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>