<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>10 ++ ways to work with hardware registers in C ++ (for example, IAR and Cortex M)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fig. I. Kiyko 

 All good health! 

 Remember, perhaps, a bearded anecdote, and perhaps a true story about how a student was asked about how to measur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>10 ++ ways to work with hardware registers in C ++ (for example, IAR and Cortex M)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/fd/id/cl/fdidclwtjklierjxrqybnqmttui.jpeg" alt="Choosing the safest path"><br>  <sub><b>Fig.</b></sub>  <sub><b>I. Kiyko</b></sub> <br><br>  All good health! <br><br>  Remember, perhaps, a bearded anecdote, and perhaps a true story about how a student was asked about how to measure the height of a building using a barometer.  The student led, in my opinion, in about 20 or 30 ways, without mentioning the direct (through the pressure difference) that the teacher expected. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Approximately in the same vein, I want to continue the discussion of using C ++ for microcontrollers and consider ways to work with registers using C ++.  And I want to note that there will be no easy way to achieve safe access to registers.  I will try to show all the pros and cons of ways.  If you know more ways, throw them in the comments.  So, let's begin: <br><a name="habracut"></a><br><h3>  Method 1. Obvious and obviously not the best. </h3><br>  The most common method, which is also used in C ++, is to use the description of register structures from the header file from the manufacturer.  For demonstration, I will take the two registers of port A (ODR - output data register and IDR - input data register) of the STM32F411 microcontroller, so that you can execute the Hello world - blink the LED. <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ GPIOA-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; GPIOA-&gt;IDR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,      }</span></span></code> </pre> <br>  Let's see what is happening here and how this design works.  In the header for the microprocessor, there is a <code>GPIO_TypeDef</code> structure and the definition of a pointer to this <code>GPIOA</code> structure.  It looks like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> __IO <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> MODER; <span class="hljs-comment"><span class="hljs-comment">//port mode register, Address offset: 0x00 __IO uint32_t OTYPER; //port output type register, Address offset: 0x04 __IO uint32_t OSPEEDR; //port output speed register, Address offset: 0x08 __IO uint32_t PUPDR; //port pull-up/pull-down register, Address offset: 0x0C __IO uint32_t IDR; //port input data register, Address offset: 0x10 __IO uint32_t ODR; //port output data register, Address offset: 0x14 __IO uint32_t BSRR; //port bit set/reset register, Address offset: 0x18 __IO uint32_t LCKR; //port configuration lock register, Address offset: 0x1C __IO uint32_t AFR[2]; //alternate function registers, Address offset: 0x20-0x24 } GPIO_TypeDef; #define PERIPH_BASE 0x40000000U //Peripheral base address in the alias region #define AHB1PERIPH_BASE (PERIPH_BASE + 0x00020000U) #define GPIOA_BASE (AHB1PERIPH_BASE + 0x0000U) #define GPIOA ((GPIO_TypeDef *) GPIOA_BASE)</span></span></code> </pre><br>  To put it in simple human words, then the entire structure of the type <code>GPIO_TypeDef</code> ‚Äúfalls‚Äù at the address <code>GPIOA_BASE</code> , and when referring to a specific field of the structure, you are essentially referring to the address of this structure + offset to an element of this structure.  If you remove <code>#define GPIOA</code> , the code would look like this: <br><br><pre> <code class="cpp hljs">((GPIO_TypeDef *) GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; ((GPIO_TypeDef *) GPIOA_BASE)-&gt;IDR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br>  In the case of the C ++ programming language, the integer address is converted to a pointer to a <code>GPIO_TypeDef</code> structure.  But in C ++, when using C conversion, the compiler tries to perform the conversion in the following sequence: <br><br><ul><li>  const_cast </li><li>  static_cast </li><li>  static_cast following const_cast, </li><li>  reinterpret_cast </li><li>  reinterpret_cast next to const_cast </li></ul><br>  those.  if the compiler was unable to convert the type using const_cast, it tries to use static_cast and so on.  As a result, the challenge: <br><br><pre> <code class="cpp hljs">((GPIO_TypeDef *) GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ;</code> </pre> <br>  there is nothing like: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;GPIO_TypeDef *&gt; (GPIOA_BASE)-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ;</code> </pre> <br>  In fact, for C ++ applications, it would be correct to ‚Äúpull‚Äù the structure onto an address like this: <br><br><pre> <code class="cpp hljs">GPIO_TypeDef * GPIOA{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;GPIO_TypeDef *&gt;(GPIOA_BASE)} ;</code> </pre> <br>  In any case, due to type conversion, there is a big disadvantage of this approach for C ++.  It <code>constexpr</code> in the fact that <code>reinterpret_cast</code> can not be used in <code>constexpr</code> constructors and functions, nor in the template parameters, and this significantly reduces the use of C ++ features for microcontrollers. <br>  Let me explain this with examples.  It is possible to do this: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b; } ; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;Test* mystruct&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Geta</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mystruct-&gt;a; } Test test{<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Geta&lt;&amp;test&gt;() ; }</code> </pre><br>  But this is already impossible to do: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;GPIO_TypeDef * mystruct&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constexpr</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">volatile</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetIdr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mystruct-&gt;IDR; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//GPIOA  reinterpret_cast&lt;GPIO_TypeDef *&gt; (GPIOA_BASE) //  ,        GetIdr&lt;GPIOA&gt;() ; // } //      : struct Port { constexpr Port(GPIO_TypeDef * ptr): port(*ptr) {} GPIO_TypeDef &amp; port ; } //  GPIOA  reinterpret_cast,   //  constexpr      constexpr Port portA{GPIOA}; //   </span></span></code> </pre><br>  Thus, the direct use of this approach imposes significant restrictions on the use of C ++.  We will not be able to locate the object that wants to use the pointer to <code>GPIOA</code> in ROM using the language tools, and we will not be able to take advantage of metaprogramming for such an object. <br>  In addition, in general, this method is not safety (as our western partners say).  After all, it is possible to do some stupidity. <br>  In connection with the foregoing, we summarize: <br><blockquote><h4>  pros </h4><br><ul><li>  Header is used from the manufacturer (it is checked, there are no errors) </li><li>  There are no additional gestures and costs, you take and use </li><li>  Ease of use </li><li>  Everyone knows and understands this way. </li><li>  No overhead </li></ul><br><h4>  Minuses </h4><br><ul><li>  Limited use of metaprogramming </li><li>  Impossibility to use in constexpr constructors </li><li>  When used in class wrappers, additional RAM consumption, on a pointer to an object of this structure </li><li>  Can do stupidity </li></ul></blockquote>  Now look at the method number 2 <br><br><h3>  Method 2. Brutal </h3><br>  Obviously, each programmer keeps in mind the addresses of all registers for all microcontrollers, so you can always just use the following method, which follows from the first: <br><br><pre> <code class="cpp hljs">*<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(GpioaOdrAddr) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>) ; *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(GpioaIdrAddr) ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt;<span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre> <br>  In any place of the program, you can always call the conversion to the <code>volatile uint32_t</code> address of the register and install anything there. <br>  There are no advantages here, but to those minuses that there will be added the inconvenience of use and the need to prescribe the address of each register in a separate file.  Therefore, we turn to method number 3. <br><br><h3>  Method 3. Obvious and obviously more correct. </h3><br>  If access to the registers occurs through the structure field, then instead of a pointer to the structure object, you can use the integer address of the structure.  The address of the structures is in the header file from the manufacturer (for example, GPIOA_BASE for GPIOA), so it is not necessary to remember it, but you can apply it both in templates and in constexpr expressions, and then ‚Äúoverlay‚Äù the structure to this address. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> pinNum&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pin</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Registers = GPIO_TypeDef ; __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toggle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     addr Registers *GpioPort{reinterpret_cast&lt;Registers*&gt;(addr)}; GpioPort-&gt;ODR ^= (1 &lt;&lt; pinNum) ; } }; int main() { using Led1 = Pin&lt;GPIOA_BASE, 5&gt; ; Led1::Toggle() ; }</span></span></code> </pre><br>  There are no particular disadvantages, from my point of view.  In principle, the working version.  But still, let's look at other ways. <br><br><h3>  Method 4. Exoteric wrapper </h3><br>  For lovers of understandable code, you can make a wrapper over the register, so that you can access them conveniently and look ‚Äúbeautiful‚Äù, make a constructor, redefine operators: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">explicit</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> addr)</span></span></span><span class="hljs-function"> : ptr</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) } { } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Register&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *ptr ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *ptr; <span class="hljs-comment"><span class="hljs-comment">//    }; int main() { Register Odr{GpioaOdrAddr}; Odr ^= (1 &lt;&lt; 5); Register Idr{GpioaIdrAddr}; Idr ^= (1 &lt;&lt; 5); // }</span></span></code> </pre><br>  As you can see, again you will have to either remember the integer addresses of all registers, or set them somewhere, and still have to store a pointer to the address of the register.  But again, not so much, <code>reinterpret_cast</code> happens again in the constructor <br>  There are some drawbacks, and the fact that in the first and second versions there was added the need for each register used to store a pointer of 4 bytes in RAM.  In general, not an option.  Look next. <br><br><h3>  Method 4.5.  Exoteric Template Wrapper </h3><br>  We add a grain of metaprogramming, but there is not much benefit from this.  This method differs from the previous one only in that the address is not transferred to the constructor, but in the template parameter, we save a little on the registers when passing the address to the constructor, this is already good: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Register() : ptr{<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr)} { } __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> Register &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *ptr ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *ptr; }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr&gt;; GpioaOdr Odr; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr&gt;; GpioaIdr Idr; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre><br>  And so, the same rake, side view. <br><br><h3>  Method 5. Reasonable </h3><br>  Obviously, we need to get rid of the pointer, so we will do the same, but remove the unnecessary pointer from the class. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline Register &amp;<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>^=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> right) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) ^= right; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr&gt;; GpioaOdr Odr; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr&gt;; GpioaIdr Idr; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">//</span></span></code> </pre><br>  You can stop here and talk a little.  This method immediately solves 2 problems that were inherited from the first method.  First, now I can use a pointer to a <code>Register</code> object in the template, and secondly, I can pass it on to the <code>constexrp</code> constructor. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;Register * <span class="hljs-keyword"><span class="hljs-keyword">register</span></span>&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">register</span></span> ^= mask ; } Register&lt;GpioaOdrAddr&gt; GpioaOdr; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Xor&lt;&amp;GpioaOdr&gt;(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//  } //   struct Port { constexpr Port(Register&amp; ref): register(ref) {} Register &amp; register ; } constexpr Port portA{GpioaOdr};</span></span></code> </pre><br>  Of course, it is necessary again, either to have eidetic memory to the addresses of registers, or to determine by hands all the addresses of registers somewhere in a separate file ... <br><blockquote><h4>  pros </h4><br><ul><li>  Ease of use </li><li>  Ability to use metaprogramming </li><li>  Ability to use in constexpr constructors </li></ul><br><h4>  Minuses </h4><br><ul><li>  Not using a valid header file from the manufacturer </li><li>  It is necessary to set all the addresses of registers </li><li>  You need to create an object class Register </li><li>  Can do stupidity </li></ul></blockquote><br>  Great, but there are still a lot of minuses ... <br><br><h3>  Method 6. Smarter than Reasonable </h3><br>  In the previous method, in order to access the register, it was necessary to create an object of this register, these are unnecessary waste of RAM and ROM, so we make a wrapper with static methods. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __<span class="hljs-function"><span class="hljs-function">forceinline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> *&gt;(addr) ^= mask; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case6 ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Odr = Register&lt;GpioaOdrAddr&gt;; Odr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Idr = Register&lt;GpioaIdrAddr&gt;; Idr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>); <span class="hljs-comment"><span class="hljs-comment">// }</span></span></code> </pre><br>  One plus is added <br><blockquote><ul><li>  No overhead.  Fast compact code, the same as in option 1 (When using wrappers in classes, there is no additional RAM cost, since the object is not created, but static methods are used without creating objects) </li></ul></blockquote>  Go ahead‚Ä¶ <br><br><h3>  Method 7. Remove stupidity </h3><br>  Obviously, I constantly do STUPID in the code and write something into a register that is not really intended for writing.  It's okay, of course, but stupidity should be prohibited.  Let's ban doing stupid.  To do this, we introduce auxiliary structures: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {};</code> </pre> <br>  Now we can set the registers for writing, and the registers are read-only: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RegisterType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//       WriteReg,    // ,  ,       __forceinline template &lt;typename T = RegisterType, class = typename std::enable_if_t&lt;std::is_base_of&lt;WriteReg, T&gt;::value&gt;&gt; Register &amp;operator^=(const uint32_t right) { *reinterpret_cast&lt;volatile uint32_t *&gt;(addr) ^= right; return *this; } };</span></span></code> </pre><br>  Now we will try to compile our test and see that the test is not compiled, because the <code>^=</code> operator for the <code>Idr</code> register <code>Idr</code> not exist: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr, WriteReg&gt; ; GpioaOdr Odr ; Odr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr, ReadReg&gt; ; GpioaIdr Idr ; Idr ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,  Idr    }</span></span></code> </pre> <br>  So, now there are more advantages ... <br><blockquote><h4>  pros </h4><br><ul><li>  Ease of use </li><li>  Ability to use metaprogramming </li><li>  Ability to use in constexpr constructors </li><li>  Fast compact code, the same as in option 1 </li><li>  When used in class wrappers, there is no additional RAM cost, since the object is not created, but static methods are used without creating objects. </li><li>  Can't do stupidity </li></ul><br><h4>  Minuses </h4><br><ul><li>  Not using a valid header file from the manufacturer </li><li>  It is necessary to set all the addresses of registers </li><li>  You need to create an object class Register </li></ul></blockquote><br>  So let's remove the ability to create a class to save more <br><br><h3>  Method 8. Without stupidity and without class object </h3><br>  Immediately code: <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = T, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(addr) ^= mask; } }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> main { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaOdr = Register&lt;GpioaOdrAddr, WriteReg&gt; ; GpioaOdr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioaIdr = Register&lt;GpioaIdrAddr, ReadReg&gt; ; GpioaIdr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//,  Idr    }</span></span></code> </pre><br>  We add one more plus, we do not create the object.  But we go further, we still have cons <br><br><h3>  Method 9. Method 8 with integration into the structure </h3><br>  In the previous method, only the register was defined.  But in method 1, all the registers are combined into structures so that it is convenient for the modules to access them.  Let's do it ... <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case9 { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = T, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { *<span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*&gt;(addr) ^= mask; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Moder = Register&lt;addr, ReadWriteReg&gt;; <span class="hljs-comment"><span class="hljs-comment">//      using Otyper = Register&lt;addr + OtyperShift, ReadWriteReg&gt; ; using Ospeedr = Register&lt;addr + OspeedrShift,ReadWriteReg&gt; ; using Pupdr = Register&lt;addr + PupdrShift,ReadWriteReg&gt; ; using Idr = Register&lt;addr + IdrShift, ReadReg&gt; ; using Odr = Register&lt;addr + OdrShift, WriteReg&gt; ; }; int main() { using Gpioa = Gpio&lt;GPIOA_BASE&gt; ; Gpioa::Odr::Xor(1 &lt;&lt; 5) ; Gpioa::Idr::Xor((1 &lt;&lt; 5) ); //,  Idr    }</span></span></code> </pre><br>  Here, the minus is that the structure will need to be re-written, and the offset of all the registers to remember and define somewhere.  It would be nice if the bias were asked by the compiler, not by the person, but this is later, but for now let's consider another interesting way suggested by my colleague. <br><br><h3>  Method 10. Wrapper over the register through a pointer to a member of the structure </h3><br>  It uses such a thing as a pointer to a member of the structure and <a href="https://en.cppreference.com/w/cpp/language/operator_member_access">access to them</a> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RegisterStructWrapper</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> P&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Xor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PT::*member, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mask)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T*&gt;(addr)-&gt;*member ^= mask ; <span class="hljs-comment"><span class="hljs-comment">//   ,     . } } ; using GpioaWrapper = RegisterStructWrapper&lt;GPIOA_BASE, GPIO_TypeDef&gt; ; int main() { GpioaWrapper::Xor(&amp;GPIO_TypeDef::ODR, (1 &lt;&lt; 5)) ; GpioaWrapper::Xor(&amp;GPIO_TypeDef::IDR, (1 &lt;&lt; 5)) ; // return 0 ; }</span></span></code> </pre><br><blockquote><h4>  pros </h4><br><ul><li>  Ease of use </li><li>  Ability to use metaprogramming </li><li>  Ability to use in constexpr constructors </li><li>  Fast compact code, the same as in option 1 </li><li>  When used in class wrappers, there is no additional RAM cost, since the object is not created, but static methods are used without creating objects. </li><li>  Used verified header file from manufacturer </li><li>  No need to set all the addresses of registers </li><li>  No need to create an object class Register </li></ul><br><h4>  Minuses </h4><br><ul><li>  You can make stupidity and even speculate on the clarity of the code </li></ul></blockquote><br><h3>  Method 10.5.  Combining method 9 and 10 </h3><br>  To find out the shift of the register relative to the beginning of the structure, you can use a pointer to a member of the structure: <code>volatile uint32_t T::*member</code> , it will return the offset of the member of the structure relative to its beginning in bytes.  For example, if we have a <code>GPIO_TypeDef</code> structure, then the address <code>&amp;GPIO_TypeDef::ODR</code> will be 0x14. <br>  Let's beat this feature and calculate the register addresses from method 9 using the compiler: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WriteReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadReg</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReadWriteReg</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> WriteReg, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReadReg {}; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> T::*member, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RegType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Register</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: __forceinline <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T1 = RegType, class = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_base_of&lt;WriteReg, T1&gt;::value&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt;T*&gt;(addr)-&gt;*member ^= mask ; } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> addr, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Gpio</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Moder = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::ODR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Otyper = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::OTYPER, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Ospeedr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::OSPEEDR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Pupdr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::PUPDR, ReadWriteReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Idr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::IDR, ReadReg&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Odr = Register&lt;addr, GPIO_TypeDef, &amp;GPIO_TypeDef::ODR, WriteReg&gt;; } ;</code> </pre> <br>  You can work with registers more exoterically: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> Case11 ; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Gpioa = Gpio&lt;GPIOA_BASE, GPIO_TypeDef&gt; ; Gpioa::Odr::Xor(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; <span class="hljs-comment"><span class="hljs-comment">//Gpioa::Idr::Xor((1 &lt;&lt; 5) ); //,  Idr   </span></span></code> </pre> <br>  Obviously, all the structures will have to be rewritten here.  This can be done automatically, by some script on Phyton, on the input of something like stm32f411xe.h on the output of your file with structures for use in C ++. <br>  In any case, there are several different ways that may be appropriate in a particular project. <br><br><h3>  Bonus  Enter language extension and parsim code using Phyton </h3><br>  The problem of working with registers in C ++ has been around for quite a while.  People decide it differently.  Of course, it would be great if the language supported something like renaming classes at compile time.  Well, let's say, what if it were like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;classname = [PortName]&gt; class Gpio[Portname] { __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask) { GPIO[PortName]-&gt;ODR ^= mask ; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> GpioA = Gpio&lt;<span class="hljs-string"><span class="hljs-string">"A"</span></span>&gt; ; GpioA::Xor(<span class="hljs-number"><span class="hljs-number">5</span></span>) ; }</code> </pre><br>  But unfortunately this language does not support.  Therefore, the solution that people use is parsing the code using Python.  Those.  some language extension is introduced.  The code, using this extension, is fed to the Python parser, which translates it into C ++ code.  Such code looks like this: (example is taken from the modm library <a href="">here is the complete source code</a> ): <br><br><pre> <code class="cpp hljs">%% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> port = gpio[<span class="hljs-string"><span class="hljs-string">"port"</span></span>] | upper %% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> reg = <span class="hljs-string"><span class="hljs-string">"GPIO"</span></span> ~ port %% <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> pin = gpio[<span class="hljs-string"><span class="hljs-string">"pin"</span></span>] class Gpio{{ port ~ pin }} : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Gpio { __forceinline <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Xor() { GPIO{{port}}-&gt;ODR ^= <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; {{pin}} ; } } <span class="hljs-comment"><span class="hljs-comment">//        class Gpio5 : public Gpio { __forceinline inline static void Xor() { GPIO-&gt;ODR ^= 1 &lt;&lt; 5 ; } } //     using Led = Gpio5; Led::Xor();</span></span></code> </pre><br><br><h3>  Update: Bonus.  Svd files and parser on phyton </h3><br>  Forgot to add another option.  ARM releases a register description file for each SVD manufacturer.  From which you can then generate a C ++ file with a description of the registers.  Paul Osborne collected all of these files on <a href="https://github.com/posborne/cmsis-svd">GitHub</a> .  He also wrote a Python script to parse them. <br><br>  That's all ... my imagination is exhausted.  If you still have ideas, well.  An example with all the ways <a href="https://onlinegdb.com/ry4pBaxWB">is here.</a> <br><br><h4>  Links </h4><br>  <a href="https://blog.salkinium.com/typesafe-register-access-in-c%2B%2B/">Typesafe Register Access in C ++</a> <br>  <a href="https://blog.feabhas.com/2017/03/making-things-stuff-part-1/">Making things do stuff -Accessing hardware from C ++</a> <br>  <a href="https://blog.feabhas.com/2017/04/making-things-stuff-part-3/">Making things do stuff - Part 3</a> <br>  <a href="https://blog.feabhas.com/2017/05/making-things-stuff-part-5/">Making things do stuff- Structure overlay</a> </div><p>Source: <a href="https://habr.com/ru/post/459204/">https://habr.com/ru/post/459204/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45919/index.html">Monty Hall's paradox: is there any difference?</a></li>
<li><a href="../459194/index.html">How we made friends with SCSS with CSS Variables on the example of UI Kit temization</a></li>
<li><a href="../459196/index.html">From monoliths to modular commands</a></li>
<li><a href="../459198/index.html">Performance analysis queries in ClickHouse. Yandex report</a></li>
<li><a href="../4592/index.html">List of reasons why VoIP will destroy traditional telecoms</a></li>
<li><a href="../459206/index.html">9 years in monolith on Node.JS</a></li>
<li><a href="../459208/index.html">Running with prostheses: nekstgen simulation of human movement with the help of muscles, bones and neural networks</a></li>
<li><a href="../45921/index.html">Home server - AMD, Debian x64, Bind9, Apache 2, PHP5, MySQL5, Trac, Subversion and a lot of fun</a></li>
<li><a href="../459212/index.html">Implementing properties in C ++</a></li>
<li><a href="../459214/index.html">Fault tolerance in storage Qsan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>