<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Selenium: New Hope</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I present to you the translation of my article on Medium.com: part 1 , part 2 . Since the first part of the article contains mostly already stated in ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Selenium: New Hope</h1><div class="post__text post__text-html js-mediator-article"><p>  I present to you the translation of my article on Medium.com: <a href="https://hackernoon.com/selenium-testing-a-new-hope-7fa87a501ee9">part 1</a> , <a href="https://hackernoon.com/selenium-testing-a-new-hope-a00649cdb100">part 2</a> .  Since the first part of the article contains mostly already stated in this <a href="https://habrahabr.ru/company/yandex/blog/268309/">post</a> , I cite the translation of only the second part. </p><br><img src="https://habrastorage.org/files/7f4/8ce/537/7f48ce537b054eec9e98635970272980.jpeg"><br><h1 id="hudeem-i-pereezzhaem-v-konteynery">  Lose weight and move to containers </h1><br><p>  In the first part of the article, I talked about simple approaches that allow building a scalable Selenium cluster without writing code.  In this part we will consider more subtle issues of working with Selenium: </p><br><ol><li>  How to create highly scalable work nodes using standard Selenium Hub </li><li>  Why it is possible and necessary to run most browsers in containers and how it is done </li><li>  What open-source tools for this exist </li></ol><br><a name="habracut"></a><br><h2 id="chto-vnutri-rabochey-nody">  What's inside the work node </h2><br><p>  All the new tools described in the first part are in fact smart lightweight proxies that redirect user requests to real Selenium hubs and nodes.  If you reflect a little, then questions arise: </p><br><ol><li>  How to organize hubs and nodes to effectively consume hardware resources and scale well? </li><li>  What operating system to use? </li><li>  What programs should be installed? </li><li>  Can I work without a monitor? </li></ol><br><p>  One way would be to use hardware with one Selenium hub and multiple nodes with different browsers.  It looks reasonable, but actually uncomfortable: </p><br><img src="https://habrastorage.org/files/ad3/fd9/bb6/ad3fd9bb671b4f0eb63bd261bcaaa3bb.png"><br><ol><li>  As it was said, the Selenium hub with a large number of loaded nodes works very slowly.  Not sure about the real reasons, but practice shows exactly that.  My advice - do not read the source code of Selenium at night, if you do not want to have nightmares.  Thus, we cannot use dozens of Selenium nodes with the same hub.  It remains to use one hub and only a few nodes.  To effectively use iron, you need to reduce the total number of cores per hub ‚Äî a good reason to move to the clouds.  For example, our working grid for a long time used small virtual machines with 2 cores and 4 GB of memory. </li><li>  It is not clear how to install different versions of the same browser in a simple way (for example, from packages). </li><li>  It is not clear how easy it is to take into account the total number of browsers of one version available. </li><li>  Different versions of Selenium nodes are compatible with different versions of browsers, i.e.  a newer Selenium node may not support an older browser. </li></ol><br><p>  The easiest way to have the same number of nodes per hub is to run them inside a single virtual machine.  If each browser version is a separate virtual machine, then counting the total number of available browsers becomes an elementary school task.  You can easily add and remove virtual machines that contain compatible versions of the node and browser.  We recommend this approach when installing a Selenium cluster in the cloud with a constantly available number of each browser version. </p><br><img src="https://habrastorage.org/files/ba4/159/4e8/ba41594e8a904132b9a161444683c585.png"><br><p>  What else besides Selenium hub and node is located inside the virtual machine for everything to work? </p><br><ul><li>  First, we recommend using Linux as the primary operating system wherever possible.  Using Linux, you can cover 80% of your browser needs.  It is easier to list what is not covered: <br><ol><li>  Internet Explorer and Microsoft Edge.  These browsers work only under Windows and deserve a separate article.  There is no sadder story in the world ... </li><li>  Desktop Safari.  Does anyone use it at all?  Selenium quite poorly supports this browser. </li><li>  iOS and Apple mobile phones.  To work with these devices, you need to use Apple hardware, for example, MacMini and <a href="http://github.com/appium/appium/">Appium</a> . </li></ol></li><li>  To run Selenium, you need to install Java (JDK or JRE), and also download the correct version of Selenium as a JAR archive. </li><li><p>  Virtual machines do not have a monitor, so Selenium must be running in a special version of the X server that emulates the display.  This implementation is called <a href="https://www.x.org/releases/X11R7.6/doc/man/man1/Xvfb.1.xhtml">Xvfb</a> .  It starts like this: </p><br><pre><code class="bash hljs">xvfb-run -l -a -s <span class="hljs-string"><span class="hljs-string">'-screen 0 1600x1200x24 -noreset'</span></span> \ java -jar /path/to/selenium-server-standalone.jar -role node &lt;... &gt;</code> </pre> <br><p>  Please note that Xvfb is only needed for the Selenium node process. </p><br></li><li>  You can also install additional font packages, for example, <a href="http://askubuntu.com/questions/578057/installation-of-fonts-in-ubuntu-14-04">Microsoft True Type fonts</a> . </li><li>  If you want to play a sound in your tests, then you need to configure the sound card support.  For Ubuntu, it can do something like this: <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash apt-get -y install linux-sound-base libasound2-dev alsa-utils alsa-oss apt-get -y install --reinstall linux-image-extra-`uname -r` modprobe snd-dummy if ! grep -Fxq "snd-dummy" /etc/modules; then echo "snd-dummy" &gt;&gt; /etc/modules fi adduser $(whoami) audio</span></span></code> </pre> <br><h2 id="hudeem">  Lose weight </h2><br><p>  As you can see, Selenium is a Java application.  To run Selenium, you need to install Java Virtual Machine (JVM).  The smallest Java installation package, called JRE, is about 50 megabytes in size.  Selenium JAR latest version 3.0.1 adds another 20 megabytes.  Now add the size of the operating system, the necessary fonts, the size of the browser itself and you easily reach several hundred megabytes.  And although hard drives are cheap now, we can do better.  Selenium versions 2.0 and 3.0 are also called Selenium Webdriver.  This is due to the fact that support for different browsers is implemented using separate applications, called web drivers. <br><img src="https://habrastorage.org/files/9ad/a36/ae7/9ada36ae75a449e9b926c11b8aa65050.png"><br></p><p>  Here's how it works: <br></p><ol><li>  Browser developers can write their product as they like.  In order for the browser to be supported in Selenium, they need to provide a web server application that provides the same API as the Selenium Server itself and supports the JSONWire protocol.  This application should be able to start the browser process, execute Selenium commands as per the specification and stop the browser on demand.  Any details of the interaction of the driver with the browser can be implemented at the discretion of the developers.  The only requirement is to support the same Selenium API.  For example, Chrome has <a href="https://sites.google.com/a/chromium.org/chromedriver/">Chromedriver</a> , Opera Blink provides <a href="https://github.com/operasoftware/operachromiumdriver">OperaDriver,</a> and so on. </li><li>  When installing Selenium, you only need to specify the path to the driver application. </li><li>  When you request a browser from Selenium, it actually starts the driver process and proxies all requests to the driver.  The driver does the rest of the work.  You can get the same result if you manually start the driver process on the required port and aim your tests at it. </li></ol><p></p><br><p></p><br><p>  Now that we‚Äôve figured it out, the question is: isn‚Äôt it too expensive to spend hundreds of megabytes for simple proxying?  A year ago, the answer was definitely not, because there was no driver application for Firefox - the most frequently used browser in Selenium.  The responsibility of Selenium was to launch Firefox, load a special extension into it, and proxy requests to the port opened by this extension.  Over the past year the situation has changed.  Starting with Firefox 48.0, Selenium interacts with the browser using a separate binary driver, <a href="https://github.com/mozilla/geckodriver">Geckodriver</a> .  This means that now for most desktop browsers we can completely remove Selenium Server and proxy requests directly to the drivers. </p><br><h2 id="pereezzhaem-v-konteynery">  We move to containers </h2><br><p>  In the previous sections, I described how you can build a Selenium cluster using virtual machines in the cloud.  In this approach, virtual machines are always running and constantly spend your money.  In addition, the total number of browsers available for each version is limited and can lead to the complete exhaustion of available browsers during peak loads.  I heard about working and even patented complex solutions that launch and warm up a pool of virtual machines, depending on the current load, in order to always have available browsers.  It works, but can you do better?  The main problem of hypervisor virtualization is speed.  Starting a new virtual machine may take a few minutes.  But let's think a bit - do we need a separate operating system for each browser?  - No, only simple isolation by disk and network is needed.  This is why container virtualization is becoming relevant.  At the moment, containers work mostly only under Linux, but, as I said, Linux covers 80% of the most popular browsers.  Browser containers start in seconds and stop even faster. </p><br><img src="https://habrastorage.org/files/b99/4d6/10c/b994d610ce4c414c921bdf64aa1a92c8.png"><br><p>  What should be inside the container?  - Almost the same as inside the virtual machine: the browser itself, fonts, Xvfb.  For older versions of Firefox (&lt;48.0), you still need to install Java and Selenium Server, but for Chrome, Opera, and newer versions of Firefox, we can use the driver application as the main container process.  If you use a lightweight Linux distribution (for example, Alpine), you can get very small and lightweight containers. </p><br><h3 id="selenoid">  Selenoid </h3><br><p>  At the moment, the most popular and well-known container platform is <a href="https://www.docker.com/">Docker</a> .  Selenium developers provide a set of ready-made Docker containers for running Selenium in Standalone or Grid mode in Docker.  In order to start a cluster of such images, you need to start and stop containers manually or with the help of tools like <a href="https://docs.docker.com/compose/">Docker Compose</a> .  This approach is much better than installing Selenium from packages, but it would be even better if there was a server with the following behavior: </p><br><ol><li>  The administrator starts the server daemon instead of the usual Selenium hub. </li><li>  The daemon "knows" (from the configuration) that, for example, to launch Firefox 48.0, you need to download and run container X, and for Chrome 53, container Y. </li><li>  The user requests the Selenium session in the usual way, but from this new demon. </li><li>  The daemon analyzes the desired capabilities, starts the desired container, and then proxies requests to the main container process (Selenium server or web driver). </li></ol><br><p>  We made such a demon ... and even more. </p><br><p>  Over the years of using the Selenium server on a large scale, we realized that it is very inefficient to use the JVM and the "thick" Selenium JAR for simple proxying requests.  Therefore, we were looking for a more lightweight technology.  Our choice was in the <a href="http://golang.org/">Go</a> programming language, also known as Golang.  Why is Go better for our goals? </p><br><ol><li>  Static linking.  The result of the compilation is one file - a binary that can be copied to the server and immediately run.  For start it is not necessary to install dependences and additional programs like JVM for Java. </li><li>  Cross compilation.  On the same machine with the same compiler, we can build binaries for different operating systems. </li><li>  Rich standard library.  For us, the most important was the support from the box reverse-proxying and HTTP / 2. </li><li>  A large community of developers.  The language is already becoming one of the most popular for a particular class of tasks. </li><li>  Well maintained in IDE.  For Go there is a good plugin for IntellijIDEA and an alpha version of the full-fledged IDE Goglang from the same developers. </li></ol><br><p>  We never came up with a good name for the demon described above.  Therefore, we called it simply <a href="http://github.com/aandryashin/selenoid">Selenoid</a> .  To try Selenoid you need to follow 3 simple steps: </p><br><ul><li>  Create a JSON file containing information about which container to launch for each browser version: </li></ul><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"firefox"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: <span class="hljs-string"><span class="hljs-string">"latest"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"versions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"49.0"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"image"</span></span>: <span class="hljs-string"><span class="hljs-string">"selenoid/firefox:49.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-string"><span class="hljs-string">"4444"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"latest"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"image"</span></span>: <span class="hljs-string"><span class="hljs-string">"selenoid/firefox:latest"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-string"><span class="hljs-string">"4444"</span></span> } } }, <span class="hljs-attr"><span class="hljs-attr">"chrome"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: <span class="hljs-string"><span class="hljs-string">"54.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"versions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"54.0"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"image"</span></span>: <span class="hljs-string"><span class="hljs-string">"selenoid/chrome:54.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"port"</span></span>: <span class="hljs-string"><span class="hljs-string">"4444"</span></span> } } } }</code> </pre> <br><p>  As in the XML file for Gridrouter, a list of available browser versions is provided.  Since Selenoid runs containers on the same machine or through the Docker API, there is no need to specify host names and regions.  For each browser version, you need to specify the name of the container, its version and the port on which the main process of the container is listening. </p><br><ul><li>  Run Selenoid: </li></ul><br><pre> <code class="bash hljs">$ selenoid -<span class="hljs-built_in"><span class="hljs-built_in">limit</span></span> 10 -conf /etc/selenoid/browsers.json</code> </pre> <br><p>  By default, Selenoid starts on port 4444, just like a regular Selenium hub. </p><br><ul><li>  Run your tests on the Selenoid host, as if it were a regular Selenium hub. </li></ul><br><p>  Our experiments show that even containers with a standard Selenium server inside start in a few seconds.  In return, you get guaranteed disk and memory status.  The browser is always in a state like after installation on a clean operating system.  In addition, you can install Selenoid on a large cluster of hosts with the same set of supported browsers saved as Docker images.  This gives you a large cluster of Selenium, which automatically scales with the consumption of browsers.  For example, if current user requests require more Chrome, more containers automatically launch.  When there are no requests for Chrome, containers with Chrome are stopped and the vacant hosts can be used for other browsers. </p><br><p>  In order to ensure a better distribution of the load across the cluster, Selenoid limits the total number of concurrent sessions on a host and queues all requests that exceed the limit.  Requests from the queue are processed as earlier sessions are completed on the same host. </p><br><img src="https://habrastorage.org/files/6fe/1cb/2ec/6fe1cb2ec1604a0b993b1f57212ede05.png"><br><p>  But Selenoid allows you to run not only containers.  It can also run on-demand web driver processes.  The main application of this functionality is the replacement of Selenium Server with Windows.  In this case, Selenoid starts the IEDriverServer process, which saves memory and avoids proxying errors in Selenium itself. </p><br><h3 id="go-grid-router-takzhe-izvestnyy-kak-ggr">  Go Grid Router (also known as ggr) </h3><br><p>  You may remember that the original <a href="https://github.com/seleniumkit/gridrouter">GridRouter</a> is a Java application.  We wrote a lightweight implementation of this proxy on Go from scratch and simply called the <a href="https://github.com/aandryashin/ggr">Go Grid Router</a> (or ggr).  What are the advantages of the new version compared to the old one? </p><br><ol><li>  Increased performance.  It can serve at least 25% more requests. </li><li>  Lower memory consumption.  With a load of 150 rps it consumes only 100-200 megabytes of memory and this number does not change. </li><li>  Tracked client disconnection.  If a client disconnects (for example, due to a timeout), the Java version of GridRouter continues to iterate over the hosts, trying to create a session.  This clogs the network with unnecessary packets and reduces the performance of the GridRouter when many hubs become unavailable.  The new implementation on Go stops trying to get the browser as soon as the client is disconnected. </li><li>  Server restart without loss of connections (graceful restart).  If the server is used outside the Docker container, you can reboot it without losing connections by sending a SIGUSR2 signal to the process. </li><li>  Reload quotas on request.  When using multiple GridRouter instances behind a balancer, it is important to update quotas at the same time.  When new hosts are added to the XML quota files and the quotas are not updated at the same time on a running Selenium cluster, a situation may occur when one ‚Äúhead‚Äù of the GridRouter already knows about new hosts and redirects requests there, and the other does not know about these hosts and returns a 404 error. The implementation on Go reloads quotas on the SIGHUP signal, rather than automatically, as it does in the Java version.  This functionality works both with and without Docker. </li><li>  Encrypted passwords.  Ggr uses Apache <a href="httpd.apache.org/docs/2.4/misc/password_encryptions.html">htpasswd</a> text files to store logins and passwords.  Logins are stored in clear text and passwords are encrypted. </li><li>  Small size of executable file.  Only 6 megabytes.  Does not require installing Java.  If installed in Docker, the Alpine Linux-based container occupies only 11 megabytes. </li></ol><br><p>  In conjunction with Selenoid, allows you to create a scalable, reliable Selenium cluster: </p><br><img src="https://habrastorage.org/files/f04/af5/ba4/f04af5ba44e64bafbc10e9b06b3a0702.png"><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  In this part, I talked about the latest technologies that can be used to organize a modern Selenium cluster: </p><br><ol><li>  Why Selenium packs well and runs in containers </li><li>  What should be inside the container </li><li>  What open-source tools for running Selenium in containers exist </li></ol><br><h1 id="ssylki">  Links </h1><br><p>  In conclusion, in one place are collected links to the products mentioned in the article: </p><br><ol><li>  <a href="https://github.com/aandryashin/selenoid">Selenoid</a> </li><li>  <a href="https://github.com/aandryashin/ggr">Go grid router</a> </li><li>  <a href="https://github.com/seleniumkit/gridrouter">Grid router</a> </li></ol></li></ul></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/322742/">https://habr.com/ru/post/322742/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322732/index.html">LED-it-GO - Data Security Risk</a></li>
<li><a href="../322734/index.html">Check-list: what is VDI or how to distinguish a real product from ‚Äúimport-substituted‚Äù crafts</a></li>
<li><a href="../322736/index.html">Travel Financial Transaction</a></li>
<li><a href="../322738/index.html">The role of the payment service in online transactions</a></li>
<li><a href="../322740/index.html">10 sins in site / application navigation systems</a></li>
<li><a href="../322744/index.html">Configure replication between PostgreSQL and PipelineDB</a></li>
<li><a href="../322748/index.html">The third conference of JavaScript-developers in Odessa "JS Lab" is looking for speakers</a></li>
<li><a href="../322750/index.html">A brief algorithm for selecting a team for a startup</a></li>
<li><a href="../322752/index.html">What does the Landing Page structure consist of and how to write a marketing headline</a></li>
<li><a href="../322754/index.html">Restore data storage and VMFS partitions. Lifting the EMC iomega from that light ...</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>