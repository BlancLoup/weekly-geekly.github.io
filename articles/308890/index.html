<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Overloading all 49 statements in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear readers of Habr! 

 When I just started my way of learning C ++, I had a lot of questions to which, at times, I could not quickly find ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Overloading all 49 statements in C ++</h1><div class="post__text post__text-html js-mediator-article">  Good day, dear readers of Habr! <br><br>  When I just started my way of learning C ++, I had a lot of questions to which, at times, I could not quickly find the answers.  Such an issue as operator overload was no exception.  Now, when I figured out this topic, I want to help others <i>dot the i</i> . <br><br>  In this publication, I will tell you about the various subtleties of operator overloading, why this overload is generally needed, about operator types (unary / binary), operator overloading with a friend (friendly function), as well as about the types of values ‚Äã‚Äãaccepted and returned by overloads. <br><a name="habracut"></a><br>  <b>UPD.:</b> For those who prefer the video format <b>there is a video</b> : <a href="https://youtu.be/Qn6mu9l6Xj8">https://youtu.be/Qn6mu9l6Xj8</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  What is overloading for? </h1><br>  Suppose that you create your own class or structure, let it describe a vector in 3-dimensional space: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, y, z; Vector3() {} Vector3(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> y, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z) : x(x), y(y), z(z) {} };</code> </pre> <br>  Now, you create 3 objects of this structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">10</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">20</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">20</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">, v3</span></span>; <span class="hljs-comment"><span class="hljs-comment">//...</span></span></code> </pre><br>  And you want to align the object v2 with the object v1, write: <br><br><pre> <code class="cpp hljs">v1 = v2;</code> </pre><br>  Everything works, but the vector example is very much simplified, maybe you have a structure in which you need not blindly copy all the values ‚Äã‚Äãfrom one object to another (as it happens by default), but produce some manipulations with them.  For example, do not copy the last variable z.  How does the program know about it?  She needs clear commands that she will execute. <br><br>  Therefore, we need to overload the assignment operator (=). <br><br><h1>  Understanding Operator Overloading </h1><br>  To do this, add an overload to our structure: <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (Vector3 v1) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;x = v1.x, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;y = v1.y, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;z = <span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre><br>  Now, in the code above, we indicated that during assignment, it is necessary to copy the variables <b>x</b> and <b>y</b> , and <b>z to</b> zero. <br><br>  <b>UPD .:</b> Thanks for the <a href="https://habrahabr.ru/users/eivind/" class="user_link">Eivind</a> hint.  Did not take into account in the article that the assignment operators should return the reference to * this, and not the value.  This is the de facto standard expected behavior. <br><br>  That is, the following code would be more correct: <br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (Vector3 v1) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;x = v1.x, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;y = v1.y, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;z = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br><br>  But such an overload is far from perfect, let's imagine that our structure contains not 3 variables of type int, but many objects of other classes, in this case this variant of overload will work rather slowly. <br><br><ul><li>  The first thing we can do is to transfer to the overload method not the entire object, but the link to the place where it is stored: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    (&amp;v1) Vector3 operator = (Vector3 &amp;v1) { return Vector3(this-&gt;x = v1.x, this-&gt;y = v1.y, this-&gt;z = 0); }</span></span></code> </pre><br>  When we pass an object <b>not by reference</b> , a new object is in fact created (a copy of the one that is passed to the method), which may incur certain costs for both the runtime of the program and the memory it consumes.  - Applied to large objects. <br><br>  By transferring an object <b>by reference</b> , memory is not allocated for the object itself (say, 128 bytes) and the copy operation, memory is allocated only for a pointer to a memory cell with which we work, which is about 4 - 8 bytes.  Thus, it turns out to work with the object on the line. <br><br></li><li>  But, if we pass an object by reference, then it <b>becomes mutable</b> .  That is, nothing prevents us from assigning (v1 = v2) to change not only the value of v1, but also v2! <br><br>  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   Vector3 operator = (Vector3 &amp;v) { // ,     = vx = 10; vy = 50; //       = return Vector3(this-&gt;x = vx, this-&gt;y = vy, this-&gt;z = 0); }</span></span></code> </pre><br>  Of course, it is unlikely that someone in their right mind will produce such not obvious manipulations.  But still, it does not hurt to <b>exclude even the likelihood of</b> such a change. <br><br>  To do this, we just need to add const before the argument, so we will point out that this object cannot be changed from the inside of the method. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    Vector3 operator = (const Vector3 &amp;v) { //   ,     = //vx = 10; vy = 50; //       = return Vector3(this-&gt;x = vx, this-&gt;y = vy, this-&gt;z = 0); }</span></span></code> </pre><br></li><li>  Now, let's look at the <b>type of return value</b> .  The overload method returns a Vector3 object, that is, a new object is created, which can lead to the same problems that I described in the very first paragraph.  And the solution will not be different originality, we do not need to create a new object - it means simply passing the link to an existing one. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,     Vector3&amp; operator = (const Vector3 &amp;v) { return Vector3(this-&gt;x = vx, this-&gt;y = vy, this-&gt;z = 0); }</span></span></code> </pre><br>  But when returning the link, certain problems may appear. <br><br>  <b>We will not write</b> such an expression: <i>v1 = (v2 + v3);</i> <br><br>  <b>A small digression about return:</b> <br>  When I studied overload, I did not understand: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  this-&gt;x = ... (       ) return Vector3(this-&gt;x = vx, this-&gt;y = vy, this-&gt;z = 0); //        ? //     ? (   ) return Vector3(vx, vy, 0);</span></span></code> </pre><br>  The fact is that we must independently and explicitly indicate all operations in the body of the method.  What does it mean to write: <i>this-&gt; x = vx</i> , etc. <br><br>  But why then return, what do we return?  In fact, the return in this example plays a fairly formal role, we can well do without it: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// void () void operator = (const Vector3 &amp;v1) { this-&gt;x = v1.x, this-&gt;y = v1.y, this-&gt;z = 0; }</span></span></code> </pre><br>  And this code works quite well.  Since  all that needs to be done is indicated in the body of the method. <br>  But in this case, we can not make such a record: <br><br><pre> <code class="cpp hljs">v1 = (v2 = v3); <span class="hljs-comment"><span class="hljs-comment">//  void operator + //v1 = void? -  v1 = (v2 + v3);</span></span></code> </pre><br>  Since  returns nothing, cannot be done and assignment.  Or, <b>in the case of a link</b> that turns out similarly to void, a reference is returned to the temporary object that no longer exists at the time of its use (will be erased after the method is executed). <br><br>  It turns out that it is better to return the object and not the link?  Not everything is so simple, and choose the type of return value (object or reference) is necessary in each case.  But for most small objects, it is better to return the object itself, so that we can work with the result further. <br><br>  <b>Digression 2 (how not to do it):</b> <br>  Now, knowing the difference between the return operation and the direct execution of the operation, we can write the following code: <br><br><pre> <code class="cpp hljs">v1(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>); v2(<span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>, <span class="hljs-number"><span class="hljs-number">15</span></span>); v3; v3 = (v1 + v2); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; v1; <span class="hljs-comment"><span class="hljs-comment">//  (10, 10, 10),  (12, 13, 14) cout &lt;&lt; v2; //  (15, 15, 15),  (50, 50, 50) cout &lt;&lt; v3; //  (25, 25, 25),  ,  </span></span></code> </pre><br>  In order to realize this horror, we define overload in this way: <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (Vector3 &amp;v1, Vector3 &amp;v2) { v1.x += <span class="hljs-number"><span class="hljs-number">2</span></span>, v1.y += <span class="hljs-number"><span class="hljs-number">13</span></span>, v1.z += <span class="hljs-number"><span class="hljs-number">4</span></span>; v2(<span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3(<span class="hljs-comment"><span class="hljs-comment">/*,  */</span></span>); }</code> </pre><br></li><li>  And when we overload the assignment operator, there remains the need to eliminate the alternate assignment in the rare case when, for some reason, the object is assigned to itself: v1 = v1. <br>  To do this, add the following condition: <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v1) { <span class="hljs-comment"><span class="hljs-comment">//      ,      //(   /) if (&amp;v1 == this) return *this; return Vector3(this-&gt;x = v1.x, this-&gt;y = v1.y, this-&gt;z = v1.z); }</span></span></code> </pre><br></li></ul><br><h1>  Differences between unary and binary operators </h1><br>  Unary operators are those operators where only one object is involved, to which all changes are applied. <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v1); <span class="hljs-comment"><span class="hljs-comment">//   Vector3 operator - (const Vector3 &amp;v1); //   //  : //++, --, !, ~, [], *, &amp;, (), (type), new, delete</span></span></code> </pre><br>  Binary operators - work with 2 objects <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v2); <span class="hljs-comment"><span class="hljs-comment">// -    ! Vector3 operator - (const Vector3 &amp;v1, const Vector3 &amp;v2); // -    ! //  : //*, /, %, ==, !=, &gt;, &lt;, &gt;=, &lt;=, &amp;&amp;, ||, &amp;, |, ^, &lt;&lt;, &gt;&gt;, +=, -=, *=, /=, %=, &amp;=, |=, ^=, &lt;&lt;=, &gt;&gt;=, -&gt;, -&gt;*, (,), ","</span></span></code> </pre><br><h1>  Overload in body and body class </h1><br>  We can declare and implement an overload directly in the body of the class or structure itself.  I think that how to do it is already clear.  Let's consider a variant in which the declaration of an overload occurs in the class body, and its implementation is already outside the class. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//, , ... //  ,       = Vector3 operator = (Vector3 &amp;v1); }; //      //   "Vector3::",    ,       //  Vector3 -     Vector3 Vector3::operator = (Vector3 &amp;v1); { return Vector3(this-&gt;x = v1.x, this-&gt;y = v1.y, this-&gt;z = 0); }</span></span></code> </pre><br><h1>  Why in friend operator overloading (friend)? </h1><br>  Friendly functions are those functions that have access to <b>private</b> methods of a class or structure. <br><br>  Suppose that in our Vector3 structure, such members as x, y, z are private, then we cannot access them outside the structure body.  This is where the friendly functions help. <br>  The only change we need to make is to add the <b>fried</b> keyword before overload declaration: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector3</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (Vector3 &amp;v1); }; <span class="hljs-comment"><span class="hljs-comment">//    </span></span></code> </pre><br><h1>  When can you not do without friendly functions in operator overloading? </h1><br>  <strong>1)</strong> When we implement an interface (.h file) in which only method declarations are placed, and the implementation is placed in a hidden .dll file <br><br>  <strong>2)</strong> When the operation is performed on objects of different classes.  Example: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Vector2  Vector3 Vector2 operator + (Vector3 v3) {/*...*/} } // Vector2    Vector2  Vector3 vec2 = vec2 + vec3; //Ok vec2 = vec3 + vec2; //</span></span></code> </pre><br>  The error will occur for the following reason; in the Vector2 structure, we overloaded the + operator, which takes the Vector3 type as the value on the right, so the first option works.  But in the second case, it is necessary to write the overload already for the Vector3 structure, and not 2. In order not to go into the implementation of the Vector3 class, we can write the following friendly function: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vector2</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">// Vector2  Vector3 Vector2 operator + (Vector3 v3) {/*...*/} //   ,         Vector3 friend Vector2 operator + (Vector3 v3, Vector2 v2) {/*...*/} } vec2 = vec2 + vec3; //Ok vec2 = vec3 + vec2; //Ok</span></span></code> </pre><br><hr><br><h1>  Examples of different operator overloads with some explanations. </h1><br>  Example of overload <b>for binary +, -, *, /,%</b> <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z); }</code> </pre><br>  Overload example for postfix increment and decrement forms ( <b>var ++, var--</b> ) <br><br><pre> <code class="cpp hljs">Vector3 Vector3::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ++ (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;x++, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;y++, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;z++); }</code> </pre><br>  Overload example for prefix increment and decrement forms ( <b>++ var, --var</b> ) <br><br><pre> <code class="cpp hljs">Vector3 Vector3::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ++ () { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3(++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;x, ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;y, ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;z); }</code> </pre><br>  Overloading arithmetic operations <b>with objects of other classes</b> <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3(v1.x * i, v1.y * i, v1.z * i); }</code> </pre><br>  <b>Unary Plus</b> Overload <b>(+)</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  ,    Vector3 operator + (const Vector3 &amp;v) { return v; }</span></span></code> </pre><br>  <b>Unary Minus</b> Overload <b>(-)</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   -1 Vector3 operator - (const Vector3 &amp;v) { return Vector3(vx * -1, vy * -1, vz * -1); }</span></span></code> </pre><br>  Example of overloading of <b>compound assignment</b> operations <b>+ =, - =, * =, / =,% =</b> <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> += (Vector3 &amp;v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3(v1.x = v1.x + v2.x, v1.y = v1.y + v2.y, v1.z = v1.z + v2.z); }</code> </pre><br>  A good example of overloading <b>comparison</b> operators <b>==,! =,&gt;, &lt;,&gt; =, &lt;=</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt; (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v2) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTemp1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sqrt</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">pow</span></span></span></span><span class="hljs-function"><span class="hljs-params">(v1.x, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">) + </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">pow</span></span></span></span><span class="hljs-function"><span class="hljs-params">(v1.y, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">) + </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">pow</span></span></span></span><span class="hljs-function"><span class="hljs-params">(v1.z, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)))</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vTemp2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">sqrt</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">pow</span></span></span></span><span class="hljs-function"><span class="hljs-params">(v2.x, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">) + </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">pow</span></span></span></span><span class="hljs-function"><span class="hljs-params">(v2.y, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">) + </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">pow</span></span></span></span><span class="hljs-function"><span class="hljs-params">(v2.z, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)))</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vTemp1 &lt; vTemp2; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> == (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v1, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 &amp;v2) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((v1.x == v2.x) &amp;&amp; (v1.y == v2.y) &amp;&amp; (v1.z == v2.z)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-comment"><span class="hljs-comment">// !=     const bool operator != (const Vector3 &amp;v1, const Vector3 &amp;v2) { return !(v1 == v2); }</span></span></code> </pre><br>  Example of overloading <b>cast</b> operations <b>(type)</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    -  true Vector3::operator bool() const { if (*this != Vector3(0, 0, 0)) return true; return false; } //    int -     Vector3::operator int() const { return int(this-&gt;x + this-&gt;y + this-&gt;z); }</span></span></code> </pre><br>  An example of overloading <b>logical operators!, &amp;&amp;, ||</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ,        bool const bool operator ! (Vector3 &amp;v1) { return !(bool)v1; } const bool operator &amp;&amp; (Vector3 &amp;v1, Vector3 &amp;v2) { return (bool)v1 &amp;&amp; (bool)v2; }</span></span></code> </pre><br>  Example of overloading <b>bitwise operators ~, &amp;, |, ^, &lt;&lt;, &gt;&gt;</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   (   -1,   ) const Vector3 operator ~ (Vector3 &amp;v1) { return Vector3(~(v1.x), ~(v1.y), ~(v1.z)); } const Vector3 operator &amp; (const Vector3 &amp;v1, const Vector3 &amp;v2) { return Vector3(v1.x &amp; v2.x, v1.y &amp; v2.y, v1.z &amp; v2.z); } //   (xor) const Vector3 operator ^ (const Vector3 &amp;v1, const Vector3 &amp;v2) { return Vector3(v1.x ^ v2.x, v1.y ^ v2.y, v1.z ^ v2.z); } //     ostream&amp; operator &lt;&lt; (ostream &amp;s, const Vector3 &amp;v) { s &lt;&lt; '(' &lt;&lt; vx &lt;&lt; ", " &lt;&lt; vy &lt;&lt; ", " &lt;&lt; vz &lt;&lt; ')'; return s; } //     (  ) istream&amp; operator &gt;&gt; (istream &amp;s, Vector3 &amp;v) { std::cout &lt;&lt; " Vector3.\nX:"; std::cin &gt;&gt; vx; std::cout &lt;&lt; "\nY:"; std::cin &gt;&gt; vy; std::cout &lt;&lt; "\nZ:"; std::cin &gt;&gt; vz; std::cout &lt;&lt; endl; return s; }</span></span></code> </pre><br>  Example of overloading <b>bitwise compound assignment &amp; =, | =, ^ =, &lt;&lt; =, &gt;&gt; =</b> <br><br><pre> <code class="cpp hljs">Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> ^= (Vector3 &amp;v1, Vector3 &amp;v2) { v1(Vector3(v1.x = v1.x ^ v2.x, v1.y = v1.y ^ v2.y, v1.z = v1.z ^ v2.z)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> v1; } <span class="hljs-comment"><span class="hljs-comment">//   ostream&amp; operator &lt;&lt;= (ostream &amp;s, Vector3 &amp;v) { s.clear(); s &lt;&lt; '(' &lt;&lt; vx &lt;&lt; ", " &lt;&lt; vy &lt;&lt; ", " &lt;&lt; vz &lt;&lt; ')'; return s; }</span></span></code> </pre><br>  An example of overloading operators working with <b>pointers and class members [], (), *, &amp;, -&gt;, -&gt; *</b> <br>  I see no reason to overload (*, &amp;, -&gt;, -&gt; *), so there will be no examples below. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//  !   []    ,     //    () int Vector3::operator [] (int n) { try { if (n &lt; 3) { if (n == 0) return this-&gt;x; if (n == 1) return this-&gt;y; if (n == 2) return this-&gt;z; } else throw ":     "; } catch (char *str) { cerr &lt;&lt; str &lt;&lt; endl; } return NULL; } //       Vector3 Vector3::operator () (Vector3 &amp;v1, Vector3 &amp;v2) { return Vector3(v1 &amp; v2); }</span></span></code> </pre><br>  How to overload <b>new</b> and <b>delete</b> ?  Examples: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   1  void* Vector3::operator new(size_t v) { void *ptr = malloc(v); if (ptr == NULL) throw std::bad_alloc(); return ptr; } //     void* Vector3::operator new[](size_t v) { void *ptr = malloc(sizeof(Vector3) * v); if (ptr == NULL) throw std::bad_alloc(); return ptr; } void Vector3::operator delete(void* v) { free(v); } void Vector3::operator delete[](void* v) { free(v); }</span></span></code> </pre><br>  Overloading new and delete is a separate and rather large topic that I will not discuss in this publication. <br><br>  Operator overload <b>comma,</b> <br><br>  Attention!  Do not confuse the operator with a comma with an enum mark!  (Vector3 var1, var2;) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vector3 <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> , (Vector3 &amp;v1, Vector3 &amp;v2) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vector3(v1 * v2); } v1 = (Vector3(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>), Vector3(<span class="hljs-number"><span class="hljs-number">20</span></span>, <span class="hljs-number"><span class="hljs-number">25</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// : (200, 250, 300)</span></span></code> </pre><br><h4>  Sources </h4><br>  <strong>1)</strong> <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2582%25D0%25BE%25D1%2580%25D1%258B_%25D0%25B2_C_%25D0%25B8_C%252B%252B">https://ru.wikipedia.org/wiki/Operators in C and C ++</a> <br>  <strong>2)</strong> R. Lafor√© Object Oriented Programming in C ++ <br>  <b>3)</b> Thank you all for the comments on the publication and for pointing out the shortcomings! </div><p>Source: <a href="https://habr.com/ru/post/308890/">https://habr.com/ru/post/308890/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../308880/index.html">NGINX: Interception of 5xx errors using a debug server</a></li>
<li><a href="../308882/index.html">SRL - Simple Regex Language</a></li>
<li><a href="../308884/index.html">As I wrote a diploma / application created / on Google Play, I posted</a></li>
<li><a href="../308886/index.html">Refactoring banking IT infrastructure and how we were friends of the IT team with the information security team</a></li>
<li><a href="../308888/index.html">UltraVDS: any server with a 50% discount only on September 1</a></li>
<li><a href="../308892/index.html">Top 10 technologies for the Internet of Things: what will happen in the next two years?</a></li>
<li><a href="../308894/index.html">Simple coroutines for C ++ games</a></li>
<li><a href="../308896/index.html">The adventures of scissors in the digital world (a couple of lines about DevelStudio)</a></li>
<li><a href="../308898/index.html">1 million webcams infected with the BASHLITE worm and used for DDoS attacks</a></li>
<li><a href="../308900/index.html">We connect ATOL KKM to AndroidStudio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>