<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the RAII idiom and locks</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The RAII idiom (Resource Acquisition Is Initialization) originates in C ++ and consists in the fact that some resource is captured in the object's con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the RAII idiom and locks</h1><div class="post__text post__text-html js-mediator-article">  The RAII idiom (Resource Acquisition Is Initialization) originates in C ++ and consists in the fact that some resource is captured in the object's constructor and released in its destructor.  And since the destructor of local objects is automatically called when the method exits (or just out of scope), regardless of the cause (normal completion of the method or when an exception is thrown), using this idiom is the simplest and most effective way to write followed C ++ code safe from a point view of exceptions. <br><br>  When moving to ‚Äúmanaged‚Äù platforms, such as .NET or Java, this idiom in some way loses its relevance, since the garbage collector deals with the release of memory, namely memory was the most popular resource that had to be taken care of in C ++.  However, since the garbage collector deals only with memory and does not contribute to the deterministic release of resources (such as operating system descriptors), the RAII idiom is still used in .NET and in Java, even if few developers know about this intricate name. <br><a name="habracut"></a><br>  Starting with the first version of the C # language, we had at our disposal a <b>using</b> construct that provided automatic release of resources by calling the <b>Dispose</b> method.  Another method of deterministic release of resources was (and remains) the manual use of a <b>try</b> / <b>finally</b> block.  Let's look at the following couple of simple examples of using the <b>ReaderWriterLockSlim</b> class, which is designed to more effectively share a common resource between ‚Äúreaders‚Äù and ‚Äúwriters‚Äù: <br><br><img src="https://habrastorage.org/storage2/239/cb8/f03/239cb8f039578e1acc8c12de035ff438.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In the <b>ManualLockManagerment</b> method, manual locking is used, while the <b>UsingBasedMethod</b> method is based on a small shell.  A full example of this shell can be found <a href="">here</a> , but it‚Äôs not difficult to guess how it <b>works</b> : the <b>UseReadLock</b> extension <b>method</b> creates some object, the constructor of which takes the lock for reading, and the <b>Dispose</b> method frees it.  The question is how much the two fragments are equivalent and what should be preferred?  Of course, a ‚Äúbicycle‚Äù with a <b>using</b> block looks more readable, but is this the only difference between them? <br><br>  OK.  Let's complicate the first example a little.  That if in our code there is the possibility of recursive calls, when the method after the lock is captured for reading, it calls the method that locks the read lock again.  I don‚Äôt think that every reader remembers the behavior of the <b>ReaderWriterLockSlim</b> object in terms of re-capture (default reentrancy mode), so I‚Äôll immediately say that, unlike the <b>lock</b> construct, <b>ReaderWriterLockSlim</b> objects <b>do</b> not support recursive captures by default: <br><br><img src="https://habrastorage.org/storage2/2fe/648/3a5/2fe6483a5875b6b64c3a6f1bc9a26c34.png"><br><br>  In this case, we get the mismatched state of the lock object and the generation of the <b>SynchronizationLockException</b> exception, but how obvious is exactly which point in the code will generate it, and what consequences will it cause?  The problem with the above code is that it does not match the behavior of the RAII idiom and the <b>using</b> block: <b>resources should be freed in the</b> <b>finally</b> <b>block</b> <b>only if they were successfully captured before</b> . <br><br>  In this case, the following occurs: since the <b>ReaderWriterLockSlim</b> object <b>does</b> not support recursive captures, when you try to call the <b>EnterReadLock</b> method a second time (line 3 of the <b>AnotherMethod</b> method), a <b>LockRecusionException</b> exception will be generated, but since this call is inside the <b>try</b> block, the <b>AnotherMethod</b> method‚Äôs <b>finally</b> block is called a subsequent call to <b>ExitReadLock</b> .  As a result, in line 4 we will get a free lock, which in itself is not healthy, because we did not capture it;  after that, the control is returned to the <b>SomeMethod</b> method and goes to the <b>finally</b> block, where the <b>ExitReadLock</b> method will be called again. <br><br><h4>  <b>Deadlock</b> <b>and other troubles</b> </h4><br><br>  This is where the fun begins.  When I thought about the problem of using the construction <b>using</b> vs manual resource management via <b>try</b> / <b>finally</b> , I assumed that this code would fall with the exception in the line for the first time, and then fall again in line 2 of the <b>SomeMethod</b> method.  I reasoned like this: since <b>ReaderWriterLockSlim</b> does not support recursive captures, the original exception will occur in line 3, but since the lock will be released in line 4, then when you try to re-release the lock, the first method will generate another exception that will ‚Äúmask‚Äù the original exception. <br><br>  In such an artificial example, with this behavior, finding the real reason will be quite simple, but such behavior on the production server may make you feel good about the blood, because the code may not be so obvious, why does it say that the lock is not captured when it is necessarily captured in the beginning of the method. <br>  However, in fact, the behavior will be somewhat different, or rather, it will be exactly like this in .NET 4.5, but it will be completely different in previous versions of the platform.  Let's take it in order. <br><br>  The problem is that on .NET 4.0 (and below) the behavior will be as follows: an attempt to call the <b>ExitReadLock</b> method before calling the <b>EnterReadLock</b> method results in an exception, but two <b>ExitReadLock calls</b> after one <b>EnterReadLock</b> call <b>succeed</b> ! <br><br><img src="https://habrastorage.org/storage2/818/fa4/07f/818fa407f3a62827a33b6bad06a6c766.png"><br><br>  The most unpleasant thing in this matter is that in the <s>current</s> old versions of the framework, this code will not just succeed, it will lead to a mismatch of the state of the lock object, with the result that we will see the following on the console: <b>‚Äú</b> <b>ReadCount</b> <b>= 4294967295,</b> <b>ReadLockHeld</b> <b>=</b> <b>False</b> <b>‚Äù</b> .  In fact, in line 3 we reduced the value of the lock counter to 0, and in line 4 we reduced it again;  as a result, the counter became -1, and 4294967295 is just a representation of the value ‚Äú-1‚Äù in an unsigned format.  But most importantly, <b>any subsequent attempt at capturing a lock on a record will stick forever, since the dork will assume that the lock on reading is still captured.</b> <br><br>  As it turned out, this is a known bug in the .NET Framework, which is finally fixed in .NET 4.5.  After the VS2012 installation, we get quite expected, though not very pleasant behavior: the original exception that occurred when the lock was re-captured was masked by a new exception that occurs when trying to release an un-captured lock! <br><br><h4>  <b>Use</b> <b>using</b> <b>or capture resources correctly!</b> </h4><br><br>  Now let's remember how the <b>using</b> block <b>works</b> : <br><br><img src="https://habrastorage.org/storage2/9b7/6f0/c37/9b76f0c370c73d8ec12a04469c7197c2.png"><br><br>  The <b>using</b> construct is deployed in such a way that the resource is captured before the <b>try</b> block, so that when an exception is thrown when it is captured, the release will not be performed.  This behavior can lead to unpleasant consequences if the <b>using</b> construct is combined with the object initializer (details in the note <a href="http://sergeyteplyakov.blogspot.com/2012/05/using.html">Initializers of objects in the using block</a> ), but it fully corresponds to the behavior of constructors / destructors in C ++, in which the destructor was called only if the object was successfully created . <br><br>  <b>NOTE</b> <br>  Here we are confronted with another distinction between destructors in C ++ and a finalizer in C #.  Unlike the destructor, the finalizer is called even if the constructor of the created object fell with an exception.  This behavior is quite logical, as it simplifies the creation of a resource management code in the C # language, when the finalizer only needs to check the fact of successful resource capture (by checking for <b>null</b> , <b>IntPtr</b> <b>.</b> <b>Zero</b> , etc.). <br><br>  Since <b>using</b> the <b>Dispose</b> method is called only when the resource is successfully captured, the following code behaves as predictably as possible: the code calling the <b>SomeMethod</b> method will get an exception that occurred in line 2 of the <b>AnotherMethod</b> method when it tries to lock again, while the lock object is completely Normal condition in any version of the .NET Framework: <br><br><img src="https://habrastorage.org/storage2/c11/654/692/c11654692962e243495f46a2c251ad3e.png"></div><p>Source: <a href="https://habr.com/ru/post/150069/">https://habr.com/ru/post/150069/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150064/index.html">The insides of the QML engine. Part 1: Downloading Files</a></li>
<li><a href="../150065/index.html">23 reasons not to believe in bullshit about working in large companies</a></li>
<li><a href="../150066/index.html">Major Steam Community Update</a></li>
<li><a href="../150067/index.html">Homomorphic DIY Encryption</a></li>
<li><a href="../150068/index.html">Path with direction signs on a map using Yandex Map Kit for Android</a></li>
<li><a href="../150071/index.html">Graphics Optimization for Retina Screens</a></li>
<li><a href="../150075/index.html">Interlocks in InnoDB (cheat sheet)</a></li>
<li><a href="../150076/index.html">After 3000 years, all people will have a common ancestor living today.</a></li>
<li><a href="../150080/index.html">Radio-86RK on Maximite hardware</a></li>
<li><a href="../150081/index.html">Oracle shell call alternative method</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>