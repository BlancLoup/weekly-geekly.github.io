<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Carefully about counting single bits</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I would like to give the Habr community an article in which I try to give a fairly complete description of the approaches to the algorithms for calcul...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Carefully about counting single bits</h1><div class="post__text post__text-html js-mediator-article">  I would like to give the Habr community an article in which I try to give a fairly complete description of the approaches to the algorithms for calculating single bits in variables ranging in size from 8 to 64 bits.  These algorithms belong to the section of the so-called ‚Äúbit magic‚Äù or ‚Äúbit alchemy‚Äù, which fascinates with its beauty and non-obviousness many programmers.  I want to show that there is nothing difficult in the basics of this alchemy, and you can even develop your own methods of calculating single bits, having become acquainted with the fundamental techniques that make up these algorithms. <br><br><a name="habracut"></a><br><br>  Before we begin, I just want to warn you that this article is not for beginners in programming.  I need the reader to have a general idea of ‚Äã‚Äãthe simplest bit operations (bitwise "and", "or", shift), to have a good hexadecimal numbering system and to use the imagination quite confidently, presenting in it not always short bit sequences.  If possible, everything will be accompanied by pictures, but you know, they only simplify, but do not replace the full presentation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      All described techniques were implemented in C language and tested in two modes: 32 and 64 bits.  Thus, for a more complete understanding of the article, it would be better that you at least approximately understand the C language.  Testing took place on the processor Core 2 Duo E8400 @ 3GHz on 64-bit Windows 7. Measurement of the net operating time of the programs was carried out using the <a href="http://code.google.com/p/runexe">runexe</a> utility.  All source codes of the described algorithms are available <a href="https://yadi.sk/d/XiHe6MNtomAeh">in the archive</a> on the Yandex disk, their compilation is checked for compilers Visual C ++, Intel C ++, GCC and CLang, so in principle, you should have no problems if someone wants to double-check the results with them.  Linux users, I think, know better than me how to test the program runtime on their system, so I don‚Äôt give them any advice. <br><br>  Among the readers, there may be people who find it easier to watch the same thing on the video.  I recorded such a video (58 minutes), in which the presentation format is exactly the same, which will be lower in the text, but maybe in a slightly different style, more dry and strictly, while I tried to revive the text a little.  Therefore, study the material as it is more convenient to whom. <br><br><div class="spoiler">  <b class="spoiler_title">Watch the video</b> <div class="spoiler_text"><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/eSZ9wzJEnhU%3Ffeature%3Doembed&amp;xid=25657,15700021,15700186,15700190,15700248,15700253&amp;usg=ALkJrhj0M5wWXvgGuqnD9pV13uWxZnORyg" frameborder="0" allowfullscreen=""></iframe><br></div></div><br><br>  Now the algorithms generated by one or another set of alchemical methods will be sequentially described, in each section there will be a table comparing the working time for variables of different sizes, and at the end there will be a summary table for all algorithms.  All algorithms use pseudonyms for unsigned numbers from 8 to 64 bits. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> u8; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u16; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> u32; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> u64;</code> </pre> <br><br><h4>  Naive approach </h4><br>  It is obvious that bit alchemy is not used to shine at the interview, but with the aim of significantly accelerating the programs.  Acceleration in relation to what?  In relation to the trivial techniques that can come to mind when there is no time to go into the task in more detail.  This is the naive approach to calculating bits: we simply ‚Äúbite off‚Äù one bit after another and add them up by repeating the procedure until the number is zero. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes0</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 n)</span></span></span><span class="hljs-function"> </span></span>{ u8 res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n) { res += n&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>; n &gt;&gt;= <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  I do not see any reason to comment on this trivial cycle.  With the naked eye it is clear that if the high bit of the number n is 1, then the cycle will have to go through all the bits of the number before it reaches the high bit. <br><br>  Changing the type of the input parameter u8 to u16, u32 and u64 we get 4 different functions.  Let's test each of them on a stream of 2 <sup>32</sup> numbers given in a chaotic order.  It is clear that for u8 we have 256 different input data, but for consistency we still run 2 <sup>32</sup> random numbers for all these and all subsequent functions, always in the same order (for details you can refer to the curriculum code from the archive ). <br><br>  The time in the table below is in seconds.  For testing, the program was run three times and the average time was selected.  The error hardly exceeds 0.1 seconds.  The first column reflects the compiler mode (32-bit source code or 64-bit), then 4 columns are responsible for 4 variants of input data. <br><table><tbody><tr><th>  Mode </th><th>  u8 </th><th>  u16 </th><th>  u32 </th><th>  u64 </th></tr><tr><td>  x86 </td><td>  38.18 </td><td>  72.00 </td><td>  130.49 </td><td>  384.76 </td></tr><tr><td>  x64 </td><td>  37.72 </td><td>  71.51 </td><td>  131.47 </td><td>  227.46 </td></tr></tbody></table><br>  As we see, the speed of work quite naturally increases with increasing size of the input parameter.  The variant when the numbers are 64 bits in size and the calculation is in x86 mode is a little out of general regularity.  It's clear that the processor is forced to do fourfold work by doubling the input parameter, and it‚Äôs even good that it only copes three times slower. <br><br>  The first benefit of this approach is that when it is implemented it is difficult to make a mistake, therefore, a program written in this way can become a reference for testing more complex algorithms (this was exactly what was done in my case).  The second benefit is versatility and relatively simple portability for numbers of any size. <br><br><h4>  The trick with "biting off" the younger single bits </h4><br>  This alchemical method is based on the idea of ‚Äã‚Äãzeroing the low-order single bit.  Having the number n, we can cast the spell n = n &amp; (n-1), taking the younger one from the number n.  The picture below for n = 232 will clarify the situation for people who first learned about this trick. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/3c5/6bd/168/3c56bd1688634b279c4b9916b05b0576.png" width="50%"></div><br>  The program code has not changed much. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes1</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 n)</span></span></span><span class="hljs-function"> </span></span>{ u8 res = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n) { res ++; n &amp;= n<span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   . } return res; }</span></span></code> </pre><br>  Now the cycle will be executed exactly as many times as the units in the number n.  This does not eliminate the worst case when all the bits in a single number, but significantly reduces the average number of iterations.  Will this approach greatly ease the processor's pain?  In fact, not much, but for 8 bits it will be even worse.  Let me remind you that the summary table of results will be at the end, and here in each section will be its own table. <br><table><tbody><tr><th>  Mode </th><th>  u8 </th><th>  u16 </th><th>  u32 </th><th>  u64 </th></tr><tr><td>  x86 </td><td>  44.73 </td><td>  55,88 </td><td>  72.02 </td><td>  300.78 </td></tr><tr><td>  x64 </td><td>  40.96 </td><td>  69,16 </td><td>  79.13 </td><td>  126.72 </td></tr></tbody></table><br><br><h4>  Preliminary account </h4><br>  Let's not rush to move to the "hard" spells, consider the last simple technique that can save even the most inexperienced magician.  This solution is not directly related to bit alchemy, but for the sake of completeness, it should be considered without fail.  Let's get two tables for 256 and 65536 values, in which the answers for all possible 1-byte and 2-byte values ‚Äã‚Äãare calculated in advance, respectively. <br><pre> <code class="cpp hljs"> u8 BitsSetTableFF[<span class="hljs-number"><span class="hljs-number">256</span></span>]; <span class="hljs-comment"><span class="hljs-comment">//       u8 BitsSetTableFFFF[65536]; //      </span></span></code> </pre><br>  Now the program for 1 byte will look like this <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes2_FF</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BitsSetTableFF[n]; }</code> </pre><br>  To calculate the number of bits in larger numbers, they need to be divided into bytes.  For example, for u32 there could be such code: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes2_FF</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 n)</span></span></span><span class="hljs-function"> </span></span>{ u8 *p = (u8*)&amp;n; n = BitsSetTableFF[p[<span class="hljs-number"><span class="hljs-number">0</span></span>]] + BitsSetTableFF[p[<span class="hljs-number"><span class="hljs-number">1</span></span>]] + BitsSetTableFF[p[<span class="hljs-number"><span class="hljs-number">2</span></span>]] + BitsSetTableFF[p[<span class="hljs-number"><span class="hljs-number">3</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre><br>  Or such, if we use the table of predalagment for 2 bytes: <br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes2_FFFF</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 n)</span></span></span><span class="hljs-function"> </span></span>{ u16 *p = (u16*)&amp;n; n = BitsSetTableFFFF[p[<span class="hljs-number"><span class="hljs-number">0</span></span>]] + BitsSetTableFFFF[p[<span class="hljs-number"><span class="hljs-number">1</span></span>]]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre><br>  Well, then you guessed it, for each option of the size of the input parameter n (except 8 bits) there can be two versions of the pre-calculation, depending on which of the two tables we use.  I think the reader understands why we cannot just take and start the BitsSetTableFFFFFFFF table, but there may well be problems where this will be justified. <br><br>  Does the pre-submission work fast?  It all depends on the size, see the table below.  The first is for a single byte precondition, and the second is for two byte. <br><table><tbody><tr><th>  Mode </th><th>  u8 </th><th>  u16 </th><th>  u32 </th><th>  u64 </th></tr><tr><td>  x86 </td><td>  0.01 </td><td>  1.83 </td><td>  21.07 </td><td>  36.25 </td></tr><tr><td>  x64 </td><td>  0.01 </td><td>  1.44 </td><td>  24.79 </td><td>  26.84 </td></tr></tbody></table><br>  An interesting point: for the x64 mode, the pre-account for u64 works much faster, perhaps it is optimization features, although this does not appear in the second case. <br><table><tbody><tr><th>  Mode </th><th>  u8 </th><th>  u16 </th><th>  u32 </th><th>  u64 </th></tr><tr><td>  x86 </td><td>  --- </td><td>  0.05 </td><td>  7.95 </td><td>  13.01 </td></tr><tr><td>  x64 </td><td>  --- </td><td>  0.07 </td><td>  8.49 </td><td>  13.01 </td></tr></tbody></table><br>  Important note: this algorithm using the pre-calculation is beneficial only if the following two conditions are met: <b>(1)</b> you have extra memory, <b>(2)</b> you need to perform the calculation of the number of single bits much more than the size of the table itself, that is, you can ‚ÄúPlay‚Äù the time spent on pre-filling the table with some of the simple algorithms.  Perhaps you can also keep in mind the exotic condition, which in practice is always fulfilled.  You must ensure that the memory access itself is fast and does not slow down other functions of the system.  The fact is that accessing the table can throw out from the cache what was originally there and thus slow down some other part of the code.  You can hardly find a jamb quickly, but such monstrous optimizations are hardly necessary for anyone to practice in the implementation of ordinary programs. <br><br><h4>  Multiplication and remainder of division </h4><br>  Finally, take the stronger potions from our alchemy shelf.  With the help of multiplication and the remainder of the division by a power of two without a unit, quite interesting things can be done.  Let's start to create a spell with one byte.  For convenience, we denote all bits of a single byte in Latin letters from ‚Äúa‚Äù to ‚Äúh‚Äù.  Our number n takes the form: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/9c6/877/dff/9c6877dff8a54f659c3595eb89dc964c.png" width="40%"></div><br>  Multiplying n '= n‚ãÖ0x010101 (so, through the prefix "0x", I denote hexadecimal numbers) does nothing more than "replicating" one byte in triplicate: <br><div style="text-align:center;"><img src="https://habrastorage.org/files/af9/eb0/df3/af9eb0df31244ad8b44c58d4f88551ff.png" width="100%"></div><br>  Now let's mentally divide our 24 bits into 8 blocks with 3 bits in each (see the following picture, the first line of the table).  Then, using the bitwise ‚Äúand‚Äù with the mask 0x249249 (the second line of the table), we reset two high-order bits in each block. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/92e/de7/ce8/92ede7ce88db48afabc35304c6048867.png" width="100%"></div><br>  The third row of the table explains the hexadecimal mask entry.  The last line shows the result we achieved: all the bits of the original byte are each contained in its three-bit block, but in a different order (the order is not important to us). <br><br>  Now attention: we have to add these 8 blocks - and we get the sum of our bits! <br><br>  It turns out that the remainder of dividing a number A by 2 <sup>k</sup> -1 just gives the sum of the k-bit blocks of the number A, also taken modulo 2 <sup>k</sup> -1. <br><div class="spoiler">  <b class="spoiler_title">Proof</b> <div class="spoiler_text">  Divide the number A (in binary notation) into blocks of k bits in each (if necessary, you can add the latest, most significant, block of zeros).  Denote by A <sub>i the</sub> i-th block.  Now we write the value of the number A through the sum of these blocks, multiplied by the corresponding power of two: <br>  A = A <sub>0</sub> ‚ãÖ <sup>2</sup> <sub>0</sub> ‚ãÖ <sup>k</sup> + A <sub>1</sub> ‚ãÖ <sup>2</sup> <sub>1</sub> ‚ãÖ <sup>k</sup> + ... + A <sub>N-1</sub> ‚ãÖ 2 <sup>(N-1) ‚ãÖ k</sup> , <br>  where N is the number of blocks. <br>  Now let's calculate A mod (2 <sup>k</sup> -1). <br>  A mod (2 <sup>k</sup> -1) = (A <sub>0</sub> ‚ãÖ <sup>2</sup> <sub>0</sub> ‚ãÖ <sup>k</sup> + A <sub>1</sub> ‚ãÖ <sup>2</sup> <sub>1</sub> ‚ãÖ <sup>k</sup> + ... + A <sub>N-1</sub> ‚ãÖ 2 <sup>(N-1) ‚ãÖ k</sup> ) mod (2 <sup>k</sup> -1) = (A <sub>0</sub> + A <sub>1</sub> + ... + A <sub>N-1</sub> ) mod (2 <sup>k</sup> -1). <br>  This is due to the fact that 2 <sup>i‚ãÖk</sup> = 1 (mod (2 <sup>k</sup> -1)) for any non-negative integer i.  (True, it is important here that the trick makes sense when k&gt; 1, otherwise it‚Äôs not quite clear how we interpret module 1).  So we got the sum of blocks modulo 2 <sup>k</sup> -1. <br></div></div><br>  That is, we need to take the remainder of the division by 2 <sup>3</sup> -1 (seven) from the number we received, and we get the sum of our 8 blocks modulo 7. The trouble is that the sum of bits can be equal to 7 or 8, in which case the algorithm will give 0 and 1, respectively.  But let's see: in which case can we get an answer of 8?  Only when n = 255.  And in what case can we get 0?  Only when n = 0.  Therefore, if the algorithm after taking the remainder by 7 gives 0, then either we received n = 0 at the input, or among exactly 7 unit bits.  Summing up this reasoning, we get the following code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  ,   0. if (n == 0xFF) return 8; //  ,   8. n = (0x010101*n &amp; 0x249249) % 7; //      7. if (n == 0) return 7; //   7  . return n; // ,     1  6  . }</span></span></code> </pre><br>  In the case when n has a size of 16 bits, you can split it into two parts of 8 bits each.  For example: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CountOnes3 (u8(n&amp;<span class="hljs-number"><span class="hljs-number">0xFF</span></span>)) + CountOnes3 (u8(n&gt;&gt;<span class="hljs-number"><span class="hljs-number">8</span></span>));</code> </pre><br>  For the case of 32-bit and 64-bit such a division does not make sense even in theory, multiplication and the remainder of division with three branches will be too expensive if you perform them 4 or 8 times in a row.  But I left empty spaces for you in the table below, so if you don‚Äôt believe me, please fill them in yourself.  There are likely to be results comparable to the CountBits1 procedure, if you have a similar processor (I‚Äôm not saying that optimization with SSE is possible here, this will be a different matter). <br><table><tbody><tr><th>  Mode </th><th>  u8 </th><th>  u16 </th><th>  u32 </th><th>  u64 </th></tr><tr><td>  x86 </td><td>  12.42 </td><td>  30.57 </td><td>  --- </td><td>  --- </td></tr><tr><td>  x64 </td><td>  13.88 </td><td>  33.88 </td><td>  --- </td><td>  --- </td></tr></tbody></table><br>  This trick, of course, can be done without branching, but then we need that when dividing a number into blocks into a block, all numbers from 0 to 8 fit together, and this can be achieved only in the case of 4-bit blocks (and more).  To perform the summation of 4-bit blocks, you need to pick up a multiplier that will allow you to correctly "propagate" the number and take the remainder of the division by 2 <sup>4</sup> -1 = 15 to add the resulting blocks.  An experienced alchemist (who knows mathematics) will easily select such a factor: 0x08040201.  Why is he chosen this way? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/66f/dfc/e8e/66fdfce8e5c74a67ab6b8dd61a9cfe7b.png" width="100%"></div><br>  The fact is that we need all the bits of the original number to occupy the correct positions in their 4-bit blocks (picture above), and since 8 and 4 are not mutually simple numbers, the usual copying of 8 bits 4 times will not give the correct location of the necessary bits.  We have to add one zero to our byte, that is, to replicate 9 bits, since 9 is mutually simple with 4. So we get a number that has a size of 36 bits, but in which all the bits of the original byte are in lower positions of 4-bit blocks.  It remains only to take the bitwise "and" with the number 0x111111111 (the second line in the picture above), in order to reset the three high-order bits in each block.  Then the blocks need to be folded. <br><br>  With this approach, the program of counting single bits in a byte will be extremely simple: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3_x64</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((u64)<span class="hljs-number"><span class="hljs-number">0x08040201</span></span>*n &amp; <span class="hljs-number"><span class="hljs-number">0x111111111</span></span>) % <span class="hljs-number"><span class="hljs-number">15</span></span>; }</code> </pre><br>  The drawback of the program is obvious: it requires an output to 64-bit arithmetic with all the ensuing consequences.  It can be noted that in reality this program uses only 33 bits out of 64 (the upper 3 bits are zeroed), and in principle it is possible to figure out how to transfer these calculations to 32-bit arithmetic, but stories about such optimizations are not included in this topic. leadership.  Let's just learn the techniques for now, and you will have to optimize them yourself for a specific task. <br><br>  We will answer the question of how large the variable n can be in order for this trick to work correctly for it.  As soon as we take the remainder of division by 15, such a variable cannot have a size greater than 14 bits, otherwise we will have to apply branching, as we did before.  But for 14 bits, reception works if you add one zero to the 14 bits so that all the bits take up their positions.  Now I will assume that you have learned the essence of the reception as a whole and can easily select the multiplier for replication and the mask for zeroing out the unnecessary bits.  I will show the finished result immediately. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3_x64</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u14 n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    (   )! return (n*0x200040008001llu &amp; 0x111111111111111llu) % 15; }</span></span></code> </pre><br>  This program above shows what the code might look like if you had a variable of 14 bits in size without a sign.  The same code will work with a variable of 15 bits, but provided that the maximum is only 14 of them equal to one, or if the case where n = 0x7FFF we analyze separately.  This is all you need to understand in order to write the correct code for a variable of type u16.  The idea is to ‚Äúbite off‚Äù the low bit first, count the bits in the remaining 15-bit number, and then add the ‚Äúbit off‚Äù bit back. <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3_x64</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 n)</span></span></span><span class="hljs-function"> </span></span>{ u8 leastBit = n&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   . n &gt;&gt;= 1; //   15   . if (n == 0) return leastBit; //   0,     . if (n == 0x7FFF) return leastBit + 15; //  ,   15+ . return leastBit + (n*0x200040008001llu &amp; 0x111111111111111llu) % 15; //  ( 14+ ). }</span></span></code> </pre><br>  For n 32 bits, you have to conjure up with a more serious face ... First, the answer fits only 6 bits, but you can consider a separate case when n = 2 <sup>32</sup> -1 and calmly make calculations in fields of 5 bits.  This saves space and allows us to split the 32-bit field of the number n into 3 parts with 12 bits in each (yes, the last field will be incomplete).  Since 12‚ãÖ5 = 60, we can replicate one 12-bit field 5 times, pick up a multiplier, and then add 5-bit blocks, taking the remainder from division by 31. You need to do this 3 times for each field.  Summing up the result, we get the following code: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3_x64</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( u32 n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n + <span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>; u64 res = (n&amp;<span class="hljs-number"><span class="hljs-number">0xFFF</span></span>)*<span class="hljs-number"><span class="hljs-number">0x1001001001001</span></span>llu &amp; <span class="hljs-number"><span class="hljs-number">0x84210842108421</span></span>llu; res += ((n&amp;<span class="hljs-number"><span class="hljs-number">0xFFF000</span></span>)&gt;&gt;<span class="hljs-number"><span class="hljs-number">12</span></span>)*<span class="hljs-number"><span class="hljs-number">0x1001001001001</span></span>llu &amp; <span class="hljs-number"><span class="hljs-number">0x84210842108421</span></span>llu; res += (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">24</span></span>)*<span class="hljs-number"><span class="hljs-number">0x1001001001001</span></span>llu &amp; <span class="hljs-number"><span class="hljs-number">0x84210842108421</span></span>llu; res %= <span class="hljs-number"><span class="hljs-number">0x1F</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">31</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre><br>  Here, in the same way, instead of three branches, it was possible to take 3 residues from division, but I chose the branchy option, it will work better on my processor. <br><br>  For n 64 bits in size I did not manage to invent a suitable spell in which there would not be so many multiplications and additions.  It turned out either 6 or 7, and this is too much for such a task.  Another option is access to 128-bit arithmetic, and this is no longer understand what kind of ‚Äúrollback‚Äù for us will turn back, an untrained magician can also throw away to the wall :) <br><br>  Let's look at the time of work. <br><table><tbody><tr><th>  Mode </th><th>  u8 </th><th>  u16 </th><th>  u32 </th><th>  u64 </th></tr><tr><td>  x86 </td><td>  39.78 </td><td>  60.48 </td><td>  146.78 </td><td>  --- </td></tr><tr><td>  x64 </td><td>  6.78 </td><td>  12.28 </td><td>  31.12 </td><td>  --- </td></tr></tbody></table><br>  An obvious conclusion from this table is that 64-bit arithmetic is poorly perceived in 32-bit execution mode, although in general, the algorithm is not bad.  If we recall the speed of the pre-counting algorithm in x64 mode for a single-byte table for the case of u32 (24.79 s), we find that this algorithm is only 25% behind, and this is the reason for the competition embodied in the next section. <br><br><h4>  Replacing taking remainder by multiplication and shift </h4><br>  The disadvantage of taking a residue is obvious to everyone.  This is division, and division is long.  Of course, modern compilers know alchemy and know how to replace division by multiplication with a shift, and to get the remainder, you need to subtract from the dividend the particular multiplied by the divisor.  However, it is still long!  It turns out that in the ancient scrolls of the spellcasters of the code there is one interesting way of optimizing the previous algorithm.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can sum up the k-bit blocks by not taking the remainder of the division, but by another multiplication by the mask, with which the extra bits in the blocks are zeroed out. </font><font style="vertical-align: inherit;">Here‚Äôs what it looks like for n 1 bytes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To begin with, we replicate the byte three times and delete the two high-order bits from each 3-bit block using the formula 0x010101‚ãÖn &amp; 0x249249 already completed.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/435/d53/ed0/435d53ed079b455e85f6c645d222c61f.png" width="80%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For convenience, I marked each three-bit block with a capital Latin letter. </font><font style="vertical-align: inherit;">Now multiply the result by the same mask 0x249249. </font><font style="vertical-align: inherit;">The mask contains a single bit in every 3rd position, so this multiplication is equivalent to adding the number itself with itself 8 times, each time with a shift of 3 bits:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b13/3cc/325/b133cc325a5a404193a2541a6894efe0.png" width="60%"></div><br>  What do we see?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bits 21 through 23 give us the right amount! </font><font style="vertical-align: inherit;">At the same time, overflow in any of the blocks on the right is impossible, since there will not be a number greater than 7 in any block. The only problem is that if our sum is equal to 8, we will get 0, but that‚Äôs okay The case can be considered separately.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3_x64_m</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 n)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n == <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ((u64(<span class="hljs-number"><span class="hljs-number">0x010101</span></span>*n &amp; <span class="hljs-number"><span class="hljs-number">0x249249</span></span>) * <span class="hljs-number"><span class="hljs-number">0x249249</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">21</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x7</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In fact, we took the code from the previous section and replaced it with taking the remainder of dividing by 7 by multiplication, shift and bitwise "AND" at the end. </font><font style="vertical-align: inherit;">At the same time, instead of 3 branches, only one remained. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To create a similar program for 16 bits, we need to take the code from the previous section, which shows how to do this by taking the remainder of division by 15 and replace this procedure with multiplication. </font><font style="vertical-align: inherit;">In this case, it is not difficult to notice what conditions can be removed from the code.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3_x64_m</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 n)</span></span></span><span class="hljs-function"> </span></span>{ u8 leastBit = n&amp;<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    n &gt;&gt;= 1; //   15 . return leastBit + (( (n*0x200040008001llu &amp; 0x111111111111111llu)*0x111111111111111llu &gt;&gt; 56) &amp; 0xF); //  ( 15 +  ). }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For 32 bits, we do the same thing: we take the code from the previous section and, having painted a little on paper, we understand what the shift will be if we replace the remainder by multiplication. </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes3_x64_m</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( u32 n )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n+<span class="hljs-number"><span class="hljs-number">1</span></span> == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">32</span></span>; u64 res = (n&amp;<span class="hljs-number"><span class="hljs-number">0xFFF</span></span>)*<span class="hljs-number"><span class="hljs-number">0x1001001001001</span></span>llu &amp; <span class="hljs-number"><span class="hljs-number">0x84210842108421</span></span>llu; res += ((n&amp;<span class="hljs-number"><span class="hljs-number">0xFFF000</span></span>)&gt;&gt;<span class="hljs-number"><span class="hljs-number">12</span></span>)*<span class="hljs-number"><span class="hljs-number">0x1001001001001</span></span>llu &amp; <span class="hljs-number"><span class="hljs-number">0x84210842108421</span></span>llu; res += (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">24</span></span>)*<span class="hljs-number"><span class="hljs-number">0x1001001001001</span></span>llu &amp; <span class="hljs-number"><span class="hljs-number">0x84210842108421</span></span>llu; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (res*<span class="hljs-number"><span class="hljs-number">0x84210842108421</span></span>llu &gt;&gt; <span class="hljs-number"><span class="hljs-number">55</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x1F</span></span>; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For 64 bits, I also could not think of something that would not force my processor to perform the role of the stove. </font></font><br><table><tbody><tr><th>  Mode </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u8 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u16 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u32 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u64 </font></font></th></tr><tr><td>  x86 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 12.66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 42.37 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 99.90 </font></font></td><td>  --- </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x64 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 3.54 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4.51 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18.35 </font></font></td><td>  --- </td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pleasantly surprised by the results for the x64 mode. </font><font style="vertical-align: inherit;">As expected, we have overtaken the pre-count with a single-byte table for the case of u32. </font><font style="vertical-align: inherit;">Is it even possible to overtake the pre-submission? </font><font style="vertical-align: inherit;">Good question :)</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Parallel summation </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhaps this is the most common trick that very often not quite experienced spellcasters repeat one after another, not understanding how it works. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with 1 byte. </font><font style="vertical-align: inherit;">A byte consists of 4 fields of 2 bits each, first sum up the bits in these fields, saying something like:</font></font><br><pre> <code class="cpp hljs">n = (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0x55</span></span> + (n&amp;<span class="hljs-number"><span class="hljs-number">0x55</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is an explanatory picture of this operation (as before, we denote the bits of one byte by the first Latin letters): </font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/files/823/dfa/365/823dfa36591249c1a46fa04ab5d15884.png" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the bitwise "And" leaves only the low bits of each two-bit block, the second leaves the high-order bits, but shifts them to the positions corresponding to the low-order bits. </font><font style="vertical-align: inherit;">As a result of summation, we get the sum of adjacent bits in each two-bit block (the last line in the picture above). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now add pairs of numbers in two-bit fields, putting the result in 2 four-bit fields:</font></font><br><pre> <code class="cpp hljs">n = (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0x33</span></span> + (n&amp;<span class="hljs-number"><span class="hljs-number">0x33</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The following picture explains the result. </font><font style="vertical-align: inherit;">I quote it now without further ado:</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/files/420/531/ef9/420531ef916b487eba7b4ed558a016ec.png" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Finally, we add two numbers in four-bit fields: </font></font><br><pre> <code class="cpp hljs">n = (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>)&amp;<span class="hljs-number"><span class="hljs-number">0x0F</span></span> + (n&amp;<span class="hljs-number"><span class="hljs-number">0x0F</span></span>);</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/files/f95/cdc/e28/f95cdce2891b4a3fbfbd5cee9230e3a3.png" width="60%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Acting by analogy, you can extend the reception to any number of bits equal to the power of two. </font><font style="vertical-align: inherit;">The number of lines of the spell equals the binary logarithm of the number of bits. </font><font style="vertical-align: inherit;">Having caught the idea, take a casual look at the 4 functions, written below, to make sure that your understanding is correct.</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes4</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u8 n)</span></span></span><span class="hljs-function"> </span></span>{ n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x55</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x55</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x33</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x33</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x0F</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes4</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 n)</span></span></span><span class="hljs-function"> </span></span>{ n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x5555</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x5555</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x3333</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x3333</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x00FF</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x00FF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes4</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 n)</span></span></span><span class="hljs-function"> </span></span>{ n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x00FF00FF</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x00FF00FF</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0000FFFF</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x0000FFFF</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes4</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u64 n)</span></span></span><span class="hljs-function"> </span></span>{ n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>llu) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>llu); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>llu) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>llu); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F0F0F0F0F</span></span>llu) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F0F0F0F0F</span></span>llu); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x00FF00FF00FF00FF</span></span>llu) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x00FF00FF00FF00FF</span></span>llu); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">16</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x0000FFFF0000FFFF</span></span>llu) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x0000FFFF0000FFFF</span></span>llu); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">32</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x00000000FFFFFFFF</span></span>llu) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x00000000FFFFFFFF</span></span>llu); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this parallel summation does not end. </font><font style="vertical-align: inherit;">The idea allows us to develop the observation that the same bitmask is used twice in each line, which seems to suggest ‚Äúis it possible somehow to perform the bitwise‚Äú AND ‚Äùonly once?‚Äù. </font><font style="vertical-align: inherit;">It is possible, but not immediately. </font><font style="vertical-align: inherit;">Here is what you can do if you take the code for u32 as an example (see the comments).</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes4</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 n)</span></span></span><span class="hljs-function"> </span></span>{ n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     n = ((n&gt;&gt;2) &amp; 0x33333333) + (n &amp; 0x33333333); //   n = ((n&gt;&gt;4) &amp; 0x0F0F0F0F) + (n &amp; 0x0F0F0F0F); //   &amp;   n = ((n&gt;&gt;8) &amp; 0x00FF00FF) + (n &amp; 0x00FF00FF); //   &amp;   n = ((n&gt;&gt;16) &amp; 0x0000FFFF) + (n &amp; 0x0000FFFF); //    &amp; return n; //    8-  . }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As an exercise, I would like to suggest that you prove yourself why the following code will be an exact mapping of the previous one. </font><font style="vertical-align: inherit;">For the first line, I give a hint, but do not look at it immediately:</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hint</font></font></b> <div class="spoiler_text">   ab    2a+b,     ‚Ä¶? <br></div></div><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes4_opt</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u32 n)</span></span></span><span class="hljs-function"> </span></span>{ n -= (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>; n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span> ) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>); n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) + n) &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F</span></span>; n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">8</span></span>) + n) &amp; <span class="hljs-number"><span class="hljs-number">0x00FF00FF</span></span>; n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">16</span></span>) + n); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Similar optimization options are possible for other data types. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Below are two tables: one for the usual parallel summation, and the second for the optimized.</font></font><br><table><tbody><tr><th>  Mode </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u8 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u16 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u32 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u64 </font></font></th></tr><tr><td>  x86 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.52 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 14.10 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21,12 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 62.70 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x64 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.89 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 21.30 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 22,59 </font></font></td></tr></tbody></table><br><table><tbody><tr><th>  Mode </th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u8 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u16 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u32 </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> u64 </font></font></th></tr><tr><td>  x86 </td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 7.18 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 11.89 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 18.86 </font></font></td><td>  65.00 </td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x64 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8.09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10.27 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 19.20 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 19.20 </font></font></td></tr></tbody></table><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> In general, we see that the optimized algorithm works well, but loses to the usual in x86 mode for u64. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Combined method </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We see that the best options for calculating unit bits are the parallel method (with optimization) and the multiplication multiplication method for calculating the sum of blocks. </font><font style="vertical-align: inherit;">We can combine both methods by obtaining a combined algorithm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The first thing to do is execute the first three lines of the parallel algorithm. </font><font style="vertical-align: inherit;">This will give us the exact amount of bits in each byte of the number. </font><font style="vertical-align: inherit;">For example, for u32, do the following:</font></font><br><pre> <code class="cpp hljs"> n -= (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>; n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>); n = (((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) + n) &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F</span></span> );</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Now our number n consists of 4 bytes, which should be considered as 4 numbers, the sum of which we are looking for: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/fc9/114/46c/fc911446cb3d40299c9765dd059baea2.png" width="25%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can find the sum of these 4 bytes, if we multiply the number n by 0x01010101. </font><font style="vertical-align: inherit;">You now understand well what this multiplication means, for the convenience of determining the position in which the answer will be, I quote a picture:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a5e/464/d55/a5e464d55eba46508d424d51c91c211a.png" width="30%"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The answer is in 3-byte (if you count them from 0). </font><font style="vertical-align: inherit;">Thus, the combined reception for u32 will look like this:</font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes5</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( u32 n )</span></span></span><span class="hljs-function"> </span></span>{ n -= (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x55555555</span></span>; n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span> ) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x33333333</span></span>); n = ((((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) + n) &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F</span></span>) * <span class="hljs-number"><span class="hljs-number">0x01010101</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">24</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-comment"><span class="hljs-comment">//      8  . }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Same for u16: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes5</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u16 n)</span></span></span><span class="hljs-function"> </span></span>{ n -= (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x5555</span></span>; n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x3333</span></span>) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x3333</span></span>); n = ((((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) + n) &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F</span></span>) * <span class="hljs-number"><span class="hljs-number">0x0101</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-comment"><span class="hljs-comment">//      8  . }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Same for u64: </font></font><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">u8 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CountOnes5</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( u64 n )</span></span></span><span class="hljs-function"> </span></span>{ n -= (n&gt;&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x5555555555555555</span></span>llu; n = ((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>llu ) + (n &amp; <span class="hljs-number"><span class="hljs-number">0x3333333333333333</span></span>llu); n = ((((n&gt;&gt;<span class="hljs-number"><span class="hljs-number">4</span></span>) + n) &amp; <span class="hljs-number"><span class="hljs-number">0x0F0F0F0F0F0F0F0F</span></span>llu) * <span class="hljs-number"><span class="hljs-number">0x0101010101010101</span></span>) &gt;&gt; <span class="hljs-number"><span class="hljs-number">56</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; <span class="hljs-comment"><span class="hljs-comment">//      8  . }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The speed of this method, you can see immediately in the summary table. </font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Final comparison </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I invite the reader to independently draw his conclusions, having studied the two tables below. </font><font style="vertical-align: inherit;">In them I indicated the name of the methods, the programs to which we implemented, and also marked with a rectangular frame those approaches that I consider the best in each specific case. </font><font style="vertical-align: inherit;">Those who thought that the precontest always wins, expect a slight surprise for the x64 mode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final comparison for x86 compilation mode. </font></font><br><img src="https://habrastorage.org/files/dc6/49c/e47/dc649ce471ef4b6e8fca8e1534a3ecaf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Final comparison for x64 compilation mode.</font></font><br><img src="https://habrastorage.org/files/e7c/fb4/365/e7cfb43659b540988c2d99eb7463e1d6.png"><br><br><h4>  Comment </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In no case do not consider the final table as evidence in favor of one or another approach. Believe that on your processor and with your compiler some numbers in such a table will be completely different. Unfortunately, we can never say for sure which of the algorithms will be better in one way or another. For each task, you need to sharpen a specific method, and, unfortunately, there is no universal fast algorithm. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I have outlined the ideas that I know about myself, but these are only ideas, the specific implementations of which in different combinations can be very different. By combining these ideas in different ways, you can get a huge number of different algorithms for calculating single bits, each of which may well be good in some way.</font></font><br><br>  Thanks for attention.  See you again! <br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UPD</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : The POPCNT instruction from SSE4.2 is not included in the testing list, because I do not have a processor that supports SSE4.2.</font></font></div><p>Source: <a href="https://habr.com/ru/post/276957/">https://habr.com/ru/post/276957/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276945/index.html">How we ported the good old Russian quest</a></li>
<li><a href="../276949/index.html">Decryption of updates of one popular cellular modem: Dmitry Sklyarov method</a></li>
<li><a href="../276951/index.html">WhatsApp architecture Facebook bought for $ 19 billion</a></li>
<li><a href="../276953/index.html">We are looking for Mega developers: turn on the idea generator</a></li>
<li><a href="../276955/index.html">Rumors confirmed - Opera Software is sold to China</a></li>
<li><a href="../276961/index.html">Nginx 1.9.11 released with support for dynamic modules</a></li>
<li><a href="../276967/index.html">Hardware password manager or how to stop entering passwords and start living</a></li>
<li><a href="../276969/index.html">Dash opened source code for vending machine with InstantX</a></li>
<li><a href="../276971/index.html">RxSwift in action - we write reactive application</a></li>
<li><a href="../276973/index.html">Explaining the inexplicable. Part 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>