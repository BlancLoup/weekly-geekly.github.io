<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Data serialization or communication dialectics: simple serialization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Good day, dear. In this article, we will look at the most popular data serialization formats and conduct a little testing with them. This is the first...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Data serialization or communication dialectics: simple serialization</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/9e6/b38/ee8/9e6b38ee8f680a201089e45f564bc4ab.jpg" alt="image" align="left">  Good day, dear.  In this article, we will look at the most popular data serialization formats and conduct a little testing with them.  This is the first article on the topic of data serialization and we will look at simple serializers, which do not require large changes in the code from the developer to integrate them. <br><br>  Sooner or later, but you, like our company, can face a situation where the number of services used in your product increases dramatically, and all of them also turn out to be very ‚Äútalkative‚Äù.  Whether this happened because of the transition to the ‚ÄúHYIP‚Äù microservice architecture today or you just received a pack of orders for minor improvements and implemented them by a handful of services - it does not matter.  The important thing is that from now on, your product has got two new problems - what to do with the increased amount of data being driven between individual services, and how to prevent chaos in developing and supporting such a number of services.  I‚Äôll explain a little about the second problem: when the number of your services grows to hundreds or more, one development team can no longer develop and maintain them, therefore, you distribute packs of services to different teams.  And the main thing is that all these teams use one format for their RPC, otherwise you will encounter such classic problems when one team cannot support the services of the other or just the two services do not fit together without abundant sealing of the junction with crutches.  But we will talk about this in a separate article, and today we will pay attention to the first problem of increased data and think about what we can do about it.  And we don‚Äôt want to do anything because of our Orthodox laziness, but we want to add a couple of lines to the common code and get a profit immediately.  With this we begin in this article, namely, consider serializers, the embedding of which does not require major changes in our beautiful RPC. <br><a name="habracut"></a><br>  The issue of format is actually rather painful for our company, because our current products use the xml format to exchange information between components.  No, we are not masochists, we are well aware that using xml for data exchange was about 10 years ago, but this is precisely the reason - the product is already 10 years old, and it contains a lot of legacy-architectural solutions that are rather difficult to ‚Äúcut out‚Äù quickly. .  After a bit of thinking and stating, we decided that we would use JSON for storing and transmitting data, but we need to choose one of the JSON packing options, since the size of the transmitted data is critical for us (I will explain below why). <br><br>  We have added a list of criteria by which we will choose the format that suits us: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Efficiency of data compression.  Our product will handle a huge amount of events to enter from various sources.  Each event is caused by some user actions.  Basically, the events are small and contain meta information about what is happening - sent a letter, chatted something on Facebook, etc.  - but may also contain data, and not a little size.  In addition, the number of such events is very large, a few dozen TB can easily be transmitted per day, therefore saving the size of events is critically important for us. <br><br></li><li>  Ability to work from different languages.  Since our new project was written using C ++, PHP and JS, we were only interested in the support of these languages, but taking into account the fact that the microservice architecture allows the development environment to be heterogeneous, support for additional languages ‚Äã‚Äãwill be useful.  Let's say that the go language is quite interesting for us, and it is possible that some services will be implemented on it. <br><br></li><li>  Support for versioning / evolving data structures.  Since our products live for quite a long time without updating clients (the update process is not at all simple), then at some point there will be too many different versions of support, and it‚Äôs important that we can easily develop the storage format without losing compatibility with already packed data. <br><br></li><li>  Ease of use.  We have experience using the Thrift protocol to build communication between components.  Honestly, it's not always easy for developers to figure out how RPC works and how to add something to already existing code without breaking anything in the old one.  Therefore, the easier it will be to use the serialization format, the better, since the C ++ level of the developer and the JS developer in such things are completely different :) <br><br></li><li>  The ability to randomly read data (Random-access reads / writes).  Since we mean using the chosen format and for storing data, it would be great if it supported the possibility of partial de-serialization of data so as not to read the entire object every time, which is often not so small.  In addition to reading data, a big plus would be the possibility of changing data without reading all the content. <br></li></ul><br>  After analyzing a decent number of options, we selected for ourselves such candidates: <br><br><ol><li>  Json </li><li>  BSON </li><li>  Message pack </li><li>  Corbor </li></ol><br>  These formats do not require a description of the IDL scheme of the data being transferred, but contain a data scheme inside it.  This greatly simplifies the work and allows in most cases to add support by writing no more than 10 lines of code. <br><br>  We are also well aware that some factors of a protocol or a serializer are highly dependent on its implementation.  What perfectly packs in C ++ can pack badly in Javascript.  Therefore, for our experiments, we will use implementations for JS and Go and will drive tests.  JS implementation for fidelity will drive in the browser and on nodejs. <br><br>  So, we will start consideration. <br><br><h3>  Json </h3><br>  The easiest of the interaction formats we are considering.  When comparing other formats, we will use it as a reference, as in our current projects it has shown its effectiveness and has shown all its minuses. <br><br>  Pros: <br><br><ul><li>  It supports almost all the data types we need.  It would be possible to find fault with the lack of support for binary data, but base64 can be dispensed with. </li><li>  Easy to read by human, which makes debugging easy </li><li>  Supported by a bunch of languages ‚Äã‚Äã(although those who used JSON in Go will understand that I'm cunning here) </li><li>  You can implement versioning via JSON Scheme </li></ul><br>  Minuses: <br><br><ul><li>  Despite the compactness of JSON as compared to xml, in our project, where gigabytes of data are transmitted per day, it is still quite wasteful for channels and for storing data in it.  The only advantage of native JSON is seen only in the use of PostgreSQL storage (with its jsob capabilities). </li><li>  No support for partial data deserialization.  To get something from the middle of the JSON file, you have to first deserialize everything that goes before the required field.  It also does not allow the format to be used for stream processing, which can be useful for network interaction. </li></ul><br>  Let's see what we have with performance.  When considering, we will immediately try to take into account the lack of JSON in its size and make tests with JSON packing using zlib.  For the tests we will use the following libraries: <br><br><ul><li>  <a href="http://nodeca.github.io/pako/">http://nodeca.github.io/pako/</a> - for packaging JSON in JS </li><li>  <a href="http://github.com/klauspost/compress">http://github.com/klauspost/compress</a> - for packaging JSON in Go </li><li>  <a href="http://github.com/pquerna/ffjson">http://github.com/pquerna/ffjson</a> - as a JSON serializer in Go </li></ul><br>  You can find the source code and all test results at the following links: <br><br>  Go - <a href="https://github.com/KyKyPy3/serialization-tests">https://github.com/KyKyPy3/serialization-tests</a> <br>  JS (node) - <a href="https://github.com/KyKyPy3/js-serialization-tests">https://github.com/KyKyPy3/js-serialization-tests</a> <br>  JS (browser) - <a href="http://jsperv.com/serialization-benchmarks/5">http://jsperv.com/serialization-benchmarks/5</a> <br><br>  Experimentally, we found that test data should be taken as close to real as possible, because test results with different test data differ dramatically.  So if it is important for you not to miss the format, always test it on the data closest to your realities.  We will be testing on data close to our realities.  You can look at them in the source code of tests. <br><br>  This is what we got for JSON speed.  Below are the benchmark results for the respective languages: <br><table><tbody><tr><th colspan="2">  JS (Node) </th></tr><tr><td>  Json encode </td><td>  21,507 ops / sec (86 runs sampled) </td></tr><tr><td>  Json decode </td><td>  9.039 ops / sec (89 runs sampled) </td></tr><tr><td>  Json roundtrip </td><td>  6.090 ops / sec (93 runs sampled) </td></tr><tr><td>  Json compres encode </td><td>  1,168 ops / sec (84 runs sampled) </td></tr><tr><td>  Json compres decode </td><td>  2,980 ops / sec (93 runs sampled) </td></tr><tr><td>  Json compres roundtrip </td><td>  874 ops / sec (86 runs sampled) </td></tr></tbody></table><br><table><tbody><tr><th colspan="2">  JS (browser) </th></tr><tr><td>  Json roundtrip </td><td>  5.754 ops / sec </td></tr><tr><td>  Json compres roundtrip </td><td>  890 ops / sec </td></tr></tbody></table><br><table><tbody><tr><th colspan="6">  Go </th></tr><tr><td>  Json encode </td><td>  5000 </td><td>  391100 ns / op </td><td>  24.37 MB / s </td><td>  54520 B / op </td><td>  1478 allocs / op </td></tr><tr><td>  Json decode </td><td>  3000 </td><td>  392785 ns / op </td><td>  24.27 MB / s </td><td>  76634 B / op </td><td>  1430 allocs / op </td></tr><tr><td>  Json roundtrip </td><td>  2000 </td><td>  796115 ns / op </td><td>  11.97 MB / s </td><td>  131150 b / op </td><td>  2908 allocs / op </td></tr><tr><td>  Json compres encode </td><td>  3000 </td><td>  422254 ns / op </td><td>  0.00 MB / s </td><td>  54790 B / op </td><td>  1478 allocs / op </td></tr><tr><td>  Json compres decode </td><td>  3000 </td><td>  464569 ns / op </td><td>  4.50 MB / s </td><td>  117206 b / op </td><td>  1446 allocs / op </td></tr><tr><td>  Json compres roundtrip </td><td>  2000 </td><td>  881305 ns / op </td><td>  0.00 MB / s </td><td>  171795 b / op </td><td>  2915 allocs / op </td></tr></tbody></table><br>  But what got the size of the data: <br><table><tbody><tr><th colspan="2">  JS (Node) </th></tr><tr><td>  Json </td><td>  9482 bytes </td></tr><tr><td>  Json compressed </td><td>  1872 bytes </td></tr></tbody></table><br><table><tbody><tr><th colspan="2">  JS (Browser) </th></tr><tr><td>  Json </td><td>  9482 bytes </td></tr><tr><td>  Json compressed </td><td>  1872 bytes </td></tr></tbody></table><br>  At this stage, we can conclude that even though JSON compression gives excellent results, the loss in processing speed is simply catastrophic.  Another conclusion: JS works great with JSON, which cannot be said, for example, about go.  It is possible that processing JSON in other languages ‚Äã‚Äãwill show results incomparable with JS.  While we postpone the JSON results aside and see how it will be with other formats. <br><br><h3>  BSON </h3><br>  This data format came from MongoDb and is actively promoted by them.  The format was originally designed for data storage and was not intended for transmission over the network.  Honestly, after a brief search on the Internet, we did not find a single serious product that uses BSON inside.  But let's see what this format can give us. <br><br>  Pros: <br><br><ul><li>  <b>Support for additional data types.</b> <br>  According to the BSON format specification, in addition to the standard data types of the JSON format, BSON also supports such types as Date, <a href="https://docs.mongodb.org/manual/reference/object-id/">ObjectId</a> , Null and binary data (Binary data).  Some of them (for example, ObjectId) are more commonly used in MongoDb and may not always be useful to others.  But some additional data types give us the following bonuses.  If we store a date in our object, then in the case of JSON format we have only one storage option - this is one of the ISO-8601 variants, and in string representation.  At the same time, if we want to filter our collection of JSON-objects by dates, during processing we will need to turn the strings into the Date format and only after that compare them.  BSON also stores all dates as Int64 (as well as the Date type) and takes over all the work of serializing / deserializing to the Date format.  Therefore, we can compare dates without deserialization - just like numbers, which is clearly faster than the classic JSON version.  This advantage is actively used in MongoDb. <br><br></li><li>  <b>BSON supports the so-called Random read / write to its data.</b> <br>  BSON stores lengths for strings and binary data, allowing you to skip attributes that are not interesting to us.  JSON, on the other hand, sequentially reads data and cannot send an element without reading its value to the end.  Thus, if we store large amounts of binary data inside the format, this feature can play an important role for us. </li></ul><br>  Minuses: <br><br><ul><li>  <b>The size of the data.</b> <br>  As for the size of the final file, then everything is ambiguous.  In some situations, the size of the object will be smaller, and in some - more, it all depends on what lies inside the Bson object.  Why it happens this way - we will be answered by a specification that says that for the speed of access to the elements of an object, the format saves additional information, such as the size of the data for large elements. <br></li></ul><br>  So for example JSON object <br><br><pre><code class="hljs objectivec">{¬´hello<span class="hljs-string"><span class="hljs-string">": "</span></span>world¬ª}</code> </pre> <br>  will turn into this: <br><br><pre> <code class="hljs tex"><span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>16<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00 // total document size <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>02 // 0x02 = type String hello<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00 // field name <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>06<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00world<span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00 // field value <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">x</span></span></span></span>00 // 0x00 = type EOO ('end of object')</code> </pre><br>  The specification says that BSON was designed as a format with fast serialization / deserialization, at least due to the fact that it stores numbers as an Int type, and does not waste time parsing them from a string.  Let's check.  For testing we took the following libraries: <br><br><ul><li>  JS (node ‚Äã‚Äãand browser) - <a href="https://github.com/mongodb/js-bson">https://github.com/mongodb/js-bson</a> </li><li>  Go - <a href="https://github.com/go-mgo/mgo/tree/v2">https://github.com/go-mgo/mgo/tree/v2</a> </li></ul><br>  And here are the results we obtained (for clarity, I also added results for JSON): <br><table><tbody><tr><th colspan="2">  JS (Node) </th></tr><tr><td>  Json encode </td><td>  21,507 ops / sec (86 runs sampled) </td></tr><tr><td>  Json decode </td><td>  9.039 ops / sec (89 runs sampled) </td></tr><tr><td>  Json roundtrip </td><td>  6.090 ops / sec (93 runs sampled) </td></tr><tr><td>  Json compres encode </td><td>  1,168 ops / sec (84 runs sampled) </td></tr><tr><td>  Json compres decode </td><td>  2,980 ops / sec (93 runs sampled) </td></tr><tr><td>  Json compres roundtrip </td><td>  874 ops / sec (86 runs sampled) </td></tr><tr><td>  Bson encode </td><td>  93.21 ops / sec (76 runs sampled) </td></tr><tr><td>  Bson decode </td><td>  242 ops / sec (84 runs sampled) </td></tr><tr><td>  Bson roundtrip </td><td>  65.24 ops / sec (65 runs sampled) </td></tr></tbody></table><br><table><tbody><tr><th colspan="2">  JS (browser) </th></tr><tr><td>  Json roundtrip </td><td>  5.754 ops / sec </td></tr><tr><td>  Json compres roundtrip </td><td>  890 ops / sec </td></tr><tr><td>  Bson roundtrip </td><td>  374 ops / sec </td></tr></tbody></table><br><table><tbody><tr><th colspan="6">  Go </th></tr><tr><td>  Json encode </td><td>  5000 </td><td>  391100 ns / op </td><td>  24.37 MB / s </td><td>  54520 B / op </td><td>  1478 allocs / op </td></tr><tr><td>  Json decode </td><td>  3000 </td><td>  392785 ns / op </td><td>  24.27 MB / s </td><td>  76634 B / op </td><td>  1430 allocs / op </td></tr><tr><td>  Json roundtrip </td><td>  2000 </td><td>  796115 ns / op </td><td>  11.97 MB / s </td><td>  131150 b / op </td><td>  2908 allocs / op </td></tr><tr><td>  Json compres encode </td><td>  3000 </td><td>  422254 ns / op </td><td>  0.00 MB / s </td><td>  54790 B / op </td><td>  1478 allocs / op </td></tr><tr><td>  Json compres decode </td><td>  3000 </td><td>  464569 ns / op </td><td>  4.50 MB / s </td><td>  117206 b / op </td><td>  1446 allocs / op </td></tr><tr><td>  Json compres roundtrip </td><td>  2000 </td><td>  881305 ns / op </td><td>  0.00 MB / s </td><td>  171795 b / op </td><td>  2915 allocs / op </td></tr><tr><td>  Bson encode </td><td>  10,000 </td><td>  249024 ns / op </td><td>  40.42 MB / s </td><td>  70085 B / op </td><td>  982 allocs / op </td></tr><tr><td>  Bson decode </td><td>  3000 </td><td>  524408 ns / op </td><td>  19.19 MB / s </td><td>  124777 b / op </td><td>  3580 allocs / op </td></tr><tr><td>  Bson roundtrip </td><td>  2000 </td><td>  712524 ns / op </td><td>  14.13 MB / s </td><td>  195334 b / op </td><td>  4562 allocs / op </td></tr></tbody></table><br>  But what got the size of the data: <br><table><tbody><tr><th colspan="2">  JS (Node) </th></tr><tr><td>  Json </td><td>  9482 bytes </td></tr><tr><td>  Json compressed </td><td>  1872 bytes </td></tr><tr><td>  Bson </td><td>  112710 bytes </td></tr></tbody></table><br><table><tbody><tr><th colspan="2">  JS (Browser) </th></tr><tr><td>  Json </td><td>  9482 bytes </td></tr><tr><td>  Json compressed </td><td>  1872 bytes </td></tr><tr><td>  Bson </td><td>  9618 bytes </td></tr></tbody></table><br>  Although BSON gives us the possibility of additional data types and, most importantly, the possibility of partial reading / changing data, in terms of data compression, it is all very sad, so we have to continue searching further. <br><br><h3>  Message pack </h3><br>  The next format that came to our table is the Message Pack.  This format is quite popular lately and I personally found out about it when picking with tarantool. <br><br>  If you look at the site format, you can: <br><br><ul><li>  Learn that the format is actively used by such products as redis and fluentd, which inspires confidence in it. </li><li>  See the loud inscription It's like JSON.  but fast and small </li></ul><br>  We'll have to check how true this is, but first let's see what the format offers. <br><br>  By tradition, let's start with the pros: <br><br><ul><li>  The format is fully compatible with JSON <br>  When converting data from MessagePack to JSON, we will not lose data, which cannot be said, for example, about BSON format.  True, there are a number of restrictions imposed on various types of data: <br><br><ol><li>  The value of the type Integer is limited from - (263) to (264) ‚Äì1; </li><li>  The maximum length of a binary object (232) ‚Äì1; </li><li>  The maximum size of the byte string (232) ‚Äì1; </li><li>  The maximum number of elements in the array is no more (232) ‚Äì1; </li><li>  The maximum number of elements in an associative array is not more than (232) ‚Äì1; </li></ol><br></li><li>  Pretty good compresses the data. <br>  For example, {‚Äúa‚Äù: 1, ‚Äúb‚Äù: 2} takes 13 bytes in JSON, 19 bytes in BSON and only 7 bytes in MessagePack, which is pretty good. <br></li><li>  It is possible to expand the supported data types. <br>  MsgPack allows you to extend its type system with your own.  Since the type in MsgPack is coded with a number, and values ‚Äã‚Äãfrom ‚Äì1 to ‚Äì128 are reserved by the format (this is stated in the format specification), values ‚Äã‚Äãfrom 0 to 127 are available for use. Therefore, we can add extensions that point to our own types data. <br></li><li>  It has the support of a huge number of languages. </li><li>  There is an RPC package (but this is not so important for us). </li><li>  You can use the streaming API. </li></ul><br>  Minuses: <br><br><ul><li>  Does not support partial data modification. <br>  Unlike the BSON format, even if MsgPack stores the size of each field, you cannot partially change the data in it.  Suppose we have a serialized JSON representation {"a": 1, "b": 2}.  Bson uses to store the value of the key 'a' 5 bytes, which will allow us to change the value from 1 to 2000 (takes 3 bytes) without problems.  But the MessagePack for storage uses 1 byte, and since 2000 occupies 3 bytes, without shifting the data on the 'b' parameter we cannot change the value of the 'a' parameter. <br></li></ul><br>  Now let's see how productive it is and how it compresses the data.  The following libraries were used for tests: <br><br><ul><li>  JS - <a href="https://github.com/kawanet/msgpack-lite">https://github.com/kawanet/msgpack-lite</a> </li><li>  Go - <a href="https://github.com/vmihailenco/msgpack">https://github.com/vmihailenco/msgpack</a> </li></ul><br>  We got the following results: <br><table><tbody><tr><th colspan="2">  JS (Node) </th></tr><tr><td>  Json encode </td><td>  21,507 ops / sec (86 runs sampled) </td></tr><tr><td>  Json decode </td><td>  9.039 ops / sec (89 runs sampled) </td></tr><tr><td>  Json roundtrip </td><td>  6.090 ops / sec (93 runs sampled) </td></tr><tr><td>  Json compres encode </td><td>  1,168 ops / sec (84 runs sampled) </td></tr><tr><td>  Json compres decode </td><td>  2,980 ops / sec (93 runs sampled) </td></tr><tr><td>  Json compres roundtrip </td><td>  874 ops / sec (86 runs sampled) </td></tr><tr><td>  Bson encode </td><td>  93.21 ops / sec (76 runs sampled) </td></tr><tr><td>  Bson decode </td><td>  242 ops / sec (84 runs sampled) </td></tr><tr><td>  Bson roundtrip </td><td>  65.24 ops / sec (65 runs sampled) </td></tr><tr><td>  MsgPack encode </td><td>  4,758 ops / sec (79 runs sampled) </td></tr><tr><td>  MsgPack decode </td><td>  2,632 ops / sec (91 runs sampled) </td></tr><tr><td>  MsgPack roundtrip </td><td>  1.692 ops / sec (91 runs sampled) </td></tr></tbody></table><br><table><tbody><tr><th colspan="2">  JS (browser) </th></tr><tr><td>  Json roundtrip </td><td>  5.754 ops / sec </td></tr><tr><td>  Json compres roundtrip </td><td>  890 ops / sec </td></tr><tr><td>  Bson roundtrip </td><td>  374 ops / sec </td></tr><tr><td>  MsgPack roundtrip </td><td>  1,048 ops / sec </td></tr></tbody></table><br><table><tbody><tr><th colspan="6">  Go </th></tr><tr><td>  Json encode </td><td>  5000 </td><td>  391100 ns / op </td><td>  24.37 MB / s </td><td>  54520 B / op </td><td>  1478 allocs / op </td></tr><tr><td>  Json decode </td><td>  3000 </td><td>  392785 ns / op </td><td>  24.27 MB / s </td><td>  76634 B / op </td><td>  1430 allocs / op </td></tr><tr><td>  Json roundtrip </td><td>  2000 </td><td>  796115 ns / op </td><td>  11.97 MB / s </td><td>  131150 b / op </td><td>  2908 allocs / op </td></tr><tr><td>  Json compres encode </td><td>  3000 </td><td>  422254 ns / op </td><td>  0.00 MB / s </td><td>  54790 B / op </td><td>  1478 allocs / op </td></tr><tr><td>  Json compres decode </td><td>  3000 </td><td>  464569 ns / op </td><td>  4.50 MB / s </td><td>  117206 b / op </td><td>  1446 allocs / op </td></tr><tr><td>  Json compres roundtrip </td><td>  2000 </td><td>  881305 ns / op </td><td>  0.00 MB / s </td><td>  171795 b / op </td><td>  2915 allocs / op </td></tr><tr><td>  Bson encode </td><td>  10,000 </td><td>  249024 ns / op </td><td>  40.42 MB / s </td><td>  70085 B / op </td><td>  982 allocs / op </td></tr><tr><td>  Bson decode </td><td>  3000 </td><td>  524408 ns / op </td><td>  19.19 MB / s </td><td>  124777 b / op </td><td>  3580 allocs / op </td></tr><tr><td>  Bson roundtrip </td><td>  2000 </td><td>  712524 ns / op </td><td>  14.13 MB / s </td><td>  195334 b / op </td><td>  4562 allocs / op </td></tr><tr><td>  MsgPack Encode </td><td>  5000 </td><td>  306260 ns / op </td><td>  27.36 MB / s </td><td>  49907 b / op </td><td>  968 allocs / op </td></tr><tr><td>  MsgPack Decode </td><td>  10,000 </td><td>  214967 ns / op </td><td>  38.98 MB / s </td><td>  59649 b / op </td><td>  1690 allocs / op </td></tr><tr><td>  MsgPack Roundtrip </td><td>  3000 </td><td>  547434 ns / op </td><td>  15.31 MB / s </td><td>  109754 b / op </td><td>  2658 allocs / op </td></tr></tbody></table><br>  But what got the size of the data: <br><table><tbody><tr><th colspan="2">  JS (Node) </th></tr><tr><td>  Json </td><td>  9482 bytes </td></tr><tr><td>  Json compressed </td><td>  1872 bytes </td></tr><tr><td>  Bson </td><td>  112710 bytes </td></tr><tr><td>  Msgpack </td><td>  7628 bytes </td></tr></tbody></table><br><table><tbody><tr><th colspan="2">  JS (Browser) </th></tr><tr><td>  Json </td><td>  9482 bytes </td></tr><tr><td>  Json compressed </td><td>  1872 bytes </td></tr><tr><td>  Bson </td><td>  9618 bytes </td></tr><tr><td>  Msgpack </td><td>  7628 bytes </td></tr></tbody></table><br>  Of course, MessagePack doesn‚Äôt compress data as coolly as we would like, but at least it behaves fairly consistently in both JS and Go.  Perhaps, at the moment it is the most attractive candidate for our tasks, but it remains to consider our last patient. <br><br><h3>  Corbor </h3><br>  To be honest, the format is very similar to MessagePack in its capabilities, and it seems that the format was designed as a replacement for MessagePack.  It also has support for data type extensions and full compatibility with JSON.  Of the differences, I noticed only support for arrays / lines of arbitrary length, but, in my opinion, this is a very strange feature.  If you want to know more about this format, then it was a great article on Habr√© - <a href="https://habrahabr.ru/post/208690/">habrahabr.ru/post/208690</a> .  Well, we'll see how Cbor works with performance and data compression. <br><br>  The following libraries were used for tests: <br><br><ul><li>  Js - <a href="https://github.com/paroga/cbor-js">https://github.com/paroga/cbor-js</a> </li><li>  Go - <a href="https://github.com/ugorji/go">https://github.com/ugorji/go</a> </li></ul><br>  And, of course, here are the final results of our tests, taking into account all the formats considered: <br><table><tbody><tr><th colspan="2">  JS (Node) </th></tr><tr><td>  Json encode </td><td>  21,507 ops / sec ¬± 1.01% (86 runs sampled) </td></tr><tr><td>  Json decode </td><td>  9.039 ops / sec ¬± 0.90% (89 runs sampled) </td></tr><tr><td>  Json roundtrip </td><td>  6.090 ops / sec ¬± 0.62% (93 runs sampled) </td></tr><tr><td>  Json compres encode </td><td>  1,168 ops / sec ¬± 1.20% (84 runs sampled) </td></tr><tr><td>  Json compres decode </td><td>  2,980 ops / sec ¬± 0.43% (93 runs sampled) </td></tr><tr><td>  Json compres roundtrip </td><td>  874 ops / sec ¬± 0.91% (86 runs sampled) </td></tr><tr><td>  Bson encode </td><td>  93.21 ops / sec ¬± 0.64% (76 runs sampled) </td></tr><tr><td>  Bson decode </td><td>  242 ops / sec ¬± 0.63% (84 runs sampled) </td></tr><tr><td>  Bson roundtrip </td><td>  65.24 ops / sec ¬± 1.27% (65 runs sampled) </td></tr><tr><td>  MsgPack encode </td><td>  4,758 ops / sec ¬± 1.13% (79 runs sampled) </td></tr><tr><td>  MsgPack decode </td><td>  2.632 ops / sec ¬± 0.90% (91 runs sampled) </td></tr><tr><td>  MsgPack roundtrip </td><td>  1.692 ops / sec ¬± 0.83% (91 runs sampled) </td></tr><tr><td>  Cbor encode </td><td>  1,529 ops / sec ¬± 4.13% (89 runs sampled) </td></tr><tr><td>  Cbor decode </td><td>  1,198 ops / sec ¬± 0.97% (88 runs sampled) </td></tr><tr><td>  Cbor roundtrip </td><td>  351 ops / sec ¬± 3.28% (77 runs sampled) </td></tr></tbody></table><br><table><tbody><tr><th colspan="2">  JS (browser) </th></tr><tr><td>  Json roundtrip </td><td>  5.754 ops / sec ¬± 0.63% </td></tr><tr><td>  Json compres roundtrip </td><td>  890 ops / sec ¬± 1.72% </td></tr><tr><td>  Bson roundtrip </td><td>  374 ops / sec ¬± 2.22% </td></tr><tr><td>  MsgPack roundtrip </td><td>  1,048 ops / sec ¬± 5.40% </td></tr><tr><td>  Cbor roundtrip </td><td>  859 ops / sec ¬± 4.19% </td></tr></tbody></table><br><table><tbody><tr><th colspan="6">  Go </th></tr><tr><td>  Json encode </td><td>  5000 </td><td>  391100 ns / op </td><td>  24.37 MB / s </td><td>  54520 B / op </td><td>  1478 allocs / op </td></tr><tr><td>  Json decode </td><td>  3000 </td><td>  392785 ns / op </td><td>  24.27 MB / s </td><td>  76634 B / op </td><td>  1430 allocs / op </td></tr><tr><td>  Json roundtrip </td><td>  2000 </td><td>  796115 ns / op </td><td>  11.97 MB / s </td><td>  131150 b / op </td><td>  2908 allocs / op </td></tr><tr><td>  Json compres encode </td><td>  3000 </td><td>  422254 ns / op </td><td>  0.00 MB / s </td><td>  54790 B / op </td><td>  1478 allocs / op </td></tr><tr><td>  Json compres decode </td><td>  3000 </td><td>  464569 ns / op </td><td>  4.50 MB / s </td><td>  117206 b / op </td><td>  1446 allocs / op </td></tr><tr><td>  Json compres roundtrip </td><td>  2000 </td><td>  881305 ns / op </td><td>  0.00 MB / s </td><td>  171795 b / op </td><td>  2915 allocs / op </td></tr><tr><td>  Bson encode </td><td>  10,000 </td><td>  249024 ns / op </td><td>  40.42 MB / s </td><td>  70085 B / op </td><td>  982 allocs / op </td></tr><tr><td>  Bson decode </td><td>  3000 </td><td>  524408 ns / op </td><td>  19.19 MB / s </td><td>  124777 b / op </td><td>  3580 allocs / op </td></tr><tr><td>  Bson roundtrip </td><td>  2000 </td><td>  712524 ns / op </td><td>  14.13 MB / s </td><td>  195334 b / op </td><td>  4562 allocs / op </td></tr><tr><td>  MsgPack Encode </td><td>  5000 </td><td>  306260 ns / op </td><td>  27.36 MB / s </td><td>  49907 b / op </td><td>  968 allocs / op </td></tr><tr><td>  MsgPack Decode </td><td>  10,000 </td><td>  214967 ns / op </td><td>  38.98 MB / s </td><td>  59649 b / op </td><td>  1690 allocs / op </td></tr><tr><td>  MsgPack Roundtrip </td><td>  3000 </td><td>  547434 ns / op </td><td>  15.31 MB / s </td><td>  109754 b / op </td><td>  2658 allocs / op </td></tr><tr><td>  Cbor Encode </td><td>  20,000 </td><td>  71203 ns / op </td><td>  117.48 MB / s </td><td>  32944 B / op </td><td>  12 allocs / op </td></tr><tr><td>  Corbor decode </td><td>  3000 </td><td>  432005 ns / op </td><td>  19.36 MB / s </td><td>  40216 b / op </td><td>  2159 allocs / op </td></tr><tr><td>  Cbor roundtrip </td><td>  3000 </td><td>  531434 ns / op </td><td>  15.74 MB / s </td><td>  73160 B / op </td><td>  2171 allocs / op </td></tr></tbody></table><br>  But what got the size of the data: <br><table><tbody><tr><th colspan="2">  JS (Node) </th></tr><tr><td>  Json </td><td>  9482 bytes </td></tr><tr><td>  Json compressed </td><td>  1872 bytes </td></tr><tr><td>  Bson </td><td>  112710 bytes </td></tr><tr><td>  Msgpack </td><td>  7628 bytes </td></tr><tr><td>  Corbor </td><td>  7617 bytes </td></tr></tbody></table><br><br><table><tbody><tr><th colspan="2">  JS (Browser) </th></tr><tr><td>  Json </td><td>  9482 bytes </td></tr><tr><td>  Json compressed </td><td>  1872 bytes </td></tr><tr><td>  Bson </td><td>  9618 bytes </td></tr><tr><td>  Msgpack </td><td>  7628 bytes </td></tr><tr><td>  Corbor </td><td>  7617 bytes </td></tr></tbody></table><br>  Comments, I think, are unnecessary here, everything is perfectly visible from the results - CBor was the slowest format. <br><br><h3>  findings </h3><br>  What conclusions did we draw from this comparison?  After a little thought and looking at the results, we came to the conclusion that none of the formats satisfied us.  Yes, MsgPack proved to be quite a good option: it is easy to use and quite stable, but after consulting with colleagues, we decided to take a fresh look at other binary data formats, not based on JSON: Protobuf, FlatBuffers, Cap'n proto and avro.  That we succeeded and what we ultimately chose will be discussed in the next article. <br><br>  Posted by:   <a href="https://habrahabr.ru/users/kykypy3uk/" class="user_link">KyKyPy3uK</a> </div><p>Source: <a href="https://habr.com/ru/post/312320/">https://habr.com/ru/post/312320/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312310/index.html">How we built our mini data center. Part 1 - Colocation</a></li>
<li><a href="../312312/index.html">As we did automate the translation to 29 locales: build the zoo into a coherent system</a></li>
<li><a href="../312314/index.html">The preliminary program of the MBLTdev 16 mobile developers conference has been published.</a></li>
<li><a href="../312316/index.html">Several versions of PHP on a Windows machine</a></li>
<li><a href="../312318/index.html">Create a game for WebGL using Unity 5 and JavaScript</a></li>
<li><a href="../312322/index.html">Development of modules for Magento 1.x - big guide + video</a></li>
<li><a href="../312324/index.html">What do we hate in job interviews?</a></li>
<li><a href="../312326/index.html">Remote work 2.0. Nadezhda Yurinova, Bookmate Marketing Director</a></li>
<li><a href="../312328/index.html">NooLite + Raspberry Pi + Telegram = smart home</a></li>
<li><a href="../312330/index.html">Network Monitoring with Apple TV</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>