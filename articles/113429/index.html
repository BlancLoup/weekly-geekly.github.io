<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++, C-style coercion and unexpected consequences of their combination</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="C ++ inherited from C a type cast (type) (what to bring) - usually called a C-style cast. There are four more explicit castings in C ++ - static_cast,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++, C-style coercion and unexpected consequences of their combination</h1><div class="post__text post__text-html js-mediator-article">  C ++ inherited from C a type cast (type) (what to bring) - usually called a C-style cast. There are four more explicit castings in C ++ - static_cast, reinterpret_cast, dynamic_cast, const_cast. <br><br>  C ++ is not the newest language, and the heated debate about what is best - the C-style cast or the use of * _cast in the right combination, started a long time ago and continues to this day.  We will not add fuel to the fire, we better consider an example, and let everyone decide what he likes more. <a name="habracut"></a><br><br>  Windows-specific and COM-specific constructs will be mentioned here, but the same problems can arise in any sufficiently complex class hierarchies, if you do not pay enough attention to type casting. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      An example based on a real code from a real open source project.  In a certain project subsystem, a class that implements several COM interfaces is declared: <br><br><blockquote><pre> <code class="hljs kotlin"><code class="cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CInterfacesImplementor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public IComInterface1</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public IComInterface2</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">public IComInterface3</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">...</span></span></span></span>(   <span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-number"><span class="hljs-number">9</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IComInterface10 { <span class="hljs-comment"><span class="hljs-comment">//    };</span></span></code></code> </pre></blockquote><br><br>  Of course, in real life, interfaces have more meaningful names, but when they are closer to the top ten, this does not help much from the problem that is discussed further. <br><br>  Recall that each COM interface is directly or indirectly inherited from IUnknown, and IUnknown contains the QueryInterface () method, the correct implementation of which is so difficult that Raymond Chen wrote about this series ( <a href="http://blogs.msdn.com/b/oldnewthing/archive/2004/03/26/96777.aspx">here</a> , <a href="http://blogs.msdn.com/b/oldnewthing/archive/2009/09/25/9899238.aspx">here</a> and <a href="http://blogs.msdn.com/b/oldnewthing/archive/2009/10/07/9904040.aspx">here</a> ). <br><br>  Our example is just the implementation of QueryInterface () in the class above.  Brief background: when a developer announces a new COM interface, he is obliged to assign him a unique identifier.  The caller calls QueryInterface () to find out if an object implements an interface with that identifier and, if it does, obtain a pointer of the appropriate type.  The __uuidof () construct asks Visual C ++ to compile and locate the interface identifier specified in brackets during compilation. <br><br>  So‚Ä¶ <br><blockquote><pre> <code class="cpp hljs">HRESULT STDMETHODCALLTYPE CInterfaceImplementor::QueryInterface( REFIID iid, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>** ppv ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ppv == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> E_POINTER; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iid == __uuidof( IUnknown ) || iid == __uuidof( IComInterface1 ) ) { *ppv = (IComInterface1*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iid == __uuidof( IComInterface2 ) ) { *ppv = (IComInterface2*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iid == __uuidof( IComInterface3 ) ) { *ppv = (IComInterface3*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>... ... <span class="hljs-comment"><span class="hljs-comment">//       COM- } else { //   COM-     *ppv = 0; return E_NOINTERFACE; } AddRef(); return S_OK; }</span></span></code> </pre></blockquote><br><br>  The implementation above works and is almost perfect.  She checks the pointer before dereferencing.  She checks if the known interface has been requested from her.  It writes a null pointer before returning the E_NOINTERFACE code.  It increases the reference count if the interface is supported.  She even responds to the request of IUnknown.  Raymond Chen would be pleased if it were not for one question. <br><br>  Why is there a ghost?  Why not write "* ppv = this;"? <br><br>  In case of multiple inheritance, the object will be ‚Äúcomplicated‚Äù from the subobjects of the base classes so that you can access each subobject separately.  Let's say that some function can work only with IComInterface2 * - you need to pass it a pointer to this sub-object, and not to the derived object, about which it may quite possibly know nothing. <br><br>  Assigning "* ppv = this;" would cause the address of the beginning of the derived object, and not the subobjects of which it consists, to be transmitted.  Attempting to call the virtual method of the interface through a pointer to another sub-object will obviously lead to a long debugging. <br><br>  The cast in the example above just provides an adjustment to the pointer.  It is necessary there for the caller to receive a pointer to the desired sub-object. <br><br>  Happinnes exists?  Before this paragraph - exactly.  Now it takes 100,500 days, the project is developing, it adds new functionality.  In the next paragraph, we will see the consequences of unsuccessful use of copy-paste when trying to develop a project.  But let's do without objections that the ‚Äúright programmers‚Äù with the ‚Äúright programming‚Äù and the ‚Äúright architecture‚Äù do not do so. <br><br>  In another subsystem of the same open source project, there is another class that implements the same set of interfaces: <br><blockquote><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CYetOtherImplementor</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IComInterface1, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IComInterface3, ...(   <span class="hljs-number"><span class="hljs-number">4</span></span>  <span class="hljs-number"><span class="hljs-number">9</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IComInterface10 { <span class="hljs-comment"><span class="hljs-comment">//    };</span></span></code> </pre></blockquote><br>  and, of course, nobody wants to write that chain of conditions anew, especially since the implementation is obviously the same: <br><blockquote><pre> <code class="cpp hljs">HRESULT STDMETHODCALLTYPE CYetOtherImplementor::QueryInterface( REFIID iid, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>** ppv ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ppv == <span class="hljs-number"><span class="hljs-number">0</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> E_POINTER; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iid == __uuidof( IUnknown ) || iid == __uuidof( IComInterface1 ) ) { *ppv = (IComInterface1*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iid == __uuidof( IComInterface2 ) ) { *ppv = (IComInterface2*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iid == __uuidof( IComInterface3 ) ) { *ppv = (IComInterface3*)<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>... ... <span class="hljs-comment"><span class="hljs-comment">//       COM- } else { //   COM-     *ppv = 0; return E_NOINTERFACE; } // V2UncmUgaGlyaW5nIC0gd3d3LmFiYnl5LnJ1L3ZhY2FuY3k= AddRef(); return S_OK; }</span></span></code> </pre></blockquote><br>  Now let's mentally lose what will happen when the IComInterface2 interface is requested.  The control will follow the if-else-if chain until the identifier matches, and then the C-style cast will be executed. <br><br>  Paragraph 5.3.5 / 5 of the C ++ standard ISO / IEC 14882: 2003 (E) says that when casting in style C, it will be executed (in our case) either static_cast or, if static_cast is impossible, reinterpret_cast. <br><br>  In the first example, the class was inherited from IComInterface2 and the static_cast of this pointer was executed to a pointer to the required sub-object. <br><br>  In the second example, the class is no longer inherited from IComInterface2 (yes, copy-paste plus file completion), therefore static_cast is not possible.  The reinterpret_cast will be executed, the this pointer will be copied unchanged.  And by the way, the object does not implement IComInterface2 at all.  Here the word is appropriate. <br><br>  When calling IComInterface2 in the second example, the caller will receive a non-zero pointer to an object that this interface does not implement and in general does not apply to this interface. <br><br>  For comparison, if you use static_cast in each of the if-else-if branches, the compiler will give an error message and the second example will not compile, it gently hints to the developer that you need to work a little more.  Minus the debugging day, you can do something useful. <br><br>  Once we are here, another bad idea is to use dynamic_cast.  When using dynamic_cast in the second example, the caller will get a null pointer and a false code of successful execution of the method, and the object will be in vain caused by an increase in the reference count, as a result it may leak.  Plus a couple of hours of debugging, but a null pointer is at least easier to notice, however, there is no point in using dynamic_cast here. <br><br>  It can be assumed that the C-style leads make it possible to write code shorter, but they complicate the writing of the correct code and only delay the moment when you have to get used to the * _cast ghosts. <br><br>  The conclusions are obvious.  Use the C-style cast as often as possible - this will give other developers a competitive advantage, and you (who knows) yourself may even one day get the Darwin Award. <br><br>  <i>Dmitry Mescheryakov</i> <i><br></i>  <i>Department of Data Entry Products</i> </div><p>Source: <a href="https://habr.com/ru/post/113429/">https://habr.com/ru/post/113429/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../113421/index.html">Using the experience of testing a relational database for NoSQL technology</a></li>
<li><a href="../113423/index.html">Who is cheaper?</a></li>
<li><a href="../113425/index.html">iPad and news: a small overview of the best apps</a></li>
<li><a href="../113426/index.html">Release Flash Player 10.2</a></li>
<li><a href="../113427/index.html">RAID-4 / RAID-DP - turning disadvantages into advantages</a></li>
<li><a href="../113430/index.html">Ubiquity RouterStation Pro: a small overview and installation of Debian GNU / Linux</a></li>
<li><a href="../113431/index.html">DHCP over VLAN on Cisco switches</a></li>
<li><a href="../113433/index.html">A joint project of Toshiba and Royal Opera House. Watch the opera ‚ÄúCarmen‚Äù in 3D (update!)</a></li>
<li><a href="../113434/index.html">David O'Reilly</a></li>
<li><a href="../113435/index.html">The most popular phone number in the world: 214-748-3647</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>