<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Console of the 21st century: mosh, tmux, fish</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my work, I have to spend almost all my time in the console, both local and remote. No, that you, I'm not complaining, even on the contrary - I like...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Console of the 21st century: mosh, tmux, fish</h1><div class="post__text post__text-html js-mediator-article">  In my work, I have to spend almost all my time in the console, both local and remote.  No, that you, I'm not complaining, even on the contrary - I like the automation capabilities provided by console tools, and the work in the console is quite productive. <br><br>  But if you spend with your tool up to 80% of the working time, it is advisable to make sure that you do not waste time and that the work gives you pleasure.  In this article I would like to talk a little about the tools that I personally use every day, and how they improve the user experience (and, often, productivity) when working with the console and with remote servers in particular. <br><br><h3>  Ssh problems </h3><br>  When working with remote servers via ssh, there are many things that can be frustrating, but there are two main problems, and the first one is fundamentally insoluble in ssh: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  With high round-trip latency (&gt; 100 ms), user input appears with a noticeable delay, and when using the mobile Internet with an edge (latency 1000 ms), work becomes like torture </li><li>  With temporary problems (a few minutes) with the delivery of packages, the connection can break with write failed: broken pipe, and you will find out about it only when you try to enter or when using settings like keepaliveinterval </li></ol><br><br>  The first problem is insoluble because ssh by-design is simply a transport for bytes, and existing applications rely on this behavior.  Since ssh does not attempt to interpret this stream of bytes, it cannot predictive input.  For me personally, this problem is most relevant, since I have to work with servers in Europe and the USA, and in the second case, the delay is about 200 ms and is fundamentally unavoidable, at least until the invention of quantum communication or something like that.  The second problem manifests itself in our conditions relatively rarely, but it is still unpleasant to reinstall all the connections in case of network failures (and to restart the fallen applications, if they were not running for some reason in the screen). <br><br><a name="habracut"></a><br><br><h3>  Solution - mosh (MObile SHell) </h3><br>  The solution to the above problems is quite radical - mosh ( <a href="http://mosh.mit.edu/">mosh.mit.edu</a> ) is a separate client-server system that works via UDP and sends screen diffs instead of the approach used by SSH, which transmits bytes "as is".  The initial connection is via ssh, but ssh only starts the mosh-server and exits after that.  Because of this, connecting to the server using mosh takes a little longer than just using SSH. <br><br>  In order to work through mosh instead of ssh, you need to install the mosh-client on your computer and the mosh-server on the remote host.  In general, it is not necessary to install it system-wide - the daemon runs from under the user, and you can specify the server's binary when connecting (example: mosh - server / home / yuriy / bin / mosh-server my-server-hostname). <br><br>  Since mosh sends screen diffs by udp, it is very different in its properties from the usual ssh via tcp / ip: <br><br>  <b>Connection never breaks</b> <br>  There is no "connection".  When restoring network connectivity, you again begin to see the current state of the console.  You can also change the way you connect to the server, for example, change the wi-fi access point, and everything will continue to work.  This is especially useful when using VPN over the mobile Internet, which is a sample of instability. <br><br>  <b>Forget about the ability to scroll the history of the mouse wheel</b> <br>  Local scrolling will not work, as mosh draws everything in an alternate screen, and only shows the difference from the previous state, without sending the rest.  In order for the story to be saved at least somewhere, you need to use screen or tmux, which will be described later.  With a certain file, you can still get the mouse wheel to work, but the sensations will still be "wrong." <br><br>  <b>High latency turns on the predictive echo.</b> <br>  If you, for example, use SSH via EDGE, then I really do not envy you :).  In this case, mosh is able to ‚Äúunderstand‚Äù in what context it is now working and, in most cases, is able to adequately display your input even before at least something comes from the server.  In the illustration below, the ‚Äúunderlined‚Äù text is the text entered by the user, but the echo (in most cases just text entered by the user) has not yet been received from the server.  Also, even in the case of not too high latency (for example, 50ms, already noticeable by sight), mosh tries to show user input instantly if it is ‚Äúsure‚Äù that the entered text is simply being returned from the server at the moment.  Thus, in the case of latency of about 50-100 ms, work in a remote console becomes almost indistinguishable from local one.  Except for the opportunity to see the story, as mentioned above. <br><br><img src="https://habrastorage.org/files/0e6/1bf/149/0e61bf14937a486cbeb72a6bf13166bd.png"><br><br>  All these things are achieved due to the fact that the server also "renders" the output from the console and keeps the current screen state in its memory.  In mosh's tracker, there are suggestions to be able to keep history as well, so that you can refuse the additional layer in the form of screen / tmux, but so far the authors have not done anything in this direction. <br><br>  Let's now move on to what tmux is and why it is better than screen: <br><br><h3>  Screen problems </h3><br>  Unfortunately, I am not a big screen expert, so I could name only two problems - the lack of support for dividing the screen vertically (instead of the horizontal one by default) and the slow development in general due to a very old code base.  The usability of the screen also left much to be desired.  The vertical separation support was filed in the new version of screen 4.2, but by that time I personally had already stopped using it.  In general, screen is still a de facto standard, just like ssh, and you cannot write it off. <br><br><h3>  What is tmux and its advantages over screen </h3><br>  If you have never heard of terminal multiplexers (Terminal MUltipleXor), then the previous paragraph is unlikely to be clear to you.  Therefore, I will tell a little about what it is: <br><br>  Imagine the situation that you want to run some kind of long ssh operation, and your connection is falling off.  Or you do not want to wait for its completion, because this command is ‚Äúwhile true;  do run-daemon;  done. "  By default, interactive sessions send a SIGHUP signal to all processes from this session when disconnected, and the processes are terminated. <br><br>  This problem can be solved in different ways, for example, using the nohup command, which redirects the output to files and ignores SIGHUP.  But a more interesting solution is to use terminal multiplexers, such as screen or tmux.  When you first start, it usually starts a new session in which you can work, and this session is not tied tightly to your ssh connection.  You can disconnect, for example, by closing the tab with an ssh connection, or by pressing Ctrl + BD (that is, first press Ctrl + B and then release Ctrl and press D), and all applications running inside tmux will remain intact.  You can then connect back to this session by typing "tmux attach" or screen with a bunch of checkboxes, for example "-rD". <br><br><img src="https://habrastorage.org/files/888/d22/609/888d226090d84b01bbe19ab51e195d53.png"><br><br>  In general, tmux looks more user-friendly and supports quite interesting things out of the box: <br><br><ol><li>  The above screen splitting is vertical, for example using Ctrl + B: split-vertical.  Unfortunately, the new version of screen with the support of such a split screen can still not be found everywhere. </li><li>  The ability to connect to an existing session several times - tmux attach will connect you to an existing session without ‚Äúthrowing out‚Äù other connected users </li><li>  Rewind history using the mouse wheel by setting the mouse-mode on option </li><li>  No need to run "script" when trying to connect to another user's screen via sudo </li></ol><br><br>  Most likely, all the above things can be done within the framework of the screen, just tmux was originally designed more simple for the user and has more features.  If you suddenly use iterm2, then it has built-in support for integrating with tmux, which can also be an argument in its favor. <br><br>  And finally, let's talk about fish - friendly interactive shell <br><br><h3>  Disadvantages bash </h3><br>  Honestly, it's hard to say what the bash is about.  The biggest advantage of bash is that it is the most common shell and that it stands by default on most Linux distributions, mac os x and even cygwin.  Also, bash is posix-compatible, which means that you can replace / bin / sh with / bin / bash in the system and ‚Äúit won't break anything.‚Äù  However, the interactive capabilities of the bash are far behind another common competitor in the face of zsh, there is not even the right prompt in the bash.  Most features in both bash and zsh are disabled by default.  To use all the features of these shells, you need to either spend a significant amount of time setting them up, or use ready-made solutions, for example oh-my-zsh. <br><br><h3>  21st century interactive shell - fish </h3><br>  It‚Äôs enough to see once how the fish (friendly interactive shell) works and you don‚Äôt want to use anything else :).  In general, fish is an interactive shell, not POSIX-compatible.  That is, scripts written for / bin / sh or / bin / bash cannot be executed with it.  The shell syntax is slightly different from the usual, see the examples below. <br><br>  <b>Main features:</b> <br><br><ul><li> Auto-complement for commands from history and for file names right as you type, in real time </li><li>  Comes "with batteries" - out of the box there is a smart auto-complement for most teams, there is git_prompt and so on. </li><li>  The presence of left and right prompts, the correct calculation of their sizes, the prompt is set by the function, not by the string from PS1 </li><li>  Automatic history for directories - Alt + Shift + left-right arrows allow you to transparently return to the previous directory and back </li><li>  ‚ÄúCorrected‚Äù syntax, no more do, then, fi, esac, $ ?, baktik (`cmd`) and many other things - with adequate hints - it makes fish a non-POSIX shell, which, in general, dignity is an </li><li>  Support for abbreviations - for example, by creating the abbreviation "st -&gt; git status", you will "enter" "git status" as soon as you enter "st" - this way the auto-complement will work and people around you will not be afraid of your incomprehensible abbreviations </li><li>  Improved auto-addition by &lt;tab&gt; - not only the prompts themselves are shown, but also their type (for example, for git checkout, branches and tags are shown separately) </li></ul><br><br>  There are also just minor nice improvements: <br><br><ul><li>  The prompt is displayed normally and does not deteriorate, even if the output of the program does not end with a newline. </li><li>  underscore correct file paths </li><li>  displaying incorrect commands in red - you can understand that you entered the wrong command name without pressing Enter </li><li>  the ability to easily redirect stderr to a pipe using the syntax of the form 2&gt; |  or ^ | </li><li>  everything has a function, no aliases, and autoload is supported for functions ‚Äî when loading fish it does not read all available functions into memory, and also allows changing the code of functions on the fly without the need to reread the full config </li><li>  local variable CMD_DURATION - the execution time of the last command, in milliseconds </li><li>  shortened path to the current default directory ‚Äî the first letters of each component of the path are taken, except for the last directory (for example, / usr / local / bin / -&gt; / u / l / bin /) </li></ul><br><br>  An example of the right prompt using CMD_DURATION and git_prompt: <br><br><pre><code class="hljs bash">$ cat ~/.config/fish/<span class="hljs-built_in"><span class="hljs-built_in">functions</span></span>/fish_right_prompt.fish <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> fish_right_prompt <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> <span class="hljs-variable"><span class="hljs-variable">$status</span></span> = 0 <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n (set_color green) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> -n (set_color red) end <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-variable"><span class="hljs-variable">$CMD_DURATION</span></span> (set_color normal)ms (set_color yellow) (__fish_git_prompt <span class="hljs-string"><span class="hljs-string">"%s"</span></span>) (set_color normal) end</code> </pre> <br><br>  Pay attention to the syntax of if-expressions - it is more like python than shell.  The expression in brackets means ‚Äúinsert the result of the command execution‚Äù - this is written to bash as $ (...), the first dollar symbol is not required in fish. <br><br>  Here is what it looks like: <br><br><img src="https://habrastorage.org/files/474/9e9/8ea/4749e98ea635432089cfb510af3b20e4.png"><br><br>  The right prompt shows the command execution time in milliseconds, in green if the command was successful, and in red if an error occurred.  The current branch, if any, is shown in yellow. <br><br><h3>  Integration of mosh, tmux and fish, conclusions </h3><br>  When using tmux and fish together, there are 2 possible problems, both of which are a bit unpleasant, but easily solved: <br><br>  The output from stderr ‚Äúdisappears‚Äù - <a href="https://github.com/fish-shell/fish-shell/issues/2115">github.com/fish-shell/fish-shell/issues/2115</a> - is solved by running ‚Äúfish 2&gt; &amp; 1‚Äù instead of just ‚Äúfish‚Äù <br>  By default, tmux sets the $ TERM environment variable to screen, although it supports the 256-color mode, so you need to set the ‚Äúexport TERM = screen-256color‚Äù environment variable to get a regular fish instead of a fallback to 16-color mode <br><br>  Also, when using the right prompt in fish, as well as when dividing windows vertically in tmux, the client for mosh can begin to shift the right border during quick entry, which leads to temporary artifacts when drawing.  This is due to the fact that mosh does not understand that the position of the frames separating the panels in tmux, as well as the position of the right prompt in fish is fixed, and shifts them when entered to the right, along with the rest of the text. <br><br>  Total: all of the above tools are quite new, and have not yet been sharpened to the same state as the usual ssh + screen + bash combination, but over time the situation improves, developers take into account feedback from users and improve integration with other "new" tools. <br><br>  In general, a bunch of mosh + tmux + fish for me decided a lot of small (and not so) problems associated with working in a remote console, without creating a lot of new ones.  A large number of small, but convenient and useful features of each of the described tools, it seems to me, it is worthwhile to try them yourself. </div><p>Source: <a href="https://habr.com/ru/post/267797/">https://habr.com/ru/post/267797/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267781/index.html">C ++ module support in Visual Studio 2015 Update 1</a></li>
<li><a href="../267785/index.html">Go, practice asynchronous interaction</a></li>
<li><a href="../267789/index.html">Flying panels flew away from us ... About navigation and the "Back" button in C # / XAML applications in Windows 10</a></li>
<li><a href="../267791/index.html">Virtual quadrocopter on Unity + OpenCV (Part 1)</a></li>
<li><a href="../267795/index.html">The digest of interesting materials for the mobile # 122 developer (September 21-27)</a></li>
<li><a href="../267799/index.html">New PHP, Part 2: Scalar types</a></li>
<li><a href="../267801/index.html">CSS games. Part 2: StarCraft</a></li>
<li><a href="../267803/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ178 (September 21 - 27, 2015)</a></li>
<li><a href="../267811/index.html">PHP and OData: we are moving from bicycles to technology from Microsoft</a></li>
<li><a href="../267813/index.html">Deploy infrastructure for development in the cloud InfoboxCloud. Part 1: Starting Gitlab</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>