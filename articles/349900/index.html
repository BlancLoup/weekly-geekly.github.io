<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a Telegram bot to get information on the Dogecoin wallet</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since the description of the blockchain technology in 2008 and the first implementation in 2009 (Bitcoin) to the present, more than a thousand cryptoc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a Telegram bot to get information on the Dogecoin wallet</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/km/bv/3k/kmbv3kzouwrsjycebeegcz9opba.png" alt="image" align="left"><br>  Since the description of the blockchain technology in 2008 and the first implementation in 2009 (Bitcoin) to the present, more than a thousand cryptocurrencies have been created.  An ICO is held every few days.  Many are engaged in mining or playing on cryptocurrency exchanges. <br><br>  Due to the fact that currencies are unstable and their rate is constantly changing, in order to avoid losing savings, it is important to be able to receive up-to-date information on the rate and status of your accounts as soon as possible. <br><br>  Since information about the blockchain is publicly available, access to it is possible through web services and mobile applications.  To monitor the status of accounts convenient to use multicurrency mobile applications.  However, due to the high speed of creating new cryptocurrencies, not all developers have time to add their support, and the user is forced to install other applications with the required currency, which affects the convenience and the occupied memory size of the device.  This is where another trend of our time comes to the rescue - chat bots, the management APIs of which are provided by most instant messengers. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider creating a chat bot for Telegram, which provides information about the accounts of a cryptocurrency such as Dogecoin.  Dogecoin was introduced in 2013 and is named after the internet meme Doge.  Often used to collect donations and charity. <br><a name="habracut"></a><br><h2>  Register bot in Telegram </h2><br>  Let's start with the registration of the bot in the messenger.  To do this, we find in the Telegram the father of all bots - BotFather, send him the command ‚Äú/ newbot‚Äù and fill in the required parameters: the displayed (DogeWallet) and unique name (DogeWalletBot).  After this, BotFather will provide a bot access token.  At this point, you can finish with registration, but for ease of use, we also enter a description of the bot, an image and a list of commands that will appear after entering the ‚Äú/‚Äù symbol: <br><br><ul><li>  setwallet - sets the address of the Dogecoin wallet; </li><li>  balance - returns the balance of the entered or default address of the DogeCoin wallet; </li><li>  received - returns Dogecoin received by the entered wallet address or the default address; </li><li>  sent - returns Dogecoin sent by the specified wallet address or default address; </li><li>  qrcode - returns the QR-code of the specified address or the default address; </li><li>  report - returns a report on the transactions of the specified address or the default address; </li><li>  rate - returns the current Dogecoin rate in US dollars and Bitcoins </li><li>  help - shows all available commands. </li></ul><br><h2>  Presets </h2><br>  Now that the bot has been registered and the main functionality has been defined, one can proceed to the choice of the development platform.  We will write a bot on the Microsoft Bot Framework, because  it provides ample opportunities for working with dialogs and a large set of supported communication channels (which provides the ability to quickly launch a bot in another messenger almost without rewriting the code), select C # as the language (you can also use Node.js). <br><br>  To get started, you need Visual Studio 2015 or higher, bot application templates, Bot Controller, Bot Dialog and Bot Framework Emulator - for details, the installation procedure is described in the <a href="https://docs.microsoft.com/en-us/bot-framework/dotnet/bot-builder-dotnet-quickstart">Microsoft Bot Framework</a> documentation. <br><br><h2>  Creating a bot, processing commands </h2><br>  Create a project from the template "Bot Application". <br><br><img src="https://habrastorage.org/webt/h-/sh/4t/h-sh4tapb8nkb67ehouzfdhnauc.png" alt="image"><br><br>  In the project structure, you can observe classes such as MessagesController and RootDialog.  The application's entry point, which accepts all incoming messages, is the Post method of the class MessagesController.  It contains the following code: <br><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;HttpResponseMessage&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[FromBody]Activity activity</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activity.Type == ActivityTypes.Message) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> Conversation.SendAsync(activity, () =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dialogs.RootDialog()); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { HandleSystemMessage(activity); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> response = Request.CreateResponse(HttpStatusCode.OK); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> response; }</code> </pre> <br>  Messages that are text are sent to the RootDialog for further processing, and all others to the HandleSystemMessage method of the MessagesController class.  Messages that are not text can be a message about adding a user or bot to a chat, the beginning or end of a dialogue. <br><br>  The RootDialog class, like all dialogs, implements the IDialog interface and must contain the StartAsync method.  The first message received by the bot enters this method.  By default, it contains a call to context.Wait (MessageReceivedAsync) ‚Äîthat is, the method that handles the next message is set (but, since not a single handler of the received message was installed, the MessageReceivedAsync call will occur immediately after StartAsync). <br><br>  Modify the MessageReceivedAsync method so that instead of sending the received message back to the user, it handles the commands defined earlier. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageReceivedAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context, IAwaitable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> activity = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> Activity; <span class="hljs-comment"><span class="hljs-comment">// if "/setwallet" command if (activity.Text == "/setwallet") { context.Call(new SetWalletDialog(), SetWalletDialogResumeAfter); } // if "/setwallet [address]" command else if (activity.Text.Contains("/setwallet")) { var forvardedMsg = context.MakeMessage(); forvardedMsg.Text = activity.Text; await context.Forward(new SetWalletDialog(), SetWalletDialogResumeAfter, forvardedMsg, CancellationToken.None); } // if "/balance [address]" command else if (activity.Text.Contains("/balance")) { var forvardedMsg = context.MakeMessage(); forvardedMsg.Text = activity.Text; await context.Forward(new GetBalanceDialog(), GetBalanceDialogResumeAfter, forvardedMsg, CancellationToken.None); } else { if (activity.Text == "/start") //start conversation await GreetUser(context, result); else if (activity.Text == "/help") //show help await ShowHelp(context); context.Wait(MessageReceivedAsync); } }</span></span></code> </pre> <br>  The "/ setwallet" command is processed first: if only this command is entered without specifying an address, the SetWalletDialog dialog is invoked using the context.Call method.  It accepts parameters such as a new called dialog and a function that is called when the called dialog ends (SetWalletDialogResumeAfter).  It is worth noting that the Microsoft Bot Framework uses such a structure as a stack of dialogs - that is, the RootDialog is first called, which in turn calls SetWalletDialog, placing it on top of the stack.  While he is at the top, all messages will come to him (not counting the global dialogues that can take control if necessary).  When creating a new dialog, the StartAsync method of the SetWalletDialog class is called immediately: <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StartAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = context.Activity.AsMessageActivity(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (msg.Text == <span class="hljs-string"><span class="hljs-string">"/setwallet"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.PostAsync(<span class="hljs-string"><span class="hljs-string">"Enter DogeCoin wallet address, please!"</span></span>); context.Wait(MessageReceivedAsync); }</code> </pre> <br>  Provided that the command does not contain an address, a message is displayed, urging the user to enter the address.  Then the next message handler is installed and input is expected. <br><br>  If a command is received that also contains the address ("/ setwallet [address]"), then the new dialog is invoked using the Forward method.  This method differs from Call in that it sends the message further to the called dialog and, after the StartAsync method is completed, it does not wait for input, and the message is immediately passed to the MessageReceivedAsync method of the SetWalletDialog class.  Consider this method. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageReceivedAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context, IAwaitable&lt;IMessageActivity&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> message = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> address = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((message.Text != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) &amp;&amp; (message.Text.Trim().Length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (message.Text.Contains(<span class="hljs-string"><span class="hljs-string">" "</span></span>)) <span class="hljs-comment"><span class="hljs-comment">//if "/setwallet [address]" command { address = message.Text.Replace("/setwallet ", "").Trim(); } else address = message.Text; try { var balance = await Client.GetBalanceAsync(address); if (balance.Success == 1) { context.UserData.SetValue("wallet", address); context.Done(address); } else await ProcessErrors(context); } catch(Exception ex) { await ProcessErrors(context); } } }</span></span></code> </pre> <br>  The message is analyzed if it contains a space (that is, both the command and the address), then this address is allocated and stored in a variable.  This option is triggered when the Forward dialog is called.  If the message does not contain a space (it is assumed that the address is entered after the bot has sent a message to suggest entering it), then the address is saved to the variable without processing.  This case occurs when creating a dialogue using the Call method.  Next, the address is checked for existence by trying to get its balance.  If this succeeds, the address is stored in the internal storage of the MS Bot Framework (context.UserData.SetValue ("wallet", address)) and the SetWalletDialog dialog ends, is removed from the stack (context.Done (address)) and passes the address to the parent dialog. <br><br>  In case of error (wrong address), errors are processed in the ProcessErrors method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessErrors</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context</span></span></span><span class="hljs-function">)</span></span> { --attempts; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (attempts &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.PostAsync(ExceptionMessage); context.Wait(MessageReceivedAsync); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* Fails the current dialog, removes it from the dialog stack, and returns the exception to the parent/calling dialog. */</span></span> context.Fail(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TooManyAttemptsException(ExceptionFinalMessage)); } }</code> </pre> <br>  The user is given several attempts to enter the correct address, then the dialog ends with an error message (context.Fail (new TooManyAttemptsException (ExceptionFinalMessage))) and control is passed to RootDialog. <br><br>  After the child dialog is completed, the [DialogClassName] ResumeAfter method is called in the parent, where the result of the child dialog is further processed and the context.Wait (MessageReceivedAsync) method is called to indicate the recipient of the next message. <br><br>  Other commands are processed in the same way with only one difference - they are always transmitted by the Forward method, since they do not require the input of a clarifying message (in the case of entering a command without an argument, the address is taken from the repository (context.UserData.TryGetValue ("wallet", out address) ). <br><br>  Let us dwell on getting data for output by the bot, and in particular on the Client.GetBalanceAsync method presented earlier.  Client is a static class that provides access to data on cryptocurrency wallets.  It contains methods that access the corresponding services API.  This project uses APIs from projects such as dogechain.info and chain.so.  Consider the GetBalanceAsync method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;BalanceEntity&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetBalanceAsync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetAsync&lt;BalanceEntity&gt;(<span class="hljs-string"><span class="hljs-string">$"address/balance/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{address}</span></span></span><span class="hljs-string">"</span></span>); }</code> </pre> <br><br>  This is where the generic data retrieval method is called, complementing the query and indicating the type of data returned.  The type of data returned is described in a simple POCO class BalanceEntity: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BalanceEntity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Balance { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Success { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  Consider the GetAsync method: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;T&gt; GetAsync&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> path) { InitClient(); T entity = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>(T); HttpResponseMessage response = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetAsync(path); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.IsSuccessStatusCode) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> jsonString = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.Content.ReadAsStringAsync(); entity = JsonConvert.DeserializeObject&lt;T&gt;(jsonString); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> entity; }</code> </pre> <br>  This method initializes a new instance of the HttpClient class in the InitClient method: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; InitClient(WebApiHost); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InitClient</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> webApiHost</span></span></span><span class="hljs-function">)</span></span> { WebApiHost = webApiHost; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (client != <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; !<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.IsNullOrEmpty(WebApiHost) &amp;&amp; client.BaseAddress.AbsoluteUri == WebApiHost) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(WebApiHost) }; client.DefaultRequestHeaders.Accept.Clear(); client.DefaultRequestHeaders.Accept.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MediaTypeWithQualityHeaderValue(<span class="hljs-string"><span class="hljs-string">"application/json"</span></span>)); }</code> </pre> <br>  Next, a request is made to the server providing the data about the wallet, and in case of successful receipt of the json object, it is converted to the corresponding class. <br><br>  After the implementation of the main commands, you can check the operation of the bot.  To do this, use the emulator downloaded earlier.  Enter the address where the bot is running and click CONNECT.  Enter the command "/ setwallet" - the bot tells us to enter the address of the wallet.  We enter. <br><br><img src="https://habrastorage.org/webt/ky/xp/-0/kyxp-0na2borhigtcp1bytyjsd0.png" alt="image"><br><br>  And the bot reports that it successfully saved it. <br><br><img src="https://habrastorage.org/webt/us/ve/vu/usvevukpkzz6jjqn_oubztitc1o.png" alt="image"><br><br>  Check the balance with the command "/ balance" and find out that there are a little more than 357 dogs on the account: "Balance of D6VDAHdzDuuUxorDN1dRZVudu2PfxZvUNp address is: 357.91600317 DogeCoin's". <br><br>  Add a greeting sent to the user during the first access to the bot.  Since we use Telegram as a platform for communication, the first message received by the bot will be ‚Äú/ start‚Äù.  Process it, as well as the ‚Äú/ help‚Äù command in the MessageReceivedAsync of the RootDialog class: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (activity.Text == <span class="hljs-string"><span class="hljs-string">"/start"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//start conversation await GreetUser(context, result); else if (activity.Text == "/help") //show help await ShowHelp(context); context.Wait(MessageReceivedAsync);</span></span></code> </pre> <br>  When a command is received, we call the appropriate methods, and then set the method to process the next received message.  The GreetUser method sends a greeting message and shows help about the commands, ShowHelp only shows help. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context, IAwaitable&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; result</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SendGreetMessage(context); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> ShowHelp(context); }</code> </pre> <br>  In the SendGreetMessage method, a greeting message is created and a Doge image is attached: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendGreetMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> qrMsg = context.MakeMessage(); qrMsg.Text = <span class="hljs-string"><span class="hljs-string">"Welcome, Young Shibe!\r\n"</span></span>; qrMsg.Attachments.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Attachment() { ContentUrl = <span class="hljs-string"><span class="hljs-string">"http://www.stickpng.com/assets/images/5845e608fb0b0755fa99d7e7.png"</span></span>, ContentType = <span class="hljs-string"><span class="hljs-string">"image/png"</span></span>, Name = <span class="hljs-string"><span class="hljs-string">" "</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> context.PostAsync(qrMsg); }</code> </pre> <br>  The new attachment contains such parameters as ContentUrl - the path to the image, ContentType - the attachment type, and Name - the name. <br><br><h2>  Register bot in MS Bot Framework </h2><br>  After creating the bot and debugging locally using the emulator, you can start deploying on the server and registering with Azure (previously registered at botframework.com, but recently migrated to Azure and it is recommended to create new bots there).  We publish our bot on Windows hosting (unfortunately, Bot Builder does not support Core in the current version) or in Azure.  After that we register the bot.  To do this, go to portal.azure.com, click the button for creating a new resource (New) and enter ‚Äúbot‚Äù in the search.  From the list, select the Bot Channels Registration and click "Create". <br><br><img src="https://habrastorage.org/webt/zs/jp/xp/zsjpxpbgyjkbn4xpdxukjk75nls.png" alt="image"><br><br>  We fill in the fields and enter the address of our deployed bot as Messaging Endpoint, adding ‚Äú/ api / messages‚Äù - <a href="https://dogewalletbot.azurewebsites.net/api/messages">dogewalletbot.azurewebsites.net/api/messages</a> . <br><br><img src="https://habrastorage.org/webt/th/wd/lo/thwdloqmdmkmuzmgge7vomkqvzg.png" alt="image"><br><br>  After creating ‚ÄúBot Channels Registration‚Äù, go to it and in the ‚ÄúSettings‚Äù tab, look for the Microsoft App ID and the Manage link next to it.  Go through it to apps.dev.microsoft.com and click the button "Create a new password."  We remember the Microsoft App ID and password (MicrosoftAppPassword) and enter them into our bot's Web.config in the appSettings section.  After that, the connection between the bot and the channels should work.  Check in the previously created service Bot Channels Registration in the section "Test in Web Chat": <br><br><img src="https://habrastorage.org/webt/cs/8i/7u/cs8i7usnn7xwnjlpl2_iyqefoby.png" alt="image"><br><br>  Next, connect the channel to connect with Telegram.  Click Channels, select Telegram and enter the token provided by BotFather.  Go to the Telegram, add the bot and click "Start". <br><br><img src="https://habrastorage.org/webt/bu/sa/dx/busadxzunurbjjr_fmfkir8etys.png" alt="image"><br><br>  The bot, having received the ‚Äú/ start‚Äù command, responds with a greeting and help.  The processing of the remaining commands also takes place. <br><br><h2>  Report creation </h2><br>  We implement the sending of the incoming transaction report to the wallet address in the form of a list ‚Äútransaction id, value‚Äù in PDF format.  To do this, we use the FastReport.Net report generator and the Telegram API (Telegram.Bot) library to send pdf to the Telegram server. <br><br>  Transaction data will be received at <a href="https://chain.so/api/v2/get_tx_received/DOGE/">chain.so/api/v2/get_tx_received/DOGE</a> [address].  The answer will be converted to the class of the following structure: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReceivedTransactionsResponse</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Status { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ReceivedTransactionsEntity Data { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReceivedTransactionsEntity</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Address { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> List&lt;ReceivedTransaction&gt; Txs { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ReceivedTransaction</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Txid { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Confirmations { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  The method of obtaining data about the transactions of the Client class is as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> Task&lt;List&lt;ReceivedTransaction&gt;&gt; GetReceivedTransactions(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> address) { WebApiHost = WebApiHostChainSo; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> trs = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> GetAsync&lt;ReceivedTransactionsResponse&gt;(<span class="hljs-string"><span class="hljs-string">$"get_tx_received/DOGE/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{address}</span></span></span><span class="hljs-string">"</span></span>); WebApiHost = WebApiHostDogechain; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> trs?.Data?.Txs; }</code> </pre> <br>  It overrides the URL of the API call at the beginning of the method and returns it back before completion. <br><br>  After getting the list of transactions in the ReportDialog class, the SendReport method is called: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SendReport</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IDialogContext context, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, List&lt;ReceivedTransaction&gt; transactions</span></span></span><span class="hljs-function">)</span></span> { Reporter repr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Reporter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (context.Activity.ChannelId != <span class="hljs-string"><span class="hljs-string">"telegram"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (MemoryStream pdfReport = repr.GetReceivedTransactionsPdf(address, transactions)) { TelegramBotClient client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TelegramBotClient(<span class="hljs-string"><span class="hljs-string">"telegram_bot_token"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> me = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.GetMeAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> chatId = context.Activity.From.Id; <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> client.SendDocumentAsync(chatId, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileToSend(<span class="hljs-string"><span class="hljs-string">"Received transactions.pdf"</span></span>, pdfReport), <span class="hljs-string"><span class="hljs-string">"First 100 received transactions."</span></span>); } }</code> </pre> <br>  It, in turn, creates a report in the Reporter class.  Then a TelegramBotClient is created and a pdf report is sent. <br><br>  Consider the GetReceivedTransactionsPdf method of the Reporter class: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> MemoryStream </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetReceivedTransactionsPdf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> address, List&lt;ReceivedTransaction&gt; transactions, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> afterTXID = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> appData = HostingEnvironment.MapPath(<span class="hljs-string"><span class="hljs-string">"~/App_Data/"</span></span>); Config.WebMode = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; Report = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Report(); Report.Load(appData + <span class="hljs-string"><span class="hljs-string">"TransactionsReport.frx"</span></span>); Report.RegisterData(transactions, <span class="hljs-string"><span class="hljs-string">"txs"</span></span>); Report.GetDataSource(<span class="hljs-string"><span class="hljs-string">"txs"</span></span>).Enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; (Report.FindObject(<span class="hljs-string"><span class="hljs-string">"Data1"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> DataBand).DataSource = Report.GetDataSource(<span class="hljs-string"><span class="hljs-string">"txs"</span></span>); Report.Prepare(); PDFExport pdf = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PDFExport(); MemoryStream exportStream = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MemoryStream(); Report.Export(pdf, exportStream); exportStream.Position = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> exportStream; }</code> </pre> <br>  At the beginning, the Config.WebMode = true line sets the mode of FastReport.Net, which prevents the appearance of loading indicators and other graphics that are not needed in the web mode.  Next, the previously prepared report from the App_Data folder is loaded.  The report contains the report title, pages and DataBand.  There are two text objects (TextObject) on the data band to display the transaction number and its value. <br><br><img src="https://habrastorage.org/webt/w3/07/vo/w307vo8_mpircnmri5qhpdtlfkc.png" alt="image"><br><br>  After the report is loaded, the data is connected using the Report.RegisterData method, enabling the connected data source and assigning it to the Data band.  Then it is exported to PDF and returned to the Stream containing the report. <br><br>  Check team work.  Let's send a message to the Telegram - / report DRapidDiBYggT1zdrELnVhNDqyAHn89cRi and get a message in reply. <br><br><img src="https://habrastorage.org/webt/wu/3v/3e/wu3v3eymsbeqsauayfjplx9tlag.png" alt="image"><br><br>  Open the file and see the list of incoming transactions and their values. <br><br><img src="https://habrastorage.org/webt/w-/hw/nc/w-hwncehmwbmighl8axrq_fkbk4.png" alt="image"><br><br><h2>  Conclusion </h2><br>  The source code for the project <a href="https://github.com/8VAid8/DogeWalletBot">is available on GitHub</a> . <br><br>  Currently, for full use of the MS Bot Framework, full .Net Framework and Windows hosting is required, which increases the cost of bots maintenance, however, in the next version, it is planned to add Core support for Microsoft.Bot.Builder.  Unfortunately, the release date is not yet known. <br><br><h2>  useful links </h2><br><ol><li>  <a href="https://core.telegram.org/bots">Documentation on the creation of bots in Telegram</a> </li><li>  <a href="https://docs.microsoft.com/ru-ru/bot-framework/">MS Bot Framework Documentation</a> </li><li>  <a href="">.NET Client for Telegram Bot API on GitHub</a> </li><li>  <a href="">Documentation .NET Client for Telegram Bot API</a> </li><li>  <a href="https://dogechain.info/api">Description of Dogechain.info API</a> </li><li>  <a href="https://chain.so/api">Description chain.so API</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/349900/">https://habr.com/ru/post/349900/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349880/index.html">Vue.js + Asp.NETCore + TypeScript application without Webpack</a></li>
<li><a href="../349886/index.html">Quick interactive layout of the hall on canvas</a></li>
<li><a href="../349888/index.html">The digest of interesting materials for the mobile developer # 242 (February 19 - February 25)</a></li>
<li><a href="../349890/index.html">We receive the list of passengers of flights of the largest air carrier of Ukraine</a></li>
<li><a href="../349894/index.html">Script for obtaining information from a Windows image</a></li>
<li><a href="../349902/index.html">"Digital States": how it all began</a></li>
<li><a href="../349904/index.html">GLPI in a small organization, part 2. Basic functionality and features of its use</a></li>
<li><a href="../349906/index.html">Setting up VoIP FXO gateway Yeastar Neogate TAXXX to work with 3CX</a></li>
<li><a href="../349908/index.html">How to learn to learn. Part 3 - we train memory "on a science"</a></li>
<li><a href="../349910/index.html">Three aspects of optimization (DB and software)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>