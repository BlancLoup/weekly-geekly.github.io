<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AVR Audio Player</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="During the next revision of electronic junk and shoving in boxes, I came across an AVR atxmega256a3u controller. In order to allay the boredom, it was...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AVR Audio Player</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/6f7/134/c40/6f7134c4060240dfa4f58827e840943c.jpg"><br><br>  During the next revision of electronic junk and shoving in boxes, I came across an AVR atxmega256a3u controller.  In order to allay the boredom, it was decided to make some kind of sound card, or rather DAC, connected to a computer.  What came out of this look under the cut. <br><a name="habracut"></a><br>  The XMEGA microcontroller line is a development of MEGA controllers familiar to most electronics lovers, many interesting buns have been added, but everything described below can be implemented on a traditional series.  I recommend only to use those controllers, where more RAM. <br><br>  From words to design, after reflection, I came to this structure of the device: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/303/ed8/b4c/303ed8b4cc994f0ca1a0cc10ded19309.png"><br><br>  I will play music from wav files, mono, 8 bits with a sampling frequency of 44.1 kHz.  Sending a serial port consists of 10 baud (start and stop bits, 8 data bits), which means that a speed of at least 441 kBaud / s is required.  The equipment allows you to work faster, I take 2000 kB / s data transfer rate with reserve. <br><br>  Inside the controller is a FIFO buffer, it‚Äôs also the first-come-first-out queue.  On a timer with a frequency of 44.1 kHz, an interrupt is started which extracts the next sample from the buffer and transmits it to the D / A converter, and also requests the next data packet from the computer, if necessary.  Thinking about all this, I trace and harass the "debug" board for the microcontroller: <br><br><img src="https://habrastorage.org/files/7c7/16d/822/7c716d8224154de4846c2ddb301eb96d.jpg"><br><br>  Perhaps the most interesting in this development is the DAC.  There is a built-in DAC in my microcontroller, but it is not sporty to use it, besides, most microcontrollers do not have this luxury.  Do not worry, you can make a DAC yourself from a handful of resistors according to the R-2R scheme: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/46c/2e4/a7046c2e4378ecc407927959ed4cec9d.png" alt="image"><br><br>  This scheme allows you to get the output voltage in the range from 0 V to the level of the logical unit, in my case it is 3.3 V. I will do an eight-bit DAC, I have only resistors with a tolerance of 5%, which means accuracy will be lost from the fifth digit because (1 /2^5)&lt;0.05.  Nevertheless, I hope that the lower digits will allow to voice the weak spectral components of the signal.  I collect from resistors with a nominal value of 5.1 kOhm such a monster: <br><br><img src="https://habrastorage.org/files/dfa/1d1/9f1/dfa1d19f175042868eeb5d689dfb575c.jpg"><br><br>  Immediately I put the amplifier TDA2822M, I connect on a bridge circuit from the datasheet: <br><br><img src="https://habrastorage.org/files/2b1/2a3/40d/2b12a340d7fb46708a44b8e4375386d9.JPG"><br><br>  And doing a column with a phase inverter: <br><br><img src="https://habrastorage.org/files/916/31d/60f/91631d60fcc24fd499d955c60a5d061e.jpg"><br><br>  It's time to listen: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/gR1DKfi2Js0%3Ffeature%3Doembed&amp;xid=17259,15700021,15700043,15700186,15700190,15700248,15700253&amp;usg=ALkJrhjogRA9-iXpjw3spzbyAmvJJG_UKw" frameborder="0" allowfullscreen=""></iframe><br><br>  It sounds more or less tolerable, if you connect a bigger speaker, it gets better. <br><br><div class="spoiler">  <b class="spoiler_title">Code for MK</b> <div class="spoiler_text">  Carefully, a code generator is used for initialization.  There is the possibility of using the internal DAC. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// I/O Registers definitions #include &lt;io.h&gt; // Declare your global variables here #define fSIZE 12000 int rAdr,wAdr,dn; char needdata; char fifo[fSIZE]; // System Clocks initialization void system_clocks_init(void) { unsigned char n,s; // Optimize for speed #pragma optsize- // Save interrupts enabled/disabled state s=SREG; // Disable interrupts #asm("cli") // External 16000,000 kHz oscillator initialization // External Clock Source - Startup Time: 0.4-16 MHz Quartz Crystal - 16k CLK OSC.XOSCCTRL=OSC_FRQRANGE_12TO16_gc | OSC_XOSCSEL_XTAL_16KCLK_gc; // Enable the external oscillator/clock source OSC.CTRL|=OSC_XOSCEN_bm; // System Clock prescaler A division factor: 1 // System Clock prescalers B &amp; C division factors: B:1, C:1 // ClkPer4: 16000,000 kHz // ClkPer2: 16000,000 kHz // ClkPer: 16000,000 kHz // ClkCPU: 16000,000 kHz n=(CLK.PSCTRL &amp; (~(CLK_PSADIV_gm | CLK_PSBCDIV1_bm | CLK_PSBCDIV0_bm))) | CLK_PSADIV_1_gc | CLK_PSBCDIV_1_1_gc; CCP=CCP_IOREG_gc; CLK.PSCTRL=n; // Wait for the external oscillator to stabilize while ((OSC.STATUS &amp; OSC_XOSCRDY_bm)==0); // Select the system clock source: External Oscillator or Clock n=(CLK.CTRL &amp; (~CLK_SCLKSEL_gm)) | CLK_SCLKSEL_XOSC_gc; CCP=CCP_IOREG_gc; CLK.CTRL=n; // Disable the unused oscillators: 2 MHz, 32 MHz, internal 32 kHz, PLL OSC.CTRL&amp;= ~(OSC_RC2MEN_bm | OSC_RC32MEN_bm | OSC_RC32KEN_bm | OSC_PLLEN_bm); // ClkPer output disabled PORTCFG.CLKEVOUT&amp;= ~(PORTCFG_CLKOUTSEL_gm | PORTCFG_CLKOUT_gm); // Restore interrupts enabled/disabled state SREG=s; // Restore optimization for size if needed #pragma optsize_default } // Ports initialization void ports_init(void) { // PORTA initialization // OUT register PORTA.OUT=0x00; // Pin0: Input // Pin1: Input // Pin2: Input // Pin3: Input // Pin4: Input // Pin5: Input // Pin6: Input // Pin7: Input PORTA.DIR=0x00; // Pin0 Output/Pull configuration: Totempole/No // Pin0 Input/Sense configuration: Sense both edges // Pin0 Inverted: Off // Pin0 Slew Rate Limitation: Off PORTA.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin1 Output/Pull configuration: Totempole/No // Pin1 Input/Sense configuration: Sense both edges // Pin1 Inverted: Off // Pin1 Slew Rate Limitation: Off PORTA.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin2 Output/Pull configuration: Totempole/No // Pin2 Input/Sense configuration: Sense both edges // Pin2 Inverted: Off // Pin2 Slew Rate Limitation: Off PORTA.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin3 Output/Pull configuration: Totempole/No // Pin3 Input/Sense configuration: Sense both edges // Pin3 Inverted: Off // Pin3 Slew Rate Limitation: Off PORTA.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin4 Output/Pull configuration: Totempole/No // Pin4 Input/Sense configuration: Sense both edges // Pin4 Inverted: Off // Pin4 Slew Rate Limitation: Off PORTA.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin5 Output/Pull configuration: Totempole/No // Pin5 Input/Sense configuration: Sense both edges // Pin5 Inverted: Off // Pin5 Slew Rate Limitation: Off PORTA.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin6 Output/Pull configuration: Totempole/No // Pin6 Input/Sense configuration: Sense both edges // Pin6 Inverted: Off // Pin6 Slew Rate Limitation: Off PORTA.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin7 Output/Pull configuration: Totempole/No // Pin7 Input/Sense configuration: Sense both edges // Pin7 Inverted: Off // Pin7 Slew Rate Limitation: Off PORTA.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Interrupt 0 level: Disabled // Interrupt 1 level: Disabled PORTA.INTCTRL=(PORTA.INTCTRL &amp; (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) | PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc; // Pin0 Pin Change interrupt 0: Off // Pin1 Pin Change interrupt 0: Off // Pin2 Pin Change interrupt 0: Off // Pin3 Pin Change interrupt 0: Off // Pin4 Pin Change interrupt 0: Off // Pin5 Pin Change interrupt 0: Off // Pin6 Pin Change interrupt 0: Off // Pin7 Pin Change interrupt 0: Off PORTA.INT0MASK=0x00; // Pin0 Pin Change interrupt 1: Off // Pin1 Pin Change interrupt 1: Off // Pin2 Pin Change interrupt 1: Off // Pin3 Pin Change interrupt 1: Off // Pin4 Pin Change interrupt 1: Off // Pin5 Pin Change interrupt 1: Off // Pin6 Pin Change interrupt 1: Off // Pin7 Pin Change interrupt 1: Off PORTA.INT1MASK=0x00; // PORTB initialization // OUT register PORTB.OUT=0x00; // Pin0: Input // Pin1: Input // Pin2: Input // Pin3: Input // Pin4: Input // Pin5: Input // Pin6: Input // Pin7: Input PORTB.DIR=0x00; // Pin0 Output/Pull configuration: Totempole/No // Pin0 Input/Sense configuration: Sense both edges // Pin0 Inverted: Off // Pin0 Slew Rate Limitation: Off PORTB.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin1 Output/Pull configuration: Totempole/No // Pin1 Input/Sense configuration: Sense both edges // Pin1 Inverted: Off // Pin1 Slew Rate Limitation: Off PORTB.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin2 Output/Pull configuration: Totempole/No // Pin2 Input/Sense configuration: Sense both edges // Pin2 Inverted: Off // Pin2 Slew Rate Limitation: Off PORTB.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin3 Output/Pull configuration: Totempole/No // Pin3 Input/Sense configuration: Sense both edges // Pin3 Inverted: Off // Pin3 Slew Rate Limitation: Off PORTB.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin4 Output/Pull configuration: Totempole/No // Pin4 Input/Sense configuration: Sense both edges // Pin4 Inverted: Off // Pin4 Slew Rate Limitation: Off PORTB.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin5 Output/Pull configuration: Totempole/No // Pin5 Input/Sense configuration: Sense both edges // Pin5 Inverted: Off // Pin5 Slew Rate Limitation: Off PORTB.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin6 Output/Pull configuration: Totempole/No // Pin6 Input/Sense configuration: Sense both edges // Pin6 Inverted: Off // Pin6 Slew Rate Limitation: Off PORTB.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin7 Output/Pull configuration: Totempole/No // Pin7 Input/Sense configuration: Sense both edges // Pin7 Inverted: Off // Pin7 Slew Rate Limitation: Off PORTB.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Interrupt 0 level: Disabled // Interrupt 1 level: Disabled PORTB.INTCTRL=(PORTB.INTCTRL &amp; (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) | PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc; // Pin0 Pin Change interrupt 0: Off // Pin1 Pin Change interrupt 0: Off // Pin2 Pin Change interrupt 0: Off // Pin3 Pin Change interrupt 0: Off // Pin4 Pin Change interrupt 0: Off // Pin5 Pin Change interrupt 0: Off // Pin6 Pin Change interrupt 0: Off // Pin7 Pin Change interrupt 0: Off PORTB.INT0MASK=0x00; // Pin0 Pin Change interrupt 1: Off // Pin1 Pin Change interrupt 1: Off // Pin2 Pin Change interrupt 1: Off // Pin3 Pin Change interrupt 1: Off // Pin4 Pin Change interrupt 1: Off // Pin5 Pin Change interrupt 1: Off // Pin6 Pin Change interrupt 1: Off // Pin7 Pin Change interrupt 1: Off PORTB.INT1MASK=0x00; // PORTC initialization // OUT register PORTC.OUT=0x00; // Pin0: Input // Pin1: Input // Pin2: Input // Pin3: Input // Pin4: Input // Pin5: Input // Pin6: Input // Pin7: Input PORTC.DIR=0x00; // Pin0 Output/Pull configuration: Totempole/No // Pin0 Input/Sense configuration: Sense both edges // Pin0 Inverted: Off // Pin0 Slew Rate Limitation: Off PORTC.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin1 Output/Pull configuration: Totempole/No // Pin1 Input/Sense configuration: Sense both edges // Pin1 Inverted: Off // Pin1 Slew Rate Limitation: Off PORTC.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin2 Output/Pull configuration: Totempole/No // Pin2 Input/Sense configuration: Sense both edges // Pin2 Inverted: Off // Pin2 Slew Rate Limitation: Off PORTC.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin3 Output/Pull configuration: Totempole/No // Pin3 Input/Sense configuration: Sense both edges // Pin3 Inverted: Off // Pin3 Slew Rate Limitation: Off PORTC.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin4 Output/Pull configuration: Totempole/No // Pin4 Input/Sense configuration: Sense both edges // Pin4 Inverted: Off // Pin4 Slew Rate Limitation: Off PORTC.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin5 Output/Pull configuration: Totempole/No // Pin5 Input/Sense configuration: Sense both edges // Pin5 Inverted: Off // Pin5 Slew Rate Limitation: Off PORTC.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin6 Output/Pull configuration: Totempole/No // Pin6 Input/Sense configuration: Sense both edges // Pin6 Inverted: Off // Pin6 Slew Rate Limitation: Off PORTC.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin7 Output/Pull configuration: Totempole/No // Pin7 Input/Sense configuration: Sense both edges // Pin7 Inverted: Off // Pin7 Slew Rate Limitation: Off PORTC.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // PORTC Peripheral Output Remapping // OC0A Output: Pin 0 // OC0B Output: Pin 1 // OC0C Output: Pin 2 // OC0D Output: Pin 3 // USART0 XCK: Pin 1 // USART0 RXD: Pin 2 // USART0 TXD: Pin 3 // SPI MOSI: Pin 5 // SPI SCK: Pin 7 PORTC.REMAP=(0&lt;&lt;PORT_SPI_bp) | (0&lt;&lt;PORT_USART0_bp) | (0&lt;&lt;PORT_TC0D_bp) | (0&lt;&lt;PORT_TC0C_bp) | (0&lt;&lt;PORT_TC0B_bp) | (0&lt;&lt;PORT_TC0A_bp); // Interrupt 0 level: Disabled // Interrupt 1 level: Disabled PORTC.INTCTRL=(PORTC.INTCTRL &amp; (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) | PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc; // Pin0 Pin Change interrupt 0: Off // Pin1 Pin Change interrupt 0: Off // Pin2 Pin Change interrupt 0: Off // Pin3 Pin Change interrupt 0: Off // Pin4 Pin Change interrupt 0: Off // Pin5 Pin Change interrupt 0: Off // Pin6 Pin Change interrupt 0: Off // Pin7 Pin Change interrupt 0: Off PORTC.INT0MASK=0x00; // Pin0 Pin Change interrupt 1: Off // Pin1 Pin Change interrupt 1: Off // Pin2 Pin Change interrupt 1: Off // Pin3 Pin Change interrupt 1: Off // Pin4 Pin Change interrupt 1: Off // Pin5 Pin Change interrupt 1: Off // Pin6 Pin Change interrupt 1: Off // Pin7 Pin Change interrupt 1: Off PORTC.INT1MASK=0x00; // PORTD initialization // OUT register PORTD.OUT=0x00; // Pin0: Output // Pin1: Output // Pin2: Output // Pin3: Output // Pin4: Output // Pin5: Output // Pin6: Output // Pin7: Output PORTD.DIR=0xFF; // Pin0 Output/Pull configuration: Totempole/No // Pin0 Input/Sense configuration: Sense both edges // Pin0 Inverted: Off // Pin0 Slew Rate Limitation: On PORTD.PIN0CTRL=PORT_SRLEN_bm | PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin1 Output/Pull configuration: Totempole/No // Pin1 Input/Sense configuration: Sense both edges // Pin1 Inverted: Off // Pin1 Slew Rate Limitation: On PORTD.PIN1CTRL=PORT_SRLEN_bm | PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin2 Output/Pull configuration: Totempole/No // Pin2 Input/Sense configuration: Sense both edges // Pin2 Inverted: Off // Pin2 Slew Rate Limitation: On PORTD.PIN2CTRL=PORT_SRLEN_bm | PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin3 Output/Pull configuration: Totempole/No // Pin3 Input/Sense configuration: Sense both edges // Pin3 Inverted: Off // Pin3 Slew Rate Limitation: On PORTD.PIN3CTRL=PORT_SRLEN_bm | PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin4 Output/Pull configuration: Totempole/No // Pin4 Input/Sense configuration: Sense both edges // Pin4 Inverted: Off // Pin4 Slew Rate Limitation: On PORTD.PIN4CTRL=PORT_SRLEN_bm | PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin5 Output/Pull configuration: Totempole/No // Pin5 Input/Sense configuration: Sense both edges // Pin5 Inverted: Off // Pin5 Slew Rate Limitation: On PORTD.PIN5CTRL=PORT_SRLEN_bm | PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin6 Output/Pull configuration: Totempole/No // Pin6 Input/Sense configuration: Sense both edges // Pin6 Inverted: Off // Pin6 Slew Rate Limitation: On PORTD.PIN6CTRL=PORT_SRLEN_bm | PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin7 Output/Pull configuration: Totempole/No // Pin7 Input/Sense configuration: Sense both edges // Pin7 Inverted: Off // Pin7 Slew Rate Limitation: On PORTD.PIN7CTRL=PORT_SRLEN_bm | PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Interrupt 0 level: Disabled // Interrupt 1 level: Disabled PORTD.INTCTRL=(PORTD.INTCTRL &amp; (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) | PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc; // Pin0 Pin Change interrupt 0: Off // Pin1 Pin Change interrupt 0: Off // Pin2 Pin Change interrupt 0: Off // Pin3 Pin Change interrupt 0: Off // Pin4 Pin Change interrupt 0: Off // Pin5 Pin Change interrupt 0: Off // Pin6 Pin Change interrupt 0: Off // Pin7 Pin Change interrupt 0: Off PORTD.INT0MASK=0x00; // Pin0 Pin Change interrupt 1: Off // Pin1 Pin Change interrupt 1: Off // Pin2 Pin Change interrupt 1: Off // Pin3 Pin Change interrupt 1: Off // Pin4 Pin Change interrupt 1: Off // Pin5 Pin Change interrupt 1: Off // Pin6 Pin Change interrupt 1: Off // Pin7 Pin Change interrupt 1: Off PORTD.INT1MASK=0x00; // PORTE initialization // OUT register PORTE.OUT=0x00; // Pin0: Input // Pin1: Input // Pin2: Input // Pin3: Input // Pin4: Input // Pin5: Input // Pin6: Input // Pin7: Input PORTE.DIR=0x00; // Pin0 Output/Pull configuration: Totempole/No // Pin0 Input/Sense configuration: Sense both edges // Pin0 Inverted: Off // Pin0 Slew Rate Limitation: Off PORTE.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin1 Output/Pull configuration: Totempole/No // Pin1 Input/Sense configuration: Sense both edges // Pin1 Inverted: Off // Pin1 Slew Rate Limitation: Off PORTE.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin2 Output/Pull configuration: Totempole/No // Pin2 Input/Sense configuration: Sense both edges // Pin2 Inverted: Off // Pin2 Slew Rate Limitation: Off PORTE.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin3 Output/Pull configuration: Totempole/No // Pin3 Input/Sense configuration: Sense both edges // Pin3 Inverted: Off // Pin3 Slew Rate Limitation: Off PORTE.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin4 Output/Pull configuration: Totempole/No // Pin4 Input/Sense configuration: Sense both edges // Pin4 Inverted: Off // Pin4 Slew Rate Limitation: Off PORTE.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin5 Output/Pull configuration: Totempole/No // Pin5 Input/Sense configuration: Sense both edges // Pin5 Inverted: Off // Pin5 Slew Rate Limitation: Off PORTE.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin6 Output/Pull configuration: Totempole/No // Pin6 Input/Sense configuration: Sense both edges // Pin6 Inverted: Off // Pin6 Slew Rate Limitation: Off PORTE.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin7 Output/Pull configuration: Totempole/No // Pin7 Input/Sense configuration: Sense both edges // Pin7 Inverted: Off // Pin7 Slew Rate Limitation: Off PORTE.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Interrupt 0 level: Disabled // Interrupt 1 level: Disabled PORTE.INTCTRL=(PORTE.INTCTRL &amp; (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) | PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc; // Pin0 Pin Change interrupt 0: Off // Pin1 Pin Change interrupt 0: Off // Pin2 Pin Change interrupt 0: Off // Pin3 Pin Change interrupt 0: Off // Pin4 Pin Change interrupt 0: Off // Pin5 Pin Change interrupt 0: Off // Pin6 Pin Change interrupt 0: Off // Pin7 Pin Change interrupt 0: Off PORTE.INT0MASK=0x00; // Pin0 Pin Change interrupt 1: Off // Pin1 Pin Change interrupt 1: Off // Pin2 Pin Change interrupt 1: Off // Pin3 Pin Change interrupt 1: Off // Pin4 Pin Change interrupt 1: Off // Pin5 Pin Change interrupt 1: Off // Pin6 Pin Change interrupt 1: Off // Pin7 Pin Change interrupt 1: Off PORTE.INT1MASK=0x00; // PORTF initialization // OUT register PORTF.OUT=0x08; // Pin0: Input // Pin1: Input // Pin2: Input // Pin3: Output // Pin4: Input // Pin5: Input // Pin6: Input // Pin7: Input PORTF.DIR=0x08; // Pin0 Output/Pull configuration: Totempole/No // Pin0 Input/Sense configuration: Sense both edges // Pin0 Inverted: Off // Pin0 Slew Rate Limitation: Off PORTF.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin1 Output/Pull configuration: Totempole/No // Pin1 Input/Sense configuration: Sense both edges // Pin1 Inverted: Off // Pin1 Slew Rate Limitation: Off PORTF.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin2 Output/Pull configuration: Totempole/No // Pin2 Input/Sense configuration: Sense both edges // Pin2 Inverted: Off // Pin2 Slew Rate Limitation: Off PORTF.PIN2CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin3 Output/Pull configuration: Totempole/No // Pin3 Input/Sense configuration: Sense both edges // Pin3 Inverted: Off // Pin3 Slew Rate Limitation: Off PORTF.PIN3CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin4 Output/Pull configuration: Totempole/No // Pin4 Input/Sense configuration: Sense both edges // Pin4 Inverted: Off // Pin4 Slew Rate Limitation: Off PORTF.PIN4CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin5 Output/Pull configuration: Totempole/No // Pin5 Input/Sense configuration: Sense both edges // Pin5 Inverted: Off // Pin5 Slew Rate Limitation: Off PORTF.PIN5CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin6 Output/Pull configuration: Totempole/No // Pin6 Input/Sense configuration: Sense both edges // Pin6 Inverted: Off // Pin6 Slew Rate Limitation: Off PORTF.PIN6CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin7 Output/Pull configuration: Totempole/No // Pin7 Input/Sense configuration: Sense both edges // Pin7 Inverted: Off // Pin7 Slew Rate Limitation: Off PORTF.PIN7CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Interrupt 0 level: Disabled // Interrupt 1 level: Disabled PORTF.INTCTRL=(PORTF.INTCTRL &amp; (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) | PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc; // Pin0 Pin Change interrupt 0: Off // Pin1 Pin Change interrupt 0: Off // Pin2 Pin Change interrupt 0: Off // Pin3 Pin Change interrupt 0: Off // Pin4 Pin Change interrupt 0: Off // Pin5 Pin Change interrupt 0: Off // Pin6 Pin Change interrupt 0: Off // Pin7 Pin Change interrupt 0: Off PORTF.INT0MASK=0x00; // Pin0 Pin Change interrupt 1: Off // Pin1 Pin Change interrupt 1: Off // Pin2 Pin Change interrupt 1: Off // Pin3 Pin Change interrupt 1: Off // Pin4 Pin Change interrupt 1: Off // Pin5 Pin Change interrupt 1: Off // Pin6 Pin Change interrupt 1: Off // Pin7 Pin Change interrupt 1: Off PORTF.INT1MASK=0x00; // PORTR initialization // OUT register PORTR.OUT=0x00; // Pin0: Input // Pin1: Input PORTR.DIR=0x00; // Pin0 Output/Pull configuration: Totempole/No // Pin0 Input/Sense configuration: Sense both edges // Pin0 Inverted: Off // Pin0 Slew Rate Limitation: Off PORTR.PIN0CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Pin1 Output/Pull configuration: Totempole/No // Pin1 Input/Sense configuration: Sense both edges // Pin1 Inverted: Off // Pin1 Slew Rate Limitation: Off PORTR.PIN1CTRL=PORT_OPC_TOTEM_gc | PORT_ISC_BOTHEDGES_gc; // Interrupt 0 level: Disabled // Interrupt 1 level: Disabled PORTR.INTCTRL=(PORTR.INTCTRL &amp; (~(PORT_INT1LVL_gm | PORT_INT0LVL_gm))) | PORT_INT1LVL_OFF_gc | PORT_INT0LVL_OFF_gc; // Pin0 Pin Change interrupt 0: Off // Pin1 Pin Change interrupt 0: Off PORTR.INT0MASK=0x00; // Pin0 Pin Change interrupt 1: Off // Pin1 Pin Change interrupt 1: Off PORTR.INT1MASK=0x00; } // Virtual Ports initialization void vports_init(void) { // PORTA mapped to VPORT0 // PORTB mapped to VPORT1 PORTCFG.VPCTRLA=PORTCFG_VP13MAP_PORTB_gc | PORTCFG_VP02MAP_PORTA_gc; // PORTC mapped to VPORT2 // PORTD mapped to VPORT3 PORTCFG.VPCTRLB=PORTCFG_VP13MAP_PORTD_gc | PORTCFG_VP02MAP_PORTC_gc; } // Disable a Timer/Counter type TC0 void tc0_disable(TC0_t *ptc) { // Timer/Counter off ptc-&gt;CTRLA=TC_CLKSEL_OFF_gc; // Issue a reset command ptc-&gt;CTRLFSET=TC_CMD_RESET_gc; } // Timer/Counter TCC0 initialization void tcc0_init(void) { unsigned char s; unsigned char n; // Note: The correct PORTC direction for the Compare Channels // outputs is configured in the ports_init function. // Save interrupts enabled/disabled state s=SREG; // Disable interrupts #asm("cli") // Disable and reset the timer/counter just to be sure tc0_disable(&amp;TCC0); // Clock source: ClkPer/1 TCC0.CTRLA=TC_CLKSEL_DIV1_gc; // Mode: Normal Operation, Overflow Int./Event on TOP // Compare/Capture on channel A: Off // Compare/Capture on channel B: Off // Compare/Capture on channel C: Off // Compare/Capture on channel D: Off TCC0.CTRLB=(0&lt;&lt;TC0_CCDEN_bp) | (0&lt;&lt;TC0_CCCEN_bp) | (0&lt;&lt;TC0_CCBEN_bp) | (0&lt;&lt;TC0_CCAEN_bp) | TC_WGMODE_NORMAL_gc; // Capture event source: None // Capture event action: None TCC0.CTRLD=TC_EVACT_OFF_gc | TC_EVSEL_OFF_gc; // Set Timer/Counter in Normal mode TCC0.CTRLE=TC_BYTEM_NORMAL_gc; // Overflow interrupt: High Level // Error interrupt: Disabled TCC0.INTCTRLA=TC_ERRINTLVL_OFF_gc | TC_OVFINTLVL_HI_gc; // Compare/Capture channel A interrupt: Disabled // Compare/Capture channel B interrupt: Disabled // Compare/Capture channel C interrupt: Disabled // Compare/Capture channel D interrupt: Disabled TCC0.INTCTRLB=TC_CCDINTLVL_OFF_gc | TC_CCCINTLVL_OFF_gc | TC_CCBINTLVL_OFF_gc | TC_CCAINTLVL_OFF_gc; // High resolution extension: Off HIRESC.CTRLA&amp;= ~HIRES_HREN0_bm; // Advanced Waveform Extension initialization // Optimize for speed #pragma optsize- // Disable locking the AWEX configuration registers just to be sure n=MCU.AWEXLOCK &amp; (~MCU_AWEXCLOCK_bm); CCP=CCP_IOREG_gc; MCU.AWEXLOCK=n; // Restore optimization for size if needed #pragma optsize_default // Pattern generation: Off // Dead time insertion: Off AWEXC.CTRL=(0&lt;&lt;AWEX_PGM_bp) | (0&lt;&lt;AWEX_CWCM_bp) | (0&lt;&lt;AWEX_DTICCDEN_bp) | (0&lt;&lt;AWEX_DTICCCEN_bp) | (0&lt;&lt;AWEX_DTICCBEN_bp) | (0&lt;&lt;AWEX_DTICCAEN_bp); // Fault protection initialization // Fault detection on OCD Break detection: On // Fault detection restart mode: Latched Mode // Fault detection action: None (Fault protection disabled) AWEXC.FDCTRL=(AWEXC.FDCTRL &amp; (~(AWEX_FDDBD_bm | AWEX_FDMODE_bm | AWEX_FDACT_gm))) | (0&lt;&lt;AWEX_FDDBD_bp) | (0&lt;&lt;AWEX_FDMODE_bp) | AWEX_FDACT_NONE_gc; // Fault detect events: // Event channel 0: Off // Event channel 1: Off // Event channel 2: Off // Event channel 3: Off // Event channel 4: Off // Event channel 5: Off // Event channel 6: Off // Event channel 7: Off AWEXC.FDEMASK=0b00000000; // Make sure the fault detect flag is cleared AWEXC.STATUS|=AWEXC.STATUS &amp; AWEX_FDF_bm; // Clear the interrupt flags TCC0.INTFLAGS=TCC0.INTFLAGS; // Set Counter register TCC0.CNT=0x0000; // Set Period register TCC0.PER=0x016A;//0x01B2; // Set channel A Compare/Capture register TCC0.CCA=0x0000; // Set channel B Compare/Capture register TCC0.CCB=0x0000; // Set channel C Compare/Capture register TCC0.CCC=0x0000; // Set channel D Compare/Capture register TCC0.CCD=0x0000; // Restore interrupts enabled/disabled state SREG=s; } // USARTF0 initialization void usartf0_init(void) { // Note: The correct PORTF direction for the RxD, TxD and XCK signals // is configured in the ports_init function. // Transmitter is enabled // Set TxD=1 PORTF.OUTSET=0x08; // Communication mode: Asynchronous USART // Data bits: 8 // Stop bits: 1 // Parity: Disabled USARTF0.CTRLC=USART_CMODE_ASYNCHRONOUS_gc | USART_PMODE_DISABLED_gc | USART_CHSIZE_8BIT_gc; // Receive complete interrupt: Disabled // Transmit complete interrupt: Disabled // Data register empty interrupt: Disabled USARTF0.CTRLA=(USARTF0.CTRLA &amp; (~(USART_RXCINTLVL_gm | USART_TXCINTLVL_gm | USART_DREINTLVL_gm))) | USART_RXCINTLVL_OFF_gc | USART_TXCINTLVL_OFF_gc | USART_DREINTLVL_OFF_gc; // Required Baud rate: 2000000 // Real Baud Rate: 2000000,0 (x2 Mode), Error: 0,0 % USARTF0.BAUDCTRLA=0x00; USARTF0.BAUDCTRLB=((0x09 &lt;&lt; USART_BSCALE_gp) &amp; USART_BSCALE_gm) | 0x00; // Receiver: On // Transmitter: On // Double transmission speed mode: On // Multi-processor communication mode: Off USARTF0.CTRLB=(USARTF0.CTRLB &amp; (~(USART_RXEN_bm | USART_TXEN_bm | USART_CLK2X_bm | USART_MPCM_bm | USART_TXB8_bm))) | USART_RXEN_bm | USART_TXEN_bm | USART_CLK2X_bm; } // Receive a character from USARTF0 #pragma used+ char getchar_usartf0(void) { char data; unsigned char status; while (1) { while (((status=USARTF0.STATUS) &amp; USART_RXCIF_bm) == 0); data=USARTF0.DATA; if ((status &amp; (USART_FERR_bm | USART_PERR_bm | USART_BUFOVF_bm)) == 0) return data; } } #pragma used- // Write a character to the USARTF0 Transmitter #pragma used+ void putchar_usartf0(char c) { while ((USARTF0.STATUS &amp; USART_DREIF_bm) == 0); USARTF0.DATA=c; } #pragma used- // DACB initialization void dacb_init(void) { // Operating mode: Single Channel (Ch0) // Channel 0 triggered by the event system: Off DACB.CTRLB=(DACB.CTRLB &amp; (~(DAC_CHSEL_gm | DAC_CH0TRIG_bm | DAC_CH1TRIG_bm))) | DAC_CHSEL_SINGLE_gc; // Reference: AVcc // Left adjust value: Off DACB.CTRLC=(DACB.CTRLC &amp; (~(DAC_REFSEL_gm | DAC_LEFTADJ_bm))) | DAC_REFSEL_AVCC_gc; // DACB is enabled // Low power mode: Off // Channel 0 output: On // Channel 1 output: Off // Internal output connected to the ADCB and Analog Comparator MUX-es: Off DACB.CTRLA=(DACB.CTRLA &amp; (~(DAC_IDOEN_bm | DAC_CH0EN_bm | DAC_CH1EN_bm | DAC_LPMODE_bm))) | DAC_CH0EN_bm | DAC_ENABLE_bm; } // Function used to write data to a DACB channel ch void dacb_write(unsigned char ch, unsigned int data) { register unsigned char m=ch ? DAC_CH1DRE_bm : DAC_CH0DRE_bm; // Wait for the channel data register to be ready for new data while ((DACB.STATUS &amp; m)==0); // Write new data to the channel data register if (m==DAC_CH1DRE_bm) DACB.CH1DATA=data; else DACB.CH0DATA=data; } // Timer/counter TCC0 Overflow/Underflow interrupt service routine interrupt [TCC0_OVF_vect] void tcc0_overflow_isr(void) { //PORTD.OUT=~PORTD.OUT; if (rAdr!=wAdr) { PORTD.OUT=fifo[rAdr++]; //DACB.CH0DATA=fifo[rAdr++]&lt;&lt;4; // PORTE.OUT=0; } //else // PORTE.OUT=1; if (fSIZE==rAdr) rAdr=0; if (!needdata) { if (rAdr&lt;=wAdr) if (wAdr-rAdr&lt;6000) { putchar_usartf0(0xFF); needdata=1; } else; else if (rAdr-wAdr&gt;6000) { putchar_usartf0(0xFF); needdata=1; } } else { if (dn++&gt;2000) { putchar_usartf0(0xFF); dn=0; } } } void main(void) { // Declare your local variables here unsigned char n; // Interrupt system initialization // Optimize for speed #pragma optsize- // Make sure the interrupts are disabled #asm("cli") // Low level interrupt: Off // Round-robin scheduling for low level interrupt: Off // Medium level interrupt: Off // High level interrupt: On // The interrupt vectors will be placed at the start of the Application FLASH section n=(PMIC.CTRL &amp; (~(PMIC_RREN_bm | PMIC_IVSEL_bm | PMIC_HILVLEN_bm | PMIC_MEDLVLEN_bm | PMIC_LOLVLEN_bm))) | PMIC_HILVLEN_bm; CCP=CCP_IOREG_gc; PMIC.CTRL=n; // Set the default priority for round-robin scheduling PMIC.INTPRI=0x00; // Restore optimization for size if needed #pragma optsize_default // System clocks initialization system_clocks_init(); // Ports initialization ports_init(); // Virtual Ports initialization vports_init(); // DACB initialization dacb_init(); // Timer/Counter TCC0 initialization tcc0_init(); // USARTF0 initialization usartf0_init(); // Globally enable interrupts #asm("sei") rAdr=0; wAdr=0; PORTD.OUT=0xFF; needdata=0; while (1) { fifo[wAdr++]=getchar_usartf0(); if (fSIZE==wAdr) wAdr=0; } }</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">PC code</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Data; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Drawing; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Linq; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Windows.Forms; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Text.RegularExpressions; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Globalization; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.IO.Ports; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">bol</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">partial</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Form1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); } <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[] byData; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Form1_Shown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] ports = SerialPort.GetPortNames(); comboBox1.Items.AddRange(SerialPort.GetPortNames()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (comboBox1.Items.Count &gt; <span class="hljs-number"><span class="hljs-number">-1</span></span>) { comboBox1.SelectedIndex = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">serialPort1_DataReceived</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, SerialDataReceivedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (serialPort1.IsOpen) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (byData.Length - <span class="hljs-number"><span class="hljs-number">2000</span></span> &gt; k) { serialPort1.Write(byData, k, <span class="hljs-number"><span class="hljs-number">2000</span></span>); k += <span class="hljs-number"><span class="hljs-number">2000</span></span>; } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">button2_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, EventArgs e</span></span></span><span class="hljs-function">)</span></span> { serialPort1.Close(); button1.Enabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { serialPort1.BaudRate = Convert.ToInt32(textBox1.Text); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> { MessageBox.Show(<span class="hljs-string"><span class="hljs-string">"!!!!!!"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (openFileDialog1.ShowDialog() == System.Windows.Forms.DialogResult.OK) { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> fileNam = openFileDialog1.FileName; FileStream fs = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileStream(fileNam, FileMode.OpenOrCreate, FileAccess.Read); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len = Convert.ToInt32(fs.Length); byData = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>[len];   <span class="hljs-comment"><span class="hljs-comment">//   try {   //  ,   (  )    fs.Read(byData, 44, len - 44 - 1); fs.Dispose(); //   } catch (IOException err) { MessageBox.Show(err.Message); return; } serialPort1.Open(); k = 0; if (byData.Length - 2000 &gt; k) { serialPort1.Write(byData, k, 2000); k += 2000; } } } private void comboBox1_TextChanged(object sender, EventArgs e) { serialPort1.PortName = comboBox1.Text; } private void button3_Click(object sender, EventArgs e) { k = 0; } private void button1_Click_1(object sender, EventArgs e) { if (serialPort1.IsOpen) { serialPort1.Close(); } else serialPort1.Open(); } } }</span></span></code> </pre><br></div></div></div><p>Source: <a href="https://habr.com/ru/post/392585/">https://habr.com/ru/post/392585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../392575/index.html">32 birch sticks or rocket engine ignition systems</a></li>
<li><a href="../392577/index.html">In Mexico City, introduced a weekly "Earth Day" for cars</a></li>
<li><a href="../392579/index.html">Recently launched Russian site for registration of UAVs was unreal</a></li>
<li><a href="../392581/index.html">Popular science and venture capital at the Global Technology Symposium conference in San Francisco</a></li>
<li><a href="../392583/index.html">Mother smoking alters fetal DNA</a></li>
<li><a href="../392587/index.html">Who hides the truth about the ancestors of man?</a></li>
<li><a href="../392589/index.html">pyLCI - front end for Raspberry Pi and other Linux devices</a></li>
<li><a href="../392591/index.html">A passenger who has fallen asleep in Uber and has rolled back the extra 20 miles to ¬£ 105 has returned his money</a></li>
<li><a href="../392595/index.html">A new record: a pig's heart transplanted to a baboon has been around for over two years.</a></li>
<li><a href="../392599/index.html">Empty space is not really empty [Voice Vert Dider]</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>