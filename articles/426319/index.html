<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Test server for the development team</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! In this article I want to share the experience of deploying a test server for the development team. In short, the essence of the problem - t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Test server for the development team</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr!  In this article I want to share the experience of deploying a test server for the development team.  In short, the essence of the problem - there is a development team and several projects in php.  While we were few and the project was essentially one, then 1 test server was used and to show the task to the customer - the developer ‚Äústarted‚Äù the server for a certain time.  If there were no ‚Äúwindows‚Äù in time, then you had to wait.  Over time, the team grew and the complexity of the tasks increased, respectively, the test time and the employment of the test server increased, which negatively affected the deadlines and the bonus.  Therefore it was necessary to search for the decision and it under a cat. <br><a name="habracut"></a><br><h3>  Introductory </h3><br>  What happened: <br><br><ol><li>  One test server </li><li>  Gitlab and redmine on another server </li><li>  The desire to understand the problem </li></ol><br>  All servers are in our local network, the test server is not accessible from the outside. <br><br>  What was required: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Ability to test multiple projects / branches at the same time </li><li>  The developer can go to the server, set it up and not break anything with others. </li><li>  Everything should be as convenient as possible and do 1 button preferably from gitlab (CI / CD). </li></ol><br><h3>  Solutions </h3><br><h4>  1. One server, many hosts </h4><br>  The easiest option.  We use the same test server, only the developer needs to create a host for each branch / project and make it into the nginx / apache2 configuration. <br><br>  Pros: <br><br><ol><li>  Quick and clear to everyone </li><li>  Can automate </li></ol><br>  Minuses: <br><br><ol><li>  Clause 2 of the requirements is not fulfilled - the developer can launch the update database and, under certain circumstances, put everything (Hi Andrey!) </li><li>  Pretty complicated automation with a bunch of configuration files. </li></ol><br><h4>  2. Each developer on the server! </h4><br>  Select each server and the developer himself is responsible for their own economy. <br><br>  Pros: <br><br><ol><li>  The developer can fully customize the server for your project. </li></ol><br>  Minuses: <br><br><ol><li>  Clause 2 of the requirements is not fulfilled. </li><li>  Expensive and resources can simply stand idle while development is underway, not testing. </li><li>  Automation is even more complicated than in claim 1 due to different servers </li></ol><br><h4>  3. Containerization - docker, kubernetes </h4><br>  This technology is increasingly penetrating our lives.  At home I have been using docker for my projects for a long time. <br><blockquote>  Docker is an automation software for deploying and managing applications in a virtualization environment at the operating system level.  Allows you to "pack" the application with all its environments and dependencies in a container that can be transferred to any Linux-system with cgroups support in the kernel, and also provides a container management environment. </blockquote>  Pros: <br><br><ol><li>  One server is used </li><li>  All requirements are met. </li></ol><br>  Minuses: <br><br><ol><li>  Images and containers sometimes take up quite a lot of space, you have to crown clean already obsolete to free up space. </li></ol><br><h3>  Docker implementation </h3><br>  When using gitlab, AutoDevOps, kubernetes settings were very often seen.  Plus, bearded guys at various meetup tell how cool everything works with kubernetes.  Therefore, it was decided to try to deploy the cluster at its facilities, the server was requested (and the test can not be touched, people are testing there) and rushed! <br><br>  Since I have experience with kubernetes 0, everything has gone down on the manual with an attempt to understand how all these clusters work.  After some time, I managed to raise the cluster, but then I went to problems with certificates, keys, and indeed with the difficulty of deployment.  I needed a simpler solution to teach my colleagues to work with it (for example, I don‚Äôt want to spend the same vacation sitting on Skype and helping with the setting).  Therefore, kubernetes was left alone.  Docker itself remained and it was necessary to find a solution for container routing.  Since they could be raised on different ports, it would be possible to use the same nginx for internal redirection.  This is called a reverse proxy server. <br><blockquote>  Reverse proxy server - a type of proxy server that relays client requests from the external network to one or more servers that are logically located on the internal network.  At the same time, it looks to the client as if the requested resources are located directly on the proxy server. </blockquote><h4>  Reverse Proxy </h4><br>  In order not to reinvent the wheel, I began to look for ready-made solutions.  And it was found - this is <a href="https://traefik.io/">traefik</a> . <br><br>  Tr√¶fik is a modern HTTP reverse proxy and load balancer that simplifies the deployment of microservices.  Tr√¶fik integrates with existing infrastructure components (Docker, Swarm mode, Kubernetes, Marathon, Consul, Etcd, Rancher, Amazon ECS, ...) and is configured automatically and dynamically.  To work with docker, it is enough to specify its socket and everything, then Tr√¶fik finds all the containers and routing to them (for more details, see ‚ÄúPacking applications in docker‚Äù). <br><br><div class="spoiler">  <b class="spoiler_title">Tr√¶fik Container Configuration</b> <div class="spoiler_text">  I launch it through docker-compose.yml <br><br><pre><code class="hljs delphi">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: traefik: image: traefik:latest # The official Traefik docker image command: --api --docker # Enables the web UI <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> tells Tr√¶fik <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> listen <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> docker ports: - <span class="hljs-number"><span class="hljs-number">443</span></span>:<span class="hljs-number"><span class="hljs-number">443</span></span> - <span class="hljs-number"><span class="hljs-number">80</span></span>:<span class="hljs-number"><span class="hljs-number">80</span></span> # The HTTP port - <span class="hljs-number"><span class="hljs-number">8080</span></span>:<span class="hljs-number"><span class="hljs-number">8080</span></span> # The Web UI (enabled by --api) volumes: - /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/run/docker.sock # So that Traefik can listen <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the Docker events - /opt/traefik/traefik.toml:/traefik.toml - /opt/traefik/certs/:/certs/ networks: - proxy container_name: traefik restart: always networks: proxy: <span class="hljs-keyword"><span class="hljs-keyword">external</span></span>: true</code> </pre> <br></div></div><br>  Here we inform the proxy that you need to listen to ports 80,443 and 8080 (web proxy), we mount the docker socket, the configuration file and the folder with certificates.  For the convenience of naming test sites, we decided to make a local domain zone * .test.  When accessing any site on it, the user gets to our test server.  Therefore, the certificates in the traefik folder are self-signed, but it supports Let's Encrypt so much. <br><br>  Certificate Generation <br><br><pre> <code class="bash hljs">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout domain.key -out domain.crt</code> </pre> <br>  Before starting, you need to create a proxy network in the docker (you can call it your own way). <br><br><pre> <code class="bash hljs">docker network create proxy</code> </pre> <br>  This will be the network to link traefik with php container sites.  Therefore, we specify it in the service‚Äôs networks parameter and in the entire file in networks, by specifying the external parameter: true. <br><br><div class="spoiler">  <b class="spoiler_title">Traefik.toml file</b> <div class="spoiler_text"><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">debug</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span> logLevel = "DEBUG" defaultEntryPoints = ["https","http"] #  insecureSkipVerify = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> #   [entryPoints] [entryPoints.http] address = ":80" [entryPoints.https] address = ":443" [entryPoints.https.tls] [docker] endpoint = "unix:///var/run/docker.sock" <span class="hljs-keyword"><span class="hljs-keyword">domain</span></span> = "docker.localhost" watch = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> exposedbydefault = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span></code> </pre> <br></div></div><br>  It's all quite simple - we specify the http and https traffic entry points, do not forget to set insecureSkipVerify = true if the certificates are local.  In the entryPoints.https.tls section, you can omit certificates, then traefik will substitute its certificate. <br><br>  You can start the service <br><br><pre> <code class="bash hljs">docker-compose up -d</code> </pre> <br>  If you go to the <a href="https://site.test/">site.test</a> address, you will get an error 404, since this domain is not tied to any container. <br><br><h4>  We pack applications in docker </h4><br>  Now you need to configure the container with the application, namely: <br><br>  1. specify the network proxy network <br>  2. add labels with traefik configuration <br><br>  The following is the configuration of one of the applications. <br><br><div class="spoiler">  <b class="spoiler_title">docker-compose.yml applications</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">version: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: app: build: <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/docker/php #   restart: always working_dir: /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span> volumes: - ./:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html #    - /home/develop/site-files/f:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/html/<span class="hljs-keyword"><span class="hljs-keyword">public</span></span>/f #       links: - mailcatcher - memcached - mysql labels: - traefik.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - traefik.frontend.rule=Host:TEST_DOMAIN,crm.TEST_DOMAIN,bonus.TEST_DOMAIN - traefik.docker.network=proxy - traefik.port=<span class="hljs-number"><span class="hljs-number">443</span></span> - traefik.protocol=https networks: - proxy - <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> mailcatcher: image: schickling/mailcatcher:latest restart: always memcached: image: memcached restart: always mysql: image: mysql:<span class="hljs-number"><span class="hljs-number">5.7</span></span> restart: always command: --max_allowed_packet=<span class="hljs-number"><span class="hljs-number">902505856</span></span> --sql-mode=<span class="hljs-string"><span class="hljs-string">""</span></span> environment: MYSQL_ROOT_PASSWORD: <span class="hljs-number"><span class="hljs-number">12345</span></span> MYSQL_DATABASE: site volumes: - ./<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>/cache/mysql-db:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/mysql #      phpmyadmin: image: phpmyadmin/phpmyadmin restart: always links: - mysql environment: MYSQL_USERNAME: root MYSQL_ROOT_PASSWORD: <span class="hljs-number"><span class="hljs-number">12345</span></span> PMA_ARBITRARY: <span class="hljs-number"><span class="hljs-number">1</span></span> PMA_HOST: mysql_1 labels: - traefik.enabled=<span class="hljs-literal"><span class="hljs-literal">true</span></span> - traefik.frontend.rule=Host:pma.TEST_DOMAIN - traefik.docker.network=proxy - traefik.port=<span class="hljs-number"><span class="hljs-number">80</span></span> - traefik.<span class="hljs-keyword"><span class="hljs-keyword">default</span></span>.protocol=http networks: - proxy - <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> networks: proxy: <span class="hljs-keyword"><span class="hljs-keyword">external</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre><br></div></div><br>  In the app service, in the network section, you need to specify proxy and default, which means that it will be available in two networks, as you can see from the configuration, I do not forward ports to the outside, everything goes inside the network. <br><br>  Next, configure the labels <br><br><pre> <code class="hljs 1c"> - traefik.enabled=true <span class="hljs-meta"><span class="hljs-meta"># traefik </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">   - traefik.frontend.rule=Host:TEST_DOMAIN,crm.TEST_DOMAIN,bonus.TEST_DOMAIN #  </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  traefik     - traefik.docker.network=proxy # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">  - traefik.port=443 #, </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword"></span></span></span><span class="hljs-meta">    ssl   80   http - traefik.protocol=https #  #  phpmyadmin   http </span></span></code> </pre><br>  In the general section of networks, you need to specify external: true <br><br>  The constant TEST_DOMAIN needs to be replaced with a domain, for example, site.test <br><br>  Run the application <br><br><pre> <code class="bash hljs">docker-compose up -d</code> </pre> <br>  Now if you go to the domains site.test, crm.site.test, bonus.site.test you can see the working site.  And on the domain pma.site.test will be phpmyadmin for convenient work with the database. <br><br><h4>  GitLab Setup </h4><br>  Create a task handler, for this run <br><br><pre> <code class="bash hljs">gitlab-runner register</code> </pre> <br>  Specify url gitlab, token and through which the task will be executed (executors).  Since my test and gitlab are on different servers, I choose ssh executor.  You will need to specify the server address and login / password to connect via ssh. <br><br>  Runner can be attached to one or more projects.  Since my work logic is the same everywhere, so a shared runner was created (common for all projects). <br>  And the final touch is to create a CI configuration file. <br><br><div class="spoiler">  <b class="spoiler_title">.gitlab-ci.yml</b> <div class="spoiler_text"><pre> <code class="hljs smalltalk">stages: - build - clear #  develop build_develop: stage: build #   build tags: #     - ssh-develop environment: # ,       -   name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME #  url: https://site<span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID.test <span class="hljs-symbol"><span class="hljs-symbol">#url</span></span>     on_stop: clear when: manual script: - cd ../ &amp;&amp; cp -r <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PROJECT_NAME <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID #     - cp -r /home/develop/site-files/.ssh data/docker/php/.ssh #  ssh - sed -i -e <span class="hljs-comment"><span class="hljs-comment">"s/TEST_DOMAIN/site$CI_PIPELINE_ID.test/g"</span></span> docker-compose.yml #   - docker-compose down #   - docker-compose up -d --build #  - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar install --prefer-dist \<span class="hljs-comment"><span class="hljs-comment">""</span></span> #   - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar first-install <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID\<span class="hljs-comment"><span class="hljs-comment">""</span></span> #     #  production build_prod: stage: build tags: - ssh-develop environment: name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME url: https://site<span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID.test on_stop: clear when: manual script: - cd ../ &amp;&amp; cp -r <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PROJECT_NAME <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID - cp -r /home/develop/site-files/.ssh data/docker/php/.ssh #  ssh - docker-compose down - docker-compose up -d --build - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar install --prefer-dist --no-dev\<span class="hljs-comment"><span class="hljs-comment">""</span></span> - script -q -c <span class="hljs-comment"><span class="hljs-comment">"docker exec -it ${CI_PIPELINE_ID}_app_1 bash -c \"</span></span>cd ../ &amp;&amp; php composer.phar first-install <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID\<span class="hljs-comment"><span class="hljs-comment">""</span></span> clear: stage: clear tags: - ssh-develop environment: name: review/<span class="hljs-string"><span class="hljs-string">$C</span></span>I_BUILD_REF_NAME action: stop script: - cd ../ &amp;&amp; cd <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID &amp;&amp; docker-compose down &amp;&amp; cd ../ &amp;&amp; echo password | sudo -<span class="hljs-type"><span class="hljs-type">S</span></span> rm -rf <span class="hljs-string"><span class="hljs-string">$C</span></span>I_PIPELINE_ID #       when: manual</code> </pre><br></div></div><br>  This configuration describes 2 stages - build and clear.  The build phase has 2 execution options - build_develop and build_prod <br><br><img src="https://habrastorage.org/webt/yz/ut/dy/yzutdyyknwjgwbcg4-kj2ssv-f8.png"><br><br>  Gitlab builds a clear process flow diagram.  In my example, all processes are started manually (when: manual parameter).  This is done so that the developer, after deploying the test site, can pull his edits into the container without rebuilding the entire container.  Another reason is the domain name - site $ CI_PIPELINE_ID.test, where CI_PIPELINE_ID is the number of the process that launched the build.  That is, we gave the site with the site123.test domain for review and in order to make hot edits, changes to the container by the developer are immediately uploaded. <br><br>  A small feature of the ssh executor.  When you connect to the server, a view folder is created. <br><br><pre> <code class="bash hljs">/home//builds/_runner/0/_/_</code> </pre> <br>  Therefore, the line was added <br><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../ &amp;&amp; cp -r <span class="hljs-variable"><span class="hljs-variable">$CI_PROJECT_NAME</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_PIPELINE_ID</span></span> &amp;&amp; <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-variable"><span class="hljs-variable">$CI_PIPELINE_ID</span></span></code> </pre> <br>  In it, we go up to the folder above and copy the project to the folder with the process number.  So you can deploy multiple branches of one project.  But in the settings of the handler you need to check Lock to current projects, so the handler will not try to deploy several branches at the same time. <br><br>  The clear phase stops the containers and deletes the folder, you may need root privileges, so use the echo password |  sudo -S rm, where password is your password. <br><br><h4>  Garbage collection </h4><br>  From time to time, it is necessary to remove unused containers in order not to take up space; for this, a script with such content is hanging in the crown <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #   : docker ps --filter status=dead --filter status=exited -aq | xargs -r docker rm -v #   : yes | docker container prune #    : yes | docker image prune #    : yes | docker volume prune</span></span></code> </pre> <br>  performed once a day. <br><br><h3>  Conclusion </h3><br>  This solution helped us significantly optimize testing and the release of new features.  Ready to answer questions, constructive criticism is accepted. <br><br><h3>  Bonus </h3><br>  In order not to collect images from the Dockerfile each time, you can store them in the local docker registry. <br><br><div class="spoiler">  <b class="spoiler_title">Docker-compose.yml file</b> <div class="spoiler_text"><pre> <code class="hljs cs">registry: restart: always image: registry:<span class="hljs-number"><span class="hljs-number">2</span></span> ports: - <span class="hljs-number"><span class="hljs-number">5000</span></span>:<span class="hljs-number"><span class="hljs-number">5000</span></span> volumes: - /opt/docker-registry/data:/<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/lib/registry <span class="hljs-meta"><span class="hljs-meta">#    </span></span></code> </pre><br></div></div><br>  In this embodiment, authentication is not used, it is not a secure method (!!!), but it is suitable for storing non-critical images. <br><br>  You can configure gitlab to view <br><br><pre> <code class="bash hljs"> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_enabled'</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_host'</span></span>] = <span class="hljs-string"><span class="hljs-string">"registry.test"</span></span> gitlab_rails[<span class="hljs-string"><span class="hljs-string">'registry_port'</span></span>] = <span class="hljs-string"><span class="hljs-string">"5000"</span></span></code> </pre><br>  After that, a list of images appears in gitlab. <br><br><img src="https://habrastorage.org/webt/lu/hn/8i/luhn8ilow44doqm5btrtafgv-hq.png"></div><p>Source: <a href="https://habr.com/ru/post/426319/">https://habr.com/ru/post/426319/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426305/index.html">Work with character statuses. Unity Experiments</a></li>
<li><a href="../426311/index.html">Conference BLACK HAT USA. A botnet of a million browsers. Part 2</a></li>
<li><a href="../426313/index.html">New Microsoft Learn</a></li>
<li><a href="../426315/index.html">How to make friends python with the Invisible Internet? Basics of developing I2P applications in Python and asyncio</a></li>
<li><a href="../426317/index.html">1155 vs 2011. Only old people go to battle</a></li>
<li><a href="../426323/index.html">Attempt to manufacture the case for the robot with a limited budget. Glass Mat and Epoxy</a></li>
<li><a href="../426325/index.html">MIT course "Computer Systems Security". Lecture 12: "Network Security", part 1</a></li>
<li><a href="../426327/index.html">What's new in Windows 10 October 2018 Update</a></li>
<li><a href="../426331/index.html">Vulnerability in PlayStation 4 - the character set in the message for the user remotely turns the console into almost a "brick"</a></li>
<li><a href="../426333/index.html">Microsoft released MS-DOS code 1.25 and 2.0 under the MIT license</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>