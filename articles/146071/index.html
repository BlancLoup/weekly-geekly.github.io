<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The simplest WDM driver</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This article describes the process of writing the simplest driver that displays the scan codes of keystrokes. 
 This article also describes the proces...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The simplest WDM driver</h1><div class="post__text post__text-html js-mediator-article">  This article describes the process of writing the simplest driver that displays the scan codes of keystrokes. <br>  This article also describes the process of setting up a workplace for writing drivers. <br>  If you are interested, please under the cat. <br><a name="habracut"></a><br><br><h4>  Stand preparation </h4><br><h5>  Install the necessary software for writing the simplest driver </h5><br>  Required software: <br><ol><li>  Windows DDK (Driver Development Kit); </li><li>  VMware Workstation or Virtual Box; </li><li>  Windows XP; </li><li>  Visual Studio 2005; </li><li>  DDKWizard; </li><li>  KmdManager </li><li>  DebugView; </li></ol><br>  I use two virtual machines, I write drivers on one, and I launch on another.  If you also decide to do this for the machine on which you will run the drivers, 4 GB hard disk and 256 MB of RAM will suffice. <br><br><h5>  Setting up the workplace </h5><br><h6>  DDK installation </h6><br>  Installation is extremely simple.  The only thing you need to pay attention to is a dialogue in which you are invited to choose the components to be installed.  I strongly recommend noting all the documentation and examples. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  Installing and configuring Microsoft¬Æ Visual Studio 2005 </h6><br>  Installing Microsoft¬Æ Visual Studio 2005 is no more difficult than installing the DDK.  If you use it only for writing drivers, then when the installer asks which components to install, select only Visual C ++. <br>  Next, you can install Visual Assist X. With this program (add-on), you can easily configure hints for writing drivers conveniently. <br>  After installing Visual Assist X in Visual Studio 2005, a new VAssistX menu will appear.  Further in this menu: <code>Visual Assist X Options -&gt; Projects -&gt; C/C++ Directories -&gt; Platform: Custom, Show Directories for: Stable include files</code> .  Click <code>Ins</code> or on the icon to add a new directory and in the appeared line, if you have Windows XP enter <code>%WXPBASE%\inc\ddk\wxp</code> . <br><br><h6>  Install and configure DDKWizard </h6><br>  In order for you to compile drivers in Visual Studio, you need to install DDKWizard.  It can be downloaded from <a href="http://ddkwizard.assarbad.net/">ddkwizard.assarbad.net</a> .  Also from this site download the ddkbuild.cmd script. <br>  After the wizard is installed, you must perform the following steps: <br><ul><li>  Create system (recommended) or user variables with the following names and value that corresponds to the path to the DDK <br><table><tbody><tr><th>  DDK version <br></th><th>  Variable name <br></th><th>  Default path <br></th></tr><tr><td>  Windows XP DDK <br></td><td>  WXPBASE <br></td><td>  C: \ WINDDK \ 2600 <br></td></tr><tr><td>  Windows 2003 Server DDK <br></td><td>  WNETBASE <br></td><td>  C: \ WINDDK \ 3790.1830 <br></td></tr><tr><td>  Windows Vista / Windows 2008 Server WDK <br></td><td>  WLHBASE <br></td><td></td></tr><tr><td>  Windows 7 / Windows 2008 Server R2 WDK <br></td><td>  W7BASE <br></td><td></td></tr></tbody></table><br>  For example, if I use Windows XP DDK, then I have to create a WXPBASE variable with a value that corresponds to the path to the DDK.  Since I did not change the installation path, the value I will have is C: \ WINDDK \ 2600. <br></li><li>  Copy the downloaded ddkbuild.cmd script, for example, to the folder with the DDK.  I have this C: \ WINDDK \. <br></li><li>  Add the path to the ddkbuild.cmd script to the end of the Path system variable. <br></li></ul><br>  Everything, the car on which we will start drivers, is ready. <br><br><h5>  Install the necessary software to run the drivers </h5><br>  Now we will configure the machine on which we will run the written drivers. <br>  We will need the following programs: <br><ul><li>  DebugView ( <a href="">link</a> ) is a utility that allows you to view debug output from both user mode and kernel mode. <br></li><li>  KmdManager ( <a href="">link</a> ) - utility for dynamic loading / unloading of drivers <br></li></ul><br>  Everything, the car is ready to start drivers. <br><br><h4>  Formulation of the problem </h4><br>  The task: to write a driver that will display scan codes of keystrokes and their combinations in debug. <br><br><h5>  A bit of theory </h5><br>  A driver is a set of functions that are called by the operating system upon the occurrence of certain events coming from the device or user mode. <br>  There are many types of drivers, some of them are listed below: <br><ul><li>  class drivers; </li><li>  minidrivers; </li><li>  functional drivers; </li><li>  filter drivers. </li></ul><br>  Class drivers are drivers that Microsoft writes.  These are common drivers for a certain class of (really!) Devices. <br>  Minidrivers are drivers that use a class driver to control a device. <br>  Functional drivers are drivers that work independently and determine everything related to the device. <br>  Filter drivers are drivers that are used to monitor or change the logic of another driver by changing the data that goes to it. <br><br>  It is not necessary to define all the functions in your driver, but it must contain <code>DriverEntry</code> and <code>AddDevice</code> . <br><br>  <code>IRP</code> is a structure that drivers use to exchange data. <br><br>  So, in order to display scan codes ( <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25B0%25D0%25BD-%25D0%25BA%25D0%25BE%25D0%25B4">what is this?</a> ) In debug, we will use a filter driver. <br>  There are two types of filter drivers: <br><ul><li>  top filter drivers; <br></li><li>  lower filter drivers. <br></li></ul><br>  What type your driver belongs to depends on where the driver is in the device driver stack.  If your driver is above the functional driver, then it is called the upper filter driver, if lower, then the lower filter driver. <br><br><h6>  Differences between upper and lower filter drivers </h6><br>  All requests pass through the upper filter drivers, which means that they can change and / or filter information going to the functional driver, and then, perhaps, to the device. <br>  An example of using top filter drivers: <br>  A filter-hook driver, which sets its own hook function for the IpFilterDirver system driver, to monitor and filter traffic.  Such drivers are used in firewalls. <br><br>  Fewer requests pass through the lower filtering drivers because most requests execute and terminate a functional driver. <br><br><h6>  Sync issues </h6><br>  In the driver, which we will write, there are several "problem" sections.  For our driver it is quite enough to use assembly inserts: <br><br><pre> <code class="cpp hljs">__asm { lock dec ¬´,     ¬ª }</code> </pre><br>  or <br><pre> <code class="cpp hljs">__asm { lock inc ¬´,     ¬ª }</code> </pre><br>  The <code>lock</code> prefix allows you to safely execute the command following it.  It blocks the remaining processors while the command is executed. <br><br><h4>  Action </h4><br>  First you need to include the header files "ntddk.h", "ntddkbd.h" <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntddk.h"</span></span></span><span class="hljs-meta"> } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntddkbd.h"</span></span></span></span></code> </pre><br>  It is also necessary to describe the structure <code>DEVICE_EXTENSION</code> <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> _</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DEVICE_EXTENSION</span></span></span><span class="hljs-class">{</span></span> PDEVICE_OBJECT pLowerDO; } DEVICE_EXTENSION, *PDEVICE_EXTENSION;</code> </pre><br>  The <code>pLowerDO</code> object is a device object that is below us on the stack.  We need it in order to know who else to send IRP packets to. <br>  Even for the operation of our driver, we need a variable in which the number of not completed requests will be stored. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> gnRequests;</code> </pre><br>  Let's start with the function that is the main entry point of our driver. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DriverEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IN PDRIVER_OBJECT theDriverObject, IN PUNICODE_STRING ustrRegistryPath)</span></span></span></span></code> </pre><br>  <code>theDriverObject</code> is a driver object that contains pointers to all functions necessary for the operating system, which we will need to initialize. <br>  <code>ustrRegistryPath</code> is the name of the section in the registry where information about this driver is stored. <br>  First you need to declare and reset the variables: <br><pre> <code class="cpp hljs">gnRequests = <span class="hljs-number"><span class="hljs-number">0</span></span>; NTSTATUS status = {<span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre><br>  Further, as I wrote above, it is necessary to initialize function pointers <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;IRP_MJ_MAXIMUM_FUNCTION; ++i) { theDriverObject-&gt;MajorFunction[i] = DispatchThru; } theDriverObject-&gt;MajorFunction[IRP_MJ_READ] = DispatchRead; theDriverObject-&gt;DriverUnload = DriverUnload;</code> </pre><br>  The <code>DispatchRead</code> function will handle read requests.  It will be called when the keyboard key is pressed or released. <br>  The <code>DriverUnload</code> function <code>DriverUnload</code> called when the driver is no longer needed and can be unloaded from memory, or when the user unloads the driver.  In this function, ‚Äústripping‚Äù should be performed, i.e.  the resources used by the driver are released, all pending requests are completed, etc. <br>  The <code>DispatchThru</code> function is a stub function.  All it does is transfer the IRP packet to the next driver (the driver that is under our stack, i.e. <code>pLowerDO</code> from <code>DEVICE_EXTENSION</code> ). <br>  Next, we call our function to create and install our device to the device stack: <br><pre> <code class="cpp hljs">status = InstallFilter(theDriverObject);</code> </pre><br>  I will describe this function below. <br>  Returning <code>status</code> , in which, if the <code>InstallFilter</code> function was <code>InstallFilter</code> , the value <code>STATUS_SUCCESS</code> is stored. <br>  Moving on to the <code>InstallFilter</code> function.  Here is its prototype: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstallFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IN PDRIVER_OBJECT theDO)</span></span></span></span>;</code> </pre><br>  This function creates a device object, sets it up and puts it on the stack of devices on top of <code>\\Device\\KeyboardClass0</code> <br><br>  We declare variables: <br><pre> <code class="cpp hljs">PDEVICE_OBJECT pKeyboardDevice; NTSTATUS status = {<span class="hljs-number"><span class="hljs-number">0</span></span>};</code> </pre><br>  <code>pKeyboardDevice</code> is the device object we need to create. <br>  Call <code>IoCreateDevice</code> to create a new device. <br><pre> <code class="cpp hljs">status = IoCreateDevice(theDO, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(DEVICE_EXTENSION), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, FILE_DEVICE_KEYBOARD, <span class="hljs-number"><span class="hljs-number">0</span></span>, FALSE, &amp;pKeyboardDevice);</code> </pre><br>  Let us consider the parameters in more detail: <br><ul><li>  The first argument is the driver object, which we received as a parameter to the InstallFilter function.  It is transferred to IoCreateDevice in order to establish a connection between our driver and the new device. <br></li><li>  The third parameter is the device name. <br></li><li>  The fourth parameter is the device type. <br></li><li>  The fifth parameter is flags, which are usually set for storage devices. <br></li><li>  The sixth parameter describes whether it is possible to open more than one device handles.  If FALSE can only open one manipulator.  Otherwise, you can open any number of manipulators. <br></li><li>  The seventh parameter is the memory in which the created device object will be stored. <br></li></ul><br>  Next, set the device flags. <br><pre> <code class="cpp hljs">pKeyboardDevice-&gt;Flags = pKeyboardDevice-&gt;Flags | (DO_BUFFERED_IO | DO_POWER_PAGABLE); pKeyboardDevice-&gt;Flags = pKeyboardDevice-&gt;Flags &amp; ~DO_DEVICE_INITIALIZING;</code> </pre><br>  The flags that we set for our device must be equivalent to the flags of the device over which we turn on the stack. <br>  Next we have to perform the transformation of the name of the device that we include in the stack. <br><pre> <code class="cpp hljs">CCHAR cName[<span class="hljs-number"><span class="hljs-number">40</span></span>] = <span class="hljs-string"><span class="hljs-string">"\\Device\\KeyboardClass0"</span></span>; STRING strName; UNICODE_STRING ustrDeviceName; RtlInitAnsiString(&amp;strName, cName); RtlAnsiStringToUnicodeString(&amp;ustrDeviceName, &amp;strName, TRUE);</code> </pre><br>  The <code>IoAttachDevice</code> function injects our device onto the stack.  The object of the next (lower) device will be stored in <code>pdx-&gt;pLowerDO</code> . <br><pre> <code class="cpp hljs">IoAttachDevice(pKeyboardDevice, &amp;ustrDeviceName, &amp;pdx-&gt;pLowerDO);</code> </pre><br>  Free up resources: <br><pre> <code class="cpp hljs">RtlFreeUnicodeString(&amp;ustrDeviceName);</code> </pre><br>  Next we analyze the function <code>DispatchRead</code> with the prototype: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DispatchRead</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IN PDEVICE_OBJECT pDeviceObject, IN PIRP pIrp)</span></span></span></span>;</code> </pre><br>  This function will be called by the operating system when you press or release a keyboard key. <br>  Increase the count of incomplete requests <br><pre> <code class="cpp hljs">__asm { lock inc gnRequests }</code> </pre><br>  Before passing the request to the next driver, we must configure the stack pointer for the driver.  <code>IoCopyCurrentIrpStackLocationToNext</code> copies the memory location that belongs to the current driver to the memory area of ‚Äã‚Äãthe next driver. <br><pre> <code class="cpp hljs">IoCopyCurrentIrpStackLocationToNext(theIrp);</code> </pre>  When a request goes down the stack, it still does not have the data we need, so we need to specify a function that will be called when the request goes up the stack with the data we need. <br><pre> <code class="cpp hljs">IoSetCompletionRoutine(theIrp, ReadCompletionRoutine, pDeviceObject, TRUE, TRUE, TRUE)</code> </pre><br>  where <code>ReadCompletionRoutine</code> our function. <br>  Pass the <code>IRP</code> following driver: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IoCallDriver(((PDEVICE_EXTENSION) pDeviceObject-&gt;DeviceExtension)-&gt;pLowerDO ,theIrp);</code> </pre><br>  Now we will analyze the function that will be called every time the <code>IRP</code> completed.  Prototype: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">NTSTATUS </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCompletionRoutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IN PDEVICE_OBJECT pDeviceObject, IN PIRP theIrp, IN PVOID Context)</span></span></span></span>;</code> </pre><br>  <code>DEVICE_EXTENSION</code> : <br><pre> <code class="cpp hljs">PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)pDeviceObject-&gt;DeviceExtension;</code> </pre><br>  The <code>PKEYBOARD_INPUT_DATA</code> structure <code>PKEYBOARD_INPUT_DATA</code> used to describe the key pressed. <br><pre> <code class="cpp hljs">PKEYBOARD_INPUT_DATA kidData;</code> </pre><br>  Check if the request is successfully completed or not. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (NT_SUCCESS(theIrp-&gt;IoStatus.Status))</code> </pre><br>  To get the <code>KEYBOARD_INPUT_DATA</code> structure, you need to refer to the system <code>IRP</code> packet buffer. <br><pre> <code class="cpp hljs">kidData = (PKEYBOARD_INPUT_DATA)theIrp-&gt;AssociatedIrp.SystemBuffer;</code> </pre><br>  Find out the number of keys <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = theIrp-&gt;IoStatus.Information / <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(KEYBOARD_INPUT_DATA);</code> </pre><br>  And display each key: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;n; ++i) DbgPrint(<span class="hljs-string"><span class="hljs-string">"Code: %x\n"</span></span>, kidData[i].MakeCode);</code> </pre><br>  And do not forget to reduce the number of requests not processed <br><pre> <code class="cpp hljs">__asm { lock dec gnRequests }</code> </pre><br>  We return the status of the request <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> theIrp-&gt;IoStatus.Status;</code> </pre><br>  Let us analyze the completion function.  Prototype: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">VOID </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DriverUnload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IN PDRIVER_OBJECT theDO)</span></span></span></span>;</code> </pre><br>  <code>DEVICE_EXTENSION</code> : <br><pre> <code class="cpp hljs">PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)theDO-&gt;DeviceObject-&gt;DeviceExtension;</code> </pre><br>  Removing the device from the stack: <br><pre> <code class="cpp hljs">IoDetachDevice(pdx-&gt;pLowerDO);</code> </pre><br>  Remove the device: <br><pre> <code class="cpp hljs">IoDeleteDevice(theDO-&gt;DeviceObject);</code> </pre><br>  We check there are incomplete requests or not.  If we unload the driver without this check, the first time the key is pressed after unloading will be the BSOD. <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (gnRequests != <span class="hljs-number"><span class="hljs-number">0</span></span>) { KTIMER ktTimer; LARGE_INTEGER liTimeout; liTimeout.QuadPart = <span class="hljs-number"><span class="hljs-number">1000000</span></span>; KeInitializeTimer(&amp;ktTimer);        ,   <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(gnRequests &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { KeSetTimer(&amp;ktTimer, liTimeout, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   KeWaitForSingleObject(&amp;ktTimer, Executive, KernelMode, FALSE, NULL); //     } }</span></span></code> </pre><br>  Driver Code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntddk.h"</span></span></span><span class="hljs-meta"> } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"ntddkbd.h"</span></span></span><span class="hljs-meta"> typedef struct _DEVICE_EXTENSION{ PDEVICE_OBJECT pLowerDO; } DEVICE_EXTENSION, *PDEVICE_EXTENSION; int gnRequests; NTSTATUS DispatchThru(PDEVICE_OBJECT theDeviceObject, PIRP theIrp) { IoSkipCurrentIrpStackLocation(theIrp); return IoCallDriver(((PDEVICE_EXTENSION) theDeviceObject-&gt;DeviceExtension)-&gt;pLowerDO ,theIrp); } NTSTATUS InstallFilter(IN PDRIVER_OBJECT theDO) { PDEVICE_OBJECT pKeyboardDevice; NTSTATUS status = {0}; status = IoCreateDevice(theDO, sizeof(DEVICE_EXTENSION), NULL, FILE_DEVICE_KEYBOARD, 0, FALSE, &amp;pKeyboardDevice); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!NT_SUCCESS(status)) { DbgPrint(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"IoCreateDevice error.."</span></span></span><span class="hljs-meta">); return status; } pKeyboardDevice-&gt;Flags = pKeyboardDevice-&gt;Flags | (DO_BUFFERED_IO | DO_POWER_PAGABLE); pKeyboardDevice-&gt;Flags = pKeyboardDevice-&gt;Flags &amp; ~DO_DEVICE_INITIALIZING; RtlZeroMemory(pKeyboardDevice-&gt;DeviceExtension, sizeof(DEVICE_EXTENSION)); PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)pKeyboardDevice-&gt;DeviceExtension; CCHAR cName[40] = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\\Device\\KeyboardClass0"</span></span></span><span class="hljs-meta">; STRING strName; UNICODE_STRING ustrDeviceName; RtlInitAnsiString(&amp;strName, cName); RtlAnsiStringToUnicodeString(&amp;ustrDeviceName, &amp;strName, TRUE); IoAttachDevice(pKeyboardDevice, &amp;ustrDeviceName, &amp;pdx-&gt;pLowerDO); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//DbgPrint("After IoAttachDevice"); RtlFreeUnicodeString(&amp;ustrDeviceName); return status; } VOID DriverUnload(IN PDRIVER_OBJECT theDO) { PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)theDO-&gt;DeviceObject-&gt;DeviceExtension; IoDetachDevice(pdx-&gt;pLowerDO); IoDeleteDevice(theDO-&gt;DeviceObject); if (gnRequests != 0) { KTIMER ktTimer; LARGE_INTEGER liTimeout; liTimeout.QuadPart = 1000000; KeInitializeTimer(&amp;ktTimer); while(gnRequests &gt; 0) { KeSetTimer(&amp;ktTimer, liTimeout, NULL); KeWaitForSingleObject(&amp;ktTimer, Executive, KernelMode, FALSE, NULL); } } } NTSTATUS ReadCompletionRoutine(IN PDEVICE_OBJECT pDeviceObject, IN PIRP theIrp, IN PVOID Context) { PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)pDeviceObject-&gt;DeviceExtension; PKEYBOARD_INPUT_DATA kidData; if (NT_SUCCESS(theIrp-&gt;IoStatus.Status)) { kidData = (PKEYBOARD_INPUT_DATA)theIrp-&gt;AssociatedIrp.SystemBuffer; int n = theIrp-&gt;IoStatus.Information / sizeof(KEYBOARD_INPUT_DATA); for(int i = 0; i&lt;n; ++i) { DbgPrint("Code: %x\n", kidData[i].MakeCode); } } if(theIrp-&gt;PendingReturned) IoMarkIrpPending(theIrp); __asm{ lock dec gnRequests } return theIrp-&gt;IoStatus.Status; } NTSTATUS DispatchRead(IN PDEVICE_OBJECT pDeviceObject, IN PIRP theIrp) { __asm{ lock inc gnRequests } IoCopyCurrentIrpStackLocationToNext(theIrp); IoSetCompletionRoutine(theIrp, ReadCompletionRoutine, pDeviceObject, TRUE, TRUE, TRUE); return IoCallDriver(((PDEVICE_EXTENSION) pDeviceObject-&gt;DeviceExtension)-&gt;pLowerDO ,theIrp); } extern "C" NTSTATUS DriverEntry(IN PDRIVER_OBJECT theDriverObject, IN PUNICODE_STRING RegistryPath) { NTSTATUS status = {0}; gnRequests = 0; for (int i = 0; i&lt;IRP_MJ_MAXIMUM_FUNCTION; ++i) { theDriverObject-&gt;MajorFunction[i] = DispatchThru; } theDriverObject-&gt;MajorFunction[IRP_MJ_READ] = DispatchRead; status = InstallFilter(theDriverObject); theDriverObject-&gt;DriverUnload = DriverUnload; return status; }</span></span></span></span></code> </pre><br><br>  MAKEFILE: <br><pre> <code class="hljs vhdl"># # DO <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> EDIT THIS <span class="hljs-keyword"><span class="hljs-keyword">FILE</span></span>!!! Edit .\sources. <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you want <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> add a <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> source # <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> this <span class="hljs-keyword"><span class="hljs-keyword">component</span></span>. This <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> merely indirects <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> the real make <span class="hljs-keyword"><span class="hljs-keyword">file</span></span> # that <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">shared</span></span> by <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> the driver components <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the Windows NT DDK # !INCLUDE $(NTMAKEENV)\makefile.def</code> </pre><br>  SOURCES: <br><pre> <code class="hljs">TARGETNAME=sysfile TARGETPATH=BIN TARGETTYPE=DRIVER SOURCES = DriverMain.cpp</code> </pre><br><h5>  How to run the driver and view debug information </h5><br>  To run the driver, I used the KmdManager utility.  To view debug information, the DbgView utility was used. <br><br>  PS I wrote the article a long time ago, when I was still in my third year, now I don‚Äôt remember almost anything.  But if you have questions, I will try to answer. <br>  PPS Please pay attention to the comments, in particular to <a href="http://habrahabr.ru/post/146071/">this</a> <br><br>  <b>UPD:</b> Project on GitHub: <a href="https://github.com/pbespechnyi/simple-wdm-driver">https://github.com/pbespechnyi/simple-wdm-driver</a> </div><p>Source: <a href="https://habr.com/ru/post/146071/">https://habr.com/ru/post/146071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../146065/index.html">Some thoughts on Metro in the desktop</a></li>
<li><a href="../146066/index.html">Simple architecture of strong artificial intelligence</a></li>
<li><a href="../146067/index.html">Pygame player</a></li>
<li><a href="../146068/index.html">Password Generator / Validator for LinkedIn Hacking</a></li>
<li><a href="../146070/index.html">Are you annoyed by the permanent ‚ÄúAccess to publication closed‚Äù?</a></li>
<li><a href="../146074/index.html">Basic principles of working with the Catalyst MVC Framework</a></li>
<li><a href="../146076/index.html">Inferno Part 0: namespaces</a></li>
<li><a href="../146077/index.html">Formation of high-level signs using a large-scale learning experiment without a teacher</a></li>
<li><a href="../146078/index.html">What are the most promising new gTLDs?</a></li>
<li><a href="../146079/index.html">Myself DynDNS or Managed DNS implementation via PowerShell</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>