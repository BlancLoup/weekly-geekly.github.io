<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a virtual file system in c ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Another of my records from the sandbox, if you have time, I will translate the remaining parts 

 This is a translation of the first part of an articl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a virtual file system in c ++</h1><div class="post__text post__text-html js-mediator-article">  Another of my records from the sandbox, if you have time, I will translate the remaining parts <br><br>  This is a translation of the first part of an article about writing VFS (virtual file system) to c ++ which I found for a long time.  I hope you will like it.  :) <br><a name="habracut"></a><br><h1>  Introduction </h1><br>  When I started developing my 3D engine, I realized that I needed something like a file system.  Not a simple archive, but its own virtual file system that supports compression, encryption, has fast access time, and so on. <br><br>  And I decided to lay out my work so that you do not have to reinvent the wheel.  This article will be divided into 2 parts.  The first is what you are reading now and the structure of the VFS will be described here.  In the second part, we actually write the VFS itself (it will be quite large). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  So what is VFS? </h1><br>  VFS is a file system similar to those in Windows (fat32, ntfs, etc.).  The main difference between VFS and a real file system is that VFS uses a real file system inside it. <br><br><h1>  Functionality </h1><br>  Some of the VFS features are: <br>  Fast access time <br>  Several archives instead of a huge number of small files <br>  Debugging option <br>  Pluggable Encryption and Compression (PEC) <br>  Security (inside the vfs file is stored MD5 key so that any changes to the archive will be immediately noticed) <br>  Several root paths <br><br>  Now, since we have listed the list of possibilities, we can proceed to the design phase <br><br><h1>  Basic design </h1><br>  Let's get started: We will have a main interface with 16 functions.  I will first show you these functions, then we will discuss why they are and we will write them in the next part. <br><br> <code>#define VFS_VERSION 0x0100&lt;br/&gt; <br> #define VFS_PATH_SEPARATOR '\\'&lt;br/&gt; <br> &lt;br/&gt; <br> void VFS_Init();&lt;br/&gt; <br> void VFS_Shutdown();&lt;br/&gt; <br> <br></code> <br><br>  These functions actually do nothing except launching / unloading some structures that we will need later. <br><br><h1>  Filters </h1><br><br> <code>typedef BOOL (* VFS_FilterProc )( LPCBYTE pIn, DWORD dwInCount, LPBYTE* ppOut, DWORD* pOutCount );&lt;br/&gt; <br> &lt;br/&gt; <br> struct VFS_Filter&lt;br/&gt; <br> {&lt;br/&gt; <br> string strName;&lt;br/&gt; <br> <br> string strDescription;&lt;br/&gt; <br> VFS_FilterProc pfnEncodeProc;&lt;br/&gt; <br> VFS_FilterProc pfnDecodeProc;&lt;br/&gt; <br> };&lt;br/&gt; <br> &lt;br/&gt; <br> void VFS_RegisterFilter( VFS_Filter* pFilter );&lt;br/&gt; <br> void VFS_UnregisterFilter( VFS_Filter* pFilter );&lt;br/&gt; <br> void VFS_UnregisterFilter( DWORD dwIndex );&lt;br/&gt; <br> <br> DWORD VFS_GetNumFilters();&lt;br/&gt; <br> const VFS_Filter* VFS_GetFilter( DWORD dwIndex );&lt;br/&gt; <br></code> <br>  Well, this is a little more difficult.  VFS_Filter is a kind of routine that processes data.  You can for example write VFS_CryptFilter that encrypts / decrypts data.  Do you have it?  The filter consists of something like a pre-processor (pfnEncodeProc procedure) for data written to the archive and a post-processor (pfnDecodeProc procedure) for reading data from the archive.  These filters implement the Pluggable Encryption and Compression mentioned above, so you can assign one or more filters to each vfs file you use.  If you are a little confused, then look at Figure 1, which is a filter scheme. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c43/f46/855/c43f468553c6013683460c486648a44d.jpg"><br><br>  You see, encoding / decoding procedures manipulate data flow in both directions: from archive to memory and from memory to archive. <br><br>  For a better understanding of filters, let's write a simple filter (in any case, keep in mind that we will not be able to test the filter, because we will implement VFS later).  Our filter will add 1 to each byte. <br><br> <code>VFS_Filter ONEADD_Filter =&lt;br/&gt; <br> {&lt;br/&gt; <br> "ONEADD",&lt;br/&gt; <br> "This Filter adds 1 to each Byte of the Data. It doesn't really make sense, "&lt;br/&gt; <br> " but anyway, this is just a test, you know",&lt;br/&gt; <br> <br> ONEADD_EncodeProc,&lt;br/&gt; <br> ONEADD_DecodeProc&lt;br/&gt; <br> };&lt;br/&gt; <br> &lt;br/&gt; <br> BOOL ONEADD_EncodeProc( LPCBYTE pIn, DWORD dwInCount, LPBYTE* ppOut, DWORD* pOutCount )&lt;br/&gt; <br> {&lt;br/&gt; <br> assert( ppOut );&lt;br/&gt; <br> assert( pOutCount );&lt;br/&gt; <br> <br> &lt;br/&gt; <br> // Allocate the Memory.&lt;br/&gt; <br> *ppOut = new BYTE[ dwInCount ];&lt;br/&gt; <br> &lt;br/&gt; <br> // Perform a For-Loop through each Byte.&lt;br/&gt; <br> for( DWORD dwIndex = 0; dwIndex &lt; dwInCount; dwIndex++ )&lt;br/&gt; <br> {&lt;br/&gt; <br> <br> ( *ppOut )[ dwIndex ] = ( BYTE )( pIn[ dwIndex ] + 1 );&lt;br/&gt; <br> }&lt;br/&gt; <br> &lt;br/&gt; <br> // Set the Output Count.&lt;br/&gt; <br> *pOutCount = dwInCount;&lt;br/&gt; <br> }&lt;br/&gt; <br> &lt;br/&gt; <br> BOOL ONEADD_DecodeProc( LPCBYTE pIn, DWORD dwInCount, LPBYTE* ppOut, DWORD* pOutCount )&lt;br/&gt; <br> <br> {&lt;br/&gt; <br> assert( ppOut );&lt;br/&gt; <br> assert( pOutCount );&lt;br/&gt; <br> &lt;br/&gt; <br> // Allocate the Memory.&lt;br/&gt; <br> *ppOut = new BYTE[ dwInCount ];&lt;br/&gt; <br> &lt;br/&gt; <br> // Perform a For-Loop through each Byte.&lt;br/&gt; <br> <br> for( DWORD dwIndex = 0; dwIndex &lt; dwInCount; dwIndex++ )&lt;br/&gt; <br> {&lt;br/&gt; <br> ( *ppOut )[ dwIndex ] = ( BYTE )( pIn[ dwIndex ] - 1 );&lt;br/&gt; <br> }&lt;br/&gt; <br> &lt;br/&gt; <br> // Set the Output Count.&lt;br/&gt; <br> <br> *pOutCount = dwInCount;&lt;br/&gt; <br> }&lt;br/&gt; <br></code> <br><br>  The only meaning of this filter is that it can be made more difficult to open the vfs file. <br><br><h1>  Root Path Functions </h1><br>  We discussed the functions of root paths not so long ago, remember?  If not - no problem.  I said that we want a function to use several root paths, that is, several search paths, such as the program installation directory, an optical disk, and a network drive.  The following functions will be used to accomplish this: <br><br> <code>void VFS_AddRootPath( LPCTSTR pszRootPath );&lt;br/&gt; <br> void VFS_RemoveRootPath( LPCTSTR pszRootPath );&lt;br/&gt; <br> void VFS_RemoveRootPath( DWORD dwIndex );&lt;br/&gt; <br> DWORD VFS_GetNumRootPaths();&lt;br/&gt; <br> LPCTSTR VFS_GetRootPath( DWORD dwIndex );</code> <br> <br>  Everything is easy enough, right? <br><br><h1>  Some simple, but necessary things. </h1><br><br>  The following 4 functions are quite simple: <br><br> <code>void VFS_Flush();</code> <br> <br>  This function will close all open vfs files that are not accessed.  You may wonder why a vfs file that is not accessed does not automatically close, but if we do that, then we had to re-analyze the vfs file every time we open or close the file.  Look at this code for further explanation: <br><br> <code>// Reference Count is 1. -&gt; Load + Parse!!!&lt;br/&gt; <br> DWORD dwHandle = VFS_File_Open( "Bla\\Bla.Txt" ); &lt;br/&gt; <br> <br> &lt;br/&gt; <br> // Reference Count is 0. -&gt; Close!!!&lt;br/&gt; <br> VFS_File_Close( dwHandle ); &lt;br/&gt; <br> &lt;br/&gt; <br> // Reference Count is 1. -&gt; Load + Parse!!!&lt;br/&gt; <br> dwHandle = VFS_File_Open( "Bla\\Bla.Txt" );&lt;br/&gt; <br> <br> &lt;br/&gt; <br> // Reference Count is 0. -&gt; Close!!!&lt;br/&gt; <br> VFS_File_Close( dwHandle );&lt;br/&gt; <br></code> <br><br>  You see, we would have to open the archive file two times.  A good place to call is VFS_Flush (). The game may be when all the data in the level have been loaded.  But here are the last 3 main functions: <br><br> <code>struct VFS_EntityInfo&lt;br/&gt; <br> {&lt;br/&gt; <br> BOOL bIsDir; // Is the Entity a Directory.&lt;br/&gt; <br> <br> BOOL bArchived; // True if the Entity is located in an Archive.&lt;br/&gt; <br> string strDir; // like Models/Sarge/Textures&lt;br/&gt; <br> string strPath; // like Models/Sarge/Textures/Texture1.Jpg&lt;br/&gt; <br> string strName; // like Texture1.Jpg&lt;br/&gt; <br> DWORD dwSize; // The Number of Files and Subdirectories for a&lt;br/&gt; <br> Directory.&lt;br/&gt; <br> <br> };&lt;br/&gt; <br> &lt;br/&gt; <br> BOOL VFS_Exists( LPCTSTR pszPath );&lt;br/&gt; <br> void VFS_GetEntityInfo( LPCTSTR pszPath, VFS_EntityInfo* pInfo );&lt;br/&gt; <br> DWORD VFS_GetVersion();&lt;br/&gt; <br></code> <br><br>  The first function is currently checking if the object exists with the pszPath path.  You see that this is a fairly simple thing, but in C (+ +) the standard library does not contain such a function (I know, they have functions like stat (), but I just want things like exists ()).  The second function is something like stat (), it returns information about the object. <br><br>  The latter function has nothing to do with the information about the object; this function simply returns the current version of VFS.  Nothing special (Seriously, it just returns the VFS_VERSION constant ;-) <br><br><h1>  File Interface </h1><br><br>  We looked at simple things.  But do not worry, there are still a couple of easy things ahead.  In fact, everything described in this part of the article is easy.  Unfortunately, if you want something more complicated, you will have to wait for the next part of this article ... ;-) <br><br>  Well, here they are, the file interface functions: <br><br> <code>#define VFS_INVALID_HANDLE ( ( DWORD ) -1 )&lt;br/&gt; <br> &lt;br/&gt; <br> // The VFS_File_Open/Create() Flags.&lt;br/&gt; <br> #define VFS_READ 0x01&lt;br/&gt; <br> #define VFS_WRITE 0x02&lt;br/&gt; <br> <br> &lt;br/&gt; <br> // The VFS_File_Seek() Flags.&lt;br/&gt; <br> #define VFS_SET 0x00&lt;br/&gt; <br> #define VFS_CURRENT 0x01&lt;br/&gt; <br> #define VFS_END 0x02&lt;br/&gt; <br> &lt;br/&gt; <br> // Create / Open / Close a File.&lt;br/&gt; <br> DWORD VFS_File_Create( LPCTSTR pszFile, DWORD dwFlags );&lt;br/&gt; <br> DWORD VFS_File_Open( LPCTSTR pszFile, DWORD dwFlags );&lt;br/&gt; <br> void VFS_File_Close( DWORD dwHandle );&lt;br/&gt; <br> <br> &lt;br/&gt; <br> // Read / Write from / to the File.&lt;br/&gt; <br> void VFS_File_Read( DWORD dwHandle, LPBYTE pBuffer, DWORD dwToRead, DWORD* pRead = NULL );&lt;br/&gt; <br> void VFS_File_Write( DWORD dwHandle, LPCBYTE pBuffer, DWORD dwToWrite, DWORD* pWritten = NULL );&lt;br/&gt; <br> &lt;br/&gt; <br> // Direct Data Access.&lt;br/&gt; <br> LPCBYTE VFS_File_GetData( DWORD dwHandle );&lt;br/&gt; <br> &lt;br/&gt; <br> // Positioning.&lt;br/&gt; <br> void VFS_File_Seek( DWORD dwHandle, LONG dwPos, DWORD dwOrigin = VFS_SET );&lt;br/&gt; <br> <br> LONG VFS_File_Tell( DWORD dwHandle );&lt;br/&gt; <br> DWORD VFS_File_GetSize( DWORD dwHandle );&lt;br/&gt; <br> &lt;br/&gt; <br> // Information.&lt;br/&gt; <br> BOOL VFS_File_Exists( LPCTSTR pszFile );&lt;br/&gt; <br> void VFS_File_GetInfo( LPCTSTR pszFile, VFS_EntityInfo* pInfo );&lt;br/&gt; <br> void VFS_File_GetInfo( DWORD dwHandle, VFS_EntityInfo* pInfo );&lt;br/&gt; <br></code> <br><br>  There are only a few things worth noting.  First, the dwFlags parameter of VFS_File_Create () and VFS_File_Open () can be either VFS_READ or VFS_WRITE or both, which means read, write or read / write access.  Secondly, these two functions return a handle, which is used by almost all other functions, as a kind of pointer.  We will not use pointers, but we will use a handle since they provide another level of abstraction.  I would also like to mention the fact that our functions will load the entire file into memory.  This is necessary due to the filtering feature (since they need memory for processing).  You can access this memory directly with VFS_File_GetData ().  Well, the rest in things you should know, thanks to the standard I / O library. <br><br><h1>  The interface of our library </h1><br><br>  This may be the place you were expecting, starting with some lines or it would be better to say pages (and when we talk about waiting: what I didn‚Äôt expect is the fact that this is page 7 or so. WOW!). <br><br>  In any case, let's continue: <br><br> <code>// Create / Open / Close an Archive.&lt;br/&gt; <br> DWORD VFS_Archive_Create( LPCTSTR pszArchive, const VFS_FilterNameList&amp; Filters, DWORD dwFlags );&lt;br/&gt; <br> DWORD VFS_Archive_CreateFromDirectory( LPCTSTR pszArchive, LPCTSTR pszSrcDir,&lt;br/&gt; <br> <br> const VFS_FilterNameList&amp; Filters, DWORD dwFlags );&lt;br/&gt; <br> DWORD VFS_Archive_Open( LPCTSTR pszArchive, DWORD dwFlags );&lt;br/&gt; <br> void VFS_Archive_Close( DWORD dwHandle );&lt;br/&gt; <br> &lt;br/&gt; <br> // Set the Filters used by this Archive.&lt;br/&gt; <br> void VFS_Archive_SetUsedFilters( DWORD dwHandle, const VFS_FilterNameList&amp; Filters );&lt;br/&gt; <br> void VFS_Archive_GetUsedFilters( DWORD dwHandle, VFS_FilterNameList&amp; Filters );&lt;br/&gt; <br> &lt;br/&gt; <br> <br> // Add / Remove Files to / from the Archive.&lt;br/&gt; <br> void VFS_Archive_AddFile( DWORD dwHandle, LPCTSTR pszFile );&lt;br/&gt; <br> void VFS_Archive_RemoveFile( DWORD dwHandle, LPCTSTR pszFile );&lt;br/&gt; <br> &lt;br/&gt; <br> // Extract the Archive.&lt;br/&gt; <br> void VFS_Archive_Extract( DWORD dwHandle, LPCTSTR pszTarget );&lt;br/&gt; <br> &lt;br/&gt; <br> // Information.&lt;br/&gt; <br> void VFS_Archive_GetInfo( DWORD dwHandle, VFS_EntityInfo* pInfo );&lt;br/&gt; <br> void VFS_Archive_GetInfo( LPCTSTR pszArchive, VFS_EntityInfo* pInfo );&lt;br/&gt; <br> <br></code> <br><br>  Very simple interface, right?  Just the usual stuff for an archive file.  And now you finally see the application for the filter functions that we saw before.  You can apply filters using VFS_Archive_Set / GetUsedFilters (). <br><br><h1>  Folder Interface </h1><br>  This is the latest VFS interface.  It contains 3 functions that should be understood without explanation as I think. <br><br> <code>// Information.&lt;br/&gt; <br> BOOL VFS_Dir_Exists( LPCTSTR pszDir );&lt;br/&gt; <br> BOOL VFS_Dir_GetInfo( LPCTSTR pszDir, VFS_EntityInfo* pInfo );&lt;br/&gt; <br> &lt;br/&gt; <br> <br> // Get the Contents of a Directory.&lt;br/&gt; <br> vector&lt; VFS_EntityInfo &gt; VFS_Dir_GetContents( LPCTSTR pszDir, BOOL bRecursive = FALSE );</code> <br> <br>  Functions 1 and 2 are fairly simple (such as if they are used for files).  Function 3 acts as a DOS command.  ;-) <br><br><h1>  A little chat </h1><br>  That's all.  We have completed the first part of the article.  I do not believe (me too :) approx.  translator).  But the hardest is still to come: <br><br>  We need to WRITE VFS !!! <br><br>  <a href="">Download article_vfs_header.h</a> <br></div><p>Source: <a href="https://habr.com/ru/post/64538/">https://habr.com/ru/post/64538/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../64532/index.html">Nakazator - betray the righteous judgment of the enemy of the people!</a></li>
<li><a href="../64533/index.html">Presentation of a webinar on time management for project managers</a></li>
<li><a href="../64534/index.html">Stickerity</a></li>
<li><a href="../64536/index.html">‚ÄúImprint of the Soul‚Äù - a blog-social network of creative people</a></li>
<li><a href="../64537/index.html">Touch branding - where everything moves</a></li>
<li><a href="../64541/index.html">What to do if the payment terminal did not issue a check</a></li>
<li><a href="../64543/index.html">Attitudes of companies towards you: what should it be?</a></li>
<li><a href="../64544/index.html">Let's go back in time. Computer DAEWOO CPC-300e</a></li>
<li><a href="../64545/index.html">How to turn a boring job into entertainment</a></li>
<li><a href="../64547/index.html">I am an altruist. I will write for the community about any useful and free web service</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>