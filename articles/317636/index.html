<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Docker, GitLab, free SSL certificates and other modern web development buns</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello again! For almost five years I have not written new articles here, although, to be honest, I always knew that sooner or later I would start to d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Docker, GitLab, free SSL certificates and other modern web development buns</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello again!  For almost five years I have not written new articles here, although, to be honest, I always knew that sooner or later I would start to do it again.  I do not know about you, but all the same, this business has always seemed quite fascinating. </p><br><p>  Starting writing new material after such a long rest from this business is the most difficult thing.  But once the goal is set - you must go to the end.  I'll start a little from afar. </p><br><p>  Throughout my adult life, web development has been and remains my main activity.  That is why, I confess at once that this material should be perceived as an attempt to build a Docker cluster from an amateur system administrator, but not a professional one.  In this article I cannot claim an expert opinion in clustering and even, moreover, I myself want to check the authenticity of my own experience. </p><br><p>  Under Habrakat, you will find <em>Quick Start on using Docker</em> at the level required for solving specific tasks indicated below, without going into the jungle of virtualization and other related topics.  If you still want to begin to successfully use this modern technology, thereby greatly simplifying a number of processes: from the development of web products to the deployment and transfer of these under any modern equipment - I ask for cat! </p><br><p><img src="https://habrastorage.org/files/701/e12/715/701e127152c84347bd00745eb1927cc9.png" alt="Opening Illustration - Docker"></p><a name="habracut"></a><br><h2 id="preambula">  Preamble </h2><br><p>  We begin, of course, with the formulation of the problem and the definition of the main technologies / methods used in the guide. </p><br><p>  From the very beginning I was interested in Docker to quickly create a small, but rather universal cluster for my own projects (work, school, etc).  Since I was not going to be professionally involved in system administration, I decided that I should learn the basics of clustering right up to the moment when I could easily deploy any popular software stack for a web project.  Next, I will look at deploying the following configurations on Docker: </p><br><ul><li>  <strong>LAMP</strong> ; </li><li>  <strong>LEMP</strong> ; </li><li>  <strong>MEAN</strong> . </li></ul><br><p>  The first two in the presentation, I think, do not need.  The third one consists of <a href="https://ru.wikipedia.org/wiki/MongoDB">MongoDB</a> , <a href="https://ru.wikipedia.org/wiki/Express.js">Express.js</a> , <a href="https://ru.wikipedia.org/wiki/Node.js">Node.js.</a>  I most often used <strong>MEAN</strong> for writing a <a href="https://ru.wikipedia.org/wiki/REST">RESTful API</a> , for example, for further developing a mobile application based on it. </p><br><p>  After that, I made the task a bit harder for me by adding the following requirements: </p><br><ol><li>  <strong>The ability to easily use different domains</strong> (or, often, subdomains) for each individual container (according to the principle of <a href="https://ru.wikibooks.org/wiki/VirtualHost">virtual hosts</a> ). </li><li>  <strong>Use HTTPS protocol</strong> by default.  Moreover, I would like to organize the free generation of <strong>SSL certificates</strong> that are not inferior to the paid counterparts. </li><li>  <strong>Deploying on the same <a href="https://gitlab.com/gitlab-org/gitlab-ce">GitLab CE</a> server</strong> - as the main CVS system for working on projects not only alone, but also in a team. </li></ol><br><h4 id="osnovnye-opredeleniya">  Basic definitions: </h4><br><ul><li><p>  <strong><a href="https://www.docker.com/">Docker</a></strong> is an automation software for deploying and managing applications in a virtualization environment at the operating system level. </p><br></li><li><p>  <a href="https://letsencrypt.org/"><strong>Letsencrypt</strong></a> - Free automatic authorization center (CA).  Provides free certificates to enable <strong>HTTPS (SSL / TLS)</strong> support on any website. </p><br></li><li>  <strong><a href="https://gitlab.com/gitlab-org/gitlab-ce">GitLab Community Edition</a></strong> - Open Source analogue of GitHub.  It provides management of Git-repositories, code analysis, error tracking, work with activity channels, Wiki creation, etc. </li></ul><br><h2 id="ustanovka-i-nastroyka">  Installation and Setup </h2><br><p>  Problems installing Docker and other packages should not arise.  On the official website, this process is described in some detail.  Next, I will sign the general list of commands required for the initial setup. </p><br><p>  I‚Äôll clarify right away that in this article I‚Äôll look at the configuration of Docker and all related programs on the <strong>CentOS 7</strong> distribution, since I‚Äôve been used to working on this OS for a long time as on the main server system.  In general, on any other Linux distribution, the actions will be approximately the same, with the only difference that, for example, for Ubuntu you will use <strong>apt-get</strong> instead of <strong>yum / dnf</strong> (for CentOS / Fedora). </p><br><h4 id="docker--docker-compose">  Docker + Docker Compose: </h4><br><p>  Training: </p><br><p><code>$ sudo yum update</code> <br> <code>$ sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-'EOF'</code> <br> <code>[dockerrepo]</code> <br> <code>name=Docker Repository</code> <br> <code>baseurl=https://yum.dockerproject.org/repo/main/centos/7/</code> <br> <code>enabled=1</code> <br> <code>gpgcheck=1</code> <br> <code>gpgkey=https://yum.dockerproject.org/gpg</code> <br> <code>EOF</code> </p> <br><p>  Installing <strong>Docker Engine</strong> : </p><br><p> <code>$ sudo yum install docker-engine</code> <br> <code>$ sudo systemctl enable docker.service</code> <br> <code>$ sudo systemctl start docker</code> </p> <br><p>  Creating a docker user group and adding the current user there (this is necessary in order to work with Docker without using sudo or root access): </p><br><p> <code>$ sudo groupadd docker</code> <br> <code>$ sudo usermod -aG docker your_username</code> </p> <br><p>  Verifying successful installation: </p><br><p> <code>$ docker run --rm hello-world</code> </p> <br><p>  Install Docker Compose (a utility to merge several containers into one web application): </p><br><p> <code>$ sudo curl -L "https://github.com/docker/compose/releases/download/1.9.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</code> <br> <code>$ sudo chmod +x /usr/local/bin/docker-compose</code> <br> <code>$ docker-compose --version</code> </p> <br><h4 id="certbot-oficialnyy-saythttpscertbotefforg">  Certbot ( <a href="https://certbot.eff.org/">official site</a> ): </h4><br><p>  A utility for automatically obtaining / updating SSL certificates from <strong>Letsencrypt</strong> : </p><br><p>  Before installation, you must <a href="https://fedoraproject.org/wiki/EPEL">enable the EPEL repository</a> , if this has not been done before. </p><br><p> <code>$ sudo yum install certbot</code> </p> <br><h2 id="osnovy-raboty-s-docker-engine">  Docker Engine Basics </h2><br><p><img src="https://habrastorage.org/files/466/da1/d5a/466da1d5a7dc4711afc9f9b603ab15b1.png" alt="Docker engine"></p><br><h4 id="bazovye-principy">  Basic principles: </h4><br><p>  Docker is an extra layer of abstraction;  <strong>a system that automates <em>virtualization at the operating system level</em></strong> . </p><br><blockquote>  <em>" <strong>Operating system</strong> - <strong>level</strong> virtualization is a virtualization method in which the core of the operating system supports several isolated instances of user space instead of one. These instances (often called <strong>containers</strong> or zones) are completely identical to the real server from the user's point of view. The kernel ensures complete isolation of containers, therefore programs from different containers cannot affect each other. "</em> <br><br>  From <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D0%25B8%25D1%2580%25D1%2582%25D1%2583%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F_%25D0%25BD%25D0%25B0_%25D1%2583%25D1%2580%25D0%25BE%25D0%25B2%25D0%25BD%25D0%25B5_%25D0%25BE%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D0%25BE%25D0%25BD%25D0%25BD%25D0%25BE%25D0%25B9_%25D1%2581%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D1%258B">wikipedia</a> </blockquote><p>  <strong>Main advantages of using Docker:</strong> </p><br><ul><li>  Isolation of separate clusters from each other; </li><li>  The same Docker container can work without changes on many different machines (with different configurations); </li><li>  Docker is optimized for application deployment ( <em>application-centric</em> ); </li><li>  Automating the assembly of applications; </li><li>  Reuse of the same components; </li><li>  Open Source registry of ready containers ( <a href="https://hub.docker.com/">Docker Hub</a> ); </li><li>  Unified API for automating container customization and deployment. </li></ul><br><p>  Next, consider the basic commands that we need to create a cluster: </p><br><h4 id="-docker-run">  $ docker run </h4><br><p>  In essence, the main team that runs the new container. </p><br><p>  Main settings: </p><br><ol><li>  <strong>--name</strong> : UUID identifier: unique container name; </li><li>  <strong>--volume (-v)</strong> : volume associated with the container: set in the form of an absolute path to the directory; </li><li>  <strong>--env (-e)</strong> : environment variable: allows additional customization of the launched container; </li><li>  <strong>--publish (-p)</strong> : configure certain ports required for the operation of the container (for example, 80 for http, 443 for https). </li></ol><br><h4 id="-docker-ps">  $ docker ps </h4><br><p>  The command with which you can get a list of running containers. </p><br><h4 id="-docker-stop-container-name">  $ docker stop container-name </h4><br><p>  The team that stops the operation of the container. </p><br><h4 id="-docker-rm-container-name">  $ docker rm container-name </h4><br><p>  Delete a specific container. </p><br><p>  <strong>Warning</strong> : before removing the container, you must stop it ( <em>docker stop</em> )! </p><br><p>  In more detail you can understand the work of each team in the <a href="https://docs.docker.com/">official documentation</a> .  In this article, I drew attention only to the basic commands needed to successfully start working with Docker. </p><br><p>  You will see specific examples of using the <code>docker run</code> in this article a little further. </p><br><h2 id="nastroyka-virtualnyh-hostov">  Configuring virtual hosts </h2><br><p><img src="https://habrastorage.org/files/a39/b4c/860/a39b4c86004545e6b2a5ae2a82874354.png" alt="Nginx Reverse Proxy"></p><br><p>  <strong>Problem: a</strong> certain complexity of cluster implementation using virtual hosts in different containers is that one port can be ‚Äúlistened‚Äù by only one container (configured via --publish).  It turns out that by default we can create only one container that will respond to requests to the server through port 80 and / or 443 (http and https protocols, respectively). </p><br><p>  <strong>Solution:</strong> in principle, it is rather obvious to use a <strong><em>Reverse Proxy</em></strong> encapsulated in one container to solve this problem, which will listen on ports 80 and 443. The functionality of this container will be to automatically redirect requests, in accordance with the virtual hosts used. </p><br><p>  Such a container exists in open access in Docker Hub - <a href="https://github.com/jwilder/nginx-proxy">nginx-proxy</a> . </p><br><p>  In addition to solving the problem with virtual hosts, by default it supports work with SSL certificates, which allows you to deploy support for HTTPS-protected access to the site. </p><br><p>  Before starting this <strong><em>Reverse Proxy</em></strong> container, let's get SSL certificates for the domains that we want to use as virtual hosts. </p><br><h4 id="poluchenie-besplatnogo-ssl-sertifikata">  Getting a free SSL certificate </h4><br><p>  To obtain an SSL certificate, we will use the free service <strong>letsencrypt</strong> .  To do this, we have already installed the <strong>certbot</strong> utility in the previous steps.  I will not dwell on the details of using this utility (this is all in the <a href="https://certbot.eff.org/">official documentation</a> ). </p><br><p>  I‚Äôll just give you a ready-made command for automatically obtaining a free SSL certificate for your domain: </p><br><p> <code>$ sudo certbot certonly -n -d yourdomain.com --email your@email.com --standalone --noninteractive --agree-tos</code> </p> <br><p>  <code>--standalone --noninteractive --agree-tos</code> - these parameters are necessary for certbot to work on the one hand in the background, and on the other hand, to generate a certificate without a specific binding to a specific web server. </p><br><p>  As a result of the successful execution of this command, two files will be generated: </p><br><p> <code>/etc/letsencrypt/live/yourdomain.com/fullchain.pem</code> </p> <br><p> <code>/etc/letsencrypt/live/yourdomain.com/privkey.pem</code> </p> <br><p>  For <strong>nginx-proxy to</strong> work correctly, we need to place all certificate files in one directory, while using two files for each domain name in the format: <strong>yourdomain.com.crt</strong> (certificate file) and <strong>yourdomain.com.key</strong> (private key). </p><br><p>  In this case, it is logical to use symbolic links.  Example: </p><br><p> <code>$ mkdir ssl-certs</code> </p> <br><p> <code>$ cd ssl-certs</code> </p> <br><p> <code>$ ln -s /etc/letsencrypt/live/yourdomain.com/fullchain.pem ./yourdomain.com.crt</code> </p> <br><p> <code>$ ln -s /etc/letsencrypt/live/yourdomain.com/privkey.pem ./yourdomain.com.key</code> </p> <br><p>  <em>There is no need to pay special attention to the .pem extension - the essence of the files does not change.</em> </p><br><p>  Similarly, we can get certificates for any domain names we own and then use them as virtual hosts.  The only requirement is that the A-records of these domain names must be directed to the external IP address of the server on which you are <code>certbot certonly ...</code> </p><br><p>  Having generated certificates for each domain, we are ready to launch the <em>nginx-proxy</em> container. </p><br><pre> <code class="bash hljs">$ docker run -d -p 80:80 -p 443:443 \ ‚Äã-v /full/path/to/ssl-keys:/etc/nginx/certs \ ‚Äã-v /var/run/docker.sock:/tmp/docker.sock:ro \ ‚Äãjwilder/nginx-proxy</code> </pre> <br><p>  Consider this command in more detail: </p><br><ol><li>  <code>-p 80:80 -p 443:443</code> - we bind ports 80 and 443 to the container. The 80th port of the server corresponds to the 80th port inside the container and similarly with port 443. In the <em>PORT: PORT2</em> format, the correspondences are created between the real port the entire machine and ports inside a separate virtual container. </li><li>  <code>-v /full/path/to/ssl-keys:/etc/nginx/certs</code> - the first volume needed to configure this container.  Here we link the standard / etc / nginx / certs directory inside the container itself to the directory into which we manually placed symbolic links to the certificate and private key files for our domains (in the previous step). </li><li>  <code>jwilder/nginx-proxy</code> is the container identifier inside the Docker Hub.  The Docker Engine automatically downloads an image of this container if it has not been loaded before. </li></ol><br><p>  That's it - the first container is running!  And this container is <strong><em>Reverse Proxy</em></strong> , through which we can further set any container application <strong>VIRTUAL_HOST</strong> . </p><br><h2 id="primery-raboty-s-razlichnymi-stekami">  Examples of working with different stacks </h2><br><h4 id="lamp">  LAMP </h4><br><p>  So, finally, we can proceed to launching containers in which we can already develop our web applications. </p><br><p>  In the Docker Hub base there are a lot of different versions of LAMP containers.  Personally, I used this: <a href="https://github.com/tutumcloud/lamp">tutum-docker-lamp</a> . </p><br><p>  Earlier, in addition to the Docker Engine, we installed the <strong><em>Docker Compose</em></strong> utility.  And only from this moment we begin to use it.  Docker Compose is convenient for creating applications in which several containers are combined and jointly represent the application being developed. </p><br><p>  In order to run this container in conjunction with our nginx-proxy you need: </p><br><ol><li><p>  Download the tutum-docker-lamp source code into a separate directory (the most convenient way to do this is using <code>git clone</code> ); </p><br></li><li>  Create a <strong>docker-compose.yml</strong> file in this working directory with something like this: </li></ol><br><pre> <code class="bash hljs">web: ‚Äãbuild: . volumes: - ./www:/var/www/html environment: - MYSQL_PASS=yourmysqlpassword - VIRTUAL_HOST=yourdomain.com</code> </pre> <br><ol><li><p>  Run it with docker-compose: </p><br><p> <code>$ docker-compose up</code> </p> <br></li></ol><br><p>  As you can see in this example, the management of virtual hosts using nginx-proxy is performed using just one environment variable <strong>VIRTUAL_HOST</strong> . </p><br><p>  Focus on a bunch of <code>./www:/var/www/html</code> .  Obviously, the working directory of your site becomes the www folder (you must create it manually).  All files in this directory automatically fall into <code>/var/www/html</code> inside the running container. </p><br><p>  You can get a better understanding of the syntax of the <strong>docker-compose.yml</strong> configuration file in the <a href="https://docs.docker.com/compose/gettingstarted/">official documentation</a> . </p><br><h4 id="lemp">  Lemp </h4><br><p>  Running a LEMP container is basically no different from the example above. </p><br><p>  First we find the container in the Docker Hub.  For example: <a href="https://github.com/stenote/docker-lemp">docker-lemp</a> . </p><br><p>  Download the source of the container and add <strong>docker-compose.yml</strong> .  Inside this settings file of our custom container, you can not only set the <strong>VIRTUAL_HOST</strong> environment <strong>variable</strong> , but also configure everything that the <em>Dockerfile</em> allows.  For example, the <em>Dockerfile</em> defines: </p><br><p> <code>VOLUME /var/www/</code> </p> <br><p>  Therefore, you can do a bundle with this volume in docker-compose.yml like this: </p><br><p> <code>volumes:</code> <br>  - <code>- ./www:/var/www</code> </p><br><h4 id="nodejs--expressjs--mongodb">  NodeJS + ExpressJS + MongoDB </h4><br><p>  An example of this configuration: <a href="https://github.com/Kyborg2011/findme-api">docker-nodejs-mongodb-example</a> . </p><br><p>  The <strong>docker-compose.yml file</strong> looks like this: </p><br><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">web</span></span>:‚Äã build: .‚Äã volumes:‚Äã - <span class="hljs-string"><span class="hljs-string">"./api:/src/app"</span></span>‚Äã environment:‚Äã - <span class="hljs-type"><span class="hljs-type">VIRTUAL_HOST</span></span>=yourdomain.com‚Äã links:‚Äã - <span class="hljs-string"><span class="hljs-string">"db:mongo"</span></span> db: ‚Äãimage: mongo ‚Äãports:‚Äã - <span class="hljs-string"><span class="hljs-string">"27017:27017"</span></span> ‚Äãvolumes:‚Äã - ./<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">/db:/</span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">/db</span></span></code> </pre> <br><p>  In this case, two linked containers will be created.  One for the base (mongoDB), the second for the <em>NodeJS</em> application itself. </p><br><p>  To run this bundle of containers, the same <code>docker-compose up</code> . </p><br><h2 id="tonkosti-v-rabote-s-gitlabgitlab-ce">  Subtleties in working with gitlab / gitlab-ce </h2><br><p><img src="https://habrastorage.org/files/308/c1e/29b/308c1e29bdfb4f378c9b5e8287900119.png" alt="GitLab CE on Docker Engine"></p><br><p>  Some more complex containers require additional configuration to run using nginx-proxy.  These containers include <strong>gitlab-ce</strong> . </p><br><p>  I will first give a fully working version of the command to run this container, taking into account the configuration discussed in this article, and further I will explain below some of the details from this command. </p><br><p>  So: </p><br><pre> <code class="bash hljs">$ docker run --detach \ --hostname gitlab.yourdomain.com \ --publish 2289:22 \ --restart always \ --name custom-gitlab \ --env GITLAB_OMNIBUS_CONFIG=<span class="hljs-string"><span class="hljs-string">"nginx['listen_port'] = 80; nginx['listen_https'] = false; nginx['proxy_set_headers'] = { \"X-Forwarded-Proto\" =&gt; \"https\", \"X-Forwarded-Ssl\" =&gt; \"on\" }; gitlab_rails['gitlab_shell_ssh_port'] = 2289; external_url 'https://gitlab.yourdomain.com'; gitlab_rails['smtp_enable'] = true; gitlab_rails['smtp_address'] = 'smtp.mailgun.org'; gitlab_rails['smtp_port'] = 2525; gitlab_rails['smtp_authentication'] = 'plain'; gitlab_rails['smtp_enable_starttls_auto'] = true; gitlab_rails['smtp_user_name'] = 'postmaster@mg.yourdomain.com'; gitlab_rails['smtp_password'] = 'password'; gitlab_rails['smtp_domain'] = 'mg.yourdomain.com';"</span></span> \ --env VIRTUAL_HOST=<span class="hljs-string"><span class="hljs-string">"gitlab.yourdomain.com"</span></span> \ --volume /srv/gitlab/config:/etc/gitlab \ --volume /srv/gitlab/logs:/var/<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/gitlab \ --volume /srv/gitlab/data:/var/opt/gitlab \ gitlab/gitlab-ce:latest</code> </pre> <br><h4 id="zapusk-cherez-nginx-reverse-proxy--https">  Run via NGINX Reverse Proxy + HTTPS </h4><br><p>  In order for the scheme with <strong><em>Reverse Proxy to</em></strong> work in this case, you need to add: </p><br><pre> <code class="bash hljs">nginx[<span class="hljs-string"><span class="hljs-string">'listen_port'</span></span>] = 80; nginx[<span class="hljs-string"><span class="hljs-string">'listen_https'</span></span>] = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; nginx[<span class="hljs-string"><span class="hljs-string">'proxy_set_headers'</span></span>] = { \<span class="hljs-string"><span class="hljs-string">"X-Forwarded-Proto\" =&gt; \"https\", \"X-Forwarded-Ssl\" =&gt; \"on\" };</span></span></code> </pre> <br><p>  The reason is that when working with containers, nginx-proxy addresses port 80 rather than 443 inside them. Without additional headers, the nginx configuration inside the gitlab-ce container ( <strong><em>proxy_set_headers</em></strong> ) will not pass the request (error <strong>502 "Bad Gateway"</strong> ) . </p><br><p>  In addition, it is important to add: </p><br><p> <code>external_url 'https://gitlab.yourdomain.com';</code> </p> <br><h4 id="port-22">  Port 22 </h4><br><p>  The essence of these lines: </p><br><p> <code>--publish 2289:22</code> </p> <br><p>  If the work with the working machine is performed via the SSH protocol, then we cannot create a bundle directly "22:22", since port 22 is already occupied by the <em>sshd</em> service. </p><br><p>  The solution to this problem is described in the official gitlab-ce documentation.  It's simple: we bind any other (except 22) port inside the server to port 22 inside the container.  This example uses port 2289. </p><br><p>  In parallel with this, it is important not to forget to add </p><br><p> <code>gitlab_rails['gitlab_shell_ssh_port'] = 2289;</code> </p> <br><p>  In the settings of the GitLab itself. </p><br><p>  Thus, after running gitlab-ce and creating some kind of repository in it, it will work with the following address: </p><br><p> <code>ssh://git@gitlab.yourdomain.com:2289/username/repository_name.git</code> </p> <br><h4 id="nastroyka-smtp-servera">  SMTP server setup </h4><br><p>  Here, too, you must use the special environment variables of GitLab itself. </p><br><p>  In my case (I use <em>Google Cloud Engine</em> ), ports 25, 465 (i.e. standard ports of the SMTP protocol) are closed by default.  One solution to this problem is to use a third-party service (such as <a href="http://mailgun.com/">MailGun</a> ) as an SMTP server.  To do this, use the settings: </p><br><pre> <code class="bash hljs">gitlab_rails[<span class="hljs-string"><span class="hljs-string">'smtp_enable'</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; gitlab_rails[<span class="hljs-string"><span class="hljs-string">'smtp_address'</span></span>] = <span class="hljs-string"><span class="hljs-string">'smtp.mailgun.org'</span></span>; gitlab_rails[<span class="hljs-string"><span class="hljs-string">'smtp_port'</span></span>] = 2525; gitlab_rails[<span class="hljs-string"><span class="hljs-string">'smtp_authentication'</span></span>] = <span class="hljs-string"><span class="hljs-string">'plain'</span></span>; gitlab_rails[<span class="hljs-string"><span class="hljs-string">'smtp_enable_starttls_auto'</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; gitlab_rails[<span class="hljs-string"><span class="hljs-string">'smtp_user_name'</span></span>] = <span class="hljs-string"><span class="hljs-string">'postmaster@mg.yourdomain.com'</span></span>; gitlab_rails[<span class="hljs-string"><span class="hljs-string">'smtp_password'</span></span>] = <span class="hljs-string"><span class="hljs-string">'password'</span></span>; gitlab_rails[<span class="hljs-string"><span class="hljs-string">'smtp_domain'</span></span>] = <span class="hljs-string"><span class="hljs-string">'mg.yourdomain.com'</span></span>;</code> </pre> <br><p>  Well, finally, do not forget about <code>--env VIRTUAL_HOST="gitlab.yourdomain.com" \</code> - the environment variable for the nginx-proxy itself. </p><br><p>  That's all.  After executing this instruction, Docker will launch a fully functioning container with GitLab CE. </p><br><h4 id="standartnyy-process-obnovleniya-gitlab-ce">  Gitlab-ce standard update process </h4><br><p>  This is the last point that I want to separately highlight in this guide. </p><br><p>  The process of updating GitLab with Docker is simplified to several commands: </p><br><ol><li><p>  <code>docker stop custom-gitlab</code> - we stop the working container; </p><br></li><li><p>  <code>docker rm custom-gitlab</code> - remove the GitLab CE container. </p><br><p>  <strong>The important point: the</strong> removal of the container does not mean the deletion of data that was created during the use of the system.  Therefore, you can execute this command without any fear. </p><br></li><li><p>  <code>docker pull gitlab/gitlab-ce</code> - the actual update of the image of the container; </p><br></li><li>  we execute a long command (example above), with the help of which we initially launched the container. </li></ol><br><p>  That's all.  After completing these 4 commands, GitLab will automatically update to the latest version and run through the Docker Engine. </p><br><h2 id="itogi">  Results </h2><br><p>  So, as a result of running this guide, you should have a Docker cluster based on the NGINX Reverse Proxy;  Each web application has its own virtual host, which at the same time supports the secure HTTPS protocol. </p><br><p>  Together with web applications, the GitLab cluster is fully configured, up to and including access to the SMTP server. </p><br><p>  I really hope that this small research of mine will be useful or, at least, interesting for many HabraHabr readers.  Of course, I will be glad to hear criticism of professionals, additions or improvements to the article! </p><br><p>  Thanks for attention! </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/317636/">https://habr.com/ru/post/317636/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../317626/index.html">Yandex used a neural network and learned how to predict precipitation to the nearest minute.</a></li>
<li><a href="../317628/index.html">Java hardcore in Novosibirsk: a review and video of the best reports JBreak 2016. And the announcement of the JBreak 2017</a></li>
<li><a href="../317630/index.html">I gave up PGP</a></li>
<li><a href="../317632/index.html">A few tips to automate data center monitoring. Part 1</a></li>
<li><a href="../317634/index.html">Current strength: how mobile communications changed our attitude to energy</a></li>
<li><a href="../317638/index.html">Overcoming difficulties: Gravity Defied on sed</a></li>
<li><a href="../317640/index.html">How does Netflix streaming work</a></li>
<li><a href="../317642/index.html">One tool for all subscriptions - newsletters, RSS, telegram feeds, social networking pages</a></li>
<li><a href="../317644/index.html">Ransomware Trojans - security theme of the year</a></li>
<li><a href="../317648/index.html">How we solved the problem of parental committees and earned a million rubles.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>