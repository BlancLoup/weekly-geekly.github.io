<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Encrypted client-server communication on Laravel 4</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Good day to all! In my first article on Laravel, I want to share my experience in organizing encrypted communication between a client (...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Encrypted client-server communication on Laravel 4</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Good day to all!  In my first article on Laravel, I want to share my experience in organizing encrypted communication between a client (desktop application) and a server running Laravel. <br><br>  What is the essence of the problem?  There is an application that works on the principle of subscription: paid for on the site, say a month of use and a month of use.  Once this period has passed, the application should stop working.  Since the condition for this application requires an Internet connection, the best option to check the licensing of the application will be to poll the license server, which can also be a website, through which the payment and extension of the application usage period actually occurs. <br><br>  But the problem is that if the traffic between the client and the server is not encrypted, anyone can eventually forge the server and use the application for an arbitrarily long time. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article I will discuss how to organize encrypted communication between the client and the server.  As a server platform, there will be an application on the Laravel 4.1 engine (the latest version at the time of publication).  It is assumed that an application written in C # will act as a client, but in this article I will not describe the writing of a client.  Instead, I can recommend an article from CodeProject that gives an example of using C # cryptography: <a href="http://www.codeproject.com/Articles/223081/Encrypting-Communication-between-Csharp-and-PHP">Encrypting Communication between C # and PHP</a> .  Actually this article was the starting point for my research. <br><a name="habracut"></a><br>  I will try to highlight the following questions: <br><ul><li>  fundamentals of cryptography (it‚Äôs about the basics, since I don‚Äôt know much about cryptography); </li><li>  programming under Laravel, adhering to SOLID-design (ideally, but in practice, to simplify the article, not all SOLID-principles will be respected) </li><li>  Maybe something else </li></ul><br><h2>  Cryptography basics </h2><br>  All existing encryption algorithms can be divided into 2 types: symmetric and asymmetric encryption.  With symmetric encryption, one key is used for both encryption and vice versa, for decryption.  Algorithms in this category are much faster asymmetric. <br><br>  Asymmetric algorithms use two keys: public and private.  Encryption is performed using the public key, while decrypting this data can only be done using the private key.  In addition to encryption, there is such a thing as a digital signature of data: a hash of data generated using the private key.  This hash is verified using the public key.  What does this mean and what is it for?  This is necessary in order to make sure that the data obtained came from who we expect, and were not modified by anyone on the way to us.  Asymmetric algorithms are much slower than symmetric ones and are intended more to encrypt a small amount of data, but more reliably.  Therefore, as a rule, the following scheme of interaction between the client and the server is used: <br><ol><li>  Initially, the client generates a random key for symmetric encryption. </li><li>  Further, the client encrypts this key using an asymmetric algorithm, using the server's public key known to him in advance. </li><li>  The encrypted key is sent to the server. </li><li>  The server receives and decrypts the received key and informs the client with a response that everything is fine. </li><li>  Further traffic between the server and the client is encrypted using the selected symmetric algorithm. </li></ol><br>  What is it for?  In order to prevent a man-in-the-middle attack (man in the middle) when traffic is intercepted and used by the attacker for his own purposes. <br><br>  In our case, in addition to encryption, the data will still be signed so that the client is 100% sure that the data was received from his server, and not from the potentially forged data. <br><br><h2>  Little about the structure of the server application </h2><br>  I will not tell here how to create an empty Laravel application, you can read about it on <a title="Laravel.com" href="http://laravel.com/">the framework's official website</a> .  Suppose you have already created an application named MySecureApp.  All our code will be located inside the app directory.  Or rather, in addition to the controllers, models and views, let's create one more thing: <br><ol><li>  Inside the app folder, create a lib folder, in it MySecureApp - all our classes will be located here that implement the business logic of the application </li><li>  Inside the app folder, create the keys folder.  It will store our private key. </li><li>  Edit the composer.json file in the application root by adding the following lines: <br><pre><code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">"autoload"</span></span>: { <span class="hljs-string"><span class="hljs-string">"classmap"</span></span>: [ <span class="hljs-string"><span class="hljs-string">"app/commands"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/controllers"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/models"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/database/migrations"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/database/seeds"</span></span>, <span class="hljs-string"><span class="hljs-string">"app/tests/TestCase.php"</span></span> ], <span class="hljs-string"><span class="hljs-string">"psr-0"</span></span>: { <span class="hljs-string"><span class="hljs-string">"MySecureApp"</span></span>: <span class="hljs-string"><span class="hljs-string">"app/lib"</span></span> } },</code> </pre> <br>  After that, you need to run the command so that the auto-loader sees our classes: <br><pre>  composer dump-autoload </pre><br></li><li>  Our application itself should have the following directory structure: <br><pre>  / app
   / lib
     / MySecureApp
       / Cryptography - classes that directly implement encryption
       / Dto - Data Transfer Objects
         / Responses - our API response classes
       / Facades - Facades for convenient access to some classes
       / Filters - filters
       / Helpers - helpers classes
       / Providers - Service providers registering our functionality in the Laravel application. </pre><br>  Gradually, we fill these directories with classes. </li></ol><br><br><h2>  Client-server interaction </h2><br>  All interaction between the client application and the server will occur through a single controller - ApiController.  That is, through Urls of the form <a href="http://mysecureapp/api/">mysecureapp / api</a> * <br><br>  The logic is as follows: the client sends a POST request to the api method of interest, passing each parameter in encrypted form.  In response, the server returns a JSON response of the form: <br><pre> <code class="javascript hljs">{ <span class="hljs-string"><span class="hljs-string">"data"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;AES encrypted JSON object&gt;"</span></span>, <span class="hljs-string"><span class="hljs-string">"sign"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;RSA signature of data&gt;"</span></span> }</code> </pre> <br><br><h2>  Cryptography implementation </h2><br>  As a symmetric encryption algorithm will use AES.  Asymmetric - RSA.  Fortunately, the phpseclib cryptographic library is already included with Laravel, which contains everything we need.  Let's start with RSA. <br><br>  For RSA, we need a pair of keys - open and closed.  Well, more precisely if we talk about the server implementation, then you only need the private key.  The public key will be needed by the client.  Let's generate this key pair. <br><br>  To do this, we need OpenSSL installed on the computer.  As far as I know, on Linux systems it is installed by default.  For Windows, you can download it from here: <a href="http://slproweb.com/products/Win32OpenSSL.html">http://slproweb.com/products/Win32OpenSSL.html</a> .  Personally, I had difficulties using Light distros - they did not have openssl.cfg necessary for work.  Therefore, it is advisable to download and install the full version (~ 19 MB).  After installation, you need to create the environment variable OPENSSL_CONF, indicating the above config.  This can be done in the console by typing <br><pre>  set OPENSSL_CONF = \ path \ to \ openssl.cfg </pre><br>  Let's start creating keys.  Run the command line and go (cd) to the directory where you just installed openssl, or rather into the subdirectory bin.  To generate the private key, run the following two commands in succession: <br><pre>  openssl genrsa -aes256 -out temp.key 1024
 openssl rsa -in temp.key -out private.key </pre><br>  Now, based on the received key, we will generate an X509 certificate, or in other words, the public key: <br><pre>  openssl req -new -x509 -nodes -sha1 -key private.key -out public.crt -days 365000 </pre><br>  You will be asked a few questions that you don‚Äôt need to answer.  You can answer anything. <br>  Total we have: <br><ol><li>  private.key - private key </li><li>  public.crt - open </li></ol><br>  Transfer them to the app / keys folder already prepared for this, and add the following line to the application config (app / config / app.php): <br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">'privateKey'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'private.key'</span></span>,</code> </pre> <br>  Before proceeding with the implementation of RSA, let's create an auxiliary class for encoding / decoding strings to / from Base64.  Create the file app / lib / MySecureApp / Helpers / Base64.php with the following contents: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Helpers</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base64</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UrlDecode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> base64_decode(str_replace(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'_'</span></span>,<span class="hljs-string"><span class="hljs-string">'-'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>,<span class="hljs-string"><span class="hljs-string">'+'</span></span>), $x)); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UrlEncode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str_replace(<span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'/'</span></span>,<span class="hljs-string"><span class="hljs-string">'+'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(<span class="hljs-string"><span class="hljs-string">'_'</span></span>,<span class="hljs-string"><span class="hljs-string">'-'</span></span>), base64_encode($x)); } }</code> </pre> <br>  Well, now proceed directly to the implementation of RSA.  To do this, create a <b>Cryptography</b> class in <i>app / lib / MySecureApp / Cryptography / Cryptography.php</i> : <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Helpers</span></span>\<span class="hljs-title"><span class="hljs-title">Base64</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cryptography</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * RSA instance * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Crypt_RSA */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $rsa; <span class="hljs-comment"><span class="hljs-comment">/** * RSA private key * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> string */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $rsaPrivateKey; <span class="hljs-comment"><span class="hljs-comment">/** * Whether RSA instance is initialized * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $isRsaInitialized = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Initializes the RSA instance using either provided private key file or config value * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> String $privateKeyFile Path to private key file * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initRsa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($privateKeyFile = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// } /** * Decrypts RSA-encrypted data * @param String $data Data to decrypt * @return String */ public function rsaDecrypt($data) { // } /** * Encrypts data using RSA * @param String $data Data to encrypt * @return String */ public function rsaEncrypt($data) { // } /** * Signs provided data * @param String $data Data to sign * @throws \Exception * @return string Signed data */ public function rsaSign($data) { // } }</span></span></code> </pre> <br><blockquote>  <strong>A small note</strong> : the proposed version of the <b>Cryptography</b> class does not quite correspond to the principles of SOLID design.  I am doing this intentionally for the purpose of simplifying the material.  I will tell you how to improve it at the end of the article. </blockquote><br>  Let's start filling in the RSA methods.  Let's start with <strong>rsaInit ()</strong> .  The algorithm is simple: we read the private key passed to us in the parameter, or taken from the config, and initialize the class <strong>Crypt_RSA</strong> supplied by the <em>phpseclib</em> library: <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initRsa</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($privateKeyFile = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">''</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    ,     if (!$privateKeyFile) { $privateKeyFile = app_path() . '/keys/' . \Config::get('app.privateKey'); } // ,     if (!\File::exists($privateKeyFile)) { Log::error("Error reading private key file."); throw new Exception("Error reading private key file."); } $this-&gt;rsaPrivateKey = \File::get($privateKeyFile); //   RSA $rsa = new \Crypt_RSA(); $rsa-&gt;setEncryptionMode(CRYPT_RSA_ENCRYPTION_PKCS1); $rsa-&gt;loadKey($this-&gt;rsaPrivateKey); //       //    true    // ()  $this-&gt;rsa = $rsa; $this-&gt;isRsaInitialized = true; }</span></span></code> </pre> <br>  Now we implement the methods themselves for the work handed over: <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rsaDecrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  RSA       if (!$this-&gt;isRsaInitialized) { $this-&gt;initRsa(); } //   return $this-&gt;rsa-&gt;decrypt(Base64::UrlDecode($data)); } // ... public function rsaEncrypt($data) { //  rsaDecrypt if (!$this-&gt;isRsaInitialized) { $this-&gt;initRsa(); } return Base64::UrlEncode($this-&gt;rsa-&gt;encrypt($data)); } // ... public function rsaSign($data) { if (!$this-&gt;isRsaInitialized) { $this-&gt;initRsa(); } // ,   PHP- openssl if (!function_exists('openssl_sign')) { throw new \Exception("OpenSSL is not enabled."); } //   $signature = ''; $keyId = openssl_get_privatekey($this-&gt;rsaPrivateKey); openssl_sign($data, $signature, $keyId); openssl_free_key($keyId); return $signature; }</span></span></code> </pre> <br>  Note that the rsaDecrypt method expects the transmitted data to be encoded in Base64.  Symmetrically, rsaEncrypt returns encrypted data encoded in Base64. <br><br>  At this RSA part of the <b>Cryptography</b> class is completed.  We proceed to AES. <br><br>  Add fields to the class: <br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * AES instance * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> \Crypt_AES */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $aes; <span class="hljs-comment"><span class="hljs-comment">/** * Whether AES instance is initialized * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> bool */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $isAesInitialized = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>;</code> </pre> <br>  Now the methods are: <br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">/** * Initializes AES instance using either provided $options or session values * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> array $options Array of options, containing 'key' and 'iv' values * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@throws</span></span></span><span class="hljs-comment"> Exception */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initAes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($options = array</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// ... } /** * Encrypts data using AES * @param String $data Data to encrypt * @return String */ public function aesEncrypt($data) { // ... } /** * Decrypts AES encrypted data * @param String $data Data to decrypt * @return String */ public function aesDecrypt($data) { // ... }</span></span></code> </pre> <br>  Initialize AES: <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initAes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($options = array</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  $options ,      if (empty($options) &amp;&amp; Session::has('aes_key') &amp;&amp; Session::has('aes_iv')) { $options = array( 'key' =&gt; Session::get('aes_key'), 'iv' =&gt; Session::get('aes_iv'), ); } //       ,    if (!(isset($options['key']) &amp;&amp; isset($options['iv']))) { Log::error("Either key or iv not set"); throw new Exception("Either key or iv not set"); } //     Session::put('aes_key', $options['key']); Session::put('aes_iv', $options['iv']); //  Crypt_AES,   phpseclib $aes = new \Crypt_AES(CRYPT_AES_MODE_CBC); $aes-&gt;setKeyLength(256); $aes-&gt;setKey(Base64::UrlDecode($options['key'])); $aes-&gt;setIV(Base64::UrlDecode($options['iv'])); $aes-&gt;enablePadding(); //     $this-&gt;aes = $aes; $this-&gt;isAesInitialized = true; }</span></span></code> </pre> <br>  Now the data processing methods themselves: <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aesEncrypt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     RSA if (!$this-&gt;isAesInitialized) { $this-&gt;initAes(); } return $this-&gt;aes-&gt;encrypt($data); } public function aesDecrypt($data) { if (!$this-&gt;isAesInitialized) { $this-&gt;initAes(); } return $this-&gt;aes-&gt;decrypt($data); }</span></span></code> </pre> <br>  On this class <b>Cryptography is</b> ready.  But for now this is only a tool, and how to use it, even though it seems obvious, will be shown further. <br><br>  Next we need a tool that would give the decrypted incoming data.  What I mean?  For example, a client wants to log in, and for this he (I am a little ahead of myself), sends a POST request to <a href="http://mysecureapp/api/login">mysecureapp / api / login</a> with the following data: email = asdpofih345kjafg and password = zxcvzxcvzxcvzxcv - this is AES encrypted data.  To get the decrypted data, we need a class similar to the Input facade, but returning the already decrypted data.  <strong>Name</strong> it <strong>DecryptedInput</strong> and create it in <i>app / lib / MySecureApp / Cryptography / DecryptedInput.php</i> .  We implement in it the most popular Input'a methods: get (), all () and only (): <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Helpers</span></span>\<span class="hljs-title"><span class="hljs-title">Base64</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Provides funcitonality for getting decrypted Input paramters * (encrypted with AES) * Class DecryptedInput * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@package</span></span></span><span class="hljs-comment"> MySecureApp\Cryptography */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecryptedInput</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Array of raw (non-decrypted) input parameters * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $params; <span class="hljs-comment"><span class="hljs-comment">/** * Array of decrypted values * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> array */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $decryptedParams = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>(); <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Cryptography */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $crypt; <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@param</span></span></span><span class="hljs-comment"> Cryptography $crypt Injected Cryptography object used for decrypting */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cryptography $crypt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     Cryptography //  $this-&gt;crypt = $crypt; //     $params $this-&gt;params = \Input::all(); } /** * Returns decrypted input parameter * @param $key * @return String */ public function get($key) { // ,        if (isset($this-&gt;decryptedParams[$key])) { return $this-&gt;decryptedParams[$key]; } //  $value = $this-&gt;crypt-&gt;aesDecrypt(Base64::UrlDecode($this-&gt;params[$key])); //     $this-&gt;decryptedParams[$key] = $value; //    return $value; } /** * Returns all input params decrypted * @return array */ public function all() { //       foreach ($this-&gt;params as $key =&gt; $value) { $this-&gt;decryptedParams[$key] = $this-&gt;get($key); } //      return $this-&gt;decryptedParams; } /** * Returns only specified input parameters * @return array */ public function only() { $args = func_get_args(); $result = array(); foreach($args as $arg) { $result[$arg] = $this-&gt;get($arg); } return $result; } }</span></span></code> </pre> <br>  Pay attention to line 33: a copy of <b>Cryptography</b> is passed to the constructor.  But you see, it would be inconvenient for us to constantly ‚Äúmanually‚Äù initialize this class, so we will proceed in the best traditions of Laravel - so that it does everything for us. <br><br>  To do this, we do the following: <br><ol><li>  Let's <b>make a</b> facade from <b>DecryptedIntput</b> , exactly the same as usual <b>Input</b> </li><li>  Make <b>Cryptography</b> singleton. </li><li>  ‚ÄúRegistering‚Äù the whole thing inside our own <i><b>Service Provider</b></i> . </li></ol><br>  So, let's go in order.  Making the facade <b>DecryptedInput</b> .  To do this, create a file DecryptedInput.php in <i>app / lib / MySecureApp / Facades</i> : <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Facades</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Illuminate</span></span>\<span class="hljs-title"><span class="hljs-title">Support</span></span>\<span class="hljs-title"><span class="hljs-title">Facades</span></span>\<span class="hljs-title"><span class="hljs-title">Facade</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DecryptedInput</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Facade</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getFacadeAccessor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// " ",     // DecryptedInput   return 'decryptedinput'; } }</span></span></code> </pre> <br>  Perhaps you will have a confusion in the names: we have two classes named DecryptedInput: one is an analogue of Input, the other is its facade, they just have different namespaces.  Therefore, it would probably be more logical to rename the facade to <b>DecryptedInputFacade</b> .  But this is only information on the note - you decide.  Thanks to namespaces, we can always specify exactly which class we are going to use. <br><br>  Now everything is ready for us to write our own Service Provider (I write it in English, because I haven‚Äôt yet come up with a decent translation of this term, literally it will be a service provider, but I prefer the service provider).  Create a <b>CryptoServiceProvider.php</b> file in <i>app / lib / MySecureApp / Providers</i> with the following contents: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Providers</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Illuminate</span></span>\<span class="hljs-title"><span class="hljs-title">Foundation</span></span>\<span class="hljs-title"><span class="hljs-title">AliasLoader</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">Illuminate</span></span>\<span class="hljs-title"><span class="hljs-title">Support</span></span>\<span class="hljs-title"><span class="hljs-title">ServiceProvider</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>\<span class="hljs-title"><span class="hljs-title">DecryptedInput</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CryptoServiceProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * Register the service provider. * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@return</span></span></span><span class="hljs-comment"> void */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">register</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   Cryptograpgy $this-&gt;app-&gt;singleton('cryptography', function() { return new Cryptography(); }); //    Input'   'decryptedinput' $this-&gt;app['decryptedinput'] = $this-&gt;app-&gt;share(function($app) { return new DecryptedInput($app['cryptography']); }); //     DirectInput' $this-&gt;app-&gt;booting(function() { $loader = AliasLoader::getInstance(); $loader-&gt;alias('DecryptedInput', 'MySecureApp\Facades\DecryptedInput'); }); } }</span></span></code> </pre> <br>  Well, I can congratulate us on the fact that we have done half the work.  There are still as many.  Just kidding, a little less ... In fact, by this time we only prepared an arsenal of tools that we still have to use. <br><br>  You can rest.  In the meantime, I will briefly tell you how it works.  I'll start with <b>DecryptedInput</b> 'a.  Now we can use it like this: <br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... $email = DecryptedInput::get('email'); $password = DecryptedInput::get('password'); //  ... extract(DecryptedInput::only('email', 'password')); //    2  : // $email  $password</span></span></code> </pre> <br>  How does this happen?  Thanks to the alias registered in the provider, Laravel knows that when referring to the <strong>DecryptedInput</strong> class, <strong>we</strong> need to use the facade we have made.  And how does the facade work?  Thanks to the key (accessor) ' <i>decryptedinput</i> ' returned by the <strong>getFacadeAccessor ()</strong> method, Laravel knows that for all calls to static facade methods, the methods <strong>\ MySecureApp \ Cryptography \ DecryptedInput</strong> (the key 'decryptedinput' must be registered by the provider) <strong>must be pulled</strong> : <br><pre> <code class="php hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... $this-&gt;app['decryptedinput'] = $this-&gt;app-&gt;share(function($app) { //   DecryptedInput    // Input',  )    , //  )      // use MySecureApp/Cryptography/DecryptedInput //   ,     //  Cryptography,   return new DecryptedInput($app['cryptography']); }); // ...</span></span></code> </pre> <br>  Well, we can continue :) As I already mentioned, all client interaction with the server occurs through <b>ApiController</b> .  What is special about this controller? <br><ol><li>  Encrypted data is sent to it. </li><li>  It must return an encrypted response. </li></ol><br>  We have already figured out how to deal with the received encrypted data - there is a <strong>DecryptedInput</strong> for this.  And how to return the ciphered answer?  Yes, and signed?  Perhaps someone will come to mind in each method of the controller to encrypt data.  But this is not a good approach.  First, you need to follow the same data format in all methods.  Secondly, it is an unnecessary copy-paste in each method (I mean data encryption).  Here we will come to the aid of a great chip Laravel - filters.  Namely, we need only one after filter that will encrypt and format all outgoing data.  Thus, all methods of the API controller will simply return the data itself in a clean (plain) form, and the after-filter will already encrypt and sign it. <br><br>  Well, let's write this filter.  Create an <b>OutgoingCryptFilter.php</b> file in <i>app / lib / MySecureApp / Filters</i> with the following contents: <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Filters</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Helpers</span></span>\<span class="hljs-title"><span class="hljs-title">Base64</span></span>; <span class="hljs-comment"><span class="hljs-comment">/** * Class OutgoingCryptFilter * Encrypts and signs the response * * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@package</span></span></span><span class="hljs-comment"> MySecureApp\Filter */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OutgoingCryptFilter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $crypt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cryptography $crypt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      , //        //  Cryptography - Laravel    $this-&gt;crypt = $crypt; } //   public function filter($route, $request, $response) { //    ,   //   $content = $response-&gt;getOriginalContent(); if (!is_string($content)) { $content = json_encode($content); } //   $content = Base64::UrlEncode($this-&gt;crypt-&gt;aesEncrypt($content)); //    $sign = Base64::UrlEncode($this-&gt;crypt-&gt;rsaSign($content)); //    (  ) : // 'data' =&gt; $content, -  // 'sign' =&gt; $sign, -  // ""   ,     $response-&gt;setContent(['data' =&gt; $content, 'sign' =&gt; $sign]); } }</span></span></code> </pre> <br>  As you can see, the filter is quite simple.  I want to once again pay attention to the constructor: it will be called when creating the filter by Laravel, and he is smart enough to recognize the parameters of the constructor and substitute the required object. <br><br>  Now you need to register this filter.  We will not be philosophical here and use the space provided for this: <i>app / filters.php</i> : <br><pre> <code class="php hljs"><span class="hljs-comment"><span class="hljs-comment">//   cryptOut Route::filter('cryptOut', 'MySecureApp\Filters\OutgoingCryptFilter');</span></span></code> </pre> <br>  Left just a little bit.  Write the controller itself with at least two methods: initialization of the connection between the client and the server (the so-called handshake) and which thread is a demonstration method that returns data. <br><br>  I will use an example from my own life.  The goal is to authorize the client application and return to it information about whether it is allowed to run (something like a license check). <br><br>  So, here is the <strong>ApiController</strong> controller <strong>structure</strong> : <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>\<span class="hljs-title"><span class="hljs-title">Cryptography</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ApiController</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Crypt */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $crypt; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cryptography $crypt)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;crypt = $crypt; <span class="hljs-comment"><span class="hljs-comment">//  after- (    ) //     :    except: //       postInit,    //       $this-&gt;afterFilter('cryptOut', array('except' =&gt; 'postInit')); } //  ()     //   :    RSA- //   AES .     : key  iv public function postInit() { // ,    if (!(Input::has('key') &amp;&amp; Input::has('iv'))) { return 'ERROR 1'; } //     $key  $iv extract(Input::only('key', 'iv')); //   $key = $this-&gt;crypt-&gt;rsaDecrypt($key); $iv = $this-&gt;crypt-&gt;rsaDecrypt($iv); //       == false (  ) //    if (!($key &amp;&amp; $iv)) { return 'ERROR 2'; } //  AES   $this-&gt;crypt-&gt;initAes(array( 'key' =&gt; $key, 'iv' =&gt; $iv, )); return 'OK'; } }</span></span></code> </pre> <br>  This was the initialization of the client's interaction with the server.  If successful, the client will return just a text message OK.  In case of error, ERROR.  I deliberately did not return the text error message - a potential hacker does not need to know what is going on here. <br><br>  Now let's write some method that would already require encryption.  I propose to write an authorization.  The client sends us his email and password, and in return the server returns data: whether the client has successfully logged in or not, and when his license expires.  I will be limited only to the controller and Dto-object of <b>LoginResponse</b> .  Anyone can write a model himself, for demonstration this will be superfluous. <br><br>  To begin, create a base class for all server responses.  <strong>app / lib / MySecureApp / Dto / Responses / ResponseBase.php</strong> : <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Dto</span></span>\<span class="hljs-title"><span class="hljs-title">Responses</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResponseBase</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> \</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonSerializable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   public $type; }</span></span></code> </pre> <br>  There is simply no place.  For a class, the field alone is the type of response.  Thanks to this field, the client will be able to write something like a package manager.  Now we <strong>‚Äôll</strong> write a specific response: <strong>LoginResponse</strong> ( <i>app / lib / MySecureApp / Dto / Responses / LoginResponse.php</i> ): <br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">MySecureApp</span></span>\<span class="hljs-title"><span class="hljs-title">Dto</span></span>\<span class="hljs-title"><span class="hljs-title">Responses</span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoginResponse</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ResponseBase</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LOGIN_SUCCESS = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LOGIN_FAIL = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> $loginResult; <span class="hljs-comment"><span class="hljs-comment">//   public $expire; // ,      public function __construct() { $this-&gt;type = 'login'; $this-&gt;expire = '0000-00-00 00:00:00'; } /** * (PHP 5 &amp;gt;= 5.4.0)&lt;br/&gt; * Specify data which should be serialized to JSON * @link http://php.net/manual/en/jsonserializable.jsonserialize.php * @return mixed data which can be serialized by &lt;b&gt;json_encode&lt;/b&gt;, * which is a value of any type other than a resource. */ public function jsonSerialize() { return [ 'type' =&gt; $this-&gt;type, 'loginResult' =&gt; $this-&gt;loginResult, 'expire' =&gt; $this-&gt;expire, ]; } }</span></span></code> </pre> <br>  Now the <b>postLogin</b> controller method <b>itself</b> : <br><pre> <code class="php hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postLogin</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//    $creds = [ 'email' =&gt; DecryptedInput::get('email'), 'password' =&gt; DecryptedInput::get('password'), ]; $response = new \MySecureApp\Dto\Responses\LoginResponse; if (!Auth::attempt($creds, false)) { //    ,     loginResult $response-&gt;loginResult = \MySecureApp\Dto\Responses\LoginResponse::LOGIN_FAIL; //   return json_encode($response); } $response-&gt;loginResult = \MySecureApp\Dto\Responses\LoginResponse::LOGIN_SUCCESS; $response-&gt;expire = Auth::user()-&gt;tariffExpire; return json_encode($response); }</span></span></code> </pre> <br>  Well, that's all.  Pay attention to the 4 and 5 lines - we use <b>DecryptedInput</b> to get the data sent to us in POST. <br><br>  Regards, <br>  Alexander [Amega] Egorov. <br><br>  PS I almost forgot, but I promised to tell you how you can change <b>Cryptography</b> for more flexibility.  The problem with this code is that it is completely tied up with a bunch of RSA + AES, and this is even manifested in the names of the methods (aesEncrypt, rsaSign, etc.). And this is not good.  Anything can happen - suddenly you have to abandon these two algorithms and use others? <br><br>  How can I correct the situation (I will give only a theory, without a code - I will leave it to you as homework)? <br><br> -,     ,    /.    asymmetricDecrypt, symmetricEncrypt  ..    <b>Cryptography</b>           <b>RsaAesCryptography</b> . <br><br> -,      App.  ,       <b>Cryptography</b> ,   CryptographyInterface. <br><br>   ,      ,      :     (  CryptographyInterface)   ,   CryptographyInterface      . <br><br>    . <br><br> PPS  -:  .  <i>app/routes.php</i> : <br><pre> <code class="php hljs">Route::controller(<span class="hljs-string"><span class="hljs-string">'api'</span></span>, <span class="hljs-string"><span class="hljs-string">'ApiController'</span></span>);</code> </pre> <br>    Service Provider.  <i>app/config/app.php</i> : <br><pre> <code class="php hljs"><span class="hljs-string"><span class="hljs-string">'providers'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>( <span class="hljs-comment"><span class="hljs-comment">// ... 'MySecureApp\Providers\CryptoServiceProvider', ),</span></span></code> </pre><br><br> <b>UPD</b> :       : <a href="https://packagist.org/packages/amegatron/cryptoapi">Amegatron/Cryptoapi</a> </div><p>Source: <a href="https://habr.com/ru/post/209612/">https://habr.com/ru/post/209612/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../209594/index.html">Making hardware startups becomes easier.</a></li>
<li><a href="../209600/index.html">Surprise from the unknown: trust in Chrome extensions</a></li>
<li><a href="../209604/index.html">The existence of DOU.ua in the framework of the Ukrainian legal field is not possible</a></li>
<li><a href="../209606/index.html">The future of hardware accelerator programming</a></li>
<li><a href="../209610/index.html">Introduction to optimization. Annealing imitation</a></li>
<li><a href="../209614/index.html">Begin courses "Universarium"</a></li>
<li><a href="../209616/index.html">Role-playing technology. Part 3. Technology in the entourage and mastering</a></li>
<li><a href="../209618/index.html">Why not use RJS</a></li>
<li><a href="../209624/index.html">Panorama of the Moon from "Chang'e 3" and the failure of the main color camera of the landing module</a></li>
<li><a href="../209626/index.html">Lightpack. Unboxing and installation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>