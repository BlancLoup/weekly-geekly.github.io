<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Yury Bushmelev "Map of the rake in the field of collecting and delivering logs" - decoding the report</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Logs - an important part of the system, allowing to understand that it works (or does not work), as expected. In the conditions of microservice archit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Yury Bushmelev "Map of the rake in the field of collecting and delivering logs" - decoding the report</h1><div class="post__text post__text-html js-mediator-article"><p>  Logs - an important part of the system, allowing to understand that it works (or does not work), as expected.  In the conditions of microservice architecture, work with logs becomes a separate discipline of a special Olympiad.  Need to solve a bunch of questions right away: </p><br><ul><li>  how to write logs from the application; </li><li>  where to write logs; </li><li>  how to deliver logs for storage and processing; </li><li>  how to process and store logs. </li></ul><br><p>  The use of currently popular containerization technologies adds sand over the rake to the field of solutions to the problem. </p><br><p>  Just about this, the transcript of the report of Yury Bushmelev "Map of the rake on the field of collecting and delivering logs" </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/NAeedJv-S3I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Who cares, I ask under the cat. </p><a name="habracut"></a><br><p>  My name is Yury Bushmelev.  I work in Lazada.  Today I will talk about how we made our logs, how we collected them, and what we write there. </p><br><p><img src="https://habrastorage.org/webt/_9/te/o5/_9teo5cvnhsihs4lyyyc_8pcx-m.png"></p><br><p>  Where are we from?  Who are we?  Lazada is the # 1 online store in six countries in Southeast Asia.  All of these countries we have distributed data centers.  Total data centers are now 4. Why is this important?  Because some decisions were due to the fact that there is a very weak link between the centers.  We have microservice architecture.  I was surprised to find that we already have 80 microservices.  When I started the task with logs, there were only 20. Plus, there is a fairly large piece of PHP legacy, with which you also have to live and put up.  All this generates us at the moment more than 6 million messages per minute on the system as a whole.  Then I will show how we are trying to live with it, and why this is so. </p><br><p><img src="https://habrastorage.org/webt/gy/fj/du/gyfjduafaipfx1ay5efm8xpwtdc.png"></p><br><p>  With these 6 million messages you need to somehow live.  What should we do with them?  6 million messages you need: </p><br><ul><li>  send from app </li><li>  accept for delivery </li><li>  deliver for analysis and storage. </li><li>  to analyze </li><li>  somehow stored. </li></ul><br><p><img src="https://habrastorage.org/webt/vq/kr/yt/vqkrytwk4c_gjs9fza8_zn9hanu.png"></p><br><p>  When there were three million posts, I had about the same look.  Because we started with some cents.  It is clear that application logs are written there.  For example, I could not connect to the database, I could connect to the database, but I could not read something.  But besides this, each of our microservice also writes an access-log.  Every request that arrives at microservice falls into the log.  Why do we do this?  Developers want to be able to trace.  In each access-log there is a traceid field, through which the special interface further spins the whole chain and beautifully shows the trace.  Trace shows how the request passed, and it helps our developers to quickly deal with any unidentified garbage. </p><br><p><img src="https://habrastorage.org/webt/me/fd/7d/mefd7deeshbhsvsjb8n7dh81ok4.png"></p><br><p>  How to live with it?  Now I will briefly tell the field of options - how is this problem solved at all?  How to solve the problem of collecting, transmitting and storing logs. </p><br><p><img src="https://habrastorage.org/webt/0m/f8/4r/0mf84rxvsn0ewrqui_4egxgb2hk.png"></p><br><p>  How to write from the application?  It is clear that there are different ways.  In particular, there is a best practice, as fashionable comrades tell us.  There are old school in two forms, as the grandfathers said.  There are other ways. </p><br><p><img src="https://habrastorage.org/webt/le/7-/_n/le7-_n8o7wl8nh4g0qadwz-jucq.png"></p><br><p>  With the collection of logs about the same situation.  There are not many solutions to this particular part.  They are already more, but not so much. </p><br><p><img src="https://habrastorage.org/webt/kn/id/o2/knido22_ecpa0cgvfjzissz3fei.png"></p><br><p>  But with the delivery and subsequent analysis - the number of variations begins to explode.  I will not describe each option now.  I think the main options are heard by everyone who was interested in the topic. </p><br><p><img src="https://habrastorage.org/webt/qu/zg/z0/quzgz0a21pgjdb0o8ek5d3nxmwc.png"></p><br><p>  I will show how we did it in Lazada, and how it all began. </p><br><p><img src="https://habrastorage.org/webt/tu/b_/xt/tub_xtgrnyznjspm2vxf_lepv7o.png"></p><br><p> A year ago, I came to Lazada, and they sent me to a project about logs.  There was something like this.  The log from the application was written to stdout and stderr.  All done in a fashionable way.  But then the developers have thrown it out of the standard streams, and then somehow the infrastructure specialists will sort it out.  Between the infrastructure specialists and the developers, there are still releasers who said: "uh ... well, let's wrap them in a file just with the shell, that's all."  And since all of this is in a container, it is wrapped right in the container itself, the catalog inside the container and put it there.  I think it‚Äôs pretty obvious to everyone what came out of it. </p><br><p><img src="https://habrastorage.org/webt/l2/pl/lz/l2pllz5jvccjhbz0zzxcitkrmsk.png"></p><br><p>  Let's look a little further away.  How we delivered these logs.  Someone chose a td-agent, which is actually fluentd, but not quite fluentd.  I still do not understand the relationship of these two projects, but they seem to be about the same thing.  And this fluentd, written in Ruby, read log files, parsed them in JSON for some regulars.  Then they sent them to Kafka.  And in Kafka for each API we had 4 separate topics.  Why 4?  Because there is live, there is staging, and because there is stdout and stderr.  The developers of them produce, and the infrastructure workers should create them in Kafka.  Moreover, Kafka was controlled by another department.  Therefore, it was necessary to create a ticket, so that they created there 4 topics for each api.  Everyone forgot about it.  In general, there was trash and waste. </p><br><p><img src="https://habrastorage.org/webt/x9/2-/5s/x92-5sqis-vgly1ccyh0gjt2mxy.png"></p><br><p>  What did we do next with this?  We sent it to the kafka.  Further from a kafka half of logs flew away to Logstash.  The other half of the logs shared.  Part flew into one Graylog, part flew into another Graylog.  As a result, all this flew into one cluster of Elasticsearch.  That is, all this mess fell in the end there.  So do not! </p><br><p><img src="https://habrastorage.org/webt/ge/w9/kz/gew9kzazsmr5pwee16cuyor6n2w.png"></p><br><p>  This is how it looks if viewed remotely from above.  Don't do that!  Here are the numbers immediately marked problem areas.  Actually, there are more of them, but 6 - these are the very problem with which you have to do something.  I will tell you about them separately now. </p><br><p><img src="https://habrastorage.org/webt/2w/xu/eb/2wxuebmewhsjvjbr_9taaq5zhn4.png"></p><br><p>  Here (1,2,3) we write files and, accordingly, here are three rakes at once. </p><br><p>  The first (1) is that we need to write them somewhere.  I would not always like to give the API the ability to write directly to a file.  It is desirable that the API was isolated in a container, and even better - that it was read-only.  I am a sysadmin, so I have a bit of an alternative look at these things. </p><br><p>  The second point (2.3) - we have a lot of requests coming to the API.  The API writes a lot of data to the file.  Files grow.  We need to rotate them.  Because otherwise there will not be enough discs.  It‚Äôs bad to rotate them because they are redirected through the shell to the directory.  We can't do it in any way.  The application cannot be told to rediscover its descriptors.  Because the developers will look at you like a fool: "What descriptors?  We generally write to stdout. ‚Äù  The infrastructure designers made a copytruncate in logrotate, which makes a simple copy of the file and truncates the original.  Accordingly, between these processes of copying and usually ends up disk space. </p><br><p>  (4) We had different formats were in different APIs.  They were a little different, but regexp had to be different.  Since it was all driven by Puppet, there was a big bundle of classes with its cockroaches.  Plus, td-agent most of the time could have a memory, be stupid, he could just pretend that it was working, and do nothing.  From the outside it was impossible to understand that he was doing nothing.  At best, he will fall, and someone will pick it up later.  More precisely, the alert will arrive, and someone will go over the hands. </p><br><p><img src="https://habrastorage.org/webt/x9/8i/a-/x98ia-rs9owg6hl2qqkfjpza-yg.png"></p><br><p>  (6) And the most trash and waste - it was elasticsearch.  Because it was the old version.  Because, we did not have dedicated masters at that time.  We had heterogeneous logs whose fields could intersect.  Different logs of different applications could be written with the same field names, but there could be different data inside.  That is, one log comes with an Integer in the field, for example, level.  Another log comes with a String in the level field.  In the absence of static mapping, this is a wonderful thing.  If after rotation of the index in elasticsearch the first message arrived with the string, then we live normally.  And if here the first has arrived with Integer, then all subsequent messages which arrived with String, are simply discarded.  Because the field type does not match. </p><br><p><img src="https://habrastorage.org/webt/c9/ym/lq/c9ymlqxv89qg1oohi-lnhknyedg.png"></p><br><p>  We started asking these questions.  We decided not to look for the guilty. </p><br><p><img src="https://habrastorage.org/webt/fl/r1/kv/flr1kvyks_o2kdciv4pekiwtbiy.png"></p><br><p>  But something must be done!  The obvious thing is to make standards.  We already had some standards.  Some we got a little later.  Fortunately, the uniform log format for all APIs was already approved at that time.  It is written directly into the standards of interaction of services.  Accordingly, those who want to receive logs should write them in this format.  If someone does not write logs in this format, it means that we do not guarantee anything. </p><br><p>  Further, I would like to have a single standard for ways to record, deliver and collect logs.  Actually, where to write them, and what to deliver them.  The ideal situation is when projects use the same library.  There is a separate logging library for Go, there is a separate library for PHP.  All who we have - everyone should use them.  At the moment, I would say that at 80 percent we get it.  But some continue to eat cacti. </p><br><p>  And there (on the slide) barely begins to show ‚ÄúSLA for logging delivery‚Äù.  He is not there yet, but we are working on it.  Because it is very convenient when infra says that if you write in such and such a format in such and such a place and no more than N messages per second, then we are likely to deliver this and that there.  This removes a bunch of headaches.  If there is an SLA, then it is just wonderful! </p><br><p><img src="https://habrastorage.org/webt/im/aq/aj/imaqajo2oi-qoyb--oja3i2fnyy.png"></p><br><p>  How did we start to solve the problem?  The main rake was with td-agent.  It was not clear where we go logs.  Are they delivered?  Are they going?  Where are they at all?  Therefore, the first point was to replace the td-agent.  Options for what to replace it, in short, I sketched here. </p><br><p>  Fluentd.  Firstly, I came across him in a previous work, and he also periodically fell there.  Secondly, it is the same, only in profile. </p><br><p>  Filebeat  How was he comfortable for us?  That he on Go, and we have a big examination in Go.  Accordingly, if anything, we could somehow add it to ourselves.  Therefore, we did not take it.  To even the temptation of any was not to begin to rewrite it for themselves. </p><br><p>  The obvious solution for the sysadmin is any syslog here in this quantity (syslog-ng / rsyslog / nxlog). </p><br><p>  Either write something of our own, but we dropped it, as did the filebeat.  If you write something, then it is better to write something useful for business.  For delivery of logs it is better to take something ready. </p><br><p>  Therefore, the choice actually came down to a choice between syslog-ng and rsyslog.  I leaned toward rsyslog simply because we already had classes for rsyslog in Puppet, and I didn‚Äôt find an obvious difference between them.  What is syslog, what is syslog.  Yes, someone's documentation is worse, someone's better.  He knows how, but he does it differently. </p><br><p><img src="https://habrastorage.org/webt/xl/wg/7y/xlwg7yv4du2k8ktumnmdltwci78.png"></p><br><p>  And a little bit about rsyslog.  Firstly, it's cool because it has a lot of modules.  It has a human-understandable RainerScript (modern configuration language).  Awesome bonus that we could emulate the behavior of td-agent with its regular means, and nothing changed for the applications.  That is, we change the td-agent to rsyslog, but for the time being we don‚Äôt touch the rest.  And we immediately get a working delivery.  Next, mmnormalize is an awesome thing on rsyslog.  It allows you to parse logs, but not with Grok and regexp.  It makes an abstract syntax tree.  It parses the logs about how the compiler parses the sources.  This allows you to work very quickly, eat little CPU, and, in general, is a very cool thing.  There are a bunch of other bonuses.  I will not dwell on them. </p><br><p><img src="https://habrastorage.org/webt/tf/6w/c0/tf6wc0eulg65fu-dy64mmkjyr4g.png"></p><br><p>  Rsyslog has a lot of flaws.  They are about the same as bonuses.  The main problems are to be able to prepare it, and it is necessary to select a version. </p><br><p><img src="https://habrastorage.org/webt/p-/2l/l5/p-2ll5-sxmfivl2136kopu1oipi.png"></p><br><p>  We decided that we will write logs in unix socket.  And not in / dev / log, because there we have porridge from system logs, there is journald in this pipeline.  So let's write to the custom socket.  We will hook him to a separate ruleset.  We will not interfere with anything.  Everything will be transparent and clear.  So we actually did.  The directory with these sockets is standardized and forwarded to all containers.  Containers can see the socket they need, open and write it. </p><br><p>  Why not a file?  Because everyone read the <a href="https://habr.com/ru/company/badoo/blog/280606/">article about Badushechka</a> , who tried to forward the file to the docker, and it was discovered that after the restart of rsyslog the file descriptor changes, and the docker loses this file.  He keeps something else open, but no longer the socket where they write.  We decided that we would bypass this problem, and, at the same time, we would bypass the blocking problem. </p><br><p><img src="https://habrastorage.org/webt/ri/kn/r9/riknr9odspcwgtmywqapeq1htmi.png"></p><br><p>  Rsyslog makes the actions indicated on the slide and sends logs either to relay or to Kafka.  Kafka corresponds to the old way.  Rayleigh - I tried to use pure rsyslog to deliver logs.  Without Message Queue, standard rsyslog tools.  Basically, it works. </p><br><p><img src="https://habrastorage.org/webt/wh/bl/fv/whblfvj4lnbmdryfev1fypctp74.png"></p><br><p>  But there are nuances with how to stuff them later in this part (Logstash / Graylog / ES).  This part (rsyslog-rsyslog) is used between data centers.  Here compressed tcp link, which allows you to save bandwidth and, accordingly, somehow increase the likelihood that we will get some logs from another data center in conditions when the channel is clogged.  Because we have Indonesia, in which everything is bad.  There is this constant problem. </p><br><p><img src="https://habrastorage.org/webt/zx/bx/gi/zxbxgimmd3xniduuuw0spq0vg1o.png"></p><br><p>  We thought about how we actually monitor, with what probability the logs, which we recorded from the application, reach the end?  We decided to have metrics.  Rsyslog has its own statistics collection module, which has some counters.  For example, he can show you the size of the queue, or how many messages came in an action.  You can already take something from them.  Plus, it has custom counters that can be configured, and it will show you, for example, the number of messages that an API recorded.  Next, I wrote rsyslog_exporter in Python, and we all sent it to Prometheus and built the graphics.  Graylog metrics are very desirable, but so far we have not managed to set them up. </p><br><p><img src="https://habrastorage.org/webt/kq/b0/-1/kqb0-1ox3sevtkje8qnb7ekp1is.png"></p><br><p>  What are the problems?  Problems arose with the fact that we discovered (EXTREMELY!) That our Live APIs write 50k messages per second.  This is only a live API without staging.  And Graylog shows us only 12 thousand messages per second.  And there was a reasonable question, but where are the remains?  From what we have concluded that Graylog just can not cope.  We looked, and, indeed, Graylog with Elasticsearch did not master this stream. </p><br><p>  Further, other discoveries that we made in the process. </p><br><p>  Writing to socket is blocked.  How did it happen?  When I used rsyslog for delivery, at some point we had a broken channel between data centers.  Stopped shipping in one place, got delivery to another place.  All this has come to the machine with the API, which write to the rsyslog socket.  There is a queue filled.  Then the queue for writing to the unix socket was filled, which by default is 128 packets.  And the next write () in the application is blocked.  When we looked at the library that we use in applications on Go, it was written there that writing to the socket occurs in non-blocking mode.  We were sure that nothing is blocked.  Because we read <a href="https://habr.com/ru/company/badoo/blog/280606/">an article about Badushechka</a> , who wrote about it.  But there is a moment.  There was still an endless loop around this call, in which an attempt was constantly made to push a message into a socket.  Here we have not noticed.  I had to rewrite the library.  Since then, it has changed several times, but now we have got rid of locks in all subsystems.  Therefore, you can stop rsyslog, and nothing will fall. </p><br><p>  It is necessary to monitor the size of the queues, which helps not to step on this rake.  First, we can monitor when we start to lose messages.  Secondly, we can monitor that we have, in principle, problems with delivery. </p><br><p>  And another unpleasant moment - amplification 10 times in microservice architecture is very easy.  We have not so many incoming requests, but because of the graph, which these messages run on further, because of access logs, we actually increase the load on the logs about ten times.  I unfortunately did not have time to calculate the exact figures, but microservices - they are.  This must be borne in mind.  It turns out that at the moment the log collection subsystem is the most loaded in Lazada. </p><br><p><img src="https://habrastorage.org/webt/6a/fd/mi/6afdmitt6iid3yqd6cmdgq8_lkq.png"></p><br><p>  How to solve the problem of elasticsearch?  If you need to quickly get logs in one place, so as not to run on all machines, and not collect them there, use the file storage.  This is guaranteed to work.  It is made from any server.  You just need to stick there drives and put syslog.  After that, you are guaranteed in one place all the logs are there.  Then you can slowly adjust elasticsearch, graylog, anything else.  But you will already have all the logs, and, moreover, you can keep them, as far as disk arrays are enough. </p><br><p><img src="https://habrastorage.org/webt/cx/1d/g3/cx1dg33kkvufonoxpwrrpmmabza.png"></p><br><p>  At the time of my report, the scheme began to look like this.  We practically stopped writing to the file.  Now, most likely, we will remove the remains.  On local machines running APIs, we will stop writing to files.  First, there is file storage, which works very well.  Secondly, the place is constantly running out on these machines, it is necessary to monitor it constantly. </p><br><p>  Here is the part with Logstash and Graylog, it really soars.  Therefore, we must get rid of it.  You need to choose one thing. </p><br><p><img src="https://habrastorage.org/webt/w4/bj/po/w4bjpoxgbdggewegwtrg1ao9mpi.png"></p><br><p>  We decided to throw out Logstash and Kibana.  Because we have a security department.  What is the connection?  The connection is that Kibana without X-Pack and without Shield does not allow to differentiate access rights to logs.  Therefore, they took Graylog.  It has it all.  I don't like him, but he works.  We bought a new iron, put a fresh Graylog there and transferred all the logs with strict formats to a separate Graylog.  We solved the problem with different types of identical fields organizationally. </p><br><p><img src="https://habrastorage.org/webt/cn/hr/41/cnhr41tyx4sf0c0skbjqrgbyb90.png"></p><br><p>  What actually comes in the new Graylog.  We just wrote everything down to the docker.  We took a bunch of servers, rolled out three Kafka instances, 7 Graylog servers of version 2.3 (because I wanted Elasticsearch version 5).  All this on raids from the HDD raised.  Saw the indexing rate up to 100 thousand messages per second.  Saw the figure that 140 terabytes of data per week. </p><br><p><img src="https://habrastorage.org/webt/wv/yd/yj/wvydyj9d_mfo3xztj9elcbvpdaa.png"></p><br><p>  And again a rake!  We have two sales coming.  We moved over 6 million posts.  We do not have time to Graylog chew.  Somehow you need to survive again. </p><br><p><img src="https://habrastorage.org/webt/xf/2j/lc/xf2jlclf52i3oi3nsxdksth-xpe.png"></p><br><p>  We survived like this.  Added a little more servers and SSD.  At the moment we live in this way.  Now we chew already 160k messages per second.  We have not yet rested against the limit, so it is not yet clear how much we can really draw from this. </p><br><p><img src="https://habrastorage.org/webt/bn/ck/ss/bnckssznjbmcrm7v4zh7yhgoltw.png"></p><br><p>  These are our plans for the future.  Of these, really, the most important is probably high availability.  We don't have it yet.  Several cars are set up in the same way, but for now everything is going through one car.  It takes time to set up a failover between them. </p><br><p>  Collect metrics with graylog. </p><br><p>  Make a rate limit so that we have one API that goes crazy and doesn‚Äôt kill the bandwidth and everything else. </p><br><p>  And finally, to sign some SLA c developers, that we can serve here so much.  If you write more, then sorry. </p><br><p>  And write documentation. </p><br><p><img src="https://habrastorage.org/webt/cc/hr/az/cchrazzrhareykxd78meljitrso.png"></p><br><p>  Briefly, the results of all that we have experienced.  First, the standards.  Secondly, syslog - cake.  Thirdly, rsyslog works exactly as it is written on the slide.  And let's move on to the questions. </p><br><p>  <strong>Questions</strong> </p><br><p>  <strong>Question</strong> : Why did they decide not to take ... (filebeat?) </p><br><p>  <strong>Answer</strong> : You must write to the file.  I really did not want to.  When your API writes thousands of messages per second, even if you rotate once an hour, this is still not an option.  You can write to the pipe.  What the developers asked me: ‚ÄúAnd what will happen if the process in which we write falls?‚Äù  I just did not find what to answer them, and said: "Well, ok, let's not do that." </p><br><p>  <strong>Question</strong> : Why don't you write logs just in HDFS? </p><br><p>  <strong>Answer</strong> : This is the next stage.  We thought about it at the very beginning, but since, at the moment, there are no resources to do this, it hangs in our long term solution. </p><br><p>  <strong>Question</strong> : Column format would be more suitable. </p><br><p>  <strong>Answer</strong> : I understand everything.  We are "behind" with both hands. </p><br><p>  <strong>Question</strong> : You write in rsyslog.  There you can and TCP, and UDP.  But if UDP, then how do you guarantee delivery? </p><br><p>  <strong>Answer</strong> : There are two points.  First, I immediately tell everyone that we do not guarantee the delivery of logs.  Because when developers come and say: ‚ÄúAnd let us start writing financial data there, and you will put it somewhere in case something happens‚Äù, we answer them ‚ÄúGreat!  Let us start blocking on the record in the socket, and do it in transactions so that guaranteed we put it in the socket and make sure that we received it from the other side. ‚ÄùAnd at that moment everyone doesn‚Äôt have to.  And if it is not necessary, what are the questions for us?  If you do not want to guarantee the entry in the socket, then why do we guarantee delivery?  We do the best effort.  We really try to deliver as much as possible and as best we can, but we do not give a 100% guarantee.  Therefore, do not write there financial data.  For this there are databases with transactions. </p><br><p>  <strong>Question</strong> : When the API generates some message in the log and transfers control to microservices, have you encountered the problem that messages from different microservices come in the wrong order?  Because of this, confusion arises. </p><br><p>  <strong>Answer</strong> : It is normal that they come in a different order.  To this must be prepared.  Because any network delivery you do not guarantee the order, or you need to spend resources on it specifically.  If we take file storages, then each API saves logs to its file.  Rather, there rsyslog decomposed them into directories.  Each API has its own logs there, where you can go and see, and then by the timestamp in this log you can match them.  If they go to look in Graylog, then there they will be sorted by timestamp.  Everything will be fine there. </p><br><p>  <strong>Question</strong> : Timestamp may differ by millisecond. </p><br><p>  <strong>Answer</strong> : Timestamp is generated by the API itself.  In this, in fact, the whole trick.  We have NTP.  The API timestamp is already in the message itself.  It is not rsyslog adds. </p><br><p>  <strong>Question</strong> : The interaction between data centers is not very clear.  In the framework of the data center, it is clear how the logs were collected and processed.  How is the interaction between data centers?  Or each data center lives its own life? </p><br><p> <strong></strong> : .       -  .       ,        .     .     Log Relay.  Rsyslog .      .   .         .    .        .   ,       (),       Graylog.        storage.  ,     ,     .   .    . </p><br><p> <strong></strong> :       ? </p><br><p> <strong></strong> :    (  )  . </p><br><p> <strong></strong> :    ,     ? </p><br><p> <strong></strong> :      ,    .    .  ,   Go API,  .   ,        socket.       .   .        socket.   ,    .      .     ,    .      prometheus,   Grafana   .   .   ,   . </p><br><p> <strong></strong> :  elasticsearch     .    ? </p><br><p> <strong></strong> :  . </p><br><p> <strong></strong> :    ? </p><br><p> <strong></strong> :    .     . </p><br><p> <strong></strong> :   rsyslog  - ? </p><br><p> <strong></strong> :      unix socket.       128 .       .     .     ,   128 . , , ,   ,   .        ,          .         . </p><br><p> <strong>c</strong> :     JSON? </p><br><p> <strong></strong> :  JSON      relay,     .    Graylog,     JSON .    ,   ,       rsyslog.      issue,     . </p><br><p> <strong>c</strong> :  Kafka?   RabbitMQ?   Graylog   ? </p><br><p> <strong></strong> :    Graylog  .  Graylog   .    .   . ,   ,   .      rsyslog   elasticsearch    Kibana.      .     ,    Graylog    Kibana. Logstash    .  ,        rsyslog.         elasticsearch.  Graylog   - .     .       . </p><br><p>  Kafka.   .   ,   ,      .          .   ,  ,    .  RabbitMQ‚Ä¶     c RabbitMQ.  RabbitMQ   .     ,     .      ,     .           .    . Graylog    AMQP 0.9,  rsyslog    AMQP 1.0.     ,     ,  .     .      Kafka.     .   omkafka   rsyslog,   ,      ,     rsyslog.     . </p><br><p> <strong>c</strong> :   Kafka ,      ?       ? </p><br><p> <strong></strong> : Kafka,  ,   Data Sience.    ,   ,  ,    .  I do not know.      Data Sience.      ,      .    Graylog,     ,      Kafka.    .          API.        live,       staging     . Graylog    . </p><br><p> <strong>c</strong> :       ?    log- syslog  . </p><br><p> <strong></strong> :        ,       .   docker 1.0  0.9. Docker     . -,       ‚Ä¶     ,       ,   .     API   ,   API   ,      stdout  stderr.       .       ,    syslog-      .          Graylog  .   log-          .   GELF    Graylog.    ,    ,       .  ,  -   ,       ,  . </p><br><p> <strong>c</strong> :       rsyslog.    Kafka? </p><br><p> <strong></strong> :    ,     .  For two reasons.    ,            .        .         .    Kafka    . E        ,     rsyslog.         ,     ,   .      -   rsyslog , - Kafka. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/450098/">https://habr.com/ru/post/450098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../450084/index.html">Self-made receiving part of the Qi standard</a></li>
<li><a href="../450088/index.html">How I draw illustrations for mathematics abstracts in Inkscape</a></li>
<li><a href="../450090/index.html">News from the world of OpenStreetMap ‚Ññ457 (16.04.2019-22.04.2019)</a></li>
<li><a href="../450092/index.html">What is what and who is who in the DDoS protection market</a></li>
<li><a href="../450096/index.html">Automatic cat toilet</a></li>
<li><a href="../4501/index.html">Amateur video advertising will reach $ 850 million in 2010</a></li>
<li><a href="../45010/index.html">Once again about all of us favorite vote for topics</a></li>
<li><a href="../450102/index.html">Self-adjusting electronic display clock</a></li>
<li><a href="../450104/index.html">Very difficult and very interesting: IT-communities on TechTrain</a></li>
<li><a href="../450106/index.html">The project of the organization of construction and reconstruction in cramped conditions in SPDS Construction site</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>