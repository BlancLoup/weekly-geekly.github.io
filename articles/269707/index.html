<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Duke, take out the trash! - Part 2</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the previous article, we introduced the terminology and basic ideas underlying the Java HotSpot VM garbage collectors and many other virtual machin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Duke, take out the trash! - Part 2</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/efa/41c/43c/efa41c43cea34521931a2b20ec3e369d.png" width="600" height="386" alt="Heap"></div><br><br>  In the <a href="http://habrahabr.ru/post/269621/">previous article,</a> we introduced the terminology and basic ideas underlying the Java HotSpot VM garbage collectors and many other virtual machines.  Now we, finally, can take a shovel in our hands and begin to rake our heap.  Today, we have <s>two shovels</s> on the review <s>:</s> two garbage collectors, used by a huge number of Java programs, which are often not even aware of this.  These are Serial GC and Parallel GC.  Their popularity is explained simply - these collectors are selected by the virtual machine by default for most hardware configurations. <br><br>  The approaches to working with the heap used in these collectors in one form or another are used in more advanced implementations, so at this stage it will be very important for us to deal with the ideas and possibilities inherent in them. <br><a name="habracut"></a><br><h1>  Serial gc </h1><br>  Serial GC (also known as sequential collector) is the youngest in terms of its functionality, but the oldest in terms of the length of its presence in the JVM garbage collection.  He was slowly but surely collecting garbage even when many of us did not even suspect the existence of the Java language.  And still continues to collect.  Just as slowly, but just as true. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But he didn‚Äôt go to the back of the story because he doesn‚Äôt have all programs that have large heaps and not all programs run on computers with powerful multi-core processors.  In such Spartan conditions, it is very helpful.  And even if this is not your case, you should not skip this chapter, since the basic approaches to the implementation of garbage collection in the JVM are described here, so let's get started. <br><br>  Using Serial GC is enabled with the <i>-XX: + UseSerialGC option</i> . <br><br><h3>  Work principles </h3><br>  When using this collector, the heap is divided into four regions, three of which belong to the younger generation (Eden, Survivor 0 and Survivor 1), and one (Tenured) - to the older one: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6b0/3a9/e6d/6b03a9e6d8174da3a7b228eb9acbe001.png" width="450" height="70" alt="Heap Regions"></div><br><br>  The average object begins its life in the Eden region (translated as Eden, which is quite logical).  This is where the JVM puts it at the time of creation.  But over time it may turn out that there is no room for a newly created object in Eden, in such cases a small garbage collection is started. <br><br>  First of all, this build finds and removes dead objects from Eden.  The remaining living objects are transferred to the empty Survivor region.  One of the two Survivor regions is always empty; it is the one that is selected to transfer objects from Eden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/245/fca/ecf/245fcaecfc9e484ebbdadcdbc5e05ffc.png" width="450" height="250" alt="Small build 1"></div><br><br>  We see that after a small assembly, the Eden region is completely empty and can be used to house new objects.  But sooner or later, our application will again occupy the entire Eden area and the JVM will again attempt to do a small build, this time clearing Eden and part-time Survivor 0, then transferring all the surviving objects to the empty Survivor 1 region: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/6cc/732/93d/6cc73293ddb04e6a9aa273cc6a81f2dd.png" width="450" height="175" alt="Small build 2"></div><br><br>  Next time, Survivor 0 will be selected again as the destination region. As long as there is enough space in the Survivor regions, everything is going well: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e70/ee9/041/e70ee904149845bf9fe70c8524ddf263.png" width="450" height="175" alt="Small build 3"></div><br><br>  The JVM constantly monitors how long objects move between Survivor 0 and Survivor 1, and selects the appropriate threshold for the number of such movements after which the objects move to Tenured, i.e. go to the older generation.  If the Survivor region is filled, then the objects from it are also sent to the Tenured: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/20b/a5e/2fa/20ba5e2faa614c558593413268b729c2.png" width="450" height="175" alt="Small build 4"></div><br><br>  The described process of small garbage collection is quite simple, but the reasons for using the Survivor regions, and precisely two of them, are not always clear.  I think we will leave a detailed explanation of the reasons beyond the scope of this article (discussed in the <a href="https://habr.com/ru/post/269707/">comments</a> ), and here we only note that of the two main ways of working with surviving objects - compacting and copying - in Sun, when developing a small garbage collector, we chose the second way. as it is easier to implement and often turns out to be more productive. <br><br>  In the case when there is not enough space for new objects in Tenured, the full garbage collection, working with objects from both generations, comes into play.  At the same time, the older generation is not divided into subregions by analogy with the younger one, but represents one big piece of memory, so after removing dead objects from Tenured, data is not transferred (there is nowhere to be transferred), but their compression, i.e. placement is sequential, without fragmentation.  Such a cleaning mechanism is called Mark-Sweep-Compact by the name of its steps (mark surviving objects, clear memory from dead objects, compact surviving objects). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/05b/268/25d/05b26825d6d5484083f6354b1d114313.png" width="450" height="175" alt="Complete assembly 1"></div><br><br><h3>  Accelerates </h3><br>  The most observant readers probably noticed that at the beginning of the description of the principles of work it is said that in the Eden section an <i>average</i> object is created, and not any.  Such a reservation is not without reason.  The fact is that there are more accelerate objects, the size of which is so large that it is too expensive to create them in Eden, and then drag them along with Survivor.  In this case, they are placed immediately in Tenured. <br><br><h3>  Is the pile small? </h3><br>  Important factors in the described processes are the absolute size of the heap and the relative sizes of the regions within it. <br><br>  As the heap fills with data, the JVM can not only purge the memory, but also ask the OS to allocate additional memory to expand the regions.  Moreover, if the actual memory used falls below a certain threshold, the JVM can return some of the memory to the operating system.  To regulate the appetite of a virtual machine, there are well-known <i>Xms</i> and <i>Xmx</i> options. <br><br>  And although setting the heap boundary values ‚Äã‚Äãis sometimes enough for the program to work and not clearly slow down, fine-tuning the collector to achieve the required performance is done by adjusting the sizes of different regions.  We will consider examples of such regulation and its influence on the work of the program in a separate article, and here for now we will simply list the parameters with which this is done (see below). <br><br>  It is also worth noting that by default the younger generation occupies one third of the entire heap, and the older, respectively, two thirds.  In addition, each Survivor region is one-tenth of the younger generation, that is, Eden is eight-tenths.  As a result, the real proportions of regions by default look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/54a/ef8/53c/54aef853c8f04e2a95b5d55514253933.png" width="450" height="50" alt="Regional proportions"></div><br><br>  And what happens if even after allocating the maximum amount of memory and its complete cleaning, there is no room for new objects?  In this case, we expectedly get <i>java.lang.OutOfMemoryError: Java heap space</i> and the application stops working, leaving us to remember its heap as a file for analysis.  Technically, this happens if the work of the collector begins to take at least 98% of the time and at the same time garbage collections free up no more than 2% of the memory. <br><br><h3>  STW situations </h3><br>  With this collector, everything is quite simple, since all his work is one continuous <abbr title="stop-the-world, pausing the application to perform garbage collection">STW</abbr> .  At the beginning of each garbage collection, the operation of the main threads of the application stops and resumes only after the end of the assembly.  Moreover, all the work on cleaning the Serial GC does not rush, in one thread, sequentially, for which he won his name. <br><br><h3>  Customization </h3><br>  We have already touched on the fact that with the help of <i>Xms</i> and <i>Xmx</i> options, you can configure the initial and maximum heap sizes, respectively.  Surely most of you have already done this.  Now let's try to dig deeper. <br><br>  There are options <i><nobr>-XX: MinHeapFreeRatio =?</nobr></i>  and <i><nobr>-XX: MaxHeapFreeRatio =?</nobr></i>  , which set the minimum and maximum share of free space in each generation, upon reaching which the generation size will be automatically increased or decreased, respectively.  For example, if <i><nobr>MinHeapFreeRatio = 35</nobr></i> , then if the share of free space in any generation falls below 35%, this generation will be provided with additional space so that at least 35% becomes free.  Similarly, if <i><nobr>MaxHeapFreeRatio = 65</nobr></i> , then, with an increase in the share of free space in a generation of up to 65% or more, part of the memory allocated to this generation will be freed to return to the desired threshold.  The default values ‚Äã‚Äãof these parameters depend on the hardware characteristics of the computer. <br><br>  You can set the desired ratio of the size of the older generation to the total size of the regions of the younger generation using the <i><nobr>-XX</nobr></i> option <i><nobr>: NewRatio =?</nobr></i>  .  For example, <i><nobr>NewRatio = 3</nobr></i> means that for the younger generation (Eden + S0 + S1) a quarter of the pile will be allotted, and for the older generation - three quarters.  The counterintuitive name of this option introduces some confusion even in the Oracle documentation, but it works that way.  It‚Äôs easier to remember that where option names end in <i>Ratio</i> , the real value will be the inverse of what you specified. <br><br>  If desired, you can limit the size of the younger generation of absolute values ‚Äã‚Äãof the bottom and top using the options <i><nobr>-XX: NewSize =?</nobr></i>  and <i><nobr>-XX: MaxNewSize =?</nobr></i>  .  If you want to set the same values ‚Äã‚Äãfor <i>NewSize</i> and <i>MaxNewSize</i> , you can simply use the <i><nobr>-Xmn</nobr></i> option.  For example, <i><nobr>-Xmn256m is</nobr></i> equivalent to <i><nobr>-XX: NewSize = 256m</nobr> <nobr>-XX: MaxNewSize = 256m</nobr></i> . <br><br>  You can still climb inside the younger generation and adjust the ratio of the size of Eden to the size of a Survivor.  This is done with the <i><nobr>-XX</nobr></i> option <i><nobr>: SurvivorRatio =?</nobr></i>  .  For example, with <i><nobr>SurvivorRatio = 6,</nobr></i> each Survivor region will occupy one eighth the size of the entire younger generation, and Eden six sixths (remember the <i>rule of options * Ratio</i> ). <br><br>  Using the <i><nobr>-XX</nobr></i> option <i><nobr>: -UseGCOverheadLimit,</nobr></i> you can disable the collector activity threshold of 98%, upon reaching which OutOfMemoryError occurs. <br><br>  If you are interested in watching how your objects in the Survivor region age and what target values ‚Äã‚Äãfor its size are set at the moment, you can use the <i><nobr>-XX: + PrintTenuringDistribution option</nobr></i> , which adds statistics on Survivor to the output of information on some garbage collections. <br><br><h3>  Advantages and disadvantages </h3><br>  The main advantage of this collector is obvious - it is unassuming in terms of computer resources.  Since he does all the work consistently in one thread, he has no noticeable overheads and negative side effects. <br><br><img src="https://habrastorage.org/files/3ed/a83/b95/3eda83b958ec4cf189ca2ede89be8781.png" width="300" height="200" align="right" alt="Turtle">  The main drawback is also understandable - it is a long pause for garbage collection with a significant amount of data.  In addition, it is clear that all the settings for Serial GC revolve around the sizes of different regions of the heap.  That is, for fine tuning you need to learn something yourself, adjust, experiment, and so on.  Someone may not like it. <br><br>  If your application does not require a large heap size for operation (Oracle specifies a conditional <nobr>100 MB</nobr> boundary), it is not very sensitive to short stops and only one processor core is available for operation, then you can take a closer look at this option.  Otherwise, you can look for a better option. <br><br><hr><br><h1>  Parallel gc </h1><br>  Parallel GC (parallel collector) develops the ideas behind the sequential collector, adding parallelism and a bit of intelligence to them.  If you have more than one processor core on your computer and you clearly did not indicate which collector you would like to use in your program, then the JVM will almost certainly opt for the Parallel GC.  It is fairly simple, but at the same time functional enough to meet the needs of most applications. <br><br>  The parallel collector is enabled with the <i><nobr>-XX: + UseParallelGC option</nobr></i> . <br><br><h3>  Work principles </h3><br>  When a parallel collector is connected, the same approaches to organizing a heap are used as in the case of Serial GC - it is divided into the same Eden, Survivor 0, Survivor 1 and Old Gen regions (known to us under the name Tenured), operating according to the same principle .  But there are two fundamental differences in working with these regions: first, garbage collection is handled by several threads in parallel;  secondly, this collector can independently adjust to the required performance parameters.  Let's see how it works. <br><br>  To determine the number of threads to be used for garbage collection on a computer with N processor cores, the JVM uses the following formula by default: if <nobr>N ‚â§ 8</nobr> , then the number of threads is N, otherwise, to get the number of threads, N is multiplied by a factor depending on other parameters, usually <nobr>5/8</nobr> , but on some platforms the coefficient may be less. <br><br>  By default, both small and full builds enable multithreading.  Small uses it when transferring objects to the older generation, and full - when compiling data in the older generation. <br><br>  Each collector thread receives its own chunk of memory in the Old Gen region, the so-called <i>promotion buffer</i> , where only it can transfer data so as not to interfere with other threads.  This approach speeds up garbage collection, but it also has a slight negative effect in the form of possible memory fragmentation: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bed/e1a/c4c/bede1ac4c5c84aa9a3363a446b1be0b6.png" width="450" height="200" alt="Parallel assembly"></div><br><br>  The intellectual component of the improvements to the parallel collector with respect to the sequential is that it has settings that focus on achieving the efficiency of garbage collection you need.  You can specify the performance parameters that suit you ‚Äî the maximum build time and / or throughput ‚Äî and the builder will try his best not to exceed the specified thresholds.  For this, he will use the statistics of the already completed garbage collections and, based on it, plan the parameters of further assemblies: vary the size of generations, change the proportions of the regions. <br><br>  For example, if a small JVM build fails to fit in the time you allot, the size of the younger generation can be reduced.  If it is not possible to achieve a given bandwidth, but there are no problems with a delay, then the generation size will be increased.  And so on. <br><br>  It should be borne in mind that the statistics ignore garbage collections that you manually started. <br><br>  Of course, nobody will give you an absolute guarantee of achieving the desired parameters, but you can try, often installing the necessary options is enough. <br><br>  If you set too strict requirements that the collector cannot fulfill, he will be guided by the following priorities (in descending order of importance): <br><br><ol><li>  Reducing the maximum pause. </li><li>  Increased bandwidth. </li><li>  Minimize used memory. </li></ol><br>  At the same time, Parallel GC allows us to independently adjust the size of the regions, as in the sequential collector.  But it is not recommended to do both at the same time, in order not to disorient the algorithms of automatic adjustment.  Either we allocate enough memory to the application, indicate the desired performance parameters and observe from the side, or we climb into the regions settings, but then we are deprived of the right to demand from the assembler automatic adjustment to the performance criteria we need.  He will not swear at us in case of violation of this rule, but he will not be able to do his job effectively either. <br><br><h3>  STW situations </h3><br>  As is the case with the sequential collector, during the memory cleanup operations all the main application threads stop.  The only difference is that the pause, as a rule, is shorter due to the performance of part of the work in parallel mode. <br><br><h3>  Customization </h3><br>  For the parallel collector, all the same options are applicable as for the sequential one.  You can manually set the size of the memory regions or the proportions between them.  Below are the options that are added by the parallel collector to what we have already discussed above. <br><br>  You can manually specify the number of threads you would like to allocate for garbage collection.  This is done with the <i><nobr>-XX</nobr></i> option <i><nobr>: ParallelGCThreads =?</nobr></i>  .  For example, <i><nobr>-XX: ParallelGCThreads = 9 will</nobr></i> limit the number of streams to nine.  Keep in mind that increasing the number of threads not only more parallelizes the assembly, but also increases the fragmentation of the Tenured region, and also adds overhead to synchronizing these threads. <br><br>  If you wish, you can completely disable parallel compaction of objects in the older generation with the <i><nobr>-XX</nobr></i> option <i><nobr>: -UseParallelOldGC</nobr></i> . <br><br>  Setting the desired performance parameters of the collector is done using the options <i><nobr>-XX: MaxGCPauseMillis =?</nobr></i>  and <i><nobr>-XX: GCTimeRatio =?</nobr></i>  . <br><br>  <i><nobr>MaxGCPauseMillis</nobr></i> sets a limit on the maximum program suspension time for garbage collection.  For example, <i><nobr>-XX: MaxGCPauseMillis = 400</nobr></i> will indicate to the JVM that it is advisable not to delay the garbage collection pauses for more than 400 milliseconds.  By default, there is no such limit.  When setting this parameter, it should be remembered that the restriction on the assembly time can lead to the need to perform it more often, as a result of which the total throughput will suffer. <br><br>  Using the <i><nobr>GCTimeRatio</nobr></i> option <i><nobr>,</nobr></i> you can specify the desired bandwidth threshold (the ratio of the running time of the program to the time of garbage collection).  For example, with <i><nobr>-XX: GCTimeRatio = 49, the</nobr></i> JVM will attempt to build in such a way that they take up no more than 2% of the program's running time (the ratio of build time to program runtime will be <nobr>1 / (1 + 49))</nobr> . <br><br>  Options <i><nobr>-XX: YoungGenerationSizeIncrement =?</nobr></i>  and <i><nobr>-XX: TenuredGenerationSizeIncrement =?</nobr></i>  establish, on how many percent it is necessary to increase if necessary younger and senior generation respectively.  By default, both of these parameters are 20. <br><br>  But the rate of reduction in the size of generations is not regulated by percentages, but by a special factor through the <i><nobr>-XX</nobr></i> option <i><nobr>: AdaptiveSizeDecrementScaleFactor</nobr></i> .  It indicates how many times the decrease should be less than the increase.  This option applies to both generations.  For example, with <i><nobr>-XX: AdaptiveSizeDecrementScaleFactor = 2,</nobr></i> each generation decrease will be two times less than its increase (that is, both generations will decrease by 10% with <i><nobr>-XX: GenerationSizeIncrement = 20</nobr></i> and <i><nobr>-XX: TenuredGenerationSizeIncrement = 20</nobr></i> ). <br><br><h3>  Advantages and disadvantages </h3><br>  The indisputable advantage of this collector on the background of Serial GC is the possibility of automatic adjustment to the required performance parameters and smaller pauses during assembly.  If there are multiple processor cores, the speed gain will be in almost all applications. <br><br>  Certain fragmentation of memory, of course, is a minus, but it is unlikely to be significant for most applications, since the collector uses a relatively small number of threads. <br><br>  In general, Parallel GC is a simple, intuitive, and efficient assembler, suitable for most applications.  It has no hidden overhead, we can always change its settings and clearly see the result of these changes. <br><br>  But it happens that it is not enough and you need to look for something more sophisticated.  We will talk about more advanced implementations of collectors in the next article. <br><br>  <a href="http://habrahabr.ru/post/269863/">Part 3 - CMS GC and G1 GC assemblers ‚Üí</a> <br><br>  <i>Earlier</i> <br>  <a href="http://habrahabr.ru/post/269621/">‚Üê Part 1 - Introduction</a> </div><p>Source: <a href="https://habr.com/ru/post/269707/">https://habr.com/ru/post/269707/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../269695/index.html">From Java to Scala: 7 reasons to learn a new language</a></li>
<li><a href="../269697/index.html">Cold perfection: news on the data center cooling systems market</a></li>
<li><a href="../269699/index.html">Compare me completely. Reflection in the service of .NET developer</a></li>
<li><a href="../269701/index.html">Monitoring is handy on IxoraRMS. Quick and tasteful</a></li>
<li><a href="../269705/index.html">Sharing checkstyle and gerrit</a></li>
<li><a href="../269709/index.html">Validation of complex structures with PHPixie Validate</a></li>
<li><a href="../269711/index.html">Another build Vivaldi 1.0.303.37 - Beta Candidate</a></li>
<li><a href="../269717/index.html">Maybe monad on steroids</a></li>
<li><a href="../269719/index.html">‚ÄúWhat's new in Swift 2?‚Äù With examples. Part 2</a></li>
<li><a href="../269721/index.html">Latest article about setting up a server for Rails</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>