<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Using the stm32cube library to create platform independent drivers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! In this article I would like to share the experience of creating drivers for the stm32 series platforms. The idea is that in Embox OS , it was ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Using the stm32cube library to create platform independent drivers</h1><div class="post__text post__text-html js-mediator-article"><img width="400" src="https://habrastorage.org/web/400/16b/466/40016b4660824f82b24531aab0e5f56f.png" align="right">  Hello!  In this article I would like to share the experience of creating drivers for the stm32 series platforms.  The idea is that in <a href="https://github.com/embox/embox">Embox OS</a> , it was not necessary to create drivers for each series of STM32F3, STM32F4 platforms and so on.  Indeed, besides the fact that it takes time, the new code will inevitably contain new errors. <br><a name="habracut"></a><br>  Initially, we took examples for different devices and reworked them to fit our needs.  At the same time, I still wanted to use some common base, and as such a base, the manufacturer of microcontroller data (STMicroelectronics) offers the <a href="http://www.st.com/en/embedded-software/stm32cube-embedded-software.html%3Fquerycriteria%3DproductId%3DLN1897">stm32cube</a> library (more precisely, a series of libraries).  Unfortunately, these libraries contain a slightly different, although very similar API for platforms of different series.  After all, as many probably know, stm32cubemx, which is the code generator, is part of the stm32cube.  That is, with its help, you can generate a project framework for any platform in this series, and the developers need to add the necessary functionality.  Because of this, you can not much care about a single interface. <br><br>  But, as I said, we wanted to use stm32cube to create drivers with a unified API, because it would allow using higher-level software independent of the device level.  In addition, as I wrote in one of the <a href="https://habrahabr.ru/company/embox/blog/255835/">articles</a> , the characteristics of modern small ARM (cortex-m) devices approach, conditionally, the Pentiums.  You can, of course, continue to use them as cool Arduino, but this is unlikely to fully reveal their potential. <br><br><h3>  Start code and linker script </h3><br>  The first thing that usually starts working with the controller, and the processor too, is the boot code, interrupt vector and other architectural features.  I will briefly touch on how it is organized in stm32cube. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In stm32cube there is a specific start code for each controller model, and even for each compiler (ARM, AIR and gcc).  All this is in the Drivers / CMSIS / Device / ST / STM32 directory, where XXX is a series, for example, F3, F4 or F7. <br><br>  The start code itself is contained in a separate assembler file for each controller series and is connected during project configuration.  We are closer gcc-shnye versions of files.  They are in the Source / Templates / gcc subfolder. <br><br>  When comparing a pair of assembler files, it turned out that they contain the same boot code, which differs only in the table (vector) of interrupts.  This difference is quite expected, because different models of controllers have a different set of hardware devices.  But in my opinion, if you put the common code for all controllers in a separate file, and generate different interrupt tables based on the hardware supported by the controller, it will be much better.  Something like this is done in Embox. <br><br>  In addition to the start code in the same folder are the linker scripts for each series of controllers.  Again, if we look at them and compare, we will see how similar they are.  I found the differences only in the section sizes and in the presence of the CCMRAM section.  In our project, we got rid of duplicating linker scripts, and made a small generator that takes a config file and turns it into a linker script with the help of the preprocessor. <br><br><div class="spoiler">  <b class="spoiler_title">Here is how, for example, we have a configuration file for stm32f3-discovery</b> <div class="spoiler_text"><code>/* region (origin, length) */ <br> ROM (0x08000000, 256K) <br> RAM (0x20000000, 40K) <br> region(SRAM_CCM, 0x10000000, 8K) <br> <br> /* section (region[, lma_region]) */ <br> text (ROM) <br> rodata (ROM) <br> data (RAM, ROM) <br> bss (RAM)</code> </div> </div><br><h3>  Debugging interface </h3><br>  In principle, the boot code and linker script is enough to start the program, then you can connect with a debugger and walk along the steps.  But this is definitely not enough for doing any useful work.  The program must respond to external influences or at least somehow manifest itself.  The simplest manifestation is either a flashing LED, or the output of something to the UART (COM port).  In our project, it is customary to begin with the UART-based diag interface, since this greatly simplifies subsequent debugging. <br><br><div class="spoiler">  <b class="spoiler_title">Like the UART interface itself, the implementation of the serial port is very simple.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uart_ops</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stm32_uart_ops</span></span></span><span class="hljs-class"> = {</span></span> .uart_getc = stm32_uart_getc, .uart_putc = stm32_uart_putc, .uart_hasrx = stm32_uart_hasrx, .uart_setup = stm32_uart_setup, }; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">uart</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stm32_diag</span></span></span><span class="hljs-class"> = {</span></span> .uart_ops = &amp;stm32_uart_ops, .irq_num = USARTx_IRQn, .base_addr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) USARTx, };</code> </pre> <br></div></div><br>  In fact, it is enough to implement four functions, three of which are trivial - they are writing or reading certain control registers.  The <code>uart_setup()</code> function is not much more complicated, it sets the port parameters. <br><br><div class="spoiler">  <b class="spoiler_title">As a result, using the API from STM32CUBE, the code is as follows:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stm32_uart_setup</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct uart *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> struct uart_params *params)</span></span></span><span class="hljs-function"> </span></span>{ UART_HandleTypeDef UartHandle; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(&amp;UartHandle, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(UartHandle)); UartHandle.Instance = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>*) dev-&gt;base_addr; UartHandle.Init.BaudRate = params-&gt;baud_rate; UartHandle.Init.WordLength = UART_WORDLENGTH_8B; UartHandle.Init.StopBits = UART_STOPBITS_1; UartHandle.Init.Parity = UART_PARITY_NONE; UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; UartHandle.Init.Mode = UART_MODE_TX_RX; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HAL_UART_Init(&amp;UartHandle) != HAL_OK) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dev-&gt;params.irq) { <span class="hljs-comment"><span class="hljs-comment">/* Enable the UART Data Register not empty Interrupt */</span></span> __HAL_UART_ENABLE_IT(&amp;UartHandle, UART_IT_RXNE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stm32_uart_putc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct uart *dev, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ch)</span></span></span><span class="hljs-function"> </span></span>{ USART_TypeDef *uart = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) dev-&gt;base_addr; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((STM32_USART_FLAGS(uart) &amp; USART_FLAG_TXE) == <span class="hljs-number"><span class="hljs-number">0</span></span>); STM32_USART_TXDATA(uart) = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>) ch; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stm32_uart_hasrx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct uart *dev)</span></span></span><span class="hljs-function"> </span></span>{ USART_TypeDef *uart = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) dev-&gt;base_addr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> STM32_USART_FLAGS(uart) &amp; USART_FLAG_RXNE; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stm32_uart_getc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct uart *dev)</span></span></span><span class="hljs-function"> </span></span>{ USART_TypeDef *uart = (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) dev-&gt;base_addr; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span>)(STM32_USART_RXDATA(uart) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>); }</code> </pre><br></div></div><br>  In order for the UART to work in the STM32Cube, it is necessary to implement <code>HAL_UART_MspInit()</code> for one or another family of controllers.  This function is declared as weak in the cube itself and is redefined for a specific example.  It is called from <code>HAL_UART_Init()</code> and, in fact, sets up the I / O pins as needed. <br><br><div class="spoiler">  <b class="spoiler_title">For stm32f4, the code looks like</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_UART_MspInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UART_HandleTypeDef *huart)</span></span></span><span class="hljs-function"> </span></span>{ GPIO_InitTypeDef GPIO_InitStruct; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *uart_base = huart-&gt;Instance; <span class="hljs-comment"><span class="hljs-comment">/*##-1- Enable peripherals and GPIO Clocks #################################*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIO TX/RX clock */</span></span> USART_TX_GPIO_CLK_ENABLE(uart_base); USART_RX_GPIO_CLK_ENABLE(uart_base); <span class="hljs-comment"><span class="hljs-comment">/* Enable USART2 clock */</span></span> USART_CLK_ENABLE(uart_base); <span class="hljs-comment"><span class="hljs-comment">/*##-2- Configure peripheral GPIO ##########################################*/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* UART TX GPIO pin configuration */</span></span> GPIO_InitStruct.Pin = USART_TX_PIN(uart_base); GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; GPIO_InitStruct.Alternate = USART_TX_AF(uart_base); HAL_GPIO_Init(USART_TX_GPIO_PORT(uart_base), &amp;GPIO_InitStruct); <span class="hljs-comment"><span class="hljs-comment">/* UART RX GPIO pin configuration */</span></span> GPIO_InitStruct.Pin = USART_RX_PIN(uart_base); GPIO_InitStruct.Alternate = USART_RX_AF(uart_base); HAL_GPIO_Init(USART_RX_GPIO_PORT(uart_base), &amp;GPIO_InitStruct); }</code> </pre> <br></div></div><br>  In Embox, it is possible to use several UARTs through a UNIX interface, that is, with the ability to access the device by the file name (/ dev / ttyS0, / dev / ttyS1).  In order to support this feature for stm32, we have not yet come up with anything better than to do a header file for each series, and in it to determine the necessary parameters, and this applies even to the port registers, since, probably, for greater optimality, hardware implementations for different series differ. <br><br><div class="spoiler">  <b class="spoiler_title">For STM32F4 it looks like this</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODOPS_USARTX OPTION_GET(NUMBER, usartx) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MODOPS_USARTX == 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx USART6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_CLK_ENABLE() __HAL_RCC_USART6_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOC_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOC_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_FORCE_RESET() __HAL_RCC_USART6_FORCE_RESET() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RELEASE_RESET() __HAL_RCC_USART6_RELEASE_RESET() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx Pins */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_PIN GPIO_PIN_6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_PORT GPIOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_AF GPIO_AF8_USART6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_PIN GPIO_PIN_7 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_PORT GPIOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_AF GPIO_AF8_USART6 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx's NVIC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQn USART6_IRQn + 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQHandler USART6_IRQHandler #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> MODOPS_USARTX == 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx USART2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_CLK_ENABLE() __HAL_RCC_USART2_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOA_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOA_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_FORCE_RESET() __HAL_RCC_USART2_FORCE_RESET() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RELEASE_RESET() __HAL_RCC_USART2_RELEASE_RESET() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx Pins */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_PIN GPIO_PIN_2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_PORT GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_AF GPIO_AF7_USART2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_PIN GPIO_PIN_3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_PORT GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_AF GPIO_AF7_USART2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx's NVIC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQn USART2_IRQn + 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQHandler USART2_IRQHandler #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> Unsupported USARTx #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_FLAGS(uart) uart-&gt;SR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_RXDATA(uart) uart-&gt;DR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_TXDATA(uart) uart-&gt;DR</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">For STM32F7</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODOPS_USARTX OPTION_GET(NUMBER, usartx) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MODOPS_USARTX == 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx USART6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_CLK_ENABLE() __HAL_RCC_USART6_CLK_ENABLE(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOC_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOC_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_FORCE_RESET() __HAL_RCC_USART6_FORCE_RESET() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RELEASE_RESET() __HAL_RCC_USART6_RELEASE_RESET() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx Pins */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_PIN GPIO_PIN_6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_PORT GPIOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_AF GPIO_AF8_USART6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_PIN GPIO_PIN_7 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_PORT GPIOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_AF GPIO_AF8_USART6 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx's NVIC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQn USART6_IRQn + 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQHandler USART6_IRQHandler #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> MODOPS_USARTX == 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx USART2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_CLK_ENABLE() __HAL_RCC_USART2_CLK_ENABLE(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOA_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOA_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_FORCE_RESET() __HAL_RCC_USART2_FORCE_RESET() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RELEASE_RESET() __HAL_RCC_USART2_RELEASE_RESET() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx Pins */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_PIN GPIO_PIN_2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_PORT GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_AF GPIO_AF7_USART2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_PIN GPIO_PIN_3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_PORT GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_AF GPIO_AF7_USART2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx's NVIC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQn USART2_IRQn + 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQHandler USART2_IRQHandler #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> MODOPS_USARTX == 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx USART1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_CLK_ENABLE() __HAL_RCC_USART1_CLK_ENABLE(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOB_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_CLK_ENABLE() __HAL_RCC_GPIOA_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_FORCE_RESET() __HAL_RCC_USART1_FORCE_RESET() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RELEASE_RESET() __HAL_RCC_USART1_RELEASE_RESET() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx Pins */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_PIN GPIO_PIN_9 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_PORT GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_AF GPIO_AF7_USART1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_PIN GPIO_PIN_7 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_PORT GPIOB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_AF GPIO_AF7_USART1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx's NVIC */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQn USART1_IRQn + 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQHandler USART1_IRQHandler #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> Unsupported USARTx #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_FLAGS(uart) uart-&gt;ISR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_RXDATA(uart) uart-&gt;RDR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_TXDATA(uart) uart-&gt;TDR</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">For STM32F3</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MODOPS_USARTX OPTION_GET(NUMBER, usartx) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> MODOPS_USARTX == 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx USART1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_CLK_ENABLE() __USART1_CLK_ENABLE(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_CLK_ENABLE() __GPIOC_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_CLK_ENABLE() __GPIOC_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_FORCE_RESET() __USART1_FORCE_RESET() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RELEASE_RESET() __USART1_RELEASE_RESET() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx Pins */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_PIN GPIO_PIN_4 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_PORT GPIOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_AF GPIO_AF7_USART1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_PIN GPIO_PIN_5 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_PORT GPIOC #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_AF GPIO_AF7_USART1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx's NVIC */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* In Embox we assume that the lower external irq number is 0, * but in the cortexm3 it is -15 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQn USART1_IRQn + 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQHandler USART1_IRQHandler #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> MODOPS_USARTX == 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx USART2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_CLK_ENABLE() __USART2_CLK_ENABLE(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_CLK_ENABLE() __GPIOA_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_CLK_ENABLE() __GPIOA_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_FORCE_RESET() __USART2_FORCE_RESET() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RELEASE_RESET() __USART2_RELEASE_RESET() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx Pins */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_PIN GPIO_PIN_2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_PORT GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_AF GPIO_AF7_USART2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_PIN GPIO_PIN_3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_PORT GPIOA #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_AF GPIO_AF7_USART2 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx's NVIC */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* In Embox we assume that the lower external irq number is 0, * but in the cortexm3 it is -15 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQn USART2_IRQn + 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQHandler USART2_IRQHandler #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">elif</span></span></span><span class="hljs-meta"> MODOPS_USARTX == 3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx USART3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_CLK_ENABLE() __USART3_CLK_ENABLE(); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_CLK_ENABLE() __GPIOB_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_CLK_ENABLE() __GPIOB_CLK_ENABLE() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_FORCE_RESET() __USART3_FORCE_RESET() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RELEASE_RESET() __USART3_RELEASE_RESET() </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx Pins */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_PIN GPIO_PIN_10 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_GPIO_PORT GPIOB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_TX_AF GPIO_AF7_USART3 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_PIN GPIO_PIN_11 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_GPIO_PORT GPIOB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_RX_AF GPIO_AF7_USART3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Definition for USARTx's NVIC */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* In Embox we assume that the lower external irq number is 0, * but in the cortexm3 it is -15 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQn USART3_IRQn + 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> USARTx_IRQHandler USART3_IRQHandler #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_FLAGS(uart) uart-&gt;ISR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_RXDATA(uart) uart-&gt;RDR #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> STM32_USART_TXDATA(uart) uart-&gt;TDR</span></span></code> </pre><br></div></div><br>  If you look at the code above, you will see that we have been supported only by a pair of UART numbers for those boards that we checked.  On the other hand, the task was completed, when you started Embox, the devices / dev / ttyS0 and / dev / ttyS1 appeared, which were tied to the hardware ports of the UART with the numbers specified in the configuration. <br><br><div class="spoiler">  <b class="spoiler_title">Config example</b> <div class="spoiler_text"> <code>@Runlevel(1) include embox.driver.serial.stm_ttyS1(baud_rate=57600, usartx=2) <br> @Runlevel(1) include embox.driver.serial.stm_ttyS0(baud_rate=115200, usartx=6)</code> <br> </div></div><br><h3>  Timers and Interrupt Controller </h3><br>  The next step in porting is usually support for the timer and interrupt controller.  For these devices, the drivers are based on a different library - <a href="https://www.arm.com/products/processors/cortex-m/cortex-microcontroller-software-interface-standard.php">CMSIS</a> (Cortex Microcontroller Software Interface Standard).  We already had them and did not have to redo them.  Looking ahead, I‚Äôll clarify that I had to implement the <code>uint32_t HAL_GetTick(void)</code> function in order for the STM32FCube to work correctly, well, and I still had to poke it in the initialization. <br><br>  The minimum initialization for all platforms is very similar.  In fact, it is necessary to call <code>SystemInit()</code> and <code>HAL_Init()</code> from stm32cube and configure clocks for a specific platform. <br><br><div class="spoiler">  <b class="spoiler_title">For stm32f4</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SystemClock_Config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_OscInitTypeDef RCC_OscInitStruct; <span class="hljs-comment"><span class="hljs-comment">/* Enable Power Control clock */</span></span> __HAL_RCC_PWR_CLK_ENABLE(); <span class="hljs-comment"><span class="hljs-comment">/* The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet. */</span></span> __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1); <span class="hljs-comment"><span class="hljs-comment">/* Enable HSE Oscillator and activate PLL with HSE as source */</span></span> RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = <span class="hljs-number"><span class="hljs-number">8</span></span>; RCC_OscInitStruct.PLL.PLLN = <span class="hljs-number"><span class="hljs-number">336</span></span>; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = <span class="hljs-number"><span class="hljs-number">7</span></span>; HAL_RCC_OscConfig(&amp;RCC_OscInitStruct); <span class="hljs-comment"><span class="hljs-comment">/* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */</span></span> RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_5); <span class="hljs-comment"><span class="hljs-comment">/* STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HAL_GetREVID() == <span class="hljs-number"><span class="hljs-number">0x1001</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/* Enable the Flash prefetch */</span></span> __HAL_FLASH_PREFETCH_BUFFER_ENABLE(); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">For stm32f7</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SystemClock_Config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_OscInitTypeDef RCC_OscInitStruct; <span class="hljs-comment"><span class="hljs-comment">/* Enable HSE Oscillator and activate PLL with HSE as source */</span></span> RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSIState = RCC_HSI_OFF; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = <span class="hljs-number"><span class="hljs-number">25</span></span>; RCC_OscInitStruct.PLL.PLLN = <span class="hljs-number"><span class="hljs-number">432</span></span>; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"&gt;&gt;&gt; SystemClock_Config failed\n"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* activate the OverDrive to reach the 216 Mhz Frequency */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HAL_PWREx_EnableOverDrive() != HAL_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"&gt;&gt;&gt; SystemClock_Config failed\n"</span></span>); } <span class="hljs-comment"><span class="hljs-comment">/* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */</span></span> RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"&gt;&gt;&gt; SystemClock_Config failed\n"</span></span>); } }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">For stm32f3</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SystemClock_Config</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_OscInitTypeDef RCC_OscInitStruct; <span class="hljs-comment"><span class="hljs-comment">/* Enable HSE Oscillator and activate PLL with HSE as source */</span></span> RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct)!= HAL_OK) { <span class="hljs-comment"><span class="hljs-comment">// Error_Handler(); } /* Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers */ RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2)!= HAL_OK) { // Error_Handler(); } }</span></span></code> </pre><br></div></div><br>  Actually, after that interruptions and timers work in the system, and this is quite enough for organizing preemptive multitasking.  To feel the power of multitasking on these microcontrollers, it is enough to run http and telnet servers on them, but for this you need to implement a network card driver.  Here the situation is similar to the UART in the sense that there is a common driver and there is a separate configuration for a particular platform that adjusts the legs and the like. <br><br><h3>  Ethernet </h3><br>  Let's start with the configuration.  We only have versions for stm32f4 and stm32f7, since stm32f3 does not have an ethernet controller. <br><br><div class="spoiler">  <b class="spoiler_title">For stm32f4</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_ETH_MspInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ETH_HandleTypeDef *heth)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*(##) Enable the Ethernet interface clock using (+++) __HAL_RCC_ETHMAC_CLK_ENABLE(); (+++) __HAL_RCC_ETHMACTX_CLK_ENABLE(); (+++) __HAL_RCC_ETHMACRX_CLK_ENABLE(); (##) Initialize the related GPIO clocks (##) Configure Ethernet pin-out (##) Configure Ethernet NVIC interrupt (IT mode) */</span></span> GPIO_InitTypeDef GPIO_InitStructure; <span class="hljs-comment"><span class="hljs-comment">/* Enable ETHERNET clock __HAL_RCC_ETHMAC_CLK_ENABLE(); __HAL_RCC_ETHMACTX_CLK_ENABLE(); __HAL_RCC_ETHMACRX_CLK_ENABLE(); */</span></span> __HAL_RCC_ETH_CLK_ENABLE(); <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIOs clocks */</span></span> __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOE_CLK_ENABLE(); <span class="hljs-comment"><span class="hljs-comment">/* Ethernet pins configuration ************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ETH_MDIO --------------&gt; PA2 ETH_MDC ---------------&gt; PC1 ETH_RMII_REF_CLK-------&gt; PA1 ETH_RMII_CRS_DV -------&gt; PA7 ETH_MII_RX_ER -------&gt; PB10 ETH_RMII_RXD0 -------&gt; PC4 ETH_RMII_RXD1 -------&gt; PC5 ETH_RMII_TX_EN -------&gt; PB11 ETH_RMII_TXD0 -------&gt; PB12 ETH_RMII_TXD1 -------&gt; PB13 ETH_RST_PIN -------&gt; PE2 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Configure PA1,PA2 and PA7 */</span></span> GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7; GPIO_InitStructure.Speed = GPIO_SPEED_HIGH; GPIO_InitStructure.Mode = GPIO_MODE_AF_PP; GPIO_InitStructure.Pull = GPIO_NOPULL; GPIO_InitStructure.Alternate = GPIO_AF11_ETH; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStructure); <span class="hljs-comment"><span class="hljs-comment">/* Configure PB10,PB11,PB12 and PB13 */</span></span> GPIO_InitStructure.Pin = GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12 | GPIO_PIN_13; <span class="hljs-comment"><span class="hljs-comment">/* GPIO_InitStructure.Alternate = GPIO_AF11_ETH; */</span></span> HAL_GPIO_Init(GPIOB, &amp;GPIO_InitStructure); <span class="hljs-comment"><span class="hljs-comment">/* Configure PC1, PC4 and PC5 */</span></span> GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5; <span class="hljs-comment"><span class="hljs-comment">/* GPIO_InitStructure.Alternate = GPIO_AF11_ETH; */</span></span> HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStructure); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (heth-&gt;Init.MediaInterface == ETH_MEDIA_INTERFACE_MII) { <span class="hljs-comment"><span class="hljs-comment">/* Output HSE clock (25MHz) on MCO pin (PA8) to clock the PHY */</span></span> HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_HSE, RCC_MCODIV_1); } <span class="hljs-comment"><span class="hljs-comment">/* Configure the PHY RST pin */</span></span> GPIO_InitStructure.Pin = GPIO_PIN_2; GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStructure.Pull = GPIO_PULLUP; GPIO_InitStructure.Speed = GPIO_SPEED_FAST; HAL_GPIO_Init(GPIOE, &amp;GPIO_InitStructure); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2, GPIO_PIN_RESET); HAL_Delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2, GPIO_PIN_SET); HAL_Delay(<span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">For stm32f7</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HAL_ETH_MspInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ETH_HandleTypeDef *heth)</span></span></span><span class="hljs-function"> </span></span>{ GPIO_InitTypeDef GPIO_InitStructure; <span class="hljs-comment"><span class="hljs-comment">/* Enable GPIOs clocks */</span></span> __HAL_RCC_GPIOA_CLK_ENABLE() ; __HAL_RCC_GPIOC_CLK_ENABLE() ; __HAL_RCC_GPIOG_CLK_ENABLE(); <span class="hljs-comment"><span class="hljs-comment">/* Ethernet pins configuration *****************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/* RMII_REF_CLK ----------------------&gt; PA1 RMII_MDIO -------------------------&gt; PA2 RMII_MDC --------------------------&gt; PC1 RMII_MII_CRS_DV -------------------&gt; PA7 RMII_MII_RXD0 ---------------------&gt; PC4 RMII_MII_RXD1 ---------------------&gt; PC5 RMII_MII_RXER ---------------------&gt; PG2 RMII_MII_TX_EN --------------------&gt; PG11 RMII_MII_TXD0 ---------------------&gt; PG13 RMII_MII_TXD1 ---------------------&gt; PG14 */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* Configure PA1, PA2 and PA7 */</span></span> GPIO_InitStructure.Speed = GPIO_SPEED_HIGH; GPIO_InitStructure.Mode = GPIO_MODE_AF_PP; GPIO_InitStructure.Pull = GPIO_NOPULL; GPIO_InitStructure.Alternate = GPIO_AF11_ETH; GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7; HAL_GPIO_Init(GPIOA, &amp;GPIO_InitStructure); <span class="hljs-comment"><span class="hljs-comment">/* Configure PC1, PC4 and PC5 */</span></span> GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5; HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStructure); <span class="hljs-comment"><span class="hljs-comment">/* Configure PG2, PG11, PG13 and PG14 */</span></span> GPIO_InitStructure.Pin = GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14; HAL_GPIO_Init(GPIOG, &amp;GPIO_InitStructure); <span class="hljs-comment"><span class="hljs-comment">/* Enable the Ethernet global Interrupt */</span></span> HAL_NVIC_SetPriority(ETH_IRQn, <span class="hljs-number"><span class="hljs-number">0x7</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); HAL_NVIC_EnableIRQ(ETH_IRQn); <span class="hljs-comment"><span class="hljs-comment">/* Enable ETHERNET clock */</span></span> __HAL_RCC_ETH_CLK_ENABLE(); }</code> </pre><br></div></div><br>  In fact, some kind of ethernet controller initialization code generator suggests itself, but so far no hands reach it. <br><br>  To implement a network device in Embox, it is enough to fill in several fields of the struct net_driver structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_driver</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stm32eth_ops</span></span></span><span class="hljs-class"> = {</span></span> .xmit = stm32eth_xmit, .start = stm32eth_open, .set_macaddr = stm32eth_set_mac, };</code> </pre> <br>  Our driver model is similar to the Linux one, sometimes completely coinciding with it in interface.  So do not be surprised if you see code that is very similar to Linux, it was deliberately done to simplify the development of drivers. <br><br><div class="spoiler">  <b class="spoiler_title">Initialization</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stm32eth_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_device</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nic</span></span></span><span class="hljs-class">;</span></span> nic = (struct net_device *) etherdev_alloc(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nic == <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> -ENOMEM; } nic-&gt;drv_ops = &amp;stm32eth_ops; nic-&gt;irq = STM32ETH_IRQ; nic-&gt;base_addr = ETH_BASE; nic_priv = netdev_priv(nic, struct stm32eth_priv); stm32eth_netdev = nic; res = irq_attach(nic-&gt;irq, stm32eth_interrupt, <span class="hljs-number"><span class="hljs-number">0</span></span>, stm32eth_netdev, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> inetdev_register_dev(nic); }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">In addition, the library itself must be initialized.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">low_level_init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> mac[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">6</span></span></span></span><span class="hljs-function"><span class="hljs-params">])</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//uint32_t regvalue; int err; memset(&amp;stm32_eth_handler, 0, sizeof(stm32_eth_handler)); stm32_eth_handler.Instance = (ETH_TypeDef *) ETH_BASE; /* Fill ETH_InitStructure parametrs */ stm32_eth_handler.Init.MACAddr = mac; stm32_eth_handler.Init.AutoNegotiation = ETH_AUTONEGOTIATION_DISABLE; //stm32_eth_handler.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE; stm32_eth_handler.Init.Speed = ETH_SPEED_100M; stm32_eth_handler.Init.DuplexMode = ETH_MODE_FULLDUPLEX; stm32_eth_handler.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII; stm32_eth_handler.Init.ChecksumMode = ETH_CHECKSUM_BY_SOFTWARE;//ETH_CHECKSUM_BY_HARDWARE; stm32_eth_handler.Init.PhyAddress = PHY_ADDRESS; stm32_eth_handler.Init.RxMode = ETH_RXINTERRUPT_MODE; if (HAL_OK != (err = HAL_ETH_Init(&amp;stm32_eth_handler))) { log_error("HAL_ETH_Init err %d\n", err); } if (stm32_eth_handler.State == HAL_ETH_STATE_READY) { log_error("STATE_READY sp %d duplex %d\n", stm32_eth_handler.Init.Speed, stm32_eth_handler.Init.DuplexMode); } /*(#)Initialize Ethernet DMA Descriptors in chain mode and point to allocated buffers:*/ HAL_ETH_DMATxDescListInit(&amp;stm32_eth_handler, DMATxDscrTab, &amp;Tx_Buff[0][0], ETH_TXBUFNB); /*for Transmission process*/ if (HAL_OK != (err = HAL_ETH_DMARxDescListInit(&amp;stm32_eth_handler, DMARxDscrTab, &amp;Rx_Buff[0][0], ETH_RXBUFNB))) { /*for Reception process*/ log_error("HAL_ETH_DMARxDescListInit %d\n", err); } /* (#)Enable MAC and DMA transmission and reception: */ HAL_ETH_Start(&amp;stm32_eth_handler); }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">broadcast</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stm32eth_xmit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct net_device *dev, struct sk_buff *skb)</span></span></span><span class="hljs-function"> </span></span>{ __IO ETH_DMADescTypeDef *dma_tx_desc; dma_tx_desc = stm32_eth_handler.TxDesc; <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>((<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *)dma_tx_desc-&gt;Buffer1Addr, skb-&gt;mac.raw, skb-&gt;len); <span class="hljs-comment"><span class="hljs-comment">/* Prepare transmit descriptors to give to DMA */</span></span> HAL_ETH_TransmitFrame(&amp;stm32_eth_handler, skb-&gt;len); skb_free(skb); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br></div></div><br>  For transmission, we allocate several buffers for the packets, and when the packet arrives for sending, we copy the data into the already selected area and then call the send function from STM32CUBE <br><br><div class="spoiler">  <b class="spoiler_title">Receipt of packets occurs by interruption:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> irq_return_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stm32eth_interrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> irq_num, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *dev_id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">net_device</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nic_p</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dev_id</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sk_buff</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb</span></span></span><span class="hljs-class">;</span></span> ETH_HandleTypeDef *heth = &amp;stm32_eth_handler; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!nic_p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IRQ_NONE; } <span class="hljs-comment"><span class="hljs-comment">/* Frame received */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (__HAL_ETH_DMA_GET_FLAG(heth, ETH_DMA_FLAG_R)) { <span class="hljs-comment"><span class="hljs-comment">/* Receive complete callback */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span> != (skb = low_level_input())) { skb-&gt;dev = nic_p; show_packet(skb-&gt;mac.raw, skb-&gt;len, <span class="hljs-string"><span class="hljs-string">"rx"</span></span>); netif_rx(skb); } <span class="hljs-comment"><span class="hljs-comment">/* Clear the Eth DMA Rx IT pending bits */</span></span> __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_R); } __HAL_ETH_DMA_CLEAR_IT(heth, ETH_DMA_IT_NIS); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IRQ_HANDLED; }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Receive function code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> struct sk_buff *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">low_level_input</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">sk_buff</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">skb</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> len; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *buffer; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; __IO ETH_DMADescTypeDef *dmarxdesc; skb = <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* get received frame */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (HAL_ETH_GetReceivedFrame_IT(&amp;stm32_eth_handler) != HAL_OK) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Obtain the size of the packet and put it into the "len" variable. */</span></span> len = stm32_eth_handler.RxFrameInfos.length; buffer = (<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *) stm32_eth_handler.RxFrameInfos.buffer; <span class="hljs-comment"><span class="hljs-comment">/* We allocate a pbuf chain of pbufs from the Lwip buffer pool */</span></span> skb = skb_alloc(len); <span class="hljs-comment"><span class="hljs-comment">/* copy received frame to pbuf chain */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (skb != <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">memcpy</span></span>(skb-&gt;mac.raw, buffer, len); } <span class="hljs-comment"><span class="hljs-comment">/* Release descriptors to DMA */</span></span> dmarxdesc = stm32_eth_handler.RxFrameInfos.FSRxDesc; <span class="hljs-comment"><span class="hljs-comment">/* Set Own bit in Rx descriptors: gives the buffers back to DMA */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt; stm32_eth_handler.RxFrameInfos.SegCount; i++) { dmarxdesc-&gt;Status |= ETH_DMARXDESC_OWN; dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc-&gt;Buffer2NextDescAddr); } <span class="hljs-comment"><span class="hljs-comment">/* Clear Segment_Count */</span></span> stm32_eth_handler.RxFrameInfos.SegCount =<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* When Rx Buffer unavailable flag is set: clear it and resume reception */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((stm32_eth_handler.Instance-&gt;DMASR &amp; ETH_DMASR_RBUS) != (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>)RESET) { <span class="hljs-comment"><span class="hljs-comment">/* Clear RBUS ETHERNET DMA flag */</span></span> stm32_eth_handler.Instance-&gt;DMASR = ETH_DMASR_RBUS; <span class="hljs-comment"><span class="hljs-comment">/* Resume DMA reception */</span></span> stm32_eth_handler.Instance-&gt;DMARPDR = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> skb; }</code> </pre> <br></div></div><br>  Actually, this is the whole driver.  After its implementation, all network utilities that we have in <a href="https://github.com/embox/embox">Embox work</a> .  You can read about the application in our previous articles ( <a href="https://habrahabr.ru/company/embox/blog/259721/">pjsip</a> and <a href="https://habrahabr.ru/company/embox/blog/249789/">httpd</a> ) <br><br>  In addition to the listed drivers based on stm32cube, spi, i2c, lcd, accelerator, gyroscope and others are also implemented. <br><br>  PS Our report was accepted on <a href="http://osday.ru/">OSDAY</a> (May 23-24 in Moscow), if it is interesting to hear live about the project, you are welcome. </div><p>Source: <a href="https://habr.com/ru/post/328866/">https://habr.com/ru/post/328866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../328856/index.html">The second group of learning Java and our news</a></li>
<li><a href="../328858/index.html">CRISP-DM: Proven Methodology for Data Scientists</a></li>
<li><a href="../328860/index.html">Test automation: who should do this, who needs it and how this area is changing</a></li>
<li><a href="../328862/index.html">Cisco Meraki MX: Security Settings on the Perimeter in 4 Clicks</a></li>
<li><a href="../328864/index.html">Why programmers can not program</a></li>
<li><a href="../328868/index.html">Analysis of the relationship of skills using graphs in R</a></li>
<li><a href="../328870/index.html">The best toys for future techies of our childhood (USSR and USA)</a></li>
<li><a href="../328872/index.html">More on one innovation in the latest version of SObjectizer</a></li>
<li><a href="../328874/index.html">PHDays VII: how the new rules of the "Confrontation" will affect the balance of power</a></li>
<li><a href="../328876/index.html">Antifraud systems in popular mobile trackers: AppsFlyer, Adjust, AppMetrica, TMC, Kochava</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>