<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The evolution of x86 architecture system calls</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Much has been said about system calls, for example, here or here . Surely you already know that a system call is a way to call an OS kernel function. ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The evolution of x86 architecture system calls</h1><div class="post__text post__text-html js-mediator-article"><p>  Much has been said about system calls, for example, <a href="https://habrahabr.ru/company/embox/blog/162229/">here</a> or <a href="https://habrahabr.ru/company/securitycode/blog/245539/">here</a> .  Surely you already know that a system call is a way to call an OS kernel function.  I also wanted to dig deeper and find out what is special about this system call, what implementations exist and what their performance is on the example of the x86-64 architecture.  If you are also interested in the answers to these questions, welcome under cat. </p><a name="habracut"></a><br><h2 id="system-call">  System call </h2><br><p>  Every time when we want to display something on the monitor, write to the device, read from the file, we have to contact the OS kernel.  It is the OS kernel that is responsible for any communication with hardware, it is there that work with interruptions, processor modes, task switching ... So that the program user could not overwhelm the entire operating system, it was decided to divide the memory <a href="https://en.wikipedia.org/wiki/User_space">space</a> into <a href="https://en.wikipedia.org/wiki/User_space">user space</a> (the memory area intended for user programs) and kernel space, and also to prohibit the user from accessing the OS kernel memory.  Implemented this separation in the x86-family hardware using <a href="https://en.wikipedia.org/wiki/X86_memory_segmentation">segmental memory protection</a> .  But the user program needs to somehow communicate with the kernel, for which the concept of <a href="https://en.wikipedia.org/wiki/System_call">system calls</a> was invented. </p><br><p>  A system call is a way for a user-space program to access kernel space.  From the outside, this may look like a call to a normal function with its own calling convention, but in fact the processor takes a little more action than when the call is called by a call instruction.  For example, in the x86 architecture during a system call, at a minimum, an increase in privilege level occurs, user segments are replaced with kernel segments, and the IP register is set to a system call handler. </p><br><p>  The programmer usually does not work with system calls directly, since system calls are wrapped in functions and hidden in various libraries, such as libc.so in Linux or ntdll.dll in Windows, with which the application developer interacts. </p><br><p>  Theoretically, a system call can be implemented using any exception, even though dividing by 0. The main thing is to transfer control to the kernel.  Consider real-world examples of exception implementations. </p><br><h2 id="sposoby-realizacii-sistemnyh-vyzovov">  Ways to implement system calls </h2><br><h3 id="vypolnenie-nevernoy-instrukcii">  Execution of invalid instructions. </h3><br><p>  Earlier, at 80386, this was the fastest way to make a system call.  For this, a meaningless and incorrect <em>LOCK NOP</em> instruction was usually used, after the execution of which the processor called the incorrect instruction handler.  It was more than 20 years ago and, they say, this method <a href="https://blogs.msdn.microsoft.com/oldnewthing/20041215-00/%3Fp%3D37003">handled</a> system calls at Microsoft.  The invalid instruction handler is now used for its intended purpose. </p><br><h3 id="call-gateshttpsenwikipediaorgwikicall_gate">  <a href="https://en.wikipedia.org/wiki/Call_gate">Call gates</a> </h3><br><p>  In order to have access to code segments with different levels of privileges, Intel developed a special set of descriptors called gate descriptors.  There are 4 types of such descriptors: </p><br><ul><li>  Call gates </li><li>  Trap gates (for exceptions, like <em>int 3</em> , requiring execution of a piece of code) </li><li>  Interrupt gates (similar to trap gates, but with some <a href="https://stackoverflow.com/questions/3425085/the-difference-between-call-gate-interrupt-gate-trap-gate">differences</a> ) </li><li>  Task gates (supposed to be used to switch tasks) </li></ul><br><p>  We are interested only in call gates, since it was through them that it was planned to implement system calls in x86. </p><br><p>  The call gate is implemented using the <em>call far</em> or <em>jmp far</em> instructions and takes as its parameter the call gate descriptor that is configured by the OS kernel.  It is a rather flexible mechanism, since it is possible to switch to any level of the protection ring, and to a 16-bit code.  Call gates are considered to be more productive than interrupts.  This method was used in OS / 2 and Windows 95. Due to the <a href="http://lkml.iu.edu/hypermail/linux/kernel/9706.2/0263.html">inconvenience of using</a> Linux, the mechanism was never implemented.  Over time, it completely ceased to be used, as there appeared more productive and easy to use implementations of system calls (sysenter / sysexit). </p><br><h2 id="sistemnye-vyzovy-realizovannye-v-linux">  System calls implemented in Linux </h2><br><p>  In the x86-64 architecture of the Linux operating system, there are several different ways to make system calls: </p><br><ul><li>  int 80h </li><li>  sysenter / sysexit </li><li>  syscall / sysret </li><li>  vsyscall </li><li>  vDSO </li></ul><br><p>  In the implementation of each system call has its own characteristics, but in general, the handler in Linux has approximately the same structure: </p><br><ul><li>  The <a href="https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention">protection</a> from reading / writing / executing user-space code is enabled. </li><li>  Replaces user stack with kernel stack, saves callee-saved registers. </li><li>  System call processing in progress </li><li>  Recovery stack registers </li><li>  Disable protection </li><li>  Exit from system call </li></ul><br><p>  Let's take a closer look at each system call. </p><br><h4 id="int-80h">  int 80h </h4><br><p>  Initially, in the x86 architecture, Linux used software interrupt <em>128</em> to make a system call.  To specify the number of the system call, the user sets the number of the system call in <em>eax</em> , and his parameters are arranged in order in the registers <em>ebx</em> , <em>ecx</em> , <em>edx</em> , <em>esi</em> , <em>edi</em> , <em>ebp</em> .  Next, the <em>int 80h</em> instruction is <em>called</em> , which programmatically causes an interrupt.  The processor calls the interrupt handler set by the Linux kernel during kernel initialization.  In x86-64, the interrupt call is used only during x32 emulation for backward compatibility. </p><br><p>  In principle, no one forbids using the instruction in <a href="https://en.wikipedia.org/wiki/Long_mode">advanced mode</a> .  But you should understand that a 32-bit <a href="">table of calls</a> is used and all used addresses should be placed in a 32-bit address space.  According to SYSTEM V ABI [4] ¬ß3.5.1, for programs whose virtual address is known at the linking stage and placed in 2GB, a <abbr title="small memory model">small memory model is</abbr> used by default and all known characters are in a 32-bit address space.  Under this definition fit statically compiled programs, where it is possible to use <em>int 80h</em> .  Step-by-step interrupt operation is described in detail on <a href="https://stackoverflow.com/questions/46087730/what-happens-if-you-use-the-32-bit-int-0x80-linux-abi-in-64-bit-code">stackoverflow</a> . </p><br><p>  In the core, the interrupt handler is the <em>entry_INT80_compat</em> function and is located in <em>arch / x86 / entry / entry_64_compat.S</em> </p><br><div class="spoiler">  <b class="spoiler_title">Call example int 80h</b> <div class="spoiler_text"><pre><code class="hljs sql">section .text global _start _start: mov edx,len mov ecx,msg mov ebx,1 ; file descriptor (stdout) mov eax,4 ; system <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> (sys_write) <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> kernel mov eax,<span class="hljs-number"><span class="hljs-number">1</span></span> ; system <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> <span class="hljs-built_in"><span class="hljs-built_in">number</span></span> (sys_exit) <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> kernel <span class="hljs-keyword"><span class="hljs-keyword">section</span></span> .data msg db <span class="hljs-string"><span class="hljs-string">'Hello, world!'</span></span>,<span class="hljs-number"><span class="hljs-number">0xa</span></span> <span class="hljs-keyword"><span class="hljs-keyword">len</span></span> equ $ - msg</code> </pre> <br><p>  Compilation: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">nasm</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">elf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main32</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-melf_i386</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main32</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a32</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.out</span></span></code> </pre> <br><p>  Or in the advanced mode (the program works as it is compiled statically) </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">nasm</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">elf64</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.out</span></span></code> </pre> </div></div><br><h4 id="sysentersysexit">  sysenter / sysexit </h4><br><p>  After some time, even when there was no x86-64, Intel realized that it was possible to speed up system calls by creating a special system call instruction, thereby bypassing some interruption costs.  So a pair of <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf">sysenter / sysexit</a> instructions <a href="https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf">appeared</a> .  Acceleration is achieved due to the fact that at the hardware level, when executing the sysenter instruction, many checks for the validity of descriptors are dropped, as well as checks that depend on the privilege level [3] ¬ß6.1.  Also, the instruction is based on the fact that the program calling it uses a flat memory model.  In the Intel architecture, the instruction is valid for both compatibility mode and advanced mode, but for AMD this instruction in advanced mode eliminates the unknown opcode [3].  Therefore, at present, the <em>sysenter / sysexit pair is</em> used only in compatibility mode. </p><br><p>  In the kernel, the handler for this instruction is the <em>entry_SYSENTER_compat</em> function and is located in <em>arch / x86 / entry / entry_64_compat.S</em> </p><br><div class="spoiler">  <b class="spoiler_title">Sysenter call example</b> <div class="spoiler_text"><pre> <code class="hljs perl">section .text global _start _start: mov edx,len ;message <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> mov ecx,msg ;message to <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> mov ebx,<span class="hljs-number"><span class="hljs-number">1</span></span> ;file descriptor (stdout) mov eax,<span class="hljs-number"><span class="hljs-number">4</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">system</span></span> call number (sys_write) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> continue_l <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp mov ebp,esp sysenter hlt ; dumb instructions that is going to be skipped continue_l: mov eax,<span class="hljs-number"><span class="hljs-number">1</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">system</span></span> call number (sys_exit) mov ebx,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp mov ebp,esp sysenter section .data msg db <span class="hljs-string"><span class="hljs-string">'Hello, world!'</span></span>,<span class="hljs-number"><span class="hljs-number">0xa</span></span> len equ $ - msg</code> </pre> <br><p>  Compiling: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">nasm</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">elf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-melf_i386</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.out</span></span></code> </pre> <br><p>  Despite the fact that the instruction is valid in the implementation of the architecture from Intel, it is most likely that such a system call cannot be used in the advanced mode.  This is due to the fact that the current value of the stack is stored in the <em>ebp</em> register, and the top address, regardless of the memory model, is outside the 32-bit address space.  This is all because Linux displays the stack at the end of the lower half of the <a href="https://en.wikipedia.org/wiki/X86-64">canonical address of the</a> space. </p></div></div><br><p>  Linux kernel developers warn users against sysenter hard programming because system call ABI may change.  Due to the fact that Android did not follow this advice, Linux had to roll back its <a href="https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/%3Fid%3D30bfa7b3488bfb1bb75c9f50a5fcac1832970c60">patch</a> to maintain backward compatibility.  Correctly implement a system call using vDSO, which will be discussed later. </p><br><h4 id="syscallsysret">  syscall / sysret </h4><br><p>  Since AMD developed the x86-64 architecture, which is called AMD64, they decided to create their own system call.  The instruction was developed by AMD, as an analogue of <em>sysenter / sysexit</em> for the IA-32 architecture.  AMD made sure that the instruction was implemented both in the advanced mode and in the compatibility mode, but Intel decided not to support this instruction in the compatibility mode.  Despite all this, Linux has 2 handlers for each of the modes: for x32 and x64.  The handlers for this instruction are the <em>entry_SYSCALL_64</em> functions for x64 and <em>entry_SYSCALL_compat</em> for x32 and are located in <em>arch / x86 / entry / entry_64.S</em> and <em>arch / x86 / entry / entry_64_compat.S,</em> respectively. </p><br><p>  Who is interested in learning more about the system call instructions, in the Intel [0] manual (¬ß4.3) their pseudo-code is given. </p><br><div class="spoiler">  <b class="spoiler_title">Syscall call example</b> <div class="spoiler_text"><pre> <code class="hljs pgsql">section .text <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> _start _start: mov rdx,len ;message length mov rsi,msg ;message <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> mov rdi,<span class="hljs-number"><span class="hljs-number">1</span></span> ;file descriptor (stdout) mov rax,<span class="hljs-number"><span class="hljs-number">1</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">system</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> number (sys_write) syscall mov rax,<span class="hljs-number"><span class="hljs-number">60</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">system</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> number (sys_exit) syscall section .data msg db <span class="hljs-string"><span class="hljs-string">'Hello, world!'</span></span>,<span class="hljs-number"><span class="hljs-number">0xa</span></span> len equ $ - msg</code> </pre> <br><p>  Compiling </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">nasm</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">elf64</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.out</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Example of a 32-bit syscall call</b> <div class="spoiler_text"><p>  To test the following example, you will need a kernel with the configuration <em>CONFIG_IA32_EMULATION = y</em> and an AMD computer.  If you have an Intel computer, you can run the example on a virtual machine.  Linux can change the ABI and this system call without warning, so I‚Äôll remind you once again that system calls in compatibility mode are more properly executed via vDSO. </p><br><pre> <code class="hljs perl">section .text global _start _start: mov edx,len ;message <span class="hljs-keyword"><span class="hljs-keyword">length</span></span> mov ebp,msg ;message to <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> mov ebx,<span class="hljs-number"><span class="hljs-number">1</span></span> ;file descriptor (stdout) mov eax,<span class="hljs-number"><span class="hljs-number">4</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">system</span></span> call number (sys_write) <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> continue_l <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> hlt continue_l: mov eax,<span class="hljs-number"><span class="hljs-number">1</span></span> ;<span class="hljs-keyword"><span class="hljs-keyword">system</span></span> call number (sys_exit) mov ebx,<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ecx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> edx <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> ebp <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> section .data msg db <span class="hljs-string"><span class="hljs-string">'Hello, world!'</span></span>,<span class="hljs-number"><span class="hljs-number">0xa</span></span> len equ $ - msg</code> </pre> <br><p>  Compilation: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">nasm</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-f</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">elf</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.s</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ld</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-melf_i386</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.out</span></span></code> </pre> </div></div><br><p>  The reason why AMD decided to develop its instruction instead of extending the Intel <em>sysenter</em> instruction to the x86-64 architecture is not clear. </p><br><h4 id="vsyscall">  vsyscall </h4><br><p>  When moving from user space to kernel space, a context switch occurs, which is not the cheapest operation.  Therefore, to improve the performance of system calls, it was decided to process them in user space.  For this, 8 MB of memory was reserved for mapping kernel space into user space.  In this memory for the x86 architecture, 3 implementations of commonly used read-only calls were placed: gettimeofday, time, getcpu. </p><br><p>  Over time, it became clear that <em>vsyscall</em> has significant drawbacks.  Fixed placement in the address space is a security vulnerability, and the lack of flexibility in the amount of allocated memory can adversely affect the expansion of the displayed kernel area. </p><br><p>  In order for the example to work, it is necessary that <em>vsyscall</em> support is enabled in the kernel: <em>CONFIG_X86_VSYSCALL_EMULATION = y</em> </p><br><div class="spoiler">  <b class="spoiler_title">Vsyscall call example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/time.h&gt; #include &lt;stdio.h&gt; #define VSYSCALL_ADDR 0xffffffffff600000UL int main() { // Offsets in x86-64 // 0: gettimeofday // 1024: time // 2048: getcpu int (*f)(struct timeval *, struct timezone *); struct timeval tm; unsigned long addrOffset = 0; f = (void*)VSYSCALL_ADDR + addrOffset; f(&amp;tm, NULL); printf("%d:%d\n", tm.tv_sec, tm.tv_usec); }</span></span></span></span></code> </pre> <br><p>  Compilation: </p><br><pre> <code class="hljs swift">gcc main.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span></code> </pre> <br><p>  Linux does not display <em>vsyscall</em> in compatibility mode. </p></div></div><br><p>  At this point, to maintain backward compatibility, the Linux kernel provides <em>vsyscall</em> emulation.  Emulation is done to patch security holes at the expense of performance. </p><br><p>  Emulation can be implemented in two ways. </p><br><p>  The first way is by replacing the function address with the <em>syscall</em> system call.  In this case, the virtual system call of the <em>gettimeofday</em> function on x86-64 is as follows: </p><br><pre> <code class="hljs perl">movq $0x6<span class="hljs-number"><span class="hljs-number">0</span></span>, %rax <span class="hljs-keyword"><span class="hljs-keyword">syscall</span></span> ret</code> </pre> <br><p>  Where 0x60 is the gettimeofday system call <em>code</em> . </p><br><p>  The second method is a bit more interesting.  When the <em>vsyscall</em> function is <em>called</em> , a <a href="https://en.wikipedia.org/wiki/Page_fault"><em>Page fault is</em></a> thrown, which is handled by Linux.  The OS sees that the error occurred due to the execution of the instruction at the <em>vsyscall</em> address and passes control to the virtual system call <em>handler emulate_vsyscall</em> (arch / x86 / entry / vsyscall / vsyscall_64.c). </p><br><p>  The vsyscall implementation can be controlled using the <em>vsyscall</em> kernel <em>parameter</em> .  You can either disable the virtual system call using the parameter <code>vsyscall=none</code> , set the implementation using the syscall instruction <code>syscall=native</code> , or through <em>Page fault</em> <code>vsyscall=emulate</code> . </p><br><h4 id="vdso-virtual-dynamic-shared-object">  vDSO (Virtual Dynamic Shared Object) </h4><br><p>  To correct the main drawback of <em>vsyscall</em> , it was proposed to implement system calls in the form of a display of a dynamically connected library to which <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization"><em>ASLR</em></a> technology is applied.  In the "long" mode, the library is called <em>linux-vdso.so.1</em> , and in compatibility mode, the <em>linux-gate.so.1</em> .  The library is automatically loaded for each process, even statically compiled.  You can see the dependencies of the application from it using the <code>ldd</code> utility in the case of dynamic linking of the libc library. </p><br><p>  Also, vDSO is used as a choice of the most efficient method of system call, <a href="https://blog.packagecloud.io/eng/2016/04/05/the-definitive-guide-to-linux-system-calls/">for example,</a> in compatibility mode. </p><br><p>  A list of shared functions can be found in the <a href="http://man7.org/linux/man-pages/man7/vdso.7.html">manual</a> . </p><br><div class="spoiler">  <b class="spoiler_title">VDSO call example</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/time.h&gt; #include &lt;dlfcn.h&gt; #include &lt;stdio.h&gt; #include &lt;assert.h&gt; #if defined __x86_64__ #define VDSO_NAME "linux-vdso.so.1" #else #define VDSO_NAME "linux-gate.so.1" #endif int main() { int (*f)(struct timeval *, struct timezone *); struct timeval tm = {0}; void *vdso = dlopen(VDSO_NAME, RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD); assert(vdso &amp;&amp; "vdso not found"); f = dlsym(vdso, "__vdso_gettimeofday"); assert(f); f(&amp;tm, NULL); printf("%d:%d\n", tm.tv_sec, tm.tv_usec); }</span></span></span></span></code> </pre> <br><p>  Compilation: </p><br><pre> <code class="hljs swift">gcc -ldl main.<span class="hljs-built_in"><span class="hljs-built_in">c</span></span></code> </pre> <br><p>  For compatibility mode: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">gcc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ldl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-m32</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a32</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.elf</span></span></code> </pre> </div></div><br><p>  It is best to look for vDSO functions by retrieving the library address from the auxiliary AT_SYSINFO_EHDR vector and then parsing the shared object.  An example of parsing vDSO from an auxiliary vector can be found in the kernel source code: tools / testing / selftests / vDSO / parse_vdso.c </p><br><p>  Or if you're interested, you can dig and see how vDSO parses in glibc: </p><br><ol><li>  Parsing helper vectors: elf / dl-sysdep.c </li><li>  Parsing a shared library: elf / setup-vdso.h </li><li>  Setting function values: sysdeps / unix / sysv / linux / x86_64 / init-first.c, sysdeps / unix / sysv / linux / x86 / gettimeofday.c, sysdeps / unix / sysv / linux / x86 / time.c </li></ol><br><p>  According to System V ABI AMD64 [4], calls should occur using the <em>syscall</em> instruction.  In practice, calls to this instruction are added via vDSO.  Support for system calls in the form of <em>int 80h</em> and <em>vsyscall</em> remained for backward compatibility. </p><br><h2 id="sravnenie-proizvoditelnosti-sistemnyh-vyzovov">  System Call Performance Comparison </h2><br><p>  With testing the speed of system calls, everything is ambiguous.  In the x86 architecture, the execution of one instruction is influenced by many factors such as the presence of instructions in the cache, the pipeline workload, even there is a table of delays for this architecture [2].  Therefore, it is rather difficult to determine the speed of execution of a code segment.  Intel even has a special time measurement guide for the code section [1].  But the problem is that we cannot measure time according to the document due to the fact that we need to call kernel objects from user space. </p><br><p>  Therefore, it was decided to measure time using <em>clock_gettime</em> and test the performance of a <em>gettimeofday</em> call, as it is in all implementations of system calls.  On different processors, time may vary, but in general, the relative results should be similar. </p><br><p>  The program was launched several times and as a result, the minimum execution time was taken. <br>  Testing <em>int 80h</em> , <em>sysenter</em> and <em>vDSO-32 was</em> performed in compatibility mode. </p><br><div class="spoiler">  <b class="spoiler_title">Testing program</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sys/time.h&gt; #include &lt;time.h&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;assert.h&gt; #include &lt;syscall.h&gt; #include &lt;dlfcn.h&gt; #include &lt;limits.h&gt; #define min(a,b) ((a) &lt; (b)) ? (a) : (b) #define GIGA 1000000000 #define difftime(start, end) (end.tv_sec - start.tv_sec) * GIGA + end.tv_nsec - start.tv_nsec static struct timeval g_timespec; #if defined __x86_64__ static inline int test_syscall() { register long int result asm ("rax"); asm volatile ( "lea %[p0], %%rdi \n\t" "mov $0, %%rsi \n\t" "mov %[sysnum], %%rax \n\t" "syscall \n\t" : "=r"(result) : [sysnum] "i" (SYS_gettimeofday), [p0] "m" (g_timespec) : "rcx", "rsi"); return result; } #endif static inline int test_int80h() { register int result asm ("eax"); asm volatile ( "lea %[p0], %%ebx \n\t" "mov $0, %%ecx \n\t" "mov %[sysnum], %%eax \n\t" "int $0x80 \n\t" : "=r"(result) : [sysnum] "i" (SYS_gettimeofday), [p0] "m" (g_timespec) : "ebx", "ecx"); return result; } int (*g_f)(struct timeval *, struct timezone *); static void prepare_vdso() { void *vdso = dlopen("linux-vdso.so.1", RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD); if (!vdso) { vdso = dlopen("linux-gate.so.1", RTLD_LAZY | RTLD_LOCAL | RTLD_NOLOAD); } assert(vdso &amp;&amp; "vdso not found"); g_f = dlsym(vdso, "__vdso_gettimeofday"); } static int test_g_f() { return g_f(&amp;g_timespec, 0); } #define VSYSCALL_ADDR 0xffffffffff600000UL static void prepare_vsyscall() { g_f = (void*)VSYSCALL_ADDR; } static inline int test_sysenter() { register int result asm ("eax"); asm volatile ( "lea %[p0], %%ebx \n\t" "mov $0, %%ecx \n\t" "mov %[sysnum], %%eax \n\t" "push $cont_label%=\n\t" "push %%ecx \n\t" "push %%edx \n\t" "push %%ebp \n\t" "mov %%esp, %%ebp \n\t" "sysenter \n\t" "cont_label%=: \n\t" : "=r"(result) : [sysnum] "i" (SYS_gettimeofday), [p0] "m" (g_timespec) : "ebx", "esp"); return result; } #ifdef TEST_SYSCALL #define TEST_PREPARE() #define TEST_PROC_CALL() test_syscall() #elif defined TEST_VDSO #define TEST_PREPARE() prepare_vdso() #define TEST_PROC_CALL() test_g_f() #elif defined TEST_VSYSCALL #define TEST_PREPARE() prepare_vsyscall() #define TEST_PROC_CALL() test_g_f() #elif defined TEST_INT80H #define TEST_PREPARE() #define TEST_PROC_CALL() test_int80h() #elif defined TEST_SYSENTER #define TEST_PREPARE() #define TEST_PROC_CALL() test_sysenter() #else #error Choose test #endif static inline unsigned long test() { unsigned long result = ULONG_MAX; struct timespec start = {0}, end = {0}; int rt, rt2, rt3; for (int i = 0; i &lt; 1000; ++i) { rt = clock_gettime(CLOCK_MONOTONIC, &amp;start); rt3 = TEST_PROC_CALL(); rt2 = clock_gettime(CLOCK_MONOTONIC, &amp;end); assert(rt == 0); assert(rt2 == 0); assert(rt3 == 0); result = min(difftime(start, end), result); } return result; } int main() { TEST_PREPARE(); // prepare calls int a = TEST_PROC_CALL(); assert(a == 0); a = TEST_PROC_CALL(); assert(a == 0); a = TEST_PROC_CALL(); assert(a == 0); unsigned long result = test(); printf("%lu\n", result); }</span></span></span></span></code> </pre> <br><p>  Compilation: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">gcc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-O2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-DTEST_SYSCALL</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time_test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_syscall</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gcc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-O2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-DTEST_VDSO</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ldl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time_test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_vdso</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gcc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-O2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-DTEST_VSYSCALL</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time_test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_vsyscall</span></span> <span class="hljs-selector-id"><span class="hljs-selector-id">#m32</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gcc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-O2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-DTEST_VDSO</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ldl</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-m32</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time_test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_vdso_32</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gcc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-O2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-DTEST_INT80H</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-m32</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time_test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_int80</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">gcc</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-O2</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-DTEST_SYSENTER</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-m32</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">time_test</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.c</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">-o</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">test_sysenter</span></span></code> </pre> </div></div><br><p>  <strong>About the system</strong> <br> <code>cat /proc/cpuinfo | grep "model name" -m 1</code>  <code>cat /proc/cpuinfo | grep "model name" -m 1</code> - Intel¬Æ Core (TM) i7-5500U CPU @ 2.40GHz <br>  <code>uname -r</code> - 4.14.13-1-ARCH </p><br><p>  <strong>Results Table</strong> </p><br><table><thead><tr><th>  Implementation </th><th>  time (ns) </th></tr></thead><tbody><tr><td>  int 80h </td><td>  498 </td></tr><tr><td>  sysenter </td><td>  338 </td></tr><tr><td>  syscall </td><td>  278 </td></tr><tr><td>  vsyscall emulate </td><td>  692 </td></tr><tr><td>  vsyscall native </td><td>  278 </td></tr><tr><td>  vDSO </td><td>  37 </td></tr><tr><td>  vDSO-32 </td><td>  51 </td></tr></tbody></table><br><p>  As you can see, each new implementation of the system call is more productive than the previous one, not counting vsysvall, since this is emulation.  As you probably already guessed, if vsyscall were the way it was conceived, the call time would be similar to vDSO. </p><br><p>  All current performance comparisons were made with a KPTI patch fixing the meltdown vulnerability. </p><br><h2 id="bonus-proizvoditelnost-sistemnyh-vyzovov-bez-kptihttpsenwikipediaorgwikikernel_page-table_isolation">  Bonus: Productivity of system calls without <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">KPTI</a> </h2><br><p>  The KPTI patch was developed specifically to fix the meltdown vulnerability.  As you know, this patch slows down the performance of the OS.  Check performance with KPTI turned off (pti = off). </p><br><p>  <strong>Result table with patch off</strong> </p><br><table><thead><tr><th>  Implementation </th><th>  Time (ns) </th><th>  Increased execution time after patch (ns) </th><th>  Performance degradation after patch <code>(t1 - t0) / t0 * 100%</code> </th></tr></thead><tbody><tr><td>  int 80h </td><td>  317 </td><td>  181 </td><td>  57% </td></tr><tr><td>  sysenter </td><td>  150 </td><td>  188 </td><td>  125% </td></tr><tr><td>  syscall </td><td>  103 </td><td>  175 </td><td>  170% </td></tr><tr><td>  vsyscall emulate </td><td>  496 </td><td>  196 </td><td>  40% </td></tr><tr><td>  vsyscall native </td><td>  103 </td><td>  175 </td><td>  170% </td></tr><tr><td>  vDSO </td><td>  37 </td><td>  0 </td><td>  0% </td></tr><tr><td>  vDSO-32 </td><td>  51 </td><td>  0 </td><td>  0% </td></tr></tbody></table><br><p>               180 .  ,       TLB-. </p><br><p>     vDSO     ,          , , ,    TLB-. </p><br><h4 id="dlya-dalneyshego-chteniya">    </h4><br><pre> <code class="hljs coffeescript">      Linux (  , ): https:<span class="hljs-regexp"><span class="hljs-regexp">//</span></span><span class="hljs-number"><span class="hljs-number">0xa</span></span>x.gitbooks.io<span class="hljs-regexp"><span class="hljs-regexp">/linux-insides/content/SysCall/syscall-3.html   Linux: https:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/www.win.tue.nl/</span></span>~aeb<span class="hljs-regexp"><span class="hljs-regexp">/linux/lk/lk-4.html   ,  1: https:/</span></span><span class="hljs-regexp"><span class="hljs-regexp">/lwn.net/Articles/604287/</span></span>   ,  <span class="hljs-number"><span class="hljs-number">2</span></span>: https:<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>lwn.net<span class="hljs-regexp"><span class="hljs-regexp">/Articles/604515/</span></span></code> </pre> <br><h4 id="ssylki">  Links </h4><br><p> [0] <a href="https://www.intel.ru/content/www/ru/ru/architecture-and-technology/64-ia-32-architectures-software-developer-vol-2b-manual.html">Intel 64 and IA-32 Architectures Developer's Manual: Vol. 2B</a> <br> [1] <a href="https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf">How to benchmark code execution times ...</a> <br> [2] <a href="https://gmplib.org/~tege/x86-timing.pdf">Instruction latencies and throughput for AMD and Intel x86 processors</a> <br> [3] <a href="http://developer.amd.com/wordpress/media/2012/10/24593_APM_v21.pdf">AMD64 Architecture Programmer's Manual Volume 2: System Programming</a> <br> [4] <a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-r252.pdf">System V ABI AMD64</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347596/">https://habr.com/ru/post/347596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347586/index.html">How I made AI to identify fake news with an accuracy of 95% and almost went crazy</a></li>
<li><a href="../347588/index.html">Tough and flexible IT skills: everything is more and less serious than I would like to think</a></li>
<li><a href="../347590/index.html">Open science school hackathon DeepHack.Babel</a></li>
<li><a href="../347592/index.html">Telegram bot for complex quests</a></li>
<li><a href="../347594/index.html">Beautiful Chromium and gnarled memset</a></li>
<li><a href="../347598/index.html">Legal aspects of domain space</a></li>
<li><a href="../347600/index.html">Friday format: ‚Äúlanguage development‚Äù - research that combines IT and linguistics</a></li>
<li><a href="../347604/index.html">File system steganography</a></li>
<li><a href="../347606/index.html">Dynamic email :: practical use</a></li>
<li><a href="../347608/index.html">Report from the last Christmas Agile MeetUp</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>