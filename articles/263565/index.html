<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Magic of tensor algebra: Part 13 - SKA Maxima in problems of transforming tensor expressions. Angular velocity and acceleration in the parameters of Rodrigues-Hamilton</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


1. What is a tensor and what is it for? 
2. Vector and tensor operations. Ranks of tensors 
3. Curved coordinates 
4. Dynamics of a point i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Magic of tensor algebra: Part 13 - SKA Maxima in problems of transforming tensor expressions. Angular velocity and acceleration in the parameters of Rodrigues-Hamilton</h1><div class="post__text post__text-html js-mediator-article"><h1>  Content </h1><br><ol><li>  <a href="http://habrahabr.ru/post/261421/">What is a tensor and what is it for?</a> </li><li>  <a href="http://habrahabr.ru/post/261615/">Vector and tensor operations.</a>  <a href="http://habrahabr.ru/post/261615/">Ranks of tensors</a> </li><li>  <a href="http://habrahabr.ru/post/261717/">Curved coordinates</a> </li><li>  <a href="http://habrahabr.ru/post/261803/">Dynamics of a point in the tensor representation</a> </li><li>  <a href="http://habrahabr.ru/post/261991/">Actions on tensors and some other theoretical questions</a> </li><li>  <a href="http://habrahabr.ru/post/262129/">Kinematics of free solid.</a>  <a href="http://habrahabr.ru/post/262129/">Nature of angular velocity</a> </li><li>  <a href="http://habrahabr.ru/post/262263/">The final turn of a solid.</a>  <a href="http://habrahabr.ru/post/262263/">Rotation tensor properties and method for calculating it</a> </li><li>  <a href="http://habrahabr.ru/post/262497/">On convolutions of the Levi-Civita tensor</a> </li><li>  <a href="http://habrahabr.ru/post/262801/">Conclusion of the angular velocity tensor through the parameters of the final rotation.</a>  <a href="http://habrahabr.ru/post/262801/">Apply head and maxima</a> </li><li>  <a href="http://habrahabr.ru/post/262957/">Get the angular velocity vector.</a>  <a href="http://habrahabr.ru/post/262957/">We work on the shortcomings</a> </li><li>  <a href="http://habrahabr.ru/post/263345/">Acceleration of the point of the body with free movement.</a>  <a href="http://habrahabr.ru/post/263345/">Solid Corner Acceleration</a> </li><li>  <a href="http://habrahabr.ru/post/263533/">Rodrig ‚Äì Hamilton parameters in solid kinematics</a> </li><li>  <a href="http://habrahabr.ru/post/263565/">SKA Maxima in problems of transformation of tensor expressions.</a>  <a href="http://habrahabr.ru/post/263565/">Angular velocity and acceleration in the parameters of Rodrig-Hamilton</a> </li><li>  <a href="http://habrahabr.ru/post/263687/">Non-standard introduction to solid body dynamics</a> </li><li>  <a href="http://habrahabr.ru/post/263853/">Non-free rigid motion</a> </li><li>  <a href="http://habrahabr.ru/post/264007/">Properties of the inertia tensor of a solid</a> </li><li>  <a href="http://habrahabr.ru/post/264099/">Sketch of nut Janibekov</a> </li><li>  <a href="http://habrahabr.ru/post/264381/">Mathematical modeling of the Janibekov effect</a> </li></ol><br><br><h1>  Introduction </h1><br><br>  In this article we will solve two questions - we will get expressions for the angular velocity and angular acceleration using the Rodrig ‚Äì Hamilton parameters, which we talked about in more detail than planned in the <a href="http://habrahabr.ru/post/263533/">previous article</a> .  And at the same time we will demonstrate how you can use the open SKA Maxima for this purpose, which, as it turned out, copes well with tensors, and with certain skills, it can be a great help in solving scientific problems.  For me, Maxima is a new product, before that I worked with Maple and quite a bit with Mathematica.  Therefore, perhaps some of the techniques I use may seem unprofessional. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/4d8/77e/4a7/4d877e4a75564beab6005408f6b48caf.jpg"><br>  <i>SKA is ready to help us and is waiting for a reasonable team ...</i> <br><br><br>  Last time, we stopped at what showed how quaternion algebra can be used to represent a transformation of a turn.  Knowing the direction of the axis of rotation, given by the ort <img src="https://tex.s2cms.ru/svg/%5Cvec%20u" alt="image">  and the angle to rotate the coordinate system <img src="https://tex.s2cms.ru/svg/%5Cvarphi" alt="image">  you can build a unit quaternion to the components <br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Clambda_%7B%5C%2C0%7D%20%3D%20%5Ccos%5Cfrac%7B%5Cvarphi%7D%7B2%7D%2C%20%5Cquad%20%5Cvec%5Clambda%20%3D%20%5Csin%5Cfrac%7B%5Cvarphi%7D%7B2%7D%20%5C%2C%20%5Cvec%20u%20%5Cquad%20(1)" alt="image"></div><br>  and then, the direct transformation of the rotation of the vector <img src="https://tex.s2cms.ru/svg/%5Cvec%20r" alt="image">  reduced to multiplication of quaternions <br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cvec%20r%5E%7B%5C%2C(0)%7D%20%3D%20%5CLambda%20%5Ccirc%20%5Cvec%20r%5E%7B%5C%2C(1)%7D%20%5Ccirc%20%5Coverline%5CLambda%20%5Cquad%20(2)" alt="image"></div><br>  and the inverse transform <br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cvec%20r%5E%7B%5C%2C(1)%7D%20%3D%20%5Coverline%5CLambda%20%5Ccirc%20%5Cvec%20r%5E%7B%5C%2C(0)%7D%20%5Ccirc%20%5CLambda%20%5Cquad%20(3)" alt="image"></div><br>  We have shown that the transformations (2) and (3) carried out directly on the vector give the Rodrigue formula describing the final turn.  Now our goal is to connect the parameters of the rotation quaternion with the rotation tensor and pseudovectors of angular velocity and angular acceleration. <br><br><a name="habracut"></a><br><br><h1>  1. The rotation tensor in the parameters of Rodrigues-Hamilton </h1><br><br>  We already know the expression for the rotation tensor <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/B_k%5E%7B%5C%2Cm%7D%20%3D%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)u%5E%7B%5C%2Cm%7D%20%5C%2C%20u_%7B%5C%2Ck%7D%20%2B%20%5Ccos%5Cvarphi%20%5C%2C%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cm%7D%20%2B%20%5Csin%5Cvarphi%20%5C%2C%20g%5E%7Bmi%7D%20%5C%2C%20%5Cvarepsilon_%7B%5C%2Cijk%7D%20%5C%2C%20u%5E%7B%5C%2Cj%7D%5Cquad(4)" alt="image"></div><br><br>  We introduce a quaternion by presenting its vector part by contravariant components. <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Clambda_%7B%5C%2C0%7D%20%3D%20%5Ccos%5Cfrac%7B%5Cvarphi%7D%7B2%7D%2C%20%5Cquad%20%5Clambda%5E%7B%5C%2Cj%7D%20%3D%20%5Csin%5Cfrac%7B%5Cvarphi%7D%7B2%7D%20%5C%2C%20u%5E%7B%5C%2Cj%7D%20%5Cquad%20(5)" alt="image"></div><br><br>  In this case, substitution (5) into (4) can be performed manually, this process does not imply anything extraordinary.  But we will do everything in Maxima, at the same time preparing some basic data for further work.  We configure Maxima for work with tensors in three-dimensional space <br><br><pre><code class="hljs sql"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">kill</span></span>(all); <span class="hljs-comment"><span class="hljs-comment">/*         LaTeX  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">load</span></span>(itensor); <span class="hljs-keyword"><span class="hljs-keyword">load</span></span>(tentex); <span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> imetric(g); idim(3);</code> </pre> <br><br>  Enter the expression (4) of the rotation tensor <br><br><pre> <code class="hljs matlab">B:ishow(<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span>*u([],[m])*u([k],[]) + (<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span>)*kdelta([k],[m]) + <span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)*g([],[m,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>])*<span class="hljs-string"><span class="hljs-string">'levi_civita([i,j,k],[])*u([],[j]))$</span></span></code> </pre><br><br>  Pay attention to the nuance - we moved to half corners.  Otherwise, when trying to simplify trigonometry, Maxima will not simplify anything, even setting the <code>halfangles</code> flag, which includes taking into account half-argument formulas, does not help.  This is the first crutch that I had to use.  Perhaps unknowingly. <br><br>  Set the relationship between the parameters of the final rotation and the components of the quaternion <br><br><pre> <code class="hljs matlab">Lambda0:p0 = <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>); Lambda:ishow(p([],[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]) = <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)*u([],[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]))$</code> </pre><br><br>  Here, for brevity (laziness to enter <code>lambda</code> each time), the components of the quaternion are indicated by the letter <code>p</code> <br><br>  Express the orth of the rotation axis through the vector part of the quaternion <br><br><pre> <code class="hljs matlab">Solv1:ishow(solve(Lambda, u([],[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>])))$</code> </pre><br><br>  outputting the solution to the equation as an array of expressions <br><br><img src="https://habrastorage.org/files/52c/5ba/06a/52c5ba06a41b4a5282657980cda12027.png"><br><br>  In the resulting expression, it is necessary to omit the index, since the rotation tensor contains the covariant components of the rotation form.  To do this, we collapse the previously obtained expression with the metric tensor <br><br><pre> <code class="hljs matlab">u_k:ishow(contract(Solv1[<span class="hljs-number"><span class="hljs-number">1</span></span>]*g([k,<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>],[])))$</code> </pre><br><br>  In addition, we replace the index <i>j</i> with <i>m</i> in the covariant components <br><br><pre> <code class="hljs matlab">um:ishow(subst(m, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>, Solv1[<span class="hljs-number"><span class="hljs-number">1</span></span>]))$</code> </pre><br><br>  As a result, we get two expressions ready for substitution in the rotation tensor <br><br><img src="https://habrastorage.org/files/83f/bb9/f92/83fbb9f921cf4748b57fa396f5f61e0c.png"><br><br>  Now we can substitute the components of the ort of the axis of rotation into the expression for the rotation tensor.  The <code>subst()</code> setting function in this case takes two arguments ‚Äî an expression that needs to be substituted into the expression that comes with the second argument.  In this case, in the transformed expression, the left side of the first argument is searched for and replaced with its right side. <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">B_1:</span></span>ishow(subst(u_k, B))$ <span class="hljs-symbol"><span class="hljs-symbol">B_1:</span></span>ishow(subst(um, B_1))$ <span class="hljs-symbol"><span class="hljs-symbol">B_1:</span></span>ishow(subst(Solv1[<span class="hljs-number"><span class="hljs-number">1</span></span>], B_1))$</code> </pre><br><br>  At the exit we have <br><br><img src="https://habrastorage.org/files/550/fc5/4ab/550fc54ab1bd452b82a5bc30ed2797bb.png"><br><br>  Great, now the components of the vector part of the quaternion appear in the rotation tensor.  Now simplify trigonometry <br><br><pre> <code class="hljs">B_2:ishow(trigsimp(B_1))$</code> </pre><br><br>  The <code>trigsim()</code> function simplifies trigonometric expressions.  In this case, as written in the documentation, takes into account the basic basic trigonometric identity and the parity / oddness of trigonometric functions.  However, whether the loading of a package of tensor algebra has such an effect, this function stumbles upon the simplification of fractions containing functions of single and half arguments, even when the flag is raised, which was mentioned above.  Nevertheless, we carried out the preparatory work and at the output we obtain a simplified formula <br><br><img src="https://habrastorage.org/files/037/07f/75f/03707f75fe814996abc4377e8876aa04.png"><br><br>  It remains to replace the squares of the cosine and sine of the half angle of rotation by the scalar parameter of the quaternion, for which we perform the substitution and simplification in the form of opening the brackets <br><br><pre> <code class="hljs pgsql">B_3:ishow(subst(p0,rhs(Lambda0), B_2))$ B_3:ishow(expand(subst(<span class="hljs-number"><span class="hljs-number">1</span></span>-p0^<span class="hljs-number"><span class="hljs-number">2</span></span>,sin(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span>, B_3)))$</code> </pre><br><br>  And, to admire the result, we derive it in LaTeX <br><br><pre> <code class="hljs lisp">tentex(<span class="hljs-name"><span class="hljs-name">B_3</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><br>  I added only the left part to the displayed code. <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/B_%7Bk%7D%5E%7B%5C%2Cm%7D%20%3D%202%5C%2C%5Cdelta_%7Bk%7D%5E%7Bm%7D%5C%2C%7B%5Cit%20p_0%7D%5E2%2B2%5C%2Cg%5E%7Bi%5C%2Cm%7D%5C%2C%5Cvarepsilon_%7Bi%5C%2Cj%5C%2Ck%7D%5C%2C%0A%20p%5E%7Bj%7D%5C%2C%7B%5Cit%20p_0%7D%2B2%5C%2Cp_%7Bk%7D%5C%2Cp%5E%7Bm%7D-%5Cdelta_%7Bk%7D%5E%7Bm%7D" alt="image"></div><br><br>  It can be seen that Maxima generates LaTeX-notation, which is very close to the natural mathematical notation, which cannot be said about Maple, which prepares a monstrous code containing all the conventions adopted by it in the derivation of readable formulas.  The terms containing the Kronecker delta will be grouped and we will take the common factor out of the brackets independently.  Well, back to the place of "lambda" <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/B_%7Bk%7D%5E%7B%5C%2Cm%7D%20%3D%202%5C%2C%5Clambda_%7Bk%7D%5C%2C%5Clambda%5E%7Bm%7D%20%2B%202%5C%2C%20%7B%5Cit%20%5Clambda_0%7D%20%5C%2C%20g%5E%7Bi%5C%2Cm%7D%5C%2C%5Cvarepsilon_%7Bi%5C%2Cj%5C%2Ck%7D%5C%2C%0A%20%5Clambda%5E%7Bj%7D%20%2B%20%5Cleft(2%5C%2C%7B%5Cit%20%5Clambda_0%7D%5E2%20-%201%5Cright)%5C%2C%5Cdelta_%7Bk%7D%5E%7Bm%7D%20%5Cquad%20(6)" alt="image"></div><br><br>  We have obtained the expression of the rotation tensor in terms of the Rodrigues-Hamilton parameters.  From this tensor, one can go to any other parameters describing the orientation of a solid body in space. <br><br>  Warm-up can be considered over.  More serious work lies ahead. <br><br><h1>  2. Pseudovector of angular velocity in the parameters of Rodrigues-Hamilton </h1><br><br>  We introduce in Maxima an expression for the pseudovector of angular velocity already known to us.  In natural form, it looks like this. <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Comega%5E%7B%5C%2Cr%7D%20%3D%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)%20%5C%2C%20%5Cvarepsilon%5E%7B%5C%2Cimr%7D%20u_%7B%5C%2Ci%7D%20%5C%2C%20%5Cdot%20u_%7B%5C%2Cm%7D%20%2B%20%5Cdot%20u%5E%7B%5C%2Cr%7D%20%5C%2C%20%5Csin%5Cvarphi%20%2B%20u%5E%7B%5C%2Cr%7D%20%5C%2C%20%5Cdot%5Cvarphi" alt="image"></div><br><br>  And in Maxima it will go with the replacement of functions of single angles by equivalent functions of half <br><br><pre> <code class="hljs markdown">Omega:ishow(2<span class="hljs-emphasis"><span class="hljs-emphasis">*sin(phi/2)^2*</span></span>'levi_civita([],[i,m,r])<span class="hljs-emphasis"><span class="hljs-emphasis">*u([i],[])*</span></span>diff(u([m],[]),t) + diff(u([],[r]),t)<span class="hljs-emphasis"><span class="hljs-emphasis">*2*</span></span>sin(phi/2)<span class="hljs-emphasis"><span class="hljs-emphasis">*cos(phi/2) + u([],[r])*</span></span>diff(phi, t))$</code> </pre><br><br>  Let me remind you that the Levi-Civita tensor, especially if you plan to simplify the expression using its properties, is better to introduce with suppression of the calculation.  Otherwise, Maxima will turn it into a generalized Kronecker delta, and this is not part of our plans.  To suppress the calculation, put an apostrophe before the name of the function that defines this tensor. <br><br>  We lower the indices and rename the indices of the orth of rotation, in accordance with the designation of the indices in the angular velocity tensor <br><br><pre> <code class="hljs matlab">u_i:ishow(contract(Solv1[<span class="hljs-number"><span class="hljs-number">1</span></span>]*g([<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>],[])))$ u_m:ishow(subst(m, <span class="hljs-built_in"><span class="hljs-built_in">i</span></span>, u_i))$ ur:ishow(subst(r, <span class="hljs-built_in"><span class="hljs-built_in">j</span></span>, Solv1[<span class="hljs-number"><span class="hljs-number">1</span></span>]))$</code> </pre><br><br>  We receive expressions which we will use in substitutions <br><br><img src="https://habrastorage.org/files/ab9/d41/133/ab9d4113345940f9a08a5d916159a900.png"><br><br>  We will need derivatives of the ort of the axis of rotation and the angle of rotation.  It is necessary to get them expressed through quaternion parameters. <br><br><pre> <code class="hljs objectivec"><span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> du_mdt:ishow(diff(u_m, t))$ <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> dLambda0dt:diff(Lambda0, t); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> Solv2:solve(dLambda0dt, diff(phi,t));</code> </pre><br><br>  Maxima will perform all operations quite correctly. <br><br><img src="https://habrastorage.org/files/67d/a23/099/67da230998cd4cc096fa42c730c62e2a.png"><br><br>  But here we are waited by another nuance.  We need to remove the derivatives from the resulting expressions.  That is, to remove completely.  Because Maxima, when simplifying expressions, does not quite adequately respond to them.  For example, if the same derivative is in the expression as a coefficient before the sine in the square and before the cosine in the square of the same angle, while simplifying trigonometry, Maxima does not see the main trigonometric identity in the focus.  And if the derivative is replaced by an ordinary expression, it easily collapses the identity into a unit.  The same applies to tensor transformations - it‚Äôs unwilling to omit indices and collapse with the Levi-Civita tensor if one of the tensors involved in the operation is represented by the time derivative of the other tensor.  I haven‚Äôt yet met direct indications of a solution to the problem, although I‚Äôm looking for them, but for now let's use Crutch Number Two - we will introduce replacements.  To begin with, in the expression of the angular velocity, we replace the derivative of the scalar parameter of the quaternion <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">dphidt</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:subst(v0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">diff</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">p0</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">t</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">Solv2</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>);</code> </pre><br><br>  We perform a direct substitution - the first argument of the function <code>subst()</code> is something to which, it is necessary to replace the expression betrayed by the second argument, in the expression in the third argument.  Result <br><img src="https://habrastorage.org/files/f0b/66f/f4c/f0b66ff4c0164bd08ec955829a96616b.png"><br>  It suits us.  Now we substitute this angular velocity into the expression for the derivative of the covort orth of the axis of rotation <br><br><pre> <code class="hljs">du_mdt:ishow(subst(dphidt, du_mdt))$</code> </pre><br><br>  and perform the replacement of the derivatives of the other quaternion parameters <br><br><pre> <code class="hljs">du_mdt:ishow(subst(v([m],[]), diff(p([m],[]),t), du_mdt))$</code> </pre><br><br>  well, raise the indices, to obtain the derivative of the contravariant component ort <br><br><pre> <code class="hljs">durdt:ishow(diff(u([],[r]),t) = contract(expand(rhs(du_mdt)*g([],[r,m]))))$</code> </pre><br><br>  At the output we have a complete set of expressions to perform the substitution. <br><br><img src="https://habrastorage.org/files/e5a/eff/c17/e5aeffc179b34a05b5e93317233adf0c.png"><br><br>  Well, we carry them out, revealing brackets along the way, forcing Maxima to reduce fractions as much as possible. <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">Omega_1:</span></span>ishow(subst(dphidt, Omega))$ <span class="hljs-symbol"><span class="hljs-symbol">Omega_1:</span></span>ishow(expand(subst(du_mdt, Omega_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">Omega_1:</span></span>ishow(expand(subst(durdt, Omega_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">Omega_1:</span></span>ishow(expand(subst(u_i, Omega_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">Omega_1:</span></span>ishow(expand(subst(ur, Omega_1)))$</code> </pre><br><br>  The result is already quite decent <br><br><img src="https://habrastorage.org/files/93f/b25/846/93fb258465e24c3fa1678522401f4884.png"><br><br>  but in the second term, the vector product of the vector part of the quaternion itself on itself looms, equal to zero.  To SKA removed her use the spell <br><br><pre> <code class="hljs">Omega_2:ishow(canform(contract(expand(applyb1(Omega_1, lc_l, lc_u)))))$</code> </pre><br><br>  Details of the construction of this command are <a href="http://habrahabr.ru/post/262801/">described by me here</a> .  I recall only the meaning - to simplify the tensor expression according to the rules for working with convolutions of the Levi-Civita tensor.  The spell removes the zero term <br><br><img src="https://habrastorage.org/files/d44/6ae/857/d446ae857c12430191e8eef54b134fd6.png"><br><br>  Things are easy - combing trigonometry <br><br><pre> <code class="hljs">Omega_3:ishow(trigsimp(Omega_2))$</code> </pre><br><br>  and replace the remaining cosine with the quaternion scalar parameter <br><br><pre> <code class="hljs">Omega_3:ishow(subst(lhs(Lambda0), rhs(Lambda0) , Omega_3))$</code> </pre><br><br>  As a result, we have a rather compact expression. <br><br><img src="https://habrastorage.org/files/589/d0e/ddc/589d0eddca6d46ecb71f2f12eb89a71f.png"><br><br>  Print it in LaTeX <br><br><pre> <code class="hljs lisp">tentex(<span class="hljs-name"><span class="hljs-name">Omega_3</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cboxed%7B%0A-2%5C%2Cp%5E%7Br%7D%5C%2C%7B%5Cit%20v_0%7D%2B2%5C%2C%7B%5Cit%20p_0%7D%5C%2Cv%5E%7Br%7D%2Bp_%7B%7B%5Cit%20%5C%25_1%7D%7D%5C%2Cv_%7B%0A%20%7B%5Cit%20%5C%25_2%7D%7D%5C%2C%5Cvarepsilon%5E%7B%7B%5Cit%20%5C%25_1%7D%5C%2C%7B%5Cit%20%5C%25_2%7D%5C%2Cr%7D-v_%7B%7B%5Cit%20%5C%25_1%7D%7D%0A%20%5C%2Cp_%7B%7B%5Cit%20%5C%25_2%7D%7D%5C%2C%5Cvarepsilon%5E%7B%7B%5Cit%20%5C%25_1%7D%5C%2C%7B%5Cit%20%5C%25_2%7D%5C%2Cr%7D%0A%7D" alt="image"></div><br><br>  The weather is spoiled by the dumb indices numbered by the function <code>canform()</code> , but here we already handles the indices we need and at the same time we return to the place the derivatives of the Rodrigues-Hamilton parameters <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Comega%5E%7B%5C%2Cr%7D%20%3D%202%5C%2C%20%5Cvarepsilon%5E%7B%7B%5Cit%20i%7D%5C%2C%7B%5Cit%20j%7D%5C%2Cr%7D%20%5C%2C%20%5Clambda_%7B%7B%5Cit%20i%7D%7D%5C%2C%5Cdot%20%5Clambda_%7B%7B%5Cit%20j%7D%7D%20%2B%202%5C%2C%7B%5Cit%20%5Clambda_0%7D%5C%2C%5Cdot%20%5Clambda%5E%7Br%7D%20-%202%5C%2C%5Clambda%5E%7Br%7D%5C%2C%7B%5Cit%20%5Cdot%20%5Clambda_0%7D%20%5Cquad%20(7)" alt="image"></div><br><br>  Expression (7) is the long-awaited expression of the angular velocity in terms of the Rodrig ‚Äì Hamilton parameters.  As you can see, it is much more compact than the original expression, written in the parameters of the final rotation.  But this is not the only positive feature.  Another nice feature will open to us when we get <br><br><h1>  3. Angular acceleration in the parameters of Rodrig-Hamilton </h1><br><br>  There are two ways to obtain angular acceleration.  The first way, the easiest, to which I, for some reason did not immediately reach, is simply to differentiate (7) by time.  It is easily and quickly done manually.  The second way I honestly crawled, get the formula in Maxima, simplifying the expression of angular acceleration known to us through the parameters of the final turn <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cepsilon%5E%7B%5C%2Cr%7D%20%3D%20%26%20%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)%20%5C%2C%20%5Cvarepsilon%5E%7B%5C%2Cimr%7D%20u_%7B%5C%2Ci%7D%20%5C%2C%20%5Cddot%20u_%7B%5C%2Cm%7D%20%2B%20%5Cdot%5Cvarphi%20%5Cleft(1%20%2B%20%5Ccos%5Cvarphi%20%5Cright)%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cr%7D%20%2B%20%5Cdot%5Cvarphi%20%5Csin%5Cvarphi%20%5C%2C%20%5Cvarepsilon%5E%7B%5C%2Cimr%7D%20u_%7B%5C%2Ci%7D%20%5C%2C%20%5Cdot%20u_%7B%5C%2Cm%7D%20%2B%20%5Cddot%20u%5E%7B%5C%2Cr%7D%20%5C%2C%20%5Csin%5Cvarphi%20%2B%20u%5E%7B%5C%2Cr%7D%20%5C%2C%20%5Cddot%5Cvarphi%20" alt="image"></div><br><br>  I will demonstrate both ways, I will only take the long way under the spoiler so that my dear reader will not lose the forest for the trees. <br><br>  So, take the time derivative of (7) <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cepsilon%5E%7B%5C%2Cr%7D%20%3D%20%5Cdot%5Comega%5E%7B%5C%2Cr%7D%20%3D%202%5C%2C%20%5Cvarepsilon%5E%7B%7B%5Cit%20i%7D%5C%2C%7B%5Cit%20j%7D%5C%2Cr%7D%20%5C%2C%20%5Cdot%5Clambda_%7B%7B%5Cit%20i%7D%7D%5C%2C%5Cdot%20%5Clambda_%7B%7B%5Cit%20j%7D%7D%20%2B%202%5C%2C%20%5Cvarepsilon%5E%7B%7B%5Cit%20i%7D%5C%2C%7B%5Cit%20j%7D%5C%2Cr%7D%20%5C%2C%20%5Clambda_%7B%7B%5Cit%20i%7D%7D%5C%2C%5Cddot%20%5Clambda_%7B%7B%5Cit%20j%7D%7D%20%2B%202%5C%2C%7B%5Cit%20%5Cdot%5Clambda_0%7D%5C%2C%5Cdot%20%5Clambda%5E%7Br%7D%20%2B%202%5C%2C%7B%5Cit%20%5Clambda_0%7D%5C%2C%5Cddot%20%5Clambda%5E%7Br%7D%20-%202%5C%2C%5Cdot%5Clambda%5E%7Br%7D%5C%2C%7B%5Cit%20%5Cdot%20%5Clambda_0%7D%20-%202%5C%2C%5Clambda%5E%7Br%7D%5C%2C%7B%5Cit%20%5Cddot%20%5Clambda_0%7D" alt="image"></div><br><br>  The first term is zero, such as are given up to the mutual annihilation of members, and as a result, without much difficulty, we get <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cepsilon%5E%7B%5C%2Cr%7D%20%3D%202%5C%2C%20%5Cvarepsilon%5E%7B%7B%5Cit%20i%7D%5C%2C%7B%5Cit%20j%7D%5C%2Cr%7D%20%5C%2C%20%5Clambda_%7B%7B%5Cit%20i%7D%7D%5C%2C%5Cddot%20%5Clambda_%7B%7B%5Cit%20j%7D%7D%20%20%2B%202%5C%2C%7B%5Cit%20%5Clambda_0%7D%5C%2C%5Cddot%20%5Clambda%5E%7Br%7D%20%20-%202%5C%2C%5Clambda%5E%7Br%7D%5C%2C%7B%5Cit%20%5Cddot%20%5Clambda_0%7D%20%5Cquad%20(8)" alt="image"></div><br><br><div class="spoiler">  <b class="spoiler_title">A long way to get (8) can be found here.</b> <div class="spoiler_text">  So, we will enter in Maxima angular acceleration in parameters of final turn, remembering about half corners <br><br><pre> <code class="hljs matlab">epsilon:ishow(<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)^<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-string"><span class="hljs-string">'levi_civita([],[i,m,r])*u([i],[])*diff(u([m],[]),t,2) + diff(phi,t)*2*cos(phi/2)^2*diff(u([],[r]),t) + diff(phi,t)*2*sin(phi/2)*cos(phi/2)*'</span></span>levi_civita([],[<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>,m,r])*u([<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>],[])*diff(u([m],[]),t) + diff(u([],[r]),t,<span class="hljs-number"><span class="hljs-number">2</span></span>)*<span class="hljs-number"><span class="hljs-number">2</span></span>*<span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>)*<span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(phi/<span class="hljs-number"><span class="hljs-number">2</span></span>) + u([],[r])*diff(phi,t,<span class="hljs-number"><span class="hljs-number">2</span></span>))$</code> </pre><br><br>  Now we need second derivatives.  Differentiate the angle of rotation <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">d2phidt2</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:diff(Solv2</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">t</span></span>);</code> </pre><br><br>  and substitute in it the expression we have already processed for the first derivative of the angle <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">d2phidt2</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:diff(Solv2</span></span><span class="hljs-selector-attr"><span class="hljs-selector-attr">[1]</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">t</span></span>);</code> </pre><br><br>  Again, we get rid of the first and second derived parameters, introducing the appropriate substitutions. <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">d2phidt2</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:subst(v0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">diff</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">p0</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">t</span></span>), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d2phidt2</span></span>); <span class="hljs-selector-tag"><span class="hljs-selector-tag">d2phidt2</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:subst(a0</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">diff</span></span>(<span class="hljs-selector-tag"><span class="hljs-selector-tag">p0</span></span>,<span class="hljs-selector-tag"><span class="hljs-selector-tag">t</span></span>,2), <span class="hljs-selector-tag"><span class="hljs-selector-tag">d2phidt2</span></span>);</code> </pre><br><br>  having a substitute expression <br><br><img src="https://habrastorage.org/files/d12/01c/8f0/d1201c8f054a4fa3af1c8571674853b5.png"><br><br>  Before differentiating the tensors, we add to the list of functions of time the substitutions introduced by us for the first derivatives, otherwise we obtain zeros, which in fact are not <br><br><pre> <code class="hljs lisp">depends([v0, v],<span class="hljs-literal"><span class="hljs-literal">t</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br><br>  We calculate the second derivative of the ort of the axis of rotation, make the necessary replacements, raise the indices to obtain the necessary expressions for the covariant components with the necessary indices <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">d2u_mdt2:</span></span>ishow(diff(du_mdt, t))$ <span class="hljs-symbol"><span class="hljs-symbol">d2u_mdt2:</span></span>ishow(subst(dphidt, d2u_mdt2))$ <span class="hljs-symbol"><span class="hljs-symbol">d2u_mdt2:</span></span>ishow(subst(a<span class="hljs-number"><span class="hljs-number">0</span></span>, diff(v<span class="hljs-number"><span class="hljs-number">0</span></span>,t), d2u_mdt2))$ <span class="hljs-symbol"><span class="hljs-symbol">d2u_mdt2:</span></span>ishow(subst(a([m],[]), diff(v([m],[]),t), d2u_mdt2))$ <span class="hljs-symbol"><span class="hljs-symbol">d2u_mdt2:</span></span>ishow(subst(v([m],[]), diff(p([m],[]),t), d2u_mdt2))$ <span class="hljs-symbol"><span class="hljs-symbol">d2urdt2:</span></span>ishow(diff(u([],[r]),t,<span class="hljs-number"><span class="hljs-number">2</span></span>) = contract(expand(rhs(d2u_mdt2)*g([],[r,m]))))$</code> </pre><br><br>  At the output we have the second derivatives of the covariant and contravariant components suitable for substitution <br><br><img src="https://habrastorage.org/files/147/579/7f1/1475797f18b543ba9ebb928b5b08c163.png"><br><br>  We perform a series of substitutions ‚Äî we replace the derivatives of the angle and ort, as well as the components of the orte itself, with the expressions obtained above, and earlier, when calculating the angular velocity <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">epsilon_1:</span></span>ishow(subst(dphidt, epsilon))$ <span class="hljs-symbol"><span class="hljs-symbol">epsilon_1:</span></span>ishow(expand(subst(durdt, epsilon_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">epsilon_1:</span></span>ishow(expand(subst(du_mdt, epsilon_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">epsilon_1:</span></span>ishow(expand(subst(d2phidt2, epsilon_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">epsilon_1:</span></span>ishow(expand(subst(d2u_mdt2, epsilon_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">epsilon_1:</span></span>ishow(expand(subst(d2urdt2, epsilon_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">epsilon_1:</span></span>ishow(expand(subst(ur, epsilon_1)))$ <span class="hljs-symbol"><span class="hljs-symbol">epsilon_1:</span></span>ishow(expand(subst(u_i, epsilon_1)))$</code> </pre><br><br>  The resulting "crocodile" is enormous <br><br><img src="https://habrastorage.org/files/eda/e7c/e2a/edae7ce2a3814f5d9a2f3b665a80ba0a.png"><br><br>  But we will tame it with a bundle simplification spell with the Levi-Civita tensor <br><br><pre> <code class="hljs">epsilon_2:ishow(canform(contract(expand(applyb1(epsilon_1, lc_l, lc_u)))))$</code> </pre><br><br>  and we get a less terrible, but still complex expression <br><br><img src="https://habrastorage.org/files/f12/80d/375/f1280d37550e4b4dae43d73434bac067.png"><br><br>  Now we simplify trigonometry, and replace the cosine of the half angle with the scalar parameter of the quaternion, and also derive LaTeX <br><br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">epsilon_3:</span></span>ishow(trigsimp(epsilon_2))$ <span class="hljs-symbol"><span class="hljs-symbol">epsilon_3:</span></span>ishow(subst(lhs(Lambda<span class="hljs-number"><span class="hljs-number">0</span></span>), rhs(Lambda<span class="hljs-number"><span class="hljs-number">0</span></span>) , epsilon_3))$ tentex(epsilon_3);</code> </pre><br><br>  And instead of the ‚Äúcrocodile‚Äù we have a completely decent formula in which the result (8) is guessed <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cboxed%7B%0A-a_%7B%7B%5Cit%20%5C%25_1%7D%7D%5C%2Cp_%7B%7B%5Cit%20%5C%25_2%7D%7D%5C%2C%5Cvarepsilon%5E%7B%7B%5Cit%20%5C%25_1%7D%5C%2C%0A%20%7B%5Cit%20%5C%25_2%7D%5C%2Cr%7D%2Bp_%7B%7B%5Cit%20%5C%25_1%7D%7D%5C%2Ca_%7B%7B%5Cit%20%5C%25_2%7D%7D%5C%2C%5Cvarepsilon%5E%7B%0A%20%7B%5Cit%20%5C%25_1%7D%5C%2C%7B%5Cit%20%5C%25_2%7D%5C%2Cr%7D%2B2%5C%2Ca%5E%7Br%7D%5C%2C%7B%5Cit%20p_0%7D-2%5C%2C%7B%5Cit%20a_0%7D%5C%2Cp%5E%7Br%7D%0A%7D" alt="image"></div><br><br>  And if we comb it, make the appropriate amendments to the designations and bring similar ones to the end, then <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cepsilon%5E%7B%5C%2Cr%7D%20%3D%202%20%5C%2C%20%5Cvarepsilon%5E%7B%0A%20%7B%5Cit%20i%7D%5C%2C%7B%5Cit%20j%7D%5C%2Cr%7D%20%5C%2C%20%5Clambda_%7B%7B%5Cit%20i%7D%7D%5C%2C%5Cddot%5Clambda_%7B%7B%5Cit%20j%7D%7D%5C%2C%2B2%5C%2C%5Cddot%5Clambda%5E%7Br%7D%5C%2C%7B%5Cit%20%5Clambda_0%7D-2%5C%2C%7B%5Cit%20%5Cddot%5Clambda_0%7D%5C%2C%5Clambda%5E%7Br%7D" alt="image"></div><br><br>  (8) we get.  Only much longer.  But they checked the correctness of the initial formulas. <br><br></div></div><br><br>  Suddenly, we see a complete analogy with (7), but instead of the first derivatives, there are second derivatives here.  The coefficients in the derivatives are the same, which means that the angular velocity and angular acceleration are obtained from the corresponding derived parameters of the Rodrigues-Hamilton multiplication by the same matrix (3 x 4).  This, by the way, determined the wide applicability of the quaternionic approach in modeling the motion of spacecraft, and other objects that perform free rotation in space. <br><br><h1>  Conclusion </h1><br><br>  The article was published with a focus on working with the Maxima tensor libraries.  I can conclude that, even with the described assumptions, it is quite convenient to simplify tensor expressions in it. <br><br>  And finally, we obtained the expressions of the angular velocity and angular acceleration using the Rodrig ‚Äì Hamilton orientation parameters convenient for modeling.  And they were convinced that formulas (7) and (8) expressing them are not only compact, but also beautiful, in the sense that they use the same linear transformation of parameters to the quaternion to the components of the angular velocity and acceleration vectors.  This approach seriously simplifies the organization of modeling programs, in which we still, I hope, will see. <br><br>  To date, we have come close to examining the dynamics of a free solid body using a tensor apparatus.  On account of the next article, I have an interesting idea, which I will try to implement and prepare high-quality material. <br><br>  Thank you for attention! <br><br>  <i><a href="http://habrahabr.ru/post/263687/">To be continued...</a></i> </div><p>Source: <a href="https://habr.com/ru/post/263565/">https://habr.com/ru/post/263565/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../263545/index.html">nxweb - HTTP server for C applications</a></li>
<li><a href="../263547/index.html">Pseudo OOP in C</a></li>
<li><a href="../263549/index.html">Multithreaded SOCKS 4 server on Qt</a></li>
<li><a href="../263551/index.html">Quick start with PHPixie 3</a></li>
<li><a href="../263555/index.html">Qucs project news: release candidate available with circuit simulation support in SPICE</a></li>
<li><a href="../263569/index.html">With LINQ on "Life"</a></li>
<li><a href="../263571/index.html">SoC: we write framebuffer implementation for controller in FPGA</a></li>
<li><a href="../263575/index.html">An example of solving a typical OOP problem in the Haskell language</a></li>
<li><a href="../263577/index.html">Competition of the user design from the Roketbank or how to order a bank card with the Habr logo</a></li>
<li><a href="../263581/index.html">Welcome to FPConf.ru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>