<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The theory of graphs in the Game of Thrones</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, on Geektimes I published an article where I cited some superficial statistics from the ‚ÄúSong of Ice and Flame‚Äù series of books. But I did no...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The theory of graphs in the Game of Thrones</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a3b/b15/35a/a3bb1535a6ce42859dc6ab5775602bb9.jpg"><br><br>  Recently, on Geektimes I published <a href="https://geektimes.ru/post/275466/">an article</a> where I cited some superficial statistics from the ‚ÄúSong of Ice and Flame‚Äù series of books.  But I did not go into the most interesting part, in the graph of social relations, because the topic deserves special attention.  In this article, I will demonstrate how graph theory can help in analyzing such data and present the implementation of the algorithms that I used. <br><br>  Anyone interested, welcome under cat. <br><a name="habracut"></a><br>  From the survey of the aforementioned article, I concluded that more than a third of the Geektimes audience was familiar with the book of fantasy novel, and more than half with the plot of the series.  I hope the audience Geektimes and Habrahabr intersect and you may be interested in not only the algorithms used, but also the results. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Data </h1><br>  Let's start, of course, with the main thing - the data.  We have a social activity graph: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a3/09b/155/4a309b1554134480f41619a2387ae8c5.png"></div><br><br>  It depicts characters from the world of thrones at the vertices of the graph, where the size of the vertex depends on the words spoken, and the dialogues of the characters on the edges of the graph, where the thickness of the edge depends on the number of conversations held. <br><br>  <b>General information about the graph:</b> <br><br>  The graph is undirected. <br>  Summits (read characters): 1105 <br>  Reber (read dialogs): 3505 <br><br>  It's all good, but who made the list of all the conversations, and even determined their identity, you ask me (in 5 books, there are almost <a href="https://www.reddit.com/r/asoiaf/comments/3froem/spoilers_all_i_made_a_word_count_of_the_whole">2 million words</a> ).  <a href="https://habrahabr.ru/post/241317/">The method of conditional random fields</a> , I answer.  Yes, machine learning was attracted to collect data and, as the model ‚Äútrainer‚Äù states, the accuracy of determining the ownership of a conversation is <a href="http://nbviewer.jupyter.org/url/atseajournal.com/asoiaf/machine_learning_asoiaf_dialogue.ipynb">about 75%</a> .  I will add a questionnaire at the end of the article to find out whether it is worth translating this article about how the method of conditional random fields was applied. <br><br>  <b>So, the input data format for all algorithms will be the same:</b> <br><br>  The first line contains <b>V</b> and <b>E</b> , the number of vertices and edges in the graph, respectively. <br><br>  Next come the <b>V</b> lines with the character <b>ID</b> and name.  After this, <b>E</b> lines of the form <b>uvw</b> are the description of edges.  It means that between <b>u</b> and <b>v</b> there is an edge with weight <b>w</b> , where <b>u</b> and <b>v</b> is the character <b>ID</b> .  Let me remind you that the weight means the number of dialogues between the respective characters.  The weight of the vertices themselves will not be taken into account anywhere.  I did not find a worthy application for him.  Oh yeah, the code of the algorithms will be presented in C ++. <br><br>  We, of course, need to read the data.  For this, I created the <i>definitions.h</i> and <i>definitions.cpp</i> files.  Further I will connect <i>definitions.h</i> everywhere that the code was less and the code was read easier.  Each subsequent algorithm is implemented as a separate function and is called in the function <i>main</i> . <br><br><div class="spoiler">  <b class="spoiler_title">defenitions.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> DEF_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DEF_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> _CRT_SECURE_NO_DEPRECATE #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;set&gt; #include &lt;iterator&gt; #include &lt;functional&gt; using namespace std; extern int reverseID[]; extern vector&lt;int&gt; id; extern vector&lt; vector&lt;int&gt; &gt; weight, edge; extern map&lt;int, string&gt; name; extern int V, E; void read_data(); #endif</span></span></span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">definitions.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> int reverseID[3000]; vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; id; // origin ID of characters vector&lt; vector&lt;int&gt; &gt; weight; // weights of edges vector&lt; vector&lt;int&gt; &gt; edge; // the graph's edges map&lt;int, string&gt; name; // names of characters int V, E; // amount of vertices and edges void read_data() { freopen("input.in", "r", stdin); // read from the input file cin &gt;&gt; V &gt;&gt; E; id.resize(V); weight.resize(V); edge.resize(V); int u; char s[100]; for (int i = 0; i &lt; V; i++) { // read the names scanf("%d %[^\n]", &amp;u, s); name[i] = string(s); id[i] = u; // origin ID by assigned ID reverseID[u] = i; // assigned ID by origin ID } int a, b, w; for (int i = 0; i &lt; E; i++) { // read the edges and weights cin &gt;&gt; a &gt;&gt; b &gt;&gt; w; edge[reverseID[a]].push_back(reverseID[b]); edge[reverseID[b]].push_back(reverseID[a]); weight[reverseID[a]].push_back(w); weight[reverseID[b]].push_back(w); } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"degree.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"dfsbfs.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"bridges_articulations.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cliques.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"spanning.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"cut.h"</span></span></span><span class="hljs-meta"> int main() { read_data(); degree(); count_components(); calculate_diameter(); find_cliques(); get_spanning_tree(); find_bridges_and_articulations(); find_cut(); }</span></span></code> </pre><br></div></div><br><h1>  Degree of vertex </h1><br>  To begin with, we will try to implement something very simple, which is even embarrassing to call an algorithm, but it will be interesting for the reader / viewer.  Find the degree of each vertex.  The degree of a vertex is the number of edges incident to (adjacent to) a vertex.  This parameter in the context of the graph, which we have, will show us how many ‚Äúfriends‚Äù the character has. <br><br>  This can be done in a single pass and the complexity of this algorithm is O (V + E).  If we apply and sort the result, as I did, then the complexity will be O (E + V * log (V)). <br><br><div class="spoiler">  <b class="spoiler_title">Algorithm for determining the degree of vertices</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> void degree() { freopen(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"degree.txt"</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"w"</span></span></span><span class="hljs-meta">, stdout); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// output file vector&lt; pair&lt;int,int&gt; &gt; degree(V); for (int i = 0; i &lt; V; i++) { degree[i] = make_pair(edge[i].size(), i); } stable_sort(degree.begin(), degree.end()); for (int i = V-1; i &gt;= 0; i--) { cout &lt;&lt; name[degree[i].second] &lt;&lt; ": " &lt;&lt; degree[i].first &lt;&lt; endl; } }</span></span></span></span></code> </pre><br></div></div><br>  Top 10 multiply characters: <br><br><ol><li>  Tyrion Lannister: 168 <br></li><li>  John Snow: 128 <br></li><li>  Arya Stark: 104 <br></li><li>  Jamie Lannister: 102 <br></li><li>  Cersei Lannister: 86 <br></li><li>  Catelyn Stark: 85 <br></li><li>  Theon Greyjoy: 76 <br></li><li>  Daineris Targaryen: 73 <br></li><li>  Brienne: 71 <br></li><li>  Sansa Stark: 69 <br></li></ol><br>  <a href="https://github.com/A33a/asoiaf/blob/master/degree.txt">The whole list</a> <br><br>  It is interesting that in the top there was no one who is familiar with many and is obliged to maintain contact with people, Varis (he is in 25th place).  But the seemingly secondary character of Brienne, on whose behalf the chapter is not yet, is in ninth place. <br><br><h1>  Bypassing the graph </h1><br>  So, we now turn to simple algorithms, namely, to search in depth ( <i>Depth-first search</i> ) and search in width ( <i>Breadth-first search</i> ).  Both algorithms are very similar, differ only in the way around the graph.  They are used when you want to go through the edges from a given vertex in the graph to another.  In the case of a depth search, the graph is traversed starting from the vertex and alternately at the maximum depth along one of the outgoing edges.  In the case of a search in width, the graph first goes through all its neighboring vertices, further along the neighbors of neighboring vertices, and so there are no pending vertices left.  Both algorithms have O (V + E) complexity. <br><br><h3>  Graph connectivity </h3><br>  Find the connected components of our graph.  A connected component is a subgraph in which all vertices have a path to any other vertex of the component.  To do this, run the search algorithm in depth by one of the vertices, and after completion, in the next, not marked by the algorithm, vertex.  Thus, each start of the search will mean a new component of connectivity. <br><br><div class="spoiler">  <b class="spoiler_title">Counting code for connected components</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bool&gt; useddfs; vector&lt;int&gt; comp; void dfs(int u) { useddfs[u] = true; comp.push_back(u); for (vector&lt;int&gt;::iterator i = edge[u].begin(); i != edge[u].end(); i++) if (!useddfs[*i]) dfs(*i); } void count_components() { freopen("components.txt", "w", stdout); // output file int comp_num = 0; useddfs.resize(V, false); for (int i = 0; i &lt; V; i++) { if (!useddfs[i]) { comp.clear(); dfs(i); comp_num++; } } cout &lt;&lt; comp_num; }</span></span></span></span></code> </pre><br></div></div><br>  It would be extremely strange if the graph were not connected and there was more than one component in it, wouldn‚Äôt it?  But to my surprise, there were already 3 components in the graph!  But looking at them, I saw that one large component was present, and 2 others, in which there was one character each (It was a smiling old man ( <i>A smiley old man</i> ) who talked with Arya near God's eye ( <i>God's eye</i> ). And the cook ( <i>A Cook</i> ), who played with Tirion on the ship).  Nothing unusual, they have no names and it is surprising that the participants in the conversation were generally defined correctly.  I, of course, added the missing edges and as a result the whole graph turned out to be connected. <br><br><h3>  Handshake Theory </h3><br>  The next thing we will find using the search algorithm is already wide - the maximum number of handshakes in the graph, in other words, the diameter of the graph, that is, the longest of the shortest paths between all the vertices of the graph.  As it turned out, the maximum number of handshakes is 8. A good result for a work about ‚Äúmedieval centuries‚Äù, if we take into account the <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D1%2588%25D0%25B5%25D1%2581%25D1%2582%25D0%25B8_%25D1%2580%25D1%2583%25D0%25BA%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25B6%25D0%25B0%25D1%2582%25D0%25B8%25D0%25B9">Theory of 6 handshakes</a> .  For example, one of these communication chains: <br><br>  <i>Mother Mole</i> - <i>Thistle</i> - Varamyr - <i>Jon Snow</i> - <i>Ned Stark</i> - Barristan <i>Selmy</i> - <i>Quentyn Martell</i> - The <i>Torn</i> Prince <i>Tattered Prince</i> ) - Lewis Lanster ( <i>Lewis Lanster</i> ) <br><br>  This algorithm works for O (V * V + V * E).  Since you need to run the BFS algorithm from each vertex of the graph.  If this graph were a <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE_(%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B8%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25BE%25D0%25B2)">tree</a> , it would take only 2 times to run BFS.  First, from any vertex of the graph, and then from the most distant vertex from it.  And the greatest depth of the last launch would be the diameter of the graph. <br><br>  And since I found the longest paths for all the vertices of the graph, then we can calculate the average value, as well as make up the distribution of maximum paths.  The average value for the length of the maximum paths turned out to be 6.16 (on average, it fits perfectly into the theory of 6 handshakes), and the total average distance is 3.6, for comparison, this parameter is 4.57 for Facebook. <br><br>  The distribution of the lengths of the maximum paths: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c2/f80/6e0/7c2f806e026a94335693fb98b9a2fa97.png"></div><br><br>  If you look at the distribution, we see that 77 characters are ‚Äúin the center‚Äù of the graph, in other words, they can contact any other character in no more than 4 others.  Among them are all the main characters of the story, except for Dayneris Targaryen and Sansa Stark, and among those to whom less than five chapters in the books are on the list are Barristan Selmi, John Connington and Melisander. <br><br>  <a href="https://github.com/A33a/asoiaf/blob/master/diameter.txt">Whole result</a> <br><br><div class="spoiler">  <b class="spoiler_title">The code for finding the given parameters</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bool&gt; usedbfs; void bfs(int u, vector&lt;int&gt; &amp;distance, vector&lt;int&gt; &amp;path) { queue&lt;int&gt; q; q.push(u); usedbfs[u] = true; path[u] = -1; while (!q.empty()) { int u = q.front(); q.pop(); for (vector&lt;int&gt;::iterator i = edge[u].begin(); i != edge[u].end(); i++) { int to = *i; if (!usedbfs[to]) { usedbfs[to] = true; q.push(to); distance[to] = distance[u] + 1; path[to] = u; } } } } void calculate_diameter() { freopen("diameter.txt", "w", stdout); // output file int diameter = 0; int current_max = 0; double average_max = 0; double average_average = 0; vector&lt; vector&lt;int&gt; &gt; distribution(V, vector&lt;int&gt; (0)); vector&lt; vector&lt;int&gt; &gt; max_path; vector&lt;int&gt; farthest_node; for (int i = 0; i &lt; V; i++) { vector&lt;int&gt; distance_to(V, 0); vector&lt;int&gt; path(V,-1); usedbfs.clear(); usedbfs.resize(V, false); bfs(i, distance_to, path); current_max = 0; for (int j = 0; j &lt; V; j++) { average_average += distance_to[j]; if (distance_to[j] &gt; current_max) current_max = distance_to[j]; if (distance_to[j] &gt; diameter) { diameter = distance_to[j]; farthest_node.clear(); max_path.clear(); max_path.push_back(path); farthest_node.push_back(j); } else if (distance_to[j] == diameter){ max_path.push_back(path); farthest_node.push_back(j); } } average_max += current_max; distribution[current_max].push_back(i); } average_max /= V; average_average /= V*V; cout &lt;&lt; "Diameter: " &lt;&lt; diameter &lt;&lt; endl; cout &lt;&lt; "Average path: " &lt;&lt; average_average &lt;&lt; endl; cout &lt;&lt; "Average farthest path: " &lt;&lt; average_max &lt;&lt; endl; vector &lt; vector&lt;int&gt; &gt; farthest_path; for (int i = 0; i &lt; farthest_node.size(); i++) { farthest_path.push_back(vector&lt;int&gt;()); for (int u = farthest_node[i]; u != -1; u = max_path[i][u]) farthest_path[i].push_back(u); } cout &lt;&lt; "Farthest paths:" &lt;&lt; endl; for (int i = 0; i &lt; farthest_path.size(); i++) { cout &lt;&lt; i+1 &lt;&lt; ": "; for (vector&lt;int&gt;::iterator j = farthest_path[i].begin(); j != farthest_path[i].end(); j++) cout &lt;&lt; name[*j] &lt;&lt; ". "; cout &lt;&lt; endl; } int minimum = V; cout &lt;&lt; "Farthest paths distribution:" &lt;&lt; endl; for (int i = 0; i &lt;= diameter; i++) { if (distribution[i].size() != 0 &amp;&amp; i &lt; minimum) minimum = i; cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; distribution[i].size() &lt;&lt; endl; } cout &lt;&lt; "Characters with minimum farthest path:" &lt;&lt; endl; for (vector&lt;int&gt;::iterator i = distribution[minimum].begin(); i != distribution[minimum].end(); i++) { cout &lt;&lt; name[*i] &lt;&lt; endl; } }</span></span></span></span></code> </pre><br></div></div><br><h1>  Clicks in the graph </h1><br>  The <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2591%25D1%2580%25D0%25BE%25D0%25BD%25D0%25B0_%25E2%2580%2594_%25D0%259A%25D0%25B5%25D1%2580%25D0%25B1%25D0%25BE%25D1%2588%25D0%25B0">Bron-Kerbosh algorithm</a> allows you to find the maximum clicks in the graph, in other words, subsets of vertices, any two of which are connected by an edge.  In the context of the graph under consideration, this will make it possible to find strongly related companies that have communicated with each other in history.  The complexity of the algorithm is linear with respect to the number of clicks in the graph, but in the worst case, it is exponential O (3 <sup>V / 3</sup> ), the algorithm solves the NP complete problem all the same.  The algorithm itself is a recursive function, which for each vertex finds the maximum click, i.e.  one in which no other vertices can be added.  So, the results: <br><br>  Click size distribution: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/533/816/851/53381685131d587eef34f523bbcc347d.png"></div><br><br>  As you can see, the maximum click size is 9 characters.  For example, one of these is the Lannister company: Tyrion, Jamie, Cersei, Varis, Tywin, Kevan, Pyzel, Petir and Mace Tyrell.  Interestingly, all clicks of size 8 and 9 are formed in or near Royal Harbor.  And the maximum click with daneris size 5. <br><br>  <a href="https://github.com/A33a/asoiaf/blob/master/cliques.txt">Whole result</a> <br><br><div class="spoiler">  <b class="spoiler_title">Click Location Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> vector </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; vector&lt;int&gt; &gt; cliques; bool compare_vectors_by_size(const vector&lt;int&gt; &amp;i, const vector&lt;int&gt; &amp;j) { return (i.size() &gt; j.size()); } void bron_kerbosch(set &lt;int&gt; R, set &lt;int&gt; P, set &lt;int&gt; X) { // where R is probable clique, P - possible vertices in clique, X - exluded vertices if (P.size() == 0 &amp;&amp; X.size() == 0) { // R is maximal clique cliques.push_back(vector&lt;int&gt;(0)); for (set&lt;int&gt;::iterator i = R.begin(); i != R.end(); i++) { cliques.back().push_back(*i); } } else { set &lt;int&gt; foriterate = P; for (set&lt;int&gt;::iterator i = foriterate.begin(); i != foriterate.end(); i++) { set &lt;int&gt; newR; set &lt;int&gt; newP; set &lt;int&gt; newX; newR = R; newR.insert(*i); set_intersection(P.begin(), P.end(), edge[*i].begin(), edge[*i].end(), inserter(newP, newP.begin())); set_intersection(X.begin(), X.end(), edge[*i].begin(), edge[*i].end(), inserter(newX, newX.begin())); bron_kerbosch(newR, newP, newX); P.erase(*i); X.insert(*i); } } } void find_cliques() { freopen("cliques.txt", "w", stdout); // output file set &lt;int&gt; P; for (int i = 0; i &lt; V; i++) { P.insert(i); stable_sort(edge[i].begin(), edge[i].end()); } bron_kerbosch(set&lt;int&gt;(), P, set&lt;int&gt;()); stable_sort(cliques.begin(), cliques.end(), compare_vectors_by_size); cout &lt;&lt; "Distribution:" &lt;&lt; endl; int max_size = 0; int max_counter = 0; for (int i = cliques.size()-1; i &gt;= 0 ; i--) { if (cliques[i].size() &gt; max_size) { if (max_counter &gt; 0) { cout &lt;&lt; max_size &lt;&lt; ": " &lt;&lt; max_counter &lt;&lt; endl; } max_size = cliques[i].size(); max_counter = 0; } max_counter++; } if (max_counter &gt; 0) { cout &lt;&lt; max_size &lt;&lt; ": " &lt;&lt; max_counter &lt;&lt; endl; } cout &lt;&lt; "Cliques:" &lt;&lt; endl; for (int i = 0; i &lt; cliques.size(); i++) { cout &lt;&lt; i + 1 &lt;&lt; "(" &lt;&lt; cliques[i].size() &lt;&lt; "): "; for (int j = 0; j &lt; cliques[i].size(); j++) { cout &lt;&lt; name[cliques[i][j]] &lt;&lt; ". "; } cout &lt;&lt; endl; } }</span></span></span></span></code> </pre><br></div></div><br><h1>  Spanning tree </h1><br>  And now let's simplify our link graph a bit, leaving only the ‚Äúcore‚Äù in it, the so-called <a href="https://ru.wikipedia.org/wiki/%25D0%259E%25D1%2581%25D1%2582%25D0%25BE%25D0%25B2%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D0%25BE">spanning tree</a> , i.e.  the most important edges of connection and at the same time turning the graph into a tree with all the original vertices  The <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%259A%25D1%2580%25D1%2583%25D1%2581%25D0%25BA%25D0%25B0%25D0%25BB%25D0%25B0">Kruskal algorithm</a> will help us in this.  The algorithm is greedy, for its implementation it is only necessary to sort all edges by their weight and add each edge in turn if it connects two components.  If you use the correct data structure (usually use a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D1%2581%25D1%2582%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BD%25D0%25B5%25D0%25BF%25D0%25B5%25D1%2580%25D0%25B5%25D1%2581%25D0%25B5%25D0%25BA%25D0%25B0%25D1%258E%25D1%2589%25D0%25B8%25D1%2585%25D1%2581%25D1%258F_%25D0%25BC%25D0%25BD%25D0%25BE%25D0%25B6%25D0%25B5%25D1%2581%25D1%2582%25D0%25B2">system of disjoint sets</a> ), then the complexity of the algorithm is O (E (logE) + V + E) = O (E (logV)).  Below is the result of the graph that has undergone these manipulations.  I also removed the edges with a weight of 1 for readability. <br><br><div style="text-align:center;"> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/c31/3ef/81e/c313ef81e15b479749e35b125196c51c.png"></a> </div><br>  <i>the picture is clickable</i> <br><br>  So, from this graph you can see the main characters and their relationship with each other.  As I expected, Tyrion Lannister is in the "center" of all ties, with 4 large branches emanating from him: Cersei Lannister, John Snow, Sansa Stark and Jorah Mormont (Daineris branch).  The last, in turn, heroes of the next level of connections.  Quite an expected result, isn't it? <br><br>  <a href="https://github.com/A33a/asoiaf/blob/master/spanning.txt">Whole result</a> <br><br><div class="spoiler">  <b class="spoiler_title">Spanning tree construction code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; p; int dsu_get(int v) { return (v == p[v]) ? v : (p[v] = dsu_get(p[v])); } void dsu_unite(int u, int v) { u = dsu_get(u); v = dsu_get(v); if (rand() &amp; 1) swap(u, v); if (u != v) p[u] = v; } void get_spanning_tree() { freopen("spanning.txt", "w", stdout); // output file vector &lt; pair &lt; int, pair&lt;int, int&gt; &gt; &gt; edges_weights, result; vector &lt; vector&lt;bool&gt; &gt; used; for (int i = 0; i &lt; V; i++) { used.push_back(vector&lt;bool&gt;(V, false)); } for (int i = 0; i &lt; V; i++) { for (int j = 0; j &lt; edge[i].size(); j++) { int cur_v = edge[i][j]; if (!used[i][cur_v]) { edges_weights.push_back(make_pair(weight[i][j], make_pair(i, cur_v))); used[i][cur_v] = true; used[cur_v][i] = true; } } } sort(edges_weights.begin(), edges_weights.end(), greater&lt; pair &lt; int, pair&lt;int, int&gt; &gt; &gt;()); for (int i = 0; i &lt; V; i++) { p.push_back(i); } for (int i = 0; i &lt; E; i++) { int u = edges_weights[i].second.first; int v = edges_weights[i].second.second; int w = edges_weights[i].first; if (dsu_get(u) != dsu_get(v)) { result.push_back(edges_weights[i]); dsu_unite(u, v); } } for (vector &lt; pair &lt; int, pair&lt;int, int&gt; &gt; &gt;::iterator i = result.begin(); i != result.end(); i++) { cout &lt;&lt; id[(i-&gt;second).first] &lt;&lt; " " &lt;&lt; id[(i-&gt;second).second] &lt;&lt; " " &lt;&lt; i-&gt;first &lt;&lt; endl; } }</span></span></span></span></code> </pre><br></div></div><br>  But how many spanning trees, including not only the maximum can be built?  Incredibly much in this column, of course.  But they can be calculated using the <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2587%25D0%25BD%25D0%25B0%25D1%258F_%25D1%2582%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE_%25D0%25B4%25D0%25B5%25D1%2580%25D0%25B5%25D0%25B2%25D1%258C%25D1%258F%25D1%2585">Kirchhoff theorem</a> .  The theorem says that if we construct a matrix where all elements of <a href="https://ru.wikipedia.org/wiki/%25D0%259C%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0_%25D1%2581%25D0%25BC%25D0%25B5%25D0%25B6%25D0%25BD%25D0%25BE%25D1%2581%25D1%2582%25D0%25B8">the adjacency matrix</a> are replaced with opposite ones, and the degrees of the corresponding vertices are on the main diagonal, then all <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25B5%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D0%25B4%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5">algebraic complements of the</a> resulting matrix will be equal and this value will be the number of spanning trees of the graph. <br><br><h1>  Bridges and Hinges </h1><br>  Bridges in the graph are called edges, as they are removed, the number of connected components increases.  Similar definitions are for hinges, but unlike bridges, hinges are vertices, as they are removed, the number of connected components increases.  In this column, the presence of bridges will mean that in the world of thrones there are connections that are the only source of communication between individual groups of characters.  The hinges are heroes who are the only mediator to a group of other characters.  Bridges and hinges are not very hard to look for.  To do this, we need a familiar depth-depth search algorithm, but slightly modified.  It is necessary to use the so-called entry time to the vertex and the exit time function ( <i>fout</i> ) on the vertex, which will take the values ‚Äã‚Äãof the minimum entry time and the vertex <i>fout</i> values ‚Äã‚Äãat which the depth search is passed, thus, when passing the edge, it turns out that the function value <i>fout</i> at the top is more than the time of entry into it, then it will be a bridge, as well as a hinge, and if it is equal, then only a hinge.  In other words, we check if we return to the same edge / vertex after the detour and only to it in the detour of a part of the graph, if so, this will be the required bridge or hinge. <br><br>  As expected, all the hinges and bridges covered only irrelevant characters.  The number of vertices in the components that would be isolated, by removing the hinges and bridges, does not exceed 4x.  This means that there is no hero who could not be sacrificed.  All are interconnected through at least two other characters. <br><br>  <a href="https://github.com/A33a/asoiaf/blob/master/bridges_and_articulations.txt">Whole result</a> <br><br><div class="spoiler">  <b class="spoiler_title">Bridge and joint search code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> vector</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;bool&gt; used, usedcnt; int timer = 0; vector&lt;int&gt; tin, fout, articulations; vector &lt; pair&lt;int,int&gt; &gt; bridges; int count_rec(int v, int skip) { int cnt = 1; usedcnt[v] = true; for (int i = 0; i &lt; edge[v].size(); i++) { int to = edge[v][i]; if(to == skip || usedcnt[to]) continue; cnt += count_rec(to, skip); } return cnt; } int count_from(int v, int skip, bool clean = true){ usedcnt.resize(V, false); if (clean) { for (int i = 0; i &lt; usedcnt.size(); i++) usedcnt[i] = false; } return count_rec(v, skip); } void dfs(int v, int prev = -1) { used[v] = true; tin[v] = fout[v] = timer++; int root_calls = 0; bool in_ar_list = false; for (int i = 0; i &lt; edge[v].size(); i++) { int to = edge[v][i]; if (to == prev) continue; if (used[to]) fout[v] = min(fout[v], tin[to]); else { dfs(to, v); fout[v] = min(fout[v], fout[to]); if (fout[to] &gt; tin[v]) { bridges.push_back(make_pair(v, to)); } if (fout[to] &gt;= tin[v] &amp;&amp; prev != -1 &amp;&amp; !in_ar_list) { articulations.push_back(v); in_ar_list = true; } root_calls++; } } if (prev == -1 &amp;&amp; root_calls &gt; 1) articulations.push_back(v); } void find_bridges_and_articulations() { freopen("bridges_and_articulations.txt", "w", stdout); // output file used.resize(V, false); tin.resize(V); fout.resize(V); for (int i = 0; i &lt; V; i++) if (!used[i]) dfs(i); cout &lt;&lt; "Bridges:" &lt;&lt; endl; for (int i = 0; i &lt; bridges.size(); i++) { cout &lt;&lt; name[bridges[i].first] &lt;&lt; " (" &lt;&lt; count_from(bridges[i].first, bridges[i].second) &lt;&lt; ") - " &lt;&lt; name[bridges[i].second] &lt;&lt; " (" &lt;&lt; count_from(bridges[i].second, bridges[i].first) &lt;&lt;")" &lt;&lt; endl; } cout &lt;&lt; endl &lt;&lt; "Articulation points:" &lt;&lt; endl; for (int i = 0; i &lt; articulations.size(); i++) { int cur = articulations[i]; cout &lt;&lt; name[cur]; for (int i = 0; i &lt; usedcnt.size(); i++) usedcnt[i] = false; for (int j = 0; j &lt; edge[cur].size(); j++) { if (!usedcnt[edge[cur][j]]) { int comp_size = count_from(edge[cur][j], cur, false); cout &lt;&lt; " (" &lt;&lt; comp_size &lt;&lt; ")"; } } cout &lt;&lt; endl; } }</span></span></span></span></code> </pre><br></div></div><br><h1>  Minimum cut </h1><br>  But it‚Äôs still interesting to know how many heroes you need to ‚Äúkill‚Äù in order to completely eliminate the contact of the two most popular (according to the above statistics) characters, such as Tirion Lannister and Arya Stark, or John Snow and Cersei Lannister.  For this we will use the <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B0">algorithm Dinnitsa</a> .  First, let's understand how the algorithm works. <br><br>  By <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25A4%25D0%25BE%25D1%2580%25D0%25B4%25D0%25B0_%25E2%2580%2594_%25D0%25A4%25D0%25B0%25D0%25BB%25D0%25BA%25D0%25B5%25D1%2580%25D1%2581%25D0%25BE%25D0%25BD%25D0%25B0">the Ford-Fulkerson theorem,</a> it follows that the magnitude of the maximum flow in a graph of paths is equal to the value of the carrying capacity of its minimum cut.  In other words, we can find the minimum cut between two vertices (sink and source) if we find the maximum flow between these vertices.  Algorithm Dinitsa just allows you to find the value of the maximum flow and, in fact, the flow itself.  I will not analyze in detail the algorithm itself and give you the opportunity to understand it yourself.  To understand the result obtained, it is enough to know that the flow is a certain function that, for each edge lying in the path from the source to the drain, determines a positive value that does not exceed the capacity of this edge.  For simplicity, one can imagine a pipe system with water, where the volume of water flowing from the source to the drain at time <i>t</i> is the flow quantity. <br><br>  The task I set is slightly different from the one that the algorithm solves.  The fact is that the flow is defined on the edges, and if we find the minimal cut, then it will cut the graph along the edges, i.e.  connections in the graph, but we need to cut the graph not at the edges, but at the vertices, i.e.  characters.  To solve this problem it is necessary to subject the graph to small changes.  We split each vertex in the graph, say, instead of the vertex <b>v</b> , we have vertices <b>v <sub>1</sub></b> and <b>v <sub>2</sub></b> , then if there was an edge between two vertices <b>v</b> and <b>u</b> , then we redirect <b>v <sub>1</sub></b> to <b>u <sub>2</sub></b> and <b>u <sub>1</sub></b> to <b>v <sub>2</sub></b> , instead of an edge <b>(u , v)</b> we get the edges <b>(v <sub>1</sub> , u <sub>2</sub> )</b> and <b>(u <sub>1</sub> , v <sub>2</sub> )</b> .  And between each forked vertices <b>v <sub>1</sub></b> and <b>v <sub>2</sub></b> we draw an edge <b>(v <sub>2</sub> , v <sub>1</sub> )</b> .  In the resulting, already oriented graph, all the links will be preserved, but where there were vertices before, edges will appear.  If the weight of these edges is 1, and all the others, say, infinity (in practice, you can use the number of vertices in the graph), then the edge between the split vertices will be a weak link in the graph and, according to the ‚Äúfuse‚Äù principle, will not allow more flow through will give the opportunity to find out the number of vertices that need to be removed in order for the graph to become disconnected.  And then we run the algorithm Dinica on the resulting graph. <br><br>  The complexity of the algorithm is O (n <sup>2</sup> m).  Therefore, we will search for the value of the maximum flow not for all pairs of vertices, but only for the characters that have the greatest number of connections, otherwise for a given graph the complexity will be O (n <sup>5</sup> ), where n = 1000 and everything will work for many hours.  Below I will give the results on the top 100 characters on the links. <br><br>  I was a little surprised at the results.  It turned out that in the top 100, you can cut the graph by getting rid of at least 6 characters.  All such connections contain either John Connington or Euron Greyjoy as a drain / source.  But this is not the main characters.  Interestingly, in the top 10, basically the minimum flow is about 45.  For example, between Tirion and Arya, the flow is 53, and between John Snow and Cersei 42. But there is also a character who can be separated by removing 16 other characters.  This is Dayneris Targaryen, not surprising, because she is the most distant heroine on the map of thrones. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> It would also be interesting to find out who is the most "important" hero in the streams. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">through whom most often flows the maximum flow. </font><font style="vertical-align: inherit;">There is something to be surprised. </font><font style="vertical-align: inherit;">Top 10 important characters in the streams (in brackets the corresponding number of entries in the streams):</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tyrion Lannister (4109) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jamie Lannister (3067) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Arya Stark (3021) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> John Snow (2883) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Eddard Stark (2847) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cersei Lannister (2745) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Theon Greyjoy (2658) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brienne (2621) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sandor Klegane (2579) </font></font><br></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sansa Stark (2573) </font></font><br></li></ol><br>  ,       ,   (  )  .  ,  ,        ,    .  ,  10   ,    ,   ,   10  : <br><br> 11.   <br> 12.   <br> 13.   <br> 14.   <br> 15.   <br> 16.  <br> 17.  <br> 18.  <br> 19.   <br> 20.  <br><br>    6      5.    .   ? <br><br>  ,  ,   ¬´¬ª ,       ,       ,      .    (A Man)   (A Guard).   ,         . <br><br> <a href="https://github.com/A33a/asoiaf/blob/master/cut_min.txt"> </a> <br><br><div class="spoiler"> <b class="spoiler_title">     </b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"definitions.h"</span></span></span><span class="hljs-meta"> const int INF = 1000000000; struct edge_s{ int a, b, c, flow; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// a-&gt;b, c-capacity, flow=0 edge_s(int a, int b, int c, int flow) : a(a), b(b), c(c), flow(flow) {} }; vector&lt; pair&lt;int, int&gt; &gt; top_degree; vector&lt; pair&lt;int, int&gt; &gt; top_flow; vector&lt;int&gt; dis; vector&lt;int&gt; ptr; vector&lt;edge_s&gt; edgelist; vector&lt; vector&lt;int&gt; &gt; edges_dup; bool compare_pairs_by_second(const pair&lt;int, int&gt; &amp;i, const pair&lt;int, int&gt; &amp;j) { return (i.second &gt; j.second); } bool bfs_dinic(int s, int t) { queue&lt;int&gt; q; q.push(s); dis[s] = 0; while (!q.empty() &amp;&amp; dis[t] == -1) { int v = q.front(); q.pop(); for (int i = 0; i &lt; edges_dup[v].size(); i++) { int ind = edges_dup[v][i], next = edgelist[ind].b; if (dis[next] == -1 &amp;&amp; edgelist[ind].flow &lt; edgelist[ind].c) { q.push(next); dis[next] = dis[v] + 1; } } } return dis[t] != -1; } int dfs_dinic(int v, int t, int flow) { if (!flow) { return 0; } if (v == t) { return flow; } for (; ptr[v] &lt; (int) edges_dup[v].size(); ptr[v]++) { int ind = edges_dup[v][ptr[v]]; int next = edgelist[ind].b; if (dis[next] != dis[v] + 1) { continue; } int pushed = dfs_dinic(next, t, min(flow, edgelist[ind].c - edgelist[ind].flow)); if (pushed) { edgelist[ind].flow += pushed; edgelist[ind ^ 1].flow -= pushed; return pushed; } } return 0; } long long dinic_flow(int s, int t) { long long flow = 0; while (true) { fill(dis.begin(), dis.end(), -1); if (!bfs_dinic(s, t)) { break; } fill(ptr.begin(), ptr.end(), 0); while (int pushed = dfs_dinic(s, t, INF)) { flow += pushed; } } return flow; } void dinic_addedge(int a, int b, int c) { edges_dup[a].push_back((int) edgelist.size()); edgelist.push_back(edge_s(a, b, c, 0)); edges_dup[b].push_back((int) edgelist.size()); edgelist.push_back(edge_s(b, a, 0, 0)); } void find_cut() { freopen("cut_min.txt", "w", stdout); // output file dis.resize(2 * V, 0); ptr.resize(2 * V, 0); edges_dup.resize(2 * V, vector&lt;int&gt;(0)); const int top = min(10, V); for (int i = 0; i &lt; V; i++) top_flow.push_back(make_pair(0, i)); for (int i = 0; i &lt; V; i++) { top_degree.push_back(make_pair(edge[i].size(), i)); for (int j = 0; j &lt; edge[i].size(); j++) { int to = edge[i][j]; dinic_addedge(i, to + V, V); } dinic_addedge(i + V, i, 1); } stable_sort(top_degree.rbegin(), top_degree.rend()); cout &lt;&lt; "Minimum cut between characters:" &lt;&lt; endl; for (int i = 0; i &lt; top; i++) { for (int j = i + 1; j &lt; top; j++) { vector&lt;int&gt;::iterator p = find(edge[top_degree[i].second].begin(), edge[top_degree[i].second].end(), top_degree[j].second); if (p != edge[top_degree[i].second].end()) continue; int flow = dinic_flow(top_degree[i].second, top_degree[j].second + V); cout &lt;&lt; name[top_degree[i].second] &lt;&lt; " -&gt; " &lt;&lt; name[top_degree[j].second] &lt;&lt; " = " &lt;&lt; flow &lt;&lt; endl; for (int k = 0; k &lt; edgelist.size(); k++) { if ((edgelist[k].a == (edgelist[k].b + V)) &amp;&amp; (edgelist[k].flow == 1)) { top_flow[edgelist[k].b].first++; } edgelist[k].flow = 0; } } } stable_sort(top_flow.rbegin(), top_flow.rend()); cout &lt;&lt; endl &lt;&lt; "Top involved characters in the flows:" &lt;&lt; endl; for (int i = 0; i &lt; top; i++) { cout &lt;&lt; name[top_flow[i].second] &lt;&lt; " (" &lt;&lt; top_flow[i].first &lt;&lt; ")" &lt;&lt; endl; } }</span></span></span></span></code> </pre><br></div></div><br>   .   ,         . ,     ,    .          GitHub,  . <br><br><h4>  References: </h4><br> <a href="https://github.com/A33a/asoiaf">  GitHub</a> <br> <a href="http://atseajournal.com/asoiaf/resources/asoiaf_exchanges.gephi">  </a> <br>  <a href="https://gephi.org/">Gephi</a> ,       <br>    ‚Äî <a href="https://www.flickr.com/photos/paperpariah/17044739072">Adam Foster</a> <br><br>  ,   , :    <a href="http://nbviewer.jupyter.org/url/atseajournal.com/asoiaf/machine_learning_asoiaf_dialogue.ipynb"></a>  ,       ? </div><p>Source: <a href="https://habr.com/ru/post/302936/">https://habr.com/ru/post/302936/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../302922/index.html">JS Programming Contest: Word qualifier (about testing)</a></li>
<li><a href="../302924/index.html">Preparing an arbitrary LTE modem for working with a SIM card for a Yota modem using the example of Huawei E3272</a></li>
<li><a href="../302926/index.html">Ways to generate a numeric sequence (data) in MySQL</a></li>
<li><a href="../302930/index.html">We analyze how successful employment and salary depend on the university, specialty and region</a></li>
<li><a href="../302932/index.html">Automating code checking or some more about pre-commit hooks</a></li>
<li><a href="../302942/index.html">PHP7 Guide</a></li>
<li><a href="../302944/index.html">CleverStyle Framework 4 Release</a></li>
<li><a href="../302946/index.html">Not a single iron: IBM Software Defined Storage</a></li>
<li><a href="../302950/index.html">C # client generation for Wargaming API</a></li>
<li><a href="../302952/index.html">20 most notable events in the history of backup and recovery</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>