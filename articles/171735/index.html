<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Animation UIView: moving along an arbitrary trajectory on the example of a circle</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perhaps, most iOs developers know that for the implementation of various visual effects, usually a few lines of code are enough. The UIKit framework, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Animation UIView: moving along an arbitrary trajectory on the example of a circle</h1><div class="post__text post__text-html js-mediator-article">  Perhaps, most iOs developers know that for the implementation of various visual effects, usually a few lines of code are enough.  The UIKit framework, which is responsible for the standard interface, has built-in tools that allow you to create fairly sophisticated types of animation - from moving in a straight line to the page turning effect.  However, to move the heirs of UIView along a more complex path, you have to go down and go to the level of the Core Graphics framework.  In this case, the number of examples in the network decreases and it is difficult to find the necessary.  And if it is, then the quality of implementation often leaves much to be desired.  I encountered this situation when it became necessary to animate an interactive book for children. <br><br><a name="habracut"></a><br><h4>  Animation mechanism </h4><br><br>  To implement movement along an arbitrary trajectory, the following approach is used: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  a path is constructed consisting of figures (straight lines, curves, circles, etc.).  This is done using the CGPath structure and auxiliary functions for working with it.  By the way, this structure can also be used to draw the resulting shape. </li><li>  A CAKeyframeAnimation animation is created that describes the behavior ‚Äî duration, type of approximation, time offset, etc.  The previously created path also ‚Äúclings‚Äù to this object. </li><li>  The CGLayer object is given the command to execute the resulting animation. </li></ol><br><br><h5>  Building a path </h5><br><br>  There are two types of paths: static CGPathRef and variable CGMutablePathRef.  The first is created using one of the functions; after creation, it cannot be changed.  For example, CGPathCreateWithEllipseInRect (CGRect rect, const CGAffineTransform * transform) creates an ellipse inscribed in a rectangle from the first parameter and imposes on it a transformation matrix from the second parameter.  This is the easiest and fastest way to create a path, but it has a drawback - the beginning of such a path will be between the 1st and 4th quarters, at 0 (360) degrees and have an hourly direction.  If we just want to draw the resulting path, this approach may well come in handy.  But in the case of animation, it will be inconvenient - the beginning and the direction matters. <br><br>  The second type of path, CGMutablePathRef, is created either empty and supplemented with separate functions, or by creating a modifiable copy of an existing path.  For example, consider creating a circle with a center at an arbitrary point: <br><br><pre><code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> center = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">200.0</span></span>, <span class="hljs-number"><span class="hljs-number">200.0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> radius = <span class="hljs-number"><span class="hljs-number">100.0</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">CGMutablePathRef</span></span> path = <span class="hljs-built_in"><span class="hljs-built_in">CGPathCreateMutable</span></span>(); <span class="hljs-built_in"><span class="hljs-built_in">CGPathAddArc</span></span>(path, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, center.x, center.y, radius, M_PI, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">NO</span></span>); <span class="hljs-comment"><span class="hljs-comment">// CGPathAddArc(path, NULL, center.x, center.y, radius, 0, M_PI, NO); CGPathRelease(path); //</span></span></code> </pre> <br><br><ul><li>  The CGPathAddArc function adds an arc to the path and takes the following parameters: <br><ol><li>  changeable path </li><li>  transformation matrix </li><li>  X coordinate of the center of the circle </li><li>  The coordinate of the center of the circle </li><li>  arc radius </li><li>  angle from X axis to the beginning of the arc, in radians </li><li>  angle to end of arc </li><li>  direction, in this case counterclockwise </li></ol><br></li><li>  The responsibility for releasing the created resource lies with the programmer.  Programmer, remember: leakage is bad.  The application will eat the memory, the apple will be indignant, and the user will be upset. </li></ul><br><br>  The value of some parameters of the CGPathAddArc function may not be obvious, and for a better understanding, look at the picture below: <br><br><img src="https://habrastorage.org/storage2/a1b/3ac/848/a1b3ac8480e3dcf3ceb8537e66d067bd.png"><br><br>  A is the center of an imaginary circle along which our arc will run.  Coordinates set parameters 3 and 4. <br>  B - the beginning of the arc, given by the angle, parameter 6. <br>  In - the end of the arc, similarly, parameter 7. <br><br><h5>  Creating and running animation </h5><br><br>  It's all easier: <br><br><pre> <code class="objectivec hljs"><span class="hljs-built_in"><span class="hljs-built_in">CAKeyframeAnimation</span></span> *pathAnimation = [<span class="hljs-built_in"><span class="hljs-built_in">CAKeyframeAnimation</span></span> animationWithKeyPath:<span class="hljs-string"><span class="hljs-string">@"position"</span></span>]; pathAnimation.path = path; pathAnimation.duration = <span class="hljs-number"><span class="hljs-number">2.0</span></span>f; [view.layer addAnimation:pathAnimation forKey:<span class="hljs-literal"><span class="hljs-literal">nil</span></span>];</code> </pre><br><br>  Create an instance of CAKeyframeAnimation and pass it to the Key-Value path constructor up to the property that we want to animate.  In our case, this is ‚Äúposition‚Äù. <br>  Assign animations previously created by CGPathRef. <br>  Set the duration of the animation. <br>  Take the UIView we need, find its CGLayer and cause the animation to play. <br><br>  Everything after this animation will start playing.  The second parameter is nil and our animation will remain nameless.  It will be impossible to contact her, but so far we don‚Äôt need it. <br>  It seems to be all simple, but there is a nuance.  How to combine the beginning of the path with UIView?  After all, if this is not done, the picture at the beginning of the animation will simply jump to the beginning of the first arc.  In order for everything to work as it should, we will have to complicate - what we will do next. <br><br><h4>  From theory to practice </h4><br><br>  In the example above, everything is simple and good, but boring and clumsy.  To make it more fun, we will write a small application in which the picture will move along an arc to the specified point.  Here is a video of what should be the result: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/tgbz_Gy6-6c%3Ffeature%3Doembed&amp;xid=17259,15700002,15700021,15700186,15700191,15700253,15700255&amp;usg=ALkJrhhGTeXHEbRJ4_RCniQMPhjduCW7sQ" frameborder="0" allowfullscreen=""></iframe><br><br>  First, create a Single View project and add the QuartzCore framework to it.  Then change the ViewController header: <br><br><pre> <code class="objectivec hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">@class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PathDrawingView</span></span></span><span class="hljs-class">; // 1 @</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CMViewController</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UIViewController</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">UIImageView</span></span> *_image; <span class="hljs-comment"><span class="hljs-comment">//2 BOOL _isAnimating; //3 BOOL _drawPath; //4 } @property (retain, nonatomic) PathDrawingView *pathView; //5 @end</span></span></code> </pre><br><br><ol><li>  We declare a helper class that will be responsible for rendering our path.  This makes debugging much easier. </li><li>  A simple picture that we will move. </li><li>  Flag playing animation. </li><li>  A flag to draw the path if we suddenly want to see how our picture will move. </li><li>  The mechanics of the work of an assistant imply multiple creation and deletion.  We declare it as a property to simplify this process. </li></ol><br><br>  Now to the implementation.  And let's start from the beginning, that is, by adding the necessary headers and declaring a constant: <br><br><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QuartzCore/QuartzCore.h&gt;</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PathDrawingView.h"</span></span></span><span class="hljs-meta"> static NSString *cAnimationKey = @</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"pathAnimation"</span></span></span><span class="hljs-meta">;</span></span></code> </pre><br><br>  The first heading is understandable, and the second is the class assistant.  The constant is useful to us for naming animations. <br><br>  Now we change the viewDidLoad method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) viewDidLoad { [<span class="hljs-keyword"><span class="hljs-keyword">super</span></span> viewDidLoad]; _drawPath = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; _isAnimating = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; _image = [[<span class="hljs-built_in"><span class="hljs-built_in">UIImageView</span></span> alloc] initWithImage:[<span class="hljs-built_in"><span class="hljs-built_in">UIImage</span></span> imageNamed:<span class="hljs-string"><span class="hljs-string">@"image.png"</span></span>]]; _image.center = <span class="hljs-built_in"><span class="hljs-built_in">CGPointMake</span></span>(<span class="hljs-number"><span class="hljs-number">160</span></span>, <span class="hljs-number"><span class="hljs-number">240</span></span>); [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view addSubview:_image]; }</code> </pre><br><br>  Set the flags.  If we suddenly want to see how our path looks, we will need to activate _drawPath.  It is clear that _isAnimating is not yet set for us - the animation is not playing yet.  Next, create an image and display it. <br><br>  We need to create a path, select it in a separate method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-built_in"><span class="hljs-built_in">CGPathRef</span></span>) pathToPoint:(<span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span>) point { <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> imagePos = _image.center; <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> xDist = (point.x - imagePos.x); <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> yDist = (point.y - imagePos.y); <span class="hljs-built_in"><span class="hljs-built_in">CGFloat</span></span> radius = sqrt((xDist * xDist) + (yDist * yDist)) / <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 CGPoint center = CGPointMake(imagePos.x + radius, imagePos.y); //2 CGFloat angle = atan2f(yDist, xDist); // 3 CGAffineTransform transform = CGAffineTransformIdentity; transform = CGAffineTransformTranslate(transform, imagePos.x, imagePos.y); transform = CGAffineTransformRotate(transform, angle); transform = CGAffineTransformTranslate(transform, -imagePos.x, -imagePos.y); //4 CGMutablePathRef path = CGPathCreateMutable(); CGPathAddArc(path, &amp;transform, center.x, center.y, radius, M_PI, 0, YES); //CGPathAddArc(path, &amp;transform, center.x, center.y, radius, 0, M_PI, YES); //5 return path; }</span></span></code> </pre><br><br>  The method passes the destination point (T) and it is conventionally divided into 4 blocks: <br><br><ol><li>  By the Pythagorean theorem, we calculate the distance between the picture and T. Divide into two and get the radius of the arc, the beginning of which will be in the picture, and the end - at the desired point. </li><li>  First we will work in the coordinate system, where the center of the image and T are on one straight line, passing along the Y axis. In this coordinate system, the center of the desired circle will be shifted by a distance of radius along the X axis. </li><li>  Find the angle between the center of the picture and T. Of course, in the original coordinate system.  To do this, use the previously found vector from T to the center of the image. </li><li>  Create a rotation matrix for the transition from an arbitrary coordinate system to the "real". </li><li>  Create a path.  By this moment we have all the necessary data.  Please note that one line is commented out.  Only one arc is created - we want the picture to stop at the specified point, rather than pass through it and come back. </li></ol><br><br>  Let's move on to the animation itself: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) followThePath:(<span class="hljs-built_in"><span class="hljs-built_in">CGPathRef</span></span>) path { <span class="hljs-built_in"><span class="hljs-built_in">CAKeyframeAnimation</span></span> *pathAnimation = [<span class="hljs-built_in"><span class="hljs-built_in">CAKeyframeAnimation</span></span> animationWithKeyPath:<span class="hljs-string"><span class="hljs-string">@"position"</span></span>]; pathAnimation.path = path; pathAnimation.removedOnCompletion = <span class="hljs-literal"><span class="hljs-literal">NO</span></span>; <span class="hljs-comment"><span class="hljs-comment">// 1 pathAnimation.fillMode = kCAFillModeForwards; //2 pathAnimation.duration = 2.0f; pathAnimation.calculationMode = kCAAnimationPaced; //3 pathAnimation.delegate = self; //4 [_image.layer addAnimation:pathAnimation forKey:cAnimationKey]; //5 }</span></span></code> </pre><br><br>  What's new here? <br><br><ol><li>  Indicates that the animation should remain after the end.  This is necessary so that we can read the last value.  But why you need it - it will be clear later. </li><li>  Indicates that the animation object (i.e., the image that we are going to move) should remain in the state in which the animation ended.  If you remove, the picture will jump to where it started moving. </li><li>  Sets the method for calculating animation intermediate frames.  If we want (and we want!) To stop the animation at an arbitrary moment, we need to specify just such a view.  Otherwise, the picture will jump, and not stop at exactly the current position. </li><li>  We assign ourselves as the delegate of animation to catch the moment of its termination. </li><li>  Run the animation.  This time, we give her a name. </li></ol><br><br>  Now we need to handle the end of the animation: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) stop { <span class="hljs-built_in"><span class="hljs-built_in">CALayer</span></span> *pLayer = _image.layer.presentationLayer; <span class="hljs-comment"><span class="hljs-comment">// 1 CGPoint currentPos = pLayer.position; [_image.layer removeAnimationForKey:cAnimationKey]; // 2 [_image setCenter:currentPos]; _isAnimating = NO; }</span></span></code> </pre><br><br><ol><li>  We take the presentation layer, it is there that the animation is spinning and contains actual information about the state of the object during its playback - this is a feature of the Core Graphics framework.  If this is not done, the picture will jump to where the animation began. </li><li>  We remove our animation. </li></ol><br><br>  Add the delegate delegate method: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) animationDidStop:(<span class="hljs-built_in"><span class="hljs-built_in">CAAnimation</span></span> *)anim finished:(<span class="hljs-built_in"><span class="hljs-built_in">BOOL</span></span>)flag { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag) [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> stop]; }</code> </pre><br><br>  Everything is simple here: if the animation is over itself, we stop it and do the necessary actions.  In the case of a forced interruption, stop it in another place.  Right here in the touch handler: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) touchesBegan:(<span class="hljs-built_in"><span class="hljs-built_in">NSSet</span></span> *)touches withEvent:(<span class="hljs-built_in"><span class="hljs-built_in">UIEvent</span></span> *)event { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_isAnimating) [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> stop]; _isAnimating = <span class="hljs-literal"><span class="hljs-literal">YES</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">UITouch</span></span> *touch = [touches anyObject]; <span class="hljs-built_in"><span class="hljs-built_in">CGPoint</span></span> touchPoint = [touch locationInView:<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.view]; <span class="hljs-built_in"><span class="hljs-built_in">CGPathRef</span></span> path = [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> pathToPoint:touchPoint]; [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> followThePath:path]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (_drawPath) [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span> drawPath:path]; <span class="hljs-built_in"><span class="hljs-built_in">CGPathRelease</span></span>(path); }</code> </pre><br><br>  Here we simply connect everything written earlier and release the created path. <br>  It remains to add a debugging method for drawing the path: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) drawPath:(<span class="hljs-built_in"><span class="hljs-built_in">CGPathRef</span></span>) path { [<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pathView removeFromSuperview]; <span class="hljs-comment"><span class="hljs-comment">// 1 self.pathView = [[PathDrawingView alloc] init]; // 2 self.pathView.path = path; self.pathView.frame = self.view.frame; [self.view addSubview:self.pathView]; }</span></span></code> </pre><br><br><ol><li>  Remove the previous path from the screen, otherwise there will be porridge </li><li>  Create a special object for drawing the path.  His code will be lower. </li></ol><br><br>  Finally, free up resources: <br><br><pre> <code class="objectivec hljs">- (<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>) viewDidUnload { [_image release]; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pathView = <span class="hljs-literal"><span class="hljs-literal">nil</span></span>; }</code> </pre><br><br>  That's it, now you can run. <br><br><h5>  application </h5><br><br><div class="spoiler">  <b class="spoiler_title">PathDrawingView.h</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><span class="hljs-meta"> @interface PathDrawingView : UIView { CGPathRef _path; } @property (retain, nonatomic) UIColor *strokeColor; @property (retain, nonatomic) UIColor *fillColor; @property (assign, nonatomic) CGPathRef path; @end</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">PathDrawingView.m</b> <div class="spoiler_text"><pre> <code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PathDrawingView.h"</span></span></span><span class="hljs-meta"> #import </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QuartzCore/QuartzCore.h&gt;</span></span></span><span class="hljs-meta"> @implementation PathDrawingView @synthesize strokeColor, fillColor; - (CGPathRef) path { return _path; } - (void) setPath:(CGPathRef)path { CGPathRelease(_path); _path = CGPathRetain(path); } - (void)drawRect:(CGRect)rect { CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextSetStrokeColorWithColor(ctx, strokeColor.CGColor); CGContextSetFillColorWithColor(ctx, fillColor.CGColor); CGContextAddPath(ctx, _path); CGContextStrokePath(ctx); } - (id) init { if (self = [super init]) { self.fillColor = [UIColor clearColor]; self.strokeColor = [UIColor redColor]; self.backgroundColor = [UIColor clearColor]; } return self; } - (void) dealloc { self.fillColor = nil; self.strokeColor = nil; CGPathRelease(_path); [super dealloc]; } @end</span></span></code> </pre> </div></div><br><br>  <a href="https://github.com/kirpa/Circle-Movement-Demo">GitHub</a> Project Code <br>  <a href="https://developer.apple.com/library/ios/">Core Animation Programming Guide</a> - A description of the subtleties of the framework. <br>  <a href="https://developer.apple.com/library/ios/">CGPathRef reference</a> - And also, functions for working with this structure. </div><p>Source: <a href="https://habr.com/ru/post/171735/">https://habr.com/ru/post/171735/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../171725/index.html">Non-standard cost-saving: how we learned to repair the Nortel 1120 office IP phones by ourselves</a></li>
<li><a href="../171727/index.html">Lean. Part 1. Kanban board in a new way.</a></li>
<li><a href="../171729/index.html">CeBIT 2013: SMI Augmented Eyewear Goggles</a></li>
<li><a href="../171731/index.html">JavaScript Prototypes for C / C ++ / C # / Java Programmers</a></li>
<li><a href="../171733/index.html">Nirvana for Testers - Nerrvana</a></li>
<li><a href="../171743/index.html">Arbitrary view of the file field in html-form, the same in all browsers</a></li>
<li><a href="../171745/index.html">PostgreSQL performance scaling with table partitioning</a></li>
<li><a href="../171747/index.html">CeBIT'13. The first day</a></li>
<li><a href="../171749/index.html">Caution: Intruders</a></li>
<li><a href="../171751/index.html">Differential Evolution: Genetic Function Optimization Algorithm</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>