<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About Z-order and R-tree</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="An index based on a Z-order curve versus an R-tree has many advantages, it is: 



- implemented as a normal b-tree, and we know that 
- B-tree pages ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About Z-order and R-tree</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/files/3a9/cf4/f19/3a9cf4f195fe4a4fb743a640588a1c6f.png" alt="image"></div><br>  An index based on a <a href="https://en.wikipedia.org/wiki/Z-order_curve">Z-order</a> curve versus an <a href="https://en.wikipedia.org/wiki/R-tree">R-tree</a> has many advantages, it is: <br><br><ul><li>  implemented as a normal b-tree, and we know that </li><li>  B-tree pages have better occupancy, moreover, </li><li>  Z-keys themselves are more compact. </li><li>  B-tree has a natural traversal order, unlike R-tree. </li><li>  B-tree is built faster </li><li>  B-tree is better balanced </li><li>  B-tree is clearer, does not depend on page splitting / merging heuristics </li><li>  B-tree does not degrade with constant changes </li><li>  ... </li></ul><br>  However, Z-order-based indexes have a disadvantage - relatively low productivity :).  Under the cut, we will try to figure out what this flaw is connected with and whether something can be done about it. <br><a name="habracut"></a><br>  Roughly, the meaning of the Z-curve is as follows - we alternate the digits of the x &amp; y coordinates in one value, as a result.  Example - (x = 33 ( <b>010 0001</b> ), y = 22 ( <i>01 0110</i> ), Z = 1577 ( <i>0</i> <b>1</b> <i>1</i> <b>0</b> <i>0</i> <b>0</b> <i>1</i> <b>0</b> <i>1</i> <b>0</b> <i>0</i> <b>1</b> ). If two points have close coordinates, then most likely Z- their values ‚Äã‚Äãwill be close. <br>  The three-dimensional (or more) version is arranged in the same way, we alternate the digits of three (or more) coordinates. <br><br>  And to search in a certain extent, we must ‚Äúrasterize‚Äù all values ‚Äã‚Äãof the Z-curve for this extent, find continuous intervals and search in each one. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Here is an illustration for the extent [111000 ... 111000] [111400 ... 111400] (675 intervals), the upper right corner (each continuous polyline - one interval): <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/cd8/7a1/c0b/cd87a1c0b06a43c0a7dec2f1ed5ed30a.png" alt="image"></div><br>  And, for example, for the extent [111000 ... 111000] [112000 ... 112000] we get 1688 continuous intervals, obviously, their number mainly depends on the length of the perimeter.  Looking ahead, on the test data, 15 points in 6 intervals fell into this extent. <br><br>  Yes, most of these intervals are small, even degenerate - from one value.  And nevertheless, even if in all this extent there is only one value, it can be in any of the intervals.  And, like it or not, we will have to do all 1,688 subqueries to find out how many points there really are. <br><br>  To view everything from the value of the lower left corner to the upper right is not an option, the difference between the angles in this case is 3,144,768, we will have to view more than three times more data, and this is not the worst case.  For example, an extent [499500 ... 499500] [500500 ... 500500] will give a range of 135,263,808 values, ~ 135 times the extent of the extent. <br><br>  And here we can ask the traditional question - <br><br><h3>  What if ... </h3><br>  Suppose we have an empty index in general, do we really need to do all these hundreds and thousands of subqueries in order to understand this?  No, one is enough - from the lower left to the upper right corner. <br><br>  Now suppose that the extent is small enough, the data are sparse and there is little chance of finding something small.  Perform the same query from corner to corner.  If nothing is found, then nothing.  Otherwise there is a chance.  But as we have seen, the area swept up by the request from corner to corner can be many times the search extent and we have no desire to deduct obviously unnecessary data.  Therefore, we will not look through the entire cursor, but take only the minimum Z-value from it.  For this, the query is executed with (order by) and (top 1). <br><br>  So, we have some value.  Suppose this value is not from our extent, what can it give?  It's time to remember that we have a sorted array of [1 ... N] subquery ranges.  We will perform a binary search and find out between which subqueries this value was squeezed in, say, between m and m + 1.  Remarkably, it means that requests from 1 to m can be omitted, there is obviously nothing there. <br><br>  If the value belongs to our extent, then it falls into one of our ranges and we can also find in which, let m too.  As before, requests with numbers 1 ... m-1 can not be executed.  But the interval with the number m deserves a separate request, which will give us everything that is located in it. <br><br>  Well, perhaps there is still data, let's continue.  Again we will execute the query, but not from the corner to the corner, but from the beginning of the interval m + 1 to the upper right corner.  And we will do so until we reach the end of the list of intervals. <br><br>  That's the whole idea, we note, it works fine in the case when a lot or even a lot of data falls into the extent.  At first glance, this will significantly reduce the number of requests and speed up work. <br><br>  It's time to test the idea in practice.  We‚Äôll use <a href="https://www.postgresql.org/">PostgeSQL</a> 9.6.1, <a href="https://www.postgresql.org/docs/9.6/static/gist.html">GiST</a> as a test site.  The measurements were conducted on a modest virtual machine with two cores and 4 GB of RAM, so the times have no absolute value, but the numbers of the pages you read can be trusted. <br><br><h3>  Initial data </h3><br>  As data, 100 million random points in the extent [0 ... 1 000 000] [0 ... 1 000 000] were used. <br><br>  Let's get a table for 2-dimensional point data: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> test_points (x <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>,y <span class="hljs-built_in"><span class="hljs-built_in">integer</span></span>);</code> </pre> <br>  We will create the data: <br><br><div class="spoiler">  <b class="spoiler_title">gawk script</b> <div class="spoiler_text">  BEGIN { <br>  for (i = 0; i &lt;100000000; i ++) <br>  { <br>  x = int (1000000 * rand ()); <br>  y = int (1000000 * rand ()); <br>  print x "\ t" z; <br>  } <br>  exit (0); <br>  } <br></div></div><br>  Sort the resulting file (explained below) and fill it with the COPY operator into the table: <br><br><pre> <code class="sql hljs">COPY test_points from '/home/.../data.csv';</code> </pre> <br>  Filling the table takes a few minutes.  Data size (\ dt +) - 4358 Mb <br><br><h3>  R-tree </h3><br>  The corresponding index is created by the command: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> test_gist_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_points <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> gist ((point(x,y)));</code> </pre> <br>  But there is a nuance.  On random data, the index is built for a very long time (in any case, the author did not manage to line up overnight).  Building on the pre-sorted data took about an hour. <br><br>  Index size (\ di +) - 9031 Mb <br><br>  In essence, for us the order of the data in the table is not important, but it must be common to different methods, so I had to use a sorted table. <br><br>  The test query looks like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test_points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> point(x,y) &lt;@ box(point(<span class="hljs-string"><span class="hljs-string">"xmin"</span></span>,<span class="hljs-string"><span class="hljs-string">"ymin"</span></span>),point(<span class="hljs-string"><span class="hljs-string">"xmax"</span></span>,<span class="hljs-string"><span class="hljs-string">"ymax"</span></span>));</code> </pre><br><h3>  Check on ordinary indexes </h3><br>  To test the functionality we will perform spatial queries and on separate indexes on x &amp; y.  They are made like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> x_test_points <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_points (x); <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> y_test_points <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_points (y);</code> </pre><br>  It takes a few minutes. <br><br>  Test request: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test_points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> x &gt;= <span class="hljs-string"><span class="hljs-string">"xmin"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> x &lt;= <span class="hljs-string"><span class="hljs-string">"xmax"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> y &gt;= <span class="hljs-string"><span class="hljs-string">"ymin"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> y &lt;= <span class="hljs-string"><span class="hljs-string">"ymax"</span></span>;</code> </pre><br><h3>  Z-index </h3><br>  Now we need a function that can convert x, y coordinates to a Z-value. <br><br>  First we create an <a href="https://habrahabr.ru/post/198332/">extension</a> , in it a function: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> zcurve_val_from_xy(<span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'MODULE_PATHNAME'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> C IMMUTABLE <span class="hljs-keyword"><span class="hljs-keyword">STRICT</span></span>;</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Her body:</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> uint32 stoBits[<span class="hljs-number"><span class="hljs-number">8</span></span>] = {<span class="hljs-number"><span class="hljs-number">0x0001</span></span>, <span class="hljs-number"><span class="hljs-number">0x0002</span></span>, <span class="hljs-number"><span class="hljs-number">0x0004</span></span>, <span class="hljs-number"><span class="hljs-number">0x0008</span></span>, <span class="hljs-number"><span class="hljs-number">0x0010</span></span>, <span class="hljs-number"><span class="hljs-number">0x0020</span></span>, <span class="hljs-number"><span class="hljs-number">0x0040</span></span>, <span class="hljs-number"><span class="hljs-number">0x0080</span></span>}; <span class="hljs-function"><span class="hljs-function">uint64 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zcurve_fromXY</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(uint32 ix, uint32 iy)</span></span></span><span class="hljs-function"> </span></span>{ uint64 val = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> curmask = <span class="hljs-number"><span class="hljs-number">0xf</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)&amp;val; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">8</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> xp = (ix &amp; curmask) &gt;&gt; (i&lt;&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> yp = (iy &amp; curmask) &gt;&gt; (i&lt;&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> tmp = (xp &amp; stoBits[<span class="hljs-number"><span class="hljs-number">0</span></span>]) | ((yp &amp; stoBits[<span class="hljs-number"><span class="hljs-number">0</span></span>])&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) | ((xp &amp; stoBits[<span class="hljs-number"><span class="hljs-number">1</span></span>])&lt;&lt;<span class="hljs-number"><span class="hljs-number">1</span></span>) | ((yp &amp; stoBits[<span class="hljs-number"><span class="hljs-number">1</span></span>])&lt;&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) | ((xp &amp; stoBits[<span class="hljs-number"><span class="hljs-number">2</span></span>])&lt;&lt;<span class="hljs-number"><span class="hljs-number">2</span></span>) | ((yp &amp; stoBits[<span class="hljs-number"><span class="hljs-number">2</span></span>])&lt;&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>) | ((xp &amp; stoBits[<span class="hljs-number"><span class="hljs-number">3</span></span>])&lt;&lt;<span class="hljs-number"><span class="hljs-number">3</span></span>) | ((yp &amp; stoBits[<span class="hljs-number"><span class="hljs-number">3</span></span>])&lt;&lt;<span class="hljs-number"><span class="hljs-number">4</span></span>); curmask &lt;&lt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; ptr[i] = (<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)tmp; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-function"><span class="hljs-function">Datum </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">zcurve_val_from_xy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PG_FUNCTION_ARGS)</span></span></span><span class="hljs-function"> </span></span>{ uint64 v1 = PG_GETARG_INT64(<span class="hljs-number"><span class="hljs-number">0</span></span>); uint64 v2 = PG_GETARG_INT64(<span class="hljs-number"><span class="hljs-number">1</span></span>); PG_RETURN_INT64(zcurve_fromXY(v1, v2)); }</code> </pre><br></div></div><br>  Now (after CREATE EXTENSION, of course) the Z-index is constructed as follows: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> zcurve_test_points <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> test_points(zcurve_val_from_xy(x, y));</code> </pre> <br>  This takes several minutes (and does not require data sorting). <br><br>  Index size (\ di +) - 2142 Mb (~ 4 times smaller than that of R-tree) <br><br><h3>  Z Index Search </h3><br>  So, in our first (let's call it ‚Äúnaive‚Äù) version, we will do this: <br><br><ol><li>  For an extent of size dx * dy, we create an array of identifiers of the appropriate size </li><li>  Z-value is calculated for each point in extent. </li><li>  Sorting an array of identifiers </li><li>  Find continuous intervals </li><li>  For each interval we execute the following subquery: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test_points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> zcurve_val_from_xy(x, y) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br></li><li>  We get the result </li></ol><br>  To search using this option, we will use the function (body below): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> zcurve_oids_by_extent(<span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'MODULE_PATHNAME'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> C IMMUTABLE <span class="hljs-keyword"><span class="hljs-keyword">STRICT</span></span>;</code> </pre><br>  Spatial query using this function looks like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> zcurve_oids_by_extent(<span class="hljs-string"><span class="hljs-string">"xmin"</span></span>,<span class="hljs-string"><span class="hljs-string">"ymin"</span></span>,<span class="hljs-string"><span class="hljs-string">"xmax"</span></span>,<span class="hljs-string"><span class="hljs-string">"ymax"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>;</code> </pre> <br>  The function returns only the number of hits, the data itself, if necessary, can be displayed using ‚Äú <a href="https://postgrespro.ru/blog/pgsql/119069">elog (INFO ...)</a> ‚Äù. <br><br>  The second, improved (let's call it ‚Äúwith samples‚Äù) option looks like this: <br><br><ol><li>  for an extent of size dx * dy, we create an array of identifiers of the appropriate size </li><li>  Z-value is calculated for each point in extent. </li><li>  sort the array of identifiers </li><li>  find continuous intervals </li><li>  we start from the first interval found: <br><br><ol><li>  Perform a ‚Äútest‚Äù type request (parameters - interval limits): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test_points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> zcurve_val_from_xy(x, y) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">order</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> zcurve_val_from_xy(x, y) <span class="hljs-keyword"><span class="hljs-keyword">limit</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre><br></li><li>  This query gives us the table row with the smallest Z-value from the beginning of the current test interval to the end of the search extent. <br></li><li>  If the query did not find anything, then there is no data left in the search extent, we exit. <br></li><li>  Now we can analyze the found Z-value: <br><br><ol><li>  We look, whether it got in any of our intervals. </li><li>  If not, find the number of the next remaining interval and go to point 5. </li><li>  If horrible, we execute a query for this interval of type: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> test_points <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> zcurve_val_from_xy(x, y) <span class="hljs-keyword"><span class="hljs-keyword">between</span></span> $<span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> $<span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre><br></li><li>  Take the next interval and go to point 5. </li></ol></li></ol></li></ol><br>  To search using this option, we will use the function: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> zcurve_oids_by_extent_ii(<span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-string"><span class="hljs-string">'MODULE_PATHNAME'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> C IMMUTABLE <span class="hljs-keyword"><span class="hljs-keyword">STRICT</span></span>;</code> </pre><br>  Spatial query using this function looks like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> zcurve_oids_by_extent_ii(<span class="hljs-string"><span class="hljs-string">"xmin"</span></span>,<span class="hljs-string"><span class="hljs-string">"ymin"</span></span>,<span class="hljs-string"><span class="hljs-string">"xmax"</span></span>,<span class="hljs-string"><span class="hljs-string">"ymax"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>;</code> </pre> <br>  The function also returns only the number of hits. <br><br><h3>  Rasterization </h3><br>  In the described algorithms, a very simple and inefficient ‚Äúrasterization‚Äù algorithm is used - obtaining a list of intervals. <br><br>  On the other hand, it is easy to perform measurements of the average times of its work on random extents of the desired size.  Here they are: <br><table><tbody><tr><th>  Dx * dy extent </th><th>  Expected average number of points in the output </th><th>  Time, msec </th></tr><tr><td>  100X100 </td><td>  one </td><td>  .96 (.37 + .59) </td></tr><tr><td>  316X316 </td><td>  ten </td><td>  11 (3.9 + 7.1) </td></tr><tr><td>  1000X1000 </td><td>  100 </td><td>  119.7 (35 + 84.7) </td></tr><tr><td>  3162X3162 </td><td>  1000 </td><td>  1298 (388 + 910) </td></tr><tr><td>  10000X10000 </td><td>  10,000 </td><td>  14696 (3883 + 10813) </td></tr></tbody></table>  Separately in brackets are two phases - the calculation of Z-values ‚Äã‚Äãand sorting <br><br><h3>  results </h3><br>  Here is a summary table with data. <br><table><tbody><tr><th>  Npoints </th><th>  Type </th><th>  Time (ms) </th><th>  Reads </th><th>  Shared hits </th></tr><tr><td>  one </td><td>  X &amp; Y <br>  rtree <br>  Z-value <br>  Z-value-ii </td><td>  43.6 <br>  .five <br>  8.3 (9.4) <br>  1.1 (2.2) </td><td>  59.0173 <br>  4.2314 <br>  4.0988 <br>  4.1984 (12.623) </td><td>  6.1596 <br>  2.6565 <br>  803.171 <br>  20.1893 (57.775) </td></tr><tr><td>  ten </td><td>  X &amp; Y <br>  rtree <br>  Z-value <br>  Z-value-ii </td><td>  83.5 <br>  .6 <br>  15 (26) <br>  4 (15) </td><td>  182.592 <br>  13.7341 <br>  14.834 <br>  14.832 (31.439) </td><td>  9.24363 <br>  2.72466 <br>  2527.56 <br>  61.814 (186.314) </td></tr><tr><td>  100 </td><td>  X &amp; Y <br>  rtree <br>  Z-value <br>  Z-value-ii </td><td>  220 <br>  2.1 <br>  80 (200) <br>  10 (130) </td><td>  704.208 <br>  95.8179 <br>  95.215 <br>  96.198 (160.443) </td><td>  16.528 <br>  5.3754 <br>  8007.3 <br>  208.214 (600.049) </td></tr><tr><td>  1000 </td><td>  X &amp; Y <br>  rtree <br>  Z-value <br>  Z-value-ii </td><td>  740 <br>  12 <br>  500 (1800) <br>  200 (1500) </td><td>  3176.06 <br>  746.617 <br>  739.32 <br>  739.58 (912.631) </td><td>  55.135 <br>  25.439 <br>  25816 <br>  842.88 (2028.81) </td></tr><tr><td>  10,000 </td><td>  X &amp; Y <br>  rtree <br>  Z-value <br>  Z-value-ii </td><td>  2,500 <br>  70 ... 1 200 <br>  4700 (19000) <br>  1300 (16000) </td><td>  12393.2 <br>  4385.64 <br>  4284.45 <br>  4305.78 (4669) </td><td>  101.43 <br>  121.56 <br>  86274.9 <br>  5785.06 (9188) </td></tr></tbody></table>  <b>Npoints</b> - the average number of points in the issue. <br><br>  <b>Type</b> - <ul><li>  'X &amp; Y' - use separate indexes on x &amp; y </li><li>  'rtree' - request via R-tree </li><li>  Z-value - fair search at intervals </li><li>  'Z-value-ii' - search at intervals with samples </li></ul><br>  <b>Time (ms)</b> - the average time of the request.  Under these conditions, the value is very unstable, it depends on the DBMS cache and on the disk cache of the virtual machine and on the disk cache of the host system.  Here is more for reference.  <i>For Z-value and Z-value-ii are 2 numbers.</i>  <i>In brackets - the actual time.</i>  <i>Without brackets - time minus the cost of "rasterization".</i> <br><br>  <b>Reads</b> - the average number of reads per request (obtained through EXPLAIN (ANALYZE, BUFFERS)) <br><br>  <b>Shared hits</b> - the number of calls to the buffers (...) <br>  <i>For Z-value-ii, 2 numbers are given in the Reads &amp; Shared hits columns.</i>  <i>In brackets - the total number of readings.</i>  <i>No brackets - minus probe requests with order by and limit 1. This is done because of the opinion that such a query reads all the data in the interval, sorts and gives the minimum, instead of just giving 1 value from an already sorted index.</i>  <i>Therefore, statistics on such requests was deemed unnecessary, but given for reference.</i> <br><br>  The times are shown on the second runs, on the heated server and the virtual machine.  The number of buffers read is on a freshly raised server. <br><br>  In all types of queries, the data of the table itself was also not belonging to indexes.  However, this is the same data of the same table, so for all types of queries we obtained constant values. <br><br><h3>  findings </h3><br><ol><li>  R-tree is still very good in statics, the efficiency of page reads is very high. </li><li>  But the Z-order index sometimes has to read pages that do not have the necessary data.  This happens when the testing cursor falls between the intervals, there is a chance that there will be many other points in this gap and the specific page does not contain any summary data. </li><li>  <b>Nevertheless, due to the more dense packing, the Z-order is close to the R-tree by the number of actually read pages</b> .  This suggests that <b>potentially</b> Z-order is capable of delivering similar performance. <br></li><li>  Z-order index reads a huge number of pages from the cache.  multiple requests are made in the same place.  On the other hand, these readings are relatively inexpensive. </li><li>  On large queries, Z-order loses much of its speed in an R-tree.  This is explained by the fact that we use <a href="http://postgrespro.ru/docs/postgrespro/9.5/spi">SPI</a> , a high-level and not too fast mechanism, for executing subqueries.  And with ‚Äúrasterization‚Äù, of course, something needs to be done. </li><li>  At first glance, the use of sample intervals did not greatly accelerate the work, and formally even worsened the statistics of page readings.  But we must understand that these are the costs of the high-level funds that had to be used.  Potentially, an index based on Z-order is not worse than an R-tree in performance and much better in other tactical and technical characteristics. </li></ol><br><h3>  Perspectives </h3><br>  To create a full spatial index based on a Z-order curve that would be able to compete on equal terms with an R-tree, the following problems must be solved: <br><br><ul><li>  come up with an inexpensive algorithm for obtaining a list of subintervals by extent </li><li>  go to low-level access to the index tree </li></ul><br>  Fortunately, both do not seem impossible. <br><br><div class="spoiler">  <b class="spoiler_title">Sources</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"postgres.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"catalog/pg_type.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"fmgr.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; #include "executor/spi.h" PG_MODULE_MAGIC; uint64 zcurve_fromXY (uint32 ix, uint32 iy); void zcurve_toXY (uint64 al, uint32 *px, uint32 *py); static uint32 stoBits[8] = {0x0001, 0x0002, 0x0004, 0x0008, 0x0010, 0x0020, 0x0040, 0x0080}; uint64 zcurve_fromXY (uint32 ix, uint32 iy) { uint64 val = 0; int curmask = 0xf; unsigned char *ptr = (unsigned char *)&amp;val; int i; for (i = 0; i &lt; 8; i++) { int xp = (ix &amp; curmask) &gt;&gt; (i&lt;&lt;2); int yp = (iy &amp; curmask) &gt;&gt; (i&lt;&lt;2); int tmp = (xp &amp; stoBits[0]) | ((yp &amp; stoBits[0])&lt;&lt;1) | ((xp &amp; stoBits[1])&lt;&lt;1) | ((yp &amp; stoBits[1])&lt;&lt;2) | ((xp &amp; stoBits[2])&lt;&lt;2) | ((yp &amp; stoBits[2])&lt;&lt;3) | ((xp &amp; stoBits[3])&lt;&lt;3) | ((yp &amp; stoBits[3])&lt;&lt;4); curmask &lt;&lt;= 4; ptr[i] = (unsigned char)tmp; } return val; } void zcurve_toXY (uint64 al, uint32 *px, uint32 *py) { unsigned char *ptr = (unsigned char *)&amp;al; int ix = 0; int iy = 0; int i; if (!px || !py) return; for (i = 0; i &lt; 8; i++) { int tmp = ptr[i]; int tmpx = (tmp &amp; stoBits[0]) + ((tmp &amp; stoBits[2])&gt;&gt;1) + ((tmp &amp; stoBits[4])&gt;&gt;2) + ((tmp &amp; stoBits[6])&gt;&gt;3); int tmpy = ((tmp &amp; stoBits[1])&gt;&gt;1) + ((tmp &amp; stoBits[3])&gt;&gt;2) + ((tmp &amp; stoBits[5])&gt;&gt;3) + ((tmp &amp; stoBits[7])&gt;&gt;4); ix |= tmpx &lt;&lt; (i &lt;&lt; 2); iy |= tmpy &lt;&lt; (i &lt;&lt; 2); } *px = ix; *py = iy; } PG_FUNCTION_INFO_V1(zcurve_val_from_xy); Datum zcurve_val_from_xy(PG_FUNCTION_ARGS) { uint64 v1 = PG_GETARG_INT64(0); uint64 v2 = PG_GETARG_INT64(1); PG_RETURN_INT64(zcurve_fromXY(v1, v2)); } static const int s_maxx = 1000000; static const int s_maxy = 1000000; #ifndef MIN #define MIN(a,b) ((a)&lt;(b)?(a):(b)) #endif static int compare_uint64( const void *arg1, const void *arg2 ) { const uint64 *a = (const uint64 *)arg1; const uint64 *b = (const uint64 *)arg2; if (*a == *b) return 0; return *a &gt; *b ? 1: -1; } SPIPlanPtr prep_interval_request(); int fin_interval_request(SPIPlanPtr pplan); int run_interval_request(SPIPlanPtr pplan, uint64 v0, uint64 v1); SPIPlanPtr prep_interval_request() { SPIPlanPtr pplan; char sql[8192]; int nkeys = 2; Oid argtypes[2] = {INT8OID, INT8OID}; /* key types to prepare execution plan */ int ret =0; if ((ret = SPI_connect()) &lt; 0) /* internal error */ elog(ERROR, "check_primary_key: SPI_connect returned %d", ret); snprintf(sql, sizeof(sql), "select * from test_points where zcurve_val_from_xy(x, y) between $1 and $2"); /* Prepare plan for query */ pplan = SPI_prepare(sql, nkeys, argtypes); if (pplan == NULL) /* internal error */ elog(ERROR, "check_primary_key: SPI_prepare returned %d", SPI_result); return pplan; } int fin_interval_request(SPIPlanPtr pplan) { SPI_finish(); return 0; } int run_interval_request(SPIPlanPtr pplan, uint64 v0, uint64 v1) { Datum values[2]; /* key types to prepare execution plan */ Portal portal; int cnt = 0, i; values[0] = Int64GetDatum(v0); values[1] = Int64GetDatum(v1); portal = SPI_cursor_open(NULL, pplan, values, NULL, true); if (NULL == portal) /* internal error */ elog(ERROR, "check_primary_key: SPI_cursor_open"); for (;;) { SPI_cursor_fetch(portal, true, 8); if (0 == SPI_processed || NULL == SPI_tuptable) break; { TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc; for (i = 0; i &lt; SPI_processed; i++) { HeapTuple tuple = SPI_tuptable-&gt;vals[i]; //elog(INFO, "%s, %s", SPI_getvalue(tuple, tupdesc, 1), SPI_getvalue(tuple, tupdesc, 2)); cnt++; } } } SPI_cursor_close(portal); return cnt; } PG_FUNCTION_INFO_V1(zcurve_oids_by_extent); Datum zcurve_oids_by_extent(PG_FUNCTION_ARGS) { SPIPlanPtr pplan; uint64 x0 = PG_GETARG_INT64(0); uint64 y0 = PG_GETARG_INT64(1); uint64 x1 = PG_GETARG_INT64(2); uint64 y1 = PG_GETARG_INT64(3); uint64 *ids = NULL; int cnt = 0; int sz = 0, ix, iy; x0 = MIN(x0, s_maxx); y0 = MIN(y0, s_maxy); x1 = MIN(x1, s_maxx); y1 = MIN(y1, s_maxy); if (x0 &gt; x1) elog(ERROR, "xmin &gt; xmax"); if (y0 &gt; y1) elog(ERROR, "ymin &gt; ymax"); sz = (x1 - x0 + 1) * (y1 - y0 + 1); ids = (uint64*)palloc(sz * sizeof(uint64)); if (NULL == ids) /* internal error */ elog(ERROR, "cant alloc %d bytes in zcurve_oids_by_extent", sz); for (ix = x0; ix &lt;= x1; ix++) for (iy = y0; iy &lt;= y1; iy++) { ids[cnt++] = zcurve_fromXY(ix, iy); } qsort (ids, sz, sizeof(*ids), compare_uint64); cnt = 0; pplan = prep_interval_request(); { // FILE *fl = fopen("/tmp/ttt.sql", "w"); int cur_start = 0; int ix; for (ix = cur_start + 1; ix &lt; sz; ix++) { if (ids[ix] != ids[ix - 1] + 1) { cnt += run_interval_request(pplan, ids[cur_start], ids[ix - 1]); // fprintf(fl, "EXPLAIN (ANALYZE,BUFFERS) select * from test_points where zcurve_val_from_xy(x, y) between %ld and %ld;\n", ids[cur_start], ids[ix - 1]); // elog(INFO, "%d -&gt; %d (%ld -&gt; %ld)", cur_start, ix - 1, ids[cur_start], ids[ix - 1]); // cnt++; cur_start = ix; } } if (cur_start != ix) { cnt += run_interval_request(pplan, ids[cur_start], ids[ix - 1]); // fprintf(fl, "EXPLAIN (ANALYZE,BUFFERS) select * from test_points where zcurve_val_from_xy(x, y) between %ld and %ld;\n", ids[cur_start], ids[ix - 1]); // elog(INFO, "%d -&gt; %d (%ld -&gt; %ld)", cur_start, ix - 1, ids[cur_start], ids[ix - 1]); } // fclose(fl); } fin_interval_request(pplan); pfree(ids); PG_RETURN_INT64(cnt); } //------------------------------------------------------------------------------------------------ struct interval_ctx_s { SPIPlanPtr cr_; SPIPlanPtr probe_cr_; uint64 cur_val_; uint64 top_val_; FILE * fl_; }; typedef struct interval_ctx_s interval_ctx_t; int prep_interval_request_ii(interval_ctx_t *ctx); int run_interval_request_ii(interval_ctx_t *ctx, uint64 v0, uint64 v1); int probe_interval_request_ii(interval_ctx_t *ctx, uint64 v0); int fin_interval_request_ii(interval_ctx_t *ctx); int prep_interval_request_ii(interval_ctx_t *ctx) { char sql[8192]; int nkeys = 2; Oid argtypes[2] = {INT8OID, INT8OID}; /* key types to prepare execution plan */ int ret =0; if ((ret = SPI_connect()) &lt; 0) /* internal error */ elog(ERROR, "check_primary_key: SPI_connect returned %d", ret); snprintf(sql, sizeof(sql), "select * from test_points where zcurve_val_from_xy(x, y) between $1 and $2"); ctx-&gt;cr_ = SPI_prepare(sql, nkeys, argtypes); if (ctx-&gt;cr_ == NULL) /* internal error */ elog(ERROR, "check_primary_key: SPI_prepare returned %d", SPI_result); snprintf(sql, sizeof(sql), "select * from test_points where zcurve_val_from_xy(x, y) between $1 and %ld order by zcurve_val_from_xy(x::int4, y::int4) limit 1", ctx-&gt;top_val_); ctx-&gt;probe_cr_ = SPI_prepare(sql, 1, argtypes); if (ctx-&gt;probe_cr_ == NULL) /* internal error */ elog(ERROR, "check_primary_key: SPI_prepare returned %d", SPI_result); return 1; } int probe_interval_request_ii(interval_ctx_t *ctx, uint64 v0) { Datum values[1]; /* key types to prepare execution plan */ Portal portal; values[0] = Int64GetDatum(v0); { // uint32 lx, ly; // zcurve_toXY (v0, &amp;lx, &amp;ly); // // elog(INFO, "probe(%ld:%d,%d)", v0, lx, ly); } if (ctx-&gt;fl_) fprintf(ctx-&gt;fl_, "EXPLAIN (ANALYZE,BUFFERS) select * from test_points where zcurve_val_from_xy(x, y) between %ld and %ld order by zcurve_val_from_xy(x::int4, y::int4) limit 1;\n", v0, ctx-&gt;top_val_); portal = SPI_cursor_open(NULL, ctx-&gt;probe_cr_, values, NULL, true); if (NULL == portal) /* internal error */ elog(ERROR, "check_primary_key: SPI_cursor_open"); { SPI_cursor_fetch(portal, true, 1); if (0 != SPI_processed &amp;&amp; NULL != SPI_tuptable) { TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc; bool isnull; HeapTuple tuple = SPI_tuptable-&gt;vals[0]; Datum dx, dy; uint64 zv = 0; dx = SPI_getbinval(tuple, tupdesc, 1, &amp;isnull); dy = SPI_getbinval(tuple, tupdesc, 2, &amp;isnull); zv = zcurve_fromXY(DatumGetInt64(dx), DatumGetInt64(dy)); // elog(INFO, "%ld %ld -&gt; %ld", DatumGetInt64(dx), DatumGetInt64(dy), zv); ctx-&gt;cur_val_ = zv; SPI_cursor_close(portal); return 1; } SPI_cursor_close(portal); } return 0; } int run_interval_request_ii(interval_ctx_t *ctx, uint64 v0, uint64 v1) { Datum values[2]; /* key types to prepare execution plan */ Portal portal; int cnt = 0, i; values[0] = Int64GetDatum(v0); values[1] = Int64GetDatum(v1); // elog(INFO, "[%ld %ld]", v0, v1); if (ctx-&gt;fl_) fprintf(ctx-&gt;fl_, "EXPLAIN (ANALYZE,BUFFERS) select * from test_points where zcurve_val_from_xy(x, y) between %ld and %ld;\n", v0, v1); portal = SPI_cursor_open(NULL, ctx-&gt;cr_, values, NULL, true); if (NULL == portal) /* internal error */ elog(ERROR, "check_primary_key: SPI_cursor_open"); for (;;) { SPI_cursor_fetch(portal, true, 8); if (0 == SPI_processed || NULL == SPI_tuptable) break; { TupleDesc tupdesc = SPI_tuptable-&gt;tupdesc; for (i = 0; i &lt; SPI_processed; i++) { HeapTuple tuple = SPI_tuptable-&gt;vals[i]; // elog(INFO, "%s, %s", SPI_getvalue(tuple, tupdesc, 1), SPI_getvalue(tuple, tupdesc, 2)); cnt++; } } } SPI_cursor_close(portal); return cnt; } PG_FUNCTION_INFO_V1(zcurve_oids_by_extent_ii); Datum zcurve_oids_by_extent_ii(PG_FUNCTION_ARGS) { uint64 x0 = PG_GETARG_INT64(0); uint64 y0 = PG_GETARG_INT64(1); uint64 x1 = PG_GETARG_INT64(2); uint64 y1 = PG_GETARG_INT64(3); uint64 *ids = NULL; int cnt = 0; int sz = 0, ix, iy; interval_ctx_t ctx; x0 = MIN(x0, s_maxx); y0 = MIN(y0, s_maxy); x1 = MIN(x1, s_maxx); y1 = MIN(y1, s_maxy); if (x0 &gt; x1) elog(ERROR, "xmin &gt; xmax"); if (y0 &gt; y1) elog(ERROR, "ymin &gt; ymax"); sz = (x1 - x0 + 1) * (y1 - y0 + 1); ids = (uint64*)palloc(sz * sizeof(uint64)); if (NULL == ids) /* internal error */ elog(ERROR, "can't alloc %d bytes in zcurve_oids_by_extent_ii", sz); for (ix = x0; ix &lt;= x1; ix++) for (iy = y0; iy &lt;= y1; iy++) { ids[cnt++] = zcurve_fromXY(ix, iy); } qsort (ids, sz, sizeof(*ids), compare_uint64); ctx.top_val_ = ids[sz - 1]; ctx.cur_val_ = 0; ctx.cr_ = NULL; ctx.probe_cr_ = NULL; ctx.fl_ = NULL;//fopen("/tmp/ttt.sql", "w"); cnt = 0; prep_interval_request_ii(&amp;ctx); { int cur_start = 0; int ix; for (ix = cur_start + 1; ix &lt; sz; ix++) { if (0 == probe_interval_request_ii(&amp;ctx, ids[cur_start])) break; for (; cur_start &lt; sz &amp;&amp; ids[cur_start] &lt; ctx.cur_val_; cur_start++); // if (ctx.cur_val_ != ids[cur_start]) // { // cur_start++; // continue; // } ix = cur_start + 1; if (ix &gt;= sz) break; for (; ix &lt; sz &amp;&amp; ids[ix] == ids[ix - 1] + 1; ix++); //elog(INFO, "%d %d %d", ix, cur_start, sz); cnt += run_interval_request_ii(&amp;ctx, ids[cur_start], ids[ix - 1]); cur_start = ix; } } if (ctx.fl_) fclose(ctx.fl_); fin_interval_request(NULL); pfree(ids); PG_RETURN_INT64(cnt); }</span></span></span></span></code> </pre></div></div><br>  I post it here, and not posted on github  The code is purely experimental and has no practical value. <br><br>  PPS: Thank you so much to the guys from <a href="http://postgrespro.ru/">PostgresPro</a> for leading me to this job. <br><br>  PPPS: continued <a href="https://habrahabr.ru/post/319810/">here</a> and <a href="https://habrahabr.ru/post/323192/">here</a> </div><p>Source: <a href="https://habr.com/ru/post/319096/">https://habr.com/ru/post/319096/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../319084/index.html">Google‚Äôs promises started to come true - now https sites are marked as trusted</a></li>
<li><a href="../319086/index.html">From nuclear power plants to data centers: a new trend in the world of telecommunications</a></li>
<li><a href="../319088/index.html">Darken an image in CollapsingToolbarLayout or Image Scrim</a></li>
<li><a href="../319092/index.html">Lebab is like Babel, just the opposite</a></li>
<li><a href="../319094/index.html">Another bike to fight callback hell in javascript</a></li>
<li><a href="../319100/index.html">Comparing objects by value - 6: Structure Equality Implementation</a></li>
<li><a href="../319104/index.html">3CX integration with amoCRM</a></li>
<li><a href="../319106/index.html">Is Nuklear the perfect GUI for micro projects?</a></li>
<li><a href="../319110/index.html">One Core API to edit Windows</a></li>
<li><a href="../319112/index.html">VZ7 vs VZ6: Is there a reason to be updated?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>