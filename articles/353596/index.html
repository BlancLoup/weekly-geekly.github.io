<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a game on Lua and L√ñVE - 7</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Table of contents  Table of contents 


- Article 1 Part 1. Game cycle Part 2. Libraries Part 3. Rooms and areas Part 4. Exercises 
- Part 1. Game cyc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a game on Lua and L√ñVE - 7</h1><div class="post__text post__text-html js-mediator-article"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/277/af4/cfe/277af4cfea1312469abb5cc1806a6a44.jpg" alt="image"></div><br><div class="spoiler">  <b class="spoiler_title">Table of contents</b> <div class="spoiler_text"><h2>  Table of contents </h2><br><ul><li>  <a href="https://habrahabr.ru/post/349276/">Article 1</a> <ul><li>  Part 1. Game cycle </li><li>  Part 2. Libraries </li><li>  Part 3. Rooms and areas </li><li>  Part 4. Exercises </li></ul></li><li>  <a href="https://habrahabr.ru/post/349440/">Article 2</a> <ul><li>  Part 5. Basics of the game </li><li>  Part 6. Basics of the Player Class </li></ul></li><li>  <a href="https://habrahabr.ru/post/349718/">Article 3</a> <ul><li>  Part 7. Player Parameters and Attacks </li><li>  Part 8. Enemies </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 4</a> <ul><li>  Part 9. Director and game cycle </li><li>  Part 10. Code Writing Practices </li><li>  Part 11. Passive skills </li></ul></li><li>  <a href="https://habrahabr.ru/post/350316/">Article 5</a> <ul><li>  Part 12. Other Passive Skills </li></ul></li><li>  <a href="https://habrahabr.ru/post/352896/">Article 6</a> <ul><li>  Part 13. The skill tree </li></ul></li><li>  <a href="https://habrahabr.ru/post/352896/">Article 7</a> <ul><li>  Part 14. Console </li><li>  Part 15. Final </li></ul></li></ul></div></div><br><h2>  Part 14: Console </h2><br><h2>  Introduction </h2><br>  In this part we will analyze the Console room.  The console is much easier to implement than anything else, because in the end it comes down to displaying text on the screen.  Here is what it looks like: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://github.com/SSYGEN/blog/raw/master/images/bytepath141.gif"></div></div></div><br>  The Console room will consist of three different types of objects: lines, input lines, and modules.  Lines are simply ordinary colored lines of text displayed on the screen.  For example, in the example shown above, ":: running BYTEPATH ..." will be a string.  From the point of view of the data structure, this will simply be a table storing the position of the line, its text and colors. <br><a name="habracut"></a><br>  Input lines are lines into which a player can enter something.  In the example shown above, these are the lines that contain the word "arch".  When you enter certain commands in the console, these commands will be executed and create new lines or modules.  From the point of view of data structure, input lines will look like simple lines, only with additional logic for reading input when the last line added to the room is an input line. <br><br>  Finally, a module is a special object that allows the player to perform more complex actions than simply entering commands.  This is a whole set of elements that appear when a player, for example, needs to choose a ship.  Such objects can be created by various teams, that is, for example, when a player wants to change the volume of a sound in a game, he must enter ‚Äúvolume‚Äù, after which the Volume module will open, in which you can select the volume level.  All of these modules themselves will also be objects, and the Console room will handle their creation and deletion accordingly. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  Strings </h2><br>  Let's start with the lines.  We can define a string like this: <br><br><pre><code class="lua hljs">{ x = x, y = y, text = love.graphics.newText(font, {boost_color, <span class="hljs-string"><span class="hljs-string">'blue text'</span></span>, default_color, <span class="hljs-string"><span class="hljs-string">'white text'</span></span>} }</code> </pre> <br>  That is, it has the position <code>x, y</code> , as well as the <code>text</code> attribute.  This text attribute is a <a href="https://love2d.org/wiki/Text" rel="nofollow">Text</a> object.  We will use Text objects from L√ñVE, because with their help you can easily define colored text.  But before we can add lines to the Console room, we need to create it, so let's get this done.  Basically, this task is similar to creating a SkillTree room. <br><br>  We will add a table of <code>lines</code> in which all text lines will be stored, and then in the draw function we will go around the entire table and draw each line.  We will also add the <code>addLine</code> function, which will add a new text line to the <code>lines</code> table: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span> = {} self.line_y = <span class="hljs-number"><span class="hljs-number">8</span></span> camera:lookAt(gw/<span class="hljs-number"><span class="hljs-number">2</span></span>, gh/<span class="hljs-number"><span class="hljs-number">2</span></span>) self:addLine(<span class="hljs-number"><span class="hljs-number">1</span></span>, {<span class="hljs-string"><span class="hljs-string">'test'</span></span>, boost_color, <span class="hljs-string"><span class="hljs-string">' test'</span></span>}) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, line <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> love.graphics.draw(line.text, line.x, line.y) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:addLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delay, text)</span></span></span></span> self.timer:after(delay, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>, {x = <span class="hljs-number"><span class="hljs-number">8</span></span>, y = self.line_y, text = love.graphics.newText(self.font, text)}) self.line_y = self.line_y + <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Something else is happening here.  First, there is a <code>line_y</code> attribute that tracks the position of y, in which we must add the following line.  It is incremented by 12 each time you call <code>addLine</code> , because we want new lines to be added under the previous one, as it happens in normal terminals. <br><br>  In addition, the <code>addLine</code> function has a delay.  This delay is useful because when adding multiple lines to the console, we do not want them added at the same time.  We want a slight delay before each addition, because everything looks better this way.  In addition, we can do here so that, together with the delay in adding each line, it is added character by character.  That is, instead of one line added at a time, each character is added with a slight delay, which will give us an even more pleasant effect.  To save time, I will not do it myself, but it can be a good exercise for you (and we already have some logic for this in the InfoText object). <br><br>  All this should look like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b97/b99/e0a/b97b99e0a8025df35e25e0075b11e4c2.png"></div><br>  And if we add a few lines, it will look like it should: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6eb/814/4bd/6eb8144bd77afc159ede6e6006ccadbb.png"></div><br><h2>  Input lines </h2><br>  The input lines are a little more complicated, but just a little bit.  The first thing we want is to add the <code>addInputLine</code> function, which will behave as <code>addLine</code> , except that it will add text to the input line and include the ability for the player to enter text.  By default, we will use the text of the <code>[root]arch~</code> input line, placed before the input, as in a normal terminal. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:addInputLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(delay)</span></span></span></span> self.timer:after(delay, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>, {x = <span class="hljs-number"><span class="hljs-number">8</span></span>, y = self.line_y, text = love.graphics.newText(self.font, self.base_input_text)}) self.line_y = self.line_y + <span class="hljs-number"><span class="hljs-number">12</span></span> self.inputting = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And <code>base_input_text</code> looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.base_input_text = {<span class="hljs-string"><span class="hljs-string">'['</span></span>, skill_point_color, <span class="hljs-string"><span class="hljs-string">'root'</span></span>, default_color, <span class="hljs-string"><span class="hljs-string">']arch~ '</span></span>} ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Also, when adding a new input line, we set <code>inputting</code> to true.  This boolean value will be used to tell us whether we should read keyboard input.  If so, we can simply add to the list as a string all the characters that the player enters, and then add this string to our Text object.  It looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:textinput</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.inputting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.input_text, t) self:updateText() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:updateText</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> base_input_text = <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.copy(self.base_input_text) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> input_text = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.input_text) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> input_text = input_text .. character <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(base_input_text, input_text) self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>[#self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>].text:set(base_input_text) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And the <code>Console:textinput</code> will be called at every call of <code>love.textinput</code> , which happens every time a player <code>love.textinput</code> key: <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- in main.lua function love.textinput(t) if current_room.textinput then current_room:textinput(t) end end</span></span></code> </pre> <br>  The last thing we need to do is make the Enter and Backspace keys work.  The Enter key will assign the <code>inputting</code> value to false, get the contents of the <code>input_text</code> table and do something with it.  That is, if a player has entered ‚Äúhelp‚Äù and then pressed Enter, we will launch the help command.  And the backspace key should simply remove the last element from the <code>input_text</code> table: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.inputting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:pressed(<span class="hljs-string"><span class="hljs-string">'return'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.inputting = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Run command based on the contents of input_text here self.input_text = {} end if input:pressRepeat('backspace', 0.02, 0.2) then table.remove(self.input_text, #self.input_text) self:updateText() end end end</span></span></code> </pre> <br>  Finally, we can also simulate the pleasant effect of a flashing cursor.  The easiest way to do this is to simply draw a flashing cursor at a position after the width of <code>base_input_text</code> , concatenated with the contents of <code>input_text</code> . <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.cursor_visible = <span class="hljs-literal"><span class="hljs-literal">true</span></span> self.timer:every(<span class="hljs-string"><span class="hljs-string">'cursor'</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.cursor_visible = <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.cursor_visible <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Thus, we implement the blinking by drawing a rectangle only when <br>  <code>cursor_visible</code> is true.  Next we draw a rectangle: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.inputting <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> self.cursor_visible <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r, g, b = <span class="hljs-built_in"><span class="hljs-built_in">unpack</span></span>(default_color) love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">96</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> input_text = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.input_text) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> input_text = input_text .. character <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> x = <span class="hljs-number"><span class="hljs-number">8</span></span> + self.font:getWidth(<span class="hljs-string"><span class="hljs-string">'[root]arch~ '</span></span> .. input_text) love.graphics.rectangle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, x, self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>[#self.<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>].y, self.font:getWidth(<span class="hljs-string"><span class="hljs-string">'w'</span></span>), self.font:getHeight()) love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here, the variable <code>x</code> stores the position of the cursor.  We add 8 to it, because each line is drawn by default, starting at position 8, so if we do not take this into account, the position of the cursor will be incorrect.  We will also assume that the width of the cursor rectangle will be equal to the width of the letter 'w' of the current font.  Usually w is the widest letter, so we chose it.  But it can be any constant number, for example 10 or 8. <br><br>  And all this will look like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c4e/e85/ff8/c4ee85ff868cbd389a1cbca39535678a.gif"></div></div></div><br><h2>  Modules </h2><br>  Modules are objects.  which contain logic that allows the player to do something in the console.  For example, <code>ResolutionModule</code> , which we implement, will allow the player to change the resolution in the game.  We will separate the modules from the rest of the Console room code, because their logic can be quite complex, and it makes sense to separate them into separate objects.  We implement a module that looks like this: <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/7bb/c0f/62a7bbc0f38241fd0397910e94631d2a.gif"></div></div></div><br>  This module is created and added when the player presses Enter after entering the ‚Äúresolution‚Äù command in the input line.  After activating the module, it takes control from the console and adds several lines to it using the <code>Console:addLine</code> .  In addition to these added lines, it has a selection logic that allows you to select the desired resolution.  After selecting the resolution and clicking on the Enter window changes to reflect this new resolution, we add a new input line using the <code>Console:addInputLine</code> and disable the option to select ResolutionModule in this object, returning control to the console. <br><br>  All modules will work in much the same way.  They are created / added, perform their functions, taking control from the Console room, and then, after their behavior is completed, they return control to the console.  We can implement the fundamentals of the modules in the Console object as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... self.modules = {} ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> self.timer:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, module <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.modules) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> module:update(dt) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.inputting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, module <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.modules) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> module:draw() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> camera:detach() ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Since we write code only for ourselves, here we can skip some formalities.  Although just said that we will have some rule / interface between the Console object <br>  and Module objects, through which they will transfer player input control to each other, in fact, we will simply add modules to the <code>self.modules</code> table, update and draw them.  At the appropriate time, each module will activate / deactivate itself, that is, on the part of the Console, we do not need to do almost anything. <br><br>  Now let's look at creating the ResolutionModule: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Console:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.inputting <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:pressed(<span class="hljs-string"><span class="hljs-string">'return'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.line_y = self.line_y + <span class="hljs-number"><span class="hljs-number">12</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> input_text = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, character <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.input_text) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> input_text = input_text .. character <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> self.input_text = {} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> input_text == <span class="hljs-string"><span class="hljs-string">'resolution'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">insert</span></span>(self.modules, ResolutionModule(self, self.line_y)) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  Here we make it so that the <code>input_text</code> variable will store what the player entered in the input line, and then, if this text is ‚Äúresolution‚Äù, we create a new ResolutionModule object and add it to the <code>modules</code> list.  Most modules will need a link to the console, as well as the current position of y, to which the lines are added, so the module will be located under the lines of code already present in the console.  To do this, when creating a new module object, we pass <code>self</code> and <code>self.line_y</code> . <br><br>  The implementation of the ResolutionModule itself is quite simple.  For it, we just need to add a few lines, as well as a small amount of logic from a choice of several lines.  To add rows, we simply do the following: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolutionModule:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(console, y)</span></span></span></span> self.console = console self.y = y self.console:addLine(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-string"><span class="hljs-string">'Available resolutions: '</span></span>) self.console:addLine(<span class="hljs-number"><span class="hljs-number">0.04</span></span>, <span class="hljs-string"><span class="hljs-string">' 480x270'</span></span>) self.console:addLine(<span class="hljs-number"><span class="hljs-number">0.06</span></span>, <span class="hljs-string"><span class="hljs-string">' 960x540'</span></span>) self.console:addLine(<span class="hljs-number"><span class="hljs-number">0.08</span></span>, <span class="hljs-string"><span class="hljs-string">' 1440x810'</span></span>) self.console:addLine(<span class="hljs-number"><span class="hljs-number">0.10</span></span>, <span class="hljs-string"><span class="hljs-string">' 1920x1080'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  To simplify our work, we will make sure that all available permissions are multiples of the base resolution, so we just need to add these four lines. <br><br>  After that we have to add the logic of choice.  The selection logic is similar to hack, but it works well: we simply place a rectangle on top of the currently selected row and move this rectangle when the player presses the up and down keys.  We will need a variable to track the line in which we are (1 through 4), and we will draw this rectangle in the corresponding position y based on this variable.  It all looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolutionModule:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(console, y)</span></span></span></span> ... self.selection_index = sx self.selection_widths = { self.console.font:getWidth(<span class="hljs-string"><span class="hljs-string">'480x270'</span></span>), self.console.font:getWidth(<span class="hljs-string"><span class="hljs-string">'960x540'</span></span>), self.console.font:getWidth(<span class="hljs-string"><span class="hljs-string">'1440x810'</span></span>), self.console.font:getWidth(<span class="hljs-string"><span class="hljs-string">'1920x1080'</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The variable <code>selection_index</code> keeps track of the current selection, and initially it is equal to <code>sx</code> .  <code>sx</code> can be 1, 2, 3 or 4, depending on the size selected by <code>main.lua</code> when calling the <code>resize</code> function.  <code>selection_widths</code> stores the widths of the rectangle in each selection line.  Since the rectangle should close each resolution, we need to determine its size based on the size of the characters that make up the string of this resolution. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolutionModule:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:pressed(<span class="hljs-string"><span class="hljs-string">'up'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.selection_index = self.selection_index - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.selection_index &lt; <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.selection_index = #self.selection_widths <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:pressed(<span class="hljs-string"><span class="hljs-string">'down'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.selection_index = self.selection_index + <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self.selection_index &gt; #self.selection_widths <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.selection_index = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  In the update function, we process the logic of the player pressing "up" and "down."  We just need to increase or decrease the <code>selection_index</code> so that the value is not less than 1 and not more than 4. <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolutionModule:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> width = self.selection_widths[self.selection_index] <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> r, g, b = <span class="hljs-built_in"><span class="hljs-built_in">unpack</span></span>(default_color) love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">96</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> x_offset = self.console.font:getWidth(<span class="hljs-string"><span class="hljs-string">' '</span></span>) love.graphics.rectangle(<span class="hljs-string"><span class="hljs-string">'fill'</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span> + x_offset - <span class="hljs-number"><span class="hljs-number">2</span></span>, self.y + self.selection_index*<span class="hljs-number"><span class="hljs-number">12</span></span>, width + <span class="hljs-number"><span class="hljs-number">4</span></span>, self.console.font:getHeight()) love.graphics.setColor(r, g, b, <span class="hljs-number"><span class="hljs-number">255</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  And in the draw function, we simply draw a rectangle in the appropriate position.  The code looks terrible again and there are a lot of strange numbers in it, but we need to position the rectangle in the right place, and there are no ‚Äúclean‚Äù methods for that. <br><br>  Now we need only to make the object read input only when it is active, and that it is active only immediately after its creation and before the player presses Enter to select a resolution.  After clicking on Enter, it should become inactive and no longer read input.  The easiest way to do this is as follows: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolutionModule:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(console, y)</span></span></span></span> ... self.console.timer:after(<span class="hljs-number"><span class="hljs-number">0.02</span></span> + self.selection_index*<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> self.active = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolutionModule:update</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(dt)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">input</span></span>:pressed(<span class="hljs-string"><span class="hljs-string">'return'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> self.active = <span class="hljs-literal"><span class="hljs-literal">false</span></span> resize(self.selection_index) self.console:addLine(<span class="hljs-number"><span class="hljs-number">0.02</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) self.console:addInputLine(<span class="hljs-number"><span class="hljs-number">0.04</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ResolutionModule:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.active <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>  The variable <code>active</code> to true several frames after the module is created.  Due to this, the rectangle will not be drawn before adding rows, because the rows are added with a slight delay.  If the <code>active</code> variable is not active, then the update and draw functions will not be executed, that is, we will not read the input for this object and draw the selection rectangle.  In addition, when you press Enter, we assign <code>active</code> to false, call the <code>resize</code> function, and then transfer control back to the Console, adding a new input line.  All this gives us the appropriate behavior and because of this, everything will work as it should. <br><br><h3>  Exercises </h3><br>  <strong>227. (CONTENT)</strong> Make it so that when the Console room has more lines than can fit on the screen, the camera will go down when adding lines and modules. <br><br>  <strong>228. (CONTENT)</strong> Implement the <code>AchievementsModule</code> module.  It shows all the achievements and requirements necessary to unlock them.  We will look at achievements in the next part of the tutorial, so go back to this exercise later! <br><br>  <strong>229. (CONTENT)</strong> Implement the module <code>ClearModule</code> .  This module allows you to delete all saved data or clear the skill tree.  Saving / loading data will also be discussed in the next article, so you can also return to this exercise later. <br><br>  <strong>230. (CONTENT)</strong> Implement the module <code>ChooseShipModule</code> .  This module allows the player to select and unlock ships for gameplay. <br><br>  <strong>231. (CONTENT)</strong> Implement the HelpModule module.  It displays all available commands and allows the player to select a team without entering text.  The gamepad will be supported in the game, so forcing players to enter something is not very good. <br><br>  <strong>232. (CONTENT)</strong> Implement the VolumeModule module.  It allows the player to choose the volume of sound effects and music. <br><br>  <strong>233. (CONTENT)</strong> Implement the commands <code>mute</code> , <code>skills</code> , <code>start</code> , <code>exit</code> and <code>device</code> .  <code>mute</code> mutes all sounds.  <code>skills</code> makes the transition to the room SkillTree.  <code>start</code> creates a ChooseShipModule, and then starts the game after the player selects the ship.  <code>exit</code> exits the game. <br><br><h2>  END </h2><br>  And on this we are done with the console.  With just three concepts (lines, lines of input and modules) we can do a lot and add salt to the gameplay.  The next part will be the last, in it we will consider various aspects that have not approached any of the previous parts. <br><br><h2>  Part 15: Final </h2><br><h2>  Introduction </h2><br>  In this last part we will talk about some topics that are not combined with any of the previous parts, but are necessary for the finished game.  We will cover the following topics: saving and loading data, achievements, shaders and sound. <br><br><h3>  Save and Load </h3><br>  Since this game does not require to save any data levels, saving and loading become very simple operations.  For them we will use the <a href="https://github.com/gvx/bitser/">bitser</a> library and its two functions: <a href=""><code>dumpLoveFile</code></a> and <a href=""><code>loadLoveFile</code></a> .  These functions will save and load any data to / from the file that we pass to them using the <a href="https://love2d.org/wiki/love.filesystem" rel="nofollow"><code>love.filesystem</code></a> .  As they say on the link, the location of saving files depends on the operating system.  In Windows, the file will be saved in <code>C:\Users\user\AppData\Roaming\LOVE</code> .  To change the save location, we can use <a href="https://love2d.org/wiki/love.filesystem.setIdentity" rel="nofollow"><code>love.filesystem.setIdentity</code></a> .  If we change the value to <code>BYTEPATH</code> , the save file will be saved to <code>C:\Users\user\AppData\Roaming\BYTEPATH</code> . <br><br>  Anyway, we need only two functions: <code>save</code> and <code>load</code> .  They will be defined in <code>main.lua</code> .  Let's start with the save function: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> save_data = {} <span class="hljs-comment"><span class="hljs-comment">-- Set all save data here bitser.dumpLoveFile('save', save_data) end</span></span></code> </pre> <br>  The save function is quite simple.  We will create a new <code>save_data</code> table and put all the data we need to save into it.  For example, if we want to save the amount of skill points a player has, then we simply write <code>save_data.skill_points = skill_points</code> , that is, the value contained in the global variable <code>skill_points</code> will be stored in <code>skill_points</code> .  The same applies to all other types of data.  However, it is important to limit yourself to storing values ‚Äã‚Äãand tables of values.  Saving objects as a whole, images, and other types of more complex data will most likely not work. <br><br>  After adding everything we want to save to <code>save_data</code> , we simply call <code>bitser.dumpLoveFile</code> and save all this data to the <code>'save'</code> file.  When in <code>C:\Users\user\AppData\Roaming\BYTEPATH</code> a <code>save</code> file is created, and when this file exists, all the information we need to save will be saved there.  We can call this function when you close the game or at the end of a round, this is up to you.  The only problem I can see here is that if you save only at the end of the game in the event of a program crash, the player‚Äôs progress will most likely not be saved. <br><br>  We now turn to the download function: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> love.filesystem.exists(<span class="hljs-string"><span class="hljs-string">'save'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> save_data = bitser.loadLoveFile(<span class="hljs-string"><span class="hljs-string">'save'</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- Load all saved data here else first_run_ever = true end end</span></span></code> </pre> <br>  The download function works in a similar way, but in the opposite direction.  We call <code>bitser.loadLoveFile</code> with the name of the saved file ( <code>save</code> ), and then put all the data inside the local table <code>save_data</code> .  By writing all the saved data to this table, we can assign them to the corresponding variables.  For example, if we want to load player skill points, we will write <code>skill_points = save_data.skill_points</code> , that is, we assign the saved skill points to our global skill points variable. <br><br>  In addition, additional logic is required for proper operation of the load function.  If the player starts the game for the first time, the save file does not exist yet, that is, when you try to load it, the program will fall out.  To fix this error, we need to check if the file exists using <a href="https://love2d.org/wiki/love.filesystem.exists" rel="nofollow"><code>love.filesystem.exists</code></a> and load it only if it exists.  If not, then we simply set the global variable <code>first_run_ever</code> to true.  This variable is useful because usually when you first start the game, we need to perform some additional actions, such as starting a tutorial or displaying a message.  The download function will be called once in <code>love.load</code> when loading the game.  It is important that this function be called after the <code>globals.lua</code> file, because in it we rewrite the global variables. <br><br>  And on this with saving / loading we finished.  What we actually need to save and load will be left as an exercise, because it depends on the realizable aspects you choose.  For example, if you implement the skill tree exactly as in part 13, then you will most likely need to save the <code>bought_node_indexes</code> table, because it stores all the nodes the player has bought. <br><br><h3>  Progress </h3><br>  Because of the simplicity of the game, achievement is also very easy to implement (at least in comparison with everything else).  We will have a regular global table called <code>achievements</code> .  And this table will contain the keys that represent the name of the achievement, and the values ‚Äã‚Äãthat determine whether the achievement is unlocked. ,      <code>'50K'</code> , ,      50 000 ,     , <code>achievements['50K']</code>    true,     ‚Äî false. <br><br>    ,   ,    <code>10K Fighter</code> , ,    10 000    Fighter.   ,    <code>achievements['10K Fighter']</code>  true,   ,    10K,     Fighter.  It looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> timer:after(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> gotoRoom(<span class="hljs-string"><span class="hljs-string">'Stage'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> achievements[<span class="hljs-string"><span class="hljs-string">'10K Fighter'</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> score &gt;= <span class="hljs-number"><span class="hljs-number">10000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> device = <span class="hljs-string"><span class="hljs-string">'Fighter'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> achievements[<span class="hljs-string"><span class="hljs-string">'10K Fighter'</span></span>] = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-comment"><span class="hljs-comment">-- Do whatever else that should be done when an achievement is unlocked end end) end</span></span></code> </pre> <br>   ,   . ,    ‚Äî  ,       ,    ,  ,     .  ,   . <br><br>         Steam,  ,     -        .   ,       ,  ,   <code>achievements['10K Fighter']</code>  true.    ,      ,      <code>save</code>  <code>load</code>  . <br><br><h3>  </h3><br>        ,    .       ¬´¬ª,       ,    ,      .  ,             ,      ,  ,    .     , ,     ,        ,     . <br><br>     RGB-        .  ,     :   - ,        ,   .       <a href="https://love2d.org/wiki/Shader" rel="nofollow"></a> . <br><br>   ,           ,   ,        .  -  (     ,     ),           ,   ..          ,  RGB-        ,    ,      .          ,     ,       ,     . <br><br>    ,     ,       X,   ,         .   ,      ,      .   ,      (,  2,5D-   )     ,      . <br><br><h4> rgb_shift.frag </h4><br> ,      ,       ,     : <br><br><pre> <code class="lua hljs">extern vec2 amount; vec4 effect(vec4 color, Image texture, vec2 tc, vec2 pc) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color*vec4(Texel(texture, tc - amount).r, Texel(texture, tc).g, Texel(texture, tc + amount).b, Texel(texture, tc).a); }</code> </pre> <br>      <code>rgb_shift.frag</code>   <code>resources/shaders</code> ,      <code>Stage</code>   <a href="https://love2d.org/wiki/love.graphics.newShader" rel="nofollow"><code>love.graphics.newShader</code></a> .       ‚Äî   <code>effect</code> .     <code>color</code> ,    <code>love.graphics.setColor</code> ,    0-255     0-1.        255, 255, 255, 255,   vec4    1.0, 1.0, 1.0, 1.0.    <code>texture</code> ,    .     ,     L√ñVE,   .                   <code>effect</code> ,     .      vec4,  4 ‚Äî   , ,   -. <br><br>   <code>tc</code>   .       0  1        .    ‚Äî  <code>0, 0</code> ,    ‚Äî <code>1, 1</code> .        <a href="http://www.shaderific.com/glsl-functions/" rel="nofollow"><code>texture2D</code></a> (  L√ñVE  <code>Texel</code> )     .   <code>pc</code>       .       . <br><br> , ,          ‚Äî       ,     .       vec2 <code>amount</code> ,      RGB-.       <a href="https://love2d.org/wiki/Shader:send" rel="nofollow"><code>send</code></a> . <br><br>  ,    ,  : <br><br><pre> <code class="lua hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color*vec4( Texel(texture, tc - amount).r, Texel(texture, tc).g, Texel(texture, tc + amount).b, Texel(texture, tc).a);</code> </pre> <br>     <code>Texel</code>   .          ,       ,     RGB-.       (     )   ,    ¬´¬ª  .          <code>tc - amount</code>  <code>tc + amount</code> ,              ,    .       ,        (   -),         . <br><br><h4>   </h4><br>            ,        .    ,    ,      <code>Area</code>   <code>draw</code> ,        .    : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrailParticle:new</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(area, x, y, opts)</span></span></span></span> TrailParticle.super.new(self, area, x, y, opts) self.graphics_types = {<span class="hljs-string"><span class="hljs-string">'rgb_shift'</span></span>} ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>     draw,        ,  : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:drawOnly</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(types)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(self.game_objects, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a.depth == b.depth <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.creation_time &lt; b.creation_time <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.depth &lt; b.depth <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, game_object <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.game_objects) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> game_object.graphics_types <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #fn.intersection(types, game_object.graphics_types) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> game_object:draw() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>     ,    <code>Area:draw</code> ,    .   <a href=""><code>intersection</code></a> ,  ,        <code>graphics_types</code>  <code>types</code> . ,   ,       <code>rgb_shift</code> ,    <code>area:drawOnly({'rgb_shift'})</code> ,         <code>graphics_types</code>  .     -  ,  <code>#fn.intersection</code>   ,      . <br><br>       <code>Area:drawExcept</code> ,  ,      ,      ,    -         .  It looks like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Area:drawExcept</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(types)</span></span></span></span> <span class="hljs-built_in"><span class="hljs-built_in">table</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">sort</span></span>(self.game_objects, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a, b)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a.depth == b.depth <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.creation_time &lt; b.creation_time <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a.depth &lt; b.depth <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, game_object <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ipairs</span></span>(self.game_objects) <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> game_object.graphics_types <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> game_object:draw() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> #fn.intersection(types, game_object.graphics_types) == <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> game_object:draw() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>    ,      <code>graphics_types</code> ,        <code>types</code>  0,          ,    . <br><br><h4>  +  </h4><br>          .        <code>TrailParticle</code> ,   RGB-        .  ,     RGB-    TrailParticle,  : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... love.graphics.setCanvas(self.rgb_shift_canvas) love.graphics.clear() camera:attach(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, gw, gh) self.area:drawOnly({<span class="hljs-string"><span class="hljs-string">'rgb_shift'</span></span>}) camera:detach() love.graphics.setCanvas() ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>     ,      ,      <code>main_canvas</code>     <code>rgb_shift_canvas</code> . ,   ,       <code>'rgb_shift'</code> .  ,         ,        .        <a href="http://kpulv.com/309/Dev_Log__Shader_Follow_Up/" rel="nofollow"><code>Shockwave</code></a>  <a href="https://github.com/SSYGEN/blog/issues/9"><code>Downwell</code></a> . <br><br>      ,       <code>main_canvas</code> ,   ,     .  It will look like this: <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... love.graphics.setCanvas(self.main_canvas) love.graphics.clear() camera:attach(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, gw, gh) self.area:drawExcept({<span class="hljs-string"><span class="hljs-string">'rgb_shift'</span></span>}) camera:detach() love.graphics.setCanvas() ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>        .   ,  <code>rgb_shift_canvas</code>      <code>final_canvas</code> ,        RGB-.    : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... love.graphics.setCanvas(self.final_canvas) love.graphics.clear() love.graphics.setColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>) love.graphics.setBlendMode(<span class="hljs-string"><span class="hljs-string">"alpha"</span></span>, <span class="hljs-string"><span class="hljs-string">"premultiplied"</span></span>) self.rgb_shift:send(<span class="hljs-string"><span class="hljs-string">'amount'</span></span>, { <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(-self.rgb_shift_mag, self.rgb_shift_mag)/gw, <span class="hljs-built_in"><span class="hljs-built_in">random</span></span>(-self.rgb_shift_mag, self.rgb_shift_mag)/gh}) love.graphics.setShader(self.rgb_shift) love.graphics.draw(self.rgb_shift_canvas, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) love.graphics.setShader() love.graphics.draw(self.main_canvas, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) love.graphics.setBlendMode(<span class="hljs-string"><span class="hljs-string">"alpha"</span></span>) love.graphics.setCanvas() ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>    <code>send</code>      <code>amount</code> ,     ,    .             0  1,       <code>gw</code>  <code>gh</code> .  ,  , ,     2 ,  <code>rgb_shift_mag</code>   2,      2/gw b 2/gh,     2  /    ,   2.      main   final,    final   ,    . <br><br> ,        final  : <br><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stage:draw</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> ... love.graphics.setColor(<span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>) love.graphics.setBlendMode(<span class="hljs-string"><span class="hljs-string">"alpha"</span></span>, <span class="hljs-string"><span class="hljs-string">"premultiplied"</span></span>) love.graphics.draw(self.final_canvas, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, sx, sy) love.graphics.setBlendMode(<span class="hljs-string"><span class="hljs-string">"alpha"</span></span>) love.graphics.setShader() <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>        ,     <code>final_canvas</code> ,            ,  <a href="https://www.shadertoy.com/view/ldXGW4" rel="nofollow"><code>distortion</code></a> ,    ,       . <br><br>        : <br><br><div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f3e/a4c/f2b/f3ea4cf2bac6b48967282098e9013380.gif"></div></div></div><br>   , RGB-     ,     ¬´¬ª . <br><br><h3>  </h3><br>      ,           ,    ,  ,        .       <a href="https://github.com/tesselode/ripple">ripple</a> . <br><br>      API           <code>ripple.newSound</code>     <code>:play</code>   . ,      ,   ,     : <br><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- in globals.lua shoot_sound = ripple.newSound('resources/sounds/shoot.ogg')</span></span></code> </pre> <br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Player:shoot</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> d = <span class="hljs-number"><span class="hljs-number">1.2</span></span>*self.w self.area:addGameObject(<span class="hljs-string"><span class="hljs-string">'ShootEffect'</span></span>, ... shoot_sound:play() ... <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br>        <code>:play</code> ,  ,   .       , ,   ,   ,          ,   .        ,       .    ,       <code>sound.lua</code> . <br><br><h2>  </h2><br>      .      ,      ,      .     ,        ,    ,      ,    ,   . <br><br> ,          ,               .             ,    ,          ¬´  ¬ª.          ,      .      ¬´¬ª,      1-5. <br><br><hr><br>      ,        -   : <br><br><ul><li> <a href="http://store.steampowered.com/app/760330/BYTEPATH/" rel="nofollow"> BYTEPATH  Steam</a> </li><li> <a href="https://ssygen.itch.io/bytepath-tutorial" rel="nofollow">  BYTEPATH  itch.io</a> </li></ul><br>    itch.io,        ,       1-9,  ,     (   ,       )      Steam. </div><p>Source: <a href="https://habr.com/ru/post/353596/">https://habr.com/ru/post/353596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353584/index.html">Thunkable X - free browser-based mobile development environment for iOS and Android</a></li>
<li><a href="../353586/index.html">How to sign a message using Java GOST R 34.11 / 34.10-2001 algorithm</a></li>
<li><a href="../353590/index.html">Control of complexity and architecture of UDF</a></li>
<li><a href="../353592/index.html">Online course on iOS development for beginners from Redmadrobot and Contented</a></li>
<li><a href="../353594/index.html">Meat grinder, super-robots and scientific research institutes (Not Artificial Intelligence)</a></li>
<li><a href="../353600/index.html">Digital events in Moscow from 16 to 22 April</a></li>
<li><a href="../353602/index.html">The perfect way to offline from online</a></li>
<li><a href="../353604/index.html">Synergistic organizations and Pokupo. How do we work and where does Ethereum?</a></li>
<li><a href="../353606/index.html">DotVVM - First Look</a></li>
<li><a href="../353608/index.html">Sberbank's Dao Integration: From Local Area Networks to Kafka and Streaming Development</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>