<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Global lighting using voxel cone tracing</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will talk about the implementation of one of the algorithms for calculating the global (re-reflected / ambient) lighting used in som...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Global lighting using voxel cone tracing</h1><div class="post__text post__text-html js-mediator-article">  In this article I will talk about the implementation of one of the algorithms for calculating the global (re-reflected / ambient) lighting used in some games and other products - Voxel Cone Tracing (VCT).  Perhaps someone read an old <a href="http://research.nvidia.com/sites/default/files/publications/GIVoxels-pg2011-authors.pdf">article</a> ([VCT]) of 2011 or watched a <a href="https://www.youtube.com/watch%3Fv%3DfAsg_xNzhcQ">video</a> .  But the article does not give exhaustive answers to the questions of how to implement a particular stage of the algorithm. <br><br><img src="https://habrastorage.org/webt/do/xf/ku/doxfkuomv9hf057k6gzpg_bbyd4.png" width="370"><img src="https://habrastorage.org/webt/ni/sb/gx/nisbgxdludojmoycwu_6zjjfp94.png" width="370"><br>  <i>Render scenes without global illumination, and using VCT:</i> <br><a name="habracut"></a><br>  First of all, it is worth saying that the implementation of global illumination using environment maps (PMREM / IBL) is cheaper than VCT.  For example, one of the developers of UE4 told in a <a href="https://youtu.be/bzHevRs-cd4%3Ft%3D5645">podcast</a> (1:34:05 - 1:37:50) that they rendered a demo using VCT, and then using environment maps, and the picture was about the same.  However, research is being conducted under this approach.  His ideas, for example, are based on Nvidia‚Äôs modern VXGI. <br><br>  While working, I relied on a bunch of sources that can be found at the end of the article. <br>  To simplify the task, the implementation takes into account only diffuse illumination (Labmert model), but it is argued that this algorithm is suitable for many other BRDF.  Also, the implementation does not take into account the dynamic objects of the scene. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      I will describe the implementation in terms of DirectX, but this algorithm can also be implemented on OpenGL.  Some DX 11.1 chips are used in this work (for example, using a UAV in a vertex shader), but you can do without them, thereby lowering the minimum system requirements for this algorithm. <br><br>  For a better understanding of the operation of the algorithm, we describe its general stages, and then we detail each of them.  The most common parts of the algorithm are: <br><br><ol><li>  <b>Scene voxelization</b> .  We rasterize the scene into a set of voxels containing material properties (for example, color) and surface normals. <br><br><img src="https://habrastorage.org/webt/ph/2h/vu/ph2hvu9ipi3w1qejvhjfx-6jmdk.png" width="370"><img src="https://habrastorage.org/webt/av/dv/r2/avdvr25o1jmpjrwh8vqdtziy7se.png" width="370"></li><li>  <b>Baking reflected lighting</b> .  For voxels, incoming or outgoing radiation from light sources is calculated, and the result is recorded in a 3D texture. <br><br><img src="https://habrastorage.org/webt/sp/ps/ae/sppsaet4gpibjrhjuoyw24fsyay.png" width="370"><img src="https://habrastorage.org/webt/oa/2e/t1/oa2et1hc3eol3yrmm4vvrxmkctu.png" width="370"></li><li>  <b>Trace cones</b> .  For each calculated surface pixel, a group of cones is created.  A cone is an abstraction that imitates a group of rays emitted to capture radiation from various mips of a 3D lighting texture.  The end result is weighted averaged and stacked with the main light. <br><br><img src="https://habrastorage.org/webt/hd/tu/q1/hdtuq143ovkt67za5y-09pxattw.png" width="370"><img src="https://habrastorage.org/webt/dq/-q/zy/dq-qzycuif4dsfmeevyltf23pv8.png" width="370"></li></ol><br>  These stages can have several conceptual variants of implementations or contain additional optimizations.  I want to show in a general form how this can be done. <br><br>  To begin with, we will define the storage structure of the voxelized scene.  You can voxelize all objects in a 3D texture.  The disadvantage of this solution is non-optimal memory consumption, because most of the scene is empty space.  For voxelization with a resolution of 256x256x256 of the format R8G8B8A8, this texture will take 64 MB, and this is without taking into account the MIPs.  Such textures are required for color and normal surfaces, as well as for baked lighting. <br><br>  Data optimization algorithms are used to optimize memory consumption.  In our implementation, we will use Sparse Voxel Octree (SVO), as in the original article.  But there are other algorithms, for example, 3D Clipmap [S4552]. <br><br>  SVO is a sparse octree scene.  Each node of such a tree divides the scene's subspace into 8 equal parts.  A sparse tree does not store information about a space that is not occupied by anything.  We will use this structure to search for voxels by their coordinates in space, as well as to sample baked lighting.  Baked lighting will be stored in a special 3D-texture - block buffer, which will be discussed below. <br><br>  Consider each of the stages of the algorithm separately. <br><br><h2>  Voxelization scene </h2><br><img src="https://habrastorage.org/webt/7x/mh/ci/7xmhcikd5lnuria3k9xp1fju42i.png"><br><br>  The voxelized scene will be stored as an array of voxels.  On the GPU, this array is implemented through StructuredBuffer / RWStructuredBuffer.  The voxel structure will be as follows: <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Voxel { <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> position; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> color; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> normal; <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> pad; <span class="hljs-comment"><span class="hljs-comment">// 128 bits aligment };</span></span></code> </pre> <br>  For compact scene storage, we use SVO.  The tree will be stored in a 2D texture format R32_UINT.  Tree node structure: <br><br><img src="https://habrastorage.org/webt/9l/_l/xv/9l_lxveo4xk3ngddgle8bfbi0ze.png"><br>  <i>Schematic representation of the nodes SVO [DP]</i> <br><br>  In the leaves of SVO, the indices of the corresponding voxels from this array will be stored at the last level. <br><br>  Suppose the resolution of our scene is 256x256x256, then to store a fully filled tree, we need a texture of 6185x6185 (145.9 MB).  But we do not intend to store a full tree.  According to my observations, for a Sponza scene with this resolution of the scene, a sparse tree is placed in a texture of 2080x2080 (16.6 MB). <br><br><h2>  Create an array of voxels </h2><br>  To create an array of voxels, you need to voxelize all the objects in the scene.  We use simple voxelization from the related article <a href="https://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-SparseVoxelization.pdf">Octree-Based Sparse Voxelization</a> .  This technique is easy to implement and works in a single pass GPU. <br><br><img src="https://habrastorage.org/webt/3g/tb/d1/3gtbd1n2tiarwetmycl_bap-p2o.png"><br>  <i>Pipeline object voxelization [SV]</i> <br><br>  Calculate the bounding cube of the scene.  Set the viewport by the resolution of the voxelized scene (for example, 256x256).  We expose the orthographic camera above the stage to fit the bounding cube.  Render every scene object we want to consider. <br><br>  In a geometric shader, we handle the object's triangles.  With the help of the normal of the triangle, the axis is chosen, in the direction of which the area of ‚Äã‚Äãthe projection of this triangle is maximal.  Depending on the axis, we rotate the triangle with the largest projection to the rasterizer, so that we get more voxels. <br><br>  In a pixel shader, each fragment will be a voxel.  Create a Voxel structure with coordinates, color and normal, and add it to the voxel array. <br><br>  At this stage, it is advisable to use low poly lody (LOD) objects in order not to have problems with missing voxels and merging voxels of adjacent triangles (such cases are discussed in article [SV]). <br><br><img src="https://habrastorage.org/webt/hq/uj/r6/hqujr6cn1tcrsh9pqicgblf3afy.png" width="250"><img src="https://habrastorage.org/webt/xs/fq/bo/xsfqbowfk1zkrsvwumg5lfdvwpk.png" width="250"><img src="https://habrastorage.org/webt/ce/5v/rh/ce5vrhmsnjudwod7nplfbtns4oc.png" width="250"><br>  <i>Voxelization artifacts - not all triangles are rasterized.</i>  <i>Low poly lody should be used or additional triangles should be stretched.</i> <br><br><h2>  Creating an octree using a voxel list </h2><br>  When the whole scene is voxelized, we have an array of voxels with their coordinates.  By this array, you can build SVO, with which we can find voxels in space.  Initially, each pixel of the texture with SVO is initialized to 0xffffffff.  To write tree nodes through a shader, the SVO texture will be represented as a UAV resource (RWTexture2D).  To work with a tree, we will get an atomic node counter (D3D11_BUFFER_UAV_FLAG_COUNTER). <br><br>  Let us describe in stages an octree creation algorithm.  The node address in SVO is hereafter referred to as the node index, which is converted to 2D texture coordinates.  By allocating a node we mean the following set of actions: <br><br><ul><li>  With the help of the current value of the node counter, addresses are calculated in which the child nodes of the node being located will be located. </li><li>  The node count is increased by the number of child nodes (8). </li><li>  Addresses of child nodes are written in the fields of the current node. </li><li>  In the flag field of the current node, it is written that it is allocated. </li><li>  The address of the current node is recorded in the parent field of the child nodes. </li></ul><br><img src="https://habrastorage.org/webt/z_/rc/b7/z_rcb7_hnkjupwtab6vdm9kczra.png"><br>  <i>Schematic representation of the octree and its representation in texture [SV]</i> <br><br>  The algorithm for creating an octree with a height of N is as follows: <br><br><ol><li>  <b>Allocate the root node</b> .  The current tree level = 1. Node counter = 1. </li><li>  <b>We touch the voxels</b> .  For each voxel, we find a node (subspace) at the current level of the tree to which it belongs.  We mark such nodes with a flag that allocation is necessary.  This stage can be parallelized on the vertex shader using <a href="https://msdn.microsoft.com/ru-ru/library/windows/desktop/bb232912(v%3Dvs.85).aspx">Input-Assembler without buffers</a> , using only the number of voxels and the SV_VertexID attribute for addressing over the array of voxels. </li><li>  <b>For each node of the current tree level, check the flag</b> .  If necessary, allocate the node.  This stage can also be parallelized on the vertex shader. </li><li>  <b>For each node of the current tree level, we write in the child nodes of the neighbors' addresses</b> . </li><li>  <b>The current tree level is ++</b> .  Repeat steps 2-5 until the current level of the tree is &lt;N. </li><li>  <b>At the last level, instead of allocating the current node, write the voxel index in the voxel array</b> .  Thus, the nodes of the last level will contain up to 8 indices. </li></ol><br>  Having built such an octree tree, we can easily find the voxel of the scene by the coordinates in space, going down the SVO. <br><br><h2>  Creating block buffer by octree tree </h2><br>  Now that we have designed the octree of the voxelized scene, we can use this information to preserve the illumination re-echoed by voxels from the light sources.  Illumination is stored in a 3D texture format R8G8B8A8.  This will allow us to use the trilinear interpolation of the GPU when sampling the texture, and as a result we will get a smoother final image.  This texture is called the block buffer (brick buffer), because it consists of blocks arranged in accordance with SVO.  A block is another representation of a group of voxels in space. <br><br>  Groups of 2x2x2 voxels, whose indices are located in the leaves of the SVO, are mapped onto 3x3x3 voxels of 3D textures: <br><br><img src="https://habrastorage.org/webt/_s/9f/c5/_s9fc5vnfmxjwtohxjoblatvnc0.png"><br>  <i>Display voxel group to voxel block [DP]</i> <br><br>  The voxel groups located in the scene next to each other may be scattered in the texture (since the texture is based on SVO).  Therefore, for correct interpolation between adjacent groups of voxels, additional work is needed to average the values ‚Äã‚Äãbetween adjacent blocks. <br><br><img src="https://habrastorage.org/webt/tx/nm/dc/txnmdc2mj0v7tjky37swz223hay.png"><br>  <i>Averaging the boundaries of adjacent blocks</i> <br><br>  The voxels from the block are located at the corners of the original voxel group and between them.  Thus, the blocks occupy more space in space than the original voxels.  But sampling inside the block will be performed along the boundaries of the original voxels.  So a semblance of a half-pixel-wide delimiter appears that is not used at all. <br><br>  Blocks arranged according to the leaves of the SVO is a display of the original voxels.  The blocks located in accordance with the remaining SVO nodes at certain octree levels are the MIP levels of the block buffer. <br><br><img src="https://habrastorage.org/webt/pr/cj/oa/prcjoa1npq1heopoywfpkvdxpua.png"><br>  <i>Schematic image of octree, its representation in texture and display in the buffer of blocks [SV]</i> <br><br>  The blocks do not have to be 3x3x3, they can be 2x2x2, and 5x5x5 - this is a question of the accuracy of the presentation.  Blocks 2x2x2 would be another good way to save memory, but I have never met such an approach. <br><br><img src="https://habrastorage.org/webt/lq/s9/wq/lqs9wqp_yd4ggilfthkbtondtsy.png"><br>  <i>Interpolation comparison when sampling four adjacent voxels: without block buffer, from 3x3x3 block buffer and from 5x5x5 block buffer</i> <br><br>  Creating such a block buffer is quite time consuming.  We will create two buffers: for storing scene transparency and for storing lighting. <br><br><h2>  Steps for creating a block buffer </h2><br>  The first step is to complete the voxels of the blocks matched with the leaves of the octree.  Suppose we compute the reflected light in specific SVO voxels.  Then these values ‚Äã‚Äãwill be mapped to the corresponding corner voxels of the block buffer. <br><br><img src="https://habrastorage.org/webt/ka/5r/j5/ka5rj5az9iuqnwacsn2-q0aigzk.png"><br><br>  After the calculation of the outgoing light is completed, for each block, we will fill in the remaining voxels with the averaged values ‚Äã‚Äãof the neighboring voxels inside the block: <br><br><img src="https://habrastorage.org/webt/jc/gq/cy/jcgqcyka7-fjkivpta7g0jjlly4.png"><br><br>  Now we average the values ‚Äã‚Äãbetween adjacent blocks.  That is why in the nodes of the tree neighbors are stored in space. <br><br><img src="https://habrastorage.org/webt/sj/is/ie/sjisiedurfjl0i5q3kzh_8ay4as.png"><br>  <i>One of the options for averaging the block buffer is on each of the axes in three passes.</i>  <i>Red rectangles indicate possible artifacts with this averaging [DP]</i> <br><br>  Create MIP levels of this buffer.  The nodes of the upper levels of the SVO will be displayed in blocks that contain averaged values ‚Äã‚Äãfrom the underlying level.  Each block corresponding to a node from the top level of the tree includes information from the blocks of the corresponding descendants.  It can also be blocks that correspond not only directly to the child nodes in the tree, but also to their neighbors (see the figure below). <br><br><img src="https://habrastorage.org/webt/cv/px/ak/cvpxakjzyvycjxxd1bpay-ptb_o.png"><br>  <i>On the left - the block includes information from the child blocks and their neighbors.</i>  <i>Right - the block includes information only from child blocks [DP]</i> <br><br>  To reduce the number of memory accesses, for each calculated block, only voxels of child blocks are used (right figure).  After that, the values ‚Äã‚Äãbetween neighboring blocks are averaged, as described above.  And so we create MIP levels until we reach the SVO root node. <br><br>  Create two buffers - the scene transparency block buffer and the reflected light block buffer. <br><br>  The transparency block buffer is created in advance, based on the voxelised geometry of the scene.  We will keep the voxel directional transparency.  To do this, fill in the RGB values ‚Äã‚Äãof the voxels of the blocks from the lower level in accordance with the transparency of the voxels, and when creating the MIP levels of the blocks for each calculated voxel, we choose the averaged maximum transparency value along the XYZ axes and save them to the corresponding RGB texture values.  Such a solution helps to take into account the obstruction of light in space in a certain direction. <br><br><img src="https://habrastorage.org/webt/tp/9t/et/tp9tetblycaiahptuxtlutemti8.png"><br>  <i>In each direction, a maximum is chosen in the value of transparency (that is, 1.0 is a completely opaque object, and this value will be maximum).</i>  <i>Further, when constructing MIP levels, the maxima along the XYZ axes in the daughter blocks are averaged and added into the RGB components.</i>  <i>[DP]</i> <br><br><h2>  Baking reflected lighting </h2><br>  The illumination re-echoed by a voxel is calculated by processing the shadow map from the calculated light sources.  Using this map, we can obtain the coordinates of objects in space and, using SVO, convert them into indices of illuminated voxels. <br><br>  Normally, the shadow map resolution is higher than the octree resolution.  The original article describes an approach in which each pixel of a shadow map is treated as a conditional photon.  Accordingly, depending on the number of photons there will be a different contribution to the illumination.  In my implementation, I simplified this stage and counted the illumination only once for each voxel that got into the shadow map. <br><br>  To avoid recalculations, for each voxel for which reflected light has already been calculated, we use the flag bit of the octree node that stores the pointer to the voxel.  Also, when processing a shadow map, among the pixels included in the same voxel, it is possible to select only the upper left for the calculation. <br><br><img src="https://habrastorage.org/webt/ij/ie/5n/ijie5nk33gqalek7hbobxhsmlym.png" width="370"><img src="https://habrastorage.org/webt/b9/t_/ev/b9t_evpazubphu-tn9ylav06cfw.png" width="370"><br>  <i>Fragment of the shadow map (left).</i>  <i>On the right - in red, the top left pixels of the same voxel are shown.</i> <br><br>  Standard albedo * lightColor * dot (n, l) is used to calculate the reflected light, but in the general case it depends on BRDF.  The calculated illuminance is written to the buffer of the lighting units.  After processing the shadow map, the block buffer is refilled and MIP levels are created, as described above. <br><br>  The algorithm is quite expensive.  It is necessary to recalculate the buffer of the lighting units each time the lighting changes.  One of the possible ways to optimize is to blur the update buffer <a href="https://habrahabr.ru/post/320530/">by frame</a> . <br><br><h2>  Create G-Buffer </h2><br>  In order for a particular pixel to apply a trace of voxels by cones, you need to know the normal and the location of the pixel in space.  These attributes are used to bypass the SVO and appropriately sample the lighting block buffer.  You can get these attributes from <a href="https://en.wikipedia.org/wiki/Deferred_shading">G-buffer</a> . <br><br>  With G-buffer, it is also possible to calculate re-reflected lighting at a lower resolution than that of the viewport, which improves performance. <br><br><h2>  Trace voxel traces </h2><br>  When the illumination block buffer is calculated, one can proceed to the calculation of the illumination re-reflected from the scene to the objects in the frame ‚Äî that is, global illumination.  For this, tracing voxels with cones is used. <br><br>  For each pixel, several cones are emitted in accordance with BRDF.  In the case of the Lambert lighting model, cones are emitted uniformly over a hemisphere oriented with the normal obtained from the G-buffer. <br><br><img src="https://habrastorage.org/webt/vo/kb/ju/vokbjusy6l1bnclgllg7ti8nlc8.png"><br>  <i>Emission of cones from the surface for which incoming lighting is calculated [VCT]</i> <br><br>  In the calculation, we assume that the illumination obtained from a point on the surface in the direction of the voxel will be the same as that emitted from the voxel towards the surface in a certain cone of visibility. <br><br><img src="https://habrastorage.org/webt/-v/sy/sw/-vsysw1jb0hthbvknsy_t2mij-k.png"><br>  <i>[VCT]</i> <br><br>  Tracing is done step by step.  At each step, the illumination block buffer is sampled in accordance with the octree level (i.e., in accordance with the created MIP levels), starting with the lowest and ending at the highest. <br><br><img src="https://habrastorage.org/webt/c3/py/nf/c3pynfn4u27dhtewd4bi3qg3vqy.png"><br>  <i>Sampling the block buffer using a cone according to SVO levels [DP]</i> <br><br>  Taper tracing is done in the same way as volumetric objects [A] are rendered.  Those.  the alpha front-to-back model is used, in which at each next step along the cone, color and transparency are calculated as follows: <br><br><pre> <code class="hljs cs"><span class="hljs-string"><span class="hljs-string">' = '</span></span> + ( <span class="hljs-number"><span class="hljs-number">1</span></span> ‚Äî <span class="hljs-string"><span class="hljs-string">' ) *  '</span></span> = <span class="hljs-string"><span class="hljs-string">' + ( 1 ‚Äî '</span></span> ) * </code> </pre> <br>  where a is transparency, c is the value obtained from the illumination block buffer multiplied by transparency (premultiplied alpha). <br><br>  The transparency value is calculated using the transparency block buffer: <br><br><pre> <code class="hljs mel">opacityXYZ = opacityBrickBuffer.Sample( linearSampler, brickSamplePos ).rgb; alpha = <span class="hljs-keyword"><span class="hljs-keyword">dot</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">abs</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">normalize</span></span>( coneDir ) * opacityXYZ ), <span class="hljs-number"><span class="hljs-number">1.0</span></span>f.xxx );</code> </pre> <br>  In other words, the transparency is read in the direction of the cone at a specific point.  This is not the only approach.  You can, for example, store transparency in the alpha channel of the illumination block buffer.  But then the direction of re-reflected light is lost.  I also tried to store directional illumination in six buffers of lighting units (two for each axis) - costs more than visible advantages. <br><br>  The final result for the cones is weightedly summed up depending on the angles of the solution of the cones.  If all the cones are the same, the weight is divided equally.  The choice of the number of cones and the size of the angles of the solution is a matter of the ratio of speed and quality.  In my implementation, there are 5 cones of 60 degrees (one in the center, and 4 on the sides). <br><br>  The figure above shows schematically the sampling points along the axis of the cone.  It is recommended to choose the location of the samples so that the octree node from the appropriate level fits into the cone.  Or you can replace the corresponding sphere [SB].  But then sharp voxel borders may appear, so the location of the samples is adjusted.  In my implementation, I just move the samples closer to each other. <br><br>  As a bonus to re-reflected lighting, we also get <a href="https://ru.wikipedia.org/wiki/Ambient_occlusion">Ambient Occlusion</a> shading, which is calculated from the alpha value obtained by tracing.  Also, when AO is miscalculated, at each step along the cone axis, a correction is made depending on the distance <code>1 / (1 + lambda * distance)</code> , where lambda is the calibration parameter. <br><br>  The result is saved in an RGBA texture (RGB for lighting and A for AO).  For a smoother result, a blur can be applied to the texture.  The final result will depend on the BRDF.  In my case, the calculated reflections are first multiplied by the surface albedo obtained from the G-buffer, then optionally multiplied by AO, and finally added to the main light. <br><br>  In general, after certain settings and improvements, the picture is similar to the result from the article. <br><br><img src="https://habrastorage.org/webt/vo/vv/dj/vovvdjkgrzvolz9zi1qzxq24z9o.png" width="250"><img src="https://habrastorage.org/webt/iq/jj/gx/iqjjgxcayddeo2rjmhjzogpu7mo.png" width="250"><img src="https://habrastorage.org/webt/iz/a6/eh/iza6ehbdgctiymft3a6dksjupm4.png" width="250"><br>  <i>Comparison of the results - on the left is the scene rendered in Mental Ray, on the right is the Voxel Cone Tracing from the original article, in the center is my implementation.</i> <br><br><h2>  Underwater rocks </h2><br>  <b>The problem of self-illumination</b> .  Since in most cases the surface is physically located in its own voxels, it is necessary to somehow deal with self-illumination.  One solution is to move the beginning of the cones in the direction of the normals.  Also, this problem can theoretically be avoided if the directed distribution of light is stored in voxels. <br><br>  <b>Performance problem</b>  The algorithm is quite complicated, and you have to spend a lot of time on effective implementation on the GPU.  I wrote the implementation "in the forehead", applying fairly obvious optimization, and the load turned out to be high.  At the same time, even an optimized algorithm when searching for voxels in a tree will require a lot of SVO texture samples dependent on each other. <br><br>  In my implementation, I emit 5 cones, sampling block buffers for the 4 penultimate octree levels of 256x256x256.  According to the Intel GPA, the relative performance distribution is as follows: <br><br><img src="https://habrastorage.org/webt/82/xg/ty/82xgty-qwgptlroykcda2s6siso.png"><br>  <i>Performance Distribution</i>  <i>G-Buffer and Shadow Map without pre-cool.</i> <br><br>  The original article uses three diffuse cones on a 512x512 texture on the whole SVO (512x512x512 - 9 levels).  Together with direct lighting, it takes ~ 45% of the time frame 512x512.  There is much to strive for.  You also need to pay attention to optimizing the update buffer lighting. <br><br>  Another problem with the algorithm is <b>light leaking through objects</b> .  This happens with thin objects that make a small contribution to the transparency block buffer.  Also, planes located near voxels of lower levels of SVO are subject to this phenomenon: <br><br><img src="https://habrastorage.org/webt/ya/gc/vw/yagcvwcbmbuaft0db2xpnczcsw4.png" width="370"><img src="https://habrastorage.org/webt/iw/xu/0f/iwxu0fc9xgcw5aacw-ky1qlv9kw.jpeg" width="370"><br>  <i>Light leaking: on the left - when using the VCT algorithm, on the right - in real life.</i>  <i>This effect can be reduced with AO.</i> <br><br>  One more consequence follows from the above: it is not so easy to tweak the algorithm in order to get a good picture - how many cones to take, how many SVO levels, with which coefficients, etc. <br><br>  We considered only static objects of the scene.  To store dynamic objects, you need to modify the SVO and the corresponding buffers.  As a rule, in this case, it is proposed to separately store static and dynamic nodes. <br><br>  To summarize, I would not recommend this technique if you do not have enough time, patience and energy.  But it will help to achieve a believable ambient lighting. <br><br>  Dynamic demonstration: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/gK837_HTfNU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Link to the application: <a href="https://github.com/Darkxiv/VoxelConeTracing">https://github.com/Darkxiv/VoxelConeTracing</a> (bin / VCT.exe) <br><br>  <b>The list of sources and resources that can help in the implementation of voxel tracing cones:</b> <br><br><ul><li>  [VCT] Original article: <a href="http://research.nvidia.com/sites/default/files/publications/GIVoxels-pg2011-authors.pdf">http://research.nvidia.com/sites/default/files/publications/GIVoxels-pg2011-authors.pdf</a> </li><li> [SV]    ,      SVO: <a href="https://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-SparseVoxelization.pdf">https://www.seas.upenn.edu/~pcozzi/OpenGLInsights/OpenGLInsights-SparseVoxelization.pdf</a> </li><li> [S4552]  NVIDIA: <a href="http://on-demand.gputechconf.com/gtc/2014/presentations/S4552-rt-voxel-based-global-illumination-gpus.pdf">http://on-demand.gputechconf.com/gtc/2014/presentations/S4552-rt-voxel-based-global-illumination-gpus.pdf</a> </li><li> [A]  alpha front-to-back: <a href="http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch39.html">http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch39.html</a> </li><li> [DP] ,     : <a href="http://dcgi.felk.cvut.cz/theses/2013/drinotom">http://dcgi.felk.cvut.cz/theses/2013/drinotom</a> </li><li> [SB]     VCT: <a href="http://simonstechblog.blogspot.ru/2013/01/implementing-voxel-cone-tracing.html">http://simonstechblog.blogspot.ru/2013/01/implementing-voxel-cone-tracing.html</a> </li><li>     UE4: <a href="https://www.yumpu.com/en/document/view/4694219/the-technology-behind-the-elemental-demo-unreal-engine">https://www.yumpu.com/en/document/view/4694219/the-technology-behind-the-elemental-demo-unreal-engine</a> </li><li>   ambient : <a href="http://www.valvesoftware.com/publications/2006/SIGGRAPH06_Course_ShadingInValvesSourceEngine.pdf">http://www.valvesoftware.com/publications/2006/SIGGRAPH06_Course_ShadingInValvesSourceEngine.pdf</a> </li><li>  sparse octree  NVIDIA <a href="https://developer.nvidia.com/gvdb">https://developer.nvidia.com/gvdb</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/353740/">https://habr.com/ru/post/353740/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../353730/index.html">Mikrotik RoS, useful things</a></li>
<li><a href="../353732/index.html">Crypto Trading Automation with Django and Celery</a></li>
<li><a href="../353734/index.html">Concepts of distributed architecture, which I met when building a large payment system</a></li>
<li><a href="../353736/index.html">Digest news from the world of PostgreSQL. Issue number 5</a></li>
<li><a href="../353738/index.html">Secure SOCKS5 proxy for Telegram for 1 Euro and 10 minutes</a></li>
<li><a href="../353744/index.html">Red Hat is heading for a hybrid cloud with Enterprise Linux 7.5: what does it mean</a></li>
<li><a href="../353746/index.html">How Sberbank Online applications work: Workflow API and frameworks</a></li>
<li><a href="../353748/index.html">It is not Android. Features of the development under Wear OS</a></li>
<li><a href="../353750/index.html">How fraudsters trick cryptocurrency users, and how to protect digital assets: 3 practical tips</a></li>
<li><a href="../353758/index.html">Raise SOCKS proxy for Telegram</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>