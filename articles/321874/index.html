<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Noise functions and map generation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I studied audio signal processing, my brain began to draw analogies with procedural card generation. The article outlines the principles linking ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Noise functions and map generation</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/f62/1e8/f1c/f621e8f1c34144c4b0d94d93d5c1a3ab.png"><br><br>  When I studied audio signal processing, my brain began to draw analogies with procedural card generation.  The article outlines the principles linking signal processing with card generation.  I do not think that I discovered something new, but some conclusions were new to me, so I decided to write them down and share them with the readers.  I consider only simple topics (frequency, amplitude, noise colors, use of noise) and do not touch on other topics (discrete and continuous functions, FIR / IIR filters, fast Fourier transform, complex numbers).  Mathematics of the article is mainly related to sinusoids. <br><br>  <b>This article is devoted to concepts</b> , starting with the simplest and ending more complex.  If you want to go straight to generating terrain using the noise functions, then study my <a href="http://www.redblobgames.com/maps/terrain-from-noise/">other</a> article. <br><a name="habracut"></a><br>  I will start with the basics of using random numbers, and then move on to explaining the work of one-dimensional landscapes.  The same concepts work for 2D (see <a href="http://www.redblobgames.com/articles/noise/2d/">demo</a> ) and 3D.  Try moving the slider [in the <a href="http://www.redblobgames.com/articles/noise/introduction.html">original</a> article] to see how a single parameter can describe different types of noise: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">Gif</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/ff2/de9/e91/ff2de9e91e5a471099a7ea8e67f63c14.gif"><br></div></div><br>  From this article you will learn: <br><br><ul><li>  how to generate similar landscapes in just 15 lines of code </li><li>  what is red, pink, white, blue and purple noise </li><li>  how noise functions can be used for procedural map generation </li><li>  how the midpoint offset, Perlin noise and fractal Brownian motion are applied </li></ul><br>  In addition, I will experiment with 2D noise, including creating a 3D visualization of a two-dimensional height map. <br><br><h2>  1. Why is randomness useful? </h2><br>  We need procedural map generation to get output data sets that have something in common and something different.  For example, all Minecraft maps have a lot in common: biome areas, grid size, average biome sizes, heights, average cavern sizes, the percentage of each type of rock, etc.  But they also have differences: the location of the biomes, the places and forms of the caves, the placement of gold, and so on.  As a designer, you need to decide which aspects should remain the same and which should be different, and take the degree of this difference. <br><br>  For different aspects, we usually use a random number generator.  Let's create an ultra-simple map generator: it will generate lines of 20 blocks each, and one of the blocks will contain a chest of gold.  Let's describe some of the maps that we need (the ‚Äúx‚Äù is the treasure): <br><br><pre><code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">1</span></span> ........x...........  <span class="hljs-number"><span class="hljs-number">2</span></span> ...............x....  <span class="hljs-number"><span class="hljs-number">3</span></span> .x..................  <span class="hljs-number"><span class="hljs-number">4</span></span> ......x.............  <span class="hljs-number"><span class="hljs-number">5</span></span> ..............x.....</code> </pre> <br>  Notice how much is common in these cards: they all consist of blocks, the blocks are on the same line, the line is 20 blocks long, there are two types of blocks and exactly one treasure chest. <br><br>  But there is one different aspect - the location of the block.  It can be in any position, from 0 (left) to 19 (right). <br><br>  We can use a random number to select the position of this block.  It will be easiest to use a <i>homogeneous selection of a random number</i> from the range from 0 to 19. This means that the probability of choosing any position from 0 to 19 is the same.  In most programming languages, there are functions for uniformly generating random numbers.  In Python, this is the function <code>random.randint(0,19)</code> , but in the article we will use the entry <code>random(0,19)</code> .  Here is a sample Python code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> map = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-comment"><span class="hljs-comment">#    pos = random.randint(0, 19) #   map[pos] = 1 #    return map for i in range(5): #  5   print_chart(i, gen())</span></span></code> </pre> <br>  But suppose that we need the cards on the cards to be more likely to be on the left.  For this we need a non-uniform selection of random numbers.  There are many ways to implement it.  One of them is to choose a random number in a uniform way, and then shift it to the left.  For example, you can try <code>random(0,19)/2</code> .  Here is the Python code for this: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> map = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">20</span></span> pos = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>) // <span class="hljs-number"><span class="hljs-number">2</span></span> map[pos] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): print_chart(i, gen())</code> </pre> <br>  But actually, I didn‚Äôt really want this.  I wanted the treasure sometimes to be on the right, but more often on the left.  Another way to move the treasure to the left is to square the number by doing something like <code>sqr(random(0,19))/19</code> .  If it is zero, then 0 squared divided by 20 is 0. If it is 19, then 19 squared divided by 19 will be 19. But in the interval, if the number is 10, then 10 squared divided at 19, equal to 5. We kept the range from 0 to 19, but moved the intermediate numbers to the left.  Such a redistribution is in itself a very useful technique, in previous projects I used squares, square roots and other functions.  ( <a href="http://easings.net/">This site</a> has standard shape-changing features used in animations. Hover over a function to view the demo.) Here is the squaring code using Python: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> map = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">20</span></span> pos = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>) pos = int(pos * pos / <span class="hljs-number"><span class="hljs-number">19</span></span>) map[pos] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>): print_chart(i, gen())</code> </pre> <br>  Another way to move objects to the left is to first randomly select the range limit of random numbers, then randomly select a number from 0 to the range limit.  If the range limit is 19, then we can put a number anywhere.  If the range limit is 10, then the numbers can be placed only on the left side.  Here is the Python code: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> map = [<span class="hljs-number"><span class="hljs-number">0</span></span>] * <span class="hljs-number"><span class="hljs-number">20</span></span> limit = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">19</span></span>) pos = random.randint(<span class="hljs-number"><span class="hljs-number">0</span></span>, limit) map[pos] = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): print_chart(i, gen())</code> </pre> <br>  There are many ways to obtain homogeneous random numbers and turn them into inhomogeneous, having the desired properties.  As a game designer, you can choose any distribution of random numbers.  I wrote an article on how to use random numbers to determine damage in role-playing games.  There are various examples of tricks. <br><br>  Summarize: <br><br><ul><li>  For procedural generation, we need to decide what remains the same and what will change. </li><li>  Random numbers are useful for filling changing parts. </li><li>  Uniformly chosen random numbers can be obtained in most programming languages, but often we need non-uniformly chosen random numbers.  To obtain them, there are different ways. </li></ul><br><h2>  2. What is noise? </h2><br>  Noise is a series of random numbers, usually located on a line or in a grid. <br><br>  When switching to a channel without a signal on old TVs, we saw random black and white dots on the screen.  This is the noise (of their open space!).  When setting up a radio channel without a station, we also hear noise (not sure if it appears from space or from somewhere else). <br><br>  In signal processing, noise is usually an undesirable aspect.  In a noisy room, it is more difficult to hear the interlocutor than in a quiet one.  Audio noise is random numbers lined up (1D).  On a noisy image, it is more difficult to see a drawing than on a clear one.  Graphic noise is a random number located in a grid (2D).  You can create noise in 3D, 4D, and so on. <br><br>  Although in most cases we try to get rid of noise, many natural systems look noisy, so to generate something that looks like natural, we need to add noise.  Although real systems look noisy, they are usually based on structure.  The noise we add will not have the same structure, but it is much simpler than simulation programming, so we use noise, and we hope that the end user will not notice this.  I will tell about this compromise later. <br><br>  Let's take a simple example of the utility of noise.  Suppose we have a one-dimensional map that we made above, but instead of one treasure chest we need to create a landscape with valleys, hills and mountains.  Let's start by using a uniform selection of random numbers at each point.  If <code>random(1,3)</code> is 1, we will consider it a valley, if 2 - hills, if 3 - mountains.  I used random numbers to create a height map: for each point in the array, I saved the height of the landscape.  Here is the Python code to create the landscape: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): random.seed(i) <span class="hljs-comment"><span class="hljs-comment">#      print_chart(i, [random.randint(1, 3) for i in range(mapsize)]) # :      Python: # output = [abc for x in def] #     : # output = [] # for x in def: # output.append(abc)</span></span></code> </pre> <br>  Hmm, these cards look "too random" for our purposes.  Perhaps we need larger areas of valleys or hills, and mountains should not be as frequent as valleys.  Earlier, we saw that a homogeneous selection of random numbers may not be entirely suitable for us, sometimes we need a heterogeneous selection.  How to solve this problem?  You can use any random selection in which valleys appear more often than mountains: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): random.seed(i) print_chart(i, [random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)])</code> </pre> <br>  This reduces the number of mountains, but does not create any interesting pictures.  The problem with such a non-uniform random choice is that the changes occur at each point separately, and we need the random choice at one point to be somehow connected with the random choice at neighboring points.  This is called coherence. <br><br>  And here we will need the functions of noise.  They give us a set of random numbers instead of one number at a time.  Here we need the 1D noise function to create a sequence.  Let's try to use the noise function, which changes the sequence of homogeneous random numbers.  There are different ways to do this, but we use at least two adjacent numbers.  If the original noise is 1, 5, 2, then the minimum (1, 5) is 1, and the minimum (5, 2) is 2. Therefore, the final noise will be 1, 2. Notice that we have eliminated the high point (5).  Also note that the resulting noise is one value less than the original.  This means that when generating 60 random numbers, the output will be only 59. Let's apply this function to the first set of cards: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adjacent_min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(noise)</span></span></span><span class="hljs-function">:</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(noise) - <span class="hljs-number"><span class="hljs-number">1</span></span>): output.append(min(noise[i], noise[i+<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">5</span></span>): random.seed(i) noise = [random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)] print_chart(i, adjacent_min(noise))</code> </pre> <br>  Compared with previous maps here turned out areas of valleys, hills or mountains.  Mountains often appear next to the hills.  And thanks to the method of changing noise (the choice of a minimum), valleys are more common than mountains.  If we took the maximum, the picture would be the opposite.  If we wanted that neither valleys nor mountains were frequent, we would choose the average instead of the minimum or maximum. <br><br>  We now have a noise modification procedure that receives noise at the input, and creates a new, smoother noise. <br><br>  And let's try to run it again! <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">adjacent_min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(noise)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     output = [] for i in range(len(noise) - 1): output.append(min(noise[i], noise[i+1])) return output for i in range(5): random.seed(i) noise = [random.randint(1, 3) for i in range(mapsize)] print_chart(i, adjacent_min(adjacent_min(noise)))</span></span></code> </pre> <br>  Now the maps have become even smoother and they have even fewer mountains.  I think we are too smooth, because the mountains do not appear with the hills too often.  Therefore, it is probably better to return one level of smoothing back in this example. <br><br>  This is a standard procedural process: you try something, see if it looks good, if not, come back and try something else. <br><br>  Note: The anti-aliasing in signal processing is called <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B8%25D0%25BB%25D1%258C%25D1%2582%25D1%2580_%25D0%25BD%25D0%25B8%25D0%25B6%25D0%25BD%25D0%25B8%25D1%2585_%25D1%2587%25D0%25B0%25D1%2581%25D1%2582%25D0%25BE%25D1%2582">a low-pass filter</a> .  Sometimes it is used to eliminate unnecessary noise. <br><br>  Summarize: <br><br><ul><li>  Noise is a collection of random numbers, usually lined up or grid. </li><li>  In procedural generation, you often need to add noise to create variations. </li><li>  The simple selection of random numbers (whether important or homogeneous) leads to noise, in which each number is not associated with those around it. </li><li>  Often we need noise with certain characteristics, for example, getting the mountains near the hills. </li><li>  There are many ways to create noise. </li><li>  Some noise functions create noise directly, others take existing noise and modify it. </li></ul><br>  Selection of the noise function is often a process of trial and error.  Understanding the nature of the work of noise and how to modify it allows you to make a more meaningful choice. <br><br><h2>  3. Creating noise </h2><br>  In the previous section, we chose noise with random numbers as output and then smoothed them out.  This is the standard pattern: start with a noise function that uses random numbers as <i>parameters</i> .  We used it when a random number chose the location of the treasure, and then we used another, where random numbers would select valleys / hills / mountains.  You can modify the existing noise to change its shape according to the requirements.  We modified the noise / valley / hill / mountain noise function, smoothing it out.  There are many different ways to modify noise functions. <br><br>  Examples of simple 1D / 2D noise generators: <br><br><ol><li>  Use random numbers directly for output.  So we did for valleys / hills / mountains. </li><li>  Use random numbers as parameters for the sines and cosines that are used for output. </li><li>  Use random numbers as parameters for gradients that are used for output.  This principle is used in the noise of Perlin. </li></ol><br>  Here are some standard noise modification methods: <br><ol><li>  Apply a filter to reduce or enhance certain characteristics.  For valleys / hills / mountains, we used anti-aliasing to reduce jumps, increase areas of valleys, and create mountains near hills. </li><li>  Add several noise functions at the same time, usually with a weighted sum, so that the influence of each noise function on the final result can be controlled. </li><li>  Interpolate between the noise values ‚Äã‚Äãobtained by the noise function to generate smoothed areas. </li></ol><br>  There are <i>so many ways to</i> create noise! <br><br>  To some extent it does not matter how the noise was created.  This is interesting, but when used in a game you need to focus on two aspects: <br><br><ol><li>  How will you <i>use the</i> noise? </li><li>  What <i>properties</i> do you need from the noise function in each case? </li></ol><br><h2>  4. Ways to use noise </h2><br>  The most straightforward way to use the noise function is to use it directly as a height.  In the example above, I generated valleys / hills / mountains, causing <code>random(1,3)</code> at each point on the map.  The noise value is directly used as a height. <br><br>  The use of midpoint displacement noise or Perlin noise are also examples of direct use. <br><br>  Another way to use noise is to use it as an offset from the previous value.  For example, if the noise function returns <code>[2, -1, 5]</code> , then we can assume that the first position is 2, the second is 2 + -1 = 1, and the third is 1 + 5 = 6. See also <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BB%25D1%2583%25D1%2587%25D0%25B0%25D0%25B9%25D0%25BD%25D0%25BE%25D0%25B5_%25D0%25B1%25D0%25BB%25D1%2583%25D0%25B6%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">"random walk"</a> .  You can do the opposite, and use the difference between the values ‚Äã‚Äãof noise.  This can also be perceived as a modification of the noise function. <br><br>  Instead of using noise to set heights, you can use it for audio. <br><br>  Or to create forms.  For example, you can use noise as the radius of the graph in polar coordinates.  You can convert a 1D noise function, such as <a href="http://www.wolframalpha.com/input/%3Fi%3Dplot%2By%2B%253D%2Bmax%25280.4%252B0.3%2Bcos%25281.313%252B7%2Bx%252B0.5%2B*%2Bsin%252819%2Bx%2529%2529%252C%2B0.7%2B-%2B0.3%2Bsin%25282.473%2B%252B%2B3%2Bx%2B-%2Bsin%25287%2Bx%2529%2529%2529">this</a> to polar form, by using the output as a radius, not an altitude.  <a href="http://www.wolframalpha.com/input/%3Fi%3Dplot%2Br%2B%253D%2Bmax%25280.4%252B0.3%2Bcos%25281.313%252B7%2B%25CE%25B8%252B0.5%2B*%2Bsin%252819%2B%25CE%25B8%2529%2529%252C%2B0.7%2B-%2B0.3%2Bsin%25282.473%2B%252B%2B3%2B%25CE%25B8%2B-%2Bsin%25287%2B%25CE%25B8%2529%2529%2529">It</a> shows how the same function looks in polar form. <br><br>  Or you can use noise as a graphic texture.  Perlin's noise is often used for this purpose. <br><br>  Noise can be applied to select locations of objects, such as trees, gold mines, volcanoes, or earthquake cracks.  In the example above, I used a random number to select the location of the treasure chest. <br><br>  You can also use noise as a <i>threshold</i> function.  For example, you can accept that at any time when the value is above 3, one event occurs, otherwise something else happens.  One example of this is the use of 3D Perlin noise to generate caves.  It can be assumed that everything is above a certain density threshold, and everything below this threshold is open air (a cave). <br><br>  In my <a href="http://www-cs-students.stanford.edu/~amitp/game-programming/polygon-map-generation/">polygon map generator,</a> I used various methods of using noise, but in none of them noise was used directly to determine the height: <br><br><ol><li>  The structure of the graph is easiest when using a grid of squares or hexagons (in fact, I started with a grid of hexagons).  Each mesh element is a polygon.  I wanted to add randomness to the grid.  This can be done by moving the points randomly.  But I needed something more random.  I used the <i>blue noise</i> generator to place polygons and the Voronoi diagram for reconstructing.  It would take much more time, but, fortunately, I had a library ( <code>as3delaunay</code> ), which did everything for me.  But I started with the grid, which is much simpler, and I recommend you to start with it. </li><li>  The coastline is a way to separate land from water.  I used two different ways to generate it using this noise, but you can also ask the designer to draw the form yourself, and I demonstrated it using square and rounded shapes.  The radial shape of the coastline is a noise function that uses sines and cosines, which draws them in polar form.  The Pearlline shoreline is a noise generator that uses Perlin noise and radial return as a threshold.  Any number of noise functions can be used here. </li><li>  The sources of the rivers are randomly located. </li><li>  Borders between polygons change from straight lines to noisy lines.  This is similar to midpoint displacement, but I scaled them so that they fit into the boundaries of the polygons.  This is a purely graphical effect, so the code is in the GUI ( <code>mapgen.as</code> ) instead of the basic algorithm ( <code>Map.as</code> ). </li></ol><br>  Most guides use noise fairly straightforwardly, but there are <i>many more</i> ways to use it. <br><br><h2>  5. Noise frequency </h2><br>  Frequency is the most important property that we are interested in.  The easiest way to understand it is to look at sinusoids.  Here is a sinusoid with a low frequency, followed by a sinusoid with a medium frequency, and at the end is a sinusoid with a high frequency: <br><br><pre> <code class="python hljs">print_chart(<span class="hljs-number"><span class="hljs-number">0</span></span>, [math.sin(i*<span class="hljs-number"><span class="hljs-number">0.293</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)])</code> </pre> <br><pre> <code class="python hljs">print_chart(<span class="hljs-number"><span class="hljs-number">0</span></span>, [math.sin(i*<span class="hljs-number"><span class="hljs-number">0.511</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)])</code> </pre> <br><pre> <code class="python hljs">print_chart(<span class="hljs-number"><span class="hljs-number">0</span></span>, [math.sin(i*<span class="hljs-number"><span class="hljs-number">1.57</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)])</code> </pre> <br>  As you can see, low frequencies create wide hills, and high frequencies narrower ones.  <i>Frequency</i> describes the horizontal size of the graph;  <i>amplitude</i> describes the vertical size.  Remember, I said earlier that the valleys / hills / mountains maps look "too random" and wanted to create wider areas of valleys or mountains?  In essence, I needed a <i>low frequency of</i> variation. <br><br>  If you have a continuous function, for example, <code>sin</code> , which creates noise, then increasing the frequency means multiplying the <i>input data</i> by some factor: <code>sin(2*x)</code> will double the frequency <code>sin(x)</code> .  Increasing amplitude means multiplying the <i>output</i> by a factor: <code>2*sin(x)</code> will double the amplitude of <code>sin(x)</code> .  In the code above, you can see that I changed the frequency by multiplying the input data with different numbers.  We use amplitude in the next section, when summing several sine waves. <br><br><div class="spoiler">  <b class="spoiler_title">Frequency change</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a42/280/b26/a42280b2674f4d9c98acf76a3bc37d4c.gif"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Amplitude change</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/3be/dd5/a6d/3bedd5a6d19740e488a4b6a239cfcbf6.gif"><br></div></div><br>  All of the above applies to 1D, but the same thing happens in 2D.  Look at Figure 1 on <a href="http://devmag.org.za/2009/04/25/perlin-noise/">this page</a> .  You see examples of 2D noise with a large wavelength (low frequency) and a small wavelength (high frequency). Note that the higher the frequency, the smaller the individual fragments. <br><br>  When they talk about frequency, wavelength or octaves of the noise functions, this is what is meant, even if sinusoids are not used. <br><br>  Speaking of sinusoids, you can do funny things by combining them in strange ways.  For example, here are the low frequencies on the left and the high frequencies on the right: <br><br><pre> <code class="python hljs">print_chart(<span class="hljs-number"><span class="hljs-number">0</span></span>, [math.sin(<span class="hljs-number"><span class="hljs-number">0.2</span></span> + (i * <span class="hljs-number"><span class="hljs-number">0.08</span></span>) * math.cos(<span class="hljs-number"><span class="hljs-number">0.4</span></span> + i*<span class="hljs-number"><span class="hljs-number">0.3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)])</code> </pre> <br>  Usually at the same time you will have a lot of frequencies, and no one will give the right answers about the choice you need.  Ask yourself: what frequencies do I need?  Of course, the answer depends on how you plan to use them. <br><br><h2>  6. noise colors </h2><br>  The ‚Äúcolor‚Äù of noise determines the types of frequencies that it contains. <br><br>  All frequencies are equally affected by <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D0%25B5%25D0%25BB%25D1%258B%25D0%25B9_%25D1%2588%25D1%2583%25D0%25BC">white noise</a> .  We already worked with white noise when we chose from 1, 2 and 3 to designate valleys, hills and mountains.  Here are 8 sequences of white noise: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): random.seed(i) print_chart(i, [random.uniform(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)])</code> </pre> <br>  In <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2580%25D0%25B0%25D1%2581%25D0%25BD%25D1%258B%25D0%25B9_%25D1%2588%25D1%2583%25D0%25BC">red noise</a> (also called Brownian), <i>low</i> frequencies are more prominent (they have high amplitudes).  This means that in the output data there will be longer hills and valleys.  Red noise can be generated by averaging the neighboring white noise values.  Here are the same 8 examples of white noise, but subjected to the averaging process: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">smoother</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(noise)</span></span></span><span class="hljs-function">:</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(noise) - <span class="hljs-number"><span class="hljs-number">1</span></span>): output.append(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * (noise[i] + noise[i+<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): random.seed(i) noise = [random.uniform(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)] print_chart(i, smoother(noise))</code> </pre> <br>  If you look closely at any of these eight examples, you will notice that they are smoother than the corresponding white noise.  Intervals of large or small values ‚Äã‚Äãare longer. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B2%25D0%25B5%25D1%2582%25D0%25B0_%25D1%2588%25D1%2583%25D0%25BC%25D0%25B0">Pink noise</a> is between white and red.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It often occurs in nature, and is usually suitable for landscapes: large hills and valleys, plus a small relief over the landscape. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">On the other side of the spectrum is purple noise. In it, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">high</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> frequencies </font><font style="vertical-align: inherit;">are more noticeable </font><font style="vertical-align: inherit;">. Violet noise can be generated by taking the difference in neighboring white noise values. Here are the same 8 examples of white noise subjected to the subtraction process:</font></font><br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rougher</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(noise)</span></span></span><span class="hljs-function">:</span></span> output = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(noise) - <span class="hljs-number"><span class="hljs-number">1</span></span>): output.append(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * (noise[i] - noise[i+<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">8</span></span>): random.seed(i) noise = [random.uniform(<span class="hljs-number"><span class="hljs-number">-1</span></span>, +<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)] print_chart(i, rougher(noise))</code> </pre> <br>        ,  ,      .      / ,    . <br><br>       .      :    ,    ,     .           .         .    <a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B2%25D0%25B5%25D1%2582%25D0%25B0_%25D1%2588%25D1%2583%25D0%25BC%25D0%25B0"></a> ,       . <br><br>  ,   ,    .         ,   .        . <br><br>  : <br><br><ul><li>  ‚Äî    , , ,        . </li><li>   ‚Äî  .    .     . </li><li> , ,    ‚Äî   ,      . </li><li>       . </li><li>       . </li></ul><br><h2> 7.   </h2><br>      ¬´¬ª    ¬´¬ª .      .         .        . <br><br>          ‚Äî       ,     . , ,       <code>noise</code> ,      <code>freq</code> .    ,   1000      2000 ,    ,    <code>noise(1000) + 0.5 * noise(2000)</code> . <br><br>  ,   <code>sine</code>   ,     ,       ,     . <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">noise</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(freq)</span></span></span><span class="hljs-function">:</span></span> phase = random.uniform(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>*math.pi) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [math.sin(<span class="hljs-number"><span class="hljs-number">2</span></span>*math.pi * freq*x/mapsize + phase) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(mapsize)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">3</span></span>): random.seed(i) print_chart(i, noise(<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br>  That's all.     ‚Äî  ,      ( <i></i> ).      ,    . <br><br>      .    8     1, 2, 4, 8, 16, 32 (       ).           (.  <code>amplitudes</code> )   .      : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">weighted_sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amplitudes, noises)</span></span></span><span class="hljs-function">:</span></span> output = [<span class="hljs-number"><span class="hljs-number">0.0</span></span>] * mapsize <span class="hljs-comment"><span class="hljs-comment"># make an array of length mapsize for k in range(len(noises)): for x in range(mapsize): output[x] += amplitudes[k] * noises[k][x] return output</span></span></code> </pre> <br>      <code>noise</code>    <code>weighted_sum</code> : <br><br><pre> <code class="python hljs">amplitudes = [<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.7</span></span>, <span class="hljs-number"><span class="hljs-number">0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0.4</span></span>] frequencies = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>): random.seed(i) noises = [noise(f) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> f <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> frequencies] sum_of_noises = weighted_sum(amplitudes, noises) print_chart(i, sum_of_noises)</code> </pre> <br>    ,     ,     ,     . <br><br>    <code>[1.0, 0.7, 0.5, 0.3, 0.2, 0.1]</code>   ?          : <br><br><img src="https://habrastorage.org/files/bec/3f5/46a/bec3f546a1704cb9896006d3da599e23.png"><br><br>         <code>[0.1, 0.1, 0.2, 0.3, 0.5, 1.0]</code> ?       ,         : <br><br><img src="https://habrastorage.org/files/f62/1e8/f1c/f621e8f1c34144c4b0d94d93d5c1a3ab.png"><br><br> ,     ‚Äî        ,     15  .        . <br><br>  : <br><br><ul><li>                   . </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can create noise by taking a weighted sum of other noise functions that have different frequencies. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> You can select noise characteristics by choosing weights for a weighted amount. </font></font></li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Generating a rainbow </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now that we can generate noise by mixing noise with different frequencies together, let's look at the noise color again. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, go to </font></font><a href="https://ru.wikipedia.org/wiki/%25D0%25A6%25D0%25B2%25D0%25B5%25D1%2582%25D0%25B0_%25D1%2588%25D1%2583%25D0%25BC%25D0%25B0"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the Wikipedia page about the colors of noise</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Notice that there is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">frequency spectrum</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">He tells us about the amplitude of each frequency present in the noise. </font><font style="vertical-align: inherit;">White noise - flat, pink and red tilted down, blue and purple rise up. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The frequency spectrum is correlated with our arrays </font></font><code>frequencies</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>amplitudes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">from the previous section.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, we used frequencies that are powers of two. </font><font style="vertical-align: inherit;">Different types of color noise have much more frequencies, so we need a larger array. </font><font style="vertical-align: inherit;">For this code, instead of the powers of two (1, 2, 4, 8, 16, 32) I am going to use all the whole frequencies from 1 to 30. Instead of recording the amplitudes manually, I will write a function </font></font><code>amplitude(f)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">that returns the amplitude of any given frequency and creates an array of these data </font></font><code>amplitudes</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can again use the </font></font><code>weighted_sum</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font><font style="vertical-align: inherit;">functions </font></font><code>noise</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, but now instead of a small set of frequencies, we will have a longer array:</font></font><br><br><pre> <code class="python hljs">frequencies = range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">31</span></span>) <span class="hljs-comment"><span class="hljs-comment"># [1, 2, ..., 30] def random_ift(rows, amplitude): for i in range(rows): random.seed(i) amplitudes = [amplitude(f) for f in frequencies] noises = [noise(f) for f in frequencies] sum_of_noises = weighted_sum(amplitudes, noises) print_chart(i, sum_of_noises) random_ift(10, lambda f: 1)</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this code, the function </font></font><code>amplitude</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">defines the form. </font><font style="vertical-align: inherit;">If it always returns 1, then we get white noise. </font><font style="vertical-align: inherit;">How to generate other colors of noise? </font><font style="vertical-align: inherit;">I will use the same random seed number, but I will use another amplitude function for it:</font></font><br><br><h4>  8.1.   </h4><br><pre> <code class="python hljs">random_ift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> f: <span class="hljs-number"><span class="hljs-number">1</span></span>/f/f)</code> </pre> <br><h4>  8.2.   </h4><br><pre> <code class="python hljs">random_ift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> f: <span class="hljs-number"><span class="hljs-number">1</span></span>/f)</code> </pre> <br><h4>  8.3.   </h4><br><pre> <code class="python hljs">random_ift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> f: <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br><h4>  8.4.   </h4><br><pre> <code class="python hljs">random_ift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> f: f)</code> </pre> <br><h4>  8.5.   </h4><br><pre> <code class="python hljs">random_ift(<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> f: f*f)</code> </pre> <br><h4>  8.6.   </h4><br> ,   .   <i> </i>      . <br><br><ul><li>   ‚Äî  f^-2 </li><li>   ‚Äî  f^-1 </li><li>   ‚Äî  f^0 </li><li>   ‚Äî  f^+1 </li><li>   ‚Äî  f^+2 </li></ul><br> <b>   </b> [  ],  ,     8.1-8.5     . <br><br>  : <br><br><ul><li>         . </li><li>      (),   f^c. </li><li>   ,          . </li></ul><br><h2> 9.    </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To generate different colors of noise, we forced the amplitudes to follow simple power-law functions with different exponents. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">But we are not limited to these forms.</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> This is the simplest pattern, displayed on logarithmic graphics with straight lines. Perhaps there are other sets of frequencies that create interesting patterns for our needs. You can use an amplitude array and customize them as you like, instead of using a single function. It's worth exploring, but I haven't done it yet. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What we did in the previous section can be thought of as </font></font><a href="http://www.thefouriertransform.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fourier series</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . The basic idea is that any continuous function can be represented as a weighted sum of sine waves and cosine waves. Depending on the chosen scales, the appearance of the final function changes.</font></font><i> </i>      .           /.     ,  ¬´¬ª . <br><br>    <i></i>    ;    <i></i>   .        . ,    .           . <br><br>     . <br><br>  <a href="http://betterexplained.com/articles/an-interactive-guide-to-the-fourier-transform/"> </a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is an explanation of how the Fourier transform works. The diagrams on this page are interactive ‚Äî you can enter the strength of each frequency, and the page will show how they are combined. By combining sinusoids, you can get a lot of interesting shapes. For example, try entering the Cycles input field </font></font><code>0 -1 0.5 -0.3 0.25 -0.2 0.16 -0.14</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and unchecking the Parts box. True, it looks like a mountain? In the Appendix (Appendix) of this page there is a version that shows how the sinusoids look in polar coordinates. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One example of using the Fourier transform to generate maps is to use a </font><a href="http://paulbourke.net/fractals/noise/"><font style="vertical-align: inherit;">frequency synthesis</font></a><font style="vertical-align: inherit;"> technique to generate a landscape.</font></font><a href="http://paulbourke.net/fractals/noise/"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paul Bourke, who first generates two-dimensional white noise, then transforms it into frequencies using the Fourier transform, then gives it a form of pink noise, and then transforms it back using the inverse Fourier transform. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">My little experience of experiments with 2D shows that everything is not so straightforward in it as in 1D. </font><font style="vertical-align: inherit;">If you want to look at my unfinished experiments, scroll to the end of </font></font><a href="http://www.redblobgames.com/articles/noise/2d/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this page</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">move the sliders</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 10. Other noise functions </font></font></h2><br>         .   .      <i></i> .       ,    ,  ,     15  . <br><br>       ,      . ,      : <br><br><ul><li> ,  midpoint displacement     ,                . ,    .      ,    -   (  ,  ),  -   ,   .    . </li><li> Diamond square ‚Äî   midpoint displacement,    ,   midpoint displacement. </li><li>    /-      .    ,      . </li><li>  ,     ()        . </li><li> <a href="http://www.firstpr.com.au/dsp/pink-noise/"> -</a>    midpoint displacement.         . </li><li>            .       .   (Paul Bourke) <a href="http://paulbourke.net/fractals/noise/">     (Frequency Synthesis)</a>       2D-,    . </li></ul><br>     -   ,           ,        . ,   midpoint displacement,  ,  - ,    -  ,    . <br><br>         . <br><br><ul><li>            ,      .     ,   ,      ,     . </li><li>       ‚Äî <a href="http://www.cs.virginia.edu/~gfx/pubs/antimony/"> </a> .         ,     . .  <a href="http://devmag.org.za/2009/05/03/poisson-disk-sampling/"> </a> ,     . </li><li> <a href="http://johanneskopf.de/publications/blue_noise/">  </a>     .      ,       . </li><li>  ,      ,         ,     . </li></ul><br>    ,         ,        .  ,      ,   ,   ,    ,   ,     . <br><br><h2> 11.   </h2><br>       .         .       ,     ,       , ,       . <br><br> <b>    <a href="http://www.redblobgames.com/articles/noise/2d/">  2D</a></b> ,    ,    .      <b>3D-   </b> . <br><br>  ,      : <br><br><ul><li>  <a href="http://libnoise.sourceforge.net/noisegen/"> libnoise</a>       ,     ,        </li><li> <a href="http://eastfarthing.com/blog/2015-04-21-noise/">     </a>  ,    ,       </li><li> <a href="https://eev.ee/blog/2016/05/29/perlin-noise/">      </a>    </li><li> <a href="http://www.cs.unm.edu/~brayer/vision/fourier.html">      </a>    ,        </li><li> <a href="http://www.reddit.com/r/proceduralgeneration/comments/31v5bg/any_guidesresources_on_using_noise_to_create/">green_meklar  reddit</a>           </li><li> <a href="http://math.stackexchange.com/questions/1002/fourier-transform-for-dummies"> Math/StackExchange    </a> </li><li> <a href="http://www.scratchapixel.com/lessons/3d-advanced-lessons/noise-part-1/">     </a> </li><li> <a href="http://staffwww.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/">   (Stefan Gustavson)   </a> ,     ,    ,   ,       - </li><li> <a href="http://books.google.com/books%3Fid%3D1-NfBElV97IC%26amp%3Bamp%3Bpg%3DPA242%26amp%3Bamp%3Blpg%3DPA241%26amp%3Bamp%3Bots%3DSPsohjmXiA%26amp%3Bamp%3Bdq%3Dfbm%2Bpink%2Bnoise%26amp%3Bamp%3Boutput%3Dhtml_text">  ,  </a> </li><li>  <a href="http://jeremykun.com/2012/07/18/the-fast-fourier-transform/"></a>  <a href="http://jakevdp.github.io/blog/2013/08/28/understanding-the-fft/"></a>        </li><li> <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">   </a> </li><li> <a href="http://www.me.ucsb.edu/~moehlis/APC591/tutorials/tutorial7/node2.html"> </a> </li><li> <a href="https://ru.wikipedia.org/wiki/%25D0%2591%25D1%2580%25D0%25BE%25D1%2583%25D0%25BD%25D0%25BE%25D0%25B2%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D0%25BC%25D0%25BE%25D1%2581%25D1%2582"> </a>   </li><li> <a href="https://ccrma.stanford.edu/~jos/log/">     (Julius Smith)   </a> ,       </li><li> <a href="http://www.gamasutra.com/view/feature/131507/a_realtime_procedural_universe_.php%3Fprint%3D1">    </a> </li><li> <a href="http://www.stuffwithstuff.com/robot-frog/3d/hills/">     </a> </li><li> <a href="http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html">    </a> </li><li> <a href="http://notch.tumblr.com/post/3746989361/terrain-generation-part-1"> Notch'    Minecraft</a> ‚Äî         ,       ,      ,      <a href="http://libnoise.sourceforge.net/examples/worms/"> </a> </li><li> <a href="http://accidentalnoise.sourceforge.net/minecraftworlds.html">  3D-</a> </li><li> <a href="http://www.gamedev.net/blog/33/entry-2138456-seamless-noise/">   2D-</a> ‚Äî    2D-    2D-  4D- </li></ul></div><p>Source: <a href="https://habr.com/ru/post/321874/">https://habr.com/ru/post/321874/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../321862/index.html">Distracted about input / output arguments</a></li>
<li><a href="../321864/index.html">OpenResty: we turn NGINX into a full-fledged application server</a></li>
<li><a href="../321868/index.html">Exceptions in Windows x64. How it works. Part 1</a></li>
<li><a href="../321870/index.html">"Neuromorphic chips": a different look at machine learning</a></li>
<li><a href="../321872/index.html">GameDev from scratch: From the hackathon to your own game development studio. Part 1</a></li>
<li><a href="../321876/index.html">Terminal Server User Authentication on FirePOWER</a></li>
<li><a href="../321878/index.html">UX: Why too much advertising is not user friendly</a></li>
<li><a href="../321880/index.html">Google launched the beta version of Cloud Spanner - NewSQL DBMS generation</a></li>
<li><a href="../321882/index.html">Install MLDonkey and DC ++ plugin for it</a></li>
<li><a href="../321884/index.html">PyNSK # 12 - February meeting of the Pitonists of Novosibirsk</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>