<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust disciplining programming language</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, dear readers! 

 Life does not stand still, and here in O'Reilly we thought about publishing the first fundamental book on the Rust programming...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust disciplining programming language</h1><div class="post__text post__text-html js-mediator-article">  Hello, dear readers! <br><br>  Life does not stand still, and here in O'Reilly we thought about publishing the first fundamental book on the Rust programming language: <br><br><img src="https://habrastorage.org/files/470/32d/a1a/47032da1a9864456b5bc0f97175cde70.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Interested in this topic, we decided to submit for translation the translation of the review article about the Rust language published in December 2014.  The article is slightly shortened, given that some of its passages are already outdated, but the author views the language well in the context of existing alternatives, emphasizes its (unconditional) merits and (conditional) shortcomings. <br><br>  However, in order to make it even more interesting, we will leave a link to another article about Rust, published in one of our favorite Russian-language programming blogs, in the commentary to this article.  For a start - go under the cat. <br><br><a name="habracut"></a><br><br>  <i>Disclaimer: The taste for programming languages ‚Äã‚Äãis a very subjective matter, like this post.</i>  <i>Take it with healthy skepticism</i> . <br><br>  Recently, several new programming languages.  Among them, I was particularly interested in <a href="https://www.rust-lang.org/">Rust</a> .  Below I will share my impressions of Rust and compare it with several other programming languages. <br><br>  <b>Barrier in the study of Rust</b> <br><br>  I met Rust not on the first try.  When learning this language there are several barriers, in particular: <br><br><ol><li>  <b>The language is changing rapidly</b> .  In Rust, there is no "generous lifelong dictator."  The language is developed thanks to the contributions of the participants in the core team and community </li><li>  Given the first point, the <b>Rust training materials are very scarce</b> .  There is a <a href="http://doc.rust-lang.org/book/README.html">manual</a> , <a href="http://doc.rust-lang.org/index.html">other official documentation</a> and the <a href="http://rustbyexample.com/">Rust by Example</a> website are excellent resources.  However, Rust is much more complicated.  Often, we have to study RFCs, blogs, and even comments on Github in order to find the necessary information, and even if this information appeared just yesterday, it is still not completely certain.  I look forward to a good, authoritative book on Rust, although, I bet, it will be voluminous. </li><li>  <b>The ownership system and borrowing checker in Rust can confuse newbies</b> .  To ensure memory safety without garbage collection, Rust uses an intricate system of borrowing and possession.  Often she scares away the neophytes. </li><li>  <b>Rust compiler is very strict</b> .  I call Rust a disciplining language.  Everything that is not quite clear for the Rust compiler, you should specify on your own, and at first you don‚Äôt know some of your intentions yourself.  This learning barrier, coupled with everyone else, often leads to the fact that the first impression of Rust turns out to be discouraging. </li></ol><br><br>  <b>Virtues</b> <br><br>  Rust has many virtues.  Some of them are unique. <br><br>  <i><b>Memory safety without garbage collection</b></i> <br><br>  Perhaps this is the most important achievement of Rust.  In low-level programming languages ‚Äã‚Äãthat allow direct manipulation of memory, errors such as the use of freed memory (use-after-free) or memory leaks during execution are quite expensive.  In modern C ++, the ability to deal with such things has improved, but they imply strict technical discipline (read: programmers continue to perform unsafe operations).  Accordingly, in my opinion, in general, C ++ cannot fundamentally and reliably solve this problem. <br><br>  Indeed, Rust programmers can write unsafe code in an unsafe block, but (1) this is done consciously and (2) unsafe blocks can only be a very small fraction of the entire code base, and they are strictly controlled. <br>  The garbage collector is the most common tool for memory security.  If you get along with GC, then you have plenty of options.  However, the ownership system used in Rust provides not only memory security, but also data and resource security (see below) <br><br>  <i><b>RAII and resources</b></i> <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D1%2581%25D1%2583%25D1%2580%25D1%2581%25D0%25B0_%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">RAII</a> (getting a resource is initialization) is a strange term, but it conveys well the idea embedded in it.  In Wikipedia, we read that RAII works with objects allocated on the stack.  Rust's owning system allows this principle to be applied to objects allocated on the heap.  Due to this, the automatic release of resources - for example, memory, files, sockets - becomes well predictable and guaranteed at compile time. <br>  There are similar possibilities in dynamic languages ‚Äã‚Äãlike Python or Ruby, but they are not as powerful as Rust IMO. <br><br>  <i><b>Competition without data races</b></i> <br><br>  Rust ensures data security in competitive programming ‚Äî that is, it ensures that at any given time, only a large number of readers or a single ‚Äúrecorder‚Äù can access the data. <br><br>  <i><b>Algebraic data type</b></i> <br><br>  In addition to the usual types (tuples and structures), Rust also provides enumerated types (here they are called "types-sums" or "variant types") and pattern matching.  It's amazing that a language for system programming has such an advanced type system. <br><br>  <i><b>Composition takes priority over inheritance</b></i> <br><br>  In Rust, type composition is clearly preferred to inheritance.  I belong to the camp where this fact is considered advantageous.  With the support of generic types in Rust, the key role is played by types. <br><br>  <b>Disadvantages (conditional)</b> <br><br>  <i><b>Everything should be very clear.</b></i> <br><br>  Rust is a disciplining language.  The compiler needs to report everything very clearly, or it will swear until there are no unexplained moments.  As a rule, this benefits the quality of the code, but may be redundant if we are talking about rapid prototyping or one-time tasks. <br><br>  As a result: you have to write better and clearer code on Rust.  Once this is learned, the rough edges can more or less disappear. <br><br>  <b><i>Garbage collection is secondary</i></b> <br><br>  Rust has the simplest garbage collector: Rc, reference counting and Arc, atomic reference counting without looping detection.  However, these features do not work in the default language, and you will have to use the standard Rust memory management mechanisms (stack, &amp; and Box) more often.  If the memory problems in your application are not significant, then you will have to suffer a Rust-based memory security model, where the garbage collector is not used. <br><br>  <i><b>Expressiveness is not an end in itself</b></i> <br><br>  Rust language does not bother about the expressiveness and beauty of the code.  In this regard, it is definitely not bad, but not as wonderful as you might like. <br><br>  <i><b>Relatively high entry barrier</b></i> <br><br>  In principle, Rust is not one of those languages ‚Äã‚Äãthat can be quickly mastered and after a few weeks writing professional code.  Perhaps Rust is more compact than C ++, but definitely more than many programming languages.  Compared to other languages, it cannot be called too accessible.  This can be a problem if your priority is the speed of learning a language. <br><br>  <b>Rust and other languages</b> <br><br>  <i><b>Dynamic languages</b></i> <br><br>  Dynamic (scenario) languages ‚Äã‚Äãare located on the opposite end of the spectrum of programming languages ‚Äã‚Äãfrom Rust.  Compared to Rust, writing code in dynamic languages ‚Äã‚Äãis usually faster and easier.  I think dynamic languages ‚Äã‚Äãwin Rust in such situations: <br><br><ul><li>  Rapid prototyping or one-time tasks </li><li>  The code is not for production, or one where an error during execution is a small problem </li><li>  Own (individual) project </li><li>  Semiautomatic work (eg parsing / log analysis, batch processing) </li><li>  Etc. </li></ul><br><br>  In such cases, you should not try to do everything perfectly.  On the contrary, Rust, in my opinion, is better suited for: <br><br><ul><li>  Work in a medium or large team </li><li>  A code based on long-term use in production </li><li>  A code that will be used for a long time requires regular support and / or refactoring. </li><li>  Code for which security you would write a lot of unit tests </li></ul><br><br>  In general, when the quality of the code is critical.  Dynamic languages ‚Äã‚Äãhelp to write code faster at the initial stage, but later the work is slowed down: you have to write more tests, the development line is broken, or even production interruptions occur.  The Rust compiler forces you to do many things right at compile time, when it is not so expensive to detect and fix bugs. <br><br>  <i><b>Go</b></i> <br><br>  Comparing these two languages ‚Äã‚Äãis an excellent reason to argue, but since I studied <a href="http://golang.org/">Go</a> for a while, I‚Äôll still share here my subjective impressions of it.  Compared to Rust, this is what I like about Go: <br><br><ul><li>  lightness - the language is small (and simple, while very powerful) </li><li>  utility gofmt - significantly reduces the mental burden when programming </li><li>  goroutine / channel </li><li>  Instant compilation </li></ul><br><br>  Why I tied up with Go: <br><br><ul><li>  He is too minimalistic.  The type system and the language itself are not very extensible. </li><li>  Go programming seems a bit dry to me.  It resembles the days when I programmed in Java: it is well suited for corporate development, mechanistic and ... not so interesting (I remind you: there is no argument about tastes) </li><li>  Go's popularity is maintained thanks to the support of Google, but it gives me some skepticism.  When the interests of the community and the company do not match, they can be the first to donate.  Of course, any company pursues first of all its own interests.  There is nothing wrong.  It's just ... a little annoying.  (Many languages ‚Äã‚Äãand frameworks promoted by corporations face a similar problem. At least Mozilla is not dependent on stock quotes). </li></ul> <br><br>  <i><b>Nim</b></i> <br><br>  <a href="http://nim-lang.org/index.html">Nim</a> (formerly called Nimrod) is a very interesting language.  It compiles to C, so its performance is quite good.  Outwardly, it resembles Python, a language I always like to program.  It is a language with garbage collection, but it provides mild real-time support, and the very behavior of the garbage collector is more predictable.  It has an interesting system of effects.  In principle, I really like this language. <br><br>  The biggest problem in his case is the immaturity of the ecosystem.  The language itself is well developed and relatively stable, but at the present time this is far from enough for the programming language to succeed.  Documentation, standard libraries, package repositories, supporting frameworks, community participation and third-party developers ... it's not easy to bring all this to readiness for production. <br><br>  Without specialists who would be engaged in completion of the language in full time, this last stage can be very exhausting.  Among the new programming languages ‚Äã‚ÄãNim still can not boast of serious support. <br>  At the same time, I wish him success and still follow him. <br><br>  <i><b>Other</b></i> <br><br>  There are other languages ‚Äã‚Äãlike <a href="http://julialang.org/">Julia</a> and <a href="http://dlang.org/">D.</a>  Julia is a dynamic language with good performance and smooth C style calls. (If you like dynamic languages ‚Äã‚Äãand REPL, pay attention).  Julia attracted everyone‚Äôs attention thanks to its numerical and scientific fields.  Although it may become a general-purpose language, it seems to me that the development of this language is significantly influenced by the community of its founders. <br><br>  D, at least initially, was an attempt to create "C ++, only better."  His version 1.0 was released in 2007, so this language is not so new.  This is a good language, but for objective reasons, it has not yet got accustomed: the case of splitting Phobos / Tango at an early stage, and ensuring memory safety primarily through garbage collection, and in the original positioning as a replacement for C ++. <br><br>  <b>Why do I think the chances of Rust are pretty high</b> <br><br>  Nowadays there are so many new programming languages.  What, in my opinion, among them stands Rust?  I will cite the following reasons: <br><br>  <i><b>This language for system programming</b></i> <br><br>  Embeddability is no easy task.  Perhaps, it is solved literally in several languages, or even just two: C and C ++.  (Perhaps that is why <a href="https://www.skylight.io/">Skylight</a> chose Rust to develop an extension for Ruby, although it was extremely risky.) It is noteworthy how well Rust managed to <a href="https://github.com/rust-lang/rust/pull/19654">get rid</a> of the execution time costs.  This opens up a unique perspective for Rust. <br><br>  <i><b>No null</b></i> <br><br>  A null object / pointer (the so-called " <a href="https://en.wikipedia.org/wiki/Pointer_%2528computer_programming%2529">billion-dollar error</a> ") is a common source of runtime errors.  There are only a few programming languages ‚Äã‚Äãin which null is missing, mostly functional languages.  The fact is that getting rid of null requires a very advanced type system.  As a rule, to cope with this at the syntactic level of a language, an algebraic data type and pattern comparison are required. <br><br>  <i><b>Low level language with advanced high level constructs</b></i> <br><br>  Being up to the core "language on bare metal" (at least <a href="https://github.com/pczarn/rustboot">theoretically</a> ), Rust also offers many relatively high-level features, including the algebraic data type, pattern comparison, type, type inference, etc. <br><br>  <i><b>Strong community and practical relevance</b></i> <br><br>  The Rust community is very friendly and active.  (Of course, this is a subjective impression).  In addition, Rust has been used in some serious practical projects - it is, in particular, the compiler Rust, <a href="https://github.com/servo/servo/">Servo</a> , Skylight, etc.  still at the stage of language development. <br><br>  <i><b>Until now - without major errors</b></i> <br><br>  At times, the development of a language or framework within the company may accidentally come to a standstill.  Fortunately, the main Rust team is doing an excellent job so far.  Keep it up, Rust! <br><br>  <b>Rust for web development</b> <br><br>  If Rust is a system programming language, is it suitable for web development?  I am looking for an answer to this question. <br><br>  <b><i>Libraries and frameworks</i></b> <br><br>  First of all, some HTTP libraries must be ready for this.  (This is discussed on the site <a href="http://arewewebyet.com/">‚ÄúAre we web yet‚Äù</a> ).  The first <a href="http">rust-http</a> library is out of date;  her potential heiress <a href="http://teepee.rs/">Teepee is</a> practically in anabiosis.  Fortunately, <a href="https://github.com/hyperium/hyper">Hyper</a> seems like a good candidate.  It is already <a href="http://blog.servo.org/2014/12/09/twis-14/">accepted</a> in Servo, a symbiotic project of Rust, I regard this as a blessing for the role of the HTTP library for Rust. <br><br>  The standard Rust library does not yet support asynchronous I / O.  For this purpose, you can use the <a href="https://github.com/carllerche/mio">mio</a> external library, which provides non-blocking socket I / O.  Support for green flows has been eliminated as part of simplifying I / O. <br><br>  Several Rust web frameworks are being actively developed, including <a href="https://github.com/iron/iron/">Iron</a> and <a href="http://nickel.rs/">nickel.rs</a> .  It may take time before the situation settles. <br><br>  <i><b>Rust - language for the web?</b></i> <br><br>  Someday libraries and frameworks will be ready.  The question is, is Rust itself suitable for web development?  Are the low-level capabilities of Rust related to memory management and security not too complex? <br><br>  I think in the end it all depends on what you expect from the project.  Above, comparing Rust with dynamic languages ‚Äã‚Äãin short-term projects, I mentioned that in such cases the complexity of Rust may be unjustified.  But if you expect the product to survive for a long time - say, six months or more - then Rust can be a good option. <br><br>  <b><i>Is Rust suitable for web startups?</i></b> <br><br>  What about startups?  They require rapid prototyping and development cycles.  This is a more ambiguous question, but I remain unconvinced: if you are counting on a long-term project, then it is important to choose the right programming language, and Rust deserves special attention.  From a business point of view, a language that provides rapid prototyping offers significant advantages, while refactoring and eliminating bottlenecks can always be left for later.  Engineering reality is such that the cost of refactoring is usually higher than it seems, and even if you shake up a lot of elements of your system, the code written sometime ago will still remain in some corner.  For years to come. <br><br>  <b>Try Rust!</b> <br><br>  Still, I recommend to get acquainted with Rust.  For now, roughness is possible with him, but I am sure that they will soon disappear. </div><p>Source: <a href="https://habr.com/ru/post/267203/">https://habr.com/ru/post/267203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../267193/index.html">News from the front about licensing products JetBrains</a></li>
<li><a href="../267195/index.html">IBM and Xerox: Mobile Devices Will Soon Be Driven By Thought</a></li>
<li><a href="../267197/index.html">About UEFI security, part two</a></li>
<li><a href="../267199/index.html">Alibaba launches productive and energy efficient data center</a></li>
<li><a href="../267201/index.html">How Netflix Finds Failed Servers</a></li>
<li><a href="../267205/index.html">Regular expressions in Java using the example of an email address</a></li>
<li><a href="../267207/index.html">"Wooden" data center group Inoventica</a></li>
<li><a href="../267209/index.html">Microsoft will release its own Linux distribution</a></li>
<li><a href="../267211/index.html">Updating Russian documentation for Firebird 2.5 and beta documentation for Firebird 3.0</a></li>
<li><a href="../267217/index.html">How I participated in the Sberbank competition about predicting customer churn</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>