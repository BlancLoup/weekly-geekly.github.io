<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Full text search in web projects: Sphinx, Apache Lucene, Xapian</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Full author's version of my blog . The original material was written specifically for Developers.org.ua 

 Probably any modern web project is hard to ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Full text search in web projects: Sphinx, Apache Lucene, Xapian</h1><div class="post__text post__text-html js-mediator-article">  <font>Full <a href="http://abrdev.com/%3Fp%3D380">author's version of my blog</a> .</font>  <font><a href="http://www.developers.org.ua/archives/aleks_raiden/2008/07/24/full-text-search-engines-overview-sphinx-apache-lucene-xapian/">The original material was written specifically for <strong>Developers.org.ua</strong></a></font> <br><br><img src="https://habrastorage.org/getpro/habr/olpictures/510/f37/4b0/510f374b0e988c18390f8a154a20d96b.jpg" width="128" height="128" hspace="10" vspace="10" align="left">  Probably any modern web project is hard to imagine without ... without content!  Yes, it is the content in its various manifestations that ‚Äúrules the ball‚Äù in various web projects today.  Not so important - automatically created by users or obtained from other sources - information is the main of any (well, or almost any) project.  And if so - then the question of finding the necessary information is very serious.  And more acutely every day, due to the rapid expansion of the amount of this very content, mainly due to user-generated (these are forums, blogs and fashionable communities today, like <a href="http://habrahabr.ru/">Habrahabr.ru</a> ).  Thus, any developer implementing a project today faces the need to implement a search in their web application.  At the same time, the requirements for such a search are much more complicated and wider than even a year or two ago.  Of course, a simple solution is quite suitable for some projects, for example, it is possible to use Custom Google Search.  But the more complex the application, and the more complex the content structure, if you need special types of search and result processing, or just the amount or format of the data in your project is special, you need your own search engine.  It is its own system, its own search server or service, and not a third-party, even if it is flexible and customizable.  But what to choose, and in general - what are the current search projects on the market that are ready for use in real projects, not research or scientific, but real business applications?  Next, we will briefly review various options for search solutions suitable for embedding into your web application or deploying on your own server. <br><a name="habracut"></a><br>  <b>General architecture and terms</b> <br><br>  And so, for a deeper understanding of the essence of the search, we will try to briefly get acquainted with the used concepts and terms.  By a search server (or simply ‚Äúsearch engine‚Äù), we mean a library or component, in general, a software solution that independently maintains its database (in fact, it can be a DBMS, or just files and a distributed storage platform) of documents in which in fact, the search takes place, provides third-party applications to add, delete and update documents in this database.  This process is called indexing, and can be implemented as a separate component or server (indexer).  The other component, namely the search engine, accepts a search request and processes the database created by the indexer and selects data that matches the query.  In addition, it can calculate additional parameters for search results (rank documents, calculate the degree of compliance with the search query, etc.).  These are the most important search engine systems, and they can be both monolithically implemented in a single library, or they can be independent servers, access to which is realized through various application protocols and APIs.  Additionally, the search server can be used to pre-process documents before indexing (for example, extracting text from files of various formats or databases), various APIs can also be implemented by additional components.  The server itself can store its index data in the database (both built-in and using an external server, for example, MySQL), in the form of files of its own optimized format, or even use a special distributed file system. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Separately, I would highlight the presence of a web search implementation module.  That is, the built-in ability to retrieve documents from web sites via HTTP protocol and index them in the search server can be implemented.  This module is usually called ‚Äúspider‚Äù or ‚Äúcrawler‚Äù, and thus, the search server may already be similar to the ‚Äúreal‚Äù and familiar to everyone search like Google or Yandex.  So you can implement your own search engine on the sites you need, for example, dedicated to one topic - just create a list of addresses and configure their periodic traversal.  However, this task is much more complex and serious, both technically and organizationally, so we do not dwell on the details of its implementation.  Among the projects that we will consider, there is one server, namely the implementing web search engine, that is, it contains everything needed to create a ‚ÄúYandex killer‚Äù.  Interesting? <br><br>  <strong>What parameters are important?</strong> <br><br>  When choosing a search engine, consider the following parameters: <br><ul><li>  <strong>indexing speed</strong> ‚Äî that is, how quickly the search server ‚Äúgrinds‚Äù documents and puts them in its index, making search available for them.  Usually measured in megabytes of clear text per second. </li><li>  <strong>speed of reindexing</strong> - in the process of working documents change or are added new, so you have to re-index the information.  If the server supports incremental indexing, then we process only new documents, and leave updating the entire index for later or even not at all.  Other servers require a complete restructuring of the index when adding new information, or use additional indexes (delta index), which includes only new information </li><li>  <strong>Supported APIs</strong> - if you use a search engine in conjunction with a web application, pay attention to the presence of a built-in API for your language or platform.  Most search engines have API for all popular platforms - Java, PHP, Ruby, Phyton </li><li>  <strong>supported protocols</strong> - besides the API, access protocols are important, in particular, if you want to access from another server or application that does not have a native API.  XML-RPC (or variations such as JSON-RPC), SOAP, or access via http / socket are usually supported. </li><li>  <strong>database size and search speed</strong> - these parameters are very interrelated and if you implement something unique and provide that you can have millions and more documents in the database for which you need to perform an instant search, then look at the known implementations of the chosen platform.  Although no one states explicitly about the limitations on the number of documents in the databases, and in small collections (for example, several thousand or tens of thousands of documents), all search engines will be about the same, but if we are talking about millions of documents, this can be a problem.  By the way, by itself, this parameter does not always matter, you need to look at the features of each system and the algorithms for working with search, as well as other parameters, such as the speed of reindexing or possible types of indexes and their storage system. </li><li>  <strong>supported document types</strong> - of course, any server supports plain text (although you should look at the ability to work with multilingual documents and UTF-8 encoding), but if you need to index different file types, for example, HTML, XML, DOC or PDF, then you should see solutions where there is a built-in component for indexing various formats and extracting text from them.  Of course, all this can be done right in your application, but better to find ready-made solutions.  This also includes support for indexing and searching information stored in a DBMS - it‚Äôs not a secret that such storage is the most common for web applications, and it‚Äôs better that the search server works directly with the database, without the need to manually extract and ‚Äúfeed‚Äù documents to it for indexing. </li><li>  <strong>work with different languages ‚Äã‚Äãand stemming</strong> - for correct search using different languages, you need native support not only of encodings, but also work with language features.  All support the English language, which is quite simple for search and processing, but for Russian and other similar ones, it is necessary to use automatic tools to ensure morphology.  Stemming module allows you to convince and parse words in a search query for a more correct search.  If the search in Russian is critical for you, pay attention to the presence of this module and its features (of course, manual stemming is better than automatic, but more difficult, although automatic ones are very different). </li><li>  <strong>support for additional field types in documents</strong> - in addition to the text itself, which is indexed and searched, it is necessary to have an unlimited number of other fields in the document that can store meta-information about the document, which is necessary for further work with the search results.  It is highly desirable that the number and types of fields are not limited, and the indexability of the fields can be customized.  For example: in one field the name is stored, in the second - the abstract, in the third - keywords, in the fourth - the document identifier in your system.  It is necessary to flexibly adjust the search area (in each field or in the specified ones), as well as those fields that will be retrieved from the search engine database and displayed in the search results. </li><li>  <strong>platform and language</strong> are just as important, though to a lesser extent.  If you are going to allocate the search to a separate module from the application or server, or even take it to a separate server (iron in the sense), then the role of the platform is not that big.  This is usually either C ++ or Java, although there are options for other languages ‚Äã‚Äã(usually solution ports in java). </li><li> <strong>the presence of built-in mechanisms for ranking and sorting</strong> is especially good if the search engine can be expanded (and it is written in a language you know) and write the implementations of these functions you need, because there are so many different algorithms, and it‚Äôs not a fact that the default search engine is right for you . </li></ul><br>  Of course, there are still a lot of different parameters, and the data search area itself is quite complex and serious, but for our applications this is quite enough.  You do not make a competitor to Google? <br><br>  Now briefly tell about those search solutions that you should pay attention to, only you decide to start the issue of search.  I intentionally do not consider the solution built into your DBMS - FULLTEXT in MySQL and FTS in PostgreSQL (integrated into the database from the version, if not mistaken, 8.3).  In MySQL, the solution cannot be used for serious search, especially for large amounts of data, the search in PostgreSQL is much better, but only if you already use this database.  Although, as an option - to install a separate database server and there only use data storage and search is also an option.  Unfortunately, I do not have on hand data on real-world applications for large amounts of data and complex queries (units and tens of GB of text). <br><br><img src="https://habrastorage.org/getpro/habr/olpictures/f58/1fb/87a/f581fb87a34560313869afaea301512b.jpg" width="200" height="51" hspace="10" vspace="10" align="left"><br>  <strong>Sphinx search engine</strong> <br><ul><li>  <strong>Type</strong> : separate server, MySQL storage engine </li><li>  <strong>Platform</strong> : C ++ / cross-platform </li><li>  <strong>Index</strong> : monolithic + delta index, the possibility of distributed search </li><li>  <strong>Search capabilities</strong> : Boolean search, phrase search, etc.  with the ability to group, rank and sort the result </li><li>  <strong>APIs and protocols</strong> : SQL DB (as well as native support for MySQL and PostgreSQL), native XML interface, built-in APIs for PHP, Ruby, Python, Java, Perl </li><li>  <strong>Language support</strong> : built-in English and Russian stemming, soundex to implement morphology </li><li>  <strong>Additional fields</strong> : yes, unlimited </li><li>  <strong>Document Types</strong> : Text Only or Native XML Format </li><li>  <strong>Index size and search speed</strong> : very fast, indexing about 10 Mb / s (depending on CPU), search about 0.1 sec / ~ 2 - 4 GB index, supports index sizes of hundreds of GB and hundreds of millions of documents (this is if you do not use clustering) However, there are examples of works on terabyte databases. </li><li>  <strong>License</strong> : open source, GPL 2 or commercial. </li><li>  <strong>URL</strong> : <a href="http://sphinxsearch.com/">http://sphinxsearch.com</a> </li></ul><br>  <strong>Sphinx is</strong> probably the most powerful and fastest of all open engines we‚Äôll look at.  It is especially convenient in that it has direct integration with popular databases and supports advanced search capabilities, including ranking and stemming for Russian and English.  It seems that the project has excellent support for the Russian language due to the fact that the author is our compatriot, <strong>Andrei Aksenov</strong> .  Non-trivial features like distributed search and clustering are supported, but the company's feature is a very, very high indexing and search speed, as well as the ability to perfectly parallelize and utilize the resources of modern servers.  Very serious installations are known that contain terabytes of data, so Sphinx can be recommended as a dedicated search engine for projects of any level of complexity and data volume.  Transparent work with the most popular MySQL and PostgreSQL databases allows you to use it in a typical web development environment, and there is also an API out of the box for different languages, primarily for PHP without the use of additional modules and extension libraries.  But the search engine itself must be compiled and installed separately, so on a regular hosting it is not applicable - only VDS or its own server, and, preferably, more memory.  The index of the search engine is monolithic, so you have to ‚Äúpervert‚Äù a little by adjusting the delta index to work correctly when there are a lot of new or modified documents, although the huge indexing speed allows you to organize the restructuring of the index on a schedule and this does not affect the actual search. <br><br>  <strong>SphinxSE</strong> is a version that functions as a data storage engine for MySQL (requires a patch and recompiles the base), <strong>Ultrasphinx</strong> is a configurator and client for Ruby (except for the API present in the distribution), except for this there are plug-ins for many well-known CMS b blog platforms, wikis which replace the standard search (see the full list here: <a href="http://www.sphinxsearch.com/contribs.html">http://www.sphinxsearch.com/contribs.html</a> ) <br><br><img title="lucene_green_300" src="http://abrdev.com/wp-content/uploads/2008/08/lucene_green_300.gif" width="300" height="46"><br>  <strong>Apache Lucene Family</strong> <br><ul><li>  <strong>Type</strong> : single server or servlet, embedded library </li><li>  <strong>Platform</strong> : Java / cross-platform (there are ports in many languages ‚Äã‚Äãand platforms) </li><li>  <strong>Index</strong> : incremental index, but requiring the operation of merging segments (can be parallel with the search) </li><li>  <strong>Search capabilities</strong> : boolean search, phrase search, fuzzy search, etc.  with the ability to group, rank and sort the result </li><li>  <strong>API and Protocols</strong> : Java API </li><li>  <strong>Language support</strong> : no morphology, stemming (Snowball) and analyzers for a number of languages ‚Äã‚Äã(including Russian) </li><li>  <strong>Additional fields</strong> : yes, unlimited </li><li>  <strong>Document types</strong> : text, database indexing via JDBC possible </li><li>  <strong>Index size and search speed</strong> : about 20 MB / minute, the size of index files is limited to 2 GB (on 32-bit OS).  There are parallel search capabilities across multiple indexes and clustering (requires third-party platforms) </li><li>  <strong>License</strong> : open source, Apache License 2.0 </li><li>  <strong>URL</strong> : <a href="http://lucene.apache.org/">http://lucene.apache.org/</a> </li></ul><br>  <strong>Lucene</strong> - the most famous of the search engines, initially focused on embedding it into other programs.  In particular, it is widely used in Eclipse (search documentation) and even in IBM (products from the OmniFind series).  The advantages of the project include advanced search capabilities, a good system for building and storing an index, which can simultaneously be replenished, documents are deleted and optimized along with the search, as well as parallel search across multiple indices and combining the results.  The index itself is built from segments, but in order to improve speed, it is recommended to optimize it, which often means almost the same costs as for re-indexing.  Initially, there are variants of analyzers for different languages, including Russian with the support of stemming (bringing words to normal form).  However, the minus is still a low indexing speed (especially in comparison with Sphinx), the complexity of working with databases and the absence of an API (except for native Java).  And although to achieve serious performance, Lucene can cluster and store indexes in a distributed file system or database, this requires third-party solutions, as well as for all other functions ‚Äî for example, initially it can index only plain text.  But it is precisely in terms of using ‚ÄúLucene ahead of the rest‚Äù as part of third-party products - for no other engine there are so many ports to other languages ‚Äã‚Äãand uses.  One of the factors behind this popularity is the very good format of index files that third-party solutions use, so it is possible to build solutions that work with the index and search, but do not have their own indexer (this is easier to implement and the requirements are much lower). <br><br><img src="https://habrastorage.org/getpro/habr/olpictures/846/e18/b14/846e18b1413580a1a25d15eb9a65bb2d.png" width="142" height="61" hspace="10" vspace="10" align="left">  <strong>Solr</strong> - the best solution based on Lucene, significantly expanding its capabilities.  This is a standalone enterprise-level server that provides extensive search capabilities as a web service.  Solr standardly accepts HTTP documents in XML format and returns the result also via HTTP (XML, JSON or another format).  Clustering and replication to several servers are fully supported, support for additional fields in documents is expanded (unlike Lucene, various standard data types are supported for them, which brings the index closer to databases), facet search and filtering support, advanced configuration and administration tools, and also the possibility of backup index in the process.  Embedded caching also improves performance.  On the one hand, this is an independent solution based on Lucene, on the other - its capabilities are very significantly expanded relative to the base ones, so if you need a separate search server, pay attention first to Solr. <br><br><img src="https://habrastorage.org/getpro/habr/olpictures/5c9/e2f/eda/5c9e2feda4052147a896a40646e7b5fd.gif" width="121" height="48" hspace="10" vspace="10" align="left">  <strong>Nutch</strong> is the second most famous project based on Lucene.  This is a web search engine (a search engine + a web spider for crawling websites) combined with a <a href="http://hadoop.apache.org/">distributed Hadoop storage system</a> .  Nutch "from the box" can work with remote nodes on the network, indexes not only HTML, but also MS Word, PDF, RSS, PowerPoint and even MP3 files (meta tags, of course), in fact it is a full-fledged search engine-killer Google.  Just kidding, the payback for this is a significant reduction in functionality, even the basic of Lucene, for example, Boolean operators are not supported in the search, and no stemming is used.  If the task is to make a small local search engine for local resources or a limited set of sites in advance, you need full control over all aspects of the search, or you create a research project to test new algorithms, in which case Nutch will be your best choice.  However, take into account its requirements for hardware and a wide channel - for a real web search engine, traffic goes to terabytes. <br><br>  Do you think no one uses Nutch as an ‚Äúadult‚Äù?  You are mistaken - one of the most famous projects that you could hear about, it is used by the search engine for the source codes <strong>Krugle</strong> ( <a href="http://krugle.com/">http://krugle.com/</a> ). <br><br>  But not only due to add-on projects, Lucene is known and popular.  Being a leader among open source solutions and embodying many excellent solutions, Lucene is the first candidate for porting to other platforms and languages.  Now there are the following ports (I mean those that are more or less actively developing and the most complete ports): <br><ul><li>  <strong>Lucene.Net</strong> is the full Lucene port, fully algorithmic, with classes and API identical porting to MS.NET/Mono and C # language.  While the project is in the incubator, and the last release is dated April 2007 (port of the final 2.0 version).  <a href="http://incubator.apache.org/lucene.net/">Project page</a> . </li><li>  <strong>Ferret</strong> - <a href="http://ferret.davebalmain.com/trac/">port to Ruby language</a> </li><li>  <strong>CLucene</strong> is a C ++ version that promises a significant performance boost.  According to some tests, it is 3‚Äì5 times faster than the original, and sometimes more (by indexing, the search is comparable or faster by only 5‚Äì10%).  It turned out that this version uses a large number of projects and companies - ht: // Dig, Flock, Kat (search engine for KDE), BitWeaver CMS and even companies such as Adobe (search documentation) and Nero.  <a href="http://clucene.sourceforge.net/">Project page</a> </li><li>  <strong>Plucene</strong> - <a href="http://search.cpan.org/search%3Fquery%3Dplucene%26amp%3Bmode%3Dall">Perl implementation</a> <br></li><li>  <strong>PyLucene</strong> is an <a href="http://pylucene.osafoundation.org/">implementation for Python applications</a> , but not complete, and partly requires Java. </li><li>  <strong>Zend_Search_Lucene</strong> is the only port in PHP that is available as part of the Zend Framework.  By the way, it is quite efficient and as an independent solution, outside of the framework, I did experiments and as a result of selecting the entire search engine now takes only 520 KB in a single PHP file.  Project home page: <a href="http://framework.zend.com/manual/en/zend.search.lucene.htm">http://framework.zend.com/manual/en/zend.search.lucene.htm</a> </li></ul><br><img src="https://habrastorage.org/getpro/habr/olpictures/e1a/83c/3d1/e1a83c3d1dfae5d4327e8adfc92a75ec.png" width="400" height="100" hspace="10" vspace="10" align="left">  <strong>Xapian</strong> <br><ul><li>  <strong>Type</strong> : Embedded Library </li><li>  <strong>Platform</strong> : C ++ </li><li>  <strong>Index</strong> : incremental index, transparently updated in parallel with the search, work with several indexes, in-memory indexes for small databases. </li><li>  <strong>Search options</strong> : boolean search, phrase search, ranking search, mask search, synonym search, etc.  with the ability to group, rank and sort the result </li><li>  <strong>API and protocols</strong> : C ++, Perl API, Java JINI, Python, PHP, TCL, C # and Ruby, CGI interface with XML / CSV format </li><li>  <strong>Language support</strong> : there is no morphology, there is a stemming for a number of languages ‚Äã‚Äã(including Russian), spelling check is implemented in search queries </li><li>  <strong>Additional fields</strong> : none </li><li>  <strong>Document types</strong> : text, HTML, PHP, PDF, PostScript, OpenOffice / StarOffice, OpenDocument, Microsoft Word / Excel / Powerpoint / Works, Word Perfect, AbiWord, RTF, DVI, indexing SQL databases through Perl DBI </li><li>  <strong>Index size and search speed</strong> : working installations of 1.5 TB index are known and the number of documents in the hundreds of millions. </li><li>  <strong>License</strong> : open source, GPL </li><li>  <strong>URL</strong> : <a href="http://xapian.org/">http://xapian.org</a> </li></ul><br>  While this is the only contender for competition with the dominance of Lucene and Sphinx, it compares favorably with the presence of a ‚Äúlive‚Äù index that does not require restructuring when adding documents, a very powerful query language, including embedded stemming and even spell checking, as well as support for synonyms.  This library will be the best choice if you have a perl system or you need advanced search engine building capabilities and the index is updated very often, and new documents should be immediately available for searching.  However, I did not find any information about the ability to add arbitrary additional fields to documents and retrieve them with search results, so the connection between the search system and your own can be difficult.  The package includes <strong>Omega</strong> - an add-on library that is ready for use as an independent search engine and is responsible for the ability to index various types of documents and the CGI interface. <br><br>  Perhaps this is where our review can be completed.  Although there are still many search engines, some of them are ports or add-ins above those already reviewed.  For example, an industrial level search server for eZ's own CMS of the company, ezFind is not really a separate search engine, but an interface to the standard Lucene Java and includes it in its delivery.  The same applies to the Search component from their <a href="http://ezcomponents.org/">eZ Components</a> package - it provides a unified interface for accessing external search servers, in particular, it interacts with the Lucene server.  And even such an interesting and powerful solution as <a href="http://project.carrot2.org/">Carrot</a> and <a href="http://www.searchblox.com/">SearchBox</a> are seriously modified versions of the same Lucene, significantly expanded and complemented by new features.  There are not so many independent search solutions with open code that fully implement indexing and search using their own algorithms on the market.  And what decision to choose depends on you and the features, often not at all obvious, of your project. <br><br>  <b>findings</b> <br><br>  Although the final decision to decide whether or not a particular search engine is suitable for your project can only you and, often, only after detailed research and tests, but some conclusions can be drawn now. <br><br>  <strong>Sphinx is</strong> right for you if you need to index large amounts of data in the MySQL database and you are interested in the speed of indexing and searching, but you do not need specific search capabilities like ‚Äúfuzzy search‚Äù and you agree to allocate a separate server or even a cluster for this. <br><br>  If you need to integrate the search module into your application, then the best search is the ready ports for your language to the <strong>Lucene</strong> library - they exist for all common languages, but not all the features of the original can be realized.  If you are developing an application in Java, then Lucene is definitely the best choice.  However, consider sufficient slow indexing and the need for frequent index optimization (and demands on the CPU and disk speed).  For PHP, this seems to be the only acceptable option to fully implement the search without additional modules and extensions. <br><br>  <b>Xapian is</b> quite a good and quality product, but less common and flexible than the rest.  For C ++ applications and requirements for the broad capabilities of the query language, it will be the best choice, but it requires manual refinement and modifications to be embedded in your own code or used as a separate search server. <br><br>  <b>Related Links</b> <br><ul><li>  Sphinx search ( <a href="http://sphinxsearch.com/">http://sphinxsearch.com/</a> ) </li><li>  Apache Nutch ( <a href="http://lucene.apache.org/nutch/">http://lucene.apache.org/nutch/</a> ) </li><li>  Apache Solr ( <a href="http://lucene.apache.org/solr/">http://lucene.apache.org/solr/</a> ) </li><li>  Apache Lucene Java ( <a href="http://lucene.apache.org/">http://lucene.apache.org/</a> ) </li><li>  Apache Lucy ( <a href="http://lucene.apache.org/lucy/">http://lucene.apache.org/lucy/</a> ) </li><li>  Lucene.Net ( <a href="http://incubator.apache.org/lucene.net/">http://incubator.apache.org/lucene.net/</a> ) </li><li>  CLucene ( <a href="http://clucene.wiki.sourceforge.net/">http://clucene.wiki.sourceforge.net/</a> ) </li><li>  List of Lucene ports ( <a href="http://wiki.apache.org/jakarta-lucene/LuceneImplementations">http://wiki.apache.org/jakarta-lucene/LuceneImplementations</a> ) </li><li>  Zend Framework Lucene full PHP port ( <a href="http://framework.zend.com/manual/ru/zend.search.lucene.html">http://framework.zend.com/manual/ru/zend.search.lucene.html</a> ) </li><li>  ezComponents Search ( <a href="http://ezcomponents.org/docs/tutorials/Search">http://ezcomponents.org/docs/tutorials/Search</a> ) </li><li>  ez Find ( <a href="http://ez.no/ezfind">http://ez.no/ezfind</a> ) </li><li>  Xapian ( <a href="http://xapian.org/">http://xapian.org</a> ) </li><li>  OpenFTS ( <a href="http://openfts.sourceforge.net/">http://openfts.sourceforge.net/</a> ) </li><li>  List of Java-based search solutions ( <a href="http://www.manageability.org/blog/stuff/full-text-lucene-jxta-search-engine-java-xml">http://www.manageability.org/blog/stuff/full-text-lucene-jxta-search-engine-java-xml</a> ) </li><li>  DotLucene.net closed ( <a href="http://www.dotlucene.net/">http://www.dotlucene.net/</a> ) </li><li>  Lidia ( <a href="http://www.nttdata.co.jp/en/media/2006/101100.html">http://www.nttdata.co.jp/en/media/2006/101100.html</a> ) </li><li>  Hyper Estraier ( <a href="http://hyperestraier.sourceforge.net/">http://hyperestraier.sourceforge.net/</a> ) </li><li>  Kneobase ( <a href="http://sourceforge.net/projects/kneobase/">http://sourceforge.net/projects/kneobase/</a> ) </li><li>  Egothor ( <a href="http://egothor.sourceforge.net/">http://egothor.sourceforge.net/</a> ) </li><li>  Ferret ( <a href="http://ferret.davebalmain.com/">http://ferret.davebalmain.com/</a> ) </li><li>  OpenGrok ( <a href="http://www.opensolaris.org/os/project/opengrok/">http://www.opensolaris.org/os/project/opengrok/</a> ) </li></ul></div><p>Source: <a href="https://habr.com/ru/post/30594/">https://habr.com/ru/post/30594/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../305924/index.html">Creating your own graph processing application in Giraph</a></li>
<li><a href="../305926/index.html">How to think in SQL?</a></li>
<li><a href="../305932/index.html">Flume - manage data streams. Part 3</a></li>
<li><a href="../305934/index.html">"Hard time management." We talk about the book, Dan Kennedy</a></li>
<li><a href="../305936/index.html">UX Design: Flags and Switches in Forms</a></li>
<li><a href="../305940/index.html">Archiving as an answer to the ‚ÄúSpring package‚Äù</a></li>
<li><a href="../305944/index.html">Tale about a peasant, or how to change dusty "aglitskie" chipset coders</a></li>
<li><a href="../305948/index.html">Mobile UX-Design: How to correctly request user permissions</a></li>
<li><a href="../305950/index.html">The use of cloud technologies in stock trading - features and prospects</a></li>
<li><a href="../305952/index.html">Usability Testing: Do you want to know the truth about your users?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>