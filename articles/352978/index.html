<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Apache Kafka Review</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Today we offer you a relatively brief, but at the same time sensible and informative article about the device and Apache Kafka applicatio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Apache Kafka Review</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  Today we offer you a relatively brief, but at the same time sensible and informative article about the device and Apache Kafka application options.  We expect to translate and release the <a href="https://www.amazon.com/Kafka-Definitive-Real-Time-Stream-Processing/dp/1491936169/">book by</a> Nii Nakhid (Neha Narkhede) et.  al until the end of summer. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pr/xi/6n/prxi6nlbiixyga1iursp8ihxdnw.jpeg"></div><br>  Enjoy reading! <br><a name="habracut"></a><br>  <b>Introduction</b> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Today they talk a lot about Kafka.  Many leading IT companies are already actively and successfully using this tool.  But what is Kafka? <br><br>  Kafka was developed by LinkedIn in 2011 and has since improved significantly.  Today, Kafka is a whole platform providing sufficient redundancy for storing absurdly large amounts of data.  It provides a message bus with colossal bandwidth, where you can process absolutely all data passing through it. <br><br>  All this is cool, however, if you reduce Kafka to a dry residue, <b>you get a distributed, horizontally scalable, fault-tolerant commit log</b> . <br><br>  It sounds wisely.  Let's look at each of these terms and see what it means.  And then we examine in detail how it all works. <br><br>  <b>Distributed</b> <br><br>  A distributed system is a system that, in a segmented form, works simultaneously on a set of machines that form a whole cluster;  therefore, for the end user, they look like a single node.  Distribution Kafka is that the storage, receipt and distribution of messages from him is organized on different nodes (the so-called "brokers"). <br>  The most important advantages of this approach are high availability and fault tolerance. <br><br>  <b>Horizontally scalable</b> <br><br>  Let's first define what vertical scalability is.  Suppose we have a traditional database server, and it gradually ceases to cope with the increasing load.  To cope with this problem, you can simply increase the resources (CPU, RAM, SSD) on the server.  This is <b>vertical scaling</b> - additional resources are hung on the machine.  With this "scaling up" there are two serious drawbacks: <br><br><ol><li>  There are certain limits related to equipment capabilities.  Infinitely can not grow. </li><li>  Such work is usually associated with downtime, and large companies can not afford to downtime. </li></ol><br>  <b>Horizontal scalability</b> solves exactly the same problem, we just get more and more cars involved.  When adding a new machine, no downtime occurs, while the number of machines that can be added to the cluster is unlimited.  The catch is that not all systems support horizontal scalability, many systems are not designed to work with clusters, and those that are designed are usually very difficult to operate. <br><br><img src="https://habrastorage.org/webt/fk/oe/lf/fkoelfgmmdwmj_bvfnmk_om_nc8.png"><br><br>  <i>After a certain threshold, horizontal scaling becomes much cheaper than vertical.</i> <br><br>  <b>fault tolerance</b> <br><br>  Unallocated systems are characterized by the presence of a so-called single point of failure.  If the only server of your database for some reason fails - you are trapped. <br>  Distributed systems are designed in such a way that their configuration can be adjusted, adapting to failures.  The Kafka cluster of five nodes remains operational, even if two nodes fall down.  It should be noted that in order to ensure fault tolerance, it is necessary to partially sacrifice performance, because the better your system tolerates failures, the lower its performance. <br><br>  <b>Commit log</b> <br><br>  The commit log (also referred to as the ‚Äúlead write log‚Äù, ‚Äútransaction log‚Äù) is a long-term ordered data structure, and you can only add data to such a structure.  Entries from this log can neither be modified nor deleted.  Information is read from left to right;  this ensures the correct order of the elements. <br><br><img src="https://habrastorage.org/webt/jm/rn/so/jmrnsoripakapmpsuvgw46xyty4.png"><br>  <i>Commit log layout</i> <br><blockquote>  - Do you mean that the data structure in Kafka is so simple? </blockquote>  In many ways, yes.  This structure forms the very core of Kafka and is absolutely priceless, because it provides orderliness, and orderliness - deterministic processing.  Both of these problems in distributed systems are difficult to solve. <br><br>  In essence, Kafka stores all its messages on disk (more on this below), and when organizing messages in the form of the structure described above, you can use sequential reading from the disk. <br><br><ul><li>  Read and write operations are performed at a constant O (1) time (if the record ID is known), which, compared to O (log N) operations on a disk in a different structure, is an incredible time saver, since each feeding operation is costly. </li><li>  Read and write operations do not affect each other (the read operation does not block the write operation and vice versa, which cannot be said about operations with balanced trees). </li></ul><br>  These two points drastically increase performance, since it is completely independent of the size of the data.  Kafka works equally well, whether you have 100KB or 100TB of data on your server. <br><br>  <b>How does all this work?</b> <br><br>  Applications ( <b>generators</b> ) send messages ( <b>records</b> ) to the Kafka node ( <b>broker</b> ), and the specified messages are processed by other applications, so-called <b>consumers</b> .  These messages are saved in the <b>thread</b> , and consumers subscribe to the thread to receive new messages. <br><br><img src="https://habrastorage.org/webt/dn/2b/ad/dn2badwphvcoceci2b3sshur3fq.png"><br><br>  Topics can grow, so large topics are divided into smaller <b>sections</b> to improve performance and scalability.  (example: <i>let's say you saved user login requests; in this case, you can distribute them by the first character in the user name</i> ) <br><br>  Kafka guarantees that all messages within the section will be ordered exactly in the sequence in which they arrived.  A specific message can be found by its offset, which can be considered a normal index in the array, a sequence number that is incremented by one for each new message in this section. <br><br><img src="https://habrastorage.org/webt/5j/qd/44/5jqd44rmbm_ldgtpvwq9w_ztv-e.png"><br><br>  In Kafka, the principle of "stupid broker - smart consumer" is observed.  Thus, Kafka does not keep track of which records are read by the consumer and then deleted, but simply keeps them for a predetermined period of time (for example, a day), or until a certain threshold is reached.  Consumers themselves questioned Kafka if he had any new messages, and indicate which records they need to read.  Thus, they can increase or decrease the offset by moving to the desired record;  at the same time events can be replayed or re-processed. <br><br>  It should be noted that in reality this is not about single consumers, but about groups, in each of which there is one or more consumer processes.  In order to prevent a situation where two processes could read the same message twice, each section is tied to only one consumer process within a group. <br><br><img src="https://habrastorage.org/webt/n2/94/i8/n294i8icuipdqwaaowevhxxtfcu.png"><br><br>  <i>So the data stream is arranged.</i> <br><br>  <b>Long-term storage on disk</b> <br><br>  As mentioned above, Kafka actually stores its records on disk and does not hold anything in RAM.  Yes, the question is possible, is there any point in this.  But Kafka has many optimizations that make this happen: <br><br><ol><li>  Kafka has a protocol that unites messages into groups.  Therefore, when network requests are, messages are added to groups, which reduces network costs, and the server, in turn, saves a batch of messages in one go, after which consumers can immediately select large linear sequences of such messages. </li><li>  Linear reads and writes to disk occur quickly.  There is a known problem: modern disks work relatively slowly because of the need to supply heads, however, with large linear operations, this problem disappears. </li><li>  These linear operations are highly optimized by the operating system by <b>read ahead</b> (large groups of blocks are selected in advance) and <b>late writing</b> (small logical write operations are combined into large physical write operations). </li><li>  Modern operating systems cache the disk in free RAM.  This technique is called <b>page cache</b> . </li><li>  Since Kafka saves messages in a standardized binary format that does not change throughout the entire chain (generator-&gt; broker-&gt; consumer), zero-copy optimization is appropriate here.  In this case, the OS copies the data from the page cache directly to the socket, practically bypassing the broker application related to Kafka. </li></ol><br>  Thanks to all these optimizations, Kafka delivers messages almost as quickly as the network itself. <br><br>  <b>Data distribution and replication</b> <br><br>  Now let's discuss how fault tolerance is achieved in Kafka and how it distributes data between nodes. <br><br>  <i><b>Data replication</b></i> <br><br>  The data from the segment is replicated to multiple brokers so that the data is saved if one of the brokers fails. <br><br>  In any case, one of the brokers always ‚Äúowns‚Äù the section: this broker is the one on which applications perform read and write operations to the section.  This broker is called the " <b>leading section</b> ".  It replicates the received data to <i><b>N</b></i> other brokers, the so-called <b>slaves</b> .  Data is also stored on the slaves, and any of them can be selected as the master if the current master fails. <br>  This way, you can configure guarantees to ensure that any message that is successfully published is not lost.  When it is possible to change the replication ratio, you can partially sacrifice performance for the sake of increased data protection and durability (depending on how critical they are). <br><br><img src="https://habrastorage.org/webt/z2/iv/bx/z2ivbx1q5ufixsirgmattyzj6aa.png"><br><br>  Thus, if one of the leaders ever fails, the follower can take his place. <br><br>  However, it is logical to ask: <br><blockquote>  - How does the generator / consumer know which broker is leading this section? </blockquote>  In order for the generator / consumer to record / read information in this section, the application needs to know which broker is leading here, right?  This information needs to be taken somewhere. <br><br>  Kafka uses a service called <b>Zookeeper</b> to store such metadata. <br><br>  <b>What is a zookeeper?</b> <br><br>  Zookeeper is a distributed repository of keys and values.  It is highly optimized for reading, but writing to it is slower.  Most often, Zookeeper is used to store metadata and process clustering mechanisms (heart rate, distributed update / configuration operations, etc.). <br><br>  Thus, clients of this service (Kafka brokers) can subscribe to it - and will receive information about any changes that may occur.  This is how brokers will know when a leader in a section changes.  Zookeeper is exceptionally fault tolerant (as it should be), since Kafka depends heavily on it. <br><br>  It is used to store all kinds of metadata, in particular: <br><br><ul><li>  Offset of consumer groups within the section (although modern clients store offsets in a separate Kafka topic) </li><li>  ACL (Access Control Lists) - used to restrict access / authorization </li><li>  Generator and consumer quotas - maximum message limits per second </li><li>  Leading sections and their level of performance </li></ul><br>  <b>How does the generator / consumer determine the lead broker for this section?</b> <br><br>  Previously, the Generator and Consumers directly connected to Zookeeper and learned from him this (and also other) information.  Now Kafka is moving away from such a bundle and, starting, respectively, from versions 0.8 and 0.9, clients firstly select metadata directly from Kafka brokers, and brokers turn to Zookeeper. <br><br><img src="https://habrastorage.org/webt/px/vb/z8/pxvbz8hulnfqq3monzzzyyvv2ve.png"><br><br>  <i>Metadata Stream</i> <br><br>  <b>Streams</b> <br><br>  The stream processor in Kafka is responsible for all the following work: it receives continuous data streams from the input topics, somehow processes this input and feeds the data stream to the output topics (either to external services, databases, to the recycle bin, and anywhere ...) <br>  Simple processing can be performed directly on the generators / consumers API, however, more complex transformations ‚Äî for example, thread integration, in Kafka are performed using the <a href="https://kafka.apache.org/documentation/streams/">Streams API</a> integrated library. <br><br>  This API is intended for use within your own code base, it does not work on a broker.  Functionally, it is similar to the consumer API, facilitates the horizontal scaling of thread processing and its distribution among several applications (similar to groups of consumers). <br><br>  <i><b>Stateless processing</b></i> <br><br>  Stateless processing is a deterministic processing flow that does not depend on any external factors.  As an example, consider the following simple data conversion: attach information to a string <br><br> <code>"Hello" -&gt; "Hello, World!"</code> <br> <br><img src="https://habrastorage.org/webt/1z/oh/e5/1zohe5hldw_vogczg--psxpe678.png"><br><br>  <b>Stream-tabular dualism</b> <br><br>  It is important to understand that threads and tables are essentially the same thing.  A stream can be interpreted as a table, and a table as a stream. <br><br>  <b>Stream as a table</b> <br><br>  If you pay attention to how synchronous replication of the database is performed, it is obvious that we are talking about <b>streaming replication</b> , where any changes in the tables are sent to the replica server (replica).  The Kafka stream can be interpreted in the same way - as a stream of updates for data that aggregates and gives the final result appearing in the table.  Such streams are stored in the local RocksDB (by default) and are called <b>KTable</b> . <br><br><img src="https://habrastorage.org/webt/te/bj/_5/tebj_5e5ja24kbz02begjvreojw.png"><br><br>  <b>Table as a stream</b> <br><br>  A table can be considered an instant snapshot, reflecting the last value for each key in the stream.  Similarly, you can create a table from stream entries, and from table updates you can create a stream with a change log. <br><br><img src="https://habrastorage.org/webt/5j/qc/2d/5jqc2dl7hwjryewpkwbrbx54h2y.png"><br><br>  <i>With each update, you can take a snapshot of the stream (record)</i> <br><br>  <b>Stateful processing</b> <br><br>  Some simple operations, such as <code>map()</code> or <code>filter()</code> , are performed statelessly, and we don‚Äôt have to store any data regarding their processing.  However, in practice, most operations are performed with state saving (for example, <code>count()</code> ), so you naturally have to store the state that is currently in place. <br><br>  The problem with maintaining state in stream processors is that these processors sometimes fail!  Where to store this state to provide fault tolerance? <br><br>  A simplified approach is to simply store all state in a remote database and connect to this repository over the network.  The problem is that the data locality is then lost, and the data itself is repeatedly distilled over the network - both factors significantly slow down your application.  A more subtle, but important problem is that the activity of your stream processing task will depend heavily on the remote database - that is, this task will not be self-sufficient (all your processing may fail if another team makes any changes to the database) . <br><br>  <b>So which approach is better?</b> <br><br>  Recall the dualism of tables and streams.  It is through this property that streams can be converted to tables located exactly where the processing takes place.  Also, we get a mechanism for ensuring fault tolerance - we store the threads on the Kafka broker. <br><br>  The stream processor can save its state in a local table (for example, in RocksDB), which the input stream will update (possibly, after any arbitrary transformations).  If this process fails, we can recover the relevant data by reproducing the stream. <br><br>  You can even ensure that the remote database generates a stream and, in fact, broadcasts the change log, on the basis of which you will rebuild the table on the local machine. <br><br><img src="https://habrastorage.org/webt/js/g0/5i/jsg05ijdvo-suaqlslfa9mohife.png"><br><br>  <i>Stateful processing, connecting KStream with KTable</i> <br><br>  <b>KSQL</b> <br><br>  As a rule, the code for stream processing is written in one of the languages ‚Äã‚Äãfor the JVM, since the only official client of the Kafka Streams API works with it. <br><br><img src="https://habrastorage.org/webt/iq/nc/0p/iqnc0pnz_dq34nrueenjpjimydw.png"><br><br>  <i>Sample KSQL installation</i> <br><br>  <a href="https://www.confluent.io/blog/ksql-open-source-streaming-sql-for-apache-kafka/">KSQL</a> is a new feature that allows you to write simple stream jobs in a familiar language that resembles SQL. <br><br>  We configure the KSQL server and interactively request it through the CLI to control the processing.  It works exactly with the same abstractions (KStream and KTable), guarantees the same advantages as the Streams API (scalability, fault tolerance) and greatly simplifies working with streams. <br><br>  It may not sound inspiring, but in practice it is very useful for testing the material.  Moreover, this model allows you to join streaming processing even to those who are not involved in the development as such (for example, product owners).  I recommend to watch a small <a href="https://www.youtube.com/watch%3Fv%3DA45uRzJiv7I%26t%3D2m13s">introductory video</a> - see for yourself how simple everything is here. <br><br>  <b>Alternative to stream processing</b> <br><br>  Kafka flows - the perfect combination of strength and simplicity.  Perhaps, Kafka is the best tool for performing streaming tasks available on the market, and integrating with Kafka is much easier than with alternative tools for streaming processing ( <a href="https://storm.apache.org/">Storm</a> , <a href="https://samza.apache.org/">Samza</a> , <a href="https://spark.apache.org/">Spark</a> , <a href="https://github.com/WallarooLabs/wallaroo">Wallaroo</a> ). <br><br>  The problem with most other stream processing tools is that they are difficult to deploy (and difficult to handle).  A batch framework, such as Spark, requires: <br><br><ul><li>  Manage a large number of tasks on a pool of machines and effectively distribute them in a cluster. </li><li>  To do this, you need to dynamically package the code and physically deploy it to the nodes where it will be executed (plus configuration, libraries, etc.) </li></ul><br>  Unfortunately, when trying to solve all these problems within one framework, this framework turns out to be too invasive.  The framework attempts to control all sorts of aspects of deploying, configuring code, monitoring it, and packaging the code. <br><br>  Kafka Streams allows you to formulate your own deployment strategy when you need it, moreover, you can work with the tool to your taste: <a href="https://kubernetes.io/">Kubernetes</a> , <a href="https://mesos.apache.org/">Mesos</a> , <a href="https://www.nomadproject.io/">Nomad</a> , <a href="https://github.com/docker/swarm">Docker Swarm</a> , etc. <br><br>  Kafka Streams is designed primarily for you to organize stream processing in your application, however, without the operational difficulties associated with supporting the next cluster.  The only potential drawback of such an instrument is its close connection with Kafka, however, in the current reality, when stream processing is mainly performed with the help of Kafka, this small drawback is not so terrible. <br><br><hr><br>  <b>When should I use Kafka?</b> <br><br>  As mentioned above, Kafka allows you to pass a huge number of messages through a centralized environment, and then store them without worrying about performance and not fearing that data will be lost. <br><br>  Thus, Kafka will be perfectly arranged in the very center of your system and will work as a link that ensures the interaction of all your applications.  Kafka can be a central element of an event-oriented architecture, which will allow you to properly detach applications from each other. <br><br><img src="https://habrastorage.org/webt/oh/7t/ro/oh7trohelazfkgg6perufp36iga.png"><br><br>  Kafka allows you to easily distinguish between communication between different (micro) services.  Working with Streams API, it has become easier than ever to write business logic that enriches data from the Kafka topic before services begin to consume them.  This opens up tremendous opportunities - so I strongly recommend to study how Kafka is used in different companies. <br><br>  <b>Results</b> <br><br>  Apache Kafka is a distributed streaming platform that allows you to handle trillions of events per day.  Kafka guarantees minimal delays, high throughput, provides fault tolerant pipelines operating on the ‚Äúpublish / subscribe‚Äù principle and allows to handle event streams. <br><br>  In this article, we got acquainted with the basic semantics of Kafka (we learned what a generator, broker, consumer, topic is), learned about some optimization options (page cache), learned what fault tolerance Kafka guarantees in data replication and briefly discussed its powerful streaming capabilities. </div><p>Source: <a href="https://habr.com/ru/post/352978/">https://habr.com/ru/post/352978/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352968/index.html">Conference DEFCON 22. ‚ÄúArming Your Pets. Fighting Kitty and Dog for denial of service. " Jen Brensfield</a></li>
<li><a href="../352970/index.html">How 64k intro is created today: immersion immersion</a></li>
<li><a href="../352972/index.html">From the Baltic Sea to the Indian Ocean</a></li>
<li><a href="../352974/index.html">Cryptocurrency for beginners. How to start using Bitcoin</a></li>
<li><a href="../352976/index.html">Manipulating Google search results</a></li>
<li><a href="../352980/index.html">Never Fail Twice, or how to build a monitoring system from scratch</a></li>
<li><a href="../352982/index.html">Alice, Google Assistant, Siri, Alexa. How to write applications for voice assistants</a></li>
<li><a href="../352984/index.html">Security Week 12: card games, hand-driven malware and a healthy approach to leaks</a></li>
<li><a href="../352986/index.html">Messengers, it's time to take the next step.</a></li>
<li><a href="../352988/index.html">Self-Managed Virtual Infrastructures: VMware Updates vRealize Suite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>