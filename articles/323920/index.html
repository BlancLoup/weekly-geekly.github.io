<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The saga is about how Java developers should test their applications. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If you still think that there is no use of reports at conferences, we invite you to read an article prepared based on the report by Nikolai xpinjectio...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The saga is about how Java developers should test their applications. Part 1</h1><div class="post__text post__text-html js-mediator-article">  If you still think that there is no use of reports at conferences, we invite you to read an article prepared based on the report by Nikolai <a href="https://habrahabr.ru/users/xpinjection/" class="user_link">xpinjection</a> Alimenkov (EPAM) at JPoint 2016. In a nearly two-hour report, Nikolay talks in detail about various aspects of testing (and development). Java applications - from approaches to testing business logic to TDD, BDD and UI testing, demonstrated on practical examples from a real project. <br><br>  The post turned out just huge, so we broke it into two parts.  Now you are reading the first part, and the second <a href="https://habrahabr.ru/company/jugru/blog/323922/">is available by reference</a> . <br><br>  Video of the report: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <iframe width="560" height="315" src="https://www.youtube.com/embed/K-eA9ZIkJBg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br><h2>  Briefly about yourself </h2><br>  My name is Nikolai Alimenkov, I came to you from sunny Kiev.  I have a <a href="https://twitter.com/xpinjection">Twitter</a> .  If you have one too, and you read something about Java and development processes - join. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/634/00d/3d1/63400d3d1944774cb056013edc29c774.jpg" align="left" width="200"><br>  I have been working with agile-methodologies and engineering practices for a long time.  The main direction of my activity throughout my rather long career is Java and the development of large distributed systems of various kinds.  Most of this time I worked as a Java Technical Lead and Delivery Manager. <br><br>  Concurrently, I am the founder and trainer in the XP Injection training center, on whose behalf we conduct many interesting activities.  We have big conferences: <br><ul><li>  <a href="http://seleniumcamp.com/">Selenium Camp</a> , entirely dedicated to test automation issues.  Initially, the conference, existing since 2011, was entirely devoted to Selenium / WebDriver, but now it has gone beyond its scope; <br><br></li><li>  <a href="http://jeeconf.com/">JEE Conf</a> - the largest Java-conference in Eastern Europe, dedicated to modern approaches to the development of distributed, highly loaded, scalable systems, new directions and interesting architectural solutions for Java, interaction with other technologies; <br><br></li><li>  <a href="http://xpdays.com.ua/">XP days Ukraine</a> big conference, which is dedicated to engineering practices (continuous delivery, continuous integration, testing, automation and everything related to engineering practice), as well as tools that allow you to implement the discussed approaches. <br></li></ul><br>  Currently I work for EPAM in the position of Senior Delivery Manager, leading a large grocery project.  The team is now more than 150 people, we are growing and we are planning to grow further.  What we will talk about today, we use in teams not only on this, but also on other projects.  All this is scaled both on small, and on big teams without any problems. <br><br>  However, everything that I will tell you is based on my personal experience and on my vision, how this should be done.  Your experience and vision may not be the same as stated.  If you have a different opinion, I will be happy to discuss everything on occasion. <br><br><h2>  Business Logic Testing </h2><br>  Let's start with a fairly simple - with business logic.  There are 2 main schools here. <br><br>  <b>The first school</b> says that any existing logic should be tested in complete isolation from any other logic.  In other words, you must create a completely isolated environment for each piece of your business logic.  If you are testing a service, then any other classes used to pull some more pieces of logic, transformations, etc., should be isolated.  Those.  This school insists that moki should be used everywhere and tested in complete isolation. <br><br>  This approach has a remarkable advantage: in the test, you can emulate any condition that you can think of.  You need to let some sender of a message throw an exception of any kind (even one that is very hard to simulate in real life) - no problem.  For example, you can find out how your code will respond to "Out of memory".  Will he eat "out of memory"?  Or will it pledge and go on?  Such things can also be tested. <br>  It gives a certain freedom.  And the advantages of the approach are clearly visible: tests are performed very quickly, with them simply.  And here there is a huge number of libraries. <br><br>  <b>The second school</b> says the opposite.  If we test the logic, then we must test it with the whole environment, with the exception of fairly complex structures, for example, external systems - they need to be somehow isolated.  This approach also has certain advantages.  One of them is that you simultaneously test not only the logic itself, but also integration with the environment.  This means that the tests will be more revealing, will give more information about the situation, if something went wrong.  After all, it often happens that all unit tests pass, but the application does not even rise.  And the reason is very simple: each element individually had some kind of its own protocol, but when they got together, it turned out that you used the old protocol to emulate the behavior, and, voila, nothing works.  This approach protects against this development. <br><br>  But what happens if your business logic has some kind of ornateness (there are logical conditions, cycles, etc.), and in the nested pieces of logic that are delegated to someone, there are also cycles and nesting.  In this case, you get a lot of tests, because  need to go all the way.  You can come to the conclusion that in order to test one service method, you will have to write about fifty tests.  Understandably, no one will write these 50 tests.  You write 10 or 15 and stop at this, moving away from the original goal of providing normal coverage that would give you an accurate understanding that everything is going well.  But do not write all 50. <br>  Such tests run slower.  It turns out that it is difficult, but there is no common problem with mocks (when you ‚Äúshut up‚Äù everything and everything is not very reliable in the end). <br><br>  I am a supporter of the first approach (where everything has to be wet), but with certain nuances.  And this is just the most interesting thing I want to talk about. <br>  There are many libraries for mocks: EasyMock, Mockito, JMock, Powermock, Spock and others.  Each has its pros and cons. <br>  For example, one of the minuses of the Mockito is that if you use it, you need to sit down and really figure it out.  And our developers (by ‚Äúour‚Äù I mean developers from the post-Soviet space) are used to bashing money.  They saw the Mockito, looked at the example in Stack Overflow or in the Mockito documentation: ‚ÄúEverything is clear.  I made mock - I made verify at the end, ‚Äùand rushed to use it.  But Mockito works on the spy principle, i.e.  records all actions, and you can check a part, but not a part of it.  Not understanding this logic, you can go on a completely wrong scenario.  I saw it in real life: the guys worked out half a year, but didn‚Äôt make a correct verify in any test.  As a result, they had a lot of tests that ran and were always green, but did not test anything (they tested that Mockito recorded everything, but in the end they did not check anything, because, in their opinion, everything had to be recorded).  Those.  understand how the framework works is necessary. <br><br>  EasyMock behaves more like Strict-mok - by default, it checks everything.  Strict-mok, when you didn‚Äôt teach him something (they called some method that wasn‚Äôt warned about, or suddenly two times called what they promised to call once), says: ‚ÄúI don‚Äôt know how to do it, so I fell ".  But, again, they need to be able to use, because there is a logic that allows you to make a stub or a more lightweight design out of such a mock. <br><br>  The biggest problem with mokami arises when you have a certain service, which is actually an integrator and does not contain any logic itself, but inside it pulls others (for example, go to the database and pull out the user, for which we pass the user ID there and pull out user, then register the user somewhere - register, return boolean true, send a message to the user by e-mail that he is registered and return boolean true or false).  Within the framework of flat logic (without branching of if-s), we pull A, then B, and so on.  What will your test look like if we use moki?  It will look exactly the same: expect A to be called, then B to be called, and so on.  And then an interesting question arises: are such tests not too fragile?  They simply repeat the implementation.  If now I just change something in the implementation (and, not conceptually, I just move something), I have to do the same in the test. <br><br>  There are three ways to solve this problem. <br><br><ul><li>  First, we do not test such integrator services at all.  This is the most pleasant option for the developer: no need to test - no problem.  Since we use flat logic, it is enough to call this service at least once in a higher level test.  We have REST-tests or functional tests through the UI, and they certainly will somehow affect this service.  If they touched him and everything went well, that's enough.  The method is very simple.  By the way, you can even specifically mark integrators with annotations so that they are not taken into account in all coverage statistics. <br><br></li><li>  The second way I don‚Äôt really like is to live with this pain and really have tests in which all behavior is completely duplicated by mock. <br><br></li><li>  The third way is to write integration tests for such integrators.  But in this case there will be a real base, a real sender, and so on. <br></li></ul><br>  Which of these options to choose - you know better. <br><br><h2>  Examples from practice </h2><br>  Let's look at some practical examples. <br><br><pre><code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@RunWith</span></span>(UnitilsJUnit4TestClassRunner.class) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProjectIndexStorageText</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ProjectIndexStorage indexStorage; <span class="hljs-meta"><span class="hljs-meta">@RegularMock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> DirectoryCompressor compressor; <span class="hljs-meta"><span class="hljs-meta">@RegularMock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> FileIndexMaintainer fileIndexMaintainer; <span class="hljs-meta"><span class="hljs-meta">@RegularMock</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ArchiveStorage storage;</code> </pre> <br><br>  Here I have IndexStorage and moki: DirectoryCompressor, FileIndexMaintainer and ArchieveStoreage.  I marked all of them with Regular Mock - this is the usual mock. <br>  What my test looks like: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> File baseDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"project-index-storage-test"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> File unpackedIndexTempDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"download-file"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> File indexActualDir = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(<span class="hljs-string"><span class="hljs-string">"page-index"</span></span>);</code> </pre> <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Before</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> URISyntaxException, IOException </span></span>{ indexStorage = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ProjectIndexStorage(fileIndexMaintainer, storage); FileUtils.forceMkdir(unpackedIndexTempDir); }</code> </pre> <br><br>  In the constructor, when the test method of the init method is called, I in Before transfer all my mocks to IndexStorage (no magic happens). <br>  At the end, I delete the file dir: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@After</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FileUtils.deleteQuietly(baseDir); }</code> </pre> <br><br>  The test is called ‚Äúarchive is created and saved‚Äù: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">archiveIsCreatedAndStored</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ expectGettingIndexPath(); storage.store(<span class="hljs-string"><span class="hljs-string">"11"</span></span>, indexActualDir); replay(fileIndexMaintainer, storage); indexStorage.uploadIndex(<span class="hljs-number"><span class="hljs-number">11</span></span>); assertProjectIdFileExists(<span class="hljs-number"><span class="hljs-number">11</span></span>); }</code> </pre> <br><br>  Here is a reusable morsel: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expectGettingIndexPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expect(fileIndexMaintainer.getIndexPath(<span class="hljs-number"><span class="hljs-number">11</span></span>)).andReturn(indexActualDir)); }</code> </pre> <br><br>  Then I kind of say: ‚ÄúFileIndexMaintainer, you will be asked for the index along the way, and you give him back some such directory (this is the real directory - above, I also created it).‚Äù <br>  After that: ‚ÄúStorage, you should be called.  And you keep this real directory. ‚Äù  I taught them all, and then I say replay, i.e.  they are now familiar with this behavior. <br>  I want to note that this is Strict-moc.  If I now change some parameter, for example, I‚Äôll specify not 11, but 12 for storage. Store, he will say: "Sorry, I did not expect 12, it was only from 11". <br>  After that, I call my upload and check on the file system that a certain archiver has been added to a certain folder - assertProjectIdFileExists (11) (although this does not apply to moks): <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assertProjectIdFileExists</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> projectId)</span></span></span><span class="hljs-function"> </span></span>{ assertTrue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> File(baseDir, String.valueOf(projectId)).exists()); }</code> </pre> <br><br>  What is worth paying attention to?  When such construction <code>storage.store ("11", indexActualDir);</code>  , - some misunderstanding is created.  If you forget that this is a regular mock, the Java syntax creates the feeling that you are actually calling this storage.  To avoid this feeling, many frameworks, the same Mockito, have their own fluent API.  And EasyMock, when you don‚Äôt need to return anything (as you can see, the store method doesn‚Äôt return anything, just void), don't wrap it in expect, but just call it.  It is sometimes confusing. <br><br>  I just gave an example here, wrapping it in expect to show: in fact, this is not a real challenge.  I just need to explain what it means.  For this, I am using the expectGettingIndexPath method: <br><br><pre> <code class="java hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expectGettingIndexPath</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expect(fileIndexMaintainer.getIndexPath(<span class="hljs-number"><span class="hljs-number">11</span></span>)).andReturn(indexActualDir)); }</code> </pre> <br><br>  This is much better than posting comments.  Do this and everything will be cool. <br><br><h2>  Description through testing </h2><br>  Business logic is tested for several reasons: <br><br><ul><li>  to make sure that it really works the way you want it; </li><li>  to achieve security.  If now someone goes into the code itself and changes it by mistake (not the way you expected it), your tests should fail; </li><li>  so that it is described somewhere what your class can do. </li></ul><br>  And I would like to talk about the last point in more detail. <br><br>  Someone makes descriptions Javadoc.  But how often do you update it? <br><br>  Do we update javadoc as soon as we make a change?  This approach is not very reliable.  Therefore, as an additional bonus from tests on business logic, I would like to have a description of what a particular class can do. <br>  It all depends on you.  That the class has been described, it is necessary to describe it somewhere.  And there is a great place for this - in the names of test scripts. <br><br>  You‚Äôve probably seen some call their test scripts, say, test_success_1, test_success_2, etc.  If I then see what my class can do, then I will see that it is very ‚Äúsuccess‚Äù.  Maybe somewhere will fail.  And, unfortunately, this is all that remains to me a legacy from the person who figured in this class when writing tests on him (and, possibly, was the author of this class). <br><br>  If I act differently and try to call each implemented test script on the business logic according to what I want to test, it will result in some kind of live specification. <br><br>  I will see: <code>archiveIsCreatedAndStored()</code> <br>  Perhaps this is the success-path - nothing falls, everything is fine. <br><br>  Here is another example: <br><br><pre> <code class="java hljs"> <span class="hljs-meta"><span class="hljs-meta">@Test</span></span>(expected = IllegalStateException.class) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">failIndexDownloadIfTemDirectoryRenameHasFailed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ FileUtils.touch(indexActualDir); expectGettingIndexPath(); expectRetrievalIndexFromStorage(unpackedIndexTempDir); replay(fileIndexMaintainer, storage, compressor); indexStorage.downloadIndex(<span class="hljs-number"><span class="hljs-number">11</span></span>); }</code> </pre> <br><br>  Here <code>failIndexDownloadIfTempDirectoryRenameHasFailed()</code> , i.e.  if rename temp directory falls, then the whole operation falls.  This is a business rule that we want to test.  And you have a direct connection with this business rule, since the specification (or task, in whatever matter you store your original task of implementing business logic) says: "If the rename temp directory falls, throw an exception." <br><br>  There is a wonderful plugin for IDEA (and Eclipse too) called TestDox, which will do a good deed for you - it breaks up all the test methods that we call CamelCase into words, providing for each test a short description in the form of specific operation names be carried out. <br><br> <code>ProjectIndexStorage: <br> &gt;&gt; archive is created and stored <br> &gt;&gt; skip downloading index if directory already exists <br> &gt;&gt; index is downloaded from storage if target dir abscent <br> &gt;&gt; index is downloaded from storage if maintainer thrown expected exception <br> &gt;&gt; skip index removal for non project events <br> &gt;&gt; skip index removal for wrong event type <br> &gt;&gt; index removal is delegated to storage <br></code> <br>  TestDox allows you to conveniently navigate between these tests.  Imagine that I have never seen this ProjectIndexStorage.  Here I can not just read what he can (perhaps you would have written this in Javadoc too).  The biggest bonus is that I can choose the behavior that I‚Äôm interested in, double-click on it, see what is expected of those mocks with whom I interact, and run this behavior.  I can stop at debugging and see how it works. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">indexDownloadedFromStorageIfMaintainerThrownExpectedException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ expectGettingIndexPathFailure(); expectRetrievalIndexFromStorage(unpackedIndexTempDir); replay(fileIndexMaintainer, storage, compressor); indexStorage.downloadIndex(<span class="hljs-number"><span class="hljs-number">11</span></span>); assertFalse(unpackedIndexTempDir.exists()); assertTrue(indexActualDir.exists()); assertProjectIdFileExists(<span class="hljs-number"><span class="hljs-number">11</span></span>); }</code> </pre> <br> <code><b>ProjectIndexStorage:</b> <br> &gt;&gt; archive is created and stored <br> &gt;&gt; skip downloading index if directory already exists <br> &gt;&gt; index is downloaded from storage if target dir abscent <br> <b>&gt;&gt; index is downloaded from storage if maintainer thrown expected exception</b></code> <br> <br>  There is no need to raise the entire system - you can deal with one class, while right in the test.  Notice, we now share several goals. <br><br><ul><li>  Firstly, tests exist and run.  And even if we write test_success_1, etc., they will still run and solve one problem. <br><br></li><li>  But, secondly, there is still an additional task - this is live documentation.  For this you need additional efforts on your part - the correct names.  Nothing more to do. <br></li></ul><br><h2>  But what about logging? </h2><br>  Many do super-logging unit tests.  What for?  The unit-test report has everything you need: if you called it correctly and understand which piece of functionality does not work.  The second thing you have is StackTrace.  I hope everyone can do operations with StackTrace: I copied StackTrace, went to IDEA, said Analize StackTrace and saw what was going wrong.  This is enough for a unit test.  Additional logging is physically useless.  The debugger in a good way is also not needed. <br><br>  But here I am repelled by the idea that we are testing only business logic.  In this case, we have one single goal - to verify that the business logic is working correctly.  It is not necessary, in the general case, to add some second goal there.  One-time (for unexpected situations) - no problem.  But I say that there should not be logging in the normal mode. <br><br>  Of course, there are different situations, for example, you may have tests that blink - and this is quite a normal thing, because running tests from the IDE and the console (or local infrastructure settings) is different.  In this case, you have to understand.  But I'm not sure that the debugger will help you.  Rather, running the command line that runs on your Continuous Integration Server will help.  A log does not give anything.  The same timings will be automatically - they will be given by the unit testing framework used. <br><br>  If the test falls in different environments, there is clearly a problem with external dependencies.  Everyone knows that unit tests should be independent.  But some developers implicitly make these dependencies.  They can pass tests on the local machine, because they wrote them in a certain order, test by test.  And locally they launch them in the order in which they are written.  And if you turn on the "Run in random order" checkbox, a test may or may not fall.  Most likely this means that it depends on something - on some other test.  You may not have cleared the directory or variable.  This happens, and you have to find it out by checking the box. <br><br>  Sometimes you are confronted with the fact that you have Memory Leak in unit tests.  Garbage Collector starts to work more aggressively and more aggressively, and he sometimes has pauses.  Since  we used the reactive model, then we wait on the promises until the result returns (let's say we set a timeout for three seconds - this is more than enough for a unit test), but it is not executed.  Look at the Garbage Collector Profile, and it turns out that there is a pause.  As a result, locally tests are run, because we, for example, have given more memory, and somewhere else - no.  This also happens.  With this you need to understand in private.  But by default there should be only the correct good test names and everything, nothing else you need here. <br><br>  It should be noted that we are not testing the hash code here.  Hashcode and equals are defined when they want to be used in collections that are based on Hashcode and equals ‚Äî hashmap, hashset, and so on.  But if you don‚Äôt use Hash anywhere, you may not need a hashcode.  Therefore, if we know that there is some kind of solution - we want to save somewhere or decide to do field caching so that it is precomputed - then we are testing it.  But we try to write as little code of this kind as possible. <br><br><h2>  About business logic and test time coverage </h2><br>  Usually in projects, business logic coverage is in most cases close to 100%, since  Most developers write on TDD (people do not write code if they cannot formulate what it should do).  We are talking about all the code, with the exception of synthetic, getters, setters, frameworks, or the above-mentioned integrators, i.e.  things we don't want to cover. <br><br>  In the project that I am running now, we strive to increase the coverage, and at the moment it is about 60%. <br><br>  Now let's talk about the mutation tests.  They are used to check how much your tests cover logic.  In a nutshell, they work like this: come to some if and invert it.  And they look - the tests continue to work or not.  If the tests are still green, then this if you are not very good at checking out.  Likewise, they do with rearranging other things.  For example, assigning a local variable of a different value.  The most popular tool used in Java is pit. <br><br>  In the past project (the code of which I showed) we experimented and found about 3 to 5 tests that were ‚Äúso-so‚Äù (and this is debatable), so we did not include mutation testing on an ongoing basis, because  we had been developing for 5 years by that time.  If in 5 years we only had 3 such tests, it is too much overhead to do the check all the time.  But on some projects, I assure you, you will find a lot of interesting things.  Some tests do not check anything at all. <br><br>  But coverage should not be a goal.  If the goal is coverage, write any rubbish, so long as it calls methods.  You can not write a single assert, make a million tests that simply call methods with different parameters - and you will have super-coverage.  But that makes no sense.  You should not fight for coverage, but for tests that give an understanding that the functionality works correctly and periodically breaks down (because when the test breaks, it shows its benefit - except for the situation when they break down due to incorrect spelling). <br><br>  How long does it take?  Here I will say such a thing, which, perhaps, not everyone will agree: I don‚Äôt want to consider how much it takes.  And the reason is very simple: everyone has some kind of approach to writing code.  You cannot approach the developer and say: ‚ÄúYou generate high-quality solutions, but how does your productivity change depending on whether you are programming with one or two hands?  Maybe we will pay you half the wages, but you can do a good job with one hand too. ‚Äù  Manipulating test writing time is an attempt to isolate a piece from the standard process by which you get a quality solution.  And she hints that you would like to get rid of him (‚Äúoptimize‚Äù). <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f25/b41/b8b/f25b41b8be0601e56612044d5a389fd8.jpg"><br><br>  The same question can be asked about code review.  How much does code review take?  This is a good question in terms of optimizing code review itself (in order to have this as a metric and keep track of code review less), but for a different purpose it is dangerous to ask this question. <br><br>  I can say a purely personal feeling: I write tests for much longer than the code itself (and here we smoothly flow into the next topic - TDD).  Most of the code I do not write, but the generator.  I never write public class and something else, constructor, getters, setters, etc.  For the past 8 years I have never created a method from scratch myself.  I just write in the test how it should look, and after that the IDE automatically generates everything for me.  It turns out that most of the time I write a test.  But this does not mean that in the absence of the test, I would immediately be greatly accelerated.  On the contrary, I would slow down and the low level design would get worse. <br><br><h2>  Evolution of tests </h2><br>  The test is more or less punctual.  Personally, I adhere to this approach: I know that we are trying not to put extra effort into this test.  If I have some kind of new functionality that makes me modify the test (and change the name), I often leave the old, new generation, make sure the new one works, and then remove the old one.  If necessary, I act in the old antiquated way of copy-paste, i.e.  copy paste driven development in this regard helps me a lot.  When I write a new test, I try to formulate how it should look now.  After that, I copy paste the inside of the dough and, thus, I can get rid of the old one. <br><br>  This solves the problem of changing the names.  With Javadoc, the opposite is true: it doesn‚Äôt affect you at all, you can change it after you finish your work (but ‚Äúafter‚Äù usually flies out of your head and no one has any desire to do it). <br><br>  Tests can be written both immediately and as the code rises.  Usually, I immediately write those test scenarios that I‚Äôm afraid to forget. <br><br>  Why is it good to write a test script before the code?  When writing, you start to think about using the API, about possible outcomes (for example, returning false instead of expected true in certain situations).  And then you either record yourself that you need to test the script with false, or you write the script with false right away - this already depends on what kind of memory the person has.  Some focus on one thing and everything they meet along the way, then they forget.  But then it's a shame that the thinking process was in vain.  Therefore, I prefer, meeting something unobvious (which was not originally in memory), to immediately formulate it as a test. <br><br>  But all the tests at once, I do not write.  Why am I not doing this?  Here is an example: I am starting to write some kind of test and it seems to me that now the API is good.  But not the fact that he will remain so.  Not the fact that when I start to implement it, I will not see any disadvantages in it.  And it will be insulting if I formulate all the tests in the framework of the same API, and then I will change everything.  Therefore, it is better to go on a small piece. <br><br>  If tests are not relevant, delete them.  Do not comment, do not skip, just delete.  You have a version control system from which you can easily restore them if necessary.  If you are afraid of losing, enter a rule: when you remove some tests, you mark it with some special tag in the comment in your version control system (for example, unit test remove - utr).  All - if utr is marked, the test is deleted there and it can be easily found.  But I think you will never need it. <br><br><h2>  The insides of the test - the division of responsibility </h2><br>  There are a few typical questions about the guts of the test concerning the division of responsibility in different variations. <br><br>  First, the question of the number of assertions in the test.  I do not agree with the rule: "Do always one assert."  The only thing is that asserts should not cover several scenarios at once. <br><br>  When we talk about unit tests for business logic, I would like to cover some specific scenario.  Sometimes it saves you a lot of money and in the course of a bunch of things to check, but it turns out more integration test.  His problem is that it is fragile - if only one functionality has changed (not all, but one of those that you assert), it will fall.  Therefore, I tend to the rule that assert should be clearly from the business scenario you are testing.  But how many of them will be physically (one will check the folder, the other will check the mocks, the third - the initial parameters) - it does not matter.  As in the example we talked about above: <br><br><pre> <code class="java hljs"> indexStorage.downloadIndex(<span class="hljs-number"><span class="hljs-number">11</span></span>); assertFalse(unpackedIndexTempDir.exists()); assertTrue(indexActualDir.exists()); assertProjectIdFileExists(<span class="hljs-number"><span class="hljs-number">11</span></span>);</code> </pre> <br>  Some say that it is impossible to do this and at the end there should be only one assert string.  And here 3 assert, but they are all interconnected.  It would be possible to connect them together, putting meaning in them and physically turning them into one, but I never did it - I don‚Äôt see the point.  In my opinion, this is perfectionism. <br><br>  Secondly, the concept of single responsibility helps to make a decision about testing protected, private, etc.  When do you want to make a protected-method?  When you realize that its logic is quite complex and you would like to test it independently.  But when the complexity of the class exceeds a certain level, for good it is necessary to split up into several classes and delegate this logic to someone else (perhaps in the same package and package visible without additional ceremonies).  And then build separate tests for individual classes. <br><br>  The profit is that classes become easier and you support the concept of single responsibility. <br><br>  Imagine that you have a class in which there are 5 different responsibilities.  There is a high probability that people from different tasks will come to it and will simultaneously work on its code.         responsibility,    (.. ,   ,  )  . <br><br>    ,         .      -,    -      ,     .   ,     ,  ,   ( private).          ,       -  .       ,     ,      ,  ,    .      .          .  ,   ‚Äî        ,   ‚Äî        .     -      .       ‚Äî ,       . <br><br>  ,   protected      -,   .   ,     protected,       .   private , -     reflection    ,    ,  protected   , ..     (  ),    , ‚Äî     . <br> ,  package default ‚Äî    .    - package default,  ,       package,         public.   (       API,    ). <br><br><h2>    - </h2><br>   ,   ,    - ‚Äî          JDK  -  .      ,    blank ( /  ),    .     ,   ,       . <br><br>   ,     -,      ,  -    -.   ,    ,        . <br><br>   ,      :    , ; ,     ,   .        .     -  . <br><br>     :  blank,    blank?   ,   ,      -?   -    ? <br>   .    ,      blank,     ,       ,     .   ,   -   (, - ¬´, ¬ª)    blank   . <br><br>     .    ,    ,  .              . <br><br><hr><br> <i>      .   <a href="https://habrahabr.ru/company/jugru/blog/323922/">  </a> . <br><br>           <a href="https://jpoint.ru/">JPoint 2017</a> (7-8  2017   ).       ¬´ Hibernate  ¬ª.              ! <br><br>   ,  JPoint           Java ‚Äî <a href="https://habrahabr.ru/company/jugru/blog/323040/">  </a>   <a href="https://jpoint.ru/"></a> .</i> <br><br>         JPoint  ,    <a href="http://jeeconf.com/program/">JEEConf</a> . </div><p>Source: <a href="https://habr.com/ru/post/323920/">https://habr.com/ru/post/323920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../323910/index.html">IBM Watson will work as a tax specialist</a></li>
<li><a href="../323912/index.html">Dark secrets of the "bright budget"</a></li>
<li><a href="../323914/index.html">Explain the effect of the last line</a></li>
<li><a href="../323916/index.html">Construction of DMZ DMZ in ACS TP systems using Modbus and IEC-60870-5-104 protocols</a></li>
<li><a href="../323918/index.html">Report from OWASP Russia Meetup # 6: video and presentation of reports</a></li>
<li><a href="../323922/index.html">The saga is about how Java developers should test their applications. Part 2</a></li>
<li><a href="../323924/index.html">Autism - programming geeks: the destruction of myths</a></li>
<li><a href="../323926/index.html">Prototype table in Axure</a></li>
<li><a href="../323928/index.html">All programmers get into # TAI</a></li>
<li><a href="../323930/index.html">On the market, a cow man sold</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>