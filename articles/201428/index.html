<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Loading CommonJS modules in the browser without changing the source code</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One day, sitting at a computer and pondering my next worthless undertaking, I suddenly realized that I needed a way to use the same code on the browse...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Loading CommonJS modules in the browser without changing the source code</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/282/750/2da/2827502dac69a4cb321e9a75ac1cd1ae.png"><br><br>  One day, sitting at a computer and pondering my next worthless undertaking, I suddenly realized that I needed a way to use the same code on the browser side and on the server side.  I almost immediately guessed that for sure I was not the first to be so clever, and everything had been invented long ago for me - and I was not mistaken. <br><br>  Indeed, my requirements were great, for example, <a href="http://requirejs.org/">RequireJS</a> with its <a href="http://requirejs.org/docs/node.html">adapter for Node.js</a> , which for some time successfully met my whims, until I again had a brilliant idea: ‚ÄúWhy do I have to use porridge from two completely different module formats in one project?  It is necessary to unify everything! ‚Äù 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And again, the answer was not long in coming, there were a million browser implementations of CommonJS modules: all sorts of script skleyschiki, and server preprocessors, and synchronous loaders, and asynchronous - everything your heart desires.  But they all ended up with one very important flaw.  They somehow modified the source code of scripts and made the process of debugging them in browser inspectors very inconvenient. <a name="habracut"></a><br><br><h4>  We think </h4><br>  According to the specification, the global namespace of each module should be global only within the boundaries of the module itself.  Beyond it, it should not spread.  If such a module is loaded into the browser in an unchanged form, its code will be executed in the global namespace and will share it along with all other modules.  To avoid this, the code for each module is usually wrapped in a function, and the module's namespace thus becomes local. <br><br>  You can wrap the module in a function either on the server before loading it into the browser, or in the browser itself.  In both cases, the executable code will be different from the source, which makes it difficult to debug. <br><br>  We will go the other way.  The essence of our method is that we will load each module into a separate iframe, thereby isolating it from the other modules.  In the namespace of each such frame, the require function and the exports and module.exports objects will be predefined, as required by <a href="">the CommonJS specification</a> . <br><br>  This method of loading scripts, unfortunately, was not without flaws.  The first thing I encountered was the inconvenience of working with the DOM of the parent window and other global objects.  To access them, you need to use the cumbersome window.parent.window construction, which, moreover, will be unnecessary if in the future we want to glue our modules for production.  The solution to this problem, in some way, will be the creation of a <a href="http://nodejs.org/api/globals.html">global</a> object in each frame, which will be a reference to the window of the parent window.  Through this object we will be able to access from our modules to such things as the window itself, document, navigator, history itself, and so on, as well as, if necessary, to use global variables. <br><br>  The second, not so obvious at first glance, disadvantage was the non-identity of global constructor functions (classes) Function, Date, String, etc.  in contexts of different modules.  This will not allow us, for example, to check whether an object belongs to any built-in class, if it was created in another module. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doSomething = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./someModule"</span></span>).doSomething; <span class="hljs-comment"><span class="hljs-comment">// doSomething -  ,    someModule console.log(doSomething instanceof Function); // false,   Function    Function  someModule (    someFunction) -   </span></span></code> </pre> <br>  This problem cannot be solved transparently; therefore, it is necessary to accept an agreement not to use constructions like the one mentioned above in the code.  Or use them neatly.  Specifically, in this example, the test for the belonging of a function to a class Function can be replaced, for example, in this way: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> doSomething === <span class="hljs-string"><span class="hljs-string">"function"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true</span></span></code> </pre><br>  Another nuance that makes life difficult for people who want to load their CommonJS modules into the browser is the synchronous nature of the CommonJS require function.  The most common way to solve this problem is to load the required module with a synchronous AJAX request and then eval the loaded code, or create an anonymous function using new Function ().  This method does not suit us, as the debugger in this case will stop pointing to the lines of code in the original file.  We will again go the other way, which will allow us to run without problems with a debugger through the code untouched by the ruthless Eval. <br><br>  The require function essentially only returns a cached module.exports object, which is exported by the loaded module.  The code of the module itself is executed only once during the first attempt to load the module. <br><br>  Bearing in mind the above, let‚Äôs go on a little trick - we will load our modules in advance, before the code that these modules will use is executed.  At the same time, we will cache exports of all modules somewhere, from where our absolutely synchronous require function will return them. <br><br>  Of course, this method is also not without flaws.  In order to load all modules in advance, we need to know their identifiers (names) absolutely exactly.  And this means that using our method, we will not be able to preload those modules whose identifiers are calculated during the execution of the application.  That is, we can not do this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = someRandomValue(); <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">"./module"</span></span> + a);</code> </pre><br>  However, to solve this problem, you can use for such cases, the usual AJAX-loading module and eval'om with all the ensuing consequences. <br><br>  There is still a problem, which consists in the fact that the order of code execution in modules will differ from that in, for example, in Node.js conditions.  Consider two small modules: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  "a" exports.result = doSomeExternalOperation();</span></span></code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//  "b" prepareDataForSomeExternalOperation(); var a = require("./a");</span></span></code> </pre><br>  In Node.js, obviously, the prepareDataForSomeExternalOperation function call will occur earlier than the doSomeExternalOperation call (but only if there have not been any other calls to require ("./ a") before).  In our case, everything will be the opposite, since module a is loaded and executed before module b.  With this drawback, we, unfortunately, will also have to put up.  But in fairness it should be said that with the correct design of the modules of such situations should not arise.  It is not good to execute any external actions in the main module code (for example, in the file system or some database) that implicitly affect the operation of other modules. <br><br>  Here, in general, and everything that I wanted to tell about loading of modules in the browser.  If someone described the method seemed useful and he decides to use it in his work (good, everything is quite elementary, and implementation difficulties should not arise), I will be immensely happy. <br><br>  But if you suddenly have nothing to do now, or just curious, welcome to the description of the details of my implementation! <br><br><h4>  Code </h4><br>  Sources are freely available on <a href="https://github.com/avgaltsev/comeon">Github</a> . <br><br>  I decided to format this utility in the form of a class, each instance of which will be a separate application with its own configuration (though so far the entire configuration consists of a single line - the path where all our scripts lie) and the module cache: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Comeon</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">path</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; self.path = path; self.modules = {}; }</code> </pre><br>  The class has the only public asynchronous require function, which starts the execution of a module with all its dependencies, and optionally accepts a callback function, which will be called after the main module completes its work and will receive its export parameter. <br><br><pre> <code class="javascript hljs">Comeon.prototype.require = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">require</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moduleRequest, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; loadNextModule.bind(self)(enqueueModule.bind(self)(getModuleId(<span class="hljs-string"><span class="hljs-string">""</span></span>, moduleRequest)), callback); }</code> </pre><br>  Before we consider the two main and most interesting functions enqueueModule and loadNextModule, consider a few auxiliary ones. <br><br>  The searchRequires function accepts the URL parameter of the module file, loads it with a synchronous XHR request, and searches for the occurrences of calls to the require function in it.  I want to note that we do not execute the loaded code, but just look for dependencies of the module using this function.  The module file during this download is cached by the browser, which later will come in handy when connecting this module. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requirePattern = <span class="hljs-regexp"><span class="hljs-regexp">/(?:^|\s|=|;)require\(("|')([\w-\/\.]*)\1\)/g</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">searchRequires</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> requires = []; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); xhr.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) &amp;&amp; (xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> match; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((match = requirePattern.exec(xhr.responseText)) !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { requires.push(match[<span class="hljs-number"><span class="hljs-number">2</span></span>]); } } }; xhr.send(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> requires; }</code> </pre><br>  The functions getModuleId and getModuleContext are used to obtain the identifier and the path to the module, respectively. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getModuleId</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moduleContext, moduleRequest</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleId = []; (<span class="hljs-regexp"><span class="hljs-regexp">/^\.\.?\//</span></span>.test(moduleRequest) ? (moduleContext + moduleRequest) : moduleRequest).replace(<span class="hljs-regexp"><span class="hljs-regexp">/\.(?:js|node)$/</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>).split(<span class="hljs-string"><span class="hljs-string">"/"</span></span>).forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value === <span class="hljs-string"><span class="hljs-string">"."</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (value === <span class="hljs-string"><span class="hljs-string">".."</span></span>) { moduleId.pop(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-regexp"><span class="hljs-regexp">/[\w\-\.]+/</span></span>.test(value)) { moduleId.push(value); } }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleId.join(<span class="hljs-string"><span class="hljs-string">"/"</span></span>); }</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getModuleContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moduleId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleId.slice(<span class="hljs-number"><span class="hljs-number">0</span></span>, moduleId.lastIndexOf(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) + <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre><br>  The require function is the same function that, in the context of the modules, will return the requested cached exports.  This function, having previously nailed to the context of the instance of our application and passing the first parameter to the path of the current module, we will put in the window of each frame. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">require</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moduleContext, moduleRequest</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleId = getModuleId(moduleContext, moduleRequest); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (self.modules[moduleId] &amp;&amp; self.modules[moduleId].exports) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.modules[moduleId].exports; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Module not found."</span></span>); } }</code> </pre><br>  Well, and finally, consider two functions that perform all the basic work. <br><br>  The recursive function enqueueModule adds the module passed as a parameter to the queue, and, by calling itself for each of the dependencies, it also adds them.  As a result, we get a queue of module loading, at the very end of which there will be a main module - the entry point to the application.  Thanks to this queue, each loadable module will already have at its disposal all cached modules on which it depends. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enqueueModule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moduleId</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleQueue = []; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!self.modules[moduleId]) { self.modules[moduleId] = { <span class="hljs-attr"><span class="hljs-attr">url</span></span>: self.path + moduleId + <span class="hljs-string"><span class="hljs-string">".js?ts="</span></span> + (<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>()).valueOf() }; moduleQueue.push(moduleId); searchRequires(self.modules[moduleId].url).forEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.push.apply(moduleQueue, enqueueModule.bind(self)(getModuleId(getModuleContext(moduleId), value))); }); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> moduleQueue; }</code> </pre><br>  The loadNextModule function runs through the queue returned by the enqueueModule function and loads our modules into the browser in order (the browser will take the files from its cache, since we already loaded them to look for dependencies).  To connect each module, as we agreed above, a separate iframe is used, in which we create global, exports and module.exports variables, as well as the require function.  Each next iframe is loaded only after a full download of the previous script.  When the load queue comes to an end, we call the callback function passed at the very beginning, if there is one, and transfer to it the export of the last module. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadNextModule</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">moduleQueue, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> self = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moduleQueue.length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iframe = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"iframe"</span></span>); iframe.src = <span class="hljs-string"><span class="hljs-string">"about:blank"</span></span>; iframe.style.display = <span class="hljs-string"><span class="hljs-string">"none"</span></span>; iframe.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> moduleId = moduleQueue.pop(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iframeWindow = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentWindow; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iframeDocument = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.contentDocument; iframeWindow.global = <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>; iframeWindow.require = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>.bind(self, getModuleContext(moduleId)); iframeWindow.module = { <span class="hljs-attr"><span class="hljs-attr">exports</span></span>: {} } iframeWindow.exports = iframeWindow.module.exports; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> script = iframeDocument.createElement(<span class="hljs-string"><span class="hljs-string">"script"</span></span>); script.src = self.modules[moduleId].url; script.onload = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ self.modules[moduleId].exports = iframeWindow.module.exports; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moduleQueue.length) { loadNextModule.bind(self)(moduleQueue, callback); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback === <span class="hljs-string"><span class="hljs-string">"function"</span></span>) { callback(self.modules[moduleId].exports); } }; iframeDocument.head.appendChild(script); }; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(iframe); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> callback === <span class="hljs-string"><span class="hljs-string">"function"</span></span>) { callback(); } }</code> </pre><br>  As a bonus, let's add functionality that allows us to start our application immediately after downloading the comeon.js script. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> script = <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.prototype.slice.call(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementsByTagName(<span class="hljs-string"><span class="hljs-string">"script"</span></span>), <span class="hljs-number"><span class="hljs-number">-1</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> main = script.getAttribute(<span class="hljs-string"><span class="hljs-string">"data-main"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (main) { <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">"load"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> comeon = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Comeon(script.getAttribute(<span class="hljs-string"><span class="hljs-string">"data-path"</span></span>) || <span class="hljs-string"><span class="hljs-string">"/"</span></span>); comeon.require(main); }); }</code> </pre><br>  That's all.  Now we can use the modules written in CommonJS format on the browser side and debug them at your pleasure.  To do this, we just need to connect comeon.js with the path to the scripts and the name of the main module in the data-attributes: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://rawgithub.com/avgaltsev/comeon/master/comeon.js"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-path</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"scripts/"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">data-main</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"main"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Or, if during execution you need to connect several modules independent of each other, or if the application has several entry points, you can use a more verbose syntax: <br><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"http://rawgithub.com/avgaltsev/comeon/master/comeon.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span><span class="javascript"><span class="javascript"> </span><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">window</span></span></span><span class="javascript">.onload = </span><span class="hljs-function"><span class="hljs-keyword"><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span></span><span class="javascript"><span class="hljs-function"> (</span></span><span class="hljs-params"></span><span class="javascript"><span class="hljs-function"><span class="hljs-params"></span>) </span></span></span><span class="javascript">{ </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">var</span></span></span><span class="javascript"> comeon = </span><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">new</span></span></span><span class="javascript"> Comeon(</span><span class="hljs-string"><span class="javascript"><span class="hljs-string">"scripts/"</span></span></span><span class="javascript">); </span><span class="hljs-comment"><span class="javascript"><span class="hljs-comment">//   comeon.require("main"); //    comeon.require("another_main", function (exports) { console.log(exports); }); }; </span></span></span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/201428/">https://habr.com/ru/post/201428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../201416/index.html">ScienceHub # 04: Theory of Random Graphs</a></li>
<li><a href="../201418/index.html">Dyson's first prize was a $ 2,000 Titan Arm project.</a></li>
<li><a href="../201422/index.html">Smartphone from Railways</a></li>
<li><a href="../201424/index.html">Off-road smartphone teXet X-driver: swimming with cucumbers, moving the seventh "Boomer" and much more</a></li>
<li><a href="../201426/index.html">Formed a conference program FailConf-2013</a></li>
<li><a href="../201434/index.html">As an online store "like" the search engine</a></li>
<li><a href="../201436/index.html">Apple AutoCAD 2014</a></li>
<li><a href="../201440/index.html">IBM laboratories have learned how to get 10 centimeter sheets of graphene</a></li>
<li><a href="../201444/index.html">Sneaky way to create animated jpeg</a></li>
<li><a href="../201446/index.html">Haskell - the impossible is possible?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>