<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ thread safety analysis</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Writing multithreaded applications is not easy. Some static code analysis tools help developers by giving them the ability to clearly define policies ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ thread safety analysis</h1><div class="post__text post__text-html js-mediator-article">  Writing multithreaded applications is not easy.  Some static code analysis tools help developers by giving them the ability to clearly define policies for the behavior of threads and provide automatic verification of the implementation of these policies.  This makes it possible to catch the race race conditions or their mutual blocking.  This article describes the thread safety analysis tool for C ++ code embedded in the Clang compiler.  It can be enabled using the ‚ÄìWthread ‚àí safety command line option.  This approach is widely used by Google - the benefits derived from its use have led to widespread voluntary use of this technology by various teams.  Contrary to popular opinion, the need for additional code annotations did not become a burden, but, on the contrary, yielded results in simplifying the support and development of the code. <br><br><h5>  Foreword </h5><br>  Writing multi-threaded applications is not easy, because developers have to imagine all the many options for the interaction of threads and their use of resources.  Experience shows that some toolkit would not hurt programmers.  Many libraries and frameworks impose on the programmer some requirements for thread safety when using them, but not always these requirements are clearly indicated.  And even in those cases where everything is well documented - this is just a request expressed in the text of the documentation, and not a strict automatic check. <br><br>  Static code analysis tools help developers define thread safety policies and test them when building a project.  An example of such policies might be the statements ‚Äúthe <b>mu</b> mutex should always be used when accessing the variable <b>accountBalance</b> ‚Äù or ‚Äúthe <b>draw</b> () method must be called only from a GUI thread‚Äù.  The formal definition of a politician gives two main advantages: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  The compiler may display warnings when policy violations are detected.  Finding an error at compile time is much cheaper than debugging fallen unit tests or, even worse, the appearance of ‚Äúfloating‚Äù bugs in the production code. </li><li>  The explicit thread-safety specifications play the role of documentation.  Such documentation is very important for libraries and SDK, because programmers need to know how to use them correctly.  Of course, this information can be placed in comments, however, practice shows that such comments tend to become obsolete, since they do not always change simultaneously when updating code. </li></ol><br><br>  This article talks about applying this approach to Clang, although it was originally developed for GCC, but the GCC version is no longer supported.  In Clang, this feature is implemented as a compiler warning.  In Google, the entire C ++ codebase is currently compiled with default thread-safety analysis enabled. <br><a name="habracut"></a><br><br>  All this works as follows: in addition to the type of a variable ( <b>int</b> , <b>float</b> , etc.), the programmer can optionally determine how access to this variable should be controlled in a multi-threaded environment.  Clnag uses annotations for this.  Annotations can be written either in the GNU attribute style (i.e. <b>attribute ((...))</b> ) or in the C ++ 11 attribute style (i.e. <b>[[...]]</b> ).  For portability, attributes are usually hidden inside a macro, which is defined only if the code is compiled with Clang.  The examples in this article assume the use of this macro.  These attribute names can be found in the Clang documentation. <br><br>  The code in the example below demonstrates the basic application of technology, using the example of a classic bank account.  The <b>GUARDED_BY attribute</b> requires the use of the <b>mu</b> mutex to read or write a balance, which will guarantee the atomic nature of operations for changing it.  Similarly, the <b>REQUIRES</b> macro requires the one who calls the <b>withdrawImpl</b> method to block the mutex <b>mu</b> before calling it - only after this the operation to change the balance in the method body will be considered safe. <br><br>  In the example, the <b>depositImpl</b> () method does not have the <b>REQUIRES</b> attribute and does not block the <b>mu</b> mutex before changing the balance, which means that compiling this code will show a warning about a potential error in this method.  The thread safety analysis does not check whether the mutex was used in the method that called <b>depositImpl</b> (), so the <b>REQUIRES</b> attribute must be explicitly defined.  We will also receive a warning about a potential error in the <b>transferFrom</b> () method, since it must use the <b>b.mu</b> mutex and use <b>this-&gt; mu</b> .  The analysis understands that these are two different mutexes in two different objects.  And finally, another warning is waiting for us in the <b>withdraw</b> () method, where we forget to unblock the <b>mu</b> mutex after changing the balance.  Each mutex lock operation must correspond to an unlock operation;  The analysis also correctly identifies double locks and double unlocks.  The function may, if necessary, perform a lock without unlocking (or unlocking without locking), but this behavior must be annotated in a special way. <br><br>  Code example: <br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> ‚Äù mutex.h ‚Äù class BankAcct { Mutex mu; int balance GUARDED BY(mu); void depositImpl(int amount) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// WARNING! Must lock mu. balance += amount; } void withd rawImpl(int amount) REQUIRES (mu) { // OK. Caller must have locked mu. balance ‚àí= amount; } public: void withdraw(int amount) { mu.lock(); // OK. We've locked mu. withdrawImpl(amount); // WARNING! Failed to unlock mu. } void transferFrom(BankAcct&amp; b, int amount) { mu.lock(); // WARNING! Must lock b.mu. b.withdrawImpl(amount); // OK. depositImpl() has no requirements. depositImpl(amount); mu.unlock(); } };</span></span></span></span></code> </pre> <br><br>  The thread safety analysis was originally designed for cases like the one above.  But the requirements for using mutexes when accessing certain objects is not the only thing that needs to be checked to ensure reliability.  Another common scenario is the assignment of certain roles to threads, for example, ‚Äúworkflow‚Äù, ‚ÄúGUI-flow‚Äù.  The same concepts that we talked about with mutexes can also be applied to thread roles.  In the example below, we see some class <b>Widget</b> , which can be used from two streams.  In one of the threads, event handling (for example, mouse clicks) occurs, and in the other, rendering.  At the same time, the <b>draw</b> () method should be called only from the rendering stream, and never delay the work of the stream processing user actions.  The analysis will warn if the <b>draw</b> () method is called from the wrong thread.  Further in the article we will talk about mutexes, but similar examples can be given for the roles of threads. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> ‚ÄùThreadRole.h‚Äù ThreadRole Input_Thread; ThreadRole GUI_Thread ; class Widget { public : virtual void onClick() REQUIRES (Input_Thread); virtual void draw() REQUIRES (GUI_Thread); }; class Button : public Widget { public : void onClick() override { depressed = true; draw(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// WARNING! } };</span></span></span></span></code> </pre><br><br><h5>  Basic concepts </h5><br>  Clang's thread safety analysis is built on capability calculations.  To read or write a specific area of ‚Äã‚Äãmemory, a thread must have the ability (or rights) to it.  This opportunity can be imagined as a kind of key or token that a thread must provide in order to get read or write permissions.  The opportunity may be ‚Äúunique‚Äù or ‚Äúshared‚Äù.  A ‚Äúunique‚Äù opportunity cannot be copied, that is, only one stream can have access to it at a time. A shared opportunity can have several duplicates belonging to different threads. The analysis uses the ‚Äúone writer / many readers‚Äù approach, There is a stream that must have a ‚Äúunique‚Äù opportunity for writing to a specific memory area, but a stream can have both a ‚Äúunique‚Äù and one of the ‚Äúshared‚Äù capabilities for reading the same area. In other words, many threads can read a pa area  They can be shared at the same time, because they can share the opportunity, but only one stream can write at a time. Moreover, the stream cannot write while another thread reads this memory area, since the opportunity cannot be simultaneously ‚Äúshared‚Äù and ‚Äúunique ". <br><br>  This approach allows you to make sure that the program is free from the race condition, where the ‚Äúrace condition‚Äù is defined as an attempt by several threads to access the same memory area, while at least one of the threads is trying to write.  Since the write operation requires the stream to have a ‚Äúunique‚Äù capability, no other thread will gain access to this memory at the same time. <br><br><h6>  Uniqueness and linear logic </h6><br><br>  Linear logic is a formal theory that can be used, for example, to express logical statements like ‚ÄúYou cannot have a whole cake and at the same time eat it already‚Äù.  A unique, or linear, variable can be used exactly once.  It can not be copied, used several times or forget to use.  A unique object can be created at one point in the program, and then later used.  Functions that have access to an object, but do not use it, can only pass it on.  For example, if std :: stringstream were a linear type, programs would be written as follows: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> stream ss; <span class="hljs-comment"><span class="hljs-comment">// produce ss auto&amp; ss2 = ss &lt;&lt; ‚ÄùHello‚Äù ; // consume ss auto&amp; ss3 = ss2 &lt;&lt; ‚ÄùWorld. ‚Äù ; // consume ss2 return ss3.str() ; // consume ss3</span></span></code> </pre><br><br>  Note that each thread variable was used exactly once.  The linear type system does not know that <b>ss</b> and <b>ss2</b> refer to the same data, a call &lt;&lt; conceptually uses one stream and creates another with a new name.  Attempting to use <b>ss</b> again will result in an error.  Similarly, an error will be to return something without using the <b>ss3.str ()</b> call, since then <b>ss3</b> will remain created but unused. <br><br><h6>  Naming of opportunities </h6><br>  Passing unique features in an explicit form, similar to the examples above, would be an incredibly graceful exercise, since each read operation and each write operation would require new names.  Instead, Clang, in its thread-safety analysis engine, tracks capabilities as anonymous implicitly passed objects.  The resulting type system is formally equivalent to linear logic, but is simpler in practical programming. <br><br>  Each feature is associated with a named C ++ object that defines the capability and provides operations for its creation and use.  The C ++ object itself is not unique.  For example, if <b>mu</b> is a mutex, then <b>mu.lock ()</b> creates a unique anonymous opportunity such as <b>Cap &lt;mu&gt;</b> .  Similarly, <b>mu.unlock ()</b> implicitly accepts and uses the ability of type <b>Cap &lt;mu&gt;</b> .  Operations that read or write data protected by the <b>mu</b> mutex follow the capability transfer protocol: they accept and use an implicit parameter of type <b>Cap &lt;mu&gt;</b> and create an implicit result of the same type of <b>Cap &lt;mu&gt;</b> . <br><br><h5>  Thread safety annotations </h5><br>  This section briefly describes all the main annotations that are supported by static analysis of thread safety in Clang. <br><br><h6>  GUARDED_BY (...) and PT_GUARDED_BY (...) </h6><br>  <b>GUARDED_BY</b> is an attribute that is hung on a member of a class.  It shows that access to a given class member is protected by some possibility.  Read operations require at least a ‚Äúshared‚Äù opportunity; write operations require a ‚Äúunique‚Äù opportunity. <b>PT_GUARDED_BY</b> works in a similar way, with the only difference being that it is intended for pointers and smart pointers. <br><br><pre> <code class="cpp hljs">Mutex mu; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> *p2 PT_GUARDED </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu)</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ *p2 = <span class="hljs-number"><span class="hljs-number">42</span></span>; / / Warning ! p2 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>; / / OK (no GUARDED_BY) . }</code> </pre><br><br><h6>  REQUIRES (...) and REQUIRES_SHARED (...) </h6><br>  <b>REQUIRES</b> is a function attribute.  It requires the caller to have a ‚Äúunique‚Äù opportunity.  You can specify more than one option.  <b>REQUIRES_SHARED</b> works in the same way, but the required capability can be either ‚Äúunique‚Äù or ‚Äúshared‚Äù.  Formally, <b>REQUIRES</b> defines the behavior of a function in such a way that it takes an opportunity as an implicit argument and returns it as an implicit result. <br><br><pre> <code class="cpp hljs">Mutex mu; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> a </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GUARDED_BY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">REQUIRES</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu)</span></span></span><span class="hljs-function"> </span></span>{ a = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// OK. } void test() { foo(); // Warning ! Requi res mu. }</span></span></code> </pre><br><br><h6>  ACQUIRE (...) and RELEASE (...) </h6><br>  Attributing <b>ACQUIRE</b> indicates that the function creates a ‚Äúunique‚Äù opportunity (or capabilities), for example, by receiving it from some thread.  The caller of this function should not pass the opportunity to it, but will receive it from the function when it returns the result.  The <b>RELEASE</b> attribute indicates that the function uses a ‚Äúunique‚Äù feature (for example, giving it to another thread).  The caller must pass this opportunity to the function, but will not receive it back when the function returns a result. <br><br><h6>  ACQUIRE_SHARED and RELEASE_SHARED </h6><br>  These attributes work in the same way as described above, but they create and use ‚Äúshared‚Äù capabilities. <br><br><h6>  CAPABILITY (...) </h6><br>  An attribute <b>CAPABILITY</b> can be applied to a structure, class, or <b>typedef</b> .  It shows that an object of this class can be used to identify opportunities.  For example, the mutex class in Google libraries is defined as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">class </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CAPABILITY</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(‚Äùmutex‚Äù)</span></span></span><span class="hljs-function"> Mutex </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ACQUIRE</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readerLock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ACQUIRE_SHARED</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RELEASE</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readerUnlock</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RELEASE_SHARED</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; };</code> </pre><br><br>  Mutexes are ordinary C ++ objects.  However, each mutex has an associated ability.  The <b>lock ()</b> and <b>unlock ()</b> methods create and release this feature.  Note that Clang does not attempt to verify whether these methods actually perform the corresponding operations with the mutex.  The annotations apply only to the interface of the mutex class and express how its various methods create and use features. <br><br><h6>  TRY_ACQUIRE (b, ...) and TRY_ACQUIRE_SHARED (b, ...) </h6><br>  These attributes of a function or method try to get the specified opportunity and return <b>true</b> or <b>false</b> depending on the result. <br><br><h6>  NO_THREAD_SAFETY_ANALYSIS </h6><br>  This attribute disables static thread safety analysis for the specified function.  This can be useful either when the function by definition should not be thread-safe, or in cases where the logic of the function is so complex that the static analysis fails. <br><br><h5>  Negative Requirements </h5><br>  All the requirements described above were ‚Äúpositive‚Äù, i.e.  It was specified what possibility should be present at the time of calling a certain function.  There are, however, also "negative" requirements, describing what opportunities this wash should not be.  Positive requirements allow to avoid race conditions, while negative ones help to fight deadlocks.  Many implementations of mutexes are not reentrable, since they can only be reentable by the cost of a significant drop in performance.  For such mutexes, trying a second time to invoke the lock () operation will result in a deadlock.  To avoid the deadlock, we can explicitly indicate that the opportunity currently being used should not be held by someone at the moment.  This "negative opportunity" is expressed as the operator "!": <br><br><pre> <code class="cpp hljs">Mutex mu; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> a </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GUARDED_BY</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mu)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clear</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">REQUIRES</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!mu)</span></span></span><span class="hljs-function"> </span></span>{ mu.lock(); a = <span class="hljs-number"><span class="hljs-number">0</span></span>; mu.unlock(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ mu.lock(); <span class="hljs-comment"><span class="hljs-comment">// Warning ! Caller cannot hold 'mu' . clear(); mu.unlock(); }</span></span></code> </pre><br><br><h4>  Results and conclusions </h4><br>  C ++ code thread safety analysis is currently widely used in Google products.  It is enabled by default for each assembly of each module.  More than 20,000 C ++ code files have correct annotations according to the above rules, the total number of annotations reaches 140,000 and grows every day.  The use of these annotations is voluntary on Google, and, accordingly, the wide distribution of technology is a sign that Google engineers sincerely find it useful. <br><br>  Since race and deadlock conditions are very insidious things, Google uses both static code analysis and dynamic analysis tools such as Thread Sanitizer.  It was found that these tools complement each other well.  Dynamic analysis does not require annotations and, accordingly, can be applied more widely.  However, it can detect problems only in those ways of executing the code that were actually performed in the course of the analysis, which means that the effectiveness of dynamic analysis directly depends on the test coverage of the code.  Static analysis is not so flexible, but covers all possible variants of code execution.  In addition, static analysis reveals problems at the compilation stage, which is much more efficient. <br><br>  Although the need to manually write annotations may seem a disadvantage, we found that annotations greatly simplify the maintenance and development of the code.  Annotations are especially widely used in libraries and APIs, since there they also serve as machine-verifiable documentation.  The developers and users of libraries most often belong to different teams, which means that who will use the library in a real project will not necessarily fully understand the multithreading control protocol adopted in it.  Documentation may be missing or outdated, which means it is easy to make a mistake.  With the use of annotations, the control protocol with synchronization tools becomes part of the API and the compiler will warn about errors in its use. <br><br>  Annotations also proved to be effective in controlling internal software limitations as it progresses.  For example, the initial design of some thread-safe class required the use of a mutex each time it accessed its private data.  Over time, new people came to the development team who, not being in the know about this requirement (or random refactoring), could change this behavior.  When analyzing the history of code changes, we several times found places where the engineer added a new method to the class, forgetting to use the necessary mutex when accessing protected data.  After that, he (or another person) was forced to painfully and for a long time debug the state of the race and fix the bug.  In the case when the restrictions were expressed as annotations, such a problem would be revealed at the first compilation of the code. <br><br>  Admittedly, the use of annotations has its price of support.  We found that about 50% of compiler warnings were triggered not by bugs in the code, but by bugs like forgotten, outdated, or incorrectly used annotation (like the lack of <b>REQUIRES</b> on <b>get \ set</b> methods).  In this regard, thread safety annotations are similar to the use of the const qualifier.  How to look at these errors depends on your point of view.  On Google, they are considered documentation errors.  Since the API is read frequently by many engineers, it is very important to keep the public interfaces up to date.  If we exclude the cases of obviously incorrect use of annotations, the remaining number of false-positive responses is quite low - less than 5%.  Such cases are mainly related to the use of access to the same memory area through different pointers, conditional use of mutexes, access to internal data from the object constructor, where synchronization is not needed yet. </div><p>Source: <a href="https://habr.com/ru/post/304176/">https://habr.com/ru/post/304176/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../304164/index.html">How to speed up build with Maven</a></li>
<li><a href="../304166/index.html">Infinite scrolling vs. pagination</a></li>
<li><a href="../30417/index.html">Licensed Hermaphrodite Stories</a></li>
<li><a href="../304170/index.html">Admission to the "free" magistracy in the United States. Part one</a></li>
<li><a href="../304174/index.html">Simple automation example letsencrypt</a></li>
<li><a href="../304178/index.html">Mindfields contracts: respectable partnership of developers and enterprises</a></li>
<li><a href="../30418/index.html">Firefox3. 5 tricks to help survive</a></li>
<li><a href="../304180/index.html">PyCon Russia 2016: latest news and final program</a></li>
<li><a href="../304182/index.html">Why graphQL future</a></li>
<li><a href="../304184/index.html">5 consequences of using high technology that can lead to depression</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>