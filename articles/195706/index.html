<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Model-View in QML. Part Three: Models in QML and JavaScript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The model we have is responsible for access to the data. The model can be implemented both in QML itself and in C ++. The choice here is most dependen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Model-View in QML. Part Three: Models in QML and JavaScript</h1><div class="post__text post__text-html js-mediator-article">  The model we have is responsible for access to the data.  The model can be implemented both in QML itself and in C ++.  The choice here is most dependent on where the data source is located.  If C ++ code is used as a data source, then it is more convenient to make a model there.  If the data comes directly into QML (for example, they are obtained from the network using XMLHttpRequest), then it is better to implement the model in QML.  Otherwise, you will have to transfer data in C ++ in order to get it back to display it, which will only complicate the code. <br><br>  By the way the models are implemented, I will divide them into three categories: <br><ul><li>  C ++ models; </li><li>  QML models; </li><li>  JavaScript models </li></ul><br>  JavaScript models I brought into a separate category, because  they have certain features, I will tell about them a little later. <br>  We will begin consideration with the models implemented by means of QML. <br><br>  Model-View in QML: <br><ol><li>  <a href="http://habrahabr.ru/post/181712/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/181712/">Part zero, introductory</a> </li><li>  <a href="http://habrahabr.ru/post/184416/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/184416/">Part One: Predefined Component Views</a> </li><li>  <a href="http://habrahabr.ru/post/190090/">Model-View in QML.</a>  <a href="http://habrahabr.ru/post/190090/">Part Two: Custom Submissions</a> </li><li>  Model-View in QML.  Part Three: Models in QML and JavaScript </li><li>  <a href="https://habrahabr.ru/post/302428/">Model-View in QML.</a>  <a href="https://habrahabr.ru/post/302428/">Part Four: C ++ Models</a> </li></ol><br><a name="habracut"></a><br><h5>  1. ListModel </h5><br>  This is a fairly simple and, at the same time, functional component.  Items in the ListModel can be defined statically (this is demonstrated in the first example), or added / removed dynamically (respectively, in the second example).  Let us examine both methods in more detail. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h6>  1) Static </h6><br>  When we define model elements statically, we need to define data in the child elements that are of type ListElement and are defined within the model.  The data is defined in the properties of the ListElement object and is available as roles in the delegate. <br>  With static data definition in ListModel, the data types that can be written to ListElement are very limited.  In fact, all data must be constants.  Those.  you can use strings or numbers, but the object or function will not work.  In this case, you will get the "ListElement: cannot use script for property value" error.  But you can use a list whose elements are all the same ListElement objects. <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">360</span></span> height: <span class="hljs-number"><span class="hljs-number">240</span></span> ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> texts: [ ListElement { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"one"</span></span> }, ListElement { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"two"</span></span> } ] } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span> texts: [ ListElement { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"three"</span></span> }, ListElement { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"four"</span></span> } ] } } ListView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.margins: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors.fill: parent spacing: <span class="hljs-number"><span class="hljs-number">10</span></span> model: dataModel delegate: Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: view.width height: <span class="hljs-number"><span class="hljs-number">100</span></span> color: model.color Row { anchors.margins: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors.left: parent.left anchors.verticalCenter: parent.verticalCenter spacing: <span class="hljs-number"><span class="hljs-number">10</span></span> Repeater { <span class="hljs-attr"><span class="hljs-attr">model</span></span>: texts delegate: Text { <span class="hljs-attr"><span class="hljs-attr">verticalAlignment</span></span>: Text.AlignVCenter renderType: Text.NativeRendering text: model.text } } } } } }</code> </pre> <br>  We use the texts role inside the delegate as a model, so we can achieve several levels of nesting. <br>  As a result, we get something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/4fc/cf1/4f2/4fccf14f21e6ad81aca84953041c23b6.png"></div><br><br>  Another important point.  In the statically described model, in all ListElement objects, each role must store data of only one type.  Those.  it is impossible to write a number in one element, and a line in another.  For example, consider a slightly modified model from the very first example: <br><br><pre> <code class="javascript hljs">ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> text: <span class="hljs-number"><span class="hljs-number">1</span></span> } ListElement { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span> text: <span class="hljs-string"><span class="hljs-string">"second"</span></span> } }</code> </pre><br>  We get this error: ‚ÄúCan't assign to existing role 'text' of different type [String -&gt; Number]‚Äù and instead of text in the second delegate we get 0. <br><br><h5>  2) Dynamic </h5><br>  This way gives us much more opportunities, than static.  Not all of them are described in the documentation and may be obvious, so we consider them in more detail. <br><br>  The interface for manipulating elements in ListModel is similar to the interface of a regular list.  Items can be added / deleted / moved, their value can be retrieved and replaced or edited. <br><br>  ListModel accepts the value of an element as a JavaScript object.  Accordingly, the properties of this object will become roles in the delegate. <br>  If you take the very first example, the model can be rewritten so that it is dynamically filled: <br><br><pre> <code class="javascript hljs">ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel Component.onCompleted: { append({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"first"</span></span> }) append({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"second"</span></span> }) } }</code> </pre><br>  An object can be set not only by a literal, but can be passed to the variable that this object contains: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"first"</span></span> } append(value)</code> </pre><br>  When I wrote about static content, I said that the data types that can be placed in the model should be constants.  I have good news :) When we fill the model dynamically, these restrictions do not apply.  We can as a property value and arrays, and objects.  Even functions, but with small features.  Let's take the same example and rewrite it a little: <br><br><pre> <code class="javascript hljs">QtObject { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: obj <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"It's alive!"</span></span>) } } ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel Component.onCompleted: { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value value = { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"first"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">functions</span></span>: obj } append(value) value = { <span class="hljs-attr"><span class="hljs-attr">data</span></span>: { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"second"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">functions</span></span>: obj } append(value) } }</code> </pre><br>  Since we placed the color and text properties in the data object, they will be in the delegate as properties of this object, i.e.  model.data.color. <br><br>  With features a bit more complicated.  If we simply make a property in an object and assign it a function, then inside the delegate we will see that this function has become an empty object.  But if you use the QtObject type, then everything inside it is saved and nothing disappears.  So in the definition of the component we can add the following line: <br><br><pre> <code class="javascript hljs">Component.onCompleted: model.functions.alive()</code> </pre><br>  and this function will be called after creating the component. <br><br>  Placing functions in data is more like a hack, and I recommend not to get too carried away with such things, but placing objects into a model is a very necessary thing.  For example, if data comes from the network directly to QML (using XMLHttpRequest) in JSON format (and usually happens when working with web resources), then decoding JSON, we get a JavaScript object that can be simply added to the ListModel. <br><br>  I already wrote about the fact that in all statically defined elements of ListModel roles must be of the same types.  By default, for items added to ListModel dynamically this rule also applies.  And the first element added determines what type of roles there will be.  But in Qt 5, the ability to make role types dynamic has been added.  To do this, set the dynamicRoles property to ListModel to true. <br><br><pre> <code class="javascript hljs">ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel dynamicRoles: <span class="hljs-literal"><span class="hljs-literal">true</span></span> Component.onCompleted: { append({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"first"</span></span> }) append({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span> }) } }</code> </pre><br>  A handy thing, but there are a couple of important points to remember.  The price for this convenience is performance - the Qt developers claim that it will be 4-6 times less.  In addition, dynamic role types will not work for a model with statically defined elements. <br><br>  Another very important point.  The first element to be added to the model determines not only the types of roles, but also what roles will be in the model at all.  If there are no roles in it, then they cannot be added later.  But there is one exception.  If elements are added at the stage of model creation (that is, in the Component.onCompleted handler), then the model will have all the roles that were in all these elements. <br><br>  Let's take the second example and redo it a little so that when creating a model one element is added without the text property, and then by clicking on the button we will add elements with the text ‚Äúnew‚Äù. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">360</span></span> height: <span class="hljs-number"><span class="hljs-number">360</span></span> ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel dynamicRoles: <span class="hljs-literal"><span class="hljs-literal">true</span></span> Component.onCompleted: { append({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> }) } } Column { anchors.margins: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors.fill: parent spacing: <span class="hljs-number"><span class="hljs-number">10</span></span> ListView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view width: parent.width height: parent.height - button.height - parent.spacing spacing: <span class="hljs-number"><span class="hljs-number">10</span></span> model: dataModel clip: <span class="hljs-literal"><span class="hljs-literal">true</span></span> delegate: Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: view.width height: <span class="hljs-number"><span class="hljs-number">40</span></span> color: model.color Text { anchors.centerIn: parent renderType: Text.NativeRendering text: model.text || <span class="hljs-string"><span class="hljs-string">"old"</span></span> } } } Rectangle { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: button width: <span class="hljs-number"><span class="hljs-number">100</span></span> height: <span class="hljs-number"><span class="hljs-number">40</span></span> anchors.horizontalCenter: parent.horizontalCenter border { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"black"</span></span> width: <span class="hljs-number"><span class="hljs-number">1</span></span> } Text { anchors.centerIn: parent renderType: Text.NativeRendering text: <span class="hljs-string"><span class="hljs-string">"Add"</span></span> } MouseArea { anchors.fill: parent onClicked: dataModel.append({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"new"</span></span> }) } } } }</code> </pre><br>  As a result, all new text elements will not and will have ‚Äúold‚Äù as text: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/6c6/6a8/c01/6c66a8c01f929a3a7edc4ddb28046680.png"></div><br><br>  Let's rewrite the definition of the model and add another element with the text property but no color property at the creation stage: <br><br><pre> <code class="javascript hljs">ListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel Component.onCompleted: { append({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> }) append({ <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"another old"</span></span> }) } }</code> </pre><br>  Correct the delegate definition to use the default color if it is not specified: <br><br><pre> <code class="javascript hljs">color: model.color || <span class="hljs-string"><span class="hljs-string">"lightgray"</span></span></code> </pre><br>  As a result, the model is formed with both roles and when adding new elements, everything is displayed as planned: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/cf6/fe6/bd1/cf6fe6bd13a9d5ae3085b023412946cf.png"></div><br><br>  We can also combine static and dynamic model content.  But using the static method imposes all its limitations and dynamically we will be able to add only objects with roles of the same types. <br><br>  Some news: in Qt 5.1, this model has been moved from QtQuick to a separate QtQml.Models module.  To use it, you need to connect this module: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQml.Models <span class="hljs-number"><span class="hljs-number">2.1</span></span></code> </pre><br>  But rushing to rewrite everything is not necessary ‚Äî for compatibility with existing code, the model will be available in the QtQuick module. <br><br>  ListModel can be considered a QML version of models from Qt.  It has similar functionality, allows you to manipulate data and is the active model.  I can say that in QML it is the most functional and convenient component for creating models. <br><br><h5>  2. VisualItemModel (ObjectModel) </h5><br>  The Model-View architecture of the Qt framework identifies two main entities: the model and the view and one auxiliary, the delegate.  Since the view here is a container for delegate instances, the delegate is usually defined there. <br><br>  This component allows you to transfer a delegate from the view to the model itself.  This is realized by the fact that not the data, but ready-made visual elements are placed in the model.  Accordingly, the representation in this case does not need a delegate and it is used only as a container, ensuring the positioning and navigation of elements. <br><br>  One interesting feature of VisualItemModel is that you can put objects of different types into it.  The regular delegate model uses objects of the same type to display all data.  When it is required to display elements of different types in one view, such a model is one of the solutions to this problem. <br><br>  As an example, put the objects of the Rectangle and Text types in the model and display them using the ListView: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">360</span></span> height: <span class="hljs-number"><span class="hljs-number">240</span></span> VisualItemModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: itemModel Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: view.width height: <span class="hljs-number"><span class="hljs-number">100</span></span> color: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> } Text { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: view.width height: <span class="hljs-number"><span class="hljs-number">100</span></span> horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter renderType: Text.NativeRendering text: <span class="hljs-string"><span class="hljs-string">"second"</span></span> } } ListView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.margins: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors.fill: parent spacing: <span class="hljs-number"><span class="hljs-number">10</span></span> model: itemModel } }</code> </pre><br>  In Qt 5.1, this model is moved from QtQuick to a separate QtQml.Models module and is called ObjectModel.  Just as with ListModel, to use this model, you must connect the appropriate module.  The interface remains the same, simply replace the VisualDataModel with ObjectModel. <br><br>  The model will still be available through VisualDataModel, so as not to break compatibility with the old code.  But if you develop a new version, it is better to immediately use the new name. <br><br><h5>  3. XmlListModel </h5><br>  When working with web resources, XML is often used.  In particular, it is used in such things as RSS, XSPF, various podcasts, etc.  So, we have a task to get this file and parse it.  Another XML may contain a list of elements (for example, a list of songs in the case of XSPF), from which we will need to create a model.  It is not the most convenient way to iterate over the element tree and fill in the model manually, so you need to be able to select the elements from the XML file automatically and present them as a model.  These tasks are implemented by XmlListModel. <br><br>  We are required to specify the address of the XML file, specify the criterion by which we need to select the elements and determine which roles should be visible in the delegate.  As a criterion for the selection of elements, we write a request in XPath format.  For delegate roles, we also specify an XPath query, based on which data for the role will be obtained from the element.  For simple cases like RSS parsing, these requests will also be simple and essentially describe the path in the XML file.  I will not go into the jungle of XPath here, and if you don‚Äôt really understand what kind of animal it is, I recommend reading the corresponding <a href="http://doc-snapshot.qt-project.org/qt5-stable/xmlprocessing.html">section</a> in the Qt documentation.  Here I will use examples that do not make any tricky sampling, so I hope that everything will be clear enough. <br><br>  As an example, we will get the Habr RSS feed and display the article titles. <br><br><pre> <code class="javascript hljs">Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">360</span></span> height: <span class="hljs-number"><span class="hljs-number">360</span></span> color: <span class="hljs-string"><span class="hljs-string">"lightsteelblue"</span></span> XmlListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel source: <span class="hljs-string"><span class="hljs-string">"http://habrahabr.ru/rss/hubs/"</span></span> query: <span class="hljs-string"><span class="hljs-string">"/rss/channel/item"</span></span> XmlRole { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">"title"</span></span> query: <span class="hljs-string"><span class="hljs-string">"title/string()"</span></span> } } ListView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.margins: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors.fill: parent spacing: <span class="hljs-number"><span class="hljs-number">10</span></span> model: dataModel delegate: Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: view.width height: <span class="hljs-number"><span class="hljs-number">40</span></span> radius: <span class="hljs-number"><span class="hljs-number">10</span></span> Text { anchors.fill: parent horizontalAlignment: Text.AlignHCenter verticalAlignment: Text.AlignVCenter elide: Text.ElideRight wrapMode: Text.Wrap renderType: Text.NativeRendering text: model.title } } } }</code> </pre><br>  The elements we need are blocks that are nested in, and that in turn in.  From this path, we construct our first XPath expression.  We will have only one role containing the title of the article.  To get it, you need to take the element and bring it into a string.  From this we form the second XPath expression.  On this, the formation of the model is completed, it remains only to display it.  As a result, we get something like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/399/d96/a97/399d96a976c70545f4a719ed847176e7.png"></div><br><br>  This model is placed in a separate module. To use it, you need to additionally connect this module: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick.XmlListModel <span class="hljs-number"><span class="hljs-number">2.0</span></span></code> </pre><br><h5>  4. FolderListModel </h5><br>  For many applications, access to the file system is not superfluous.  QML has an experimental component for this, representing the directory of the file system as a model - FileSystemModel.  To use it, you need to connect the module of the same name: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Qt.labs.folderlistmodel <span class="hljs-number"><span class="hljs-number">1.0</span></span></code> </pre><br>  While he is experimental, he enters Qt Labs, but in the future he may be moved to Qt Quick or anywhere else. <br>  In order to use the model, we need, first of all, to set the directory using the folder property.  The path must be specified in the URL format, i.e.  The path to the directory at the file system is set via ‚Äúfile:‚Äù.  You can specify the path for resources using "qrc:". <br><br>  You can set filters for file names using the nameFilters property, which accepts a list of masks for selecting the necessary files.  You can also configure to get into the directory model and file sorting. <br><br>  For example, we will get a list of files in the directory and display information about these files as a table: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick.Controls <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Qt.labs.folderlistmodel <span class="hljs-number"><span class="hljs-number">1.0</span></span> Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">600</span></span> height: <span class="hljs-number"><span class="hljs-number">300</span></span> FolderListModel { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel showDirs: <span class="hljs-literal"><span class="hljs-literal">false</span></span> nameFilters: [ <span class="hljs-string"><span class="hljs-string">"*.jpg"</span></span>, <span class="hljs-string"><span class="hljs-string">"*.png"</span></span> ] folder: <span class="hljs-string"><span class="hljs-string">"file:///mnt/store/Pictures/Wallpapers"</span></span> } TableView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.margins: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors.fill: parent model: dataModel clip: <span class="hljs-literal"><span class="hljs-literal">true</span></span> TableViewColumn { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">300</span></span> title: <span class="hljs-string"><span class="hljs-string">"Name"</span></span> role: <span class="hljs-string"><span class="hljs-string">"fileName"</span></span> } TableViewColumn { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> title: <span class="hljs-string"><span class="hljs-string">"Size"</span></span> role: <span class="hljs-string"><span class="hljs-string">"fileSize"</span></span> } TableViewColumn { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: <span class="hljs-number"><span class="hljs-number">100</span></span> title: <span class="hljs-string"><span class="hljs-string">"Modified"</span></span> role: <span class="hljs-string"><span class="hljs-string">"fileModified"</span></span> } itemDelegate: Item { Text { anchors.left: parent.left anchors.verticalCenter: parent.verticalCenter renderType: Text.NativeRendering text: styleData.value } } } }</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/d7d/bdf/60f/d7dbdf60fe70fb8880ca5f32f24bfe4c.png"></div><br><br>  We remove catalogs from the model and leave only the files * .jpg and * .png. <br><br>  With this model, information about the file is available for the delegate: path, name, etc.  We use here the name, size and modification time. <br><br>  We have learned how to access the file system.  But looking at the names of the pictures may not be so very exciting, so as a bonus, let's make a slightly more interesting display of them :) We have already considered such a thing as CoverFlow.  It's time to apply it here. <br><br>  So, take the example of CoverFlow and change it a bit.  We will take the model from the previous example.  Increase the size of the item: <br><br><pre> <code class="javascript hljs">property int itemSize: <span class="hljs-number"><span class="hljs-number">400</span></span></code> </pre><br>  And change the delegate: <br><br><pre> <code class="javascript hljs">delegate: Image { property real rotationAngle: PathView.angle property real rotationOrigin: PathView.origin width: itemSize height: width z: PathView.z fillMode: Image.PreserveAspectFit source: model.filePath transform: Rotation { axis { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; y: <span class="hljs-number"><span class="hljs-number">1</span></span>; z: <span class="hljs-number"><span class="hljs-number">0</span></span> } angle: rotationAngle origin.x: rotationOrigin } }</code> </pre><br>  Now let's take a look at the cool thing we did: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/storage3/aff/27b/098/aff27b09853bfea62bcbfa7adc4a8de0.png"></div><br><br>  FolderListModel is a very useful component that gives us access to the file system and, despite its experimentation, it is quite possible to use it now. <br><br><h5>  5. JavaScript Models </h5><br>  In addition to specially designed to create models of components, many other objects can also act as a model.  And this option may even be easier than using special components for the model. <br><br>  In general, such models are obtained passive, and are suitable when the number of elements is fixed or rarely changes. <br><br>  We will consider these types as models: <br><br><ul><li>  lists / arrays; </li><li>  JavaScript objects and QML components; </li><li>  whole numbers. </li></ul><br><h6>  1) Lists / arrays </h6><br><br>  You can use ordinary JavaScript arrays as a model.  A delegate will be created for each array element and the data of the array element itself will be available in the delegate through the modelData property. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> QtQuick <span class="hljs-number"><span class="hljs-number">2.0</span></span> Rectangle { property <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataModel: [ { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"second"</span></span> } ] width: <span class="hljs-number"><span class="hljs-number">360</span></span> height: <span class="hljs-number"><span class="hljs-number">240</span></span> ListView { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: view anchors.margins: <span class="hljs-number"><span class="hljs-number">10</span></span> anchors.fill: parent spacing: <span class="hljs-number"><span class="hljs-number">10</span></span> model: dataModel delegate: Rectangle { <span class="hljs-attr"><span class="hljs-attr">width</span></span>: view.width height: <span class="hljs-number"><span class="hljs-number">100</span></span> color: modelData.color Text { anchors.centerIn: parent renderType: Text.NativeRendering text: modelData.text || <span class="hljs-string"><span class="hljs-string">"empty text"</span></span> } } } }</code> </pre><br>  If there are objects in the array, then modelData will also be an object and will contain all the properties of the original object.  If the elements are simple values, then they will be modelData.  For example: <br><br><pre> <code class="javascript hljs">property <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataModel: [ <span class="hljs-string"><span class="hljs-string">"orange"</span></span>, <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span> ]</code> </pre><br>  and in the delegate we refer to the model data as follows: <br><br><pre> <code class="javascript hljs">color: modelData</code> </pre><br>  And just like in ListModel, we can put a function in these models.  As with the ListModel, if you put it in a regular JavaScript object, then in the delegate it will be visible as an empty object.  Therefore, here we also use the trick with QtObject. <br><br><pre> <code class="javascript hljs">property <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataModel: [ { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span>, <span class="hljs-attr"><span class="hljs-attr">functions</span></span>: obj }, { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"second"</span></span>, <span class="hljs-attr"><span class="hljs-attr">functions</span></span>: obj } ] QtObject { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: obj <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">alive</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"It's alive!"</span></span>) } }</code> </pre><br>  And in the delegate we call the function: <br><br><pre> <code class="javascript hljs">Component.onCompleted: modelData.functions.alive()</code> </pre><br>  I have already said that almost all JavaScript models are passive and this one is not an exception.  When you change items and add / delete them, the view will not know that they have changed.  This happens because the properties of JavaScript objects have no signals that are called when the property changes, unlike Qt objects and, accordingly, QML objects.  The view will receive a signal if we change the property itself used as a model, replace the model.  But there is one trick: we can not only assign a new model to this property, but also reassign the old one.  For example: <br><br><pre> <code class="javascript hljs">dataModel.push({ <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"skyblue"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"something new"</span></span> }) dataModel = dataModel</code> </pre><br>  This model is well suited for data that comes from web resources and is rarely updated and / or completely. <br><br><h6>  2) objects </h6><br>  JavaScript objects and QML objects can act as a model.  This model will have one element and the properties of the object will be roles in the delegate. <br>  Take the very first example and redo it to use a JavaScript object as a model: <br><br><pre> <code class="javascript hljs">property <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> dataModel: <span class="hljs-literal"><span class="hljs-literal">null</span></span> Component.onCompleted: { dataModel = { <span class="hljs-attr"><span class="hljs-attr">color</span></span>: <span class="hljs-string"><span class="hljs-string">"orange"</span></span>, <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-string"><span class="hljs-string">"some text"</span></span> } }</code> </pre><br>  Object properties in the delegate are available via modelData: <br><br><pre> <code class="javascript hljs">color: modelData.color</code> </pre><br>  As with JavaScript arrays, changing an object after it has been set as a model does not affect the display, i.e.  This is also a passive model. <br><br>  I also referred to JavaScript models using one QML object as a model.  Although these objects can be used as a full-fledged QML model, in terms of functionality it is almost an analogue of using a regular JavaScript object, with some features.  Therefore, I consider them together. <br><br>  Let's change the same example for use as a QML object model: <br><br><pre> <code class="javascript hljs">Item { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: dataModel property color color: <span class="hljs-string"><span class="hljs-string">"orange"</span></span> property string text: <span class="hljs-string"><span class="hljs-string">"some text"</span></span> }</code> </pre><br>  Item is selected here to show that any QML object can be a model.  In practice, if you only need to store data, QtObject is best suited.  This is the most basic and, accordingly, the lightest QML object.  Item, in this case, contains too much extra. <br><br>  With such a model, the data in the delegate is available through both model and modelData. <br><br>  Also, this model is the only active of the JavaScript-models.  Since the properties of QML objects have signals that are called when a property changes, changing a property in an object will change the data in the delegate. <br><br><h6>  3) Integer </h6><br>  The simplest model :) We can use an integer as a model.  This number is the number of model elements. <br><br><pre> <code class="javascript hljs">property int dataModel: <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  Or you can directly specify a constant as a model: <br><br><pre> <code class="javascript hljs">model: <span class="hljs-number"><span class="hljs-number">5</span></span></code> </pre><br>  The delegate will have a modelData property that contains an index.  The index will also be available through model.index. <br><br>  This model is well suited when you need to create a certain number of identical elements. <br><br><h5>  As output </h5><br>  We reviewed the models that are implemented by QML and JavaScript.  There are many options, but from myself I‚Äôll say that the most frequently used are ListModel and JavaScript arrays. <br><br>  The considered models are implemented quite simply, if we do not need any special tricks (such as storing functions in ListModel).  In cases where this option is suitable, we can implement all the components of MVC in one language and thereby reduce the complexity of the program. <br><br>  But, I want to draw attention to one thing.  It is not necessary to drag everything into QML, you should be guided by practical considerations.  Some things may be easier to implement in C ++.  It is the C ++ model that we will look at in the next section. </div><p>Source: <a href="https://habr.com/ru/post/195706/">https://habr.com/ru/post/195706/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../195690/index.html">We create a website using Laravel and Recurly. Part 1</a></li>
<li><a href="../195694/index.html">iTunes Store Support: the whole truth about Apple‚Äôs rules and support</a></li>
<li><a href="../195696/index.html">3d printer will print space structures directly in orbit</a></li>
<li><a href="../195698/index.html">81 devices can be linked to a single Windows account.</a></li>
<li><a href="../195704/index.html">Simple Science - Digest of Experiences # 28</a></li>
<li><a href="../195710/index.html">MagOS Linux (September release)</a></li>
<li><a href="../195712/index.html">Impressions of testing the Valve controller</a></li>
<li><a href="../195718/index.html">How does Sberbank share your personal information?</a></li>
<li><a href="../195720/index.html">Welding of optical fibers. Part 2: welding machines and cleavers, mechanical and welded splicing, measuring and laying fibers</a></li>
<li><a href="../195722/index.html">Romo: pet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>