<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Visualize concurrency in Go with WebGL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the great strengths of the Go programming language is its built-in concurrency support, based on the Communicating Sequential Processes work of...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Visualize concurrency in Go with WebGL</h1><div class="post__text post__text-html js-mediator-article">  One of the great strengths of the Go programming language is its built-in concurrency support, based on the <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">Communicating Sequential Processes</a> work of Tony Hoare.  Go is designed for convenient work with multi-threaded programming and makes it very easy to build fairly complex concurrent programs.  But have you ever wondered how different concurrency patterns look visually? <br><br>  Of course, thought.  All of us, one way or another, we think in visual images.  If I ask you about something that includes the numbers ‚Äúfrom 1 to 100‚Äù, you will instantly ‚Äúsee‚Äù them in your head in one form or another, probably without even realizing it.  For example, I see a row from 1 to 100 as a line with numbers leaving me, turning 90 degrees to the right on the number 20 and continuing to 1000+.  And, having rummaged in my memory, I remember that in the very first kindergarten in the locker room along the wall the numbers were written, and the number 20 was just in the corner.  You probably have some idea of ‚Äã‚Äãyour own.  Or, another frequent example - imagine all year round and 4 seasons of the year - someone sees them as a square, each face of which belongs to the season, someone as a circle, someone else somehow. <br><br>  Anyway, let me show my attempt to visualize the basic concurrency patterns using Go and WebGL.  These interactive visualizations more or less reflect how I see it in my head.  It will be interesting to hear how this differs from the visualization of the readers. <br><img src="https://habrastorage.org/files/043/d32/32d/043d3232d5ba4217a6e88934b773873d.gif"><br><a name="habracut"></a><br>  So let's start with the simplest example - ‚ÄúHello, concurrent world‚Äù to get acquainted with the concept of my approach. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Hello concurrent world </h4><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//     int ch := make(chan int) //     go func() { //  42   ch &lt;- 42 }() // ,    &lt;-ch }</span></span></code> </pre> <br><img src="https://habrastorage.org/files/b0f/1a2/81c/b0f1a281c2c04bd0b27c4195c9f321cb.gif"><br>  <a href="https://divan.github.io/demos/hello/"><b>Link to an interactive WebGL demo</b></a> <br>  Here the blue lines represent the gorutines, time ‚Äúruns‚Äù down the Y axis. The thin blue lines connecting the 'main' and 'go # 19' are marks of the beginning and end of the life of the gorutina, showing ancestors and children.  The red arrows show the event of sending a message to the channel, and the value sent is signed.  In fact, ‚Äúsending to the channel‚Äù and ‚Äúreading from the channel‚Äù are two separate events, and the behavior will be very different between the buffered and unbuffered channels, but I will animate these two events as one - ‚Äútransmitting the value over the channel‚Äù.  The string "# 19" in the name of an anonymous gorutina is the real ID of a running gorutina.  Although it is impossible to officially recognize ID Gorutin (so that people do not town other concurrency models in which identifiers play an important role), but for such hacker cases you can do it - this is well written in the article by <a href="http://blog.sgmansfield.com/2015/12/goroutine-ids/">Gorotine IDs by</a> Scott Mansfield. <br><br><h4>  Timers </h4><br>  In fact, our simplest Hello, world above can be used to create the simplest timer.  In the standard Go library there are such convenient functions as time.After or time.Tick, but let's implement our own - we will write a function that creates a channel, starts a gorutina that sleeps the necessary time and writes to the channel, and returns this channel to the caller. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(d time.Duration)</span></span></span><span class="hljs-function"> &lt;-</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">chan</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { c := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { time.Sleep(d) c &lt;- <span class="hljs-number"><span class="hljs-number">1</span></span> }() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">24</span></span>; i++ { c := timer(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) &lt;-c } }</code> </pre> <br><img src="https://habrastorage.org/files/8e1/6d2/f0d/8e16d2f0d9024394823f776c3acf0155.gif"><br>  <a href="https://divan.github.io/demos/timers/"><b>Link to an interactive WebGL demo</b></a> <br>  Great, right?  But we go further. <br><br><h4>  Ping pong </h4><br>  This interesting example of concurrency was taken from Sameer Ajmani, a famous paper by the Googler " <a href="https://talks.golang.org/2013/advconc.slide">Advanced Concurrency Patterns</a> ".  Of course, this example is not very advanced, but for those who are only acquainted with concurrency in Go, it should be interesting and demonstrative. <br><br>  So, we have a table channel that performs the role of a table, there is a Ball Ball, which is an int variable and stores the number of blows on it, and there are gorutin players who ‚Äútake the ball from the table‚Äù (read from the channel), ‚Äú beat on him "(increase the variable) and" throw back on the table "(write to the channel). <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Ball <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> table := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> player(table) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> player(table) table &lt;- Ball time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) &lt;-table } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">player</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(table </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { ball := &lt;-table ball++ time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) table &lt;- ball } }</code> </pre> <br><img src="https://habrastorage.org/files/803/124/d08/803124d0801a444aadd1ef1d0a298a98.gif"><br>  <a href="https://divan.github.io/demos/pingpong/"><b>Link to an interactive WebGL demo</b></a> <br>  At this point, I want to once again draw your attention to the <a href="https://divan.github.io/demos/pingpong/">link with the interactive WebGL demo</a> available under each animation - by opening in a new tab, you can move, rotate, zoom in / out and view these 3D animations as you like, as well as slow down / speed up and restart them. <br><br>  Now, let's run three gorein players, instead of two: <br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> player(table) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> player(table) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> player(table)</code> </pre> <br><img src="https://habrastorage.org/files/19b/e2a/f64/19be2af64a0a4f04ae6ec16dce9edad3.gif"><br>  <a href="https://divan.github.io/demos/pingpong3/"><b>Link to an interactive WebGL demo</b></a> <br>  In this example, we see that each player picks up the ball from the table in turn, and you may wonder why this is so, who guarantees this order? <br><br>  The answer here is simple - the Go runtime contains a <a href="">FIFO queue</a> for gorutins ready to read from the channel, which is why we are observing this order.  In our case, each gorutina is in the queue immediately after sending the ball to the table.  However, this behavior may change in the future and rely on the order is not worth it.  But for now this is so, and let's launch not three, but one hundred gorutin. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> player(table) }</code> </pre> <br><img src="https://habrastorage.org/files/049/667/48c/04966748c1ee4ff7821ada8730a4ebca.gif"><br>  <a href="https://divan.github.io/demos/pingpong100/"><b>Link to an interactive WebGL demo</b></a> <br>  The FIFO order is now more obvious, isn't it?  We can easily run a million gorutins (they are cheap, and it‚Äôs ok to have hundreds of thousands of gorutins in large Go programs), but for our purposes it will be too much.  Let's move on to other patterns. <br><br><h4>  Fan-in </h4><br>  One of the most famous patterns is the so-called <i>fan-in</i> pattern.  It is the opposite of the <i>fan-out</i> pattern, which we will look at next.  In short, <i>fan-in</i> is a function that reads from multiple sources and multiplexes everything into one channel. <br>  For example: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">producer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, d time.Duration)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { ch &lt;- i i++ time.Sleep(d) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(out </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> out { fmt.Println(x) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { ch := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) out := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> producer(ch, <span class="hljs-number"><span class="hljs-number">100</span></span>*time.Millisecond) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> producer(ch, <span class="hljs-number"><span class="hljs-number">250</span></span>*time.Millisecond) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> reader(out) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> ch { out &lt;- i } }</code> </pre> <br><img src="https://habrastorage.org/files/735/259/737/735259737f6c4fb6b0298acee046e993.gif"><br>  <a href="https://divan.github.io/demos/fanin/"><b>Link to an interactive WebGL demo</b></a> <br>  As we can see, the first <i>producer</i> generates numbers every 100ms, the second one every 250ms, and <i>reader</i> receives the numbers from both producers immediately.  Multiplexing, in fact, occurs in the function main. <br><br><h4>  Fan out </h4><br>  The opposite of <i>fan-in</i> is the <i>fan-out</i> or <i>workers</i> pattern.  Many Gorutin are read from one channel, taking away some data for processing and effectively distributing the work between the CPU cores.  Hence the name " <i>workers</i> ".  It is very easy to implement this pattern in Go - start a pack of gorutin, transfer a channel through a parameter and write your data to this channel, and multiplexing and distribution will be done automatically due to Go runtime. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tasksCh &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, wg *sync.WaitGroup)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> wg.Done() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { task, ok := &lt;-tasksCh <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } d := time.Duration(task) * time.Millisecond time.Sleep(d) fmt.Println(<span class="hljs-string"><span class="hljs-string">"processing task"</span></span>, task) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wg *sync.WaitGroup, workers, tasks </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { tasksCh := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; workers; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> worker(tasksCh, wg) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; tasks; i++ { tasksCh &lt;- i } <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(tasksCh) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wg sync.WaitGroup wg.Add(<span class="hljs-number"><span class="hljs-number">36</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> pool(&amp;wg, <span class="hljs-number"><span class="hljs-number">36</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>) wg.Wait() }</code> </pre> <br><img src="https://habrastorage.org/files/ee5/686/06c/ee568606cf9e4940893183a8ad4baef0.gif"><br>  <a href="https://divan.github.io/demos/workers/"><b>Link to an interactive WebGL demo</b></a> <br>  One thing that I would like to draw attention to here is concurrency.  Lego notice that the gorutiny-workers run in parallel, taking their "work" through the channels, one after another.  For this animation, you can also see that the gorutines do it almost simultaneously.  Unfortunately, so far the animation doesn‚Äôt see where the gorutin really works, and where it is blocked, and also here the time scale is already close to the error threshold of the error, but specifically this animation was recorded on a program running on 4 cores, ie with GOMAXPROCS = 4 .  A little further we will look at this issue in more detail. <br><br>  In the meantime, let's try something more complicated - workers who have their own, sub workers. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( WORKERS = <span class="hljs-number"><span class="hljs-number">5</span></span> SUBWORKERS = <span class="hljs-number"><span class="hljs-number">3</span></span> TASKS = <span class="hljs-number"><span class="hljs-number">20</span></span> SUBTASKS = <span class="hljs-number"><span class="hljs-number">10</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subworker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(subtasks </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { task, ok := &lt;-subtasks <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } time.Sleep(time.Duration(task) * time.Millisecond) fmt.Println(task) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">worker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tasks &lt;-</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, wg *sync.WaitGroup)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> wg.Done() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { task, ok := &lt;-tasks <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } subtasks := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SUBWORKERS; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> subworker(subtasks) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; SUBTASKS; i++ { task1 := task * i subtasks &lt;- task1 } <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(subtasks) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> wg sync.WaitGroup wg.Add(WORKERS) tasks := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; WORKERS; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> worker(tasks, &amp;wg) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; TASKS; i++ { tasks &lt;- i } <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(tasks) wg.Wait() }</code> </pre> <br><img src="https://habrastorage.org/files/4c6/c06/329/4c6c06329d724e5e8a73fee25164d900.gif"><br>  <a href="https://divan.github.io/demos/workers2/"><b>Link to an interactive WebGL demo</b></a> <br>  Great.  Of course, it was possible to do more and workers, and sub-workers, but I tried to make the animation as clear as possible. <br><br>  There are much more complex patterns, workers with subwoofers with their own subwoofers, and channels that are transmitted through the channels themselves, but the idea of ‚Äã‚Äãfan-out should be clear. <br><br><h4>  Servers </h4><br>  The next popular pattern, similar to fan-out, is <i>servers</i> .  It is distinguished by the fact that gorutiny start dynamically, perform the necessary work and complete.  And quite often this pattern is used to implement servers - we listen to the port, accept the connection, start the gorutina, which will continue to deal with the incoming request, passing the connection to it, and at that time we listen further, waiting for the next connection.  This is quite convenient and allows you to implement an efficient server that can handle 10K connections, very simple.  Take a look at the following example: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c net.Conn)</span></span></span></span> { c.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"ok"</span></span>)) c.Close() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">":5000"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { c, err := l.Accept() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> handler(c) } }</code> </pre> <br><img src="https://habrastorage.org/files/2f1/27e/0e6/2f127e0e6ba8466db99a11b2009ee836.gif"><br>  <a href="https://divan.github.io/demos/servers/"><b>Link to an interactive WebGL demo</b></a> <br>  This example is not very interesting - in fact, nothing much happens here.  Although, of course, under the hood there is tremendously hidden enormous complexity and algorithms.  <a href="https://www.youtube.com/watch%3Fv%3DrFejpH_tAHM">"Simplicity is complicated."</a> <br><br>  But let's add some activity to our server, and, let's say, add a logger in which each client will write the client's address. <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c net.Conn, ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { ch &lt;- c.RemoteAddr().String() c.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"ok"</span></span>)) c.Close() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { fmt.Println(&lt;-ch) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l net.Listener, ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { c, err := l.Accept() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> handler(c, ch) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">":5000"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } ch := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> logger(ch) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> server(l, ch) time.Sleep(<span class="hljs-number"><span class="hljs-number">10</span></span> * time.Second) }</code> </pre> <br><img src="https://habrastorage.org/files/c85/b22/75a/c85b2275aa744e1fbabb87d93670954a.gif"><br>  <a href="https://divan.github.io/demos/servers2/"><b>Link to an interactive WebGL demo</b></a> <br>  Quite defiantly, isn't it?  This animation shows that our logger can quickly become a bottleneck if the number of connections grows, and the logger is not too fast (say, it will serialize data and send it somewhere else).  But we can solve this by using the <i>fan-out</i> pattern already familiar to us.  Let's write it. <br><br><h4>  Server + Worker </h4><br>  An example of a server with a worker will be a slightly more advanced version of the solution just announced.  It not only starts the logger in several mountains, but also collects data from them with the results (for example, the result of recording to a remote service). <br>  Let's look at the code and animation: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"net"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c net.Conn, ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { addr := c.RemoteAddr().String() ch &lt;- addr time.Sleep(<span class="hljs-number"><span class="hljs-number">100</span></span> * time.Millisecond) c.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(<span class="hljs-string"><span class="hljs-string">"ok"</span></span>)) c.Close() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, results </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { data := &lt;-wch data++ results &lt;- data } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(results </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { &lt;-results } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, n </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { wch := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) results := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; i++ { <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> logger(wch, results) } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> parse(results) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { addr := &lt;-ch l := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(addr) wch &lt;- l } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(l net.Listener, ch </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">chan</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { c, err := l.Accept() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> handler(c, ch) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { l, err := net.Listen(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, <span class="hljs-string"><span class="hljs-string">":5000"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } ch := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> pool(ch, <span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> server(l, ch) time.Sleep(<span class="hljs-number"><span class="hljs-number">10</span></span> * time.Second) }</code> </pre> <br><img src="https://habrastorage.org/files/f64/24e/b05/f6424eb0589e47e0a15a53c1d162bd8d.gif"><br>  <a href="https://divan.github.io/demos/servers3/"><b>Link to an interactive WebGL demo</b></a> <br>  We have improved our server, effectively distributing the task for the logger between 4 gorutinami, but still we see that the logger can become a bottleneck.  Thousands of connections converge in the same channel.  before multiplexing between the gorutins.  But, of course, this will happen already at much greater loads than in the previous version. <br><br><h4>  Sieve of Eratosthenes </h4><br>  But pretty fan-in / fan-out experiments.  Let's look at a more interesting example.  One of my favorites is the ‚ÄúSieve of Eratosthenes‚Äù on the gorutines and canals, found in the report ‚Äú <a href="https://talks.golang.org/2012/concurrency.slide">Go Concurrency Patterns</a> ‚Äù.  Sieve of Eratosthenes is an ancient algorithm for finding primes to a given limit.  Its essence lies in the successive deletion of all numbers divisible by each subsequent prime number found.  The forehead algorithm is not very efficient, especially on multi-core machines. <br><br>  A variant of the implementation of this algorithm with gorutinami and channels runs one gorutin for each prime number found, and this gorutina filters the numbers that are divided into it.  When the first prime number in a gorutin is found, it is sent to the main gorutin (main) and displayed on the screen.  This algorithm is also far from the most effective, but I find it stunningly elegant.  Here is the code itself: <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// A concurrent prime sieve package main import "fmt" // Send the sequence 2, 3, 4, ... to channel 'ch'. func Generate(ch chan&lt;- int) { for i := 2; ; i++ { ch &lt;- i // Send 'i' to channel 'ch'. } } // Copy the values from channel 'in' to channel 'out', // removing those divisible by 'prime'. func Filter(in &lt;-chan int, out chan&lt;- int, prime int) { for { i := &lt;-in // Receive value from 'in'. if i%prime != 0 { out &lt;- i // Send 'i' to 'out'. } } } // The prime sieve: Daisy-chain Filter processes. func main() { ch := make(chan int) // Create a new channel. go Generate(ch) // Launch Generate goroutine. for i := 0; i &lt; 10; i++ { prime := &lt;-ch fmt.Println(prime) ch1 := make(chan int) go Filter(ch, ch1, prime) ch = ch1 } }</span></span></code> </pre> <br><br>  And now take a look at the animation. <br><img src="https://habrastorage.org/files/043/d32/32d/043d3232d5ba4217a6e88934b773873d.gif"><br>  <a href="https://divan.github.io/demos/primesieve/"><b>Link to an interactive WebGL demo</b></a> <br>  Do not forget to spin it interactively in 3D space at the link above.  I really like how illustrative this example is and studying it in 3D can help you understand the algorithm itself better.  We see that the first Gorutin ( <i>generate</i> ) sends the first prime number (2) to <i>main</i> , then the first Gorutin filter starts, filtering out twos, then triples, fives, sevens ... and each time a new found prime number goes to <i>main</i> - this is especially good seen from above.  Beautiful algorithm, including in 3D. <br><br><h4>  GOMAXPROCS </h4><br>  Now let's go back to our example with the workers.  Remember, I wrote that this example was launched with GOMAXPROCS = 4?  This is because all these animations are not drawn, they are real traces of real programs. <br><br>  To begin with, let's refresh our memory and remember what <a href="https://golang.org/pkg/runtime/">GOMAXPROCS is</a> : <br><blockquote>  GOMAXPROCS sets the maximum number of CPU cores that can execute code simultaneously. </blockquote><br><br>  I changed the code of the workers slightly to make it work.  loading the processor, not just sleeping.  Then I ran the code without any changes on a Linux machine with two processors of 12 cores each - first with GOMAXPROCS = 1, then with GOMAXPROCS = 24. <br><br>  So.  the first animation shows the same program running on the 1st core, the second on 24 cores. <br><img src="https://habrastorage.org/files/0e7/949/e10/0e7949e106834706944ac1395903d6a1.gif"><img src="https://habrastorage.org/files/d14/243/bc7/d14243bc7e2b475f87d93bd8d4212e7c.gif"><br><br>  <a href="https://divan.github.io/demos/gomaxprocs1/">WebGL animation 1</a> <a href="https://divan.github.io/demos/gomaxprocs24/">WebGL animation 24</a> <br>  The time animation speed is different in these examples (I wanted all the animations to take a fixed time in height), but the difference should be obvious.  With GOMAXPROCS = 1, the next worker takes the work (reads from the channel) only when the processor core is released and the previous gorutina has completed its portion.  With 24 cores, the gorutines almost immediately disassemble the tasks and the acceleration is huge. <br><br>  However, it is important to understand that an increase in GOMAXPROCS does not always lead to an increase in performance, and there may be cases when it even drops from an increase in the number of cores. <br><br><h4>  Leaks gorutin </h4><br>  What else can we demonstrate from the world of concurrency?  One of the things that comes to my mind is gorutin leaks.  They can happen by negligence, or, say, if you <a href="http://openmymind.net/Leaking-Goroutines/">started a gorutina, but it went out of scope</a> . <br><br>  The first (and only) time when I ran into a gorutin leak was a terrifying picture in my head, and literally next weekend I wrote <a href="https://github.com/divan/expvarmon">expvarmon</a> for quick monitoring.  And now I can visualize this horrific image using WebGL. <br><br>  Take a look: <br><img src="https://habrastorage.org/files/810/ee0/c94/810ee0c946d5429786943d94f2916b20.gif"><br>  <a href="https://divan.github.io/demos/leak/"><b>Link to an interactive WebGL demo</b></a> <br>  It pains me even to look at it :) Each line is a spent computer resources and a time bomb for your program. <br><br><h4>  Concurrency is not parallelism </h4><br>  The word concurrency is often translated as "parallelism", but this is not entirely true.  In truth, I don‚Äôt know a good translation, so everywhere I write here without translation.  But the topic itself, explaining the differences between concurrency and concurrency, has been <a href="https://existentialtype.wordpress.com/2011/03/17/parallelism-is-not-concurrency/">uncovered</a> <a href="https://ghcmutterings.wordpress.com/2009/10/06/parallelism-concurrency/">many times</a> , including Rob Paik, in a remarkable <a href="https://www.youtube.com/watch%3Fv%3DcN_DpYBzKso">report of the same name</a> .  Look, if not yet. <br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/cN_DpYBzKso%3Ffeature%3Doembed&amp;xid=17259,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhi2l8IEUtDxXhP_W-K7zgujRJLMgQ" frameborder="0" allowfullscreen=""></iframe><br><br>  In short, then: <br><blockquote>  Parallelism is just a lot of things running in parallel. <br>  Concurrency is a way to structure a program. </blockquote><br>  It is important to understand that these concepts are somewhat orthogonal ‚Äî a concurrent program may or may not be parallel.  We have just seen an example of this with different GOMAXPROCS - the same code ran both on the 1st core (sequentially), and on the 24 cores (in parallel). <br><br>  I could repeat many of the postulates of the above references and reports, but this has already been done before me.  Better try to show it visually. <br><br>  So, this is parallelism.  Just a lot of things running in parallel. <br><img src="https://habrastorage.org/files/4d9/583/440/4d95834402834902abbf870bef9f169f.gif"><br>  <a href="https://divan.github.io/demos/parallelism1/"><b>Link to an interactive WebGL demo</b></a> <br><br>  And this is parallelism.  Even more parallel pieces, which, however, does not change anything. <br><img src="https://habrastorage.org/files/687/022/93e/68702293e43842bfbbffc1634657a60a.gif"><br>  <a href="https://divan.github.io/demos/parallelism2/"><b>Link to an interactive WebGL demo</b></a> <br><br>  But this is concurrency: <br><img src="https://habrastorage.org/files/043/d32/32d/043d3232d5ba4217a6e88934b773873d.gif"><br><br>  And this: <br><img src="https://habrastorage.org/files/4c6/c06/329/4c6c06329d724e5e8a73fee25164d900.gif"><br><br>  And this is also a concurrency: <br><img src="https://habrastorage.org/files/049/667/48c/04966748c1ee4ff7821ada8730a4ebca.gif"><br><br><h4>  How was this done? </h4><br>  To create these animations, I wrote two programs, <i>gotracer</i> and <i>gothree.js</i> .  The first does the following things: <br><ul><li>  parses the AST tree of the source code of the examples on Go (another plus of the simple Go grammar) and inserts a special output on events related to concurrency - start / stop of the gortina, write / read to the channel, create a channel </li><li>  launches a modified program </li><li>  analyzes output, and generates special JSON with events and time stamps </li></ul><br>  Example of the resulting JSON: <br><img src="https://habrastorage.org/files/295/392/c8f/295392c8ff9b48b8b66487be1d1bd682.png"><br><br>  Further, <i>gothree.js</i> uses the power of the elegant <a href="http://threejs.org/">Three.js</a> library to draw and animate this data in 3D using WebGL.  A small wrapper to cram it into one demo page and ready. <br><br>  However, this approach is very limited.  I had to very carefully select examples, rename channels to get the correct trace.  With this approach, there is no easy way to link the channels between the gorutines, if they are called differently inside the function.  There are also problems with timing - the output to the console sometimes takes more time than starting the gorutina, recording to the channel and output, so in some examples I had to tweak a bit by inserting time.Sleep (in the example with timers, the animation is slightly incorrect therefore). <br><br>  Generally.  This is the main reason why I don‚Äôt open the code.  Now I‚Äôm still playing with Dmitry Vyukov‚Äôs <a href="https://golang.org/cmd/trace/">execution tracer</a> - it seems to give the required level of detail, although it doesn‚Äôt contain information about what was sent to the channel.  Perhaps there are still some ways to achieve the most detailed trays, I will explore further.  E-mail me on twitter or here in the comments if you have ideas.  It would be cool if this tool eventually evolved into a 3D concurrency debugger applicable to absolutely any Go program, with no exceptions. <br><br>  This article was originally presented as <a href="http://divan.github.io/talks/2016/lviv/vis_concurrency/">a report</a> at <a href="http://www.meetup.com/Lviv-Golang-Group/events/227453083/">Go Meetup in Lviv (January 23, 2016)</a> , then <a href="https://divan.github.io/posts/go_concurrency_visualize/">published in English on my blog</a> .  Also <a href="https://news.ycombinator.com/item%3Fid%3D10981616">on HackerNews</a> and <a href="https://www.reddit.com/r/golang/comments/42yc77/visualizing_concurrency_in_go_with_webgl/">on Reddit</a> . </div><p>Source: <a href="https://habr.com/ru/post/276255/">https://habr.com/ru/post/276255/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276239/index.html">TotalView extends status monitoring for IP PBX 3CX Phone System</a></li>
<li><a href="../276247/index.html">Working with JSON in Swift</a></li>
<li><a href="../276249/index.html">Top free vector icon collections</a></li>
<li><a href="../276251/index.html">Procedurally generated world maps on Unity C #, part 1</a></li>
<li><a href="../276253/index.html">How programming makes it logical to express thoughts</a></li>
<li><a href="../276257/index.html">The "energy" Trojan BlackEnergy is introduced through a vulnerability in Microsoft Office 2013</a></li>
<li><a href="../276259/index.html">The digest of interesting materials for the mobile # 138 developer (January 24-31)</a></li>
<li><a href="../276269/index.html">Tor Browser 5.5 released</a></li>
<li><a href="../276271/index.html">Conceptual description of individuals</a></li>
<li><a href="../276273/index.html">XAML Developer Chips: Composite Converters</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>