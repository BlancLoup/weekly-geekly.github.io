<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Silent Ruby Exposures: Transactional Rails / PostgreSQL Thriller</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the story of why you should never keep silent about mistakes when you are inside a transaction in a database. Learn how to properly use transa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Silent Ruby Exposures: Transactional Rails / PostgreSQL Thriller</h1><div class="post__text post__text-html js-mediator-article"><p>  <em>This is the story of why you <strong>should</strong> never keep silent about mistakes when you are inside a transaction in a database.</em>  <em>Learn how to properly use transactions and what to do when using them is not an option.</em>  <em>Spoiler: it's about advisory locks in PostgreSQL!</em> </p><br><p>  I worked on a project in which users can import a large number of heavy entities (let's call them products) from an external service into our application.  Each product is loaded with even more of a variety of related data from an external API.  There is often a situation where a user needs to load hundreds of products along with all-all dependencies, as a result, the import of a single product takes considerable time (30-60 seconds), and the whole process can take so long.  The user may be bored waiting for the result and he has the right to press the ‚ÄúCancel‚Äù button at any time and the application should be useful with the number of products that were able to be loaded by this moment. </p><a name="habracut"></a><br><p>  ‚ÄúInterrupted import‚Äù is implemented as follows: in the beginning, for each product, a temporary record-task is created in the table in the database.  For each product, the background import task is launched, which downloaded the product, saved it to the database along with all the dependencies (it does everything in general) and right at the end deletes its entry-task.  If at the moment when the background task starts, there will be no records in the database - the task just quietly ends.  Thus, to cancel the import, simply delete all the tasks and everything. </p><br><p>  It does not matter whether the import was canceled by the user or was completely completed by himself - in any case, the lack of tasks means that everything is over and the user can start using the application. </p><br><p>  The design is simple and reliable, but there was one small bug in it.  A typical bug report about him was: ‚ÄúAfter the import is canceled, the user is shown a list of his goods.  However, if you refresh the page, the list of products is complemented by several entries. ‚Äù  The reason for this behavior is simple - when the user pressed the Cancel button, he was immediately transferred to the list of all products.  But at this time, the already started imports of certain goods are still ‚Äúreaching‚Äù. </p><br><p>  This, of course, is a trifle, but the users were puzzled by the order, so it would be nice to fix it.  I had two ways: to somehow determine and "kill" already running tasks, or when I press the cancel button, wait until they finish and "die their own death" before pushing the user further.  I chose the second way - wait. </p><br><h2 id="tranzakcionnye-blokirovki-speshat-na-pomosch">  Transactional locks rush to the rescue </h2><br><p>  For anyone working with (relational) databases, the answer is obvious: use <a href="http://api.rubyonrails.org/classes/ActiveRecord/Transactions/ClassMethods.html">transactions</a> ! </p><br><p> At the same time, it is important to remember that in most RDBMS, records that are updated within a transaction will be <em>blocked</em> and inaccessible for modification by other processes until this transaction is completed.  Records selected using <a href="https://api.rubyonrails.org/classes/ActiveRecord/Locking/Pessimistic.html"><code>SELECT FOR UPDATE</code></a> will also be locked. </p><br><p>  Just our case!  I wrapped the tasks of importing individual goods into a transaction and blocked the task entry at the very beginning: </p><br><pre> <code class="ruby hljs">ActiveRecord::Base.transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> task = Import::Task.lock.find_by(<span class="hljs-symbol"><span class="hljs-symbol">id:</span></span> id) <span class="hljs-comment"><span class="hljs-comment"># SELECT ‚Ä¶ FOR UPDATE  ¬´    ¬ª return unless task #  - ? ,    ! #     task.destroy end</span></span></code> </pre> <br><p>  Now, when the user wants to cancel the import, the import stop operation will delete the tasks for imports that have not yet started and will have to wait for the completion of the ongoing ones: </p><br><pre> <code class="ruby hljs">user.import_tasks.delete_all <span class="hljs-comment"><span class="hljs-comment">#       </span></span></code> </pre> <br><p>  Simple and elegant!  I drove the tests, checked the imports locally and staging, and put them into battle. </p><br><h2 id="ne-tak-bystro">  Not so fast‚Ä¶ </h2><br><p>  Satisfied with my work, I was quite surprised to find out soon bug reports and tons of errors in the logs.  Many products were not imported <em>at all</em> .  In some cases, only one single product could remain after the completion of the entire import. </p><br><p>  Errors in the logs also did not inspire: <code>PG::InFailedSqlTransaction</code> with backtrace leading to code that executed innocent SELECTs.  What is going on at all? </p><br><p>  After a day of grueling debugging, I identified three main causes of the problems: </p><br><ol><li>  Inserting conflicting entries into the database. </li><li>  Automatic cancellation of transactions in PostgreSQL after errors. </li><li>  Hiding problems (Ruby exceptions) in the application code. </li></ol><br><p>  <strong>Problem One: Competitive Insertion of Conflicting Entries</strong> </p><br><p>  Since each import operation takes up to a minute and there are many of these tasks, we perform them in parallel to save time.  Dependent records for goods can intersect, to the point that all user products can refer to one single record created once and then reused. </p><br><p>  To find and reuse the same dependencies in the application code, there are checks, but <em>now, when we use transactions, these checks are useless</em> : if transaction A has created a dependent record, but has not completed yet, then transaction B cannot find out about its existence and will try to create a duplicate record </p><br><p>  <strong>Problem two: Automatic abolition of transactions in PostgreSQL after errors</strong> </p><br><p>  We, of course, prevented the creation of duplicate tasks at the database level using the following DDL: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> product_deps <span class="hljs-keyword"><span class="hljs-keyword">ADD</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> (user_id, characteristics);</code> </pre> <br><p>  If transaction A, which is still in progress, has inserted a new entry and, in parallel with it, transaction B tries to insert an entry with the same values ‚Äã‚Äãof the <code>user_id</code> and <code>characteristics</code> fields ‚Äî transaction B will receive an error: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> product_deps (user_id, characteristics) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">'{"same": "value"}'</span></span>); <span class="hljs-comment"><span class="hljs-comment">-- Now it will block until first transaction will be finished ERROR: duplicate key value violates unique constraint "product_deps_user_id_characteristics_key" DETAIL: Key (user_id, characteristics)=(1, {"same": "value"}) already exists. -- And will throw an error when first transaction have commited and it is become clear that we have a conflict</span></span></code> </pre> <br><p>  But there is one feature about which we must not forget - transaction B will be automatically canceled after an error is detected and all the work done in it will be a waste.  However, this transaction <strong>is still open</strong> in the "erroneous" state, but any attempt to execute any, even the most innocuous request, only errors will be returned in response: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> products; ERROR: current transaction is aborted, commands ignored until <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">block</span></span></code> </pre> <br><p>  Well, it is completely superfluous to say that everything that was entered into the database in this transaction will not be saved: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-comment"><span class="hljs-comment">--      ,   ROLLBACK --          </span></span></code> </pre> <br><p>  <strong>Problem Three: Silencing Problems</strong> </p><br><p>  By this point, it had already become clear that simply adding transactions to the application had broken it.  There was no choice: I had to dive into the import code.  In the code, the following patterns quite often caught my eye: </p><br><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_stuff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span></span> <span class="hljs-comment"><span class="hljs-comment"># ,   rescue StandardError nil #  ,  end</span></span></code> </pre> <br><p>  The author of the code here as if tells us: "We tried, we did not succeed, but that's okay, we continue without it."  And although the reasons for this choice can be quite explainable (not everything can be processed at the application level), this is exactly what makes any logic based on transactions impossible: a ‚Äúdropped‚Äù transaction cannot pop up to the <code>transaction</code> block and cannot cause a correct rollback. transactions (ActiveRecord catches all errors in this block, rolls back the transaction and throws them again). </p><br><h2 id="idealnyy-shtorm">  Perfect storm </h2><br><p>  And that's how all these three factors came together to create the perfect <del>  storm </del>  bug: </p><br><ul><li>  An application in a transaction tries to insert a conflicting entry into the database and at the same time causes a "duplicate key" error from PostgreSQL.  However, this error does not cause a rollback of the transaction in the application, as it is ‚Äúsilenced‚Äù inside one of the parts of the application. </li><li>  The transaction becomes invalid, but the application does not know about it and continues its work.  When any attempt to access the database, the application again receives an error, this time "current transaction is aborted", but this error can also be "thrown out" ... </li><li>  You probably already understood that something in the application continues to break down, but no one will know about it until the execution reaches the first place where there is no overly greedy <code>rescue</code> and where the error may eventually emerge, be output to the log, registered in the error tracker - anything.  But this place will be very far away from the place that became the root cause of the error, and this alone will turn debugging into a nightmare. </li></ul><br><h2 id="alternativa-tranzakcionnym-blokirovkam-v-postgresql">  Alternative to transactional locks in PostgreSQL </h2><br><p>  Hunting for <code>rescue</code> in the application code and rewriting the entire import logic is not an option.  Long.  I needed a quick fix and postgres found it!  He has a built-in solution for locks, an alternative to locking records in transactions, meet session-level advisory locks.  I used them as follows: </p><br><p>  First, I first removed the wrapping transaction.  In any case, it is a bad idea to interact with external APIs (or any other side effects) from the application code with an open transaction, because even if you roll back the transaction along with all the changes in our database, the changes in external systems will remain , and the application as a whole may be in a strange and undesirable state.  Heme <a href="https://github.com/palkan/isolator">isolator</a> can help you make sure that side effects are properly <em>isolated</em> from transactions. </p><br><p>  Then, in each import operation, I take a <em>shared</em> lock on a key that is unique for the entire import (for example, created from the user ID and hash from the name of the operation class): </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock_shared(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id);</code> </pre> <br><p>  Shared locks on the same key can be taken simultaneously by any number of sessions. </p><br><p>  At the same time, the operation of canceling the import deletes all task records from the database and tries to take <em>an exclusive</em> lock on the same key.  At the same time, it will have to wait until all shared locks are released: </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_advisory_lock(<span class="hljs-number"><span class="hljs-number">42</span></span>, user.id)</code> </pre> <br><p>  And it's all!  Now the ‚Äúcancellation‚Äù will wait until all the already ‚Äúrunning‚Äù imports of certain goods are completed. </p><br><p>  Moreover, now that we are not bound by a transaction, we can use a small hack to limit the waiting time for the import to be canceled (in case some import gets stuck), because it‚Äôs not good to block the web server‚Äôs flow for a long time (and force user wait): </p><br><pre> <code class="ruby hljs">transaction <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> execute(<span class="hljs-string"><span class="hljs-string">"SET LOCAL lock_timeout = '30s'"</span></span>) execute(<span class="hljs-string"><span class="hljs-string">"SELECT pg_advisory_lock(42, user.id)"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">rescue</span></span> ActiveRecord::LockWaitTimeout <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">#    (     ) end</span></span></code> </pre> <br><p>  It is safe to catch the error <em>outside</em> the <code>transaction</code> block, since <a href="">ActiveRecord will already roll back the transaction</a> . </p><br><h2 id="no-chto-delat-s-konkurentnoy-vstavkoy-odinakovyh-zapisey">  But what about the competitive insertion of the same records? </h2><br><p>  Unfortunately, I do not know a solution that would work well with <em>competitive</em> inserts.  There are the following approaches, but they will all block parallel inserts until the first transaction completes: </p><br><ul><li>  <code>INSERT ‚Ä¶ ON CONFLICT UPDATE</code> (available starting from PostgreSQL 9.5) in the second transaction is blocked until the first one is completed and then returns the record that was inserted by the first transaction. </li><li>  Block some common record in the transaction before running validations to insert a new record.  Here we will wait until the record inserted in another transaction becomes visible and validations can not fully work. </li><li>  To take some general recommendation blocking - the effect is the same as for blocking the general record. </li></ul><br><p>  Well, if you are not afraid to work with base level errors, you can just catch the uniqueness error: </p><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">import_all_the_things</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">#   ,   Dep.create(user_id, chars) rescue ActiveRecord::RecordNotUnique retry end</span></span></span></span></code> </pre> <br><p>  Just make sure that this code is not already wrapped in a transaction. </p><br><blockquote>  Why are they blocked? <br><br>  UNIQUE and EXCLUDE restrictions block <em>potential conflicts</em> by not allowing them to be recorded at the same time.  For example, if you have a unique constraint on an integer column and one transaction inserts a row with a value of 5, then other transactions that also try to insert 5 will be blocked, but transactions that try to insert 6 or 4 will immediately execute successfully, without blocking.  Since the <a href="https://postgrespro.ru/docs/postgresql/10/transaction-iso">minimal actual transaction isolation level in PostgreSQL</a> is <code>READ COMMITED</code> , the transaction cannot see uncommitted changes from other transactions.  Therefore, an <code>INSERT</code> with a conflicting value cannot be accepted or rejected until the first transaction commits its changes (then the second receives a unique error) or rolls back (then the insertion in the second transaction succeeds).  Read more about this in the <a href="http://thoughts.davisjeff.com/2010/09/25/exclusion-constraints-are-generalized-sql-unique/">article from the author of EXCLUDE restrictions</a> . </blockquote><br><h2 id="predotvraschaem-katastrofu-v-buduschem">  Prevent catastrophe in the future </h2><br><p>  <em>Now</em> you know that not all code can be wrapped in a transaction.  It would be nice to make sure that no one else would wrap a similar code in a transaction in the future, repeating my mistake. </p><br><p>  To do this, all of your operations can be wrapped in a small auxiliary module that will check if the transaction is not open before running the wrapped operation code (here it is assumed that all your operations have the same interface - the <code>call</code> method). </p><br><pre> <code class="ruby hljs"><span class="hljs-comment"><span class="hljs-comment">#     module NoTransactionAllowed class InTransactionError &lt; RuntimeError; end def call(*) return super unless in_transaction? raise InTransactionError, "#{self.class.name} doesn't work reliably within a DB transaction" end def in_transaction? connection = ApplicationRecord.connection # service transactions (tests and database_cleaner) are not joinable connection.transaction_open? &amp;&amp; connection.current_transaction.joinable? end end #    class Deps::Import &lt; BaseService prepend NoTransactionAllowed def call do_import rescue ActiveRecord::RecordNotUnique retry end end</span></span></code> </pre> <br><p>  Now, if someone tries to wrap a <em>dangerous</em> service in a transaction, then he will immediately get an error (if, of course, he will not be silent about it). </p><br><h2 id="itogi">  Results </h2><br><p>  Main lesson to be learned: be careful with exceptions.  Do not handle everything, catch only the exceptions that you know how to handle and let the rest get to the logs.  Never suppress exceptions (only if you are not 100% sure why you are doing this).  The earlier the error is noticed, the easier it will be to debug. </p><br><p>  And do not worry about transactions in the database.  This is not a panacea.  Use our <a href="https://github.com/palkan/isolator">isolator</a> and <a href="https://github.com/Envek/after_commit_everywhere/">after_commit_everywhere gems</a> - they will help your transactions become completely foolproof. </p><br><h2 id="chto-pochitat">  What to read </h2><br><p>  <a href="http://exceptionalruby.com/"><em>Exceptional Ruby</em></a> <em>by Avdi Grimm</em> .  This little book will teach you how to handle existing exceptions in Ruby and tell you how to properly design an exception system for your application. </p><br><p>  <a href="http-transactions"><em>Using @Brandur's Atomic Transactions to Power an Idempotent API</em></a> .  <a href="https://brandur.org/articles">His blog has</a> many useful articles about application reliability, Ruby and PostgreSQL. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/418147/">https://habr.com/ru/post/418147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../418137/index.html">Bloodlust: an interview with the founder of DonorSearch</a></li>
<li><a href="../418139/index.html">Numerical solution of mathematical models of objects given by systems of differential equations</a></li>
<li><a href="../418141/index.html">RE: Gata / AFR Beginner Skipper Race</a></li>
<li><a href="../418143/index.html">PVS-Studio as SAST solution</a></li>
<li><a href="../418145/index.html">The first lawsuit against Roskomnadzor from the company that suffered while blocking Telegram</a></li>
<li><a href="../418149/index.html">Phishing with the title tag</a></li>
<li><a href="../418151/index.html">Introduction to the task of recognizing emotions</a></li>
<li><a href="../418153/index.html">Videos from Kolesa Android Meetup: About MVVM, Anti-Patterns and Modular Development</a></li>
<li><a href="../418155/index.html">Diode. Light-emitting diode. Zener diode</a></li>
<li><a href="../418157/index.html">The book "Elegant Objects. Java Edition ¬ª</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>