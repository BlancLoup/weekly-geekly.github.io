<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Elegant Patterns of Modern JavaScript: RORO</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The author of the material, the translation of which we publish today, Bill Soro, says that he wrote the first lines of JavaScript code shortly after ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Elegant Patterns of Modern JavaScript: RORO</h1><div class="post__text post__text-html js-mediator-article">  The author of the material, the translation of which we publish today, Bill Soro, says that he wrote the first lines of JavaScript code shortly after the appearance of this language.  According to him, if then he would have been told that one day he would release a series of articles on elegant design patterns in JavaScript, he would have died laughing.  Then he perceived JS as a strange little language, the writing on which one could with a stretch be called "programming". <br><br>  But in 20 years, much has changed.  Now Bill perceives JavaScript the way <a href="https://en.wikipedia.org/wiki/Douglas_Crockford">Douglas Crockford</a> saw him when he was working on the book JavaScript.  Strengths ‚Äù: beautiful, elegant and expressive dynamic programming language. <br><br> <a href="https://habrahabr.ru/company/ruvds/blog/350536/"><img src="https://habrastorage.org/webt/da/pk/du/dapkdu-7q0cqolskwkxz5tqdu_0.jpeg"></a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, Bill wants to talk about a wonderful little pattern that he has been enjoying with for some time.  He hopes that this design pattern will be useful to other programmers as well.  Bill says that he does not consider himself the pioneer of this pattern, rather, it‚Äôs about the fact that he saw something similar in someone‚Äôs code, and then adapted it to fit his needs. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">RORO pattern</font> </h2><br>  RORO (Receive an object, return an object - received an object, returned an object), this is the pattern through which most of my functions now accept a single parameter of type <code>object</code> , and many of them also return a value of type <code>object</code> , or are resolved by a similar value. <br><br>  Partly due to the destructuring capabilities that appeared in ES2015, I realized that RORO is a powerful and useful pattern.  I even gave him the name - RORO, which sounds somewhat frivolous, probably, in order to highlight it in a special way. <br><br>  I want to draw your attention to the fact that destructuring is one of my favorite features in modern JavaScript.  We will talk about the strengths of this mechanism a little later, so if you are not familiar with restructuring, you can read more interestingly to continue reading this <a href="https://youtu.be/-vR3a11Wzt0">video</a> . <br><br>  Here are some reasons why you might like the RORO pattern: <br><br><ul><li>  It uses named function parameters. </li><li>  It allows you to more clearly highlight the parameters of functions assigned by default. </li><li>  It helps return complex sets of values ‚Äã‚Äãfrom functions. </li><li>  It simplifies the composition of functions. </li></ul><br>  Consider each of these RORO features in more detail. <br><br><h2>  <font color="#3AC1EF">Named Parameters</font> </h2><br>  Imagine that we have a function that returns a list of users (Users) with a given role (Role), and suppose that we need to provide this function with an argument that is needed to be included in the output of contact information (Contact Info) of each user, and one more argument for inclusion in issuing inactive (Inactive) users.  In the traditional approach, declaring such a function would look like this: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRole</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( role, withContactInfo, includeInactive )</span></span></span><span class="hljs-function"> {...}</span></span></code> </pre> <br>  Calling this function would look like this: <br><br><pre> <code class="hljs cs">findUsersByRole( <span class="hljs-string"><span class="hljs-string">'admin'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> )</code> </pre> <br>  When reading the code, the role of the last two arguments in this call is completely incomprehensible.  What do the two <code>true</code> values ‚Äã‚Äãmean? <br><br>  What happens if the application almost never needs the contact information of users, but almost always needs data on inactive users?  We will have to struggle all the time with the same argument, even though it almost never changes (we will talk more about this later). <br><br>  In a nutshell, this traditional approach provides potentially incomprehensible code overloaded with unnecessary details that is difficult to understand and difficult to write. <br><br>  Let's see what happens if instead of the usual list of arguments at the input of a function, a single object is expected with arguments: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRole</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ role, withContactInfo, includeInactive })</span></span></span><span class="hljs-function"> {...}</span></span></code> </pre> <br>  Notice that the function declaration looks almost the same as in the previous example, the only difference is that the parameters are now included in curly brackets.  This indicates that the function now, instead of receiving three separate arguments, expects one object with the properties <code>role</code> , <code>withContactInfo</code> , and <code>includeInactive</code> . <br><br>  This mechanism works through destructuring ‚Äî an opportunity that appeared in ES2015. <br><br>  Now we can call the function like this: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">findUsersByRole</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">role</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span>, withContactInfo: true, includeInactive: true })</code> </pre> <br>  So in the code it turns out to be much less ambiguity, now it is easier to read, it is much clearer.  In addition, omitting arguments or changing their order no longer causes problems, since the parameters are now represented by the named properties of the object. <br><br>  For example, we can call a function like this: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">findUsersByRole</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">withContactInfo</span></span>: true, role: <span class="hljs-string"><span class="hljs-string">'admin'</span></span>, includeInactive: true })</code> </pre> <br>  And we can and so: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">findUsersByRole</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">role</span></span>: <span class="hljs-string"><span class="hljs-string">'admin'</span></span>, includeInactive: true })</code> </pre> <br>  In addition, new parameters can be added so that their appearance does not break the code written earlier. <br><br>  Here it is worth noting one important thing, which is connected with the possibility of calling functions without arguments, that is, so that all the parameters of the function could be optional.  Calling this function looks like this: <br><br><pre> <code class="hljs lisp">findUsersByRole()</code> </pre> <br>  In order for our function to be called without arguments, you need to set the default values ‚Äã‚Äãof the arguments: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRole</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ role, withContactInfo, includeInactive } = {})</span></span></span><span class="hljs-function"> {...}</span></span></code> </pre> <br>  An additional benefit of using destructuring for an object with parameters is that this approach contributes to immunity.  When we unstructure an object when it enters the function, we assign the properties of the object to new variables.  Changing the values ‚Äã‚Äãof these variables will not change the source object. <br><br>  Consider the following example: <br><br><pre> <code class="hljs lua">const options = { role: <span class="hljs-string"><span class="hljs-string">'Admin'</span></span>, includeInactive: <span class="hljs-literal"><span class="hljs-literal">true</span></span> } findUsersByRole(options) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRole</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ role, withContactInfo, includeInactive } = {})</span></span></span></span> { role = role.toLowerCase() console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(role) // <span class="hljs-string"><span class="hljs-string">'admin'</span></span> ... } console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(options.role) // <span class="hljs-string"><span class="hljs-string">'Admin'</span></span></code> </pre> <br>  Here, despite the fact that we changed the value of the <code>role</code> variable, the value of the properties of the <code>options.role</code> object remained unchanged. <br><br>  It should be noted that destructuring makes a surface copy of an object, as a result, if any of the properties of an object with arguments is an object (for example, of type <code>array</code> or <code>object</code> ), changing this property, even if assigned to a separate variable, will lead to a change in the original object.  I express my gratitude to Yury Khomyakov for <a href="https://medium.com/%40yurik1776/hey-bill-569e596030b7">paying attention to this</a> . <br><br><h2>  <font color="#3AC1EF">Default Default Values</font> </h2><br>  Thanks to the innovations of ES2015, when declaring JS functions, you can now set parameter values ‚Äã‚Äãthat are assigned to them by default.  In fact, we have already demonstrated the use of default parameters here by adding functions <code>={}</code> to the declaration after describing an object with parameters. <br><br>  When using traditional parameters, adding default parameter values ‚Äã‚Äãmight look like this: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRole</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( role, withContactInfo = true, includeInactive )</span></span></span><span class="hljs-function"> {...}</span></span></code> </pre> <br>  If we need to set the <code>includeInactive</code> parameter to <code>true</code> , we need to explicitly pass <code>undefined</code> as the value for <code>withContactInfo</code> in order to keep the default value: <br><br><pre> <code class="hljs actionscript">findUsersByRole( <span class="hljs-string"><span class="hljs-string">'Admin'</span></span>, <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> )</code> </pre> <br>  It all looks very mysterious. <br><br>  Compare this with the use of an object function with parameters in the declaration: <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRole</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ role, withContactInfo = true, includeInactive } = {})</span></span></span><span class="hljs-function"> {...}</span></span></code> </pre> <br>  Now this function can be called like this: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">findUsersByRole</span></span>({ <span class="hljs-attribute"><span class="hljs-attribute">role</span></span>: <span class="hljs-string"><span class="hljs-string">'Admin'</span></span>, includeInactive: true })</code> </pre> <br>  At the same time, the default value specified for <code>withContactInfo</code> does not go anywhere. <br><br><h3>  About the necessary parameters of the function </h3><br>  Here we deviate a little from our main topic in order to consider one useful trick concerning the indication of the function parameters, which are absolutely necessary for its proper operation. <br><br>  How often did you have to write something like the code below? <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRole</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ role, withContactInfo, includeInactive } = {}</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (role == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {    <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(...) } ... }</code> </pre> <br>  Notice that the double equal sign, <code>==</code> , is used to check the value for both <code>null</code> and <code>undefined</code> . <br><br>  What if I tell you that instead of all this, you can use the default parameters, thanks to which you can check the receipt of the necessary data in the function? <br><br>  In order to perform such a check, you first need to declare the function <code>requiredParam()</code> , which returns an error: <br><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requiredParam</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> requiredParamError = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(  <span class="hljs-string"><span class="hljs-string">`Required parameter, "</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${param}</span></span></span><span class="hljs-string">" is missing.`</span></span> ) <span class="hljs-comment"><span class="hljs-comment">//   - if (typeof Error.captureStackTrace === 'function') {   Error.captureStackTrace(     requiredParamError,     requiredParam   ) } throw requiredParamError }</span></span></code> </pre> <br>  By the way, I know that this function does not use RORO, but therefore at the very beginning I didn‚Äôt say that absolutely all my functions use this pattern. <br><br>  Now we can, as the default value for a <code>role</code> , set the function call to <code>requiredParam</code> : <br><br><pre> <code class="hljs php"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">findUsersByRole</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ role = requiredParam</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-string">'role'</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">)</span></span></span></span><span class="hljs-function"><span class="hljs-params">, withContactInfo, includeInactive } = {})</span></span></span><span class="hljs-function"> </span></span>{...}</code> </pre> <br>  The result is that if someone calls the <code>findUserByRole</code> function without specifying a <code>role</code> , he will see an error message that indicates that he forgot to pass the required parameter to the function, which in our case will look like the <code>Required parameter, "role" is missing</code> . <br><br>  From a technical point of view, we can use this approach with the usual default parameters.  The object here is voluntary.  However, it is very convenient, so I told you about it here. <br><br><h2>  <font color="#3AC1EF">Return from functions of complex value sets</font> </h2><br>  Functions in JavaScript can return only one value.  If this value is of type <code>object</code> , it can contain a lot of interesting things. <br><br>  Imagine a function that saves <code>User</code> objects to a database.  When this function returns an object, it can transfer much more information to where it was called from than without using this approach. <br><br>  For example, usually when saving information to the database in the corresponding functions, the approach is used which means that new rows are inserted into the table, if they do not exist yet, if the corresponding rows exist, they are updated. <br><br>  In such cases, it would be useful to know what kind of database operation was performed by our function of storing information - <code>INSERT</code> or <code>UPDATE</code> .  It would be nice to get an accurate description of what was stored in the database, and the details of the result of the operation would not hurt.  For example, it may succeed, it may be merged with a larger transaction and put in a queue, the write attempt may be unsuccessful, as the timeout for the operation has expired. <br><br>  Returning an object from a function makes it very easy to put all the necessary information into it: <br><br><pre> <code class="hljs ruby">async saveUser({ upsert = <span class="hljs-literal"><span class="hljs-literal">true</span></span>, transaction, ...userInfo }) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   operation, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">'INSERT'</span></span>   status, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-string"><span class="hljs-string">'Success'</span></span>   <span class="hljs-symbol"><span class="hljs-symbol">saved:</span></span> userInfo } }</code> </pre> <br>  Technically, the following construct returns a <code>Promise</code> object, which is resolved by an ordinary object of type <code>object</code> , but I suppose this example well illustrates the idea considered here. <br><br><h2>  <font color="#3AC1EF">Simplify the composition of functions</font> </h2><br>  <i>Function composition is the process of combining two or more functions to create a new function.</i>  <i>The composition of functions is similar to the assembly of a system of several pipes through which it is planned to pass our data.</i> <i><br></i>  <i><a href="https://medium.com/%40_ericelliott">Eric Elliott</a></i> <br><br>  You can compose functions using the special function <code>pipe</code> , whose declaration looks like this: <br><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-rest_arg"><span class="hljs-function"><span class="hljs-params"><span class="hljs-rest_arg">...fns</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> param =&gt; fns.reduce(   (result, fn) =&gt; fn(result),   param ) }</code> </pre> <br>  This function takes a list of functions and returns one function that can perform these functions from left to right, passing in the first of these functions the arguments passed to the <code>pipe</code> , the second one that the first function returns, and so on. <br><br>  Perhaps it all looks a bit confusing, so now we look at an example that puts everything in its place.  The only limitation of this approach is that each function in the list should receive only one parameter.  Fortunately, when we use the RORO pattern, this is not a problem. <br><br>  Here is our example.  There is a function <code>saveUser</code> , which passes the <code>userInfo</code> object through three separate functions, which, respectively, check, normalize and save the data. <br><br><pre> <code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saveUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userInfo)</span></span></span><span class="hljs-function"> { </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pipe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   validate,   normalize,   persist )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(userInfo)</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br>  We can use the so-called <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">rest-parameters</a> in the functions <code>validate</code> , <code>normalize</code> , and <code>persist</code> to restructuring only those values ‚Äã‚Äãthat are needed by each of the functions, passing everything else on. <br><br>  Here, to make it clearer, a bit of code: <br><br><pre> <code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">validate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( id, firstName, lastName, email = requiredParam()</span></span></span></span>, username = requiredParam(), pass = requiredParam(), address, ...rest ) { //  -  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   id,   firstName,   lastName,   email,   username,   pass,   address,   ...rest } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( email, username, ...rest )</span></span></span></span> { //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   email,   username,   ...rest } } async <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">persist</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">({ upsert = true, ...info })</span></span></span></span> { //  userInfo    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {   operation,   <span class="hljs-built_in"><span class="hljs-built_in">status</span></span>,   saved: info } }</code> </pre> <br><h2>  <font color="#3AC1EF">RO or RO - that is the question</font> </h2><br>  At the very beginning, I said that most of my functions accept objects, and many of them also return objects.  Many, but not all.  Like any pattern, RORO should be considered only as one of the tools in the developer‚Äôs arsenal.  We use it where it is useful, making the function parameter list more comprehensible and flexible, and the value returned by the function more expressive. <br><br>  If you are writing a function that is enough to pass one argument, then passing it an object is already a brute force.  Similarly, if you write a function that can pass a simple value to the place of the call, which clearly and clearly expresses everything that is needed, then it is clear that such a function should not return a value of type <code>object</code> . <br><br>  For example, I almost never use RORO in assertion checking functions.  Suppose there is a function <code>isPositiveInteger</code> that checks the value passed to it on whether it is a non-negative integer.  When writing such a function, it is very likely that there will be no sense from the RORO pattern.  However, when developing JavaScript applications, this pattern can be useful in many other situations. <br><br>  <b>Dear readers!</b>  Do you plan to use the RORO pattern in your code?  Or maybe you already use something similar? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/350536/">https://habr.com/ru/post/350536/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350520/index.html">Google, Qualcomm and cloud gaming services. Integration success?</a></li>
<li><a href="../350524/index.html">Results of MentorHack: chat bot for selecting conversations from dialogues, services for building career paths and teams</a></li>
<li><a href="../350526/index.html">WhiteList vs BlackList: how to implement file extension checks and not become a victim of hackers</a></li>
<li><a href="../350528/index.html">How we did the Olympiad in SQL (end)</a></li>
<li><a href="../350530/index.html">Tibero and Oracle compatibility issues. Part 1. Conditional PL / SQL Compilation</a></li>
<li><a href="../350538/index.html">Introduction to Gjallarhorn.Bindable.WPF (F #) on the example of the test</a></li>
<li><a href="../350540/index.html">Detective story about RMCP + and OpenSSL, or how Wireshark helped defeat an incorrect argument in OpenIPMI</a></li>
<li><a href="../350542/index.html">Prospects for the development of the video surveillance industry: the capabilities of modern video analytics systems</a></li>
<li><a href="../350544/index.html">Learned helplessness in software development</a></li>
<li><a href="../350546/index.html">FastTrack Training. "Network Basics". "Products in the field of wireless local networks." Eddie Martin December 2012</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>