<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How we accelerated on FPGA AES: driver development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, we used the Ethond board as a mini router and launched OpenVPN on it. 


 But it was found that the processor is often loaded at 100%, and t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How we accelerated on FPGA AES: driver development</h1><div class="post__text post__text-html js-mediator-article"><p><img align="right" src="https://habrastorage.org/files/38d/8a1/7dd/38d8a17dd0564347af6bb050ffd3c7d0.jpg">  Recently, we used the <a href="http://metrotek.spb.ru/ethond.html">Ethond</a> board as a mini router and launched OpenVPN on it. </p><br><p>  But it was found that the processor is often loaded at 100%, and the speed does not rise above 15-16 Mbit / s.  On a 100 megabit communication channel, this is very small, so we decided to speed up the process by hardware. </p><br><p> The guys from the FPGA-developers group made an <a href="http://opencores.org/project,aes_decrypt_fpga,overview">open IP-core</a> firmware for Altera CycloneV with the implementation of the AES-128 cipher, which can encrypt 8 Gbit / s and decrypt 700 Mbit / s.  For comparison, the <code>openssl</code> program on the CPU (ARM Cortex A9) of the same CycloneV can handle only about 160 Mbps. </p><br><p>  This article focuses on our research on using AES hardware encryption.  We briefly present the description of the cryptographic infrastructure in Linux and describe the driver (the source code is open and available on <a href="https://github.com/STC-Metrotek/soc-aes-accel">github</a> ), which communicates between the FPGA and the kernel.  The implementation of encryption on FPGA is not the topic of the article - we describe only the interface with which the processor interacts with the accelerator on the processor side. </p><br><a name="habracut"></a><br><p>  Now we understand that it would be better to first determine what is the main factor in reducing the bandwidth of the channel: what if in fact not the encryption process itself, but the passage through the software stack takes most of the time?  We did not do this, and the performance gains as a result were not at all what was expected.  However, there is still a benefit: it was interesting to learn how to register the hardware acceleration mechanism in Linux, how to access it from user programs, and finally, how to get popular things like <code>openssl</code> and <code>openvpn</code> to choose an accelerated algorithm, rather than a standard software implementation. </p><br><p>  In the future, we are going to accelerate OpenVPN on <a href="http://metrotek.spb.ru/ethond.html">Ethond</a> - then expect another article from us! </p><br><h2>  Introduction </h2><br><p>  What are we so interested in cryptography?  At first glance, it does not go side by side with the equipment we do.  However, the application for it, we can also find.  A huge part of the traffic is encrypted, and every Internet user regularly encounters, even without knowing it, cryptography.  For example, the popularity of VPN is growing: according to a <a href="https://www.globalwebindex.net/blog/turkey-leads-for-vpn-usage">study</a> , at the beginning of 2017, three out of ten people are using this technology. </p><br><p>  We had the idea to make our own small router that could encrypt and decrypt at high speeds.  The idea is that the VPN does not connect the user from his machine, but the router itself.  Well, it was just interesting to try yourself in the new. </p><br><p>  What can accelerate cryptographic algorithms?  If they are expressed through arithmetic and logical operations, it turns out slowly.  In the implementation of specialized digital circuits can achieve much better performance.  A good set of related links can be found <a href="https://en.wikipedia.org/wiki/AES_instruction_set">in the Wikipedia article on AES instruction set</a> . </p><br><p>  It is possible to implement the algorithm hardware on the CPU and call its execution through special instructions.  A well-known example is <a href="https://en.wikipedia.org/wiki/AES_instruction_set">Intel's AES-NI</a> .  However, embedded processors often do not have such functionality or have restrictions on export / import.  In this case, you can install additional peripheral devices that will process the data themselves.  And, of course, the functionality of such peripherals can be implemented on the FPGA. </p><br><p>  Having decided to translate the possible into the real, we began research on hardware accelerated encryption on FPGA. </p><br><h2>  Theoretical information </h2><br><p>  In the course of researching ways to bundle hardware encryption on FPGAs and user programs, we have been stuck for a while in the study of hardware and we think it makes sense to present here some basic points. </p><br><h3 id="yadro-linux">  Linux kernel </h3><br><p>  The Linux kernel implements many cryptographic algorithms: symmetric ciphers, hashes, and block cipher modes of operation.  All this can be used by the kernel itself: for example, to encrypt disks (dm-crypt) or work VPN (IPsec).  Unified access to cryptographic functions is provided by Kernel CryptoAPI, which allows drivers to register hardware implementations of the corresponding algorithms. </p><br><p>  User programs can also access CryptoAPI.  One of the interfaces providing this feature is the socket address family <code>AF_ALG</code> and the <code>AF_ALG</code> wrapper library over it.  The main competitor of <code>AF_ALG</code> is the <code>cryptodev</code> kernel <code>cryptodev</code> (access to CryptoAPI via the character device <code>/dev/crypto</code> ). </p><br><p>  According to the authors of <code>cryptodev</code> , their solution is much more productive than <code>AF_ALG</code> (see <a href="http://cryptodev-linux.org/comparison.html">comparison</a> ). </p><br><p><img src="https://habrastorage.org/files/7ea/5d6/023/7ea5d602331a428ea963724a21579aa2.png" alt="CryptoAPI Linux"></p><br><p>  The diagram shows CryptoAPI, where two implementations of AES-128 are registered: software and hardware, accessed through the appropriate driver. </p><br><p>  A request to CryptoAPI can, for example, be <code>IPsec</code> , as well as the <code>af_alg.ko</code> and <code>cryptodev.ko</code> .  Both give user programs the opportunity to access the cryptographic subsystem of the kernel, the first through the address family, the second through the character device. </p><br><p>  As a rule, this is done transparently: CryptoAPI itself, when receiving a request, chooses which implementation to use, however, if you wish, you can learn some details of its work through the <code>/proc/crypto</code> file.  It contains, in particular, the following fields: </p><br><ul><li>  <code>name</code> - the name of the implemented algorithm. </li><li>  <code>driver</code> is a unique name for a separate implementation of the algorithm.  Those that end in <code>-generic</code> are usually standard software implementations in the kernel. </li><li>  <code>priority</code> .  If the kernel has multiple implementations of the same algorithm, it will choose the implementation with the highest priority.  Each driver itself assigns an arbitrary priority when registering an algorithm.  An implementation is selected whose priority value is the highest. </li></ul><br><h3 id="userspace">  Userspace </h3><br><p>  CryptoAPI, despite the fact that it is already a high-level abstraction, has another wrapper: very few people in userspace refer to it directly and most programs prefer using libraries, for example, <code>libcrypto</code> and <code>libssl</code> from the <code>openssl</code> project.  They are used, for example, <code>openssh</code> , <code>opvenvpn</code> and, <code>opvenvpn</code> , <code>openssl</code> .  These libraries support engines, what are usually called plug-ins, mechanisms for adding new implementations of cryptography algorithms. </p><br><p>  The <code>openssl</code> developers have already written engines for encryption in the kernel via <code>AF_ALG</code> and <code>/dev/crypto</code> .  Therefore, many programs automatically get access to the hardware implementation of the cryptoalgorithm, if it is registered in CryptoAPI. </p><br><p><img src="https://habrastorage.org/files/151/0b5/954/1510b59541804dadb4d3345f24bcdfdc.png" alt="Interaction of CpyptoAPI Kernel with Userspace Interfaces"></p><br><p>  The diagram shows several programs that use cryptographic functions provided in the <code>libssl</code> and <code>libcrypto</code> libraries that can access CryptoAPI via <code>/dev/crypto</code> or <code>AF_ALG</code> .  For example, in <code>libcrypto</code> <code>cryptodev engine</code> and <code>afalg engine</code> respectively, are specified for both. </p><br><h2>  Real experience </h2><br><p>  Having dealt with the theory, we turn to the harsh reality: the description of our practical experience. </p><br><h3 id="cel-issledovaniya">  Purpose of the study </h3><br><p>  When developing an encryption accelerator driver, the main research question was how much bandwidth between FPGAs and user programs we can provide on our CycloneV boards onboard (for example, Ethond or <a href="http://metrotek.spb.ru/cbcvsom.html">BlueSom</a> ).  In our conditions, this turned out to be important: when encryption occurs so quickly, most of the time is spent on sending data and synchronizing what is happening in different parts of the system. </p><br><h3 id="metall">  Metal </h3><br><p>  Our driver is almost completely determined by what iron provides us.  Therefore, we start with a description of the hardware. </p><br><p><img src="https://habrastorage.org/files/7d2/81d/b44/7d281db4463d4292ba5e47fd5eb00286.png" alt="The scheme of the hardware"></p><br><p>  The diagram shows a simplified model of interaction between the processor and the FPGA inside the SoC CycloneV.  For a more accurate and detailed description, you can refer to the original image in the "Introduction to the Hard Processor" chapter of the <a href="https://www.altera.com/en_US/pdfs/literature/hb/cyclone-v/cv_5v4.pdf">Cyclone V Device Handbook, Volume 3: Hard Processor Technical Reference Manual</a> , an exciting but thick book. </p><br><p>  Linux with our driver is running on MPU (Microprocessor Unit) inside HPS (Hard Processor System).  The processor can access FPGA registers via L3 SWITCH over the HPS-to-FPGA interface.  Appeals to registers in the diagram are shown by blue arrows. </p><br><p>  Devices implemented in FPGA can access SDRAM-memory via FPGA-to-HPS interface via DMA (green arrows), as well as send interrupt processor (red arrows).  The FPGA implements two independent entities: an encryption accelerator and a decryption accelerator.  Each of them consists of two related blocks, one of which implements an algorithm (encryption / decryption), and the other communicates with the memory via DMA. </p><br><p><img src="https://habrastorage.org/files/fff/6c3/650/fff6c3650fce4da5a96cef5e5a29b477.png" alt="Control status registers of encryption accelerator in FPGA"></p><br><p>  Both pairs of "blocks" implemented in the FPGA have their own registers. </p><br><p>  Encrypt Core and Decrypt Core have identical sets of registers that allow you to specify a key (Key), an initialization vector (IV, initialization vector) used in the next encryption / decryption operation. </p><br><p>  Decrypt DMA and Encrypt DMA also have a mirror structure.  Through their registers, you can specify the addresses and lengths of the memory segments ‚Äî we call these sets of parameters descriptors ‚Äî in one part of which the source data are located, and in another it is necessary to place the result of using AES.  Also available is the ability to enable and disable interrupts to alert when each descriptor has finished processing. </p><br><h3 id="crypto-api">  Crypto API </h3><br><p>  Let's tell a little more about some concepts of the Linux cryptographic subsystem. </p><br><p>  One of its main entities is "transformations" (transformation) - this is the name for any data transformations: hash sum calculation, compression, encryption.  The driver can independently "register" the transformation - provide an opportunity to use it. </p><br><p>  The class of transformation types is quite extensive, but only three of them are involved in encryption: </p><br><ul><li>  <code>CRYPTO_ALG_TYPE_CIPHER</code> : a cipher that operates on single blocks (in terms of block ciphers). </li><li>  <code>CRYPTO_ALG_TYPE_BLKCIPHER</code> : a cipher that operates on chunks of data with a length multiple of the block size, and synchronous: the cipher function does not complete until encryption is completed. </li><li>  <code>CRYPTO_ALG_TYPE_ABLKCIPHER</code> : it differs from the previous one in that it is asynchronous: the encryption function is used only to start encryption and terminates without waiting for completion.  The end of the operation is reported by the driver itself, which implements encryption. </li></ul><br><p>  In CryptoAPI, it is also possible to set "templates" (templates) - implementations of complex entities, for example, a specific mode of the block cipher or HMAC, based on simple transformations such as encrypting a single data block or calculating a hash sum. </p><br><p>  In particular, the existence of patterns allows the use of <code>CRYPTO_ALG_TYPE_CIPHER</code> to implement a block cipher, although the transformation itself operates with only 16-byte blocks.  However, this is very CPU-intensive: the kernel itself controls the operation mode of the cipher.  <code>CRYPTO_ALG_TYPE_BLKCIPHER</code> and <code>CRYPTO_ALG_TYPE_ABLKCIPHER</code> take it on themselves, and the kernel does not have to use the templates that provide the mode. </p><br><p>  Since our firmware in FPGA now implements AES-128 in CBC mode, <code>CRYPTO_ALG_TYPE_CIPHER</code> is of no interest to us: we have already implemented the required mode of operation and no additional costs are required from the processor. </p><br><p>  Our driver provides a transformation of the <code>CRYPTO_ALG_TYPE_BLKCIPHER</code> type, it seemed to us that it would be easier to implement. </p><br><p>  The transformation gives the CryptoAPI function to set the IV (initialization vector), key, for encryption and for decryption.  All this is indicated by the transformation driver when it is registered in the fields of the <code>blkcipher_alg</code> structure.  This <a href="">structure</a> looks like this: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> blkcipher_alg { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*setkey)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> crypto_tfm *tfm, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> u8 *key, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> keylen); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*encrypt)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> blkcipher_desc *desc, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> scatterlist *dst, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> scatterlist *src, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbytes); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*decrypt)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> blkcipher_desc *desc, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> scatterlist *dst, <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> scatterlist *src, <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> nbytes); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *geniv; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> min_keysize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> max_keysize; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ivsize; };</code> </pre> <br><p>  Consider the most interesting fields: <code>setkey</code> , callback for setting a key, and <code>encrypt</code> / <code>decrypt</code> for encryption / decryption.  The <code>blkcipher_desc</code> structure contains an IV for the encryption operation.  The <code>src</code> and <code>dst</code> callbacks of <code>encrypt</code> and <code>decrypt</code> set the memory areas from which you need to take the original data and in which you need to place the result. </p><br><h3 id="varianty-steka-kriptografii-na-primere-openssl">  Variants of a cryptography stack on the example of Openssl </h3><br><p>  Now we have a little better idea of ‚Äã‚Äãhow the cryptographic stack is implemented in Linux, and we can more responsibly consider various options for its construction with various attendant advantages and disadvantages. </p><br><p><img src="https://habrastorage.org/files/283/e22/0d8/283e220d8dbf4c84ade08f628f220317.png" alt="Possible options for the implementation of the driver"></p><br><p>  Obviously, if the encryption accelerator driver should be used by the kernel itself - for example, in IPsec - you need to register your implementation with CryptoAPI.  In this case, both user programs and Linux have access to the driver.  This is marked on the diagram as "Driver option 1". </p><br><p>  However, there is an alternative possibility, designated as "Driver option 2": the implementation of its interface for the user environment, bypassing CryptoAPI and the <code>cryptodev</code> and <code>af_alg</code> .  This may seem like the wrong decision: rarely avoiding standardized mechanisms leads to pleasant results.  However, we have not studied the question enough to be sure that our case is well suited for CryptoAPI and that does not impose significant limitations on performance. </p><br><p>  In the current implementation, we chose the first option, but we are ready to try the second one. </p><br><h3 id="arhitektura-soc-aes-accel">  Soc-aes-accel architecture </h3><br><p>  When the kernel wants us to encrypt or decrypt something, it calls our functions <code>fpga_encrypt</code> and <code>fpga_decrypt</code> .  They have identical signatures and do the same thing, only one refers to the registers of the encryption device in the FPGA, and the second - to the registers of the encrypting device. </p><br><p>  These functions take two pointers to arrays from a <code>struct scatterlist</code> .  Each of them stores a sequence of memory areas: <code>src</code> - where to get the source data, <code>dst</code> - where to put the result.  It is guaranteed that each of these pieces of memory does not cross the borders of one page. </p><br><p>  The driver task looks trivial: </p><br><ol><li>  Display the addresses of each memory area in the corresponding bus addresses - those on which the device can make calls on DMA; </li><li>  Write the bus addresses and lengths of memory areas in the registers of the DMA controller; </li><li>  Ask the DMA controller to send an interrupt after processing all the pieces; </li><li>  Wait for the interrupt. </li></ol><br><p>  But the devil is in the details: the version of the DMA controller in the FPGA, which we have implemented, accepts only input data that is a multiple of 16 bytes.  Soon this restriction will be removed, but as long as FPGA developers do not have time to change the firmware, we work with what we have: copy the memory pieces that are not multiple to 16 bytes into the serial buffer. </p><br><p><img src="https://habrastorage.org/files/9dd/af5/168/9ddaf51684e44278a949792c4ae1af03.png" alt="Memory alignment circuit"></p><br><h3 id="proizvoditelnost">  Performance </h3><br><p>  Now, when the driver is written, you need to answer the burning question: how productive is it? </p><br><p>  Of course, it would be possible to use openssl for measurements, however, we decided to write our own program <a href="">openssl_benchmark.c</a> : openssl does not provide us with sufficient flexibility.  In particular, you cannot set the exact size of a single buffer that will be sent to libcrypto, since openssl may decide to process the input data in parts.  Also, performance indicators become more difficult to distinguish, as it takes some time to input / output, allocate memory, initialize openssl, and the like. </p><br><p>  Our program works simply: it allocates and zeros the buffers of a given size as input, and then sends them to libcrypto for processing the specified number of times.  It only measures the time spent on calls to libcrypto.  Due to the fact that the processing takes place repeatedly, it is possible to quite accurately determine the performance of precisely performing AES without taking into account the losses caused by auxiliary tasks like receiving input data. </p><br><p>  Using this program, we encrypted and decrypted buffers of different lengths (1000 operations of both types for each buffer length).  Then they calculated the bandwidth in Mbps.  We did all this twice: in the first case, libcrypto encrypted our data with its software implementation ("Software" on the charts), in the second - gave it to the kernel via the cryptodev engine ("Hardware" on the charts). </p><br><p><img src="https://habrastorage.org/files/4a1/7f6/cd9/4a17f6cd952d48039273ecff3dc9c967.png" alt="Encryption performance"><br><img src="https://habrastorage.org/files/5ea/c40/099/5eac400990604de4a769369d1fb3a1e9.png" alt="Decryption performance"></p><br><p>  Of particular interest is the moment in which the hardware implementation overtakes the software in terms of bandwidth.  Let's take measurements at a smaller interval and at smaller intervals: </p><br><p><img src="https://habrastorage.org/files/f5d/569/803/f5d569803f2b49d3b4106d6e2e87408b.png" alt="Encryption performance"><br><img src="https://habrastorage.org/files/c9b/3f7/a74/c9b3f7a749e643c3be2e22bc38edef74.png" alt="Decryption performance"></p><br><p>  We see that the performance of the software implementation is almost independent of the buffer size.  This can be explained by the fact that the data exchange between our program and libcrypto is very fast and as the buffer size grows, it quickly becomes imperceptible to waste time on calling functions. </p><br><p>  With encryption on FPGA, the situation is more complicated.  A call to librypto is sent to the cryptodev engine, it opens <code>/dev/crypto</code> , sets up a session for encryption with several system calls, and only then sends pointers to the encryption buffers to the <code>cryptodev</code> module.  That, in turn, forms in the form of a <code>struct scatterlist *</code> two lists of physical pages, onto which a user buffer is projected in its virtual address space, and passes to CryptoAPI.  Our driver has the highest priority of all registered implementations of AES, so it gets lists.  When the driver makes sure that the lengths of all the pieces of memory are a multiple of the length of the AES block, he gets the corresponding bus addresses and writes them to the FPGA registers. </p><br><p>  We see that requests between FPGAs and user programs must pass through several layers and the time losses on them are very large.  Only the data of a very large amount of bandwidth ceases to strongly influence the time for the implementation of the request.  On the graph, this moment can be determined by the fact that the line becomes almost horizontal: most of the time is spent on data processing. </p><br><p>  A reader who looks not only at the shape of the lines, but also at specific numerical values, of course, wonders: why is decryption stabilized at 250 Mbps, and encryption at 400 Mbps?         ,   ,   FPGA,    ,      -. </p><br><p>  ,   CPU    .    CPU         : CPU     ,       .   ,    . </p><br><p>                       CPU  <code>top</code> . ,   " "   <code>top</code>    ,   ,     - . </p><br><p>   : </p><br><table><tbody><tr><td rowspan="2"></td><td colspan="6">   </td></tr><tr><td>  sixteen </td><td>  256 </td><td>  1024 </td><td>  4096 </td><td> 8192 </td><td> 450000 </td></tr><tr><td>  </td><td>  92% </td><td>  89% </td><td>  81% </td><td>  63% </td><td>  53% </td><td>  29% </td></tr><tr><td>  </td><td>  93% </td><td>  91% </td><td>  86% </td><td>  74% </td><td>  64% </td><td>  43% </td></tr></tbody></table><br><p>       - ,     FPGA           ,    FPGA   . </p><br><p> ,     ,        ,    CPU.    ,         ,      . </p><br><h2>  Conclusion </h2><br><p>   FPGA          .             :          .          .                  - . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/324042/">https://habr.com/ru/post/324042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../324028/index.html">Four kinds of accidents in Hearthstone</a></li>
<li><a href="../324030/index.html">Chaincode debugging in Hyperledger Fabric</a></li>
<li><a href="../324034/index.html">CSS slider</a></li>
<li><a href="../324036/index.html">Hackathon of Kaspersky Lab: save the gas oil processing plant from hackers</a></li>
<li><a href="../324038/index.html">Video recordings of the best reports of DotNext 2016 Moscow: Performance, CLR and functional programming on .NET</a></li>
<li><a href="../324046/index.html">Feature, not a bug. Or how Rambler allows to replace the sender of the letter</a></li>
<li><a href="../324048/index.html">I am an impostor</a></li>
<li><a href="../324052/index.html">Another algorithm for recovering blurred images</a></li>
<li><a href="../324056/index.html">The path to the dream</a></li>
<li><a href="../324060/index.html">What is Resizable Concurrent Map</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>