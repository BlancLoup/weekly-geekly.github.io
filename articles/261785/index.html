<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Seven amazing "features" Javascript</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Over the past few months, I have made a few JSHint for JSHint , mainly with the goal of exploring ES6 (I'm particularly proud of how the scope scans f...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Seven amazing "features" Javascript</h1><div class="post__text post__text-html js-mediator-article"> Over the past few months, I have made a few <code>JSHint</code> for <code>JSHint</code> , mainly with the goal of exploring ES6 (I'm <a href="https://github.com/lukeapage/jshint/commit/08eb4e25962eb71f94c09f79b3b08288b91a7bce">particularly proud of</a> how the scope scans for variables are redone).  During this process, I came across a few things that surprised me - mostly in ES6, but there is also something about ES3 that I have never used before. <br><br><h2>  Break from any block </h2><br>  Surely you know that in any cycle you can use the keywords <code>break</code> and <code>continue</code> - this is a standard feature in modern programming languages.  However, not everyone knows that cycles can be given labels and with their help interrupt any particular cycle: <br><br><pre> <code class="javascript hljs">outer: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">4</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> outer; } }</code> </pre><a name="habracut"></a><br>  The same applies to <code>break</code> .  You have probably seen how it is used in a <code>switch</code> : 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; }</code> </pre><br>  Generally speaking, this is why Crockford does not advise adding indents before <code>case</code> - the expression <code>break</code> throws out of the <code>switch</code> block, not <code>case</code> , but for me the option with indents seems more readable.  Switch <code>switch</code> can also be tagged with: <br><br><pre> <code class="javascript hljs">myswitch: <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(i) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> myswitch; }</code> </pre><br>  You can also declare blocks just like that.  I know that this is also available in C #, and probably in other languages ‚Äã‚Äãtoo: <br><br><pre> <code class="javascript hljs">{ { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"   "</span></span>); } }</code> </pre><br>  If you put it all together, you can exit any block using a label: <br><br><pre> <code class="javascript hljs">outer: { <span class="hljs-attr"><span class="hljs-attr">inner</span></span>: { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> outer; } } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"    "</span></span>); }</code> </pre><br>  Of course, this only applies to <code>break</code> - the <code>continue</code> statement is valid only inside the loop.  I have never seen labels in Javascript code - most likely, because if you suddenly need to urgently exit more than one block, this is a reason to rewrite the code to a function with <code>return</code> . <br><br>  However, if I suddenly wanted to write a function with a single exit point (which, generally speaking, is not to my taste), one could use this approach.  Here, for example, is a function with multiple exit points: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b; }</code> </pre><br>  Add tags, and it turns out this: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> returnValue = b; myBlock: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b) { returnValue = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> myBlock; } doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { returnValue = c; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnValue; }</code> </pre><br>  Or, one could use more blocks: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> returnValue = b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b) { returnValue = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doSomething(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c) { returnValue = c; } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> returnValue; }</code> </pre><br>  In general, the option with labels I like the least, but maybe only because I was not used to it? <br><br><h3>  Destructuring an existing variable </h3><br>  First - a trick that I can not explain.  In ES3, apparently, you can add parentheses around the variable when assigning and it will work: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a; (a) = <span class="hljs-number"><span class="hljs-number">1</span></span>; assertTrue(a === <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><br>  If you know why someone might need to do this, please write in the comments. <br><br>  Destructuring is the process of getting the value of a variable from an object or array.  Most often you can see a similar example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pullOutInParams</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{a}, [b]</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">pullOutInLet</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">obj, arr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> {a} = obj; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> [b] = arr; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a, b); } pullOutInParams({<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> }, [<span class="hljs-string"><span class="hljs-string">"World"</span></span>]); pullOutInLet({<span class="hljs-attr"><span class="hljs-attr">a</span></span>: <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> }, [<span class="hljs-string"><span class="hljs-string">"World"</span></span>]);</code> </pre><br>  But you can do the same without <code>let</code> , <code>var</code> and <code>const</code> .  For an array, just write like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a; [a] = array;</code> </pre><br>  But with the object does not work - it must be wrapped in parentheses: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a; ({a} = array);</code> </pre><br>  The reason is that it gives too much room for ambiguous interpretation and errors associated with anonymous blocks of code, because the <abbr title="automatic semi-colon insertion, ASI">automatic placement of semicolons</abbr> turns identifiers into calculated expressions, and they can have side effects: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = { get b() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"!"</span></span>); } }; <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>(a) { { b } }</code> </pre><br>  Returning to the original example, where we have concluded the assignment in parentheses - contrary to assumptions, this has nothing to do with restructuring: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a, b, c; (a) = <span class="hljs-number"><span class="hljs-number">1</span></span>; [b] = [<span class="hljs-number"><span class="hljs-number">2</span></span>]; ({c} = { <span class="hljs-attr"><span class="hljs-attr">c</span></span> : <span class="hljs-number"><span class="hljs-number">3</span></span> });</code> </pre><br><h3>  Destructuring with numbers </h3><br>  Another aspect of destructuring that not everyone can suspect is that property names do not have to be unquoted lines.  These can be numbers: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> {<span class="hljs-number"><span class="hljs-number">1</span></span> : a} = { <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre><br>  Or quoted strings: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> {<span class="hljs-string"><span class="hljs-string">"1"</span></span> : a} = { <span class="hljs-string"><span class="hljs-string">"1"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre><br>  And you can also calculate the property name from the expression: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myProp = <span class="hljs-string"><span class="hljs-string">"1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> {[myProp] : a} = { [myProp]: <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre><br>  This makes it easy to write very convoluted code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-string"><span class="hljs-string">"a"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> {[a] : [a]} = { <span class="hljs-attr"><span class="hljs-attr">a</span></span>: [a] };</code> </pre><br><h3>  Class declarations are block-bound </h3><br>  Function declarations <abbr title="hoisted">rise</abbr> to the very top of the block, which allows them to be used before the declaration: <br><br><pre> <code class="javascript hljs">func(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); }</code> </pre><br>  But if a function is declared during the assignment of a variable, then only the declaration of the variable is raised, but not the value assigned to it: <br><br><pre> <code class="javascript hljs">func(); <span class="hljs-comment"><span class="hljs-comment">// func ,    ,   "func   " var func = function func() { console.log("  "); };</span></span></code> </pre><br>  Classes are one of the most popular parts of the ES6 specification, and have always been considered a kind of syntactic sugar for functions.  However, if you think that this code will work, then you are mistaken: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> func(); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">func</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"  "</span></span>); } }</code> </pre><br>  Despite the similarities with the first example, it does not work.  This is actually the equivalent of the following code: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> func(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> func = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Fine"</span></span>); }</code> </pre><br>  Here we are trying to access <code>func</code> inside the <abbr title="Temporal dead zone, TDZ">temporary dead zone</abbr> , which is a syntax error. <br><br><h3>  Parameters-namesake </h3><br>  I assumed that a function cannot have two parameters with the same name - but in fact it can! <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); } func(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ""</span></span></code> </pre><br>  However, in strict mode, everything is not so: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">"use strict"</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(a); } func(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  Chrome   - SyntaxError: Strict mode function may not have duplicate parameter names</span></span></code> </pre><br><h3>  <code>typeof</code> operator unsafe </h3><br>  Okay, okay, I <a href="http://es-discourse.com/t/why-typeof-is-no-longer-safe/15">stole this observation</a> , but it will not be superfluous to repeat it anyway. <br><br>  Before ES6, it was widely known that using the <code>typeof</code> operator, you can safely find out if an identifier is declared, even if it is not assigned a value: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span> !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Symbol  } //    ,  Symbol   if (Symbol !== "undefined") { }</span></span></code> </pre><br>  But now it only works if you have not declared a variable using <code>let</code> or <code>const</code> .  It‚Äôs all the fault of <abbr title="Temporary dead zone">VSW</abbr> , due to which accessing a variable before assigning it is a syntax error, even though ‚Äúunder the hood‚Äù the declaration of the variable still rises to the very top of the block. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Symbol</span></span> !== <span class="hljs-string"><span class="hljs-string">"undefined"</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Symbol  } let Symbol = true; //      !</span></span></code> </pre><br><h3>  Array creation </h3><br>  I have always avoided creating an array using the <code>new</code> keyword.  Basically, because arguments can be either the length of an array, or its elements: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">// [undefined] new Array(1, 2); // [1, 2]</span></span></code> </pre><br>  However, a colleague recently stumbled upon something that I had never met before: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; arr.length; i++) { arr[i] = i; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.dir(arr);</code> </pre><br>  This code produces an array with numbers from 0 to 9. And what will happen if you refactor it using <code>map</code> ? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>); arr = arr.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item, index</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index; }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.dir(arr);</code> </pre><br>  The array remained unchanged.  Apparently, a constructor that takes a length creates an array and sets the <code>length</code> property, but does not create any elements.  Therefore, you can access the property, but you cannot list the elements.  And if you set the value of any element? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>); arr[<span class="hljs-number"><span class="hljs-number">8</span></span>] = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; arr = arr.map(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">item, index</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> index; }); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.dir(arr);</code> </pre><br>  We get an array, where the eighth element is assigned the number 8, but all other values ‚Äã‚Äãare not specified.  If you look at the polyfill code for the <code>map</code> function, it checks the property of the property using the <code>in</code> operator.  The same behavior can be achieved using array literals: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> arr = []; arr[<span class="hljs-number"><span class="hljs-number">9</span></span>] = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var arr = []; arr.length = 10;</span></span></code> </pre><br><h3>  Other pearls </h3><br>  There is a <a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/">great article on the</a> Mozilla developers blog <a href="https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/">about functions with arrows</a> , which state that comments can be marked with the symbol <code>&lt;--</code> .  Not bad and read the <a href="https://hacks.mozilla.org/category/es6-in-depth/">rest of the</a> blog posts. </div><p>Source: <a href="https://habr.com/ru/post/261785/">https://habr.com/ru/post/261785/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../261775/index.html">Getting Started with Junos PyEZ</a></li>
<li><a href="../261777/index.html">Batcher's even-odd merge sort</a></li>
<li><a href="../261779/index.html">Express analysis of suspicious activity in the web server log</a></li>
<li><a href="../261781/index.html">About the intricacies of privacy in the Telegram Bots API: ‚Äúthis is not a bug, this is a feature‚Äù</a></li>
<li><a href="../261783/index.html">Vim in full: Working with Git</a></li>
<li><a href="../261787/index.html">Remote injection of Wi-Fi frames</a></li>
<li><a href="../261789/index.html">And do not you go to the clouds?</a></li>
<li><a href="../261799/index.html">Receive notifications from external services, or why Hooksler was made</a></li>
<li><a href="../261801/index.html">Introducing Nim: writing a console 2048</a></li>
<li><a href="../261803/index.html">Magic of tensor algebra: Part 4 - Dynamics of a point in a tensor statement</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>