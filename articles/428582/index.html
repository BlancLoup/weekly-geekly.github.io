<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The forgotten story of the PLO</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most of the programming paradigms that we use today were first mathematically studied in the 1930s using the ideas of lambda calculus and the Turing m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The forgotten story of the PLO</h1><div class="post__text post__text-html js-mediator-article">  Most of the programming paradigms that we use today were first mathematically studied in the 1930s using the ideas of lambda calculus and the Turing machine, which are variants of the model of universal computing (these are formalized systems that can perform general-purpose calculations).  The Church-Turing thesis showed that lambda calculus and Turing machines are functionally equivalent.  Namely, we are talking about the fact that everything that can be calculated using the Turing machine can be calculated using the lambda calculus, and vice versa. <br><br> <a href="https://habr.com/company/ruvds/blog/428582/"><img src="https://habrastorage.org/webt/hq/so/jp/hqsojpds8ed1zxx9g7lelnfknbu.jpeg"></a> <br><a name="habracut"></a><br>  There is a common misconception that Turing machines can calculate everything that can be calculated.  There are classes of problems (for example, the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8">problem of stopping</a> ) that can be computable using Turing machines only for some cases.  When the word "computable" is used in this text, it is meant "computable by the Turing machine". <br><br>  Lambda calculus demonstrates the approach of applying functions to calculations from the top-down principle.  And the Turing tape machine is an imperative (step-by-step) approach to calculations, implemented on a ‚Äúbottom-up‚Äù basis. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Low-level programming languages, such as machine code or assembler, appeared in the 1940s, and by the end of the 1950s, the first popular high-level languages ‚Äã‚Äãemerged that implemented both functional and imperative approaches.  So, Lisp dialects are still widely used, among them Clojure, Scheme, AutoLisp, and so on.  In the fifties, languages ‚Äã‚Äãsuch as FORTRAN and COBOL appeared.  They are examples of imperative high-level languages ‚Äã‚Äãthat are still alive.  Although it should be noted that the languages ‚Äã‚Äãof the C family, in most spheres, replaced both COBOL and FORTRAN. <br><br>  The roots of imperative and functional programming lie in the formal mathematics of computing, they appeared before digital computers.  Object Oriented Programming, or OOP (Object Oriented Programming, OOP), came later, it originated in a structural programming revolution that took place in the sixties and seventies of the last century. <br><br>  The first object I knew was used by Ivan Sutherland in his fateful Sketchpad application, created between 1961 and 1962, which he described in <a href="https://dspace.mit.edu/handle/1721.1/14979">this</a> work in 1963.  The objects were graphic signs displayed on the oscilloscope screen (perhaps this is the first ever case of using a graphical computer monitor), and supporting inheritance through dynamic delegates, which Ivan Sutherland called masters in his work.  Any object could become a master object, additional instances of the object were called "implementations" (occurrences).  This made Sketchpad the owner of the first known programming language that implemented prototype inheritance. <br><br>  The first programming language, widely known as "object-oriented", was the Simula language, specifications of which were developed in 1965.  Like Sketchpad, Silmula involved working with objects, but also included classes, class-based inheritance, subclasses, and virtual methods. <br><br>  <i><font color="#999999">A virtual method is a method defined in a class that is intended to be redefined by subclasses.</font></i>  <i><font color="#999999">Virtual methods allow programs to call methods that may not exist at the time of compilation of code, thanks to the use of dynamic dispatch to determine which particular method to call during program execution.</font></i>  <i><font color="#999999">JavaScript has dynamic types and uses a delegation chain to determine which method to call. As a result, this language does not need to introduce the concept of virtual methods to programmers.</font></i>  <i><font color="#999999">In other words, all methods in JavaScript use dispatching at runtime; as a result, methods in JavaScript do not need to be declared ‚Äúvirtual‚Äù to support this feature.</font></i> <br><br><h2>  <font color="#3AC1EF">The opinion of the father of the PLO on the PLO</font> </h2><br>  <i><font color="#999999">"I came up with the term" object-oriented ", and I can say that I did not mean C ++."</font></i>  <i><font color="#999999">Alan Kay, OOPSLA Conference, 1997.</font></i> <br><br>  Alan Kay coined the term "object-oriented programming," meaning Smalltalk programming language (1972).  This language was developed by Alan Kay, Dan Ingles and other employees of the Xerox PARC research and development center as part of a project to create a Dynabook device.  Smalltalk was more object oriented than Simula.  In Smalltalk, everything is an object, including classes, integers, and blocks (closures).  The initial implementation of the language, Smalltalk-72, did not have the ability to create subclasses.  This feature appeared in Smalltalk-76. <br><br>  While Smalltalk supported classes, and, as a result, the creation of subclasses, in Smalltalk these ideas were not put at the forefront.  It was a functional language that Lisp influenced as much as Simula.  According to Alan Kay, treating classes as a code reuse mechanism is a mistake.  The programming industry pays great attention to creating subclasses, distracting from the real advantages of object-oriented programming. <br><br>  JavaScript and Smalltalk have a lot in common.  I would say that JavaScript is a Smalltalk revenge on the world for misunderstanding OOP concepts.  Both of these languages ‚Äã‚Äãsupport the following features: <br><br><ul><li>  Objects </li><li>  First class and closure functions. </li><li>  Dynamic types </li><li>  Late binding (functions and methods can be replaced during program execution). </li><li>  OOP without a class-based inheritance system. </li></ul><br>  <i><font color="#999999">‚ÄúI regret the fact that a long time ago I came up with the term‚Äú objects ‚Äùfor this phenomenon, since its use leads to the fact that many people give the main meaning to an idea that is not as important as the main one.</font></i>  <i><font color="#999999">The basic idea is messaging. ‚Äù</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  In 2003 e-mail <a href="http://www.purl.org/stefan_ram/pub/doc_kay_oop_en">correspondence</a> , Alan Kay clarified what he had in mind when he called Smalltalk "object-oriented language." <br><br>  <i><font color="#999999">"OOP for me means only messaging, local storage, and protection, and hiding the state, and very late binding."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  In other words, in accordance with the ideas of Alan Kay, the most important ingredients of the PLO are the following: <br><br><ul><li>  Messaging. </li><li>  Encapsulation. </li><li>  Dynamic linking </li></ul><br>  It is important to note that Alan Kay, the man who invented the term "OOP" and brought it to the masses, did not consider inheritance and polymorphism to be the most important components of the OOP. <br><br><h2>  <font color="#3AC1EF">Essence OOP</font> </h2><br>  The combination of messaging and encapsulation serves several important purposes: <br><br><ul><li>  Avoiding the shared mutable state of an object by encapsulating the state and isolating other objects from local changes in its state.  The only way to influence the state of another object is to ask him (and not give him a command) about the change by sending him a message.  State changes are controlled at the local, cellular level, the state is not made available to other objects. </li><li>  Separation of objects from each other.  The sender of the message is loosely associated with the recipient through the message API. </li><li>  Adaptability and resistance to change during program execution through late binding.  Adapting to changes during program execution provides many significant benefits that Alan Kay considered to be very important for the PLO. </li></ul><br>  The sources of inspiration for Alan Kay, who expressed these ideas, were his knowledge of biology, and what he knew about ARPANET (this is an early version of the Internet).  Namely, we are talking about biological cells and about individual computers connected to the network.  Even then, Alan Kay imagined how programs run on huge, distributed computers (the Internet), while individual computers act like biological cells, independently working with their own isolated state and communicating with other computers by sending messages. <br><br>  <i><font color="#999999">‚ÄúI realized that the metaphor of a cell or computer would help get rid of the data [...]‚Äù.</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  Saying ‚Äúhelp get rid of the data,‚Äù Alan Kay, of course, was aware of the problems caused by the shared mutable state, and the strong connectivity caused by sharing data.  Today, these topics are widely heard.  But in the late 1960s, ARPANET programmers were unhappy with the need to choose a data model representation for their programs before starting to develop programs.  The developers wanted to get away from this practice, since, in advance of driving themselves into the framework determined by the presentation of data, it is more difficult to change something in the future. <br><br>  The problem was that different ways of presenting data required, for access to them, different code and different syntax in the programming languages ‚Äã‚Äãused at some point in time.  The holy grail here would be a universal way to access and manage data.  If all the data looked the same for a program, it would solve a lot of problems for developers regarding the development and maintenance of programs. <br>  Alan Kay was trying to "get rid" of the idea, in accordance with which the data and programs were, in a sense, independent entities.  They are not treated as such in the List or in Smalltalk.  There is no separation between what you can do with data (with values, variables, data structures, and so on) and software constructs like functions.  Functions are ‚Äúfirst class citizens‚Äù, and programs are allowed to change during their execution.  In other words, there is no particular, privileged relationship to data in Smalltalk. <br><br>  Alan Kay, moreover, considered objects as algebraic structures, which provided certain, mathematically demonstrable, guarantees of their behavior. <br><br>  <i><font color="#999999">"My mathematical education allowed me to understand that each object can have several algebraic models associated with it, that there can be whole groups of similar models, and that they can be very, very useful."</font></i>  <i><font color="#999999">Alan Kay</font></i> <br><br>  It was proved that this is the case, and this formed the basis for objects such as promises and lenses, and both the theory of categories had an impact on both. <br>  The algebraic nature of how Alan Kay saw objects would allow objects to provide formal verification, deterministic behavior, improve testability, since algebraic models are, in essence, operations that obey several rules in the form of equations. <br><br>  In the jargon of programmers, ‚Äúalgebraic models‚Äù are abstractions created from functions (operations) that accompany certain rules enforced by modular tests that these functions must pass (axioms, equations). <br><br>  These ideas have been forgotten for decades in most object-oriented C family languages, including C ++, Java, C #, and so on.  But these ideas are beginning to search for the way back, in recent versions of the most widely used object-oriented languages. <br><br>  On this occasion, one might say that the programming world rediscovers the benefits of functional programming and makes rational arguments in the context of object-oriented languages. <br><br>  Like JavaScript and Smalltalk earlier, most modern object-oriented languages ‚Äã‚Äãare becoming more and more ‚Äúmulti-paradigm."  There is no reason to choose between functional programming and OOP.  When we look at the historical essence of each of these approaches, they look not only as compatible, but also as complementary ideas. <br><br>  What, according to Alan Kay, is the most important thing in the PLO? <br><br><ul><li>  Encapsulation. </li><li>  Messaging. </li><li>  Dynamic binding (the ability of programs to evolve and adapt to changes during their implementation). </li></ul><br>  What is insignificant in OOP? <br><br><ul><li>  Classes. </li><li>  Class based inheritance. </li><li>  Special treatment of objects, functions, or data. </li><li> Keyword <code>new</code> . </li><li>  Polymorphism. </li><li>  Static typing. </li><li>  Attitude to classes as to "types". </li></ul><br>  If you know Java or C #, you might think that static typing or polymorphism are the most important ingredients of OOP, but Alan Kay prefers to deal with universal patterns of behavior in algebraic form.  Here is an example written in Haskell: <br><br><pre> <code class="hljs erlang-repl">fmap :: (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  This is the signature of the universal functor <code>map</code> , which works on the indefinite types <code>a</code> and <code>b</code> , applying the function <code>a</code> to <code>b</code> in the context of the functor <code>a</code> in order to create the functor <code>b</code> .  A ‚Äúfunctor‚Äù is a word from mathematical jargon, the meaning of which comes down to ‚Äúsupporting a mapping operation‚Äù.  If you are familiar with the <code>[].map()</code> method in JavaScript, then you already know what that means. <br><br>  Here are a couple of JavaScript examples: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> isEven = Number =&gt; Boolean const isEven = n =&gt; n % <span class="hljs-number"><span class="hljs-number">2</span></span> === <span class="hljs-number"><span class="hljs-number">0</span></span>; const nums = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  map   `<span class="javascript"><span class="javascript">a =&gt; b</span></span>`    `<span class="javascript"><span class="javascript">a</span></span>` ( `<span class="javascript"><span class="hljs-keyword"><span class="javascript"><span class="hljs-keyword">this</span></span></span></span>`) <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     `<span class="javascript"><span class="javascript">b</span></span>` <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    `<span class="javascript"><span class="javascript">a</span></span>`   `<span class="javascript"><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Number</span></span></span></span>`,   `<span class="javascript"><span class="javascript">b</span></span>`  `<span class="javascript"><span class="hljs-built_in"><span class="javascript"><span class="hljs-built_in">Boolean</span></span></span></span>` const results = nums.map(isEven); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(results); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> [<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>]</code> </pre> <br>  The <code>.map()</code> method is universal, in the sense that <code>a</code> and <code>b</code> can be of any type, and this method can easily cope with this situation, since arrays are data structures that implement the algebraic laws of functors.  Types for <code>.map()</code> do not matter, as this method does not attempt to work with the corresponding values ‚Äã‚Äãdirectly.  Instead, it uses a function that expects and returns values ‚Äã‚Äãof appropriate types that are correct from the point of view of the application. <br><br><pre> <code class="hljs pgsql">// matches = a =&gt; <span class="hljs-type"><span class="hljs-type">Boolean</span></span> //  `a`    ,   const matches = control =&gt; input =&gt; input === control; const strings = [<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar'</span></span>, <span class="hljs-string"><span class="hljs-string">'baz'</span></span>]; const results = strings.map(matches(<span class="hljs-string"><span class="hljs-string">'bar'</span></span>)); console.log(results); // [<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>]</code> </pre> <br>  Relationships of generic types can be difficult to correctly and fully express in languages ‚Äã‚Äãlike TypeScript, but this is very easy to do in the Hindley-Milner type system used in Haskell, which supports higher types of genders (types of types). <br><br>  Most type systems provide too strong restrictions to allow free expression of dynamic and functional ideas, such as the composition of functions, the free composition of objects, the expansion of objects during program execution, the use of combinators, lenses, and so on.  In other words?  static types often make it difficult to write software using build methods. <br><br>  If your type system is distinguished by too many restrictions (as in TypeScript or in Java), then you have to write more complex code to achieve the same goals than when using languages ‚Äã‚Äãwith a freer approach to typing.  This does not mean that using static types is a bad idea, or that all implementations of static types are characterized by the same restrictions.  I, for example, encountered much fewer problems working with the Haskell type system. <br><br>  If you are a fan of static types and not against restrictions, I wish you seven feet under the keel.  But if you find that some of the ideas expressed here are difficult to implement because it is not easy to typify the functions obtained by combining other functions and composite algebraic structures, then blame the type system and not the ideas.  Drivers like the amenities that frame SUVs give them, but no one complains that they don‚Äôt fly.  To fly you need a vehicle that has more degrees of freedom. <br><br>  If restrictions simplify your code, that's great!  But if restrictions force you to write more complex code, then maybe something is wrong with these restrictions. <br><br><h2>  <font color="#3AC1EF">What is an "object"?</font> </h2><br>  The word "object", over time, has acquired many side shades of meaning.  What we call ‚Äúobjects‚Äù in JavaScript is simply composite data types, with no hint of class-based programming or Alan Kay‚Äôs message passing ideas. <br><br>  In JavaScript, these objects can support, and often support, encapsulation, message passing, behavioral separation, even polymorphism using subclasses (albeit using a delegation chain rather than type-based dispatching). <br><br>  Alan Kay wanted to get rid of the difference between the program and its data.  JavaScript, to some extent, achieves this goal by placing the methods of the objects in the same place as the properties that store the data.  Any property, for example, can be assigned to any function.  You can dynamically design the object's behavior and change the semantic content of the object during the execution of the program. <br><br>  An object is just a composite data structure, and it does not need anything special in order to be considered an object.  However, programming with the use of objects does not lead to the fact that such code turns out to be ‚Äúobject-oriented‚Äù, just as the use of functions does not make the code ‚Äúfunctional‚Äù. <br><br><h2>  <font color="#3AC1EF">OOP is no longer a real OOP.</font> </h2><br>  Since the concept of ‚Äúobject‚Äù in modern programming languages ‚Äã‚Äãmeans much less than that for Alan Kay, I use the word ‚Äúcomponent‚Äù instead of the word ‚Äúobject‚Äù to describe the rules of this OOP.  Some objects are owned and controlled directly by some third-party JavaScript code in relation to them, but components must encapsulate their own state and control it. <br><br>  This is what the real PLO is: <br><br><ul><li>  Programming using components (Alan Kay calls them "objects"). </li><li>  The state of the component must be encapsulated. </li><li>  For communication between entities, message passing is used. </li><li>  Components can be added, modified and replaced during program execution. </li></ul><br>  Most object behaviors can be defined in a generic form using algebraic data structures.  There is no need for inheritance.  Components can reuse behaviors from publicly available functions and import modules without having to make their data publicly available. <br><br>  Manipulating objects in JavaScript or using class-based inheritance does not mean that someone is OOP programming.  But the use of components in such ways means.  But it‚Äôs very difficult to get rid of well-established notions about terms, so perhaps we should leave the term ‚ÄúOOP‚Äù and name what the above described ‚Äúcomponents‚Äù use, ‚ÄúMessage Oriented Programming (MOP)‚Äù?  Below, we will use the term ‚ÄúMOP‚Äù when talking about message-oriented programming. <br><br>  By chance, the English word "mop" is translated as "mop", and they are known to be used to restore order. <br><br><h2>  <font color="#3AC1EF">What does a good MOP look like?</font> </h2><br>  In most modern programs, there is a certain user interface (User Interface, UI) that is responsible for user interaction, some code involved in managing the state of the application (user data), and code that works with the system or is responsible for communicating with the network. <br><br>  Each of these systems may require long-lived processes, such as event listeners.  It will also need the state of the application - to store something like information about network connections, the status of interface controls, and the application itself. <br><br>  A good MOP means that instead of all such systems having access to each other‚Äôs state and being able to directly control it, they interact with each other through messages.  When the user clicks the Save button, the message <code>"SAVE"</code> can be dispatched.  The application component responsible for managing the state can interpret this message and redirect it to the handler responsible for updating from the state (such as a pure reducer function).  Perhaps after updating the state, the component responsible for managing the state dispatches the message <code>"STATE_UPDATED"</code> the user interface component, which in turn interprets the state, decides which parts of the interface need to be updated, and passes the updated state to the subcomponents who are responsible for specific interface elements. <br><br>  Meanwhile, the component responsible for network connections can monitor the user's connection to another computer on the network, listen for messages, and dispatch an updated status view to save it to the remote machine.  This component is responsible for working with network mechanisms, knows whether the connection is working or not, and so on. <br><br>  Such systems applications should not know the details of its other parts.  They should only care about solving their own problems.  System components can be disassembled and assembled as a constructor.  They implement standardized interfaces, which means that they can interact with each other.  As long as the well-known interface requirements of the components are fulfilled, such components can be replaced by others, with the same interfaces, but doing the same thing differently, or performing, accepting the same messages, something completely different.  It is possible to change one component to another even during the execution of the program - this will not break its work. <br><br>  The components of some kind of software system do not even have to be on the same computer.  The system can be decentralized.  Network storage can place data in a decentralized data storage system like <a href="https://en.wikipedia.org/wiki/InterPlanetary_File_System">IPFS</a> , as a result, the user is independent of the health of some specific machine, which ensures the safety of its data.  With this approach, data is securely stored and protected from intruders. <br><br>  The PLO, in part, came under the influence of the ideas of ARPANET, and one of the goals of this project was to create a decentralized network that would be resistant to attacks like a nuclear strike. <br><br>  A good MOP system can have a similar level of resiliency using components that support hot swapping while the application is running.  It will be able to continue functioning if the user is working with her from a cell phone and was out of the network coverage area because he entered the tunnel.  If the hurricane broke the power supply of one of the data centers in which its servers are located, it will also continue to function. <br><br>  The time has come for the world of software to free itself from a failed experiment with class-based inheritance and adopt the mathematical and scientific principles that were at the origin of the PLO. <br><br>  The time has come for us, the developers, to create more flexible, stable, beautiful programs using a harmonious combination of MOP and functional programming. <br>  By the way, the acronym ‚ÄúMOP‚Äù is already used, describing ‚ÄúMonitoring oriented programming‚Äù (Monitoring Oriented Programming), but this concept, unlike OOP, will just quietly disappear. <br><br>  So do not be discouraged if the term ‚ÄúMOP‚Äù does not look like a word from the jargon of programmers.  Simply put your OOP in order using the above MOP principles. <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/428582/">https://habr.com/ru/post/428582/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428572/index.html">Higher-order components in React</a></li>
<li><a href="../428574/index.html">We take corporate communication to a new level with Zextras Chat</a></li>
<li><a href="../428576/index.html">[bookmark] Node.js pdf guide and new javascript guide</a></li>
<li><a href="../428578/index.html">How to start working with Hibernate Search</a></li>
<li><a href="../428580/index.html">Fruitful Communication Guide</a></li>
<li><a href="../428588/index.html">IT digest of November events (part two)</a></li>
<li><a href="../428590/index.html">Micro-interactions and micro-prompts in the interface</a></li>
<li><a href="../428592/index.html">Stop hiring "effective managers." They are not only useless, but also harmful</a></li>
<li><a href="../428596/index.html">Ilon Mask fired Starlink satellite Internet project managers due to non-compliance with deadlines</a></li>
<li><a href="../428598/index.html">Deep neural networks for automatic call evaluation</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>