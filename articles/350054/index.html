<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Anatomy of .NET Core: how we set up NTLM for Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We continue to talk about the migration of the mobile service in ASP.NET Core and Docker. This article will deal with the WCF client module mentioned ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Anatomy of .NET Core: how we set up NTLM for Linux</h1><div class="post__text post__text-html js-mediator-article"><p>  We continue to talk about the migration of the mobile service in ASP.NET Core and Docker.  This article will deal with the WCF client module mentioned in the previous <a href="https://habrahabr.ru/company/eastbanctech/blog/348590/">article</a> , NTLM authorization and other problems during its migration.  Now we will tell why we had to study anatomy for a bit and touch the .NET Core from the inside. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/015/816/82a/01581682a805643488911ed73015ad56.jpg"></p><a name="habracut"></a><br><h2 id="myagkiy-put-windows-konteyner">  Soft way.  Windows container </h2><br><p>  First of all, we <a href="https://habrahabr.ru/company/eastbanctech/blog/349510/">configured debag</a> to the docker image and started the service locally in a windows container. </p><br><p>  When I tried to send a request to the WCF service, I got a rather ornate error: </p><br><p><code>System.ServiceModel.Security.MessageSecurityException: The HTTP request is unauthorized with client authentication scheme 'Negotiate'. The authentication header received from the server was 'Negotiate TlRMTVNTUAACAAAAEAAQADgAA...</code> </p> <br><p>  By the method of sampling we came to the conclusion that it is required to specify the Domain in the credit of the service.  It's funny that you can specify any value, just not null - then it works. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">partial</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ConfigureEndpoint</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ServiceEndpoint serviceEndpoint, ClientCredentials clientCredentials</span></span></span><span class="hljs-function">)</span></span> { ... clientCredentials.Windows.ClientCredential.Domain = <span class="hljs-string"><span class="hljs-string">""</span></span>; }</code> </pre> <br><p>  Everything, now requests go, now in the Windows container affairs ok.  We go further. </p><br><h2 id="probuem-net-core-pod-linux">  We try. NET Core under Linux </h2><br><p>  Switching to the Linux container assembly, the Domain value was removed for the sake of interest - and it works. </p><br><p>  The first problem when sending requests to WCF is related to SSL.  Swears like this: </p><br><p> <code>System.Net.Http.CurlException SSL peer certificate or SSH remote key was not OK</code> </p> <br><p>  Which means: there is no trust in the certificate.  If the WCF service sent not only the final certificate, but also all the intermediate ones, there would be no problem. </p><br><p>  As decided: </p><br><p>  1. We extort intermediate certificates. </p><br><p>  For example, in Chrome, open the link and go to F12 in the Security tab.  Further View Certificate ‚Üí Certification Path.  For each certificate, open the View Certificate and on the Details tab of the Copy To File button, save the Base-64 encoded certificates to the project directory.  File extension needs to be changed to .crt. </p><br><p>  2. Add a new layer to the Dockerfile. </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> microsoft/aspnetcore:latest <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> base WORKDIR /app EXPOSE <span class="hljs-number"><span class="hljs-number">80</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> base <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> cert <span class="hljs-keyword"><span class="hljs-keyword">COPY</span></span> Certificates<span class="hljs-comment"><span class="hljs-comment">/*.crt /usr/local/share/ca-certificates/ RUN update-ca-certificates || exit 0</span></span></code> </pre> <br><p>  For debugging and experimenting, you can simply temporarily disable SSL validation: </p><br><pre> <code class="cs hljs">clientCredentials.ServiceCertificate.SslCertificateAuthentication = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> X509ServiceCertificateAuthentication() CertificateValidationMode = X509CertificateValidationMode.None, RevocationMode = X509RevocationMode.NoCheck };</code> </pre><br><p>  The most useful and important thing we learned when we received a CurlException is that libcurl is used for network requests. </p><br><p>  The tasty part was waiting for us to come. </p><br><h2 id="linux--wcf--ntlm--lyubov-no-posle-uzhina">  Linux + WCF + NTLM = love, but after dinner </h2><br><p>  Now the road was blocked by such an exception. </p><br><p> <code>MessageSecurityException The HTTP request is unauthorized with client authentication scheme 'Negotiate'. The authentication header received from the server was 'Negotiate, NTLM'.</code> </p> <br><p>  Change <code>Security.Transport.ClientCredentialType = HttpClientCredentialType.Windows</code> to <code>HttpClientCredentialType.Ntlm</code> </p><br><p>  The error has changed somewhat, but it has not become easier: </p><br><p> <code>MessageSecurityException The HTTP request is unauthorized with client authentication scheme 'Ntlm'. The authentication header received from the server was 'Negotiate, NTLM'.</code> </p> <br><p>  Let's make sure that we are not faced with another docker-related feature like the Domain value. </p><br><p>  We start service in a virtualka with Ubuntu LTS. </p><br><blockquote>  Lyrical digression: Docker for Windows loves Hyper-V and may refuse to work when installing other virtual machines.  Therefore, this time I had to raise Ubuntu under Hyper-V, in which copy-paste does not work between the host and guest machines, which is good news. <br><br>  By the way, Microsoft, how is the friendship with Apple? <br><br>  Next lay a Mac with Visual Studio installed.  Hands themselves itch.  When launching with SslCertificateAuthentication disabled, the <code>The handler does not support custom handling of certificates with this combination of libcurl (7.54.0) and its SSL backend ("SecureTransport")</code> .  If you return to the place of validation of certificates, there will be the same error with NTLM.  Still, the first error casts suspicion that the differences from Linux can be significant. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What other ways are there to return? <br><br>  Ubuntu on Windows - when the service was started, they got into the error <code>System.DllNotFoundException: Unable to load DLL 'System.Net.Http.Native'</code> . </blockquote><p>  And in the case: on pure Linux, the error is exactly the same as in the container, which means that the problem lies in the implementation of the WCF client. </p><br><p>  We try to come from the other side.  From the command line, run: </p><br><p>  1. <code>curl -v --negotiate</code> - fails </p><br><pre> <code class="hljs swift">* gss_init_sec_context() failed: <span class="hljs-type"><span class="hljs-type">SPNEGO</span></span> cannot <span class="hljs-built_in"><span class="hljs-built_in">find</span></span> mechanisms to negotiate.</code> </pre> <br><p>  2. <code>curl -v --ntlm</code> - everything is fine, the query works </p><br><p>  Here is the time to remember the list of officially supported <a href="">features in WCF</a> .  The search line says that Core on Linux does not know how to use NTLM.  But it does not stick with the fact that curl is able, and it would be strange not to realize such a popular option. </p><br><p>  From the <a href="https://github.com/dotnet/corefx/issues/9533">commentary</a> on the Internet, we learn that Negotiate Negotiate is different: in some implementations there is support for fallback Kerberos ‚Üí NTLM (everywhere on Windows), and in others - not.  Curl of the latter, and Negotiate becomes an obstacle. </p><br><p>  All this suggests that HttpClient can not take into account this nuance, which means that there is hope for victory. </p><br><h3 id="smotrim-ishodniki">  We watch source codes </h3><br><p>  And here it is impossible not to rejoice at the new Microsoft for their decision to open the code to the world.  In the <a href="">sorts,</a> we find the key <code>CURLHANDLER_DEBUG_VERBOSE=true</code> , which will tell us what libcurl is doing at the time of the WCF requests. </p><br><p>  In the logs we see the already familiar error <code>gss_init_sec_context() failed</code> for both HttpClientCredentialType.Windows and for HttpClientCredentialType.Ntlm. </p><br><p>  Now it is clear that the WCF client does not respond to switching from Windows authorization to NTLM and tries to use Negotiate in both cases.  This is most likely due to the WWW-Authentication 'Negotiate, NTLM' dual header, which sends the WCF service, and since Negotiate is a stronger authorization, it is used. </p><br><p>  From the libcurl manual, it‚Äôs tasted that the authorization type is set via the <code>CURLOPT_HTTPAUTH</code> option.  Following this trail, we went to the <a href="">authorization selection table</a> : </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>,CURLAUTH&gt;[] s_orderedAuthTypes = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, CURLAUTH&gt;[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>,CURLAUTH&gt;(<span class="hljs-string"><span class="hljs-string">"Negotiate"</span></span>, CURLAUTH.Negotiate), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>,CURLAUTH&gt;(<span class="hljs-string"><span class="hljs-string">"NTLM"</span></span>, CURLAUTH.NTLM), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>,CURLAUTH&gt;(<span class="hljs-string"><span class="hljs-string">"Digest"</span></span>, CURLAUTH.Digest), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyValuePair&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>,CURLAUTH&gt;(<span class="hljs-string"><span class="hljs-string">"Basic"</span></span>, CURLAUTH.Basic), };</code> </pre> <br><p>  The <code>static readonly</code> attributes look especially tempting, since this means that it is enough to play around using Reflection with the values ‚Äã‚Äãin the table at the start of the service, and there will be no overhead in HTTP requests. </p><br><p>  Added the following code to <code>Program.cs</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">// redirect Negotiate to NTLM (only for libcurl on Linux) var curlHandlerType = typeof(HttpClient).Assembly.GetTypes() .FirstOrDefault(type =&gt; type.Name == "CurlHandler"); if (curlHandlerType != null) { var authTypesField = urlHandlerType.GetField("s_orderedAuthTypes", BindingFlags.Static | BindingFlags.NonPublic); var authTypes = authTypesField.GetValue(null); var authTypesGetByIndex = authTypes.GetType().GetMethod("Get"); var ntlmKeyValuePair = authTypesGetByIndex.Invoke(authTypes, new object[] { 1 }); var ntlmValue = ntlmKeyValuePair.GetType().GetProperty("Value"); var CURLAUTH = ntlmValue.GetMethod.ReturnType; var CURLAUTH_NTLM = ntlmValue.GetValue(ntlmKeyValuePair); var authTypeKeyValuePairBuilder = typeof(KeyValuePairBuilder&lt;,&gt;) .MakeGenericType(new[] { typeof(string), CURLAUTH }); var builder = Activator.CreateInstance(authTypeKeyValuePairBuilder); var negotiateToNtlmKeyValuePair = authTypeKeyValuePairBuilder .GetMethod("Build") .Invoke(builder, new object[] { "", CURLAUTH_NTLM }); var authTypesSetByIndex = authTypes.GetType().GetMethod("Set"); authTypesSetByIndex.Invoke(authTypes, new object[] { 0, negotiateToNtlmKeyValuePair }); } } // makes it possible to call Activator.CreateInstance on KeyValuePair struct public class KeyValuePairBuilder&lt;K, V&gt; { public KeyValuePair&lt;K, V&gt; Build(K k, V v) { return new KeyValuePair&lt;K, V&gt;(k, v); } }</span></span></code> </pre> <br><p>  Here we nail the correspondence between "Negotiate" and CURLAUTH.NTLM. </p><br><p>  Voila, now requests work successfully. </p><br><h2>  Bonus track </h2><br><p>  We did not stop there.  If you take a close look at the logs, you can see that one WCF request-response includes several HTTP request-responses, and one of the responses returns steadily with a <code>Bad Request</code> .  What's the matter? </p><br><p>  For an erroneous request, the <code>HEAD</code> method is used.  Indeed, the same behavior is easily emulated with <code>curl -I</code> .  In libcurl, this corresponds to the <code>CURLOPTION_NOBODY</code> option.  In corefx, this option is used when sending <a href="">HttpMethod.Head</a> requests. <br>  We go up the stack higher in WCF.  We see that in the <code>SendPreauthenticationHeadRequestIfNeeded</code> method, a <a href="">HEAD request is</a> sent for authorization, and all errors are simply ignored: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-comment"><span class="hljs-comment">// There is a possibility that a HEAD pre-auth request might fail when the actual request // will succeed. For example, when the web service refuses HEAD requests. We don't want // to fail the actual request because of some subtlety which causes the HEAD request. await SendPreauthenticationHeadRequestIfNeeded(); } catch { /* ignored */ }</span></span></code> </pre> <br><p>  Here a flag is clearly suggested, similar to <code>HttpClientHandler.PreAuthenticate</code> , in order not to launch a request that is doomed to 400 in advance. </p><br><p>  Since we are not taken care of, then we will cut. </p><br><p>  The <code>SendPreauthenticationHeadRequestIfNeeded</code> method <code>SendPreauthenticationHeadRequestIfNeeded</code> asynchronous, so patching it can cause red eyes at a very early age.  If you look around you can see the simple and unpretentious <a href="">method</a> <code>AuthenticationSchemeMayRequireResend</code> .  Obviously, if it returns always false, then <code>SendPreauthenticationHeadRequestIfNeeded</code> will not run. </p><br><p>  Getting to the operation. </p><br><p>  We add to the solution a new project WcfPreauthPatch.  Now we put Cecil, with which we will get into the IL-code.  We need a beta version to work under .NET Core. </p><br><p> <code>Install-Package Mono.Cecil -Version 0.10.0-beta7 -ProjectName WcfPreauthPatch</code> </p> <br><p>  The code is: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> curlHandlerType = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(HttpClient).Assembly.GetTypes() .FirstOrDefault(type =&gt; type.Name == <span class="hljs-string"><span class="hljs-string">"CurlHandler"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (curlHandlerType == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-comment"><span class="hljs-comment">// continue only when libcurl is used var wcfDllPath = typeof(System.ServiceModel.ClientBase&lt;&gt;) .Assembly.ManifestModule.FullyQualifiedName; var wcfAssembly = AssemblyDefinition.ReadAssembly(wcfDllPath); var requestType = wcfAssembly.MainModule.GetAllTypes() .FirstOrDefault(type =&gt; type.Name.Contains("HttpClientChannelAsyncRequest")); var authRequiredMethod = requestType.Methods .FirstOrDefault(method =&gt; method.Name.Contains("AuthenticationSchemeMayRequireResend")); authRequiredMethod.Body.Instructions.Insert(0, Instruction.Create(OpCodes.Ldc_I4_0)); // put false on stack authRequiredMethod.Body.Instructions.Insert(1, Instruction.Create(OpCodes.Ret)); wcfAssembly.Write(wcfDllPath + ".patched"); File.Delete(wcfDllPath); File.Move(wcfDllPath + ".patched", wcfDllPath); }</span></span></code> </pre> <br><p>  In Dockerfile we will add </p><br><pre> <code class="hljs mel"># <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">image</span></span> FROM build AS build-wcf-patch WORKDIR /src/WcfPreauthPatch/ RUN dotnet build -c Debug -o /app ... # <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> release <span class="hljs-keyword"><span class="hljs-keyword">image</span></span> FROM base AS base-wcf-preauth-fixed COPY --from=publish /app . RUN dotnet WcfPreauthPatch.dll</code> </pre> <br><p>  We start service and we are convinced that in logs one request became less. </p><br><h3 id="epilog">  Epilogue </h3><br><p>  WCF client in .NET Core gave us a lot of trouble. </p><br><p>  On github, there is already a discussion of the issues and questions raised in the article: </p><br><p>  1. Negotiate / NTLM </p><br><p>  <a href="https://github.com/dotnet/corefx/issues/9533">https://github.com/dotnet/corefx/issues/9533</a> <br>  <a href="https://github.com/dotnet/corefx/issues/9234">https://github.com/dotnet/corefx/issues/9234</a> </p><br><p>  2. Preauthentication-request </p><br><p>  <a href="https://github.com/dotnet/wcf/issues/2433">https://github.com/dotnet/wcf/issues/2433</a> </p><br><p>  However, as we have seen, these problems are not completely solved.  We hope that our 5 kopecks in the discussion will add a new turn to the process. </p><br><h2>  Some ideas and facts for a snack </h2><br><ul><li><p>  In the absence of integration with docker, patching can be run as a postbuild target. </p><br></li><li><p>  There are NTLM proxies, for example, CNTLM.  An alternative way to set up an NTLM proxy inside the container also has prospects and is more versatile, and the ready-made customized image will be worthy of the layout on the Docker Hub. </p><br></li><li><p>  Hypothetically, you can try to edit the authorization header WWW-Authentication, which comes from WCF-service.  You need to override the WCF client's behavior through IEndpointBehavior and the AfterReceiveReply method.  However, this will only work if the preauthentication request is turned off, because  AfterReceiveReply will not catch it. </p><br></li><li><p>  If you use / have access to HttpClient, then here is a link to workaround for a similar problem with NTLM. </p><br></li><li><p>  Patching CurlHandler with Cecil does not work: System.Net.Http.dll is a mixed mode assembly (ie, with managed and native code), and this option is not yet supported in Cecil. </p><br></li><li><p>  Replacing the pointer to the method in runtime described in the <a href="https://www.codeproject.com/Articles/463508/NET-CLR-Injection-Modify-IL-Code-during-Run-time">article</a> does not work, do not try. </p><br></li><li>  Under Linux in .NET Core there is no support for function breakpoints. </li></ul></div><p>Source: <a href="https://habr.com/ru/post/350054/">https://habr.com/ru/post/350054/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350044/index.html">Announcement of Google Summer of Code 2018 for the project radare2</a></li>
<li><a href="../350046/index.html">Hidden JS-mining in the browser</a></li>
<li><a href="../350048/index.html">Let's Encrypt postponed issuance of wildcard certificates due to security issues.</a></li>
<li><a href="../350050/index.html">CodeFest Frontend: React, Javascript and Best Practices</a></li>
<li><a href="../350052/index.html">Designer, close Sketch! Knowledge of UX / UI is not a guarantee of a successful career</a></li>
<li><a href="../350056/index.html">RequireJS for Vue.js + Asp.NETCore + TypeScript applications</a></li>
<li><a href="../350058/index.html">How to finally release your first game</a></li>
<li><a href="../350060/index.html">Optimistic UI, CQRS and EventSourcing</a></li>
<li><a href="../350062/index.html">Tell us about yourself. How to do it during an interview</a></li>
<li><a href="../350064/index.html">From a box of matches to 411 stores: the history of the new IKEA museum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>