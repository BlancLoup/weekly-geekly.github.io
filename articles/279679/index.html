<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>QNX RTOS: Qnet - transparent inter-tasking network interaction</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I hope that the long-awaited continuation of the cycle of notes on the QNX real-time operating system . This time, I would like to talk about Qnet, th...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>QNX RTOS: Qnet - transparent inter-tasking network interaction</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/a84/b40/c31/a84b40c31d5b4bfb8c91196b40ee6a35.jpg" align="left">  I hope that the long-awaited continuation of the cycle of notes on the <a href="http://habrahabr.ru/blogs/nix/124656/">QNX real-time operating system</a> .  This time, I would like to talk about Qnet, the QNX proprietary network protocol.  I‚Äôll clarify right away that in addition to Qnet‚Äôs native network, QNX also supports the TCP / IP protocol stack, which you should generally be familiar with for administrators of Unix-like systems.  Therefore, in the note, I first talk a little about the network administrator <code>io-pkt</code> , and then in more detail about the Qnet protocol.  In the course of the narrative, four lyrical and one technical digressions are also waiting for us. <br><br><h4>  What is Qnet? </h4><br>  A QNX network is a group of interconnected target systems, each of which runs the QNX Neutrino RTOS.  In such a network, any program has access to any resource on any node (node, this is the name of the individual computers on the network).  A resource can be a file, a device or a process (including the launch of processes on another node).  At the same time, the target systems (those nodes) can be computers of various architectures ‚Äî x86, ARM, MIPS, and PowerPC (the current implementation of Qnet also works in a cross-endian environment).  But as if this is not enough, any POSIX application ported to QNX (for migration often requires only rebuilding) without any modification will have the above capabilities of working in the Qnet network.  Intrigued, how does this work? <a name="habracut"></a><br><br>  The Qnet protocol extends <a href="https://habrahabr.ru/post/127173/">the messaging engine</a> to the QNX Neutrino micronuclei network.  Here is the biggest secret of Qnet, and further in the article we will look at how it all works. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div class="spoiler">  <b class="spoiler_title">As a lyrical digression.</b> <div class="spoiler_text">  This note is about QNX 6.5.0, but sometimes I will remember about other versions of QNX6 and even QNX4.  And now I remember ... A similar approach with its own network was in QNX4, where the network was called FLEET.  Protocols Qnet and FLEET are not compatible with each other, affect the differences in the implementation of the kernel.  There are also differences in the addressing nodes.  Nevertheless, the same principle is based on the extension of the messaging mechanism to the microkernel network. <br></div></div><br><h4>  Io-pkt network subsystem </h4><br>  The network subsystem is a typical representative of one of the QNX subsystems, i.e.  consists of an <code>io-pkt*</code> administrator (built using QNX resource manager technology), device modules (drivers), for example, <code>devnp-e1000.so</code> , protocol modules, for example, <code>lsm-qnet.so</code> , and utilities, for example, <code>ifconfig</code> and <code>nicinfo</code> .  By the way, QNX has three network managers: <code>io-pkt-v4</code> , <code>io-pkt-v4-hc</code> and <code>io-pkt-v6-hc</code> .  The suffix <code>v4</code> says that this manager supports only IPv4, and the version with <code>v6</code> supports IPv4 and IPv6.  The suffix <code>hc</code> (high capacity) means an advanced version with support for encryption and Wi-Fi.  Therefore, sometimes in the literature one can find the name <code>io-pkt*</code> , but we will call the manager <code>io-pkt</code> (without an asterisk), since  In our case, it does not matter what version of TCP / IP we are talking about, because this note is about Qnet. <br><br><div class="spoiler">  <b class="spoiler_title">As a lyrical digression.</b> <div class="spoiler_text">  In previous versions of QNX6, the network manager was called <code>io-net</code> , and the TCP / IP protocol module was not linked to <code>io-net</code> , but was a stand-alone module like <code>lsm-qnet.so</code> .  Although wait, the modules then had a different prefix, since TCP / IP modules were called <code>npm-tcpip-v4.so</code> and <code>npm-tcpip-v6.so</code> , and Qnet was <code>npm-qnet.so</code> .  Although the latter is not entirely true, in ancient times (in the QNX 6.3.2 era) there were two Qnet modules ‚Äî <code>npm-qnet-compat.so</code> (for compatibility with older versions of QNX6) and <code>npm-qnet-l4_lite.so</code> ( which is supported by the QNX 6.5.0 <code>lsm-qnet.so</code> module).  By the way, npm means Network Protocol Module, and lsm means Loadable Shared Module. <br><br>  At the time of <code>io-net</code> , network driver modules carried the proud prefix devn.  The drivers for <code>io-pkt</code> have another prefix - devnp.  Older drivers can also be connected to <code>io-pkt</code> , <code>io-pkt</code> interlayer module is automatically used. <br></div></div><br><img src="https://habrastorage.org/files/04e/857/af2/04e857af2cb74491a4669fb6233a3cc5.png" alt="Detailed view of io-pkt architecture"><br><br>  <i>Fig.</i>  <i>1. Detailed view of <code>io-pkt</code> .</i> <br><br>  The <code>io-pkt</code> is shown in Figure 1.  At the bottom level are the drivers of wired and wireless networks.  These are loadable modules (DLL, shared libraries).  It is worth noting that in addition to Ethernet, other transmission media are supported.  For example, the <code>devn-fd.so</code> driver allows <code>devn-fd.so</code> to organize the transmission and reception of data using a file descriptor (fd is just a file descriptor), so you can organize the network, for example, on a serial port.  Speed, of course, will be appropriate, but sometimes it is very saving.  Device drivers connect to a second-level multi-thread component (stack).  The stack, first, provides the possibility of bridging and relaying.  Secondly, the stack provides a unified interface for packet management and processing of IP, TCP and UDP protocols.  At the top level is the resource manager, which implements the transfer of messages between the stack and user applications, i.e.  provides the functions <code>open()</code> , <code>read()</code> , <code>write()</code> and <code>ioctl()</code> .  The <code>libsocket.so</code> library converts the <code>io-pkt</code> to the BSD socket layer API, which is the standard for most modern networking code. <br><br>  The stack also provides interfaces for working with data on the Ethernet and IP levels, which allows protocols (for example, Qnet) executed as a DLL to connect to the required level (IP or Ethernet).  If interaction with external applications is required, a protocol (for example, Qnet) may include its own resource manager.  In addition to drivers and protocols, the stack includes packet filtering tools: BPF (Berkeley Packet Filter) and PF (Packet Filter). <br><br>  An example of starting <code>io-pkt</code> with support for the Qnet protocol: <br><br><pre> <code class="bash hljs">io-pkt-v4-hc -d e1000 -p qnet</code> </pre><br>  The <code>-d</code> option indicates the network controller driver <code>devnp-e1000.so</code> , the <code>-p</code> option loads the Qnet module.  In fact, when installing the QNX from the installation disk, the network starts automatically from the start-up scenarios; manual start is usually required when QNX is embedded and to reduce the system boot speed. <br><br>  In addition to working with Ethernet frames, Qnet can also be encapsulated in IP packets.  This can be convenient, for example, when working in distributed networks.  It should be noted that overhead costs in this case increase.  An example of running Qnet over IP: <br><br><pre> <code class="bash hljs">io-pkt-v4-hv -d e1000 -p qnet <span class="hljs-built_in"><span class="hljs-built_in">bind</span></span>=ip,resolve=dns</code> </pre><br>  If for some reason <code>io-pkt</code> was launched without Qnet support, then the <code>lsm-qnet.so</code> module can be <code>lsm-qnet.so</code> later, for example: <br><br><pre> <code class="bash hljs">mount -Tio-pkt lsm-qnet.so</code> </pre><br>  More complete information about <code>io-pkt</code> can be obtained in the QNX help system, and we will proceed to the main topic of our note. <br><br><h4>  How does Qnet work? </h4><br>  From the user's point of view, Qnet works completely transparent ... Stop.  Isn't it time to clarify the meaning of the word transparently in this context?  Perhaps it's time.  The term transparency, in our case, means that in order to access a remote resource, there is no need to take any additional actions compared to access to a local resource.  I will try to explain with examples just below. <br><br>  Once launched, Qnet creates the / net directory, which displays the file system of each host in a separate directory with the host name.  If the host name is not set (i.e., the default name is localhost), then in the / net directory it will be called with the name composed of the MAC address.  For example, the following command will display the contents of the zvezda node root directory: <br><br><pre> <code class="bash hljs">ls -l /net/zvezda</code> </pre><br>  The following command allows you to edit one of the startup scripts on the zvezda node: <br><br><pre> <code class="bash hljs">vi /net/zvezda/etc/rc.d/rc.local</code> </pre><br>  With access to the files figured out, nothing unusual here.  Access to devices works in a similar way.  So, for example, you can work with a serial port on another node: <br><br><pre> <code class="bash hljs">qtalk -m /net/zvezda/dev/ser1</code> </pre><br>  And here is an example more interesting: <br><br><pre> <code class="bash hljs">phcalc -s /net/zvezda/dev/photon</code> </pre><br>  Typically, Photon applications (this is a regular QNX graphics window subsystem) allow you to specify the server to which you will connect (the <code>-s</code> ).  In this case, the application runs on the local node, and the graphical window will be displayed on the zvezda node.  The local node does not even need to start the graphics subsystem.  This may be convenient in some cases, for example, when a node does not have a graphic controller, but a graphic display of the collected data from sensors or a system setting is required.  Also, this approach may allow the central processor of the graphics server to be unloaded. <br><br><div class="spoiler">  <b class="spoiler_title">As a lyrical digression.</b> <div class="spoiler_text">  The described approach can be applied not only to the graphics subsystem, but also to any other, including  oddly enough to network.  And even sometimes used in QNX4, which requires a separate license for each module, including a separate license for the TCP / IP stack.  You can run the <code>Tcpip</code> manager <code>Tcpip</code> only one node in the FLEET network, and direct all requests from the socket library to this node.  Do not be scared, in QNX6 usually do not.  And in the case of <code>io-pkt</code> there is no point in this, because  TCP / IP stack is inseparable from <code>io-pkt</code> . <br></div></div><br>  With files and devices, I hope, sorted out.  But what about the processes?  With this, too, everything is simple.  A number of system utilities provide the <code>-n</code> option, which says that you need to either work on a remote node or collect information from a remote node.  For example, you can get a list of running processes with command line arguments like this: <br><br><pre> <code class="bash hljs">pidin -n zvezda arg</code> </pre><br>  If some utility or program does not support the <code>-n</code> option, then the regular <code>on</code> utility comes in handy, which is exactly intended for running applications on another node, for example: <br><br><pre> <code class="bash hljs">on -f zvezda ls</code> </pre><br>  In this case, the <code>ls</code> utility is run on the zvezda node, and the utility output is displayed in the current terminal. <br><br><div class="spoiler">  <b class="spoiler_title">As a lyrical digression.</b> <div class="spoiler_text">  In fact, the <code>on</code> utility provides rich possibilities for controlling the parameters of running processes.  You can not only start processes on a remote node, but also change the priority level, dispatching discipline, start processes from another user, and even bind the process to a specific processor core.  More details can be found in the help for the utility. <br></div></div><br>  It is also easy to stop the process, since  The <code>slay</code> utility supports the <code>-n</code> option.  For example: <br><br><pre> <code class="bash hljs">slay -n zvezda io-usb</code> </pre><br>  Similarly, with the help of <code>slay</code> you can send any other signal, not only SIGTERM. <br><br><h4>  How does Qnet work from a programmer's point of view? </h4><br>  In the previous section, we looked at how Qnet works from the point of view of the RTOS user.  In most cases, it does not even require software development to support Qnet.  Is that really true?  Those.  to create a network application does not require working with any special frameworks and libraries?  Yes, not required.  If you work with POSIX, then you will not even notice the difference.  But in order not to be unsubstantiated, I will give the code of a small program, which as an example saves a string to a file (including on a remote node): <br><br><pre> <code class="hljs lua">#include &lt;unistd.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;fcntl.h&gt; int main(int argc, <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> *argv[]) { int fd; <span class="hljs-built_in"><span class="hljs-built_in">char</span></span> str[] = <span class="hljs-string"><span class="hljs-string">"This is a string.\n"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( argc &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> ) { printf(<span class="hljs-string"><span class="hljs-string">"Please specify file name.\n"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (fd = <span class="hljs-built_in"><span class="hljs-built_in">open</span></span>(argv[<span class="hljs-number"><span class="hljs-number">1</span></span>], O_RDWR|O_CREAT, <span class="hljs-number"><span class="hljs-number">0644</span></span>)) &lt; <span class="hljs-number"><span class="hljs-number">0</span></span> ) { perror(<span class="hljs-string"><span class="hljs-string">"open()"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">write</span></span>(fd, str, sizeof(str)<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(fd); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  This code is compatible with Qnet.  After all, there really is no difference in which file the string is stored in <code>/tmp/1.txt</code> or <code>/net/zvezda/tmp/1.txt</code> .  The same with devices, two code fragments for the programmer are identical (the only difference is in the file name): <br><br><pre> <code class="hljs swift">fd = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">"/dev/ser1"</span></span>, <span class="hljs-type"><span class="hljs-type">O_RDWR</span></span>);</code> </pre><br>  and <br><br><pre> <code class="hljs swift">fd = <span class="hljs-keyword"><span class="hljs-keyword">open</span></span>(<span class="hljs-string"><span class="hljs-string">"/net/zvezda/dev/ser1"</span></span>, <span class="hljs-type"><span class="hljs-type">O_RDWR</span></span>);</code> </pre><br>  Due to what is achieved such simplicity of work with the network?  POSIX calls, such as <code>open()</code> , spawn a series of low-level microkernel calls that control <a href="https://habrahabr.ru/post/127173/">message exchanges</a> : <code>ConnectAttach()</code> , <code>MsgSend()</code> , etc.  The program code required for network interaction is identical to that used locally.  The only difference is in the path name; in the case of networking, the path name will contain the node name.  The prefix with the node name is converted into a node handle, which is later used in the low-level call to <code>ConnectAttach()</code> .  Each node in the network has its own descriptor.  To search for the descriptor, the pathnames of the file system are used.  In the case of a single machine, the search result will be a node descriptor, a process id, and a channel id.  In the case of a Qnet network, the result will be the same, only the node descriptor will be non-zero (i.e. not equal to ND_LOCAL_NODE, and this indicates a remote connection).  However, all these calls are hidden and there is no need to take care of them if you simply use <code>open()</code> . <br><br><h4>  What is hidden behind the simple <code>open()?</code> function <code>open()?</code> </h4><br>  Consider a situation where an application on <code>node1</code> needs to use the serial port <code>/dev/ser1</code> on <code>node2</code> .  In fig.  2 shows what operations are performed when the application calls the <code>open()</code> function with the name <code>/net/node2/dev/ser1</code> . <br><br><img src="https://habrastorage.org/files/974/5f5/70f/9745f570ff844a228b99651ed0a97b02.png" alt="Qnet network messaging"><br><br>  <i>Fig.</i>  <i>2. Messaging over the Qnet network.</i> <br><br><ol><li>  The application sends a message to the local process manager with a request to resolve the path name <code>/net/node2/dev/ser1</code> .  Since  <code>lsm-qnet.so</code> is responsible for the namespace <code>/net</code> , then the process manager returns a redirect message, indicating that the application should contact the local <code>io-pkt</code> network administrator. </li><li>  The application sends a message to the local <code>io-pkt</code> network administrator with the same request to resolve the <code>io-pkt</code> .  The local network administrator returns a redirection message indicating the node descriptor, process identifier, and channel ID of the node <code>node2</code> process manager. </li><li>  The application creates a connection with the <code>node2</code> process manager and sends the request for the <code>node2</code> resolution again.  The process manager on <code>node2</code> in turn returns another redirect message indicating the node descriptor, process identifier, and channel identifier of the serial port driver on its own node ( <code>node2</code> ). </li><li>  The application creates a connection with the serial port driver on <code>node2</code> and obtains a connection identifier that can be used for further message exchange (for example, when calling <code>read()</code> , <code>write()</code> and other POSIX functions). </li></ol><br>  After all this quest, the exchange of messages on the received connection identifier occurs in the same way as in the case of local exchange.  It is important that all subsequent messaging operations are performed directly between the application on <code>node1</code> and the serial port driver (also, by the way, an ordinary application in QNX) on <code>node2</code> . <br><br>  Once again, for the programmer using the <code>open()</code> POSIX function, all these low-level calls are hidden.  As a result of the <code>open()</code> call, either a file descriptor or an error code will be received. <br><br><div class="spoiler">  <b class="spoiler_title">As a technical retreat.</b> <div class="spoiler_text">  When resolving a name, at each step the name components that were resolved are automatically removed from the request.  In the example above in step 2, the request to the local network administrator contains only <code>node2/dev/ser1</code> .  In step 3, the name contains only <code>dev/ser1</code> .  In step 4, only <code>ser1</code> . <br></div></div><br><h4>  Service Quality Policies </h4><br>  The Qnet protocol supports multi-channel transmission.  To select the mode of operation when using multiple channels, quality of service (QoS) policies are applied.  In Qnet networks, QoS essentially selects the transmission medium.  But if there is only one network interface in the system, then QoS does not work.  The following quality of service policies are supported: <br><br><ul><li>  <i>loadbalance</i> - the Qnet protocol will use any available communication channels and will be able to distribute data transfer between them.  This policy is used by default.  In this mode, the bandwidth between nodes will be equal to the sum of bandwidth on all available channels.  If one of the channels fails, Qnet will automatically switch to using other available channels.  Service packets will be automatically sent to the faulty channel, and when the connection is restored, Qnet will again use this channel. </li><li>  <i>preffered</i> - only one specified communication channel is used, and the rest are ignored until the main one fails.  After the primary link fails, Qnet enters <i>loadbalance</i> mode using all available channels.  When the main channel is restored, Qnet goes into <i>preffered</i> mode. </li><li>  <i>exclusive</i> - only one specified communication channel is used, and the remaining channels will NOT be used even if the main one fails. </li></ul><br>  To set the quality of service policy, the pathname modifier is used, starting with a tilde (~) character.  For example, to use the QoS <i>exclusive</i> policy on the interface <code>en0</code> to access the serial port on the node zvezda the name would be as follows: <br><br><pre> <code class="bash hljs">/net/zvezda~exclusive:en0/dev/ser1</code> </pre><br><h4>  When to use Qnet? </h4><br>  The choice of a protocol depends on a number of factors.  The Qnet protocol is intended for a network of trusted computers running the QNX Neutrino RTOS and having the same byte order.  The Qnet protocol does not authenticate requests.  Protection of access rights is performed using the usual access rights of users and groups of files.  Also, the Qnet protocol is a connection-based protocol, network error messages are sent to the client process. <br><br>  If computers with different operating systems are working on the network or the network is not trustworthy, then it is worth considering using other protocols with which QNX also works, for example, TCP / IP, in particular, FTP, NFS, Telnet, SSH and others. <br><br><h4>  Instead of an epilogue </h4><br>  In the note, of course, not all the features and features of Qnet are considered, but a general description of the protocol features is given.  If you are interested in Qnet technology or QNX in general, then more information on this and other topics can be found in the QNX Neutrino System Architecture.  Documentation is available in electronic form on the website <a href="http://www.qnx.com/">www.qnx.com</a> (in English), partially translation is available on the website <a href="http://docs.kpda.ru/index.jsp">www.kpda.ru.</a>  There is also a Russian translation in hard copy: <br><br>  QNX Neutrino Real-Time Operating System 6.5.0 System Architecture.  ISBN 978-5-9775-3350-8 <br>  QNX Neutrino 6.5.0 Real-Time Operating System User Guide.  ISBN 978-5-9775-3351-5 </div><p>Source: <a href="https://habr.com/ru/post/279679/">https://habr.com/ru/post/279679/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279665/index.html">Simpson's Paradox and Little Pandas</a></li>
<li><a href="../279667/index.html">Andrey Breslav and Dmitry Zhemerov on Kotlin 1.0 on jug.msk.ru</a></li>
<li><a href="../279669/index.html">Evaluation and optimization of computing performance on multi-core systems. Part 2</a></li>
<li><a href="../279671/index.html">Angular is a design pattern.</a></li>
<li><a href="../279675/index.html">Track updates from MongoDB Oplog to Sharded Cluster using Scala and Akka Streams</a></li>
<li><a href="../279681/index.html">New home for repository or history of moving to GitLab</a></li>
<li><a href="../279685/index.html">The digest of interesting materials for the mobile # 145 developer (March 14-20)</a></li>
<li><a href="../279687/index.html">Distribution of applications. Part 1: Creating a Formula for Homebrew</a></li>
<li><a href="../279689/index.html">2.3 Working with custom data streams</a></li>
<li><a href="../279695/index.html">Yet another instructions for obtaining the Let's Encrypt ssl certificate</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>