<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Highlighting code on android. My experience</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="During the development of my last application, I had to spend quite a lot of time experimenting with different approaches to the placement of spans in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Highlighting code on android. My experience</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/455/182/fec/455182fec7812b639447b77bdd31ac04.png" align="right"><br>  During the development of my last application, I had to spend quite a lot of time experimenting with different approaches to the placement of <a href="http://developer.android.com/reference/android/text/style/CharacterStyle.html">spans</a> in EditText.  In this post I would like to summarize some of this pastime, as well as save time for those who will solve such problems in the future. <br><br>  There will be little code, only highlights. <br><br>  First I want to give a small list of facts in order to bring the reader up to date: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ul><li>  Despite the N cores (each with a huge frequency), modern smartphones are still very much inferior in performance even to inexpensive, but large computers. </li><li>  Each application in android has a strictly limited amount of allocated memory.  And he is not great. </li><li>  The <a href="http://developer.android.com/reference/android/text/Spannable.html">setSpan</a> method is slow. </li><li>  The more work you take out in Workers, the more responsive your application will be. </li><li>  Keep highlighted all the text will not work - only the visible part of it. </li><li>  It‚Äôs pretty obvious, but still: the search for the placement of spans in the UI stream will not work. </li></ul><br><br><a name="habracut"></a><br><br>  So, immediately to my decision, which, perhaps, is far from the most optimal.  In this case, I will be glad to advice. <br><br><h4>  General description of the structure of the proposed solution </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/8d1/ee5/6e1/8d1ee56e16aedbf2cbcce1043454bc6e.png"><br>  Create a <a href="http://developer.android.com/reference/android/widget/ScrollView.html">ScrollView</a> extension and put <a href="http://developer.android.com/reference/android/widget/EditText.html">EditText</a> in it.  In ScrollView, we override <a href="http://developer.android.com/reference/android/view/View.html">onScrollChanged</a> in order to catch the end of scrolling.  At this time, we notify our constantly hanging in the background thread that the text should be parsed. <br>  EditText <a href="http://developer.android.com/reference/android/text/TextWatcher.html">hangs the</a> text change listener <a href="http://developer.android.com/reference/android/text/TextWatcher.html">TextWatcher</a> .  In his <a href="http://developer.android.com/reference/android/text/TextWatcher.html">afterTextChanged</a> method, <a href="http://developer.android.com/reference/android/text/TextWatcher.html">we</a> inform Worker that the text should be parsed.  In the class (the descendant of EditText), we get a Handler, to which from the Worker we will send a list of the spans that need to be hung on the text. <br><br>  The general scheme is as follows.  Now for the details that will be presented in the form of question-answer. <br><br><h4>  How to catch the end of scrolling? </h4><br>  The onScrollChanged method is called after each "scrolled" pixel, and if you force the stream parser to work after each call, then, of course, nothing good will come of it.  Therefore, we do as follows: <br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Thread timerThread; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrollChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldx, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> oldy)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onScrollChanged(x, y, oldx, oldy); timer = <span class="hljs-number"><span class="hljs-number">500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (timerThread == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> || !timerThread.isAlive()) { timerThread = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Thread(lastScrollTime); timerThread.start(); } } Runnable lastScrollTime = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (timer != <span class="hljs-number"><span class="hljs-number">0</span></span>) { timer -= <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { Thread.sleep(<span class="hljs-number"><span class="hljs-number">10</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InterruptedException e) { } } CustomScrollView.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.post(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Runnable() { <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (onScrollStoppedListener != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { onScrollStoppedListener.onScrollStopped(CustomScrollView.<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.getScrollY()); } } }); } }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OnScrollStoppedListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrollStopped</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scrollY)</span></span></span></span>; }</code> </pre> <br><br>  That is, each time the method is called, we set the timer to 500 ms and, if the method is not called during this time, we inform OnScrollStoppedListener that the scrolling has stopped.  In my case, the OnScrollStoppedListener interface implements my EditText. <br><br><h4>  How not to start the parser thread after each character entered? </h4><br>  See previous paragraph. <br>  In fact, this method in this case is far from ideal because the user will always have to wait for the N-th number of milliseconds before the parsing process begins.  In an amicable way, some kind of intellectual system is needed, which will be understood when the user just types slowly, and when he has already completed some operation (for example, he wrote the echo operator). <br><br><h4>  How to understand which text falls into the visible area? </h4><br>  Unfortunately, this can not be done exactly, so you have to do about.  To start, after each text change, I call the following method: <br><br><pre> <code class="java hljs">List&lt;Integer&gt; charsCountPerLine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fillArrayWithCharsCountPerLine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String text)</span></span></span><span class="hljs-function"> </span></span>{ charsCountPerLine.clear(); charsCountPerLine.add(<span class="hljs-number"><span class="hljs-number">0</span></span>); BufferedReader br = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BufferedReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InputStreamReader(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ByteArrayInputStream(text.getBytes()))); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> currentLineLength = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> current; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c = br.read(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c == -<span class="hljs-number"><span class="hljs-number">1</span></span>) { charsCountPerLine.add(currentLineLength); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } current = (<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>) c; currentLineLength++; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == <span class="hljs-string"><span class="hljs-string">'\n'</span></span>) { charsCountPerLine.add(currentLineLength); } } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (IOException e) { Log.e(TAG, <span class="hljs-string"><span class="hljs-string">""</span></span>, e); } }</code> </pre><br>  That is, I get the symbol number of the beginning of each line.  Then, knowing the height of the screen in pixels, we can easily calculate the number of the first and last visible line: <br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lineHeight = mEditText.getLineHeight(); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startLine = scrollY / lineHeight; <span class="hljs-comment"><span class="hljs-comment">// scrollY -     ScrollView int endLine = mEditText.startLine + viewHeight / lineHeight + 1; // viewHeight    </span></span></code> </pre><br><br>  Having this data, you can easily find the first and last visible symbol. <br><br><h4>  Why do I need to fill the list with spans?  Why not just send each span to the handler right after its creation? </h4><br>  First, then you lose the convenient opportunity to use multiple threads to parse the text.  In this configuration, for example, at the stage of inserting a span into the list you can check it for the presence of a double in the sheet.  Secondly, in my opinion, the programmer works iteratively.  That is, he did some kind of action, and then thought for a second.  At this moment, a pack of spans will come to our ui stream and highlight it for a split second.  In the opposite case, the spans will come constantly, creating micro brakes UI. <br><br><h4>  Why do we constantly sleep flow?  Why not use ThreadPool? </h4><br>  In theory, it should be a little better, but I have not tried. <br><br>  I highlighted the general structure of the decision, and, in my opinion, unobvious moments.  I hope it will be useful to someone.  Thank. </div><p>Source: <a href="https://habr.com/ru/post/204248/">https://habr.com/ru/post/204248/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../204236/index.html">OpenVX: computer vision standard</a></li>
<li><a href="../204238/index.html">60 FPS? Easy! pointer-events: none!</a></li>
<li><a href="../204240/index.html">Introduction to Veritas Volume Manager</a></li>
<li><a href="../204242/index.html">Openfire + Miranda + Asterisk + Active Directory + pinch php, bash, C # or how to call from Miranda using regular phones</a></li>
<li><a href="../204244/index.html">How software companies die, or How to grow programmers correctly</a></li>
<li><a href="../204250/index.html">Service robot Tod. First steps with ROS</a></li>
<li><a href="../204252/index.html">10 months of free clouds on DigitalOcean</a></li>
<li><a href="../204254/index.html">Gnuplot vs. 2MASS</a></li>
<li><a href="../204258/index.html">Generating functions back and forth</a></li>
<li><a href="../204260/index.html">SSAO on OpenGL ES 3.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>