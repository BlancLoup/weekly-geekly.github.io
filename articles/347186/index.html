<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to ConcourseCI</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! I noticed that on Habr√© there is very little information about such a build server as ConcourseCI . I decided to fill this gap and write a smal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to ConcourseCI</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/er/ye/gf/eryegft4xznuk3wvy1iri65q3ry.jpeg" alt="ConcourseCI logo"></p><br><p>  Hello!  I noticed that on Habr√© there is very little information about such a build server as <a href="https://concourse-ci.org/">ConcourseCI</a> .  I decided to fill this gap and write a small introduction.  Under the cut description of this tool and a small tutorial. </p><a name="habracut"></a><br><p>  So ConcourseCI is a CI / CD build server.  It is developed by <a href="https://pivotal.io/">Pivotal</a> , is currently under active development.  In the company itself, there are several people who work full-time on this project entirely, so new versions are currently being released quite regularly, additional features are being actively implemented, and bugs are fixed quickly.  Initially, as is most often the case, Pivotal made this tool for internal use, because they were dissatisfied with Jenkins, but later they published this project on <a href="https://github.com/concourse">GitHub</a> and the community <a href="https://github.com/concourse">came</a> up with new releases from third-party developers from the community.  Written entirely in Go. </p><br><p>  In this article: </p><br><ul><li>  <a href="https://habr.com/ru/post/347186/">Virtues</a> </li><li>  <a href="https://habr.com/ru/post/347186/">Installation</a> </li><li>  <a href="https://habr.com/ru/post/347186/">Three concepts</a> </li><li>  <a href="https://habr.com/ru/post/347186/">Appearance of the web interface</a> </li><li>  <a href="https://habr.com/ru/post/347186/">Fly</a> </li><li>  <a href="https://habr.com/ru/post/347186/">Pipeline configuration</a> </li><li>  <a href="https://habr.com/ru/post/347186/">Secrets</a> </li><li>  <a href="https://habr.com/ru/post/347186/">Why do we need task?</a> </li></ul><br><h2 id="dostoinstva">  Virtues </h2><br><p>  I will list the main advantages of this product: </p><br><ul><li>  Each operation is launched in a separate Docker-container, which makes this product completely independent of technology.  That is, you can collect any code that is collected inside any docker container </li><li>  the assembly process is described in the form of a so-called.  <em>pipeline</em> (pipeline), because the modern assembly is becoming less linear.  And to describe a complex assembly procedure in the form of such a graph becomes very convenient and intuitive.  ConcourseCI comes with a convenient, read-only web-based graphical interface. </li></ul><br><p><img src="https://habrastorage.org/webt/ls/wc/gt/lswcgt-wjbhyddrbvr8lmgnjdlk.jpeg" alt="ConcourseCI main view main view"></p><br><p>  Although a new design is currently in beta, it is being <a href="https://github.com/concourse/concourse/issues/1829">actively discussed by the community</a> , so my screenshots are likely to become obsolete in the near future.  The new interface might look something like this: </p><br><p><img src="https://habrastorage.org/webt/px/10/qt/px10qtwmjmdidvdwvidzgvpago4.jpeg" alt="ConcourseCI new design beta"></p><br><ul><li>  out of the box easily expands horizontally.  If you do not have enough resources, you can start another worker at the new machine, specify the main server‚Äôs address as parameters and everything else will be done for you: the worker will register himself, report about himself and be ready to do some work right away. .  Moreover, if you have any parallel operations in the assembly process, they may well run on different physical machines.  The operation of adding a new worker is literally launching one command. </li></ul><br><h2 id="ustanovka">  Installation </h2><br><p>  As I mentioned, the project is written in Go, so the release <a href="https://github.com/concourse/concourse/releases/">comes</a> as a single binary file, and you can run it in one command.  But there is a better way.  ConcourseCI provides the <a href="https://hub.docker.com/r/concourse/concourse/">official docker image</a> , so you can start a project with just one team, using docker-compose. </p><br><p>  Launched ConcourseCI consists of three parts: </p><br><ol><li>  <strong>PostgreSQL</strong> database </li><li>  <strong>Concourse Web</strong> .  This is something like a master.  The graphical web interface works here and the most important thing is <a href="https://concourse-ci.org/architecture.html">ATC</a> (the <em>term ATC or <a href="https://en.wikipedia.org/wiki/Air_traffic_control">Air Traffic Control</a> is borrowed from aviation: this is a flight control tower, which stands at airports near the runway where air traffic controllers direct flights</em> ).  ATC allocates resources, runs various tasks, monitors the cluster.  It is important to remember that the actual build does not occur in Concourse Web, it only <em>manages the</em> build, delegating tasks to the available workers.  The system can have only one main Concourse Web. </li><li>  <strong>Concourse Worker</strong> - this is where the real work happens.  A worker receives assignments from ATC and performs it, reporting on his results.  There can be as many such workers in the system as long as you have enough iron.  It is recommended to run one worker per server / instance. </li></ol><br><p>  Thus, a fully working server can be started with just one docker-compose command.  But before the very first launch, you should generate the keys, because the ATC communicates with the workers over the encrypted channel and you need to slip the keys on both sides before launching.  We generate keys like this: </p><br><pre><code class="bash hljs">mkdir -p keys/web keys/worker ssh-keygen -t rsa -f ./keys/web/tsa_host_key -N <span class="hljs-string"><span class="hljs-string">''</span></span> ssh-keygen -t rsa -f ./keys/web/session_signing_key -N <span class="hljs-string"><span class="hljs-string">''</span></span> ssh-keygen -t rsa -f ./keys/worker/worker_key -N <span class="hljs-string"><span class="hljs-string">''</span></span> cp ./keys/worker/worker_key.pub ./keys/web/authorized_worker_keys cp ./keys/web/tsa_host_key.pub ./keys/worker</code> </pre> <br><p>  Well, after that we will be able to run the entire system with this file (see the official file <a href="">here</a> ): </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">version</span></span>: <span class="hljs-string"><span class="hljs-string">'3'</span></span> services: concourse-db: image: postgres:<span class="hljs-number"><span class="hljs-number">9.6</span></span> environment: POSTGRES_DB: concourse POSTGRES_USER: concourse POSTGRES_PASSWORD: changeme PGDATA: /<span class="hljs-keyword"><span class="hljs-keyword">database</span></span> concourse-web: image: concourse/concourse links: [concourse-db] command: web depends_on: [concourse-db] ports: ["8080:8080"] volumes: ["./keys/web:/concourse-keys"] <span class="hljs-keyword"><span class="hljs-keyword">restart</span></span>: unless-stopped # required so that it retries <span class="hljs-keyword"><span class="hljs-keyword">until</span></span> concourse-db comes up environment: CONCOURSE_BASIC_AUTH_USERNAME: concourse CONCOURSE_BASIC_AUTH_PASSWORD: changeme CONCOURSE_EXTERNAL_URL: "${CONCOURSE_EXTERNAL_URL}" CONCOURSE_POSTGRES_HOST: concourse-db CONCOURSE_POSTGRES_USER: concourse CONCOURSE_POSTGRES_PASSWORD: changeme CONCOURSE_POSTGRES_DATABASE: concourse concourse-worker: image: concourse/concourse privileged: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> links: [concourse-web] depends_on: [concourse-web] command: worker volumes: ["./keys/worker:/concourse-keys"] environment: - CONCOURSE_TSA_HOST=concourse-web:<span class="hljs-number"><span class="hljs-number">2222</span></span></code> </pre> <br><p>  Do not forget to export to the <code>CONCOURSE_EXTERNAL_URL</code> variable the real value of the web address at which the web interface will be available. </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> CONCOURSE_EXTERNAL_URL=http:<span class="hljs-comment"><span class="hljs-comment">//192.168.99.100:8080</span></span></code> </pre> <br><p>  As you can see, in this example, we run everything on one machine, but no one limits you to this and you can safely create a distributed cluster according to your needs. </p><br><p>  After launch, you can open the address of your server in the browser (in the example above - <a href="http://192.168.99.100:8080/">http://192.168.99.100:8080</a> ) and you will see a still empty Concourse Web. </p><br><p>  Read more about the installation <a href="https://concourse-ci.org/docker-repository.html">here</a> . </p><br><h2 id="tri-koncepcii">  Three concepts </h2><br><p>  So, before we get down to business, let's look at the terminology to understand each other.  ConcourseCI operates with three basic concepts. </p><br><ol><li><p>  <strong>Resource</strong> - a resource that can provide material for the assembly, or can be updated with the results of the assembly.  Typical examples are git / hg repositories, docker registries, FTP, S3, chats, emails, telegram bots, and so on.  A complete list <a href="https://concourse-ci.org/resource-types.html">here</a> , plus you can always find something in the open spaces of the GitHub and in extreme cases you can <a href="https://concourse-ci.org/implementing-resources.html">write it yourself</a> .  It is important to understand that the resource does not do any specific work, it only ‚Äúprovides‚Äù material for further actions. </p><br></li><li><p>  <strong>Task</strong> is a unit of work that can be done within your assembly.  Task is launched in your chosen docker container. </p><br></li><li>  <strong>Job</strong> - the task;  combines resources and tasks into one.  In other words, inside the task, we take resources, somehow we process them in a task, collect and update resources with results.  One task is completely isolated and can be run separately any number of times. </li></ol><br><h2 id="vneshniy-vid-veb-interfeysa">  The appearance of the web interface </h2><br><p>  And in the ConcourseCI browser, it looks like this: </p><br><p><img src="https://habrastorage.org/webt/lc/eh/ql/lcehqlnaeis01panw4lthv0usri.jpeg" alt="An example of a simple conveyor at the ConcourseCI"></p><br><p>  This is a very simple example for the pipeline, but here you can see how we take the sources from the Git repository and start building the project, create a docker image and notify everyone in the telegram channel with the help of the corresponding <a href="https://github.com/w32blaster/telegram-notification-resource">resource</a> . </p><br><p>  In this screenshot, only the resources and the task are visible, but the tasks are not visible.  But if you click on one of the tasks (in this example we have one), then you can see what is going on inside the green square: </p><br><p><img src="https://habrastorage.org/webt/h9/oe/jx/h9oejxno35qnh-ma2lkoutlkwuy.jpeg" alt="ConcourseCI open task"></p><br><p>  In this picture numbers are marked: </p><br><ol><li>  manual start button.  You can run it again at any time. </li><li>  All previous builds are arranged in a long chain under the title in the form of history </li><li>  resource that takes source.  The down arrow means "get", that is, we are "taking" material from the resource. </li><li>  output work of one task.  You can open this link and see the stdout log from our container, what happened during the assembly of our project </li><li>  we collect the resource (docker image) and throw it into a private register.  The arrow "up" means "put", that is, we "update" the resource </li><li>  Finally, we throw a message in a private telegram channel </li></ol><br><p>  In this interface, you can view all the conveyors and tasks, monitor the results. </p><br><p>  As an example of a completely ‚Äúadvanced‚Äù version of the pipeline, you can bring the <a href="https://ci.concourse-ci.org/">pipeline of the ConcourseCI itself</a> (yes, surprisingly, but he himself is going to do it himself :)) </p><br><p>  But as I mentioned above, the web is read-only here.  A reasonable question arises: how then to add new conveyors to the project?  It's time to introduce you to fly. </p><br><h2 id="fly">  Fly </h2><br><p>  <a href="https://github.com/concourse/fly">Fly</a> is a command line utility that allows you to manage your entire ConcourseCI cluster from a terminal.  It is installed on your work computer and is managed by the server.  With it, you can perform all the necessary operations and maintain the cluster. </p><br><p>  Displaying help for this command (small part): </p><br><pre> <code class="hljs pgsql">$ fly help <span class="hljs-keyword"><span class="hljs-keyword">Usage</span></span>: fly [<span class="hljs-keyword"><span class="hljs-keyword">OPTIONS</span></span>] &lt;command&gt; Application <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>: -t, <span class="hljs-comment"><span class="hljs-comment">--target= Concourse target name -v, --version Print the version of Fly and exit --verbose Print API requests and responses --print-table-headers Print table headers even for redirected output Help Options: -h, --help Show this help message Available commands: abort-build Abort a build (aliases: ab) builds List builds data (aliases: bs) check-resource Check a resource (aliases: cr) checklist Print a Checkfile of the given pipeline (aliases: cl) containers Print the active containers (aliases: cs) destroy-pipeline Destroy a pipeline (aliases: dp) destroy-team Destroy a team and delete all of its data (aliases: dt) execute Execute a one-off build using local bits (aliases: e) .....  ..</span></span></code> </pre><br><p>  The command is also a single binary written in Go.  It can be downloaded from the <a href="https://github.com/concourse/fly/releases">githab</a> , but it will be more convenient to download using the link at the bottom of the web interface: <br><img src="https://habrastorage.org/webt/zo/c6/sz/zoc6szxnhezetpjs_i_ukziynym.jpeg" alt="download fly"><br>  and drop it into <code>/usr/bin/fly</code> , making it run. </p><br><p>  So, you have set fly.  To get started with ConcourseCI, you need to authenticate to your server.  This is done quite simply: </p><br><p> <code>$ fly --target office login --concourse-url=http://ci.your.concouce.server.com</code> </p> <br><p>  Where: </p><br><ul><li>  <strong>--target</strong> (or <strong>-t</strong> ) you specify any name for this server (target, target server).  In this example, this is the name "office".  The fact is that you can have several servers: one for the company, one for your team and, for example, one on your local computer where you train on tutorials.  And with the <strong>-t</strong> option you can easily switch between these servers. </li><li>  <strong>login</strong> - <strong>login</strong> command </li><li>  <strong>--concourse-url</strong> - you <strong>specify the URL</strong> where your ConcourseCI cluster is located;  is indicated only for the first time. </li></ul><br><p>  After entering the command, you will be asked to login and password.  Enter the data you specified in the docker-compose.yml file during the installation (variables <code>CONCOURSE_BASIC_AUTH_USERNAME</code> and <code>CONCOURSE_BASIC_AUTH_PASSWORD</code> , see above) </p><br><p>  You can find a list of all available commands by typing <code>$ fly help</code> or on <a href="https://concourse-ci.org/fly-cli.html">the documentation page</a> . </p><br><p>  After a successful login, you can already start working.  Let's say you can create your first pipeline with this command: </p><br><p> <code>$ fly -t office sp -c pipeline.yml -p my-pipeline-name</code> </p> <br><p>  Where: </p><br><ul><li>  <strong>-t office</strong> - we specify the target server where we run the command (in this example, the <em>office</em> we created at the time of login in the previous step) </li><li>  <strong>sp</strong> (or <strong>set-pipeline</strong> ) - directly, the command to create a new pipeline.  Each team has its short alias.  You can write the full <code>set-pipeline</code> command or use the short alias <code>sp</code> - the result will be identical </li><li>  <strong>-c pipeline.yml</strong> - file with the configuration of the pipeline itself, described in the YAML markup language.  This is the next chapter. </li><li>  <strong>-p my-pipeline-name</strong> - set the name of this pipeline, with which it will appear in the web interface. </li></ul><br><p>  After running this command, you can open our ConcourseCI in the browser and see our fresh pipeline.  Initially it will be paused.  To make the new pipeline active, you need to click on the blue "‚ñ∏" button in the browser </p><br><p><img src="https://habrastorage.org/webt/fc/ov/o4/fcovo4yrrh_3npshemwqo7jndoy.jpeg" alt="ConcourseCI just created paused pipeline"></p><br><p>  or use the command </p><br><p> <code>$ fly -t office unpause-pipeline -p my-pipeline-name</code> </p> <br><h2 id="konfiguraciya-konveyera">  Pipeline configuration </h2><br><p>  It is time to consider how the description of the pipeline.  The file is described by the YAML format, and can be stored in the same repository as the source code of your project, that is, as if "closer" to the code.  In other words, we can say that every project "knows how to assemble itself," because the configuration lies in it.  This is quite convenient, since each programmer will be able to see the details and subtleties of a complete assembly, which undoubtedly can help in the development. </p><br><p>  The file can be divided into several parts: the declaration of resources (resources) and the description of tasks (jobs).  Let's create a simple pipeline of, say, a Java project.  In this case, we take the source from the Git repository, run the tests and build the project using Gradle, and, let's say, drop the build result into the Amazon S3 cloud. </p><br><p>  Let's start with the resource.  They are described in the <strong>resources</strong> section.  In our case, we need to declare two resources: the Git repository and the AWS S3. </p><br><pre> <code class="hljs scala">resources: - name: source-code <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: git source: uri: git<span class="hljs-meta"><span class="hljs-meta">@your</span></span>-project.git branch: master private_key: | ......... - name: aws-s3-release <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span></span>: s3 source: bucket: releases regexp: directory_on_s3/release-(.*).tgz access_key_id: ........ secret_access_key: ........</code> </pre> <br><p>  Name (- name) we set any, by it we will refer to these resources, and with the same name we will see our resource in the browser. </p><br><p>  Next, create one job (job) that will do three things: </p><br><ol><li>  take source from <code>source-code</code> resource </li><li>  build a project </li><li>  deploy to <code>aws-s3-release</code> </li></ol><br><p>  Tasks are described in the <code>jobs</code> : section and you can create as many as you like.  In our simple example, we do only one task with the name "Build project". </p><br><pre> <code class="hljs pgsql">jobs: - <span class="hljs-type"><span class="hljs-type">name</span></span>: "Build project" plan: #   - <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>: source-code <span class="hljs-keyword"><span class="hljs-keyword">trigger</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">true</span></span> #   ,    #    - task: "Build gradle project" config: platform: linux image_resource: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: docker-image source: {repository: "chickenzord/alpine-gradle", tag: "latest" } inputs: - <span class="hljs-type"><span class="hljs-type">name</span></span>: source-code outputs: - <span class="hljs-type"><span class="hljs-type">name</span></span>: result-jar run: <span class="hljs-type"><span class="hljs-type">path</span></span>: sh args: - -exc - | cd source-code gradle test gradle build #    output, #       cp build/libs/app.jar ../result-jar #    S3 - put: aws-s3-<span class="hljs-keyword"><span class="hljs-keyword">release</span></span> params: file: result-jar/app.jar acl: <span class="hljs-built_in"><span class="hljs-built_in">public</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">read</span></span></code> </pre><br><p>  Let's look at this example in more detail. </p><br><p>  Everything is clear with the resource: we declare it as <code>- get</code> : which means we will take data from it.  The <code>trigger: true</code> parameter means that the task will start automatically each time the resource is updated (in this case, it means that someone has committed and started the commit).  You can optionally specify more specific parameters that can be found in the <a href="https://github.com/concourse/git-resource">documentation for the specific resource</a> . </p><br><p>  Task  As you remember, this is where real action takes place.  A task has two properties to keep in mind: </p><br><ol><li>  it can have incoming and outgoing data ( <em>inputs</em> and <em>outputs</em> ) </li><li>  it runs in the docker container (well ... actually, everything starts in containers, but for the task, you must explicitly specify the image). </li></ol><br><p>  In this example, we specified only one input source: </p><br><pre> <code class="hljs pgsql"> inputs: - <span class="hljs-type"><span class="hljs-type">name</span></span>: source-code</code> </pre> <br><p>  An incoming source can be either from a resource or from another task that was launched before (this way, you can run tasks in a chain and transfer intermediate results to the next).  In practice, this means that inside the container we will have a folder with the same name and inside this folder ConcourseCI will accurately place the contents of the resource (in our case, the contents of the git repository).  That is why the very first thing I did in the body of the task is to go into this folder ( <code>cd source-code</code> ), where I will have the sources of my Java project. </p><br><p>  You also need to specify the image of the docker that you want to use for the assembly.  The logic here is very simple: you need a container, inside of which there are all the assembly tools for a specific project.  Let's say, in my case, since the project on Java is going to be done by the gredlom, then inside the container I need the version of Java I need and the Gredl itself.  For example, <a href="https://hub.docker.com/r/chickenzord/alpine-gradle/">this image</a> works and is perfect for my task.  Specify this image in the config like this: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">config</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">platform</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">linux</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">image_resource</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">type</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">docker-image</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">source</span></span>: {<span class="hljs-attribute"><span class="hljs-attribute">repository</span></span>: <span class="hljs-string"><span class="hljs-string">"chickenzord/alpine-gradle"</span></span>, tag: <span class="hljs-string"><span class="hljs-string">"latest"</span></span> }</code> </pre> <br><p>  and inside this container we will be able to run our gredl haul, which I do as a demonstration: </p><br><pre> <code class="hljs bash"> <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> <span class="hljs-built_in"><span class="hljs-built_in">source</span></span>-code gradle <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> gradle build</code> </pre> <br><p>  And yes, if you have any very specific requirements for the build environment, then it‚Äôs easy to assemble your own docker image and store it in your private registry: ConcourseCI can easily upload images from anywhere. </p><br><p>  It is also worth noting that in this example I described everything in some detail so that it is as clear as possible in one single YAML file.  But task can be taken out in a <a href="">separate YAML file</a> .  It is so convenient to reuse tasks in different projects.  In this case, the task will be declared with only two lines, while its "body" will be saved separately: </p><br><pre> <code class="hljs pgsql"> - task: hello-world file: <span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/my_task.yml</code> </pre> <br><p>  The same applies to the <strong>run</strong> command: its contents can also be transferred to the shell script and referenced by one command, making the code shorter.  This can be useful if you, say, want to test the script locally or to cover its <a href="https://github.com/kward/shunit2">unit with tests</a> .  In this case, the task will look something like this: </p><br><pre> <code class="hljs pgsql">- task: "Run altogether" config: platform: linux image_resource: <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: docker-image source: repository: somedocker/image tag: latest run: <span class="hljs-type"><span class="hljs-type">path</span></span>: <span class="hljs-type"><span class="hljs-type">path</span></span>/<span class="hljs-keyword"><span class="hljs-keyword">to</span></span>/script.sh</code> </pre><br><p>  Just do not forget that your script should return the standard Unix <a href="http://tldp.org/LDP/abs/html/exitcodes.html">output result</a> (0 - everything is in order, any other number is an error).  Only in this way will ConcourseCI know if your team is successful or not. </p><br><p>  And the final touch is to briefly mention the second resource, which we declare as <code>- put</code> :, which means that we will update it (and not receive data from it, as is the case with source-code). </p><br><p>  Now that our configuration file is ready, we save it in a file under any name, say, <code>pipeline.yml</code> and now we should create / update the pipeline on the remote ConcourseCI server with the command: </p><br><p> <code>$ fly -t office sp -c pipeline.yml -p my-pipeline-name</code> </p> <br><p>  and after that we open our browser and see the newly created (or updated) pipeline.  If we make a commit to our git repository, it will start automatically: </p><br><p><img src="https://habrastorage.org/webt/rc/zk/dp/rczkdpqmit5kg4kbzjyrrvst8lc.jpeg" alt="ConcourseCI first run of the pipeline"></p><br><p>  When we click on this large square (job "Build project"), then we will reveal the details.  All these steps on the screen can be "expanded" to view the output from the console. </p><br><p><img src="https://habrastorage.org/webt/dv/1m/7e/dv1m7ejij5ohu9jryiw_uno8wnq.jpeg" alt="ConcourseCI was disclosed task, details, task"></p><br><h2 id="sekrety">  Secrets </h2><br><p>  You have seen in my example that I have written my secrets (passwords, keys) right in the code.  Of course, in a real project, you should not do this in view of security considerations, since the YAML file will lie in a common repository.  All secrets must be stored separately.  In concourse, we can use special aliases, into which real values ‚Äã‚Äãwill be substituted only during the update of the pipeline.  Let's say we replace passwords and private keys with placeholders, enclosed in double brackets: </p><br><pre> <code class="hljs pgsql">- <span class="hljs-type"><span class="hljs-type">name</span></span>: source-code <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: git source: uri: git@your-project.git branch: master private_key: ((git-pivate-key)) - <span class="hljs-type"><span class="hljs-type">name</span></span>: aws-s3-<span class="hljs-keyword"><span class="hljs-keyword">release</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span>: s3 source: bucket: releases regexp: directory_on_s3/<span class="hljs-keyword"><span class="hljs-keyword">release</span></span>-(.*).tgz access_key_id: ((aws-<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-key)) secret_access_key: ((aws-secret-key))</code> </pre><br><p>  And then we will create a local file (which is stored securely only on your computer or in another secure storage) with passwords and keys in YAML format (say, <code>credentials-ci.yml</code> ), containing all the values: </p><br><pre> <code class="hljs pgsql">aws-<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>-key: "myawsaccesskey" aws-secret-key: "myawssecretkey" ftp-<span class="hljs-keyword"><span class="hljs-keyword">password</span></span>: "my-secure-password" git-pivate-key: | <span class="hljs-comment"><span class="hljs-comment">-----BEGIN RSA PRIVATE KEY----- ............</span></span></code> </pre> <br><p>  And now we have to use the <code>--load-vars-from</code> parameter to substitute real values ‚Äã‚Äãfor our secrets.  So, the full command to create / update the pipeline now looks like this: </p><br><p> <code>fly -t office sp -c pipeline.yml -p my-pipeline-name --load-vars-from ~/credentials-ci.yml</code> </p> <br><p>  Now, our pipeline will be stored in a common repository, and passwords only on the administrator's computer in a safe place.  Now you can safely leave your build configurator even on a <a href="">public github</a> . </p><br><p>  Alternatively, you can use the <a href="https://github.com/Docurated/concourse-vault-resource">resource of the standard vault tool</a> . </p><br><h2 id="zachem-nuzhny-taski">  Why do we need task? </h2><br><p>  Probably, looking at my example, you ask yourself: why are jobs and tasks needed and why they cannot be combined into one whole (as, for example, this is <a href="https://docs.gitlab.com/ee/ci/yaml/">done in GitLabCI</a> )?  Why should one task be split into smaller steps?  Good question, I will try to explain with an example. </p><br><p>  By design, a <strong>job</strong> is an isolated task that does not depend on other parts of the pipeline.  This means that it can be launched at any time and it does not require any preliminary actions.  All intermediate and final operations take place inside, and from the outside everything looks like a single step.  Therefore, if you have any operations in the assembly that cannot exist separately, all the dependent steps should be combined into one task.  On the one hand, this gives difficulty, because too many movements are concentrated in one task, on the other - we have an excellent tool to break the process down into logical steps: tasks.  Moreover, each task can use different tools. </p><br><p>  To make it clearer, consider the example more difficult.  In the previous paragraph, I gave an example of a simple project that is built by just one command - the <code>gradle build</code> .  But this is not always the case.  Take the example of a classic monolith: some single project in which the frontend, the backend, and everything are all in the same repository.  How is the assembly of such a project?  We list all hypothetical steps: </p><br><ul><li><p>  we need to build a frontend.  Let it have a styles preprocessor, like sass / less.  You can even optimize and minify JS files.  In order to build the project's face, we download the dependencies using the <code>npm install</code> command and after that through some build tools, such as <code>gulp</code> / <code>grunt</code> generate ready-made code.  Quite standard.  After the build, we will get a certain folder <code>dist</code> , where the fully compiled optimized and minimized CSS and JS code will be. </p><br></li><li><p>  ( <em>this step was added for demonstration purposes, so it would be more interesting</em> ) sometimes we want to "sew" some information about the current release somewhere directly into the code at the assembly stage, so that we can easily determine which version is currently running on production.  Whether it is a small <code>build version 0.11.34.1122</code> , which is located at the bottom of the page in the basement of the site, or some meta-information about the current commit in Git (like hash, author name and date), which are available as JSON on some URL let's say <code>/version</code> .  There are many such options.  This is very important if the team uses the practice of continuous delivery and makes releases very often.  To do this, write a small script that takes the meta information from Git and "sew" tightly into some configuration file or directly into the HTML template, to whom it is more convenient.  ( <em>by the way, in Go you can achieve the same goal during compilation <a href="https://blog.cloudflare.com/setting-go-variables-at-compile-time/">using the</a> <code>-ldflags</code> <a href="https://blog.cloudflare.com/setting-go-variables-at-compile-time/">flag</a> , but I intentionally left this step in a separate task for example</em> ) </p><br></li><li>  and of course, the server side build.  To do this, you need to download the dependencies, transfer the generated files in the previous step, putting it all together.  Let's build a Go project this time.  In this language, a zoo of different package managers, for example, I took a <a href="https://github.com/kardianos/govendor">govendor</a> , but this fact does not change.  Before the build, we make the <code>govendor fetch -v +out</code> command, which downloads all the latest dependencies as source <code>govendor fetch -v +out</code> them in the <code>vendor</code> daddy (well, it‚Äôs worth mentioning that some programmers will commit this entire folder to git so as not to unload the dependencies again and again ; both approaches have advantages and disadvantages, the discussion of which is beyond the scope of this article).  Well, after the source code has been locally found, we can compile everything. </li></ul><br><p>  So what we counted?         : npm, gulp, git (,   ,   ssh), go, govendor.   ,   ConcourseCI   -,     ,       -,             ?                ‚Äî  git,  npm,  go, ? ,    ,   ,  ,  .         (job)   -,       -. ,     : </p><br><ol><li>  NPM     . </li><li>  Git </li><li>    Go </li><li>    </li></ol><br><p>   ,          ,     .        (job),      -,              . </p><br><p>         ,      ,    .    ‚Äî     <a href="https://hub.docker.com/r/monostream/nodejs-gulp-bower/~/dockerfile/">  NPM, Gulp</a>   ,   ‚Äî <a href="https://hub.docker.com/r/alpine/git/">   git  ssh</a> ,   ‚Äî <a href="https://hub.docker.com/r/electrotumbao/go-govendor/~/dockerfile/"> go-vendor</a> . ,        ,   ,    ! </p><br><p>  ,         , ?      !   ConcourseCI    <a href="https://concourse-ci.org/aggregate-step.html">aggregate</a> ,    ,    ,  .   ,      ,  , , ,      : </p><br><pre> <code class="hljs pgsql"> ‚ï≠  NPM ,   Gulp build <span class="hljs-number"><span class="hljs-number">1.</span></span> ‚î® Git <span class="hljs-keyword"><span class="hljs-keyword">version</span></span> ‚ï∞  Go  <span class="hljs-number"><span class="hljs-number">2.</span></span>   go build</code> </pre> <br><p> ,          (  source-code  docker-example-image   ): </p><br><pre> <code class="hljs lua">... jobs: - name: <span class="hljs-string"><span class="hljs-string">"Build monolith example"</span></span> plan: - get: source-code trigger: <span class="hljs-literal"><span class="hljs-literal">true</span></span> #     aggregate, #     - aggregate: # Build the frontend (SASS <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> Javascript) - task: <span class="hljs-string"><span class="hljs-string">"Build frontend, compile SASS, download dependencies"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>: platform: linux image_resource: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: docker-image source: repository: <span class="hljs-string"><span class="hljs-string">'monostream/nodejs-gulp-bower'</span></span> inputs: - name: source-code outputs: - name: compiled-assets run: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: sh args: - -ec - | cd source-code/ #   npm install #   gulp build #     outputs, #       cp -r dist/* ../compiled-assets/ - task: <span class="hljs-string"><span class="hljs-string">"Download GO dependencies"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>: platform: linux image_resource: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: docker-image source: repository: <span class="hljs-string"><span class="hljs-string">"electrotumbao/go-govendor"</span></span> inputs: - name: source-code #    Go:    #     #      #     #   <span class="hljs-built_in"><span class="hljs-built_in">path</span></span> <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: src/authorName/repoName outputs: - name: vendor-<span class="hljs-built_in"><span class="hljs-built_in">output</span></span> run: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: sh args: - -ec - | export GOPATH GOPATH=<span class="hljs-string"><span class="hljs-string">"$(pwd)"</span></span> cd src/authorName/repoName/ || <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> #       <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>, #       govendor fetch -v +out cp -r vendor/* <span class="hljs-string"><span class="hljs-string">"$GOPATH"</span></span>/vendor-<span class="hljs-built_in"><span class="hljs-built_in">output</span></span> - task: <span class="hljs-string"><span class="hljs-string">"Update GIT commit details"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>: platform: linux image_resource: <span class="hljs-built_in"><span class="hljs-built_in">type</span></span>: docker-image source: { repository: <span class="hljs-string"><span class="hljs-string">'alpine/git'</span></span>, tag: <span class="hljs-string"><span class="hljs-string">"latest"</span></span>} inputs: - name: source-code outputs: - name: versioned-file run: <span class="hljs-built_in"><span class="hljs-built_in">path</span></span>: sh args: - -ec - | #        cd source-code GITSHA=$(git rev-parse HEAD) GITAUTHOR=$(git <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> <span class="hljs-comment"><span class="hljs-comment">--format='%an %ae' -1) GITDATE=$(git log --format='%aD' -1) TODAY=$(date) #    -   , #     sed sed ... #       output, #       cp version.config ../versioned-file/ #  ,     #   ,     - task: "Build Source Code" config: platform: linux image_resource: type: docker-image source: {repository: "golang", tag: "alpine" } #  inputs    #       inputs: - name: source-code path: src/authorName/repoName - name: versioned-file - name: compiled-assets - name: vendor-output outputs: - name: output-for-docker run: path: sh args: - -ec - | set -e export GOPATH GOPATH="$(pwd)" cd src/daxi.re/cyprus-tours/ || exit #          cp -r "$GOPATH"/compiled-assets/* ./assets/ cp -r "$GOPATH"/vendor-output/* ./vendor #    go test # ,   CGO_ENABLED=0 GOOS=linux go build -a -o app . #   -    #           . #   ,     -. #       # docker-example-image (. )      #        output cp app "$GOPATH"/output-for-docker/ cp Dockerfile "$GOPATH"/output-for-docker/ #  ,   , #  -    #   , #       #  Dockerfile # (     ) - put: docker-example-image params: { build: output-for-docker } get_params: {rootfs: true}</span></span></code> </pre><br><p>             ,      . </p><br><p><img src="https://habrastorage.org/webt/pm/yn/_6/pmyn_6rvbuo55oxbuaf8pid1fc8.jpeg" alt="ConcourseCI Conveyor"></p><br><p>  ,    ,         (job).            ,     .       ,     <em></em> :   NPM ,  ‚Äî Go  (     ).         . </p><br><p><img src="https://habrastorage.org/webt/t8/uk/om/t8ukomlx1altfoptuyj9xq2exka.jpeg" alt="The process of parallel assembly in ConcourseCI"></p><br><p>    ,   ,      : </p><br><p><img src="https://habrastorage.org/webt/y-/5y/ne/y-5ynevhtmzacj3l6xnkzjdmnbs.jpeg" alt="ConcourseCI successfully assembled task"></p><br><p>  Voila!  ,              !        .    ,        -. </p><br><p>  ,            .      .  Thank you for reading to the end!   ! </p><br><p>  References: </p><br><ul><li> <a href="https://concourse-ci.org/"></a> </li><li> <a href="https://concoursetutorial.com/">   </a> </li><li> <a href="https://www.youtube.com/watch%3Fv%3DJtbR2bTmjkI">   "ConcourseCI:   "    . </a> </li></ul><br><p> <strong>UPD 15.3.2018:</strong>  ,        <a href="https://medium.com/concourse-ci/were-switchin-domains-5597dcd0b48b"> </a> ,      . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/347186/">https://habr.com/ru/post/347186/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../347170/index.html">Making games in Python 3 and Pygame: Part 2</a></li>
<li><a href="../347174/index.html">Not a webpack</a></li>
<li><a href="../347180/index.html">Convert from Sketch to PSD</a></li>
<li><a href="../347182/index.html">Digital events in Moscow from January 22 to 28</a></li>
<li><a href="../347184/index.html">Generative Modeling and AI</a></li>
<li><a href="../347188/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ298 (January 15 - 21, 2018)</a></li>
<li><a href="../347190/index.html">Pros of the "correct" virtual number</a></li>
<li><a href="../347192/index.html">News from the world of OpenStreetMap ‚Ññ391 (09.01.2018-15.01.2018)</a></li>
<li><a href="../347194/index.html">CSS naming conventions and time saving</a></li>
<li><a href="../347196/index.html">DDoS protection at the web server level</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>