<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to prevent memory overruns when using Java collections</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 Our experiment with steps in the Java Developer course continues and, oddly enough, even quite successfully (sort of): as it turned out, pla...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to prevent memory overruns when using Java collections</h1><div class="post__text post__text-html js-mediator-article"> Hello! <br><br>  Our experiment with steps in the <a href="https://otus.pw/b4wG/">Java Developer</a> course continues and, oddly enough, even quite successfully (sort of): as it turned out, planning a couple of months with the next transition to a new level at any convenient time is much more convenient than if allocate almost six months to such a complex course.  So there is a suspicion that it is precisely difficult courses that we will soon begin to gradually transfer to such a system. <br><br>  But this is me about our, about Otusovskom, sorry.  As always, we continue to explore interesting topics that, although not touched upon in our program, but which are discussed with us - therefore, to one of the questions that our teachers asked, we prepared a translation of the most interesting article in our opinion. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Go! <br><br><img src="https://habrastorage.org/webt/gg/pb/_w/ggpb_wvr4ihy5kk_wj9wm0awrea.png"><a name="habracut"></a><br><br>  Collections in the JDK are standard library implementations of lists and maps.  If you look at a snapshot of the memory of a typical large application written in Java, you will see thousands or even millions of copies of <code>java.util.ArrayList</code> , <code>java.util.HashMap</code> , etc. Collections are indispensable for storing and manipulating data.  But have you ever thought about whether all the collections in your application make optimal use of memory?  In other words, if your application crashes with the shameful <code>OutOfMemoryError</code> or causes a long pause for the garbage collector, have you ever checked your collections for leaks. <br><br>  First, it must be noted that the internal collections of the JDK are not some kind of magic.  They are written in Java.  Their source code comes with the JDK, so you can open it in your IDE.  Their code can also be easily found on the Internet.  And, as it turns out, most collections are not very elegant in terms of optimizing the amount of memory consumed. <br><br>  Consider, for example, one of the simplest and most popular collections ‚Äî the <code>java.util.ArrayList</code> class.  Inside each <code>ArrayList</code> operates with an array of <code>Object[] elementData</code> .  This is where the list items are stored.  Let's see how this array is processed. <br><br>  When you create an <code>ArrayList</code> constructor by default, that is, call <code>new ArrayList()</code> , <code>elementData</code> points to a generic array of size zero ( <code>elementData</code> can also be set to <code>null</code> , but the array provides some minor implementation benefits).  When you add the first element to the list, a real unique <code>elementData</code> array is <code>elementData</code> and the provided object is inserted into it.  In order to avoid resizing the array every time you add a new element, it is created with a length of 10 (‚Äúdefault capacity‚Äù).  So it turns out: if you no longer add elements to this <code>ArrayList</code> , 9 out of 10 slots in the <code>elementData</code> array will remain empty.  And even if you clear the list, the size of the internal array will not be reduced.  Below is a diagram of this life cycle: <br><br><img src="https://habrastorage.org/webt/mu/3n/hd/mu3nhdbrmajrdvphqi1kyj6nhii.png"><br><br>  How much memory is wasted here?  In absolute values, it is calculated as (object pointer size).  If you are using a JVM HotSpot (which comes with the Oracle JDK), the pointer size will depend on the maximum heap size (for more information, see <a href="https://blog.codecentric.de/ru/2014/02/35gb-heap-less-32gb-java-jvm-memory-oddities/">https://blog.codecentric.de/ru/2014/02/35gb-heap-less- 32gb-java-jvm-memory-oddities /</a> ).  Usually, if you specify <code>-Xmx</code> less than 32 gigabytes, the pointer will be 4 bytes in size;  for large heaps - 8 bytes.  Thus, an <code>ArrayList</code> , initialized by the default constructor, with the addition of only one element, wastes either 36 or 72 bytes. <br><br>  In fact, an empty <code>ArrayList</code> also wastes memory, since it does not carry any workload, but the size of the <code>ArrayList</code> object itself is not zero and larger than you probably think.  This is because, on the one hand, each object managed by the HotSpot JVM has a 12- or 16-byte header that is used by the JVM for internal purposes.  Further, most collection objects contain a <code>size</code> field, a pointer to an internal array or another ‚Äúworkload carrier‚Äù object, a <code>modCount</code> field to track content changes, etc. Thus, even the smallest possible object representing an empty collection will probably need at least 32 bytes of memory.  Some, like <code>ConcurrentHashMap</code> , take up much more. <br><br>  Consider another common collection - the <code>java.util.HashMap</code> class.  Its life cycle is similar to the <code>ArrayList</code> life cycle: <br><br><img src="https://habrastorage.org/webt/qu/ov/lm/quovlmld5clm9w8f0x3v7a_kor8.png"><br><br>  As you can see, a <code>HashMap</code> containing only one key-value pair spends 15 internal array cells, which corresponds to 60 or 120 bytes.  These numbers are small, but the scale of memory loss for all collections in your application is important.  And it turns out that some applications can spend a lot of memory in this way.  For example, some of the popular open source Hadoop components that the author has analyzed lose about 20 percent of their heap in some cases!  For products developed by less experienced engineers and not subjected to regular performance analysis, memory loss may be even higher.  There are enough cases when, for example, 90% of the nodes in a huge tree contain only one or two descendants (or nothing at all), and other situations where the heap is filled with 0-, 1- or 2-element collections. <br><br>  If you find unused or underused collections in your application, how do you fix them?  Below are some common recipes.  Here it is assumed that our problem collection is the <code>ArrayList</code> referenced by the data field <code>Foo.list</code> . <br><br>  If most instances of the list are never used, try initializing it lazily.  So the code that previously looked like ... <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ list.add(x); }</code> </pre> <br>  ... must be converted to something like <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addToList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Object x)</span></span></span><span class="hljs-function"> </span></span>{ getOrCreateList().add(x); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> list </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateList</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,         if (list == null) list = new ArrayList(); return list; }</span></span></code> </pre> <br>  Keep in mind that sometimes you will need to take extra steps to resolve possible contests.  For example, if you support <code>ConcurrentHashMap</code> , which can be updated by several threads simultaneously, the code that initializes it is deferred, should not allow two threads to create two copies of this map randomly: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Map </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getOrCreateMap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (map == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//,       synchronized (this) { if (map == null) map = new ConcurrentHashMap(); } } return map; }</span></span></code> </pre> <br>  If most instances of your list or map contain only a few elements, try initializing them with a more suitable initial capacity, for example. <br><br><pre> <code class="java hljs">list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList(<span class="hljs-number"><span class="hljs-number">4</span></span>); <span class="hljs-comment"><span class="hljs-comment">//       4</span></span></code> </pre> <br>  If your collections are empty or contain only one element (or a key-value pair) in most cases, you can consider one extreme form of optimization.  It only works if the collection is fully managed within the current class, that is, other code cannot access it directly.  The idea is that you change the type of your data field, for example, from List to a more general Object, so that it can either point to a real list or directly to a single list item.  Here is a brief sketch: <br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ***   *** private List&lt;Foo&gt; list = new ArrayList&lt;&gt;(); void addToList(Foo foo) { list.add(foo); } // ***   *** //   ,    null.      , //      .       //   ArrayList. private Object listOrSingleEl; void addToList(Foo foo) { if (listOrSingleEl == null) { //   listOrSingleEl = foo; } else if (listOrSingleEl instanceof Foo) { //  Foo firstEl = (Foo) listOrSingleEl; ArrayList&lt;Foo&gt; list = new ArrayList&lt;&gt;(); listOrSingleEl = list; list.add(firstEl); list.add(foo); } else { //      ((ArrayList&lt;Foo&gt;) listOrSingleEl).add(foo); } }</span></span></code> </pre> <br>  Obviously, code with this optimization is less clear and harder to maintain.  But this can be useful if you are sure that in this way you will save a lot of memory or get rid of the long pauses of the garbage collector. <br><br>  You are probably already thinking: how do I find out which collections in my application memory overrun and how much? <br><br>  In short: it's hard to find out without the right tools.  Attempting to guess the amount of memory used or spent by data structures in a large complex application almost never leads to anything.  And, not knowing exactly where the memory goes, you can spend a lot of time chasing the wrong goals, while your application stubbornly continues to fall with <code>OutOfMemoryError</code> . <br><br>  For this, you should check out a bunch of applications with a special tool.  By experience, the best way to analyze a JVM memory (measured as the amount of available information versus the impact of this tool on application performance) is to dump the heap, and then view it offline.  A heap dump is essentially a complete snapshot of the heap.  You can get it at any time by calling the jmap utility, or you can configure the JVM to automatically create a dump if the application crashes with an <code>OutOfMemoryError</code> .  If you google the JVM heap dump, you will immediately see a large number of articles explaining in detail how to get the dump. <br><br>  A heap dump is a binary file the size of a JVM heap, so it can only be read and analyzed using special tools.  There are several such tools, both open source and commercial.  The most popular open source tool is the Eclipse MAT;  There are also VisualVM and some less powerful and less well-known tools.  Commercial tools include Java general purpose profilers: JProfiler and YourKit, as well as one tool designed specifically for heap dump analysis - JXRay (a disclaimer: the last one was developed by the author). <br><br>  Unlike other tools, JXRay immediately analyzes the heap dump for a large number of common problems, such as duplicate lines and other objects, as well as insufficiently efficient data structures.  Problems with the above collections fall into the latter category.  The tool generates a report with all the information gathered in HTML format.  The advantage of this approach is that you can view the analysis results anywhere at any time and easily share them with others.  You can also run the tool on any machine, including large and powerful, but ‚Äúheadless‚Äù machines in the data center. <br><br>  JXRay calculates the overhead (how much memory you save if you get rid of a specific problem) in bytes and as a percentage of the heap used.  It combines collections of the same class, which have the same problem ... <br><br><img src="https://habrastorage.org/webt/qm/_n/44/qm_n44hqttg315sv5h8wv3ujefc.png"><br><br>  ... and then groups problem collections that are accessed from some root of the garbage collector through the same link chain, as in the example below. <br><br><img src="https://habrastorage.org/webt/4o/is/ib/4oisibqplc6cj55ojwossuycohs.png"><br><br>  Knowing which reference chains and / or individual data fields (for example, <code>INodeDirectory.children</code> above) indicate collections that spend most of the memory allows you to quickly and accurately identify the code that is responsible for the problem, and then make the necessary changes. <br><br>  Thus, inadequately configured Java collections can waste a lot of memory.  In many situations, this problem is easy to solve, but sometimes you may need to change your code in non-trivial ways to achieve a significant improvement.  It is very difficult to guess which collections need to be optimized in order to have the greatest impact.  In order not to waste time on optimizing the wrong parts of the code, you need to get a dump of the JVM heap and analyze it using the appropriate tool. <br><br>  THE END <br><br>  We are, as always, interested in your opinions and questions, which you can leave here or drop by for <a href="https://otus.pw/7i6v/">an open lesson</a> and ask our <a href="https://otus.pw/OU13/">teachers</a> there. </div><p>Source: <a href="https://habr.com/ru/post/420245/">https://habr.com/ru/post/420245/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420233/index.html">UE4 | Inventory for multiplayer # 5 | Information transfer between Server and Client</a></li>
<li><a href="../420235/index.html">Zenject: How an IoC container can kill Dependency Injection on your project</a></li>
<li><a href="../420237/index.html">Qt wrapper around gRPC framework in C ++</a></li>
<li><a href="../420239/index.html">Mobile development. Swift: the mystery of the protocols</a></li>
<li><a href="../420243/index.html">Breakthrough Philanthropy: Breakthrough projects on a scale of Humanity</a></li>
<li><a href="../420247/index.html">Is it worth it to go to a specialist in the Far East</a></li>
<li><a href="../420251/index.html">Apple claims that the company's headquarters complex costs only $ 200.</a></li>
<li><a href="../420253/index.html">How open API banks change the financial world</a></li>
<li><a href="../420257/index.html">Do you still install Windows 2008? Me too and that's why</a></li>
<li><a href="../420259/index.html">Singapore Aging Dashboard</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>