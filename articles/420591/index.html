<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Translation of Andrew Un‚Äôs Passion for Machine Learning, Chapter 20-27</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="previous chapters 
 20 Offset and scatter: Two major sources of error 


 translator's comment Before the change, this chapter was called "Systematic ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Translation of Andrew Un‚Äôs Passion for Machine Learning, Chapter 20-27</h1><div class="post__text post__text-html js-mediator-article"><p>  <a href="https://habr.com/post/419885/">previous chapters</a> </p><br><h1 id="20-smeschenie-i-razbros-dva-osnovnyh-istochnika-oshibok">  20 Offset and scatter: Two major sources of error </h1><br><p>  <em><u>translator's comment</u> Before the change, this chapter was called <strong>"Systematic and Random: Two main sources of error,"</strong> that is, I used the terms "random error" and "systematic error" to translate bias and variance.</em>  <em>However, the forum <a href="https://habr.com/users/Phaker/">user robot @ Phaker</a> rightly remarked in the comments that in the field of machine learning in Russian terminology the concepts of "displacement" and "scatter" are fixed for these terms.</em>  <em>I looked at the work of K.V.</em>  <em>Vorontsova, who is deservedly one of the authorities in the field of machine learning in Russia and the resources of the professional community, and agreed with the comment by <a href="https://habr.com/users/Phaker/">robot @ Phaker</a> .</em>  <em>Despite the fact that, from my point of view, there is a profound analogy between the "bias" and "variance" in teaching algorithms and the "systematic error" and "random error" of a physical experiment. , it is nevertheless correct to use the terms established in this field.</em>  <em>Therefore, I revised the translation of this and subsequent chapters, replacing "Systematic and Random errors" with "Offset and Scatter" and will stick to this approach in the future.</em> </p><a name="habracut"></a><br><p>  Suppose your training, validation and test samples have the same distribution.  Then you need to take more data for training, it will only improve the quality of the algorithm, is this true? </p><br><p>  Despite the fact that getting more data can not damage the work, unfortunately, new data does not always help as much as you can expect.  In some cases, working on additional data may be a waste of effort.  How to make a decision - when to add data, and when you should not worry about it. </p><br><p>  In machine learning there are two main sources of errors: displacement and dispersion (variance).  Understanding what they are will help you decide whether to add more data, will also help you choose tactics to improve the quality of the classifier. </p><br><p>  Suppose you hope to build a cat recognizer with 5% errors.  Currently, your classifier has a 15% error on the training sample, and a 16% validation sample.  In this case, adding training data is unlikely to help significantly increase the quality.  You should concentrate on other system changes.  In fact, adding more examples to your training sample will only make it harder for your algorithm to get a good result on this sample (why this will be explained in the following chapters). </p><cut></cut><br><p>  If the percentage of your mistakes in the training sample is 15% (which corresponds to an accuracy of 85%), but your goal is the error rate of 5% (95% accuracy), then first of all you need to improve the quality of your algorithm in the training sample.  The quality of the algorithm on a validation / test sample is usually worse than the quality of its work on the sample for training (on a training sample).  You need to understand that those approaches that led you to an accuracy not exceeding 85% with examples with which your algorithm is familiar will not allow you to get 95% accuracy with examples that this algorithm has not even seen. </p><cut></cut><br><p>  Suppose, as noted above, the error rate of your algorithm is 16% (accuracy is 84%) in the validation sample.  We have to break the 16% error into two components: </p><br><ul><li>  First, the proportion of algorithm errors in the training sample.  In this example, it is 15%.  We informally call it <strong>bias</strong> . </li><li>  Second, how much worse the algorithm works on the validation (or test) sample than on the training one.  In our example, 1% worse on the validation sample than on the training.  We will also informally consider it as a <strong>variance of the</strong> algorithm. </li></ul><br><p>  <em><u>author's comment</u> In the statistics there is a more accurate definition for the bias and the spread (systematic and random errors), but we should not be disturbed.</em>  <em>Roughly speaking, we will assume that the offset is a mistake of your algorithm on your training sample, when you have a very large training sample.</em>  <em>The scatter is how much worse the algorithm works on the test sample compared to the training one with the same parameter settings.</em>  <em>If we use the root-mean-square error, then we can write the formulas defining these two quantities and prove that the total error is equal to the sum of the displacement and the spread (the sum of random and systematic errors).</em>  <em>But for our purposes of improving the algorithms in machine learning problems, an informal definition of displacement and scatter is sufficient.</em> </p><br><p>  Some changes in the learning algorithm affect the first component of the error - bias ( <strong>bias</strong> ) and improve the execution of the algorithm on the training set.  Some changes affect the second component - <strong>variance</strong> and help to better generalize the work of the algorithm to the validation and test samples.  To select the most effective changes that need to be made to the system, it is extremely useful to understand how each of these two components of the error affects the overall system error. </p><br><p>  <em><u>author's note:</u> There are also some approaches that simultaneously reduce displacement and scatter, making significant changes to the system architecture.</em>  <em>But they are usually more difficult to find and implement.</em> </p><br><p>  To select the most effective changes that need to be made to the system, it is extremely useful to understand how each of these two components of the error affects the overall system error. </p><br><p>  Developing an intuition in understanding how the Offset contributes to the error, and which Spread, helps you to effectively choose ways to improve your algorithm. </p><cut></cut><br><h1 id="21-primery-klassifikacii-oshibok">  21 Error Classification Examples </h1><br><p>  Consider our task on the classification of cats.  The ideal classifier (for example, a person) can achieve the excellent quality of this task. </p><br><p>  Suppose that the quality of our algorithm is as follows: </p><br><ul><li>  Error in training sample = 1% </li><li>  Error on validation sample = 11% </li></ul><br><p>  What is the problem with this classifier?  Applying the definitions from the previous chapter, we estimate the displacement at 1% and the variation at 10% (= 11% - 1%).  Thus, our algorithm has a large <strong>scatter</strong> .  The qualifier has a very low error on the training sample, but it cannot generalize the results of training for the validation sample.  In other words, we are dealing with <strong>overfitting</strong> . </p><br><p>  Now consider the following situation: </p><br><ul><li>  Error in training sample = 15% </li><li>  Error on validation sample = 16% </li></ul><br><p>  Then we estimate the <strong>offset</strong> at 15% and the <strong>spread</strong> at 1%.  This classifier was poorly trained in the training sample, while its error in the validation sample was slightly more than in the training sample.  Thus, this classifier has a large offset, but a small variation.  It can be concluded that this algorithm is <strong>underfitting</strong> . </p><cut></cut><br><p>  Consider the following error distribution: </p><br><ul><li>  Error in training sample = 15% </li><li>  Error on validation sample = 30% </li></ul><br><p>  In this case, the offset is 15% and the spread is also 15%.  This classifier has high offset and scatter: it works poorly in the training sample, having a high offset, and its quality in the validation sample is much worse than in the training sample, i.e.  the spread is also great.  This case is difficult to describe in terms of over-training / under-training, this classifier is both re-trained and under-trained. </p><cut></cut><br><p>  Finally, consider the following situation: </p><br><ul><li>  Error in training sample = 0.5% </li><li>  Error on validation sample = 1% </li></ul><br><p>  This is a perfectly working classifier, it has a low offset and scatter.  Congratulations to engineers with a great result! </p><cut></cut><br><h1 id="22-sravnenie-s-optimalnoy-doley-oshibok">  22 Comparison with optimal error rate </h1><br><p>  In our example on recognition of cats, the ideal fraction of errors is the level available to the ‚Äúoptimal‚Äù classifier and this level is close to 0%.  The person viewing the picture is almost always able to recognize whether the cat is in the picture or not, and we can hope that sooner or later the car will do it just as well. </p><br><p>  But there are more complex tasks.  For example, imagine that you are developing a speech recognition system and found that 14% of audio recordings have so much background noise or so unintelligible speech that even a person cannot make out what was said there.  In this case, even the most "optimal" speech recognition system may have an error in the region of 14%. </p><br><p>  Suppose in the given problem of speech recognition our algorithm has achieved the following results: </p><br><ul><li>  Error in training sample = 15% </li><li>  Error on validation sample = 30% </li></ul><cut></cut><br><p>  The quality of work of the classifier on the training sample is already close to the optimum, having a 14% error rate.  Thus, in this case we have not so many opportunities to reduce the <strong>bias</strong> (improving the performance of the algorithm on the training sample).  However, it is not possible to generalize the work of this algorithm on the validation sample, therefore there is a large field for <strong>scatter</strong> reduction activities. </p><br><p>  This case is similar to the third example from the previous chapter, in which the error on the training sample is also equal to 15% and the error on the validation sample is 30%.  If the optimal error rate is about 0%, then the error on the training sample of 15% gives a lot of space to work on improving the algorithm.  With this assumption, efforts to reduce the <strong>bias</strong> in the work of the algorithm can be very fruitful.  But if the optimal fraction of classification errors cannot be lower than 14%, then a similar proportion of algorithm errors in the training sample (ie, in the region of 14-15%) suggests that the possibilities for reducing the <strong>bias are</strong> almost exhausted. </p><br><p> For tasks in which the optimal fraction of classification errors is significantly different from zero, it is possible to propose a more detailed structuring of errors.  Continuing with the speech recognition example given above, a total error of 30% on a validation sample can be decomposed into the following components (errors can be analyzed in a test sample in the same way): </p><cut></cut><br><ul><li>  <strong>Optimal bias (unavoidable bias):</strong> 14%.  Imagine, we decided that even perhaps the best speech recognition system in the world would have an error rate of 14%.  We will speak of this as the ‚Äúunavoidable‚Äù part of the learning algorithm. </li><li>  <strong>Avoidable bias</strong> : 1%.  This value is calculated as the difference between the fraction of errors in the training sample and the optimal fraction of errors. </li></ul><br><p>  <em><u>author's note:</u> If this value is negative, thus your algorithm on the training sample shows a smaller error than the ‚Äúoptimal‚Äù one.</em>  <em>This means that you have retrained in the training sample, your algorithm has memorized examples (and their classes) of the training sample.</em>  <em>In this case, you should focus on the methods of reducing the scatter, and not on further reducing the bias.</em> </p><br><ul><li>  <strong>Variance</strong> : 15%.  Difference between errors in the training sample and validation sample </li></ul><br><p>  Matching this with our previous definitions, the bias and the disposable bias are related as follows: </p><br><p>  Offset <strong>(bias)</strong> = Optimal Offset ( <strong>"unavoidable bias"</strong> ) + Disposable Offset ( <strong>"avoidable bias"</strong> ) </p><br><p>  <em><u>author's note</u> : These definitions are chosen to better explain how the quality of the learning algorithm can be improved.</em>  <em>These definitions differ from the formal definitions of displacement and scatter adopted in statistics.</em>  <em>Technically, what I define as ‚ÄúOffset‚Äù should be called ‚Äúan error that lies in the data structure (it cannot be identified and eliminated)‚Äù and ‚ÄúEliminated offset‚Äù should be defined as ‚ÄúOffset learning algorithm that exceeds the optimal offset‚Äù .</em> </p><br><p>  The avoidable bias shows how much worse the quality of your algorithm in the training sample is than the quality of the ‚Äúoptimal classifier‚Äù. </p><br><p>  The basic idea of ‚Äã‚Äãvariance remains the same.  In theory, we can always reduce the spread to almost zero, training on a fairly large training sample.  Thus, any variation is ‚Äúavoidable‚Äù if there is a sufficiently large sample, so there can be no such thing as an ‚Äúunavoidable variance‚Äù. </p><cut></cut><br><p>  Consider another example in which the optimal error is 14% and we have: </p><br><ul><li>  Error in training sample = 15% </li><li>  Error on validation sample = 16% </li></ul><br><p>  In the previous chapter, we estimated the classifier with such indicators as a classifier with a high offset; in the current conditions, we will say that the ‚Äúavoidable bias‚Äù is 1% and the spread is about 1%.  Thus, the algorithm is already working quite well and there is almost no room for improving the quality of its work.  The quality of operation of this algorithm is only 2% lower than optimal. </p><br><p>  From these examples it is clear that the knowledge of the magnitude of a fatal error is useful for making decisions about further actions.  In statistics, the optimal <strong>error rate</strong> is also called the <strong>Bayes error rate</strong> . </p><br><p>  How to find out the size of the optimal error rate?  For tasks that a person does well, such as image recognition or decoding audio clips, you can ask assessors to mark up the data, and then measure the accuracy of the human markup on the training sample.  This will give an estimate of the optimal proportion of errors.  If you are working on a problem that is difficult for a person to cope with (for example, to predict which film to recommend or which advertisement to show to the user), in this case it is rather difficult to estimate the optimal proportion of errors. </p><br><p>  In the Comparison with Human-Level Performance section, Chapters 33 through 35, I will discuss in more detail the process of comparing the quality of the learning algorithm with the level of quality that a person can achieve. </p><cut></cut><br><p>  In the last chapters, you learned how to estimate removable / unrecoverable displacement and spread by analyzing the fraction of classifier errors in training and validation samples.  The next chapter will look at how you can use the findings from such an analysis to decide whether to focus on methods that reduce bias or on methods that reduce scatter.  Approaches to dealing with bias are very different from approaches to reducing scatter, so the techniques that you should use in your project to improve quality depend strongly on what is currently the problem ‚Äî a large bias or a large scatter. </p><cut></cut><br><p>  Read on! </p><br><h1 id="23-ustranenie-smescheniya-i-razbrosa">  23 Elimination of bias and scatter </h1><br><p>  We give a simple formula for eliminating bias and scatter: </p><br><ul><li>  If you have a large avoidable bias, increase the complexity of your model (for example, increase your neural network by adding layers or (and) neurons) </li><li>  If you have a wide variation, add examples to your training sample. </li></ul><br><p>  If you have the opportunity to increase the size of the neural network and add unlimited data to the training sample, this will help to achieve a good result for a large number of machine learning tasks. </p><br><p>  In practice, increasing the size of a model will ultimately cause computational complexity, since learning of very large models is slow.  You can also exhaust the limit of training data.  (Even in the whole Internet, the number of images with cats of course!) </p><br><p>  Different architectures of models of algorithms, for example, different architectures of neural networks, will give different values ‚Äã‚Äãfor displacement and spread, with reference to your task.  A shaft of recent research in the field of depth learning has allowed for the creation of a large number of innovative architectures of neural network models.  Thus, if you use neural networks, scientific literature can be an excellent source for inspiration.  There is also a large number of excellent implementations of algorithms in open sources, for example on GitHub.  However, the results of attempts to use new architectures are much less predictable than the above simple formula - increase the size of the model and add data. </p><br><p>  Increasing the size of the model usually reduces the offset, but it can also cause an increase in the spread, and the risk of over-training also increases.  However, the problem of retraining arises only when you are not using regularization.  If you include a well-designed regularization method in the model, it is usually possible to safely increase the size of the model without allowing retraining. </p><br><p>  Suppose you apply deep learning using L2 regularization or dropout ( <em><u>Translator's Note</u> : You can read about <strong>Dropout</strong> , for example, here: <a href="https://habr.com/company/wunderfund/blog/330814/">https://habr.com/company/wunderfund/blog/330814/</a></em> ) using regularization parameters that work flawlessly on validation sample.  If you increase the size of the model, usually the quality of your algorithm remains the same or grows;  its significant decrease is unlikely.  The only reason for which it is necessary to refuse to increase the size of the model - large computational costs. </p><br><h1 id="24-kompromiss-mezhdu-smescheniem-i-razbrosom">  24 Compromise between bias and scatter </h1><br><p>  You may have heard of the ‚Äútrade-off between displacement and spread.‚Äù  Among the many changes that can be made to the learning algorithms, there are those that reduce the offset and increase the spread or vice versa.  In this case, they speak of a ‚Äúcompromise‚Äù between displacement and spread. </p><br><p>  For example, increasing the size of a model ‚Äî adding neurons and (or) layers of the neural network, or adding input features usually reduce the offset, but can increase the spread.  On the contrary, the addition of regularization often increases the offset, but reduces the spread. </p><br><p>  Today, we usually have access to a large amount of data and enough computing power to train large neural networks (for deep learning).  Thus, the problem of compromise is not so acute, and we have many tools at our disposal to reduce the displacement without harming the scatter value strongly and vice versa. </p><br><p>  For example, you can usually increase the size of the neural network and adjust the regularization so as to reduce the offset without noticeably increasing the spread.  Adding data to the training sample, as a rule, reduces the spread, without affecting the offset. </p><br><p>  If you successfully select the model architecture that is well suited to the task, you can simultaneously reduce both the offset and the spread.  But choosing such an architecture can be challenging. </p><br><p>  In the next few chapters, we will discuss other specific techniques aimed at combating displacement and scatter. </p><br><h1 id="25-podhody-k-umensheniyu-ustranimogo-smescheniya">  25 Approaches to reducing disposable bias </h1><br><p>  If your learning algorithm suffers from a large removable offset, you can try the following approaches: </p><br><ul><li>  <strong>Increasing the size of the model</strong> (such as the number of neurons and layers): this approach reduces the offset, so you have the opportunity to better customize the algorithm to the training sample.  If you find that this increases the spread, use regularization, which usually eliminates the increase in spread. </li><li>  <strong>Modify incoming signs based on the ideas that came up when analyzing errors</strong> .  Suppose error analysis has prompted you to create new additional features that help the algorithm get rid of a specific category of errors (in the following chapters we will discuss this aspect).  These new features can help with both offset and spread.  In theory, the addition of new features may increase the spread;  but if this happens, you can always use regularization, which usually helps to cope with the increase in scatter. </li><li>  <strong>Reduction or rejection of regularization</strong> (L2 regularization, L1 regularization, Dropout): this approach reduces the recoverable displacement, however, leads to an increase in the spread. </li><li>  <strong>Modifying the model's architecture</strong> (for example, the neural network architecture) so that it is more suitable for your task: This approach affects both the spread and the offset. </li></ul><br><p>  One not very useful method: </p><br><ul><li>  <strong>Adding data to a training sample</strong> : This approach helps to reduce the spread, but usually does not have a significant effect on the bias. </li></ul><br><h1 id="26-analiz-oshibok-na-trenirovochnoy-vyborke">  26 Analysis of errors in the training sample </h1><br><p>  Only after a good quality of the algorithm in the training sample, can we expect acceptable results from it on a validation / test sample. </p><br><p>  In addition to the methods previously described, applied to a large offset, I sometimes also pass on error analysis to the training sample data, following the same approach that was used in analyzing the validation sample of the eyeball.  This can help if your algorithm has a high offset, i.e., if the algorithm was not able to study well in a training set. </p><br><p>  For example, suppose you are developing a speech recognition system for an application and have collected a training sample of audio clips from volunteers.  If your system does not work well on a training sample, you can consider listening to a set of 100 examples in which the algorithm worked poorly in order to understand the main categories of errors in the training sample.  Similar to analyzing errors in a validation sample, you can calculate errors by category: </p><br><table><thead><tr><th>  Audio clip </th><th>  Loud background noise </th><th>  User spoke too fast </th><th>  Too far from microphone </th><th>  Comments </th></tr></thead><tbody><tr><td>  one </td><td>  X </td><td></td><td></td><td>  Car noise </td></tr><tr><td>  2 </td><td>  X </td><td></td><td>  X </td><td>  Restaurant noise </td></tr><tr><td>  3 </td><td></td><td>  X </td><td>  X </td><td>  User shouts across the room </td></tr><tr><td>  four </td><td>  X </td><td></td><td></td><td>  Noise cafe </td></tr><tr><td>  % of total qty </td><td>  75% </td><td>  25% </td><td>  50% </td><td></td></tr></tbody></table><br><p>  In this example, you might understand that your algorithm is experiencing particular difficulties with training examples that have a lot of background noise.  In this way, you can focus on methods that will allow him to work better on training examples with background noise. </p><br><p>  You can also re-check how much a person can parse such audio clips by letting him listen to the same recordings as the learning algorithm.  If there is so much background noise in them that it is simply impossible for anyone to understand what they are saying, then it may be meaningless to expect that any algorithm correctly recognizes such pronunciation.  In further chapters we will discuss the benefits of comparing the quality of our algorithm with the level of quality available to humans. </p><br><h1 id="27-podhody-k-umensheniyu-razbrosa">  27 Approaches to reducing scatter </h1><br><p>  If your algorithm suffers from a large scatter, you can try the following approaches: </p><br><ul><li>  <strong>Add more data to the training sample</strong> : This is the most simple and feasible way to reduce scatter, it works as long as you have the opportunity to significantly increase the amount of data used and there is enough computational power to process them. </li><li>  <strong>Add regularization</strong> (L1 regularization, L2 regularization, dropout): this approach reduces the spread, but increases the offset. </li><li>  <strong>Add an early stop</strong> (i.e., stop the gradient descent earlier, based on the error value on the validation sample): This technique reduces the spread, but increases the offset.  Early stopping strongly resembles the regularization method, therefore some authors refer it to regularization. </li><li>  <strong>Selecting features to reduce the number / types of incoming features</strong> : This approach can help with the scatter problem, but can also increase the offset.  A slight decrease in the number of signs (say, from 1000 signs to 900) is unlikely to have a large effect on displacement.  A significant decrease (say, from 1000 signs to 100 or 10 fold reduction) is more likely to have a significant effect, the effect will increase until you eliminate too many useful signs.  In modern deep learning, when there is a lot of data, there is a departure from careful selection of signs, and today we will most likely take all the signs that we have and will teach them the algorithm, allowing the algorithm to decide which ones to use based on number of teaching examples.  However, if your training sample is small, the selection of signs can be very useful. </li><li>  <strong>Reducing the size (complexity) of the model</strong> (such as the number of neurons / layers).  <em>Use with caution!</em>  This approach can reduce scatter and at the same time possibly increase offset.  However, I would not recommend this approach to reduce the spread.  The addition of regularization usually leads to a better classification quality.  The advantage of reducing the size of the model is to reduce your need for computing power and thus speeds up the process of training models.  If an increase in the speed of training models will be useful, then you need to consider the option with a decrease in the size of the model.  However, if your task is only to reduce the spread and you do not experience a shortage of computing power, it is better to consider the possibilities of additional regularization. </li></ul><br><p>  Here I present two additional tactical techniques, repeating what was said in previous chapters, in relation to reducing bias: </p><br><ul><li>  <strong>Modify incoming signs based on the understanding derived from error analysis</strong> : Let's say your error analysis led to the idea that you can create additional signs that will help the algorithm get rid of certain categories of errors.  These new features will help reduce both scatter and offset.  Theoretically, the addition of new features may increase the bias;  but if this happens, you can always use regularization, which usually eliminates the increase in offset. </li><li>  <strong>Modify the model architecture</strong> (for example, the neural network architecture), making it more suitable for your task: This approach can reduce both displacement and spread. </li></ul><br><p>  <a href="https://habr.com/post/429832/">a continuation</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/420591/">https://habr.com/ru/post/420591/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420579/index.html">24-core CPU, and I can not dial an email</a></li>
<li><a href="../420581/index.html">Forecasting real estate sales. Lecture in Yandex</a></li>
<li><a href="../420585/index.html">Barcode database free download without registration (and other persimmon)</a></li>
<li><a href="../420587/index.html">Well, where do these engines go now?</a></li>
<li><a href="../420589/index.html">What to look for when choosing a logging system, and why we stopped at ELK</a></li>
<li><a href="../420593/index.html">Mobile Web Navigation Optimization (2 Recent Success)</a></li>
<li><a href="../420595/index.html">Automatic program generation, inverse problem and some related solutions</a></li>
<li><a href="../420597/index.html">Data Protection Officer - GDPR updates profession</a></li>
<li><a href="../420599/index.html">Thirteen Things Lemme foreseen</a></li>
<li><a href="../420603/index.html">Statistics from the owner of Tesla Model S</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>