<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to plan the capacity of the Apache Ignite cluster</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We publish the transcript of the video recording of the speech by Alexei Goncharuk (Apache Ignite PMC Member and Chief Architect of GridGain) at the A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to plan the capacity of the Apache Ignite cluster</h1><div class="post__text post__text-html js-mediator-article">  We publish the transcript of the <a href="https://www.youtube.com/watch%3Fv%3D272Q_yr1Nxk">video recording of the speech by Alexei Goncharuk</a> (Apache Ignite PMC Member and Chief Architect of GridGain) at the <a href="https://www.meetup.com/St-Petersburg-Apache-Ignite-Meetup/">Apache Ignite community meeting in St. Petersburg</a> on March 29.  You can download slides <a href="https://go.gridgain.com/rs/491-TWR-806/images/01_goncharuk_ignite_capacity%2520planning_29032018.pdf">by reference</a> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/272Q_yr1Nxk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br>  Apache Ignite community members are often asked: ‚ÄúHow many nodes and memory do you need in order to load such and such amount of data?‚Äù I want to talk about this today.  Looking ahead: such forecasting is still quite a complex, non-trivial task.  To do this, you need to understand a little about the Apache Ignite device.  I will also tell you how to simplify the forecasting task and what optimization can be applied. <br><a name="habracut"></a><br>  So, very often users come to us and say: ‚ÄúWe have data presented in the form of files.  How much memory does it take to translate this data into Apache Ignite? ‚Äù <br>  With this formulation, it is almost impossible to answer the question, because different file formats are translated into completely different models.  For example, a file can be compressed.  And if it is not compressed into a classical binary form, but data can be deduplicated, then the file is implicitly compressed. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Also do not forget that Apache Ignite provides quick access to data using different keys or SQL indexes, so in addition to the data that lies in the file, we build additional indexes, which are associated with additional costs.  So, in general, it is wrong to say that a single index will add some percentage of the total data, since the field being indexed may have a different size.  That is, it is wrong to allocate a fixed percentage of memory per index. <br><br>  Let's reformulate the problem.  We say that our model consists of several types, and we well understand the structure of each type.  Moreover, if the model has fields of variable size, say, string, then we can roughly estimate the minimum and maximum data size, as well as the size distribution in the entire data set.  Based on how many data types we have and how much information is available for each type, we will plan the amount of memory and disks. <br><br><h2>  Empirical approach </h2><br>  The empirical approach may be a little inaccurate, but, from the user's point of view, does not require some kind of deep immersion in the structure of the system.  The essence of the approach is as follows. <br>  Take a representative sample of the data and load it into Apache Ignite.  While loading, watch the storage grow.  On certain volumes, you can make "cutoffs" in order to linearly extrapolate and predict the required storage capacity for the entire data set. <br><br>  A good question is usually asked here: ‚ÄúWhat should be a representative sample?‚Äù <br>  Once we generated a sample randomly.  But it turned out that the generator collected the data in such a way that the set of residues from the division during generation was included.  At some point, it turned out that our random strings, which should have had a uniform distribution, in fact did not have this distribution.  Therefore, when you estimate the storage capacity, make sure that in the representative sample the distributions with which you operate are really performed. <br><br>  Also note the variation in the size of your objects.  If you assume that they will be of the same length, then, in general, a small number of objects is sufficient for a representative sample.  The greater the variability, the more combinations of field sizes, the larger the sample will need to load to understand the dependency.  From my own experience I‚Äôll say that the dependency starts to clear up with about a million objects that are loaded into one partition per node. <br><br>  What exactly needs to be monitored during the loading of a representative sample?  If you are working with persistence, you can look at the volume of files that you get.  Or you can simply turn on the metrics of the region, the metrics in the Apache Ignite configuration, and through MX Bean monitor the increase in memory, making ‚Äúcutoffs‚Äù and plotting the graph. <br><br><h2>  Numerical evaluation </h2><br>  In this case, we will go through all the stages of changing the data structure that your object undergoes when it is saved in Apache Ignite, and also look at the surrounding data structures that can increase memory consumption.  When we understand what changes occur and what data structures change, we can accurately estimate the amount of memory needed to load the data. <br><br>  Let's analyze the cash put operation when writing to Apache Ignite.  Data goes through 4 stages of conversion: <br><br><img src="https://habrastorage.org/webt/ry/19/ew/ry19ewmu5zf--78nefw3u1thloo.png"><br><br>  The first stage is optional, because some users work with the class and pass a Java object to Apache Ignite.  Some users create a binary object directly, so the first stage of the object conversion is skipped.  But if you work with Java objects, then this is the first transformation that an object undergoes. <br><br>  After converting a Java object into a binary object, we get a class-independent format.  Its essence is that you can operate with binary objects in a cluster, without having a description of classes.  This allows you to change the class structure and perform the so-called rolling object structure changes.  That is, your model grows, changes, and you get the opportunity to work with your data without changing classes, without expanding them in a cluster. <br><br>  The third stage of change, which introduces additional overhead - writing to disk.  The unit of work with the disk is traditionally the page.  And starting with Apache Ignite 2.0, we switched to page architecture.  This means that each page has optional headers, some metadata, which also take up space when writing objects to the page. <br><br>  And the last piece, which also needs to be considered - the update index.  Even if you do not use SQL, in Apache Ignite you have quick access by key.  This is the main Apache Ignite cache API.  Therefore, the primary key index is always built, and space is also spent on it. <br><br>  This is our binary object: <br><br><img src="https://habrastorage.org/webt/ey/cu/ju/eycuju91hwn33z-_b45dwkiefpm.png"><br><br>  We will not go deep into the structure, in general, it can be represented as a kind of title, then the fields, our essential data and the footer.  The header of the binary object is 24 bytes.  Perhaps this is a lot, but so much is needed to support the mutability of objects without classes. <br><br>  If the data model that you put in the cache implies some kind of spreading internal structure, then it might be worth seeing if you can inject some small objects into your original large object?  In principle, such inlining will save you 24 bytes per object, which gives a significant increase with a sufficiently large spreading pattern. <br><br>  The size of the footer depends on the compactFooter flag, which allows you to write the structure of the object in additional metadata.  That is, instead of writing the order of the fields in the object itself, we save them separately.  And if compactFooter is true, then the footer will be very small.  But at the same time, Apache Ignite takes additional steps to preserve and maintain this metadata.  If compactFooter is false, then the object is self-sufficient and its structure can be read without additional metadata. <br><br>  Currently, there is no method in our public API that returns the size of a binary object.  Therefore, if you find this very interesting, you can make a hack and bring the object to implementation, then you will see its size.  I think in Apache Ignite 2.5 we will add a method that will allow us to get the size of the object. <br><br><h2>  Page architecture </h2><br>  As I said, the unit of work with the disk is the page.  This is done to optimize reading and writing to disk.  But at the same time it imposes restrictions on the internal architecture of Apache Ignite, since any data structures that will be saved to disk should also work with pages. <br><br>  In other words, any data structure is built up from building blocks, whether it is a tree or a freelist.  Pages link to each other by a unique identifier.  Using the same unique identifier, we can determine in a constant time a file from which these pages can be read, from which offset one or another page will be read from this file. <br><br>  A single section, which is divided into many pages, can be represented as such a scheme: <br><br><img src="https://habrastorage.org/webt/fi/ok/qd/fiokqd3shd8suasqm-fuq_ukupa.png"><br><br>  Starting metastranitsy allows you to reach any other page.  They are divided into different types, which are quite a lot, but to simplify the example I‚Äôll say that we have: <br><br><ul><li>  data pages that store data; </li><li>  index pages that allow you to build an index tree; </li><li>  helper pages for structures such as freelist or metadata. </li></ul><br>  Why this is needed, we will talk a little below. <br><br>  Let's start with the <b>data page</b> .  This block accepts our key and value when we write data to Apache Ignite.  First, a data page is taken that can hold our information, and data is recorded in it.  When a link to them is received, information is recorded in the index. <br><br>  The data page has a tabular organization.  At the beginning there is a table that contains the offset to the key-value pairs.  The key-value pairs themselves are written in reverse order.  The very first entry is located at the end of the page.  This is done to make it easier to work with free space.  You ask why it was so difficult?  Why it is impossible to write data directly to the page and refer to the offset inside the page?  This is done to defragment the page. <br><br><img src="https://habrastorage.org/webt/v_/by/s6/v_bys64dj8piuxnjuys4m6gdqzw.png"><br><br>  If you delete entry number 2 here, two free zones are formed.  It is possible that record number 3 will need to be moved to the right in the future in order to accommodate a larger record here.  And if we have indirect addressing, then you simply change the offset of the corresponding entry in the table.  However, the external link that links to this page remains constant. <br><br>  A string can be fragmented in the sense that its size will be larger than the page size.  In this case, we take a blank page and write the tail of the line into it, and the remainder into the data page. <br><br>  In addition to the key and value, auxiliary information is also recorded in the data page for correct system operation, for example, the version number.  If you use expire policy, expiry time is also written there.  In general, additional metadata takes up 35 bytes.  After you know the size of the binary object and key, you add 35 bytes and get the amount of a specific record in the data page.  And then calculate how many entries fit in the page. <br><br>  It may be that in the data page there will be free space in which none of the entries fit.  Then in the metrics you will see the fill factor, which is not equal to 1. <br><br>  And a few words <b>about the recording procedure</b> .  Suppose you had a blank page and you wrote down some data in it.  A lot of space left.  It would be wrong to just throw out the page so that it was somewhere lying around and no longer used. <br><br>  Information about which pages have free space, which it makes sense to take into account, is stored in the ‚Äúfree list‚Äù data structure (freelist).  If in this implementation and at the moment the page contains less than 8 bytes, it does not fall into the freelist, because there will not be such a key-value pair that would fit in 8 bytes. <br><br>  After we figured out the data pages and estimated their number, we can estimate the number of <b>index pages</b> we need. <br><br>  Any Apache Ignite index is a B-tree.  This means that at the lower - the widest - level there are links to absolutely all key-value pairs.  The index starts with the root page.  On each of the internal pages there are links to the lower level. <br><br>  The index, which is the primary key, has an element size written to the index page of 12 bytes.  Depending on which page you are looking at, internal or sheet, you will have a different number of maximum elements.  If you take for such a numerical estimate, then you can see the number of maximum elements in the code.  For a primary index, the link size is always fixed and equal to 12 bytes.  To roughly calculate the maximum number of page elements, you can divide the page size (by default, 4 megabytes) into 12 bytes. <br><br>  Taking into account the growth of the tree, we can assume that each page will be filled from 50% to 75%, depending on the order of loading data.  Given that the bottom level of the tree contains all the elements, you can also estimate the number of pages needed to store the index. <br>  As for the SQL indexes - or secondary ones - here the size of the element stored in the page depends on the inline size configured.  You need to carefully analyze the data model to calculate the number of index pages. <br><br>  Many questions cause additional memory consumption per unit partition.  To start an empty cache, in which literally one element is written in each of the partitions, a substantial amount of memory is required.  The fact is that with such a structure, all the necessary metadata should be initialized for each partition. <br><br>  &lt;illustration&gt; <br><br>  The number of partitions defaults to 1024, so if you launch one node and start writing one element to each partition, then you immediately initialize a very large number of metastranits, which results in such a large initial memory overhead. <br><br>  With an empirical approach, you will load a sufficiently large amount of data, and the memory consumption of the partition becomes less noticeable.  But it should be considered for a more accurate assessment.  If you add up the memory overhead for a partition, on all data pages and index pages, you can calculate the required amount of memory with sufficient accuracy. <br><br><h2>  Optimization </h2><br>  How can you make life easier in the future?  Apache Ignite is moving toward SQL systems, and there are many ideas for reducing overhead. <br><br>  You can <b>change the binary format</b> to reduce the size of the header.  If you move to a more strictly typed data structure in any of the caches, but you will not be able to mix objects, but the amount of memory consumed will decrease. <br><br>  The second solution is to <b>group objects of the same type in the pages</b> and select the title or its part.  In this case, Apache Ignite will independently deduplicate data already at the page level. <br><br>  Another sensible idea: <b>implement a custom data capture threshold in freelist</b> .  If you understand that the pages will be fragmented in such a way that 100 bytes will remain in them, and your data will never be less than 100 bytes, then it makes sense to tweak the freelist so that the pages do not get there and do not consume space in this freelist. <br><br>  Actively discussed and performed by the system <b>data compression at the page level</b> , transparent to the user.  There are some technical difficulties, but in general you will sacrifice performance in favor of a more compact data placement. <br><br>  And the last, very demanded optimization - the <b>cluster capacity calculator</b> .  The big question is what will be the entrance to such a utility.  The following scheme appears: the user loads into the calculator the structure of objects, indicates how many lines he plans to load, and the calculator tells how much memory is needed taking into account all the indices and the Apache Ignite internal overhead. <br><br><h2>  Drive / Memory Proportions </h2><br><img src="https://habrastorage.org/webt/ws/6z/d5/ws6zd5vxha2jxrnm8heapzxfo9w.png"><br><br>  How much memory do we need to allocate, provided that the amount of stored data is larger than the amount of available memory?  If you run out of memory, Apache Ignite does the same thing as the OS: it throws out some data from the memory and loads the necessary ones.  Some data can not be thrown out, but for most cases it does not matter. <br><br>  Here it must be remembered that the appearance of the page itself does not imply recording.  Dropping data from memory is cheap.  And the subsequent reading of the data for which there was a miss from the disk is an expensive operation.  In most cases, the most important characteristic to pay attention to is how much IOPS your disk can produce.  If you are working with cloud deployment, then IOPS count is very easy. <br><br>  For example, starting and mounting an image in Amazon, you can choose among discs those that have a write speed in MB / sec.  But, in our experience, it's much better to know IOPS.  Since we operate with pages, then, in fact, IOPS is the maximum number of read or write operations that we can perform on disk per unit of time. <br><br>  How is the page chosen to be erased from memory?  Now this is done using the LRU random algorithm.  Apache Ignite keeps in memory a page that stores a display of that same page identifier at a specific physical address in memory where the data resides.  When we need to throw out some of the pages, we take n random pages from this table and select the oldest one.  It will not always be the oldest in the absolute sense.  But more often we will fall into one n-th part, where n is the number of samples we choose. <br><br>  Today, the LRU random algorithm is not resistant to full scanning, but we already have an implementation of the LRU 2 random algorithm, which is used in Apache Ignite for another task.  And when we use random LRU 2 to wipe out pages, the problem of resilience to full scanning will be solved. <br><br>  The preemption of pages significantly affects the delay in a single operation in the cache.  Worst situation: you had some little-used SQL index or region in the cache, and it turned out that absolutely all the pages in this region were pushed out to disk, that is, kicked out of memory.  If you refer to some key that will access all n pages, they will be sequentially read from disk.  And we need to minimize the amount of possible reading from the disk. <br><br>  Starting with Apache Ignite 2.3, it became possible to split caches into different data regions.  If you know that you have a subset of hot data, and you will surely work with them, and there is also a subset of data that is historical, then it makes sense to divide these subsets into different data regions. <br><br>  Also, to determine the disk / memory ratio, one should always watch not the median or average access time for a single operation in the cache, but the percentiles, because they are the most complete way to present information. <br><br>  In the worst case scenario, in one percent of cases the delay will be significantly higher, because pages have to be read from disk.  If you just look at the average, you will never notice this feature.  If strict SLAs are important to you, then you just need to analyze the percentiles when determining the proportion. <br><br>  Last thing to mention: do not run many Apache Ignite nodes with persistence enabled on the same physical media.  Since the disk is physically one, the number of IOPS is divided between Apache Ignite nodes.  Not only do you divide the bandwidth between nodes, in addition to this, each of the nodes can exhaust the capacity by IOPS, and the behavior of the entire cluster will become unpredictable. <br><br>  If for some reason you want to run several Apache Ignite nodes on the same machine, then be sure to ensure that the physical storages for the nodes are different.  This is in addition to recommending that Write-Ahead Log be carried to a separate physical medium. <br><br><h2>  CPU and network bandwidth planning </h2><br>  You should not use a network with a bandwidth of less than 1 gigabit.  Today, few people have networks with less bandwidth.  The choice of CPU is very dependent on the load profile, on the number of indices.  Here it is worth going back to the empirical approach and simply generate the load profile expected for your application and carefully monitor all system indicators.  If you see that some of the resources are completely exhausted, then it makes sense to add it. <br><br>  We welcome any questions or ideas for improving Apache Ignite. <br><br>  Join our meetings <a href="https://www.meetup.com/Moscow-Apache-Ignite-Meetup/">in Moscow</a> and <a href="https://www.meetup.com/St-Petersburg-Apache-Ignite-Meetup/">St. Petersburg</a> . <br><br><h3>  Other interesting videos on our channel: </h3><br><ul><li>  <a href="https://youtu.be/vKVVMzOL6uY">What's new in Apache Ignite 2.4</a> </li><li>  <a href="https://youtu.be/bHWSmZEQBG8">Scaling Apache Ignite Cluster for Architects</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/358546/">https://habr.com/ru/post/358546/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../358532/index.html">Open webinar: ‚ÄúTranslation difficulties: 2 and 3 versions‚Äù</a></li>
<li><a href="../358536/index.html">The Telegram v. Russia case will be considered by the European Court of Human Rights. Also sent a complaint to the Moscow City Court</a></li>
<li><a href="../358538/index.html">New orienteering: how to determine your location</a></li>
<li><a href="../358540/index.html">First Atlassian User Group in Minsk</a></li>
<li><a href="../358544/index.html">One day as a user support employee. What does it change?</a></li>
<li><a href="../358548/index.html">Create a fighting game in Unity: the implementation of Hitbox and Hurtbox</a></li>
<li><a href="../358550/index.html">Monitoring Elasticsearch without pain and suffering</a></li>
<li><a href="../358552/index.html">Best practices for designing productive mobile APIs</a></li>
<li><a href="../358554/index.html">Confrontation: results</a></li>
<li><a href="../358558/index.html">The whole program Backend Conf: from microservices to endless data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>