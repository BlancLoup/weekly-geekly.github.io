<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Memory allocation mechanisms in Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When I first tried to understand how Go memory allocators work, what I wanted to figure out seemed to me a mysterious black box. As is the case with a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Memory allocation mechanisms in Go</h1><div class="post__text post__text-html js-mediator-article">  When I first tried to understand how Go memory allocators work, what I wanted to figure out seemed to me a mysterious black box.  As is the case with any other technology, the most important thing here lies behind the many layers of abstractions, through which you need to sneak in order to understand something. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/442648/"><img src="https://habrastorage.org/webt/tv/0k/gh/tv0kghio2zhsc-og7bjd-mtl41q.jpeg"></a> <br><br>  The author of the material, the translation of which we publish, decided to get to the essence of the memory allocation tools in Go and tell about it. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Physical and virtual memory</font> </h2><br>  All means for memory allocation have to work with the address space of virtual memory, which is controlled by the operating system.  Let's take a look at how memory works, starting from the lowest level - from memory cells. <br>  Here's how you can imagine a cell of RAM. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e22/5e5/74c/e225e574c2649eb0bf9f5dd9cb1edadb.png"></div><br>  <i><font color="#999999">Memory cell diagram</font></i> <br><br>  If, very simply, to imagine a cell of RAM and what surrounds it, then we will have the following: <br><br><ol><li>  The address line (the transistor plays the role of a switch) is what gives access to the capacitor (data lines). </li><li>  When a signal appears in the address line (red line), the data line allows data to be written to the memory cell, that is, charging the capacitor, which makes it possible to store in it a logical value corresponding to 1. </li><li>  When there is no signal in the address line (green line), the capacitor is isolated and its charge does not change.  To write to cell 0, you must select its address and feed the logical 0 data line, that is, connect the data line to the minus, thereby discharging the capacitor. </li><li>  When the processor needs to read a value from memory, the signal is sent along the address line (the switch closes).  If the capacitor is charged, the signal goes through the data line (read 1), otherwise the signal does not go through the data line (read 0). </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/33a/100/e8d33a100b5dbf94d34e794785670f24.png"></div><br>  <i><font color="#999999">The scheme of interaction of physical memory and processor</font></i> <br><br>  The data bus is responsible for transporting data between the processor and the physical memory. <br><br>  Now let's talk about the address line and addressable bytes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/e38/542/d24e38542de230b449750b26641f5e8c.png"></div><br>  <i><font color="#999999">Address bus lines between the processor and physical memory</font></i> <br><br><ol><li>  Each byte in memory is assigned a unique numeric identifier (address).  It should be noted that the number of physical bytes in memory is not equal to the number of address lines. </li><li>  Each address line can specify a 1-bit value, so it points to one bit in the address of a certain byte. </li><li>  Our circuit has 32 address lines.  As a result, each addressable byte uses a 32-bit number as an address.  [00000000000000000000000000000000] - the lowest memory address.  [11111111111111111111111111111111] - the highest memory address. </li><li>  Since each byte has a 32-bit address, our address space consists of 2 <sup>32</sup> addressable bytes (4 GB). </li></ol><br>  As a result, it turns out that the number of addressable bytes depends on the total number of address lines.  For example, if you have 64 address lines (x86‚Äì64 processors), you can address 2 <sup>64</sup> bytes (16 exabytes) of memory, but most architectures that use 64-bit pointers actually use 48-bit address lines (AMD64) and 42-bit address lines (Intel), which, theoretically, allows computers to be equipped with 256 terabytes of physical memory (Linux allows, on x86‚Äì64 architecture, when using address pages of 4 levels, to allocate processes up to 128 TB of address space, Windows allows 192 TB). <br>  Since the size of the physical RAM is limited, each process runs in its own sandbox - in the so-called ‚Äúvirtual address space‚Äù, called virtual memory. <br><br>  The byte addresses in the virtual address space do not correspond to the addresses that the processor uses to access physical memory.  As a result, you need a system that allows you to convert virtual addresses into physical ones.  Take a look at how virtual memory addresses look like. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/09b/354/9d009b354ada519bf1280ea96e139e64.jpg"></div><br>  <i><font color="#999999">Representation of the virtual address space</font></i> <br><br>  As a result, when the processor executes an instruction that refers to a memory address, the first step is to convert the logical address to a linear address.  This conversion is performed by the memory management unit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/330/ba9/56a330ba9d27daeb5737e013c0c15156.png"></div><br>  <i><font color="#999999">Simplified representation of the relationship of virtual and physical memory</font></i> <br><br>  Since logical addresses are too large to make it convenient to work with them separately (depending on various factors), the memory is organized into structures called pages.  In this case, the virtual address space is divided into small areas, pages that are 4 KB in size in most OS, although this size can usually be changed.  This is the smallest unit of memory management in virtual memory.  Virtual memory does not store anything; it simply sets the correspondence between the address space of the program and the physical memory. <br><br>  Processes see only virtual memory addresses.  What happens if the program needs more dynamic memory (such memory is also called heap memory, or ‚Äúheap‚Äù)?  Here is an example of a simple assembler code in which additional dynamically allocated memory is requested from the system: <br><br><pre><code class="plaintext hljs">_start:        mov $12, %rax #    brk        mov $0, %rdi # 0 -  ,            syscall b0:        mov %rax, %rsi #  rsi    ,           mov %rax, %rdi #     ...        add $4, %rdi # ..  4 ,           mov $12, %rax #    brk        syscall</code> </pre> <br>  Here's how it can be represented as a diagram. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c22/962/904/c229629041c7612e254d89d146fcc4ef.png"></div><br>  <i><font color="#999999">Increase in dynamically allocated memory</font></i> <br><br>  The program requests additional memory using the <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/brk.2.html">brk</a> system call (sbrk / mmap and so on).  The kernel updates virtual memory information, but new pages are not yet represented in physical memory, and here there is a difference between virtual and physical memory. <br><br><h2>  <font color="#3AC1EF">Memory allocator</font> </h2><br>  After we, in general terms, discussed working with virtual address space, talked about how to perform the request for additional dynamic memory (memory in the heap), it will be easier for us to talk about the means for memory allocation. <br><br>  If there is enough memory in the heap to satisfy our code requests, then the memory allocator can execute these requests without referring to the kernel.  Otherwise, it has to increase the heap size using a system call (using brk, for example), while requesting a large block of memory.  In the case of malloc, ‚Äúlarge‚Äù means the size described by the <code>MMAP_THRESHOLD</code> parameter, which, by default, is 128 KB. <br><br>  However, a memory allocator has more responsibilities than a simple memory allocation.  One of his most important responsibilities is to reduce internal and external memory fragmentation, and to allocate memory blocks as quickly as possible.  Suppose that our program sequentially executes requests for allocating continuous memory blocks using a function of the <code>malloc(size)</code> , after which this memory is freed using the function of the <code>free(pointer)</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a0/779/9448a077982dfb81e4c982c1228cad15.png"></div><br>  <i><font color="#999999">Demonstration of External Fragmentation</font></i> <br><br>  In the previous scheme, in step p4, we do not have enough consecutive blocks of memory to fulfill the request for the allocation of six such blocks, although the total amount of free memory allows this.  This situation leads to memory fragmentation. <br><br>  How to reduce memory fragmentation?  The answer to this question depends on the specific memory allocation algorithm, on which basic library is used for working with memory. <br><br>  We will now look at the TCMalloc memory allocator, on which the Go memory allocation mechanisms are based. <br><br><h2>  <font color="#3AC1EF">TCMalloc</font> </h2><br>  At the heart of <a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">TCMalloc</a> is the idea of ‚Äã‚Äãsharing memory into several levels for the sake of reducing memory fragmentation.  Inside TCMalloc, memory management is divided into two parts: working with the memory of threads and working with a heap. <br><br><h3>  <font color="#3AC1EF">Memory threads</font> </h3><br>  Each page of memory is divided into a sequence of fragments of certain sizes, selected in accordance with the size classes.  This reduces fragmentation.  As a result, each stream has a cache for small objects, which makes it very efficient to allocate memory for objects whose size is less than or equal to 32 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/331/901/7c8/3319017c8657e4b75a25003357d4b4f4.png"></div><br>  <i><font color="#999999">Thread cache</font></i> <br><br><h3>  <font color="#3AC1EF">‚ñç Heap</font> </h3><br>  A TCMalloc managed heap is a collection of pages in which a set of consecutive pages can be represented as a range of pages (span).  When you need to allocate memory for an object whose size exceeds 32 KB, a heap is used to allocate memory. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/f49/707/48cf497071e18b1539c18e6c2057e85d.png"></div><br>  <i><font color="#999999">Heap and work with pages</font></i> <br><br>  When there is not enough space to accommodate small objects in memory, they turn to the heap for memory.  If there is not enough free memory on the heap, additional memory is requested from the operating system. <br><br>  As a result, the presented model of working with memory supports a user-space memory pool, its use significantly improves the efficiency of memory allocation and freeing. <br><br>  It should be noted that the Go memory allocator was originally based on TCMalloc, but it differs slightly from it. <br><br><h2>  <font color="#3AC1EF">Go Memory Allocator</font> </h2><br>  We know that the Go runtime schedules gorutin execution on logical processors.  Similarly, the version of TCMalloc used in Go divides memory pages into blocks whose dimensions correspond to certain size classes, which exist 67. <br><br>  If you are not familiar with the Go planner <a href="https://povilasv.me/go-scheduler/">,</a> you can read about it <a href="https://povilasv.me/go-scheduler/">here</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/824/d5c/0df/824d5c0dfac562629662650924292583.png"></div><br>  <i><font color="#999999">Go Classes</font></i> <br><br>  Since the minimum page size in Go is 8192 bytes (8 KB), if such a page is divided into blocks of 1 KB in size, we will get 8 such blocks. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/150/865/6ba/1508656ba4a4c009624468a164d41e5b.png"></div><br>  <i><font color="#999999">An 8 KB page is divided into blocks corresponding to a 1 KB size class.</font></i> <br><br>  Similar page sequences in Go are managed using a structure called mspan. <br><br><h3>  <font color="#3AC1EF">M mspan structure</font> </h3><br>  The mspan structure is a doubly linked list, an object that contains the starting address of the page, information about the page size and the number of pages included in it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbd/cae/fc0/dbdcaefc090a443369d33c2cde7e06ae.png"></div><br>  <i><font color="#999999">Mspan structure</font></i> <br><br><h3>  <font color="#3AC1EF">M mcache structure</font> </h3><br>  Like TCMalloc, Go provides each logical processor with a local cache for threads, known as mcache.  As a result, if a gorutin needs memory, she can get it directly from mcache.  To do this, you do not need to perform locks, since at any time only one gorutin is executed on one logical processor. <br><br>  The mcache structure contains, in the form of a cache, mspan structures of various size classes. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/7bb/459/4787bb4597d56f89b474189c5e86441b.png"></div><br>  <i><font color="#999999">The interaction between the logical processor, mcache and mspan in Go</font></i> <br><br>  Since each logical processor has its own mcache, there is no need for locks when allocating memory from mcache. <br><br>  Each size class can be represented by one of the following objects: <br><br><ul><li>  The scan object is the object that contains the pointer. </li><li>  The noscan object is an object with no pointer. </li></ul><br>  One of the strengths of this approach is that when garbage collection is performed, noscan objects need not be bypassed, since they do not contain objects for which memory is allocated. <br><br>  What gets into mcache?  Objects that do not exceed 32 KB in size fall directly into mcache using the appropriate size class mspan. <br><br>  What happens if there is no free cell in mcache?  Then get a new mspan of the desired size class from the mspan object list, which is called mcentral. <br><br><h3>  <font color="#3AC1EF">‚ñç mcentral structure</font> </h3><br>  The mcentral structure collects all page ranges of a particular size class.  Each mcentral object contains two lists of mspan objects. <br><br><ol><li>  A list of mspan objects that do not have free objects, or those mspan that are in mcache. </li><li>  List of mspan objects that have free objects. </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b88/7f9/6dcb887f9c717bb1f24735daa4b50aa7.png"></div><br>  <i><font color="#999999">Mcentral structure</font></i> <br><br>  Each mcentral structure exists within the mheap structure. <br><br><h3>  <font color="#3AC1EF">M mheap structure</font> </h3><br>  The mheap structure is represented by an object that handles the heap in Go.  There is only one such global object that owns the virtual address space. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/b07/01b/c8eb0701bbe46523e2735e695db97115.png"></div><br>  <i><font color="#999999">Mheap structure</font></i> <br><br>  As can be seen from the above diagram, the mheap structure contains an array of mcentral structures.  This array contains mcentral structures for all size classes. <br><br><pre> <code class="plaintext hljs">central [numSpanClasses]struct { mcentral mcentral   pad     [sys.CacheLineSize unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte }</code> </pre> <br>  Since we have a mcentral structure for each size class, when mcache requests the mspan structure from mcentral, blocking is applied at the mcentral individual level, as a result, requests from other mcache that request mspan structures of other sizes can be served simultaneously. <br><br>  The alignment (pad) allows you to ensure that the mcentral structures are separated from each other by the number of bytes corresponding to the <code>CacheLineSize</code> value.  As a result, each <code>mcentral.lock</code> has its own cache line, which avoids the problems associated with false memory sharing. <br><br>  What happens if the mcentral list is empty?  Then mcentral receives a sequence of pages from mheap to allocate fragments of memory of the required size class. <br><br><ul><li>  <code>free[_MaxMHeapList]mSpanList</code> is a spanList array.  The mspan structure in each spanList consists of 1 ~ 127 (_MaxMHeapList - 1) pages.  For example, free [3] is a linked list of mspan structures containing 3 pages.  The word "free" in this case indicates that we are talking about an empty list, in which the memory is not allocated.  A list may be, as opposed to an empty list, in which memory is allocated (busy). </li><li>  <code>freelarge mSpanList</code> is a list of free mspan structures.  The number of pages per element (i.e., mspan) is more than 127. To support such a list, the mtreap data structure is used.  The list of busy mspan structures is called busylarge. </li></ul><br>  Objects that are larger than 32 KB are considered large objects, and memory for them is allocated directly from mheap.  Requests for the allocation of memory for such objects are performed using a block, as a result, at a given point in time, a similar request from only one logical processor can be processed. <br><br><h2>  <font color="#3AC1EF">The process of allocating memory for objects</font> </h2><br><ul><li>  If the size of an object exceeds 32 KB, it is recognized as large, the memory for it is allocated directly from mheap. </li><li>  If the size of the object is less than 16 KB, the mcache mechanism is used, which is called tiny allocator. </li><li>  If the size of the object is in the range of 16-32 Kb, then it turns out which size class (sizeClass) should be used, then the appropriate block is allocated in mcache. </li><li>  If there are no blocks available in sizeClass corresponding to mcache, the call to mcentral is made. </li><li>  If mcentral has no free blocks, then mheap is accessed and a search is made for the most appropriate mspan.  If the memory size required by the application is larger than can be allocated, the requested memory size will be processed so that the program can return as many pages as necessary by creating a new mspan structure. </li><li>  If the virtual memory of the application is still not enough, the operating system is called for a new set of pages (at least 1 MB of memory is requested). </li></ul><br>  In fact, at the operating system level, Go requests the allocation of even larger chunks of memory, called arenas.  The one-time allocation of large pieces of memory allows you to find a compromise between the amount of memory allocated to the application and costly in terms of performance appeals to the operating system. <br><br>  The memory requested in the heap is allocated from the arena.  Consider this mechanism. <br><br><h2>  <font color="#3AC1EF">Virtual Memory Go</font> </h2><br>  Take a look at the memory usage of a simple program written in Go: <br><br><pre> <code class="plaintext hljs">func main() {   for {} }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/4cd/dee/c334cddee46f32a66d3528b08deda48e.png"></div><br>  <i><font color="#999999">Information about the process of the program</font></i> <br><br>  The virtual address space of even such a simple program is approximately 100 MB, while the RSS rate is only 696 KB.  To begin, let's try to find out the reason for this discrepancy. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/2a7/f41/f342a7f41d8ff7fbf3b5f081415c5ab4.png"></div><br>  <i><font color="#999999">Map and smap data</font></i> <br><br>  Here you can see the memory area, the size of which is approximately equal to 2 MB, 64 MB, 32 MB.  What is this memory? <br><br><h3>  <font color="#3AC1EF">‚ñç Arenas</font> </h3><br>  It turns out that virtual memory in Go consists of a set of arenas.  The original memory size intended for the heap corresponds to one arena, that is, 64 MB (this is relevant for Go 1.11.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/17e/ba9/9dd17eba9a4c5acf9371052d62d902d9.png"></div><br>  <i><font color="#999999">The current size of the arena in various systems</font></i> <br><br>  As a result, the memory required for the current needs of the program is allocated in small portions.  This process begins with a single 64 MB arena. <br><br>  Those numerical indicators, which we are talking about here, should not be taken for some absolute and constant values.  They can change.  Previously, for example, Go reserved a continuous virtual space in advance, on 64-bit systems the size of the arena was 512 GB (is it interesting to think about what will happen if the real need for memory is so large that the corresponding request is rejected by mmap?). <br><br>  In fact, a bunch of we call a set of arenas.  In Go, arenas are perceived as fragments of memory, divided into blocks of 8192 bytes (8 Kb). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/927/7e0/55b9277e0c55876b1bbf11bb1b869c9e.png"></div><br>  <i><font color="#999999">One 64 MB arena</font></i> <br><br>  In Go, there are a couple more varieties of blocks - span and bitmap.  Memory for them is allocated outside the heap, they store arena metadata.  They are mainly used in garbage collection. <br>  Here is a general scheme of the memory allocation mechanisms in Go. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/61f/13f/b0161f13f6bc905731f0bfb339fd3a10.png"></div><br>  <i><font color="#999999">General scheme of memory allocation mechanisms in Go</font></i> <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>  In general, it can be noted that in this material we described the Go memory subsystem in very general terms.  The main idea of ‚Äã‚Äãthe memory subsystem in Go is memory allocation using various structures and caches of different levels.  This takes into account the size of the objects for which the memory is allocated. <br><br>  Representation of a single block of continuous memory addresses received from the operating system in the form of a multi-level structure, increases the efficiency of the memory allocation mechanism due to the fact that this approach avoids locks.  The allocation of resources, taking into account the size of objects that need to be stored in memory, allows to reduce fragmentation, and, after the release of memory, allows you to speed up the collection of garbage. <br><br>  <b>Dear readers!</b>  Have you encountered problems caused by memory problems in programs written in Go? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/442648/">https://habr.com/ru/post/442648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../442636/index.html">Do you bring bad news to management?</a></li>
<li><a href="../442638/index.html">App-based Kubernetes metrics scaling from Prometheus</a></li>
<li><a href="../442640/index.html">Ideal bug: Using Type Confusion in Flash. Part 1</a></li>
<li><a href="../442642/index.html">What to read in March: 22 new books for marketers, managers, developers and designers</a></li>
<li><a href="../442644/index.html">Most developer value does not increase programming skills</a></li>
<li><a href="../442652/index.html">Using Fastify and Preact for rapid prototyping of web applications</a></li>
<li><a href="../442658/index.html">8 techniques for working with CSS: parallax, "sticky" footer and others</a></li>
<li><a href="../442660/index.html">Mathematics, reconciling Newton with the quantum world</a></li>
<li><a href="../442662/index.html">How to watch SDDL and not break your eyes on semicolons</a></li>
<li><a href="../442664/index.html">QIWI Kitchen February 6 - as it was + speaker reports</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>