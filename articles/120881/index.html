<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Creating a programming language using LLVM. Part 5: Language Expansion: Control Flow</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welcome to Chapter 5 of the tutorial, Creating a Programming Language with LLVM. The previous chapters ( 1st , 2nd, 3rd , and 4th ) described the impl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Creating a programming language using LLVM. Part 5: Language Expansion: Control Flow</h1><div class="post__text post__text-html js-mediator-article"> Welcome to Chapter 5 of the tutorial, Creating a Programming Language with LLVM.  The previous chapters ( <b><a href="http://habrahabr.ru/blogs/programming/119850/">1st</a></b> , <b><a href="http://habrahabr.ru/blogs/compilers/120005/">2nd, 3rd</a></b> , and <b><a href="http://habrahabr.ru/blogs/compilers/120516/">4th</a></b> ) described the implementation of a simple Kaleidoscope programming language and the inclusion of support for generating LLVM IR, as well as subsequent optimization and JIT compilation.  Unfortunately, the Kaleidoscope is almost useless in its current form: it has no control flow, with the exception of calls and returns.  This means that there can be no conditional jumps in the code, which significantly limits the programming language.  In this chapter, we extend the Kaleidoscope by adding the expression <code>if/then/else</code> and a simple <code>"for"</code> loop. <br><a name="habracut"></a><br><h1>  If / Then / Else </h1><br>  Extending Kaleidoscope to using <code>if/then/else</code> is a fairly simple task.  It is required to add support for this ‚Äúnew‚Äù concept to the lexical and syntactic analyzers, AST and code generator.  This is a good example because it shows how easy it is to ‚Äúbuild up‚Äù a language over time, gradually expanding it as new ideas appear. <br><br>  Before we add this extension, you need to talk about what we want to get in the end.  And we want to be able to write something like this: <br><br><blockquote><pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fib</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x &lt; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(x-<span class="hljs-number"><span class="hljs-number">1</span></span>)+fib(x-<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre></blockquote><br>  In Kaleidoscope, each construct is an expression.  Thus, an <code>if/then/else</code> expression, like any others, should return a value.  Since we mainly use the functional form, we must calculate the condition and then return the value of <code>"then"</code> or <code>"else"</code> depending on its value.  This is very similar to the C <code>"?:"</code> Expression. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The semantics of the <code>if/then/else</code> expression is that it evaluates the condition as a logical value: <code>0.0</code> is considered false, and everything else is true.  If the condition is true, the first subexpression is calculated and returned; if the condition is false, the second subexpression is calculated and returned.  Since Kaleidoscope allows for side effects, it is important to fix this behavior. <br><br>  Now that we know what we want, we will begin to sort things out in parts. <br><br><h5>  Refinement of the lexical analyzer to support If / Then / Else </h5><br>  Everything is simple here.  First, add new values ‚Äã‚Äãfor the corresponding tokens to the enumeration: <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  tok_if = -6, tok_then = -7, tok_else = -8,</span></span></code> </pre></blockquote><br>  Now we recognize new keywords in lexical analysis.  It's easy too: <br><br><blockquote><pre> <code class="cpp hljs"> ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"def"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"extern"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_extern;</code> </pre> <pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"if"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_if; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"then"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_then; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"else"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_else;</code> </pre> <pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_identifier;</code> </pre></blockquote><br><br><h5>  Refine AST to support If / Then / Else </h5><br>  To introduce a new kind of expression, add a new AST node: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// IfExprAST -     if/then/else. class IfExprAST : public ExprAST { ExprAST *Cond, *Then, *Else; public: IfExprAST(ExprAST *cond, ExprAST *then, ExprAST *_else) : Cond(cond), Then(then), Else(_else) {} virtual Value *Codegen(); };</span></span></code> </pre></blockquote><br>  The AST node has pointers to various subexpressions. <br><br><h5>  Refinement of the parser to support If / Then / Else </h5><br>  Now, when in lexical analysis we have the corresponding tokens and there is an AST node, the parsing logic will be very simple.  First, let's define a new parsing function: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// ifexpr ::= 'if' expression 'then' expression 'else' expression static ExprAST *ParseIfExpr() { getNextToken(); //  if. // . ExprAST *Cond = ParseExpression(); if (!Cond) return 0; if (CurTok != tok_then) return Error("expected then"); getNextToken(); //  then ExprAST *Then = ParseExpression(); if (Then == 0) return 0; if (CurTok != tok_else) return Error("expected else"); getNextToken(); ExprAST *Else = ParseExpression(); if (!Else) return 0; return new IfExprAST(Cond, Then, Else); }</span></span></code> </pre></blockquote><br>  Next, connect it as the primary expression: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> ExprAST *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ParsePrimary</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (CurTok) { <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Error(<span class="hljs-string"><span class="hljs-string">"unknown token when expecting an expression"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tok_identifier: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseIdentifierExpr(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tok_number: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseNumberExpr(); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'('</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseParenExpr();</code> </pre> <pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tok_if: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ParseIfExpr();</code> </pre> <pre> <code class="cpp hljs"> } }</code> </pre></blockquote><br><br><h5>  LLVM IR for If / Then / Else </h5><br>  Now that we have parsing and building an AST, the final part will be adding support for LLVM code generation.  This is the most interesting part in adding <code>if/then/else</code> , because here we will introduce new concepts.  Everything in the above code was described in detail in previous chapters. <br><br>  Let's look at a simple example: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <pre> <code class="ruby hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">baz</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> foo() <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> bar();</code> </pre></blockquote><br>  If you disable optimization, the code you receive (soon) from Kaleidoscope looks like this: <br><br><blockquote><pre> <code class="hljs perl">declare double @foo() declare double @bar() define double @baz(double %x) { entry: %ifcond = fcmp one double %x, <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">000000</span></span>e+<span class="hljs-number"><span class="hljs-number">00</span></span> br i1 %ifcond, label %then, label %else then: ; preds = %entry %calltmp = call double @foo() br label %ifcont <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: ; preds = %entry %calltmp1 = call double @bar() br label %ifcont ifcont: ; preds = %else, %then %iftmp = phi double [ %calltmp, %then ], [ %calltmp1, %else ] ret double %iftmp }</code> </pre></blockquote><br>  To visualize the flow control graph, you can use the excellent feature of the LLVM " <a href="http://llvm.org/cmds/opt.html">opt</a> " tool.  If you put this LLVM IR in "t.ll" and run <code>"llvm-as &lt; t.ll | opt -analyze -view-cfg"</code> , a <a href="http://llvm.org/docs/ProgrammersManual.html">window will appear</a> in which you will see this graph: <br><br><div style="text-align:center;"><img src="http://llvm.org/docs/tutorial/LangImpl5-cfg.png" alt="image"></div><br>  Another way to get it is to call <code>"F-&gt;viewCFG()"</code> or <code>"F-&gt;viewCFGOnly()"</code> (where <code>F</code> is <code>"Function*"</code> ) by actually including the call in the code and recompiling or calling in the debugger.  LLVM has many useful features for visualizing various graphs. <br><br>  Returning to the generated code, it is quite simple: the input block calculates a conditional expression (in our case <code>"x"</code> ) and compares the result with <code>0.0</code> using the instruction <code><a href="http://llvm.org/docs/LangRef.html"></a> "fcmp one"</code>  <code><a href="http://llvm.org/docs/LangRef.html"></a> "fcmp one"</code> .  Based on the result of this expression, the code goes into either the <code>"then"</code> block or the <code>"else"</code> block, which contain expressions for true / false cases. <br><br>  As soon as the <code>then/else</code> blocks are completed, both of these branches go to the <code>"ifcont"</code> block to execute code that is located after <code>if/then/else</code> .  In this case, the only thing left to do is to return to the calling function.  Then the question arises: how do you know the code of the expression to return? <br><br>  The answer to this question includes an important operation SSA: operation <code><a href="http://en.wikipedia.org/wiki/Static_single_assignment_form"></a> Phi</code>  <code><a href="http://en.wikipedia.org/wiki/Static_single_assignment_form"></a> Phi</code> .  If you are not familiar with SSA, then the <a href="http://ru.wikipedia.org/wiki/SSA">Wikipedia</a> <a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">article</a> will be a good introduction, as well as there are other introductory articles about it that are easily found by your favorite search engine.  The short version: the ‚Äúexecution‚Äù of the <code>Phi</code> operation requires the ‚Äúmemorization‚Äù of the block from which we came.  The operation <code>Phi</code> takes values ‚Äã‚Äãand the corresponding input control units.  In this case, if the control comes from the <code>"then"</code> block, it gets the value <code>"calltmp"</code> .  If control comes from an <code>"else"</code> block, it gets the value <code>"calltmp1"</code> . <br><br>  Now you are probably starting to think, ‚ÄúOh, no!  This means that my simple and elegant front end will have to start generating the SSA form in order to use LLVM! ‚Äù  Fortunately, this is not the case, and we strongly advise <i>NOT to</i> implement the SSA algorithm in your front end, unless there is a truly important reason for this.  In practice, there are two kinds of values ‚Äã‚Äãin code written for the average imperative programming language that might require Phi nodes: <ol><li>  Code providing custom variables: <code> = 1;  =  + 1;</code> <code> = 1;  =  + 1;</code> </li><li>  Values ‚Äã‚Äãthat are implied in the structure of your AST, such as the Phi node in this case. </li></ol>  In Chapter 7 of this tutorial (‚Äúmutable variables‚Äù), we will talk about # 1.  In the meantime, just trust me that you do not need to build SSA to cope with this case.  For # 2, you have a choice: use the methods we describe for # 1, or you can directly insert Phi nodes if it is convenient for you.  In this case, it's really very easy to generate Phi nodes, so we decided to do just that. <br><br>  Okay, time to generate the code! <br><br><h5>  If / Then / Else Code Generation </h5><br>  For code generation, we implement the <code>IfExprAST</code> method for <code>IfExprAST</code> : <br><br><blockquote><pre> <code class="cpp hljs">Value *IfExprAST::Codegen() { Value *CondV = Cond-&gt;Codegen(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (CondV == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       0.0. CondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(getGlobalContext(), APFloat(0.0)), "ifcond");</span></span></code> </pre></blockquote><br>  This code is simple and similar to what we saw before.  We get an expression for the condition, and then compare this value with zero to get its truth as a 1-bit (bool) value. <br><br><blockquote><pre> <code class="cpp hljs"> Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); <span class="hljs-comment"><span class="hljs-comment">//     then  else.   'then'  //  . BasicBlock *ThenBB = BasicBlock::Create(getGlobalContext(), "then", TheFunction); BasicBlock *ElseBB = BasicBlock::Create(getGlobalContext(), "else"); BasicBlock *MergeBB = BasicBlock::Create(getGlobalContext(), "ifcont"); Builder.CreateCondBr(CondV, ThenBB, ElseBB);</span></span></code> </pre></blockquote><br>  This code creates base blocks that are related to <code>if/then/else</code> and correspond to the blocks in the example above.  The first line gets the current <code>Function</code> object (the function being formed).  She gets it by asking <code>Builder</code> about the current base unit and getting its ‚Äúparent‚Äù (current function). <br><br>  Then he creates three blocks.  Notice that it passes <code>"TheFunction"</code> to the constructor of the <code>"then"</code> block.  This causes the constructor to automatically insert a new block at the end of the specified function.  Two other blocks are also created, but not yet inserted into the function. <br><br>  After creating the blocks, we can generate a conditional transition that chooses between them.  Note that the implicit creation of new blocks does not affect the <code>IRBuilder</code> in <code>IRBuilder</code> , so the insertion still occurs in the same block in which we are included.  Also note that it creates a branch for the <code>"then"</code> block and the <code>"else"</code> block, although the <code>"else"</code> block has not yet been inserted into the function.  But everything is in order: this is the standard way to support LLVM links "forward". <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//  . Builder.SetInsertPoint(ThenBB); Value *ThenV = Then-&gt;Codegen(); if (ThenV == 0) return 0; Builder.CreateBr(MergeBB); // Codegen of 'Then'    ,  ThenBB  PHI. ThenBB = Builder.GetInsertBlock();</span></span></code> </pre></blockquote><br>  After inserting a conditional transition, we tell Builder to begin inserting into the <code>"then"</code> block.  Strictly speaking, this call moves the cursor to the end of the specified block.  However, since the <code>"then"</code> block is empty, it also begins our insertion at the beginning of the block.  :) <br><br>  Once the cursor is set, we recursively call the code generation of the <code>"then"</code> expression from the AST.  To complete the block <code>"then"</code> , we create an unconditional transition to the block merging branches.  One of the interesting (and very important) aspects of LLVM IR is that it <a href="http://llvm.org/docs/LangRef.html">requires all the basic blocks to ‚Äúcomplete‚Äù</a> <a href="http://llvm.org/docs/LangRef.html">with a control flow statement</a> , such as a return or branch.  This means that the entire control flow, including the transfer of control to another code ( <a href="http://www.diclib.com/cgi-bin/d1.cgi%3Fl%3Dru%26st%3D3%26page%3Dshowid%26start%3D0%26base%3Den_foldoc%26id%3D4531%26letter%3DF"><i>fall throughs</i></a> ), must be <i>explicitly</i> present in the LLVM IR.  If this rule is violated, the verifier will return an error. <br><br>  The last line is important here.  When creating the <code>Phi</code> node in the merge block of the branches, we must specify the block / value pairs that indicate how <code>Phi</code> will work.  It is important to note that the <code>Phi</code> node expects to get an input point for each block predecessor in the CFG.  Why, then, do we get the current block when we just set it in <code>ThenBB</code> five lines higher?  The problem is that the expression <code>"then"</code> may in fact itself change the block that Builder generates, for example, if it contains nested expressions <code>"if/then/else"</code> .  Since the recursive call of <code>Codegen</code> can arbitrarily change the current block, we need to get the current actual values ‚Äã‚Äãfor the code to be created in the <code>Phi</code> node. <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   else. TheFunction-&gt;getBasicBlockList().push_back(ElseBB); Builder.SetInsertPoint(ElseBB); Value *ElseV = Else-&gt;Codegen(); if (ElseV == 0) return 0; Builder.CreateBr(MergeBB); //  'Else'    ,  ElseBB  PHI. ElseBB = Builder.GetInsertBlock();</span></span></code> </pre></blockquote><br>  Code generation for the <code>"else"</code> block is almost identical to code generation for the <code>"then"</code> block.  The only significant difference in the first line is that it adds an <code>"else"</code> block to the function.  Recall that earlier the <code>"else"</code> block was created, but not added to the function.  Now that the <code>"then"</code> and <code>"else"</code> blocks have been generated, we can end up with the merge code: <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   . TheFunction-&gt;getBasicBlockList().push_back(MergeBB); Builder.SetInsertPoint(MergeBB); PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(getGlobalContext()), 2, "iftmp"); PN-&gt;addIncoming(ThenV, ThenBB); PN-&gt;addIncoming(ElseV, ElseBB); return PN; }</span></span></code> </pre></blockquote><br>  The first two lines are already familiar to you: the first one adds the <code>"merge"</code> block for the function object.  The second block moves the insertion point so that the newly created code will be inserted into the <code>"merge"</code> block.  Then we need to create a <code>PHI</code> node and set the block / value pairs for the <code>PHI</code> . <br><br>  Finally, the <code>CodeGen</code> function returns the <code>Phi</code> node as the value calculated for the <code>if/then/else</code> expression.  In our example above, this return value will be passed to the top level function code, which will create a return instruction. <br><br>  In general, we now have the ability to execute conditional code in Kaleidoscope.  With this extension, Kaleidoscope is a fairly comprehensive programming language that can calculate a wide range of numeric functions.  Now we will add another useful expression that is familiar to us from non-functional programming languages ‚Äã‚Äã... <br><br><h1>  'For' loop </h1><br>  Now that we know how to add basic control constructs to a language, we have a tool for adding more powerful things.  Let's try to add something more aggressive - the expression <code>"for"</code> : <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">putchard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span></code> </pre> <pre> <code class="ruby hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printstar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>, i &lt; n, <span class="hljs-number"><span class="hljs-number">1.0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> putchard(<span class="hljs-number"><span class="hljs-number">42</span></span>); <span class="hljs-comment"><span class="hljs-comment"># ascii 42 = '*' #  100  '*' printstar(100);</span></span></code> </pre></blockquote><br>  This expression defines a new variable (in this case, <code>"i"</code> ), which is iterated from the initial value until the condition (in this case, <code>"i &lt; n"</code> ) becomes true, increasing by the step value (in this case, <code>"1.0"</code> ).  If the step value is omitted, then by default it is equal to <code>1.0</code> .  The loop executes its body expression.  Since we have nothing better to return, we will simply define the cycle as always returning <code>0.0</code> .  Later, when we add mutable variables, it will be more useful. <br><br>  As in the previous case, consider the changes that we need Kaleidoscope in to support the cycles, in parts. <br><br><h5>  Refinement of the lexical analyzer to support the 'for' cycle </h5><br>  The lexical analyzer is supplemented in the same way as in the case of <code>if/then/else</code> : <br><br><blockquote><pre> <code class="cpp hljs"> ...   Token ... <span class="hljs-comment"><span class="hljs-comment">//  tok_if = -6, tok_then = -7, tok_else = -8,</span></span></code> </pre> <pre> <code class="cpp hljs"> tok_for = <span class="hljs-number"><span class="hljs-number">-9</span></span>, tok_in = <span class="hljs-number"><span class="hljs-number">-10</span></span></code> </pre> <pre> <code class="cpp hljs">... in gettok ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"def"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_def; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"extern"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_extern; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"if"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_if; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"then"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_then; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"else"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_else;</code> </pre> <pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"for"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_for; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IdentifierStr == <span class="hljs-string"><span class="hljs-string">"in"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_in;</code> </pre> <pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tok_identifier;</code> </pre></blockquote><br><br><h5>  AST revision to support the 'for' loop </h5><br>  The AST node is also simple.  It stores in its nodes the name of the variable and the expression of the loop body. <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// ForExprAST -     for/in. class ForExprAST : public ExprAST { std::string VarName; ExprAST *Start, *End, *Step, *Body; public: ForExprAST(const std::string &amp;varname, ExprAST *start, ExprAST *end, ExprAST *step, ExprAST *body) : VarName(varname), Start(start), End(end), Step(step), Body(body) {} virtual Value *Codegen(); };</span></span></code> </pre></blockquote><br><br><h5>  Revision of the parser to support the 'for' loop </h5><br>  Changes in the parser code are also fairly standard.  The only interesting point here is the handling of the optional step value.  The parser processes it by checking if the second comma is present.  If not, it sets the step value to <code>null</code> in the AST node: <br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static ExprAST *ParseForExpr() { getNextToken(); //  for. if (CurTok != tok_identifier) return Error("expected identifier after for"); std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '=') return Error("expected '=' after for"); getNextToken(); //  '='. ExprAST *Start = ParseExpression(); if (Start == 0) return 0; if (CurTok != ',') return Error("expected ',' after for start value"); getNextToken(); ExprAST *End = ParseExpression(); if (End == 0) return 0; //   . ExprAST *Step = 0; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (Step == 0) return 0; } if (CurTok != tok_in) return Error("expected 'in' after for"); getNextToken(); //  'in'. ExprAST *Body = ParseExpression(); if (Body == 0) return 0; return new ForExprAST(IdName, Start, End, Step, Body); }</span></span></code> </pre></blockquote><br><br><h5>  LLVM IR for the 'for' loop </h5><br>  Now we come to the interesting part: let's start the generation of LLVM IR.  For our example above, we get the following LLVM IR (note that this dump is generated for clarity with optimization turned off): <br><br><blockquote><pre> <code class="cpp hljs">declare <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @putchard(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>) define <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @printstar(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %n) { entry: ; initial value = <span class="hljs-number"><span class="hljs-number">1.0</span></span> (inlined into phi) br label %loop loop: ; preds = %loop, %entry %i = phi <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> [ <span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span>, %entry ], [ %nextvar, %loop ] ;  %calltmp = call <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> @putchard(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-number"><span class="hljs-number">4.200000e+01</span></span>) ;  %nextvar = fadd <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %i, <span class="hljs-number"><span class="hljs-number">1.000000e+00</span></span> ;  %cmptmp = fcmp ult <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %i, %n %booltmp = uitofp i1 %cmptmp to <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %loopcond = fcmp one <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> %booltmp, <span class="hljs-number"><span class="hljs-number">0.000000e+00</span></span> br i1 %loopcond, label %loop, label %afterloop afterloop: ; preds = %loop ; loop always returns <span class="hljs-number"><span class="hljs-number">0.0</span></span> ret <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> <span class="hljs-number"><span class="hljs-number">0.000000e+00</span></span> }</code> </pre></blockquote><br>  This loop contains all the same constructs that we saw before: the <code>phi</code> node, several expressions, and some basic blocks.  Let's see how it fits together. <br><br><h5>  Code Generation for a 'for' Loop </h5><br>  The first part of <code>Codegen</code> very simple: we just get the expression for the initial value of the loop: <br><br><blockquote><pre> <code class="cpp hljs">Value *ForExprAST::Codegen() { <span class="hljs-comment"><span class="hljs-comment">// Emit the start code first, without 'variable' in scope. Value *StartVal = Start-&gt;Codegen(); if (StartVal == 0) return 0;</span></span></code> </pre></blockquote><br>  The next step is to create the base block LLVM to start the loop body.  In the above case, the whole body of the loop is one block, but remember that the body code itself may consist of several blocks (for example, if it contains <code>if/then/else</code> or <code>for/in</code> expressions). <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//       ,    //  . Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); BasicBlock *PreheaderBB = Builder.GetInsertBlock(); BasicBlock *LoopBB = BasicBlock::Create(getGlobalContext(), "loop", TheFunction); //        LoopBB. Builder.CreateBr(LoopBB);</span></span></code> </pre></blockquote><br>  This code is similar to the one we saw for <code>if/then/else</code> .  We remember the block from which we got into the loop, since we will need it to create the node <code>Phi</code> .  Then we create the actual block that starts the loop, and create an unconditional transition between the two blocks. <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//    LoopBB. Builder.SetInsertPoint(LoopBB); //   PHI    Start. PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(getGlobalContext()), 2, VarName.c_str()); Variable-&gt;addIncoming(StartVal, PreheaderBB);</span></span></code> </pre></blockquote><br>  Now that the <code>"preheader"</code> header for the loop is set, we proceed to generate the loop body code.  First, we move the cursor and create a <code>PHI</code> node for the loop variable.  Since we already know the initial value, we add it to the <code>Phi</code> node.  Please note that <code>Phi</code> will eventually get the second value, but we cannot yet install it (because it does not exist yet!). <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//       PHI.    //  ,     ,  . Value *OldVal = NamedValues[VarName]; NamedValues[VarName] = Variable; //   . ,      ,   //   .  ,    , //  ,     . if (Body-&gt;Codegen() == 0) return 0;</span></span></code> </pre></blockquote><br>  Now the code becomes more interesting.  Our <code>"for"</code> loop introduces a new variable into the symbol table.  This means that our symbol table can contain either function arguments or loop variables.  Before we generate the loop body code, we add the loop variable as the current value for its name.  Please note - it is possible that there is already a variable with the same name in the outer scope.  You can easily make this an error (return an error and return <code>null</code> if there is already an entry for VarName), but we will allow the overlapping of variables.  For proper processing, we memorize the potentially overlapping value in <code>OldVal</code> (which will be <code>null</code> if there is no overlapping variable). <br><br>  After setting the loop variable in the symbol table, code is recursively generated in the body.  This allows the body to use a loop variable: any references to it are naturally found in the symbol table. <br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   . Value *StepVal; if (Step) { StepVal = Step-&gt;Codegen(); if (StepVal == 0) return 0; } else { //   ,  1.0. StepVal = ConstantFP::get(getGlobalContext(), APFloat(1.0)); } Value *NextVar = Builder.CreateFAdd(Variable, StepVal, "nextvar");</span></span></code> </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When the body is generated, we calculate the next value of the iteration variable by adding the step value or </font></font><code>1.0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, if it is not specified. </font></font><code>"NextVar"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">will be the value of the loop variable in the next loop step.</font></font><br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//      . Value *EndCond = End-&gt;Codegen(); if (EndCond == 0) return EndCond; //       0.0. EndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(getGlobalContext(), APFloat(0.0)), "loopcond");</span></span></code> </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, we calculate the loop out value to determine if the loop should be completed. </font><font style="vertical-align: inherit;">This is almost the same as the condition calculation in </font></font><code>if/then/else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   " "   . BasicBlock *LoopEndBB = Builder.GetInsertBlock(); BasicBlock *AfterBB = BasicBlock::Create(getGlobalContext(), "afterloop", TheFunction); //      LoopEndBB. Builder.CreateCondBr(EndCond, LoopBB, AfterBB); //       AfterBB. Builder.SetInsertPoint(AfterBB);</span></span></code> </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With the complete loop body code, we only need to complete the control flow for it. </font><font style="vertical-align: inherit;">This code remembers the end of a block (for a node </font></font><code>phi</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">), and then creates a block to exit the loop ( </font></font><code>"afterloop"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font><font style="vertical-align: inherit;">Based on the value of the exit condition, it creates a conditional transition that chooses between executing the loop again or exiting the loop. </font><font style="vertical-align: inherit;">Any subsequent code is added to the block </font></font><code>"afterloop"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so we move the insertion point exactly there.</font></font><br><br><blockquote><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//      PHI. Variable-&gt;addIncoming(NextVar, LoopEndBB); //   . if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); //  for   0.0. return Constant::getNullValue(Type::getDoubleTy(getGlobalContext())); }</span></span></code> </pre></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The final code does the cleanup: we now have a value </font></font><code>"NextVar"</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and we can add the loop's PHI value to the node. </font><font style="vertical-align: inherit;">After that, we delete the loop variable from the symbol table, so it is not in scope after the loop. </font><font style="vertical-align: inherit;">Finally, the code generated for the loop always returns </font></font><code>0.0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, so we return from </font></font><code>ForExprAST::Codegen</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This concludes the tutorial chapter "Adding a control flow to Kaleidoscope". </font><font style="vertical-align: inherit;">In this chapter, we looked at a couple of aspects of LLVM IR that are important for front-end developers to know. </font><font style="vertical-align: inherit;">In the next chapter of our saga, we will be a little crazier and add user-defined operators for our poor innocent programming language.</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Full code listing </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here is the full code listing, extended expressions </font></font><code>if/then/else</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>for</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... Going as follows:</font></font><br><br><blockquote> <code>#  <br> g++ -g toy.cpp `llvm-config --cppflags --ldflags --libs core jit native` -O3 -o toy <br> #  <br> ./toy <br></code> </blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And the code itself: </font></font><br><br><blockquote><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/DerivedTypes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ExecutionEngine/ExecutionEngine.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/ExecutionEngine/JIT.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/LLVMContext.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Module.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/PassManager.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Analysis/Verifier.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Analysis/Passes.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Target/TargetData.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Target/TargetSelect.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Transforms/Scalar.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"llvm/Support/IRBuilder.h"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;cstdio&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;vector&gt; using namespace llvm; //===----------------------------------------------------------------------===// // Lexer ( ) //===----------------------------------------------------------------------===// //     [0-255],   , //       enum Token { tok_eof = -1, //  ( ) tok_def = -2, tok_extern = -3, //  ( : , ) tok_identifier = -4, tok_number = -5, //   tok_if = -6, tok_then = -7, tok_else = -8, tok_for = -9, tok_in = -10 }; static std::string IdentifierStr; // ,  tok_identifier static double NumVal; // ,  tok_number /// gettok -       . static int gettok() { static int LastChar = ' '; //  . while (isspace(LastChar)) LastChar = getchar(); if (isdigit(LastChar) || LastChar == '.') { // : [0-9.]+ IdentifierStr = LastChar; while (isalnum((LastChar = getchar()))) IdentifierStr += LastChar; if (IdentifierStr == "def") return tok_def; if (IdentifierStr == "extern") return tok_extern; if (IdentifierStr == "if") return tok_if; if (IdentifierStr == "then") return tok_then; if (IdentifierStr == "else") return tok_else; if (IdentifierStr == "for") return tok_for; if (IdentifierStr == "in") return tok_in; return tok_identifier; } if (isdigit(LastChar) || LastChar == '.') { // Number: [0-9.]+ std::string NumStr; do { NumStr += LastChar; LastChar = getchar(); } while (isdigit(LastChar) || LastChar == '.'); NumVal = strtod(NumStr.c_str(), 0); return tok_number; } if (LastChar == '#') { //     do LastChar = getchar(); while (LastChar != EOF &amp;&amp; LastChar != '\n' &amp;&amp; LastChar != '\r'); if (LastChar != EOF) return gettok(); } //   . if (LastChar == EOF) return tok_eof; //         ASCII int ThisChar = LastChar; LastChar = getchar(); return ThisChar; } //===----------------------------------------------------------------------===// // Abstract Syntax Tree (     ) //===----------------------------------------------------------------------===// /// ExprAST -      . class ExprAST { public: virtual ~ExprAST() {} virtual Value *Codegen() = 0; }; /// NumberExprAST -       (, "1.0"). class NumberExprAST : public ExprAST { double Val; public: NumberExprAST(double val) : Val(val) {} virtual Value *Codegen(); }; /// VariableExprAST -      (, "a"). class VariableExprAST : public ExprAST { std::string Name; public: VariableExprAST(const std::string &amp;name) : Name(name) {} virtual Value *Codegen(); }; /// BinaryExprAST -      . class BinaryExprAST : public ExprAST { char Op; ExprAST *LHS, *RHS; public: BinaryExprAST(char op, ExprAST *lhs, ExprAST *rhs) : Op(op), LHS(lhs), RHS(rhs) {} virtual Value *Codegen(); }; /// CallExprAST -      . class CallExprAST : public ExprAST { std::string Callee; std::vector&lt;ExprAST*&gt; Args; public: CallExprAST(const std::string &amp;callee, std::vector&lt;ExprAST*&gt; &amp;args) : Callee(callee), Args(args) {} virtual Value *Codegen(); }; /// IfExprAST -     if/then/else. class IfExprAST : public ExprAST { ExprAST *Cond, *Then, *Else; public: IfExprAST(ExprAST *cond, ExprAST *then, ExprAST *_else) : Cond(cond), Then(then), Else(_else) {} virtual Value *Codegen(); }; /// ForExprAST -     for/in. class ForExprAST : public ExprAST { std::string VarName; ExprAST *Start, *End, *Step, *Body; public: ForExprAST(const std::string &amp;varname, ExprAST *start, ExprAST *end, ExprAST *step, ExprAST *body) : VarName(varname), Start(start), End(end), Step(step), Body(body) {} virtual Value *Codegen(); }; /// PrototypeAST -    ""  , ///        (,  , ///    ). class PrototypeAST { std::string Name; std::vector&lt;std::string&gt; Args; public: PrototypeAST(const std::string &amp;name, const std::vector&lt;std::string&gt; &amp;args) : Name(name), Args(args) {} Function *Codegen(); }; /// FunctionAST -     class FunctionAST { PrototypeAST *Proto; ExprAST *Body; public: FunctionAST(PrototypeAST *proto, ExprAST *body) : Proto(proto), Body(body) {} Function *Codegen(); }; //===----------------------------------------------------------------------===// // Parser (   ) //===----------------------------------------------------------------------===// /// CurTok/getNextToken -    . CurTok -   /// ,  . getNextToken     ///     CurTok. static int CurTok; static int getNextToken() { return CurTok = gettok(); } /// BinopPrecedence -      static std::map&lt;char, int&gt; BinopPrecedence; /// GetTokPrecedence -     . static int GetTokPrecedence() { if (!isascii(CurTok)) return -1; // ,     . int TokPrec = BinopPrecedence[CurTok]; if (TokPrec &lt;= 0) return -1; return TokPrec; } /// Error* -       . ExprAST *Error(const char *Str) { fprintf(stderr, "Error: %s\n", Str);return 0;} PrototypeAST *ErrorP(const char *Str) { Error(Str); return 0; } FunctionAST *ErrorF(const char *Str) { Error(Str); return 0; } static ExprAST *ParseExpression(); /// identifierexpr /// ::= identifier /// ::= identifier '(' expression* ')' static ExprAST *ParseIdentifierExpr() { std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '(') //  . return new VariableExprAST(IdName); //  . getNextToken(); //  ( std::vector&lt;ExprAST*&gt; Args; if (CurTok != ')') { while (1) { ExprAST *Arg = ParseExpression(); if (!Arg) return 0; Args.push_back(Arg); if (CurTok == ')') break; if (CurTok != ',') return Error("Expected ')' or ',' in argument list"); getNextToken(); } } //  ')'. getNextToken(); return new CallExprAST(IdName, Args); } /// numberexpr ::= number static ExprAST *ParseNumberExpr() { ExprAST *Result = new NumberExprAST(NumVal); getNextToken(); //   return Result; } /// parenexpr ::= '(' expression ')' static ExprAST *ParseParenExpr() { getNextToken(); //  (. ExprAST *V = ParseExpression(); if (!V) return 0; if (CurTok != ')') return Error("expected ')'"); getNextToken(); //  ). return V; } /// ifexpr ::= 'if' expression 'then' expression 'else' expression static ExprAST *ParseIfExpr() { getNextToken(); //  if. // . ExprAST *Cond = ParseExpression(); if (!Cond) return 0; if (CurTok != tok_then) return Error("expected then"); getNextToken(); //  then ExprAST *Then = ParseExpression(); if (Then == 0) return 0; if (CurTok != tok_else) return Error("expected else"); getNextToken(); ExprAST *Else = ParseExpression(); if (!Else) return 0; return new IfExprAST(Cond, Then, Else); } /// forexpr ::= 'for' identifier '=' expr ',' expr (',' expr)? 'in' expression static ExprAST *ParseForExpr() { getNextToken(); //  for. if (CurTok != tok_identifier) return Error("expected identifier after for"); std::string IdName = IdentifierStr; getNextToken(); //  . if (CurTok != '=') return Error("expected '=' after for"); getNextToken(); //  '='. ExprAST *Start = ParseExpression(); if (Start == 0) return 0; if (CurTok != ',') return Error("expected ',' after for start value"); getNextToken(); ExprAST *End = ParseExpression(); if (End == 0) return 0; //   . ExprAST *Step = 0; if (CurTok == ',') { getNextToken(); Step = ParseExpression(); if (Step == 0) return 0; } if (CurTok != tok_in) return Error("expected 'in' after for"); getNextToken(); //  'in'. ExprAST *Body = ParseExpression(); if (Body == 0) return 0; return new ForExprAST(IdName, Start, End, Step, Body); } /// primary /// ::= identifierexpr /// ::= numberexpr /// ::= parenexpr /// ::= ifexpr /// ::= forexpr static ExprAST *ParsePrimary() { switch (CurTok) { default: return Error("unknown token when expecting an expression"); case tok_identifier: return ParseIdentifierExpr(); case tok_number: return ParseNumberExpr(); case '(': return ParseParenExpr(); case tok_if: return ParseIfExpr(); case tok_for: return ParseForExpr(); } } /// binoprhs /// ::= ('+' primary)* static ExprAST *ParseBinOpRHS(int ExprPrec, ExprAST *LHS) { //    ,    while (1) { int TokPrec = GetTokPrecedence(); //           , //  ,    if (TokPrec &lt; ExprPrec) return LHS; // ,  ,    . int BinOp = CurTok; getNextToken(); //    //       ExprAST *RHS = ParsePrimary(); if (!RHS) return 0; //  BinOp   RHS  ,    RHS, //      RHS  LHS. int NextPrec = GetTokPrecedence(); if (TokPrec &lt; NextPrec) { RHS = ParseBinOpRHS(TokPrec+1, RHS); if (RHS == 0) return 0; } //  LHS/RHS. LHS = new BinaryExprAST(BinOp, LHS, RHS); } } /// expression /// ::= primary binoprhs /// static ExprAST *ParseExpression() { ExprAST *LHS = ParsePrimary(); if (!LHS) return 0; return ParseBinOpRHS(0, LHS); } /// prototype /// ::= id '(' id* ')' static PrototypeAST *ParsePrototype() { if (CurTok != tok_identifier) return ErrorP("Expected function name in prototype"); //    . std::string FnName = IdentifierStr; getNextToken(); if (CurTok != '(') return ErrorP("Expected '(' in prototype"); std::vector&lt;std::string&gt; ArgNames; while (getNextToken() == tok_identifier) ArgNames.push_back(IdentifierStr); if (CurTok != ')') return ErrorP("Expected ')' in prototype"); //  . getNextToken(); //  ')'. return new PrototypeAST(FnName, ArgNames); } /// definition ::= 'def' prototype expression static FunctionAST *ParseDefinition() { getNextToken(); //  def. PrototypeAST *Proto = ParsePrototype(); if (Proto == 0) return 0; if (ExprAST *E = ParseExpression()) return new FunctionAST(Proto, E); return 0; } /// toplevelexpr ::= expression static FunctionAST *ParseTopLevelExpr() { if (ExprAST *E = ParseExpression()) { //   . PrototypeAST *Proto = new PrototypeAST("", std::vector&lt;std::string&gt;()); return new FunctionAST(Proto, E); } return 0; } /// external ::= 'extern' prototype static PrototypeAST *ParseExtern() { getNextToken(); //  extern. return ParsePrototype(); } //===----------------------------------------------------------------------===// // Code Generation () //===----------------------------------------------------------------------===// static Module *TheModule; static IRBuilder&lt;&gt; Builder(getGlobalContext()); static std::map&lt;std::string, Value*&gt; NamedValues; static FunctionPassManager *TheFPM; Value *ErrorV(const char *Str) { Error(Str); return 0; } Value *NumberExprAST::Codegen() { return ConstantFP::get(getGlobalContext(), APFloat(Val)); } Value *VariableExprAST::Codegen() { //      . Value *V = NamedValues[Name]; return V ? V : ErrorV("Unknown variable name"); } Value *BinaryExprAST::Codegen() { Value *L = LHS-&gt;Codegen(); Value *R = RHS-&gt;Codegen(); if (L == 0 || R == 0) return 0; switch (Op) { case '+': return Builder.CreateFAdd(L, R, "addtmp"); case '-': return Builder.CreateFSub(L, R, "subtmp"); case '*': return Builder.CreateFMul(L, R, "multmp"); case '&lt;': L = Builder.CreateFCmpULT(L, R, "cmptmp"); //   0  1   0.0  1.0 return Builder.CreateUIToFP(L, Type::getDoubleTy(getGlobalContext()), "booltmp"); default: return ErrorV("invalid binary operator"); } } Value *CallExprAST::Codegen() { //      . Function *CalleeF = TheModule-&gt;getFunction(Callee); if (CalleeF == 0) return ErrorV("Unknown function referenced"); //    . if (CalleeF-&gt;arg_size() != Args.size()) return ErrorV("Incorrect # arguments passed"); std::vector&lt;Value*&gt; ArgsV; for (unsigned i = 0, e = Args.size(); i != e; ++i) { ArgsV.push_back(Args[i]-&gt;Codegen()); if (ArgsV.back() == 0) return 0; } return Builder.CreateCall(CalleeF, ArgsV.begin(), ArgsV.end(), "calltmp"); } Value *IfExprAST::Codegen() { Value *CondV = Cond-&gt;Codegen(); if (CondV == 0) return 0; //       0.0. CondV = Builder.CreateFCmpONE(CondV, ConstantFP::get(getGlobalContext(), APFloat(0.0)), "ifcond"); Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); //     then  else.   'then'  //  . BasicBlock *ThenBB = BasicBlock::Create(getGlobalContext(), "then", TheFunction); BasicBlock *ElseBB = BasicBlock::Create(getGlobalContext(), "else"); BasicBlock *MergeBB = BasicBlock::Create(getGlobalContext(), "ifcont"); Builder.CreateCondBr(CondV, ThenBB, ElseBB); //  . Builder.SetInsertPoint(ThenBB); Value *ThenV = Then-&gt;Codegen(); if (ThenV == 0) return 0; Builder.CreateBr(MergeBB); //  'Then'    ,  ThenBB  PHI. ThenBB = Builder.GetInsertBlock(); //   else. TheFunction-&gt;getBasicBlockList().push_back(ElseBB); Builder.SetInsertPoint(ElseBB); Value *ElseV = Else-&gt;Codegen(); if (ElseV == 0) return 0; Builder.CreateBr(MergeBB); //  'Else'    ,  ElseBB  PHI. ElseBB = Builder.GetInsertBlock(); //   . TheFunction-&gt;getBasicBlockList().push_back(MergeBB); Builder.SetInsertPoint(MergeBB); PHINode *PN = Builder.CreatePHI(Type::getDoubleTy(getGlobalContext()), 2, "iftmp"); PN-&gt;addIncoming(ThenV, ThenBB); PN-&gt;addIncoming(ElseV, ElseBB); return PN; } Value *ForExprAST::Codegen() { // Output this as: // ... // start = startexpr // goto loop // loop: // variable = phi [start, loopheader], [nextvariable, loopend] // ... // bodyexpr // ... // loopend: // step = stepexpr // nextvariable = variable + step // endcond = endexpr // br endcond, loop, endloop // outloop: // Emit the start code first, without 'variable' in scope. Value *StartVal = Start-&gt;Codegen(); if (StartVal == 0) return 0; //       ,    //  . Function *TheFunction = Builder.GetInsertBlock()-&gt;getParent(); BasicBlock *PreheaderBB = Builder.GetInsertBlock(); BasicBlock *LoopBB = BasicBlock::Create(getGlobalContext(), "loop", TheFunction); //         LoopBB. Builder.CreateBr(LoopBB); //    LoopBB. Builder.SetInsertPoint(LoopBB); //   PHI    Start. PHINode *Variable = Builder.CreatePHI(Type::getDoubleTy(getGlobalContext()), 2, VarName.c_str()); Variable-&gt;addIncoming(StartVal, PreheaderBB); //       PHI.    //  ,     ,  . Value *OldVal = NamedValues[VarName]; NamedValues[VarName] = Variable; //   . ,      ,   //   .  ,    , //  ,     . if (Body-&gt;Codegen() == 0) return 0; //   . Value *StepVal; if (Step) { StepVal = Step-&gt;Codegen(); if (StepVal == 0) return 0; } else { //   ,  1.0. StepVal = ConstantFP::get(getGlobalContext(), APFloat(1.0)); } Value *NextVar = Builder.CreateFAdd(Variable, StepVal, "nextvar"); //      . Value *EndCond = End-&gt;Codegen(); if (EndCond == 0) return EndCond; //       0.0. EndCond = Builder.CreateFCmpONE(EndCond, ConstantFP::get(getGlobalContext(), APFloat(0.0)), "loopcond"); //   " "   . BasicBlock *LoopEndBB = Builder.GetInsertBlock(); BasicBlock *AfterBB = BasicBlock::Create(getGlobalContext(), "afterloop", TheFunction); //      LoopEndBB. Builder.CreateCondBr(EndCond, LoopBB, AfterBB); //       AfterBB. Builder.SetInsertPoint(AfterBB); //      PHI. Variable-&gt;addIncoming(NextVar, LoopEndBB); //   . if (OldVal) NamedValues[VarName] = OldVal; else NamedValues.erase(VarName); //  for   0.0. return Constant::getNullValue(Type::getDoubleTy(getGlobalContext())); } Function *PrototypeAST::Codegen() { //   : double(double,double)  .. std::vector&lt;const Type*&gt; Doubles(Args.size(), Type::getDoubleTy(getGlobalContext())); FunctionType *FT = FunctionType::get(Type::getDoubleTy(getGlobalContext()), Doubles, false); Function *F = Function::Create(FT, Function::ExternalLinkage, Name, TheModule); //   (F)     ,     'Name'. //     ,      . if (F-&gt;getName() != Name) { //   ,      . F-&gt;eraseFromParent(); F = TheModule-&gt;getFunction(Name); //   (F)   , . if (!F-&gt;empty()) { ErrorF("redefinition of function"); return 0; } //   (F)    , . if (F-&gt;arg_size() != Args.size()) { ErrorF("redefinition of function with different # args"); return 0; } } //     . unsigned Idx = 0; for (Function::arg_iterator AI = F-&gt;arg_begin(); Idx != Args.size(); ++AI, ++Idx) { AI-&gt;setName(Args[Idx]); //      . NamedValues[Args[Idx]] = AI; } return F; } Function *FunctionAST::Codegen() { NamedValues.clear(); Function *TheFunction = Proto-&gt;Codegen(); if (TheFunction == 0) return 0; //      . BasicBlock *BB = BasicBlock::Create(getGlobalContext(), "entry", TheFunction); Builder.SetInsertPoint(BB); if (Value *RetVal = Body-&gt;Codegen()) { //  . Builder.CreateRet(RetVal); //   ,    (). verifyFunction(*TheFunction); //  . TheFPM-&gt;run(*TheFunction); return TheFunction; } //  ,   . TheFunction-&gt;eraseFromParent(); return 0; } //===----------------------------------------------------------------------===// // Top-Level parsing (  )   JIT //===----------------------------------------------------------------------===// static ExecutionEngine *TheExecutionEngine; static void HandleDefinition() { if (FunctionAST *F = ParseDefinition()) { if (Function *LF = F-&gt;Codegen()) { fprintf(stderr, "Read function definition:"); LF-&gt;dump(); } } else { //      . getNextToken(); } } static void HandleExtern() { if (PrototypeAST *P = ParseExtern()) { if (Function *F = P-&gt;Codegen()) { fprintf(stderr, "Read extern: "); F-&gt;dump(); } } else { //      . getNextToken(); } } static void HandleTopLevelExpression() { //      . if (FunctionAST *F = ParseTopLevelExpr()) { if (Function *LF = F-&gt;Codegen()) { // JIT-,   . void *FPtr = TheExecutionEngine-&gt;getPointerToFunction(LF); //     ( ,  double), //       . double (*FP)() = (double (*)())(intptr_t)FPtr; fprintf(stderr, "Evaluated to %f\n", FP()); } } else { //      . getNextToken(); } } /// top ::= definition | external | expression | ';' static void MainLoop() { while (1) { fprintf(stderr, "ready&gt; "); switch (CurTok) { case tok_eof: return; case ';': getNextToken(); break; //     . case tok_def: HandleDefinition(); break; case tok_extern: HandleExtern(); break; default: HandleTopLevelExpression(); break; } } } //===----------------------------------------------------------------------===// // "" ,     //   ("extern")   . //===----------------------------------------------------------------------===// /// putchard -        0. extern "C" double putchard(double X) { putchar((char)X); return 0; } //===----------------------------------------------------------------------===// // Main driver code (  ) //===----------------------------------------------------------------------===// int main() { InitializeNativeTarget(); LLVMContext &amp;Context = getGlobalContext(); //    . // 1 -  . BinopPrecedence['&lt;'] = 10; BinopPrecedence['+'] = 20; BinopPrecedence['-'] = 20; BinopPrecedence['*'] = 40; //  . // Prime the first token. fprintf(stderr, "ready&gt; "); getNextToken(); //  ,     . TheModule = new Module("my cool jit", Context); //  JIT.     . std::string ErrStr; TheExecutionEngine = EngineBuilder(TheModule).setErrorStr(&amp;ErrStr).create(); if (!TheExecutionEngine) { fprintf(stderr, "Could not create ExecutionEngine: %s\n", ErrStr.c_str()); exit(1); } FunctionPassManager OurFPM(TheModule); //   .     ,  //       . OurFPM.add(new TargetData(*TheExecutionEngine-&gt;getTargetData())); //   AliasAnalysis  GVN. OurFPM.add(createBasicAliasAnalysisPass()); //   "peephole"  "bit-twiddling". OurFPM.add(createInstructionCombiningPass()); //  . OurFPM.add(createReassociatePass()); //   . OurFPM.add(createGVNPass()); //     (    ..). OurFPM.add(createCFGSimplificationPass()); OurFPM.doInitialization(); //   ,     . TheFPM = &amp;OurFPM; //    " ". MainLoop(); TheFPM = 0; //   . TheModule-&gt;dump(); return 0; }</span></span></span></span></code> </pre></blockquote></div><p>Source: <a href="https://habr.com/ru/post/120881/">https://habr.com/ru/post/120881/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../120872/index.html">Base GeoIP - countries and cities, June 2011 (+ update script)</a></li>
<li><a href="../120874/index.html">IPv6 day</a></li>
<li><a href="../120876/index.html">Passing a password over an open channel (part 2)</a></li>
<li><a href="../120877/index.html">Hyperkin Releases SupaBoy Portable SNES Console</a></li>
<li><a href="../120878/index.html">Lightcycle demo using WebGL (part 0)</a></li>
<li><a href="../120882/index.html">Yandex finances "Zenmoney"</a></li>
<li><a href="../120883/index.html">Overview of Twitter clients for iPhone</a></li>
<li><a href="../120884/index.html">Cactus Obfuscator obfuscator javascript / css</a></li>
<li><a href="../120885/index.html">Sony PSN: Welcome Back</a></li>
<li><a href="../120886/index.html">Who is the "concert organizer"?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>