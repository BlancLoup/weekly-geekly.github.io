<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Parsing WKB format without third-party libraries</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of working on one task in the Mail.Ru Map project, it became necessary to read the WKB format. Of course, you could use GDAL , but you ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Parsing WKB format without third-party libraries</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/storage2/1d2/ddd/79b/1d2ddd79b912f902060706cee1ea0f83.png" align="left">  In the process of working on one task in the <a href="http://maps.mail.ru/">Mail.Ru Map</a> project, it became necessary to read the <a href="http://en.wikipedia.org/wiki/Well-known_text">WKB</a> format.  Of course, you could use <a href="http://en.wikipedia.org/wiki/GDAL">GDAL</a> , but you only needed reading, and all other features were superfluous.  And so this small bicycle was born. <br>  I want to immediately warn you that the functionality is implemented only within the required framework and only basic types are supported, such as: <ul><li>  point </li><li>  line </li><li>  polygon </li><li>  multiline </li><li>  multipolygon </li></ul><br>  Recoding of the byte order in a word is not supported.  And so - take it and use it. <br><a name="habracut"></a><br><br>  For convenience, a vrapper class representing a memory region as an STL-like container is also useful;  there's nothing to even comment on.  It can be taken <a href="https://github.com/darkserj/container">from here</a> .  And additional simplest classes for geometric primitives: points and rectangles. <br><div class="spoiler">  <b class="spoiler_title">Class code</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ml { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point_d</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> y; }; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp;s, point_d <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;p) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s &lt;&lt; px &lt;&lt; <span class="hljs-string"><span class="hljs-string">", "</span></span> &lt;&lt; py; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(point_d </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;p1, point_d </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;p2)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dx = (p1.x-p2.x); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> dy = (p1.y-p2.y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sqrt</span></span>(dx*dx+dy*dy); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">rect_d</span></span></span><span class="hljs-class"> {</span></span> point_d min; point_d max; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> rect_d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void_rect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rect_d(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;T&gt;::max(),<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;T&gt;::max(), -<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;T&gt;::max(),-<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt;T&gt;::max()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">this</span></span> == rect_d::void_rect() || (width()==<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; height()==<span class="hljs-number"><span class="hljs-number">0</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">height</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(max.y-min.y); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">double</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">width</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">fabs</span></span>(max.x-min.x); } <span class="hljs-function"><span class="hljs-function">rect_d &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rect_d &amp;r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(r.empty()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; min.x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(min.x,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(r.min.x,r.max.x)); min.y = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(min.y,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(r.min.y,r.max.y)); max.x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(max.x,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(r.min.x,r.max.x)); max.y = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(max.y,<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(r.min.y,r.max.y)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> C &gt; <span class="hljs-function"><span class="hljs-function">rect_d &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( C begin, C end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(; begin != end; ++begin) { min.x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(min.x,begin-&gt;x); min.y = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::min(min.y,begin-&gt;y); max.x = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(max.x,begin-&gt;x); max.y = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::max(max.y,begin-&gt;y); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } }; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> &lt;&lt; (<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::ostream &amp;s,<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rect_d &amp;r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s &lt;&lt; <span class="hljs-string"><span class="hljs-string">'['</span></span> &lt;&lt; r.min &lt;&lt; <span class="hljs-string"><span class="hljs-string">','</span></span> &lt;&lt; r.max &lt;&lt; <span class="hljs-string"><span class="hljs-string">']'</span></span>; } } <span class="hljs-comment"><span class="hljs-comment">// namespace ml</span></span></code> </pre> <br></div></div><br><br>  To use the class, you must first load the data in WKB format into memory.  How this will be done, let it be left to the discretion of who will use it. <br>  It was supposed to use the written class approximately as follows: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *data = .... ml::wkb shape(data); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; ml::wkb::type_to_text(shape.type()) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; shape.bounds() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>;</code> </pre><br>  The first version turned out to be a solution to the forehead, and it looked like this: <br><div class="spoiler">  <b class="spoiler_title">First version</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> ml { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wkb</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> * m_data; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> type_e{ wkb_point = <span class="hljs-number"><span class="hljs-number">1</span></span>, wkb_line_string = <span class="hljs-number"><span class="hljs-number">2</span></span>, wkb_polygon = <span class="hljs-number"><span class="hljs-number">3</span></span>, wkb_multi_point = <span class="hljs-number"><span class="hljs-number">4</span></span>, wkb_multi_line_string = <span class="hljs-number"><span class="hljs-number">5</span></span>, wkb_multi_polygon = <span class="hljs-number"><span class="hljs-number">6</span></span>, wkb_geometry_collection = <span class="hljs-number"><span class="hljs-number">7</span></span> }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type_to_text</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(type_e type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_point: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"wkb_point"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_line_string: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"wkb_line_string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_polygon: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"wkb_polygon"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_point: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"wkb_multi_point"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_line_string: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"wkb_multi_line_string"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_polygon: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"wkb_multi_polygon"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_geometry_collection: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"wkb_geometry_collection"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"unknown"</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> container&lt;ml::point_d&gt; line; wkb(<span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> *data) : m_data(data) {} wkb &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (wkb <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;d) { m_data = d.m_data; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">byte_order</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_data[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> type_e </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (type_e)*(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;m_data[<span class="hljs-number"><span class="hljs-number">1</span></span>]; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">size</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;m_data[<span class="hljs-number"><span class="hljs-number">5</span></span>]; } <span class="hljs-function"><span class="hljs-function">line </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linestring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line((line::value_type*)&amp;m_data[<span class="hljs-number"><span class="hljs-number">9</span></span>], size()); } ml::<span class="hljs-function"><span class="hljs-function">point_d </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(ml::point_d*)&amp;m_data[<span class="hljs-number"><span class="hljs-number">5</span></span>]; } <span class="hljs-function"><span class="hljs-function">wkb </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linestring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;size(); ++i) { <span class="hljs-function"><span class="hljs-function">wkb </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">l</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;m_data[offset])</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i == index) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l; offset += <span class="hljs-number"><span class="hljs-number">9</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span> * l.size(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wkb(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-function">line </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;size(); ++i) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> point_count = *(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)&amp;m_data[offset]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == index) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line((line::value_type*)&amp;m_data[offset+<span class="hljs-number"><span class="hljs-number">4</span></span>], point_count); offset = offset + <span class="hljs-number"><span class="hljs-number">4</span></span> + <span class="hljs-number"><span class="hljs-number">16</span></span>*point_count; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>,(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>)<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-function">wkb </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">polygon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> offset = <span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;size(); ++i) { <span class="hljs-function"><span class="hljs-function">wkb </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">o</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(&amp;m_data[offset])</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i == index) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> o; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> j=<span class="hljs-number"><span class="hljs-number">0</span></span>; j&lt;o.size(); ++j) offset += o.ring(j).size() * <span class="hljs-number"><span class="hljs-number">16</span></span> + <span class="hljs-number"><span class="hljs-number">4</span></span>; offset += <span class="hljs-number"><span class="hljs-number">9</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wkb(<span class="hljs-number"><span class="hljs-number">0</span></span>); } ml::<span class="hljs-function"><span class="hljs-function">rect_d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ ml::<span class="hljs-function"><span class="hljs-function">rect_d </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ml::rect_d::void_rect())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_polygon: { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size(); ++i) { line l = ring(i); r.bounds(l.begin(),l.end()); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_polygon: { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size(); ++i) { r.extend(polygon(i).bounds()); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_point: { r.min.x = r.max.x = *(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>*)&amp;m_data[<span class="hljs-number"><span class="hljs-number">5</span></span>]; r.min.y = r.max.y = *(<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>*)&amp;m_data[<span class="hljs-number"><span class="hljs-number">13</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_line_string: { line l = linestring(); r.bounds(l.begin(),l.end()); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_line_string: { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size(); ++i) { r.extend(linestring(i).bounds()); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } }; } <span class="hljs-comment"><span class="hljs-comment">// namespace ml</span></span></code> </pre><br></div></div><br>  In principle, everything worked and gave correct results, but (where without this ‚Äúbut‚Äù) when we had to process several million objects, the time spent on processing did not suit us. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a result of the profiling, it became clear why a lot of time was spent on calculating the necessary part of the WKB.  Many intermediate objects were created on the stack and there was a small but recursion available.  Scratching the back of the head, we decided to refine the code somewhat and get rid of unnecessary recursion, and indeed of unnecessary actions.  To begin with, we added the code to calculate the end of the current element and get the beginning of the next element: <pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_of_ring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr + <span class="hljs-number"><span class="hljs-number">4</span></span> + (*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(ptr) * <span class="hljs-number"><span class="hljs-number">16</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">char</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end_of_polygon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *ptr)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sz = *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)((ptr+=<span class="hljs-number"><span class="hljs-number">9</span></span>)<span class="hljs-number"><span class="hljs-number">-4</span></span>);sz--;) ptr += (*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(ptr) * <span class="hljs-number"><span class="hljs-number">16</span></span>) + <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ptr; }</code> </pre><br>  After that, the methods for obtaining elements were rewritten, they became simpler and more obvious: <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-function">line </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linestring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line((line::value_type*)(m_data+<span class="hljs-number"><span class="hljs-number">9</span></span>), size()); } ml::<span class="hljs-function"><span class="hljs-function">point_d </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">point</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *(ml::point_d*)(m_data+<span class="hljs-number"><span class="hljs-number">5</span></span>); } <span class="hljs-function"><span class="hljs-function">wkb </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">linestring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(index&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; index&lt;m_size); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = m_data+<span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (index--) { ptr += <span class="hljs-number"><span class="hljs-number">9</span></span> + (*(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)(ptr+<span class="hljs-number"><span class="hljs-number">5</span></span>) * <span class="hljs-number"><span class="hljs-number">16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wkb(ptr); } <span class="hljs-function"><span class="hljs-function">wkb </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">polygon</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(index&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; index&lt;m_size); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = m_data+<span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (index--) { ptr = end_of_polygon(ptr); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wkb(ptr); } <span class="hljs-function"><span class="hljs-function">line </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ring</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ assert(index&gt;=<span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; index&lt;m_size); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *ptr = m_data+<span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (index--) { ptr = end_of_ring(ptr); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> line((line::value_type*)(ptr+<span class="hljs-number"><span class="hljs-number">4</span></span>),(line::value_type*)end_of_ring(ptr)); }</code> </pre></div></div><br>  This has already increased productivity.  But given the specifics of processing points, it was possible to further improve the architecture and convenience by adding the following method: <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">apply</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T &amp; func)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_polygon: { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr = m_data+<span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;m_size; ++i) { ml::point_d *begin = (ml::point_d*)(ptr+<span class="hljs-number"><span class="hljs-number">4</span></span>); ml::point_d *end = begin + *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(ptr); ptr = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)end; func(begin,end); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_polygon: { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr = m_data+<span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;m_size; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> sz = *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>*)((ptr+=<span class="hljs-number"><span class="hljs-number">9</span></span>)<span class="hljs-number"><span class="hljs-number">-4</span></span>);sz--;) { ml::point_d *begin = (ml::point_d*)(ptr+<span class="hljs-number"><span class="hljs-number">4</span></span>); ml::point_d *end = begin + *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(ptr); ptr = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)end; func(begin,end); } } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_point: { ml::point_d *begin = (ml::point_d*)(m_data+<span class="hljs-number"><span class="hljs-number">5</span></span>); ml::point_d *end = begin + <span class="hljs-number"><span class="hljs-number">1</span></span>; func(begin,end); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_line_string: { ml::point_d *begin = (ml::point_d*)(m_data+<span class="hljs-number"><span class="hljs-number">9</span></span>); ml::point_d *end = begin + size(); func(begin,end); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_line_string: { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * ptr = m_data+<span class="hljs-number"><span class="hljs-number">9</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;m_size; ++i) { ml::point_d *begin = (ml::point_d*)(ptr+<span class="hljs-number"><span class="hljs-number">9</span></span>); ml::point_d *end = begin + *(<span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *)(ptr+<span class="hljs-number"><span class="hljs-number">5</span></span>); ptr = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *)end; func(begin,end); } } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> func; }</code> </pre></div></div><br>  we add a functor to compute a descriptive rectangle like this: <pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bounds_counter</span></span></span><span class="hljs-class"> {</span></span> ml::rect_d r; bounds_counter() : r(ml::rect_d::void_rect()) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ml::point_d </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *begin, ml::point_d </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *end)</span></span></span><span class="hljs-function"> </span></span>{ r.bounds(begin,end); } ml::<span class="hljs-function"><span class="hljs-function">rect_d </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } };</code> </pre><br>  bounds method after rewriting began to look like this: <pre> <code class="cpp hljs">ml::rect_d ml::wkb::bounds() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bounds_counter</span></span></span><span class="hljs-class"> {</span></span> ml::rect_d r; bounds_counter() : r(ml::rect_d::void_rect()) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ml::point_d </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *begin, ml::point_d </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *end)</span></span></span><span class="hljs-function"> </span></span>{ r.bounds(begin,end); } ml::<span class="hljs-function"><span class="hljs-function">rect_d </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; } }; bounds_counter b; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> apply(b).bounds(); }</code> </pre><br>  This option will not work for g ++, it follows standards more strictly: <blockquote>  14.3.1 / 2: for a type of parameter. <br></blockquote>  but it is fully functional in clang and, judging by the search on the Internet, in MSVC ++ (honestly, we did not check).  <i>For universality and correctness, the definition of a functor should be placed in an unnamed namespace.</i> <br><br>  After all the improvements, the task execution time has decreased about four times.  Also, when using this approach, it was convenient to write output of objects in JSON format: <div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ml::wkb::to_geo_json() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">point_formatter</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> &amp;ss; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> counter; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> parts; point_formatter(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> &amp;s) : ss(s),counter(<span class="hljs-number"><span class="hljs-number">0</span></span>), parts(<span class="hljs-literal"><span class="hljs-literal">false</span></span>) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ml::point_d </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *begin, ml::point_d </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *end)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parts) ss &lt;&lt; (counter ? <span class="hljs-string"><span class="hljs-string">",["</span></span> : <span class="hljs-string"><span class="hljs-string">"["</span></span>); ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"["</span></span> &lt;&lt; begin-&gt;x &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; begin-&gt;y &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(++begin;begin != end;++begin){ ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">",["</span></span> &lt;&lt; begin-&gt;x &lt;&lt; <span class="hljs-string"><span class="hljs-string">","</span></span> &lt;&lt; begin-&gt;y &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (parts) ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; ++counter; } <span class="hljs-function"><span class="hljs-function">point_formatter &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_parts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> p)</span></span></span><span class="hljs-function"> </span></span>{parts = p; counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;} }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">stringstream</span></span> ss; <span class="hljs-function"><span class="hljs-function">point_formatter </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ss)</span></span></span></span>; ss &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::fixed &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::showpoint &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::setprecision(<span class="hljs-number"><span class="hljs-number">6</span></span>); ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"{"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(type()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_point: { ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"type\":\"Point\",\"coordinates\":"</span></span>; apply(fmt); } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_line_string: { ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"type\":\"LineString\",\"coordinates\": ["</span></span>; apply(fmt); ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_line_string: { ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"type\":\"MultiLineString\",\"coordinates\": ["</span></span>; apply(fmt.make_parts(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_polygon: { ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"type\":\"Polygon\",\"coordinates\": ["</span></span>; apply(fmt.make_parts(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> wkb_multi_polygon: { ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\"type\":\"MultiPolygon\",\"coordinates\": ["</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; size(); ++i) { ss &lt;&lt; (i ? <span class="hljs-string"><span class="hljs-string">",["</span></span> : <span class="hljs-string"><span class="hljs-string">"["</span></span>); polygon(i).apply(fmt.make_parts(<span class="hljs-literal"><span class="hljs-literal">true</span></span>)); ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; } ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"]"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } ss &lt;&lt; <span class="hljs-string"><span class="hljs-string">"}"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ss.str(); }</code> </pre></div></div><br>  The result was a fairly convenient class for working with data presented in WKB format.  It became convenient to add new operations on objects.  Reached decent performance. <br><br>  All the code in the article can be found <a href="https://github.com/darkserj/wkb_wrapper">here</a> and <a href="https://github.com/darkserj/container">here</a> . <br><br>  <i>Ershov Sergey,</i> <i><br></i>  <i>programmer project <a href="http://maps.mail.ru/">Maps@Mail.Ru</a></i> <i><br></i> </div><p>Source: <a href="https://habr.com/ru/post/167517/">https://habr.com/ru/post/167517/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../167507/index.html">Automatic calculation of column width</a></li>
<li><a href="../167509/index.html">Making a simple game with buttons, drawers and doors on Unity</a></li>
<li><a href="../16751/index.html">Korotkostvol</a></li>
<li><a href="../167511/index.html">The first award in the new year and new applications</a></li>
<li><a href="../167515/index.html">Install Redmine 2.2.2 + Passenger on FreeBSD 9.1</a></li>
<li><a href="../167519/index.html">Hero H9500 + (OEM Zopo zp900) - a large smartphone at a low price</a></li>
<li><a href="../16752/index.html">Advertising</a></li>
<li><a href="../167521/index.html">Study of the App Annie of the Japanese application market: it's hard to break through, but you can't ignore</a></li>
<li><a href="../167523/index.html">Thermonuclear energy: the hope of mankind?</a></li>
<li><a href="../167525/index.html">Thoughts on layout with JavaScript positioning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>