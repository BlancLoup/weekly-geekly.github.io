<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>About the usefulness of indexes by expressions</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the PostgreSQL training sessions, both in advanced and basic courses, I often come across the fact that learners know almost nothing about how powe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>About the usefulness of indexes by expressions</h1><div class="post__text post__text-html js-mediator-article">  In the PostgreSQL training sessions, both in advanced and basic courses, I often come across the fact that learners know almost nothing about how powerful expressions indexes can be (if they are generally aware of their existence).  So let me do a little review for you. <br><a name="habracut"></a><br>  Suppose we have a table with a range of timestamps (yes, we have a generate_series function that can generate dates): <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> d, <span class="hljs-keyword"><span class="hljs-keyword">repeat</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">md5</span></span>(d::<span class="hljs-built_in"><span class="hljs-built_in">text</span></span>), <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> padding <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-string"><span class="hljs-string">'1900-01-01'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">timestamp</span></span> <span class="hljs-string"><span class="hljs-string">'2100-01-01'</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 day'</span></span>) s(d); VACUUM <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> t;</code> </pre> <br>  The table also contains a padding column so that it is a bit larger.  Now, let's perform a simple range query, returning only one month from the approximately 200 years that are in the table.  If you execute this query with explain, you get something like this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> d <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> <span class="hljs-string"><span class="hljs-string">'2001-01-01'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-string"><span class="hljs-string">'2001-02-01'</span></span>; QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------ Seq Scan on t (cost=0.00..4416.75 rows=32 width=332) Filter: ((d &gt;= '2001-01-01 00:00:00'::timestamp without time zone) AND (d &lt;= '2001-02-01 00:00:00'::timestamp without time zone)) (2 rows)</span></span></code> </pre><br>  and on my computer, the request is about 20 milliseconds.  Not bad, considering the fact that he needs to go through the entire table consisting of 75 thousand rows. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      But let's create an index on a column with a timestamp (all indexes in this text are basic, that is, btree, if not explicitly specified): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> idx_t_d <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t (d);</code> </pre><br>  And now let's try the query again: <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------ Index Scan using idx_t_d on t (cost=0.29..9.97 rows=34 width=332) Index Cond: ((d &gt;= '2001-01-01 00:00:00'::timestamp without time zone) AND (d &lt;= '2001-02-01 00:00:00'::timestamp without time zone)) (2 rows)</span></span></code> </pre><br>  Now it runs in 0.5 milliseconds, which is roughly 40 times faster.  But it was, of course, a simple index created directly on the column, not an index by expression.  So let's assume that instead of the last request, we will request data for each first day of each month, performing the following request: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTRACT</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> d) = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  which, however, cannot use the index, since it needs to execute the expression on the column, while the index is built on the column itself, as shown by EXPLAIN ANALYZE: <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------ Seq Scan on t (cost=0.00..4416.75 rows=365 width=332) (actual time=0.045..40.601 rows=2401 loops=1) Filter: (date_part('day'::text, d) = '1'::double precision) Rows Removed by Filter: 70649 Planning time: 0.209 ms Execution time: 43.018 ms (5 rows)</span></span></code> </pre><br>  So he not only has to perform a sequential scan, but also count the number, increasing the request time to 43 milliseconds. <br><br>  The database cannot use indexes for several reasons.  Indices (at least btree) are based on queries to the sorted data provided by the tree structure, and if the first query on the range benefits from this, then the second one (with the extract call) does not. <br><br>  Note: Another problem is that the set of operators supported by indices (that is, which can be executed directly on the index itself) is very limited.  And the extract function is not supported, so the query cannot bypass the sorting problem using Bitmap Index Scan. <br><br>  Theoretically, the database can try to convert a condition into a set of conditions, but it is extremely difficult and specific for each expression.  In this case, we will have to generate an infinite number of such ranges per day, because the scheduler does not really know the minimum / maximum timestamp in the table.  So the base won't even try. <br><br>  But while the database does not know how to transform the condition, the developers usually know.  For example, the condition of the form: <br><br><pre> <code class="sql hljs">(column + 1) &gt;= 1000</code> </pre><br>  it is not difficult to rewrite as follows: <br><br><pre> <code class="sql hljs">column &gt;= (1000 - 1)</code> </pre><br>  and it will already work fine with indexes. <br><br>  But what if such a conversion is not possible, as is the case with our query: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTRACT</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> d) = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  In this case, the developer will have to face the same problem of unknown minimum / maximum values ‚Äã‚Äãfor column d, and even then he will have to generate multiple ranges. <br><br>  Well, this article is about indexes on expressions, and we used only ordinary indexes up to this point, built directly on the column.  Let's create the first index by expression: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> idx_t_expr <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t ((<span class="hljs-keyword"><span class="hljs-keyword">extract</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">day</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> d))); <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> t;</code> </pre><br>  as a result of which we will get the following plan: <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------ Bitmap Heap Scan on t (cost=47.35..3305.25 rows=2459 width=332) (actual time=2.400..12.539 rows=2401 loops=1) Recheck Cond: (date_part('day'::text, d) = '1'::double precision) Heap Blocks: exact=2401 -&gt; Bitmap Index Scan on idx_t_expr (cost=0.00..46.73 rows=2459 width=0) (actual time=1.243..1.243 rows=2401 loops=1) Index Cond: (date_part('day'::text, d) = '1'::double precision) Planning time: 0.374 ms Execution time: 17.136 ms (7 rows)</span></span></code> </pre><br>  So far, he does not give the same increase in speed by 40 times, as the index from the first example, this is expected, since  this query returns much more tuples (2401 vs 32).  Moreover, they are spread over the entire table and are not as localized as in the first example.  So this is a good acceleration of 2 times, and in many situations from real life, you will see a much larger increase. <br><br>  But the ability to use indexes for conditions with complex expressions at the base is not the most interesting information in this article, this is the reason why people create indexes on expressions.  But this is not the only advantage. <br><br>  If you look at the two plans for executing queries below (with and without an index by expression), you will notice the following: <br><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------ Seq Scan on t (cost=0.00..4416.75 rows=365 width=332) (actual time=0.045..40.601 rows=2401 loops=1) ...</span></span></code> </pre><br><pre> <code class="sql hljs"> QUERY PLAN <span class="hljs-comment"><span class="hljs-comment">------------------------------------------------------------------------ Bitmap Heap Scan on t (cost=47.35..3305.25 rows=2459 width=332) (actual time=2.400..12.539 rows=2401 loops=1) ...</span></span></code> </pre><br>  True - creating an index by expression has significantly improved the scores.  Without an index, we only have statistics (MCV + histogram) for the coarse columns of the table, and the base does not know how to evaluate the expression <br><br><pre> <code class="sql hljs">EXTRACT(day FROM d) = 1</code> </pre><br>  Accordingly, it applies a comparison to the default equality, which returns approximately 0.5% of all rows ‚Äî since the table has 73050 rows, we get a score of only 365 rows.  Often you can see much larger evaluation errors in real-world applications. <br><br>  With the index, however, the database also collected statistics on the index columns and, in this case, the column contains the result of the expression.  In the planning process, the optimizer pays attention to this and produces a much better estimate. <br><br>  This is a great advantage that can help deal with the problems of poor query plans caused by inaccurate estimates.  However, most people do not know about such a handy tool. <br><br>  And the utility of this tool has only increased with the introduction of the JSONB data type in version 9.4, because it is practically the only way to collect statistics about the contents of JSONB documents. <br><br>  When using JSONB documents, there are two basic indexing strategies.  You can create a GIN / GIST index for the entire document, for example as follows: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">USING</span></span> GIN (jsonb_column);</code> </pre><br>  which allows you to query arbitrary parts of the JSONB field, use the content operator to compare subdocuments, and so on.  This is fine, but you still have only basic statistics on the column, which is not very convenient, since the documents are served as scalar values ‚Äã‚Äã(and neither matches the whole document, or does not use a range of documents). <br><br>  Expression indices, for example, created as follows: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t ((jsonb_column-&gt;<span class="hljs-string"><span class="hljs-string">'id'</span></span>));</code> </pre><br>  will be useful only for a specific expression, for this particular example: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> jsonb_column -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'id'</span></span> = <span class="hljs-number"><span class="hljs-number">123</span></span>;</code> </pre><br>  but not for requests directed to other JSON keys, for example, value: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> jsonb_column -&gt;&gt; <span class="hljs-string"><span class="hljs-string">'value'</span></span> = <span class="hljs-string"><span class="hljs-string">'xxxx'</span></span>;</code> </pre><br>  This does not mean that GIN / GIST indexes are useless on the whole document, but you have to choose.  Alternatively, you will create an index targeted to a specific expression, useful when the request goes to a specific key and with the added advantage of expression statistics.  Or you create a GIN / GIST index on the entire document, able to cope with requests for arbitrary keys, but without statistics. <br><br>  However, you can kill both birds with one stone, in this case, because you can create both indices at the same time, and the database itself will choose which one to use for which queries.  And you will have accurate statistics, thanks to the index on expressions. <br><br>  Unfortunately, expression indexes and GIN / GIST indexes use different conditions: <br><br><pre> <code class="sql hljs"><span class="hljs-comment"><span class="hljs-comment">-- expression (btree) SELECT * FROM t WHERE jsonb_column -&gt;&gt; 'id' = 123; -- GIN/GiST SELECT * FROM t WHERE jsonb_column @&gt; '{"id" : 123}';</span></span></code> </pre><br>  so the scheduler cannot use them at the same time - expression indexes for evaluation and GIN / GIST indexes for execution. </div><p>Source: <a href="https://habr.com/ru/post/282932/">https://habr.com/ru/post/282932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282918/index.html">Performance Indicators: KVM vs. Xen</a></li>
<li><a href="../282922/index.html">Work with WAV files using PHP</a></li>
<li><a href="../282924/index.html">Test Gradle Plugins Correctly</a></li>
<li><a href="../282926/index.html">About Modbus and Intel Edison Protocol</a></li>
<li><a href="../282930/index.html">Smart or virtual hardware drivers</a></li>
<li><a href="../282934/index.html">Easy Hack: Java application</a></li>
<li><a href="../282936/index.html">Efficient Rails - a new book on optimizing the development of Rails applications</a></li>
<li><a href="../282938/index.html">Redmine: Migration from MySQL to PostgreSQL 9.5</a></li>
<li><a href="../282940/index.html">How to write an IO monad in C # (not) without the help of a parallel universe and time machine</a></li>
<li><a href="../282944/index.html">About order management on the new 1C-Bitrix platform</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>