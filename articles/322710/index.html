<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Primitives for implementing 1-Wire master using PWM and ICP on AVR AtMega microcontrollers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="If someone used the linux driver of the 1-Wire bus based on GPIO, he probably noticed that at the time of exchanging data, the loading of SY% jumps to...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Primitives for implementing 1-Wire master using PWM and ICP on AVR AtMega microcontrollers</h1><div class="post__text post__text-html js-mediator-article">  If someone used the linux driver of the 1-Wire bus based on GPIO, he probably noticed that at the time of exchanging data, the loading of SY% jumps to almost 100% (which is quite logical for a bitbang implementation).  Of course, you can install a dedicated 1-Wire bus controller connected via I2C <a href="https://habr.com/ru/post/322710/">DS28E17</a> or use a <a href="https://habr.com/ru/post/322710/">UART</a> , but ... Still, using linux for real-time applications is not a good idea.  Let the controller on it is engaged in high-level logic, and the whole realtime can be transferred to a separate processor.  Moreover, there are more than enough tasks for this separate processor in my project. <br><a name="habracut"></a><br>  No, <s>I will not take STM32 that is now ramping up</s> (after all, I did an <a href="https://habrahabr.ru/post/326114/">implementation for STM8</a> ).  Take the good old AtMega328P (well, or some <a href="https://habr.com/ru/post/322710/">Arduino</a> , if it becomes easier for someone like this) and collect everything on it.  But we will do everything ‚Äúin an adult way‚Äù, with work in the mode of allowed interrupts and with the expectation of the subsequent <a href="https://habrahabr.ru/post/326320/">implementation of higher levels using protothreads</a> (for the protothreads themselves, see the <a href="https://habr.com/ru/post/322710/">original</a> and <a href="https://habr.com/ru/post/322710/">chewed examples in Russian</a> ).  Those.  from bitbang we refuse immediately and irrevocably. <br><br>  We will also save the UART for future use under other peripherals.  For in our case, it is one, and I would have to push the eBus protocol here.  For this is also realtime. <br>  I2C is good, but this is another not the cheapest crystal with strapping, and we need it?  So, from interesting remains PWM and ICP. <br><br>  What is PWM, I think, no need to explain.  This is simply the generation of pulses of a given phase and duration, which is produced by hardware (that is, from the point of view of the program ‚Äúin the background‚Äù), but the parameters of which can be changed by software.  But ICP is quite an interesting thing: it allows the hardware to save the timer value at the moment of changing the signal level at a certain microcontroller output.  Thus, it is possible to quite accurately obtain the moment of the occurrence of the event (change in the state of the microcontroller's output) and / or measure its duration. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      So, we will use hardware TIMER1 ATmega328 (my timers 0 and 2 are used for other purposes).  For PWM, you can use pins OC1A and OC1B.  However, OC1B is also used as an SS signal, and I planned to connect the ATmega328 to the target device via the SPI bus.  This is convenient from the point of view of upgrading ATmega firmware - we make them with the help of the target device, only one of the CE signals from its SPI controller will be put on the SS Atmega contact, and the other CE signal will be put on the RESET pin.  Yes, and with the agreement of exchange rates do not need to mess around.  Well, as another argument against the use of OC1B is that on the <a href="https://habr.com/ru/post/322710/">Arduino MEGA 2560</a> board, this signal is not output to the outside world at all. <br><br>  So, to generate PWM use the contact OC1A.  There are no options for ICP at all - there is only one output of this type for this chip.  For the ‚ÄúACTIVE PULLUP‚Äù mode, use any free IO port and configure it to work in the ‚ÄúOUT‚Äù mode. <br><br>  So, with the circuitry sorted out.  Now let's refresh the <a href="https://habr.com/ru/post/322710/">physics of</a> the 1-wire bus.  In a nutshell, it can be described as: <br><br><ul><li>  Receive and transmit is clocked by the master device (i.e. us) </li><li>  The time interval between the transmitted and / or received bits is not critical (the main thing is that it be not less than the minimum allowable) </li><li>  The duration of the transmitted pulse and the duration of the received (measured) signal is critical. </li></ul><br>  Well, then choose the Phase Correct PWM Mode mode (the meter first counts up from the BOTTOM value to the TOP value, and after reaching the TOP value it starts counting down to the BOTTOM value).  In this case, the BOTTOM value is fixed and is always 0, and the TOP value can be either one of the fixed values ‚Äã‚Äã(0xFF, 0x1FF, 0x3FF), or a value from the OCR1A or ICR1 registers.  The last two options do not suit us, because  OCR1A will be used to generate pulses on the OC1A pin, and ICR1 will be used to measure the low level duration on the 1-Wire bus.  Those.  it only remains to use the variant with fixed TOP values, since the time interval between bits is not critical for us. <br><br>  In accordance with the scheme, the OC1A output is enabled in the inverse mode (i.e., a high level setting on it will result in a low level setting on the 1-Wire bus and vice versa), we will use the following PWM mode: <br><br><ul><li>  when the timer counts down and its value coincides with the value from the OCR1A register, we set the signal at the OC1A pin to a high level (there will be a low level on the 1-Wire bus). <br><br></li><li>  when the timer counts up and its value coincides with the value from the OCR1A register, set the signal at the OC1A pin to a low level (and, perhaps, start measuring the moment of the signal transition at the ICP pin from low to high). <br><br></li></ul><br><img src="https://habrastorage.org/files/8b4/492/120/8b44921208904d59b2c44fd5b56ce12f.png"><br>  The rest is simple.  The new value (the duration of the next transmitted bit) in the OCR1A register will be loaded via the TIMER1_OVF interrupt (in this mode it is generated when the counter reaches the BOTTOM value, and then activated after the TOP value is reached), and the TIMER1_ICP interrupt will be calculated state of the low level and, depending on this, to conclude that the acceptance of bit "1" or bit "0". <br><br>  Thus, for each operation of receiving or transmitting one bit, we will generate one OVF interrupt and one ICP interrupt.  Accordingly, it would be better to optimize their ISRs, but for now let them be written in C. <br><br>  Well, we‚Äôll perform the RESET operation for the 1-Wire bus by reprogramming TIMER1 to NORMAL mode (since the RESET pulse and the subsequent possible PRESENCE pulse are long enough, we need to expand the ‚Äúdynamic range‚Äù of the timer. In the NORMAL mode, it is 0xFFFF This is quite enough in our case. Moreover, we will even specifically limit it to the value from the OCR1B register, so that in the absence of devices connected to the 1-Wire bus, we should not wait until the timer reaches 0xFFFF, but abort the operation immediately after reaching the maximum  time interval). <br><br>  Manually counting the timer settings depending on the ATmega clock frequency is moveton (and lazily checking all boundary conditions), so let's make it do the C compiler preprocessor using the fact that we need to have a certain constant F_CPU, the value of which is equal to the clock frequency used in Hertz (unsigned long, i.e. a constant must be defined as either 8000000UL or 16000000UL, otherwise the preprocessor will consider it as an int and lose significant digits). <br><br><div class="spoiler">  <b class="spoiler_title">Determine the parameters of the used board</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Arduino Pro Mini 1-Wire connection */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_DDR DDRB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_PORT PORTB #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_PIN PINB </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* OC1A/PCINT1 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_OUT PB1 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* (PCINT0/CLKO/ICP1) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_ICP PB0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IN_ICP PINB0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Active pullup PD7 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_PULLUP_DDR DDRD #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_PULLUP_PORT PORTD #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_PULLUP_OUT PD7 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Presence detection in idle mode: external interrupt #0 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_IRQ INT0_vect #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_EICRA_MASK (_BV(ISC01) | _BV(ISC00)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Presence detection in idle mode: low level generate IRQ */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_EICRA_ISC 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_EIMSK_INT INT0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_EIFR_INTF INTF0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_DDR DDRD #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_PORT PORTD #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_PIN PIND #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_IDLE_PRESENCE_DETECT_BIT PD2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_TCNT TCNT1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_TCCRA TCCR1A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_TCCRB TCCR1B #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_TCCRC TCCR1C #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_OCRA OCR1A #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_OCRB OCR1B #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_ICR ICR1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_TIFR TIFR1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_TIMSK TIMSK1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_ICP_IRQ TIMER1_CAPT_vect #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_OVF_IRQ TIMER1_OVF_vect #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_COMPA_IRQ TIMER1_COMPA_vect #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_COMPB_IRQ TIMER1_COMPB_vect #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_POWER_ON() \ power_timer1_enable()</span></span></code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Determine the temporary parameters of the protocol 1-Wire</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*   RESET   TSLOT */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RESET_DURATION_TSLOTS 8 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_TLOWR_MIN 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_TLOWR_MAX 15 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_TSLOT_MIN 60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_TSLOT_MAX 120 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT1_MIN NORMAL_TLOWR_MIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT1_MAX NORMAL_TLOWR_MAX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT0_MIN NORMAL_TSLOT_MIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT0_MAX NORMAL_TSLOT_MAX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_TREC_MIN 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_RESET (RESET_DURATION_TSLOTS * NORMAL_TSLOT_MIN) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_PRESENCE_START_MIN 15 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_PRESENCE_START_MAX 60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_PRESENCE_MIN 60 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_PRESENCE_MAX 240 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_TLOWR_MIN 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_TLOWR_MAX 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_TSLOT_MIN 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_TSLOT_MAX 16 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT1_MIN OVERDRIVE_TLOWR_MIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT1_MAX OVERDRIVE_TLOWR_MAX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT0_MIN OVERDRIVE_TSLOT_MIN #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT0_MAX OVERDRIVE_TSLOT_MAX #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_TREC_MIN 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_RESET (RESET_DURATION_TSLOTS * OVERDRIVE_TSLOT_MIN) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_PRESENCE_START_MIN 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_PRESENCE_START_MAX 6 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_PRESENCE_MIN 8 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_PRESENCE_MAX 24 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_MAX_PERIOD (NORMAL_TSLOT_MAX + NORMAL_TREC_MIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    (..    ) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_MIN_PRECISION (OVERDRIVE_TLOWR_MAX / 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     RESET */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> WIRE1_RESET_PROCEDURE_DURATION (RESET_DURATION_TSLOTS * NORMAL_TSLOT_MIN * 2)</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Calculation of timer settings</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*  TOP  NORMAL MODE */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_NORMAL_MODE_TOP 0xFFFF </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   TOP,   */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_FIXED_TOP_1 0xFF #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_FIXED_TOP_2 0x1FF #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_FIXED_TOP_3 0x3FF </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*          */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_PRECISION(_n) \ ((_n) * 1000000UL / F_CPU) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  _cnt    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_DURATION(_n, _cnt) \ ((_cnt) * (_n) * 1000000UL / F_CPU) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*          */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_PERIOD(_n, _t) \ ((_t) * 2 * (_n) * 1000000UL / F_CPU) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*         */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_COUNT_VALUE(_n, _t) \ (((F_CPU / (_n)) / 1000000UL) * (_t)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   OCRA       */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> PWM_BOTTOM_VALUE(_n, _t) \ ((F_CPU / 2 / (_n) / 1000000UL) * (_t)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* *      TOP: * * A.   * -   .. &gt;= WIRE1_MAX_PERIOD * -   .. &lt; WIRE1_MIN_PRECISION * * B.   * -        (..  TOP) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">undef</span></span></span><span class="hljs-meta"> PWM_TOP </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     8 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PWM_DURATION(8, PWM_FIXED_TOP_3) &gt;= WIRE1_MAX_PERIOD #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> PWM_PRECISION(8) </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; WIRE1_MIN_PRECISION #undef PWM_TOP #define PWM_TOP PWM_FIXED_TOP_3 #undef PWM_DIVIDER #define PWM_DIVIDER 8 #undef PWM_TCCRA #define PWM_TCCRA (_BV(WGM11) | _BV(WGM10)) #undef PWM_TCCRB #define PWM_TCCRB _BV(CS11) #endif #endif #if PWM_DURATION(8, PWM_FIXED_TOP_2) &gt;= WIRE1_MAX_PERIOD #if PWM_PRECISION(8) &lt; WIRE1_MIN_PRECISION #undef PWM_TOP #define PWM_TOP PWM_FIXED_TOP_2 #undef PWM_DIVIDER #define PWM_DIVIDER 8 #undef PWM_TCCRA #define PWM_TCCRA _BV(WGM11) #undef PWM_TCCRB #define PWM_TCCRB _BV(CS11) #endif #endif #if PWM_DURATION(8, PWM_FIXED_TOP_1) &gt;= WIRE1_MAX_PERIOD #if PWM_PRECISION(8) &lt; WIRE1_MIN_PRECISION #undef PWM_TOP #define PWM_TOP PWM_FIXED_TOP_1 #undef PWM_DIVIDER #define PWM_DIVIDER 8 #undef PWM_TCCRA #define PWM_TCCRA _BV(WGM10) #undef PWM_TCCRB #define PWM_TCCRB _BV(CS11) #endif #endif /*     1 */ #if PWM_DURATION(1, PWM_FIXED_TOP_3) &gt;= WIRE1_MAX_PERIOD #if PWM_PRECISION(1) &lt; WIRE1_MIN_PRECISION #undef PWM_TOP #define PWM_TOP PWM_FIXED_TOP_3 #undef PWM_DIVIDER #define PWM_DIVIDER 1 #undef PWM_TCCRA #define PWM_TCCRA (_BV(WGM11) | _BV(WGM10)) #undef PWM_TCCRB #define PWM_TCCRB _BV(CS10) #endif #endif #if PWM_DURATION(1, PWM_FIXED_TOP_2) &gt;= WIRE1_MAX_PERIOD #if PWM_PRECISION(1) &lt; WIRE1_MIN_PRECISION #undef PWM_TOP #define PWM_TOP PWM_FIXED_TOP_2 #undef PWM_DIVIDER #define PWM_DIVIDER 1 #undef PWM_TCCRA #define PWM_TCCRA _BV(WGM11) #undef PWM_TCCRB #define PWM_TCCRB _BV(CS10) #endif #endif #if PWM_DURATION(1, PWM_FIXED_TOP_1) &gt;= WIRE1_MAX_PERIOD #if PWM_PRECISION(1) &lt; WIRE1_MIN_PRECISION #undef PWM_TOP #define PWM_TOP PWM_FIXED_TOP_1 #undef PWM_DIVIDER #define PWM_DIVIDER 1 #undef PWM_TCCRA #define PWM_TCCRA _BV(WGM10) #undef PWM_TCCRB #define PWM_TCCRB _BV(CS10) #endif #endif #if !defined(PWM_TOP) #error "Can't build I/O procedure with current F_CPU value" #endif /* *  RESET     normal mode,    *   TOP      RESET * */ #undef PWM_RESET_TCCRB /*     8 */ #if PWM_PERIOD(8, PWM_NORMAL_MODE_TOP) &gt;= WIRE1_RESET_PROCEDURE_DURATION #undef PWM_RESET_DIVIDER #define PWM_RESET_DIVIDER 8 #undef PWM_RESET_TCCRB #define PWM_RESET_TCCRB _BV(CS11) #endif /*     1 */ #if PWM_PERIOD(1, PWM_NORMAL_MODE_TOP) &gt;= WIRE1_RESET_PROCEDURE_DURATION #undef PWM_RESET_DIVIDER #define PWM_RESET_DIVIDER 1 #undef PWM_RESET_TCCRB #define PWM_RESET_TCCRB _BV(CS10) #endif #if !defined(PWM_RESET_TCCRB) #error "Can't build reset procedure with current F_CPU value" #endif</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Define some useful macros.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_STOP_CLOCK() do { \ _SFR_BYTE(WIRE1_TCCRB) &amp;= ~(_BV(CS12) | _BV(CS11) | _BV(CS10)); \ } while(0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    "NORMAL MODE" */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_TIMER_NORMAL_MODE() do { \ _SFR_BYTE(WIRE1_TCCRB) &amp;= ~(_BV(WGM13) | _BV(WGM12)); \ _SFR_BYTE(WIRE1_TCCRA) &amp;= ~(_BV(WGM11) | _BV(WGM10)); \ } while(0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   OCRA     (low level) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_DISCONNECT_OCRA_PIN() do { \ _SFR_BYTE(WIRE1_TCCRA) &amp;= ~(_BV(COM1A1) | _BV(COM1A0)); } while(0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   OCRA   low level    OCRA */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_MATCH_OCRA_PIN_LOW() do { \ _SFR_BYTE(WIRE1_TCCRA) = \ (_SFR_BYTE(WIRE1_TCCRA) &amp; ~_BV(COM1A0)) | _BV(COM1A1); } while(0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   OCRA   high level    OCRA */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_MATCH_OCRA_PIN_HIGH() do { \ _SFR_BYTE(WIRE1_TCCRA) |= _BV(COM1A1) | _BV(COM1A0); } while(0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*        (1 =&gt; 0) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_CAPTURE_FALLING_EDGE() do { \ _SFR_BYTE(WIRE1_TCCRB) &amp;= ~_BV(ICES1); } while(0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*        (0 =&gt; 1) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_CAPTURE_RISING_EDGE() do { \ _SFR_BYTE(WIRE1_TCCRB) |= _BV(ICES1); } while(0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  != 0,         */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_IS_CAPTURE_RISING() \ (_SFR_BYTE(WIRE1_TCCRB) &amp; _BV(ICES1)) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  OCRA     1   normal */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT1_VALUE \ PWM_BOTTOM_VALUE(PWM_DIVIDER, (NORMAL_BIT1_MIN + NORMAL_BIT1_MAX) / 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  OCRA     1   overdrive */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT1_VALUE \ PWM_BOTTOM_VALUE(PWM_DIVIDER, (OVERDRIVE_BIT1_MIN + OVERDRIVE_BIT1_MAX) / 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  OCRA     0   normal */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT0_VALUE \ PWM_BOTTOM_VALUE(PWM_DIVIDER, (NORMAL_BIT0_MIN + NORMAL_BIT0_MAX) / 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  OCRA     0   overdrive */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT0_VALUE \ PWM_BOTTOM_VALUE(PWM_DIVIDER, (OVERDRIVE_BIT0_MIN + OVERDRIVE_BIT0_MAX) / 2) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     1   normal    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT1_MIN_VALUE \ PWM_COUNT_VALUE(PWM_DIVIDER, NORMAL_BIT1_MIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     1   overdrive    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT1_MIN_VALUE \ PWM_COUNT_VALUE(PWM_DIVIDER, OVERDRIVE_BIT1_MIN) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     1   normal    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT1_MAX_VALUE \ PWM_COUNT_VALUE(PWM_DIVIDER, NORMAL_BIT1_MAX) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     1   overdrive    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT1_MAX_VALUE \ PWM_COUNT_VALUE(PWM_DIVIDER, OVERDRIVE_BIT1_MAX) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     0   normal    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NORMAL_BIT0_MAX_VALUE \ PWM_COUNT_VALUE(PWM_DIVIDER, NORMAL_BIT0_MAX) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     0   overdrive    */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> OVERDRIVE_BIT0_MAX_VALUE \ PWM_COUNT_VALUE(PWM_DIVIDER, OVERDRIVE_BIT0_MAX)</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Define data types to help save RAM.</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  ,   .. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> state; <span class="hljs-comment"><span class="hljs-comment">/* ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*      RESET */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   presence TPDH */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> tpdhMeasure; <span class="hljs-comment"><span class="hljs-comment">/*   presence TPDL*/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> tpdlMeasure; } reset; <span class="hljs-comment"><span class="hljs-comment">/*         */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/* ,    compare unit  capture event */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> icpOCRA; <span class="hljs-comment"><span class="hljs-comment">/*   -  ,   -   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> value; <span class="hljs-comment"><span class="hljs-comment">/* - ,     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pending; } io; } param; } <span class="hljs-keyword"><span class="hljs-keyword">drv_1wire_context_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* state:  RESET  */</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_RESET_COMPLETE 0b10000000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* state:    PRESENCE   tpdhMeasure/tpdlMeasure  */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_PRESENCE_DETECTED 0b01000000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* state:      overdrive */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_OVERDRIVE_DETECTED 0b00100000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* state:     */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_IO_COMPLETE 0b00010000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* state:       */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_IO_ERROR 0b00001000 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* state:        parasite power */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_BUS_PARASITE_POWER 0b00000100 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* state:     -    pullup. *           */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_ACTIVATE_PULLUP 0b00000010 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* state:  :  OCA  high    ICP  low. *       RESET. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_OCA_LOW_PASSED 0b00000010 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* state:  :  OCA  low    ICP  high. *       RESET. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_OCA_HIGH_PASSED 0b00000001 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    1-wire. *       RESET. */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_1WIRE_DETECTED \ (DRV_1WIRE_STATE_OCA_LOW_PASSED | DRV_1WIRE_STATE_OCA_HIGH_PASSED) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  ,          */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_DEVICE_DETECTED(_s) \ ((_s) &amp; DRV_1WIRE_STATE_PRESENCE_DETECTED) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*  ,    /   */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_STATE_IO_OK(_s) \ (((_s) &amp; (DRV_1WIRE_STATE_PRESENCE_DETECTED | DRV_1WIRE_STATE_IO_ERROR)) == DRV_1WIRE_STATE_PRESENCE_DETECTED) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_TXBITS(_v, _n, _p) \ drv1WireStartIo((_v), (_n), (_p)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_RXBITS(_n) \ DRV_1WIRE_TXBITS(0xFF, (_n), 0) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*       */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_TXBYTE(_v, _p) \ DRV_1WIRE_TXBITS((_v), 8, (_p)) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_RXBYTE() \ DRV_1WIRE_RXBITS(8) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_RESET() \ drv1WireStartReset(DRV_1WIRE_STATE() &amp; DRV_1WIRE_STATE_OVERDRIVE_DETECTED) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIRE1_PULLUP_OUT) #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_PULLUP_ON() \ drv1WirePullupOn() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_PULLUP_OFF() \ drv1WirePullupOff() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* defined(WIRE1_PULLUP_OUT) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_PULLUP_ON() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> DRV_1WIRE_PULLUP_OFF() #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* defined(WIRE1_PULLUP_OUT) */</span></span></span></span></code> </pre><br></div></div><br><br><div class="spoiler">  <b class="spoiler_title">Source code for the implementation of primitives</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">drv_1wire_context_t</span></span> ctx1WireDriver; <span class="hljs-comment"><span class="hljs-comment">/** *   RESET * * @param _flags -     */</span></span> __<span class="hljs-function"><span class="hljs-function">INLINE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resetOperationComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _flags)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   , ..   */</span></span> _SFR_BYTE(WIRE1_TIMSK) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> ctx1WireDriver.state |= _flags | DRV_1WIRE_STATE_RESET_COMPLETE; <span class="hljs-comment"><span class="hljs-comment">/* !? */</span></span> DRV_STOP_CLOCK(); <span class="hljs-comment"><span class="hljs-comment">/*   OCA   low (   high level) */</span></span> DRV_MATCH_OCRA_PIN_LOW(); _SFR_BYTE(WIRE1_TCCRC) |= _BV(FOC1A); <span class="hljs-comment"><span class="hljs-comment">/*   precence  */</span></span> VOS_KERNEL_FIRE_SIGNIFICANT_EVENT(VOS_SE_REASON_1WIRE_PRESENCE_DETECTOR); } <span class="hljs-comment"><span class="hljs-comment">/** *    * * @param _flags */</span></span> __<span class="hljs-function"><span class="hljs-function">INLINE </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ioOperationComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint8_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _flags)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*   , ..   */</span></span> _SFR_BYTE(WIRE1_TIMSK) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> ctx1WireDriver.state |= _flags | DRV_1WIRE_STATE_IO_COMPLETE; <span class="hljs-comment"><span class="hljs-comment">/*         normal */</span></span> _SFR_BYTE(WIRE1_TCCRB) = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*    normal,      OCA  low */</span></span> _SFR_BYTE(WIRE1_TCCRA) = _BV(COM1A1); <span class="hljs-comment"><span class="hljs-comment">/*   ,   OCA    */</span></span> _SFR_BYTE(WIRE1_TCCRC) |= _BV(FOC1A); <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> VOS_KERNEL_FIRE_SIGNIFICANT_EVENT(VOS_SE_REASON_1WIRE_IO_BYTE_COMPLETE); } <span class="hljs-comment"><span class="hljs-comment">/** *       */</span></span> __INLINE __<span class="hljs-function"><span class="hljs-function">OPTIMIZE_SPEED </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">txBit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ctx1WireDriver.param.io.value &amp; <span class="hljs-number"><span class="hljs-number">0x01</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*      1 */</span></span> _SFR_WORD(WIRE1_OCRA) = (ctx1WireDriver.state &amp; DRV_1WIRE_STATE_OVERDRIVE_DETECTED) ? OVERDRIVE_BIT1_VALUE : NORMAL_BIT1_VALUE; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-comment"><span class="hljs-comment">/*      0 */</span></span> _SFR_WORD(WIRE1_OCRA) = (ctx1WireDriver.state &amp; DRV_1WIRE_STATE_OVERDRIVE_DETECTED) ? OVERDRIVE_BIT0_VALUE : NORMAL_BIT0_VALUE; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drv1WireAttach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> WIRE1_POWER_ON(); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> DRV_STOP_CLOCK(); <span class="hljs-comment"><span class="hljs-comment">/* Z-  pullup */</span></span> _SFR_BYTE(WIRE1_PORT) &amp;= ~(_BV(WIRE1_OUT) | _BV(WIRE1_ICP)); <span class="hljs-comment"><span class="hljs-comment">/*   OCA   low (   high level) */</span></span> DRV_MATCH_OCRA_PIN_LOW(); _SFR_BYTE(WIRE1_TCCRC) |= _BV(FOC1A); <span class="hljs-comment"><span class="hljs-comment">/* Set WIRE1_OUT out direction and low signal level, force ICP is in direction */</span></span> _SFR_BYTE(WIRE1_DDR) = (_SFR_BYTE(WIRE1_DDR) &amp; ~_BV(WIRE1_ICP)) | _BV(WIRE1_OUT); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIRE1_IDLE_PRESENCE_DETECT_BIT) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Z-  pullup */</span></span></span><span class="hljs-meta"> _SFR_BYTE(WIRE1_IDLE_PRESENCE_DETECT_PORT) &amp;= ~_BV(WIRE1_IDLE_PRESENCE_DETECT_BIT); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   ,    presence  idle mode   */</span></span></span><span class="hljs-meta"> _SFR_BYTE(WIRE1_IDLE_PRESENCE_DETECT_DDR) &amp;= ~_BV(WIRE1_IDLE_PRESENCE_DETECT_BIT); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* defined(WIRE1_IDLE_PRESENCE_DETECT_BIT) */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIRE1_PULLUP_OUT) </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Z-  pullup */</span></span></span><span class="hljs-meta"> drv1WirePullupOff(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* pullup pin    */</span></span></span><span class="hljs-meta"> _SFR_BYTE(WIRE1_PULLUP_DDR) |= _BV(WIRE1_PULLUP_OUT); #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* defined(WIRE1_PULLUP_OUT) */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    */</span></span></span><span class="hljs-meta"> ctx1WireDriver.state = 0; } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(WIRE1_PULLUP_OUT) void drv1WirePullupOn() { _SFR_BYTE(WIRE1_PULLUP_PORT) |= _BV(WIRE1_PULLUP_OUT); } void drv1WirePullupOff() { _SFR_BYTE(WIRE1_PULLUP_PORT) &amp;= ~_BV(WIRE1_PULLUP_OUT); } #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* defined(WIRE1_PULLUP_OUT) */</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/** *   "RESET" * * @param _overdrive -   OVERDRIVE ( != 0 - ) * *  : * 1.    NORMAL MODE    TCNT = 0 * 2.  OCRA = 0    FOCA   *   OCRA  HIGH (     LOW) * 3.   OCRA    LOW * 4.     OCRA    * (..      HIGH) * 5.   * *     OCRA  OCRA    *   LOW (    high)    * */</span></span></span><span class="hljs-meta"> void drv1WireStartReset(uint8_t _overdrive) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    strong pullup,      MOSFET */</span></span></span><span class="hljs-meta"> DRV_1WIRE_PULLUP_OFF(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> ctx1WireDriver.state &amp;= ~(DRV_1WIRE_STATE_RESET_COMPLETE | DRV_1WIRE_STATE_PRESENCE_DETECTED | DRV_1WIRE_STATE_1WIRE_DETECTED); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    LOW,   */</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(_overdrive) { ctx1WireDriver.param.reset.tpdhMeasure = PWM_COUNT_VALUE(PWM_RESET_DIVIDER, OVERDRIVE_RESET); } </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> { ctx1WireDriver.param.reset.tpdhMeasure = PWM_COUNT_VALUE(PWM_RESET_DIVIDER, NORMAL_RESET); } </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> VOS_KERNEL_ENTER_MODE(VOS_KERNEL_RING_HARD); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     */</span></span></span><span class="hljs-meta"> DRV_STOP_CLOCK(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     NORMAL MODE */</span></span></span><span class="hljs-meta"> DRV_TIMER_NORMAL_MODE(); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   */</span></span></span><span class="hljs-meta"> _SFR_WORD(WIRE1_TCNT) = 0; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*   OCRA   high (   low level) */</span></span></span><span class="hljs-meta"> DRV_MATCH_OCRA_PIN_HIGH(); _SFR_BYTE(WIRE1_TCCRC) |= _BV(FOC1A); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*    LOW */</span></span></span><span class="hljs-meta"> _SFR_WORD(WIRE1_OCRA) = ctx1WireDriver.param.reset.tpdhMeasure; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/*     */</span></span></span><span class="hljs-meta"> _SFR_WORD(WIRE1_OCRB) = (ctx1WireDriver.param.reset.tpdhMeasure </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;&lt; 1); /*   OCRA  OCRA   low (   high) */ DRV_MATCH_OCRA_PIN_LOW(); /*   ,     OCRA  OCRB  (  1) */ _SFR_BYTE(WIRE1_TIFR) |= _BV(OCF1A) | _BV(OCF1B); /*      OCRA  OCRB */ _SFR_BYTE(WIRE1_TIMSK) |= _BV(OCIE1A) | _BV(OCIE1B); /*     ICP   HIGH   LOW */ DRV_CAPTURE_FALLING_EDGE(); /*     (  noise canceller) */ _SFR_BYTE(WIRE1_TCCRB) |= PWM_RESET_TCCRB | _BV(ICNC1); /*    ,        */ if(!(_SFR_BYTE(WIRE1_PIN) &amp; _BV(WIRE1_ICP))) { /*    ,     */ ctx1WireDriver.state |= DRV_1WIRE_STATE_OCA_LOW_PASSED; } /*   */ VOS_KERNEL_ENTER_MODE(VOS_KERNEL_RING_SOFT); } /** *     (  ) * * @param _value -   * @param _bits - -   ( 8) * @param _pullup -   pullup      * * ,         *    OCA == 0 ( ). */ void drv1WireStartIo(uint8_t _value, uint8_t _bits, uint8_t _pullup) { /*    strong pullup,      MOSFET */ DRV_1WIRE_PULLUP_OFF(); /* :           */ ctx1WireDriver.state &amp;= ~(DRV_1WIRE_STATE_IO_COMPLETE | DRV_1WIRE_STATE_IO_ERROR); /*    pullup    */ if(_pullup) { ctx1WireDriver.state |= DRV_1WIRE_STATE_ACTIVATE_PULLUP; } else { ctx1WireDriver.state &amp;= ~DRV_1WIRE_STATE_ACTIVATE_PULLUP; } /*   */ ctx1WireDriver.param.io.value = _value; /* - ,   */ ctx1WireDriver.param.io.pending = _bits; /*   */ VOS_KERNEL_ENTER_MODE(VOS_KERNEL_RING_HARD); /*   ,   capture  bottm reach  (  1) */ _SFR_BYTE(WIRE1_TIFR) |= _BV(ICF1) | _BV(TOV1); /*    capture   bottom */ _SFR_BYTE(WIRE1_TIMSK) |= _BV(ICIE1) | _BV(TOIE1); /*  OCRA     */ txBit(); /*     1   top, *   1 clock  OCRA     */ _SFR_WORD(WIRE1_TCNT) = PWM_TOP - 1; /* *  : * Phase Correct PWM    TOP, *  OCA=1    OCRA     *  OCA=0    OCRA    */ _SFR_BYTE(WIRE1_TCCRA) = PWM_TCCRA | _BV(COM1A1); /* *  : * WGM13  WGM12 == 0  Phase Correct PWM    TOP *    *  Input Capture Noise Canceler * capture     ICP      * *        . */ _SFR_BYTE(WIRE1_TCCRB) = PWM_TCCRB | _BV(ICNC1) | _BV(ICES1); /*   */ VOS_KERNEL_ENTER_MODE(VOS_KERNEL_RING_SOFT); } /** *    BOTTOM, ..       * Phase Correct PWM Mode. *      BOTTOM     OCRA,  *          *  TOP. */ __OPTIMIZE_SPEED ISR(WIRE1_OVF_IRQ) { if(ctx1WireDriver.param.io.pending--) { /*          */ ctx1WireDriver.param.io.value &gt;&gt;= 1; /*       compare unit */ ctx1WireDriver.param.io.icpOCRA = _SFR_WORD(WIRE1_OCRA); /*   OCRA ,      *  .       *   TOP. */ if(ctx1WireDriver.param.io.pending) { txBit(); } else { /*   ,     */ } } else { /*      capture   . *    . */ ioOperationComplete(DRV_1WIRE_STATE_IO_ERROR); } } /** *   capture */ __OPTIMIZE_SPEED ISR(WIRE1_ICP_IRQ) { if(ctx1WireDriver.state &amp; DRV_1WIRE_STATE_RESET_COMPLETE) { /* *  RESET .    - ,  *     .     *     ICP   0   1. *    (,   ) *  io.icpOCRA + _SFR_WORD(WIRE1_ICR)  . * * ..          255, *    uint8_t. */ /*         */ uint16_t lowDuration = ctx1WireDriver.param.io.icpOCRA + _SFR_WORD(WIRE1_ICR); if(ctx1WireDriver.state &amp; DRV_1WIRE_STATE_OVERDRIVE_DETECTED) { /*  OVERDRIVE */ if((lowDuration &lt; OVERDRIVE_BIT1_MIN_VALUE) || (lowDuration &gt; OVERDRIVE_BIT0_MAX_VALUE)) { /*       */ ioOperationComplete(DRV_1WIRE_STATE_IO_ERROR); /*      */ return; } /*    */ if(lowDuration &lt; OVERDRIVE_BIT1_MAX_VALUE) { /*   . 1*/ ctx1WireDriver.param.io.value |= 0x80; } } else { /*   */ if((lowDuration &lt; NORMAL_BIT1_MIN_VALUE) || (lowDuration &gt; NORMAL_BIT0_MAX_VALUE)) { /*       */ ioOperationComplete(DRV_1WIRE_STATE_IO_ERROR); /*      */ return; } /*    */ if(lowDuration &lt; NORMAL_BIT1_MAX_VALUE) { /*   . 1*/ ctx1WireDriver.param.io.value |= 0x80; } } if(!ctx1WireDriver.param.io.pending) { /*   (, , )   -  */ if(ctx1WireDriver.state &amp; DRV_1WIRE_STATE_ACTIVATE_PULLUP) { /*       pullup */ DRV_1WIRE_PULLUP_ON(); } /*  /   */ ioOperationComplete(0); } } else { /*   RESET. *  ICP      HIGH   LOW. *    presence pulse. */ if(DRV_IS_CAPTURE_RISING()) { /* ICES ,     */ /*  TPDL */ ctx1WireDriver.param.reset.tpdlMeasure = _SFR_WORD(WIRE1_ICR) - ctx1WireDriver.param.reset.tpdlMeasure; /* ..     ,    *          OCR *   . */ ctx1WireDriver.state |= DRV_1WIRE_STATE_OCA_HIGH_PASSED; /*  , presence  */ resetOperationComplete(DRV_1WIRE_STATE_PRESENCE_DETECTED); } else { /* ICES ,     */ ctx1WireDriver.param.reset.tpdlMeasure = _SFR_WORD(WIRE1_ICR); /*  TPDH */ ctx1WireDriver.param.reset.tpdhMeasure = ctx1WireDriver.param.reset.tpdlMeasure - ctx1WireDriver.param.reset.tpdhMeasure; /*         */ DRV_CAPTURE_RISING_EDGE(); } } } /** *     OCRA */ __OPTIMIZE_SPEED ISR(WIRE1_COMPA_IRQ) { /*  OCRA     RESET. *  ,     OCRA     *   low,         high. *     ,      *      high   low (..  *  presence pulse,    ). */ /*    ICF (  1) */ _SFR_BYTE(WIRE1_TIFR) |= _BV(ICF1); /*    capture */ _SFR_BYTE(WIRE1_TIMSK) |= _BV(ICIE1); } /** *     OCRB * *         RESET  *       PRESENCE. */ __OPTIMIZE_SPEED ISR(WIRE1_COMPB_IRQ) { /*  OCRB     RESET. *  ,   presence       *  . *       1-wire   *    . */ if(_SFR_BYTE(WIRE1_PIN) &amp; _BV(WIRE1_ICP)) { /*    ,     */ ctx1WireDriver.state |= DRV_1WIRE_STATE_OCA_HIGH_PASSED; } /*  , presence   */ resetOperationComplete(0); }</span></span></span></span></code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here is an example of an acquisition waveform: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/5bb/b90/f41/5bbb90f41fe74d698c204c8e902c6e46.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Channel C is connected to the OC1A output (pulses of the same duration), and channel B is connected to the 1-Wire bus. </font><font style="vertical-align: inherit;">It can be seen that the duration of the 1st and 3rd pulse on channel B is longer than the duration of the corresponding sync pulse on channel C. Ie </font><font style="vertical-align: inherit;">The slave in bits 1 and 3 transmits the value "0". </font><font style="vertical-align: inherit;">And the pulse duration 2 on channels B and C is approximately equal, which corresponds to bit "1". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since the 1-Wire bus driver used also supports the ‚ÄúACTIVE PULLUP‚Äù mode (which is also implemented in primitives), the corresponding waveforms are listed below:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/e00/8c0/27d/e008c027d6734c1c8d55d7f54936f32a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Activating the ‚ÄúACTIVE PULLUP‚Äù mode after the last bit of the command has been transmitted (the channel B signal goes from low to high, after which the PULLUP activation signal also goes to the active state for no more than 10 ¬µs, applying the supply voltage to the signal bus through Q5). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/bb4/860/9ef/bb48609ef002493ab2614b2fd61dd9f4.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The same mode is ‚ÄúACTIVE PULLUP‚Äù, but on a smaller scale (command transmission, activation of PULLUP, deactivation of PULLUP and reading command with obtaining results). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/eae/92b/25a/eae92b25a96f4bc3a2feca5aef958cf6.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The end of the "ACTIVE PULLUP" mode with the transfer of the command to read the results in an enlarged form. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/279/723/c93/279723c9302c4c92823f63a16426aea0.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The RESET procedure (the first low level pulse on channel B, coinciding in duration with the high level pulse on channel C) followed by a PRESENCE from the device connected to the 1-Wire bus (the second low level pulse on channel B, when channel C also has a low level). </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/0f0/2ea/ab0/0f02eaab0f294ad39b5003690c6a7853.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The same, but after the end of the mode "ACTIVE PULLUP". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Question to readers: does it make sense to write a sequel, where will the implementation of 1-Wire exchange protocol commands be based on these primitives and the </font></font><a href="http://protothreads_rus/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">protothreads</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> library </font><font style="vertical-align: inherit;">? </font><font style="vertical-align: inherit;">In principle, everything is very simple there and is written just right away, peeping with one eye into the corresponding datasheet.</font></font><br><br>  Bibliography <br><br><ol><li> <a href="https://geektimes.ru/post/286374/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-Wire bus driver for power controllers less than 5V</font></font></a> </li><li> <a href="http://blog.gegg.us/2013/03/4-different-methods-of-1-wire-access-on-raspberry-pi/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Four methods for connecting 1-Wire devices to the Raspberry Pi</font></font></a> </li><li><a name="bitbang"></a> <a href="https://www.maximintegrated.com/en/app-notes/index.mvp/id/126"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-Wire Communication Through Software</font></font></a> </li><li><a name="i2c1wire"></a> <a href="https://www.maximintegrated.com/en/products/interface/controllers-expanders/DS28E17.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1-Wire-to-I2C Master Bridge</font></font></a> </li><li> <a href="https://www.maximintegrated.com/en/products/interface/controllers-expanders/DS2482-100.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Single-Channel 1-Wire Master</font></font></a> </li><li><a name="uart1wire"></a> <a href="https://www.maximintegrated.com/en/app-notes/index.mvp/id/214"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Using a UART to Implement a 1-Wire Bus Master</font></font></a> </li><li><a name="microsin"></a> <a href="http://microsin.ru/content/view/508/44"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here the fingers explain the functioning of 1-Wire devices (in Russian)</font></font></a> </li><li><a name="protothreads_eng"></a> <a href="http://dunkels.com/adam/pt/index.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protothreads by Adam Dunkels</font></font></a> </li><li><a name="protothreads_rus"></a> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Protothread and cooperative multitasking</font></font></a> </li><li> <a href="http://www.atmel.com/Images/Atmel-42735-8-bit-AVR-Microcontroller-ATmega328-328P_Datasheet.pdf"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ATmega328 / P datasheet</font></font></a> </li><li><a name="megapromini"></a> <a href="https://www.arduino.cc/en/Main/arduinoBoardProMini"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino PRO mini</font></font></a> </li><li><a name="mega2560"></a> <a href="https://www.arduino.cc/en/Main/arduinoBoardMega2560"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Arduino MEGA 2560</font></font></a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/322710/">https://habr.com/ru/post/322710/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../322700/index.html">The hunt for the mythical MVC. User Interface Building</a></li>
<li><a href="../322702/index.html">Mechanical Shakespeare: Are machines capable of literary creativity?</a></li>
<li><a href="../322704/index.html">Puzzle game Neo Angle. Work with levels in Unity</a></li>
<li><a href="../322706/index.html">Social bots: who, how and why use bots?</a></li>
<li><a href="../322708/index.html">Data Science Weekend March 3-4</a></li>
<li><a href="../322712/index.html">Arrested the alleged organizer of the MIRAI botnet attack on the provider Deutsche Telekom</a></li>
<li><a href="../322714/index.html">NetScaler Unified Gateway: a secure solution for applications through a single URL</a></li>
<li><a href="../322716/index.html">PyMC3 - MCMC and not only</a></li>
<li><a href="../322720/index.html">VLAN configuration on the routerOS operating system</a></li>
<li><a href="../322724/index.html">ClickHouse: very fast and very convenient</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>