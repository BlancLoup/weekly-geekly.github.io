<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create a parser for ini-files in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I will tell you how to write your ini-file parser in C ++. We take as a basis the context-free grammar built in my previous article . ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create a parser for ini-files in C ++</h1><div class="post__text post__text-html js-mediator-article">  In this article I will tell you how to write your ini-file parser in C ++.  We take as a basis the context-free grammar built <a href="http://avsmal.habrahabr.ru/blog/50973/">in my previous article</a> .  To build the parser, the <a href="http://spirit.sourceforge.net/">Boost Spirit</a> library will be used, which allows you to build your own parsers by combining ready-made <i>primitive</i> parsers using <i>parser combinators</i> . <br><br>  <b>Important:</b> this article assumes that the reader is familiar with the basics of C ++ (including the active use of STL).  If you are not very sure of yourself, then I advise you first to read a couple of articles for C ++ and STL beginners. <br><a name="habracut"></a><br><br><h2>  Grammar </h2><br>  First, let us recall which grammar for ini-files we built in the previous article: <br> <code>inidata = spaces, {section} . <br> section = "[", ident, "]", stringSpaces, "\n", {entry} . <br> entry = ident, stringSpaces, "=", stringSpaces, value, "\n", spaces . <br> ident = identChar, {identChar} . <br> identChar = letter | digit | "_" | "." | "," | ":" | "(" | ")" | "{" | "}" | "-" | "#" | "@" | "&amp;" | "*" | "|" . <br> value = {not "\n"} . <br> stringSpaces = {" " | "\t"} . <br> spaces = {" " | "\t" | "\n" | "\r"} . <br></code> <br>  We will need her description soon. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h2>  C ++ and Boost Spirit </h2><br><br>  Start by installing boost (you can take it on the official website or search for ready-made packages for your OS).  It is not necessary to collect the boost, since the whole Spirit lives in heders.  The installation process for different systems may be different, so I will not describe it here. <br><br>  I will try to describe in detail the process of creating a parser in C ++.  In this case, I will not particularly think about performance, since this is not the purpose of this article. <br><br>  Let's start by connecting the necessary headers. <br> <code>1 <font color="#ff6060"><b>#include</b></font> <font color="#0000ff">&lt;fstream&gt;</font> <br> 2 <font color="#ff6060"><b>#include</b></font> <font color="#0000ff">&lt;functional&gt;</font> <br> 3 <font color="#ff6060"><b>#include</b></font> <font color="#0000ff">&lt;numeric&gt;</font> <br> 4 <font color="#ff6060"><b>#include</b></font> <font color="#0000ff">&lt;list&gt;</font> <br> 5 <font color="#ff6060"><b>#include</b></font> <font color="#0000ff">&lt;vector&gt;</font> <br> 6 <font color="#ff6060"><b>#include</b></font> <font color="#0000ff">&lt;string&gt;</font> <br> 7 <br> 8 <font color="#ff6060"><b>#include</b></font> <font color="#0000ff">&lt;boost/spirit.hpp&gt;</font> <br> 9 <font color="#ff6060"><b>#include</b></font> <font color="#0000ff">&lt;boost/algorithm/string.hpp&gt;</font> <br> 10 <br> 11 <font color="#8080ff"><b>using</b></font> <font color="#00ff00"><b>namespace</b></font> std; <br> 12 <font color="#8080ff"><b>using</b></font> <font color="#00ff00"><b>namespace</b></font> boost::spirit; <br></code> <br>  In addition to the header of the Spirit itself, I included a library of string algorithms from boost (I will use the trim function).  The construction using namespace is not always a good practice, but here for brevity I will allow myself. <br><br>  We define data types: a record is a key ‚Äì value pair, a section is a key ‚Äì list of records pair, all ini-file data is a list of sections. <br> <code>14 <font color="#00ff00"><b>typedef</b></font> pair&lt;string, string&gt;    Entry; <br> 15 <font color="#00ff00"><b>typedef</b></font> list&lt;Entry &gt;            Entries; <br> 16 <font color="#00ff00"><b>typedef</b></font> pair&lt;string, Entries&gt;  Section; <br> 17 <font color="#00ff00"><b>typedef</b></font> list&lt;Section&gt;          IniData; <br></code> <br>  In addition to the data types, we will need event handlers that will be called when the parser parses the next non-terminal. <br> <code>19 <font color="#00ff00"><b>struct</b></font> add_section <br> 20 { <br> 21   add_section( IniData &amp; data ) : data_(data) {} <br> 22 <br> 23 <font color="#00ff00">void</font> <font color="#ff6060"><b>operator</b></font> ()( <font color="#00ff00">char</font> <font color="#00ff00">const</font> * p, <font color="#00ff00">char</font> <font color="#00ff00">const</font> * q) <font color="#00ff00">const</font> <br> 24   { <br> 25       string s(p,q); <br> 26       boost::algorithm::trim(s); <br> 27       data_.push_back( Section( s, Entries() ) ); <br> 28   } <br> 29 <br> 30   IniData &amp; data_; <br> 31 }; <br> 32 <br> 33 <font color="#00ff00"><b>struct</b></font> add_key <br> 34 { <br> 35   add_key( IniData &amp; data ) : data_(data) {} <br> 36 <br> 37 <font color="#00ff00">void</font> <font color="#ff6060"><b>operator</b></font> ()( <font color="#00ff00">char</font> <font color="#00ff00">const</font> * p, <font color="#00ff00">char</font> <font color="#00ff00">const</font> * q) <font color="#00ff00">const</font> <br> 38   { <br> 39       string s(p,q); <br> 40       boost::algorithm::trim(s); <br> 41       data_.back().second.push_back( Entry( s, string() ) ); <br> 42   } <br> 43 <br> 44   IniData &amp; data_; <br> 45 }; <br> 46 <br> 47 <font color="#00ff00"><b>struct</b></font> add_value <br> 48 { <br> 49   add_value( IniData &amp; data ) : data_(data) {} <br> 50 <br> 51 <font color="#00ff00">void</font> <font color="#ff6060"><b>operator</b></font> ()( <font color="#00ff00">char</font> <font color="#00ff00">const</font> * p, <font color="#00ff00">char</font> <font color="#00ff00">const</font> * q) <font color="#00ff00">const</font> <br> 52   { <br> 53       data_.back().second.back().second.assign(p, q); <br> 54   } <br> 55 <br> 56   IniData &amp; data_; <br> 57 }; <br></code> <br><br>  Event handlers are functors that take a piece of a string as input (through two pointers). <br>  The add_section functor will be called at the moment when the parser recognizes the next section.  As a parameter, add_section will receive the name of this section.  The add_key functor will be called at the moment when the parser recognizes the name of the new parameter.  The add_value functor will be called at the moment when the parser recognizes the value of the parameter.  Using these functors, sequential filling of IniData is organized: first an empty section is added (add_section), then an Entry with an empty value is added (add_key) to this section, and then this value is filled (add_value). <br><br>  Now we will transfer the grammar from the Backus-Naur notation to C ++.  To do this, create a special class inidata_parser. <br> <code>59 <font color="#00ff00"><b>struct</b></font> inidata_parser : <font color="#8080ff"><b>public</b></font> grammar&lt;inidata_parser&gt; <br> 60 { <br> 61   inidata_parser(IniData &amp; data) : data_(data) {} <br> 62 <br> 63 <font color="#00ff00"><b>template</b></font> &lt; <font color="#00ff00"><b>typename</b></font> ScannerT&gt; <br> 64 <font color="#00ff00"><b>struct</b></font> definition <br> 65   { <br> 66       rule&lt;ScannerT&gt; inidata, section, entry, ident, value, stringSpaces, spaces; <br> 67 <br> 68       rule&lt;ScannerT&gt; <font color="#00ff00">const</font> &amp; start() <font color="#00ff00">const</font> { <font color="#8080ff"><b>return</b></font> inidata; } <br> 69 <br> 70       definition(inidata_parser <font color="#00ff00">const</font> &amp; self) <br> 71       { <br> 72         inidata = *section; <br> 73 <br> 74         section = ch_p( <font color="#0000ff">'['</font> ) <br> 75               &gt;&gt; ident[add_section(self.data_)] <br> 76               &gt;&gt; ch_p( <font color="#0000ff">']'</font> ) <br> 77               &gt;&gt; stringSpaces <br> 78               &gt;&gt; ch_p( <font color="#0000ff">'\n'</font> ) <br> 79               &gt;&gt; spaces <br> 80               &gt;&gt; *(entry); <br> 81 <br> 82         entry =  ident[add_key(self.data_)] <br> 83               &gt;&gt; stringSpaces <br> 84               &gt;&gt; ch_p( <font color="#0000ff">'='</font> ) <br> 85               &gt;&gt; stringSpaces <br> 86               &gt;&gt; value[add_value(self.data_)] <br> 87               &gt;&gt; spaces; <br> 88 <br> 89 <br> 90         ident  = +(alnum_p | chset&lt;&gt;( <font color="#0000ff">"-_.,:(){}#@&amp;*|"</font> ) ); <br> 91 <br> 92         value = *(~ch_p( <font color="#0000ff">'\n'</font> )); <br> 93 <br> 94         stringSpaces = *blank_p; <br> 95 <br> 96         spaces = *space_p; <br> 97       } <br> 98 <br> 99   }; <br> 100 <br> 101   IniData &amp; data_; <br> 102 }; <br></code> <br>  This class encapsulates the entire grammar.  We will understand in more detail.  In line 59, we see that the parser is inherited from the grammar class template using crtp, which is necessary for Spirit to work properly.  The parser accepts a link to the empty IniData in the constructor and saves it (61).  Inside the parser you need to define a template structure definition (63-64).  The definition structure has data members of type rule ‚Äî these are the parsers for each of the non-terminals of our Backus-Naur grammar (66).  It is necessary to define a member function start, which will return a link to the main nonterminal - inidata (68). <br><br>  In the definition constructor, we describe the grammar.  Grammar is rewritten in C ++ almost verbatim.  inidata consists of several sections (72) - this is expressed by an asterisk (as the wedge closure, but the asterisk to the left).  The section starts with a square bracket - for this, the built-in parser ch_p is used, which parses one character.  Instead of a comma from the Backus-Naur notation, use the &gt;&gt; operator.  The event handler functor is written in square brackets after the expression (75, 82, 86).  The symbol "+" on the left means "at least one", and "~" means negation.  alnum_p - built-in parser for letters and numbers.  chset &lt;&gt; matches any character from a string (it is important that the minus comes first, otherwise it is perceived as an interval sign, like ‚Äúaz‚Äù).  blank_p matches the space character in the string (space or tab), space_p matches any space character (including both line feed and carriage return). <br><br>  Note that the nonterminals of ident and identChar were merged into one thanks to the ‚Äú+‚Äù operator ‚Äî in Backus-Naur notation, this was impossible, since  there is no such designation. <br><br>  With grammar everything.  It remains to learn how to delete comments and search for values ‚Äã‚Äãin IniData. <br>  To delete comments, we need a special functor. <br> <code>104 <font color="#00ff00"><b>struct</b></font> is_comment{ <font color="#00ff00">bool</font> <font color="#ff6060"><b>operator</b></font> ()( string <font color="#00ff00">const</font> &amp; s ) <font color="#00ff00">const</font> { <font color="#8080ff"><b>return</b></font> s[ <font color="#0000ff">0</font> ] == <font color="#0000ff">'\n'</font> || s[ <font color="#0000ff">0</font> ] == <font color="#0000ff">';'</font> ; } }; <br></code> <br>  Now let's write the search function in IniData. <br> <code>106 <font color="#00ff00"><b>struct</b></font> first_is <br> 107 { <br> 108     first_is(std::string <font color="#00ff00">const</font> &amp; s) : s_(s) {} <br> 109 <br> 110 <font color="#00ff00"><b>template</b></font> &lt; <font color="#00ff00"><b>class</b></font> Pair &gt; <br> 111 <font color="#00ff00">bool</font> <font color="#ff6060"><b>operator</b></font> ()(Pair <font color="#00ff00">const</font> &amp; p) <font color="#00ff00">const</font> { <font color="#8080ff"><b>return</b></font> p.first == s_; } <br> 112 <br> 113     string <font color="#00ff00">const</font> &amp; s_; <br> 114 }; <br> 115 <br> 116 <font color="#00ff00">bool</font> find_value( IniData <font color="#00ff00">const</font> &amp; ini, string <font color="#00ff00">const</font> &amp; s, string <font color="#00ff00">const</font> &amp; p, string &amp; res ) <br> 117 { <br> 118     IniData::const_iterator sit = find_if(ini.begin(), ini.end(), first_is(s)); <br> 119 <font color="#8080ff"><b>if</b></font> (sit == ini.end()) <br> 120 <font color="#8080ff"><b>return</b></font> <font color="#0000ff">false</font> ; <br> 121 <br> 122     Entries::const_iterator it = find_if(sit-&gt;second.begin(), sit-&gt;second.end(), first_is(p)); <br> 123 <font color="#8080ff"><b>if</b></font> (it == sit-&gt;second.end()) <br> 124 <font color="#8080ff"><b>return</b></font> <font color="#0000ff">false</font> ; <br> 125 <br> 126     res = it-&gt;second; <br> 127 <font color="#8080ff"><b>return</b></font> <font color="#0000ff">true</font> ; <br> 128 } <br></code> <br>  Instead of the functor first_is, you can use boost :: bind, but I decided not to interfere with everything in one heap.  The search is simple: first in the list we look for a section by name, then in the list of section records we look for a parameter by name, and, if everything is found, then we return the value of the parameter through the link parameter. <br><br>  It remains to write the main. <br> <code>130 <font color="#00ff00">int</font> main( <font color="#00ff00">int</font> argc, <font color="#00ff00">char</font> ** argv) <br> 131 { <br> 132 <font color="#8080ff"><b>if</b></font> ( argc != <font color="#0000ff">4</font> ) <br> 133   { <br> 134       cout &lt;&lt; <font color="#0000ff">"Usage: "</font> &lt;&lt; argv[ <font color="#0000ff">0</font> ] &lt;&lt; <font color="#0000ff">" &lt;file.ini&gt; &lt;section&gt; &lt;parameter&gt;"</font> &lt;&lt; endl; <br> 135 <font color="#8080ff"><b>return</b></font> <font color="#0000ff">0</font> ; <br> 136   } <br> 137 <br> 138   ifstream in(argv[ <font color="#0000ff">1</font> ]); <br> 139 <font color="#8080ff"><b>if</b></font> ( !in ) <br> 140   { <br> 141       cout &lt;&lt; <font color="#0000ff">"Can't open file</font> <font color="#0000ff">\"</font> <font color="#0000ff">"</font> &lt;&lt; argv[ <font color="#0000ff">1</font> ] &lt;&lt; <font color="#0000ff">'\"'</font> &lt;&lt; endl; <br> 142 <font color="#8080ff"><b>return</b></font> <font color="#0000ff">1</font> ; <br> 143   } <br> 144 <br> 145   vector&lt; string &gt; lns; <br> 146 <br> 147   std::string s; <br> 148 <font color="#8080ff"><b>while</b></font> ( !in.eof() ) <br> 149   { <br> 150       std::getline( in, s ); <br> 151       boost::algorithm::trim(s); <br> 152       lns.push_back( s+= <font color="#0000ff">'\n'</font> ); <br> 153   } <br> 154   lns.erase( remove_if(lns.begin(), lns.end(), is_comment()), lns.end()); <br> 155   string text = accumulate( lns.begin(), lns.end(), string() ); <br> 156 <br> 157   IniData data; <br> 158   inidata_parser parser(data); //  Our parser <br> 159   BOOST_SPIRIT_DEBUG_NODE(parser); <br> 160 <br> 161   parse_info&lt;&gt; info = parse(text.c_str(), parser, nothing_p); <br> 162 <font color="#8080ff"><b>if</b></font> (!info.hit) <br> 163   { <br> 164       cout &lt;&lt; <font color="#0000ff">"Parse error</font> <font color="#0000ff">\n</font> <font color="#0000ff">"</font> ; <br> 165 <font color="#8080ff"><b>return</b></font> <font color="#0000ff">1</font> ; <br> 166   } <br> 167 <br> 168   string res; <br> 169 <font color="#8080ff"><b>if</b></font> (find_value(data, argv[ <font color="#0000ff">2</font> ], argv[ <font color="#0000ff">3</font> ], res)) <br> 170       cout &lt;&lt; res; <br> 171 <font color="#8080ff"><b>else</b></font> <br> 172       cout &lt;&lt; <font color="#0000ff">"Can't find requested parameter"</font> ; <br> 173   cout &lt;&lt; endl; <br> 174 } <br></code> <br><br>  Lines 132-136 - we check the program parameters: if there are not 4 of them, then we output the usage.  If everything is OK with the parameters, then open the file (138-143).  If everything is fine with the file, then we create an array of strings lns (145) and read the entire file into it (147-153).  After that, we delete the comments from there using the is_comment funded functor (154).  In conclusion, we glue all the lines into one (155). <br><br>  In lines 157-159 a parser is created and initialized.  Now we start the parser - the parse function is used for this, which accepts the text itself, the parser and a special parser for the passed characters (for example, we would like to skip all spaces).  In our case, the parser for the passed characters will be empty - nothing_p (i.e., nothing without parsing).  The result of the parse function is the parse_info &lt;&gt; structure.  We are interested in the boolean field hit of this structure, which is true if no errors occurred.  In lines 162-166, we report if an error has occurred.  It remains only to find the parameter specified in the command line and display its value (168-173). <br><br>  Now the code is completely written.  Compile it and run it on a test sample. <br> <code>$ g++ ini.cpp -o ini_cpp <br> <br> $ ./ini_cpp /usr/lib/firefox-3.0.5/application.ini App ID <br> {ec8030f7-c20a-464f-9b0e-13a3a9e97384} <br> <br> $ ./ini_cpp /usr/lib/firefox-3.0.5/application.ini App IDD <br> Can't find requested parameter <br></code> <br><br>  I hope that this article will help you write your own parser =) <br><br>  <b>An interesting note:</b> you can compare the parser from this article with the Haskell parser from the article <a href="http://habrahabr.ru/blogs/Haskell/50337/">‚ÄúCreate a parser for ini-files in Haskell‚Äù</a> . <br><br>  Ps.  Thanks for helping move this article to the C ++ blog. </div><p>Source: <a href="https://habr.com/ru/post/50976/">https://habr.com/ru/post/50976/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../50965/index.html">Crackulous: a simple program for hacking iPhone applications</a></li>
<li><a href="../50967/index.html">Fall in love with F #: Dose 0: Why do we need another programming language?</a></li>
<li><a href="../50968/index.html">Microsoft invites students to participate in the student conference "Microsoft Technologies in Theory and Practice of Programming"</a></li>
<li><a href="../50969/index.html">Paid links to exler.ru?</a></li>
<li><a href="../50973/index.html">We create a parser for ini-files. Theory</a></li>
<li><a href="../50977/index.html">MyRambler - test version</a></li>
<li><a href="../50979/index.html">First release of StartupIndex Review</a></li>
<li><a href="../50982/index.html">Encrypt messages on the XMPP / Jabber network using PGP</a></li>
<li><a href="../50983/index.html">Yes, how much can you?</a></li>
<li><a href="../50985/index.html">Implementation of the exception mechanism using the C language</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>