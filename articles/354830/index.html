<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to detect FinFisher. ESET Manual</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Thanks to serious countermeasures against analysis, FinFisher spyware remained poorly understood. This is a well-known surveillance tool, however, onl...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to detect FinFisher. ESET Manual</h1><div class="post__text post__text-html js-mediator-article">  Thanks to serious countermeasures against analysis, FinFisher spyware remained poorly understood.  This is a well-known surveillance tool, however, only a partial analysis was published from previous samples. <br><br>  The situation began to change in the summer of 2017 after the analysis of FinFisher cyber espionage campaigns by ESET.  During the study, we identified attacks <a href="https://habr.com/company/eset/blog/338422/">involving the compromise of the victims of the Internet provider</a> . <br><br><img src="https://habrastorage.org/webt/p7/sw/eg/p7swegz14e1t20gjwcl7hu9u2ag.jpeg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      When we began the analysis of Malvari, the main efforts were spent on overcoming measures to counter the analysis of FinFisher in its versions under Windows.  The combination of advanced obfuscation and proprietary virtualization makes the removal of masking with FinFisher extremely difficult. <br><br>  In this guide, we share what we learned from the FinFisher analysis process.  In addition to analyzing the FinFisher virtual machine, the guide will help you understand protection using the virtual machine as a whole, that is, proprietary virtual machines found in the binary code and used to protect the software. <br><a name="habracut"></a><br>  We also analyzed the versions of FinFisher for Android, whose protection mechanism is based on the open access LLVM obfuscator.  It is not as complicated and interesting as the versioning mechanism for Windows, so we will not discuss it in this manual. <br><br>  We hope that the guide will be useful to information security researchers and virus analysts to understand the tools and tactics of FinFisher, as well as to protect customers from this threat. <br><br><h2>  Measures against disassembly </h2><br>  Opening the FinFisher sample in IDA Pro, we notice in the main function a simple but effective method of countering disassembling, the first defense. <br><br>  FinFisher uses a common technique against disassembling - hiding the course of execution by replacing one unconditional jump command with two complementary conditional jumps.  They indicate the same transition point, therefore, regardless of the transition being performed, the order of code execution does not change.  After the conditional transitions are meaningless bytes of code.  They are designed to confuse the disassembler, since under normal conditions it will not be able to recognize the non-working area and will continue to work on disassembling this garbage. <br><br>  This way of using this technique makes this feature special.  In most malware that we have studied, the method is used a certain number of times.  However, FinFisher applies this trick after each command. <br><br>  This protection is very effective against the disassembler and confuses it so that many sections of the code do not go through the process properly.  And, of course, the graphical mode in IDA Pro becomes impossible to use.  Our first task is to get rid of this protection. <br>  The code was obviously obfuscated not manually, but with the help of an automatic tool, and we observe a certain pattern in all pairs of transition commands. <br><br>  There are two different types of transition pairs ‚Äî an internal transition with an indent of 32 bits and a short transition with an indent of 8 bits. <br><br>  The operation code of both conditional internal transitions (where DWORD is the indent of the transition) begins with byte 0x0F, and the second byte equals 0x8?, Where?  in both commands, the transitions differ only by 1 bit.  This is due to the fact that the OS x86 opcodes for complementary transitions are consecutive in numerical terms.  For example, this obfuscation scheme always binds JE with JNE (opcodes 0x0F 0x84 and 0x0F 0x85), JP with JNP (opcodes 0x0F 0x8A and 0x0F 0x8B), and so on. <br><br>  After these opcodes, there is a 32-bit argument defining the indent where the transition will take place.  Since the size of both commands is 6 bytes, the indents of two consecutive transitions differ exactly by 6 (see Figure 1). <br><br><img src="https://habrastorage.org/webt/3x/gp/ng/3xgpngyt9zkibcorzeyvsg56rtw.png"><br>  <i>Figure 1. Screenshot of the teams, after which two conditional internal transitions follow each time</i> <br><br>  For example, the code below can be used to detect these two consecutive transitions: <br><br><pre><code class="hljs kotlin">def is_jump_near_pair(addr): jcc1 = <span class="hljs-built_in"><span class="hljs-built_in">Byte</span></span>(addr+<span class="hljs-number"><span class="hljs-number">1</span></span>) jcc2 = <span class="hljs-built_in"><span class="hljs-built_in">Byte</span></span>(addr+<span class="hljs-number"><span class="hljs-number">7</span></span>) #      ? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Byte</span></span>(addr) != <span class="hljs-number"><span class="hljs-number">0x0F</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">Byte</span></span>(addr+<span class="hljs-number"><span class="hljs-number">6</span></span>) != <span class="hljs-number"><span class="hljs-number">0x0F</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False #   <span class="hljs-number"><span class="hljs-number">2</span></span>    ? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (jcc1 &amp; <span class="hljs-number"><span class="hljs-number">0xF0</span></span> != <span class="hljs-number"><span class="hljs-number">0x80</span></span>) || (jcc2 &amp; <span class="hljs-number"><span class="hljs-number">0xF0</span></span> != <span class="hljs-number"><span class="hljs-number">0x80</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False #     ? <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> abs(jcc1-jcc2) != <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False #        ? dst1 = Dword(addr+<span class="hljs-number"><span class="hljs-number">2</span></span>) dst2 = Dword(addr+<span class="hljs-number"><span class="hljs-number">8</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dst1-dst2 != <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> False <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> True</code> </pre> <br>  De-fussing short transitions is based on a similar idea, only the constants differ. <br><br>  The opcode of the short conditional jump is 0x7 ?, followed by one byte - the jump indent.  Therefore, again we are looking for two consecutive conditional internal transitions, and we need opcodes: 0x7 ?;  indent;  0x7?  ¬± 1;  indent -2.  After the first opcode, there is one byte, differing by 2 in two successive transitions (which, again, are the size of both commands) (Figure 2). <br><br><img src="https://habrastorage.org/webt/zb/_f/ir/zb_fircltxw8wz4kcbqmnxvz2ty.png"><br>  <i>Figure 2. Examples of commands, followed by two short conditional transitions each time.</i> <br><br>  For example, this code can be used to detect two conditional short transitions: <br><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_jcc8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b&amp;<span class="hljs-number"><span class="hljs-number">0xF0</span></span> == <span class="hljs-number"><span class="hljs-number">0x70</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_jump_short_pair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span><span class="hljs-function">:</span></span> jcc1 = Byte(addr) jcc2 = Byte(addr+<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> is_jcc8(jcc1) || <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> is_jcc8(jcc2): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> abs(jcc2‚Äìjcc1) != <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> dst1 = Byte(addr+<span class="hljs-number"><span class="hljs-number">1</span></span>) dst2 = Byte(addr+<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dst1 ‚Äì dst2 != <span class="hljs-number"><span class="hljs-number">2</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span></code> </pre> <br>  After detecting one of these pairs of conditional transitions, we de-code the code with a patch, turning the first conditional transition into an unconditional (using opcode 0xE9 for internal transition pairs and 0xEB for short transition pairs) and filling the remaining bytes with empty commands (0x90) <br><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patch_jcc32</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span></span>: PatchByte(addr, <span class="hljs-number"><span class="hljs-number">0x90</span></span>) PatchByte(addr+<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0xE9</span></span>) PatchWord(addr+<span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">0x9090</span></span>) PatchDword(addr+<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">0x90909090</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patch_jcc8</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span></span>: PatchByte(addr, <span class="hljs-number"><span class="hljs-number">0xEB</span></span>) PatchWord(addr+<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0x9090</span></span>)</code> </pre> <br>  In addition to these two situations, there may be places where a pair of transitions consists of short and internal, that is, of different types.  But this is only found in a few places, so in the FinFisher samples this can be corrected manually. <br><br>  Using these inserts, IDA Pro begins to ‚Äúunderstand‚Äù the new code and is ready (well, or almost ready) to create a diagram.  It may happen that we need to make another improvement: add endings, that is, assign the node with the transition position, so that it coincides with the transition command on the chart.  For this purpose, we can use the IDA Python function <code>append_func_tail</code> . <br><br>  The final step in circumventing the tricks that interfere with the disassembler‚Äôs normal operation is to correct the definitions of the functions.  It may happen that the command after the transition will be <code>push ebp</code> , in which case IDA Pro (erroneously) considers this the beginning of the function and, accordingly, begins its new definition.  In this case, we need to delete the function definition, make a correct entry and add more endings. <br>  Thus, we remove the first level of protection FinFisher, designed against disassembling. <br><br><h2>  FinFisher virtual machine </h2><br>  After the successful deobfusion of the first level of protection, the main function opens to us, the sole purpose of which is to launch a specially created virtual machine and its further use to interpret the baytkod with, actually, the payload. <br><br>  Unlike a regular executable file, an executable file with a virtual machine internally uses a set of virtualized commands instead of directly executing processor commands.  Virtualized commands are executed by a virtual processor, which has its own structure and does not convert bytecode to unmanaged machine code.  This virtual processor, like bytecode (and virtual commands), is determined by who programs the virtual machine (Figure 3). <br><br>  In the introduction, we said that one of the famous examples of a virtual machine is a Java VM.  But in this case, the virtual machine is inside the binary code, so here we are confronted with a virtual machine to protect against reverse engineering.  There are well-known commercial protections using a virtual machine, such as VMProtect and Code Virtualizer. <br><br>  FinFisher spyware is compiled from source, and then the resulting binary file is protected by the virtual machine at the assembler level.  The protection process involves translating the instructions of the original binary file into virtual instructions, and then creating a new binary file containing the bytecode and virtual processor.  Native instructions from the source binary file are lost.  A secure, virtualized pattern must have the same behavior as an unprotected pattern. <br><br>  To analyze a binary file protected by a virtual machine, the following is necessary: <br><br><ol><li>  Analyze Virtual CPU </li><li>  Write your own disassembler for this nonstandard virtual CPU and parse bytecode </li><li>  Optionally: compile the disassembled code into a binary file, getting rid of the virtual machine. </li></ol><br>  The first two tasks take a lot of time, and the first one can become quite complicated.  It includes the analysis of each <i>vm_handler</i> handler and an understanding of how registers, memory access, calls, and so on are transmitted. <br><br><img src="https://habrastorage.org/webt/y0/2g/ee/y02gee7erdjbos-k-hi-dqjm47w.png"><br>  <i>Figure 3. Bytecode interpreted by the virtual CPU</i> <br><br><h3>  Terms and Definitions </h3><br>  There is no standard for defining individual parts of a virtual machine.  Therefore, we will define some terms that we will refer to in this work: <br><br><ul><li>  Virtual machine (vm) ‚Äìvirtual CPU;  contains <i>vm_dispatcher, vm_start, vm_handlers</i> </li><li>  <i>vm_start</i> - initialization;  there is a memory allocation and decryption process </li><li>  Bytecode (also known as pcode) - virtual <i>vm_instructions</i> with arguments are stored here </li><li>  <i>vm_dispatcher</i> - calls and decodes virtual opcodes;  essentially prepares for the execution of any of the <i>vm_handlers</i> </li><li>  <i>vm_handler</i> - implementation of <i>vm_instruction</i> ;  execution of one <i>vm_handler</i> means execution of one <i>vm_instruction</i> </li><li>  Interpreter (also known as <i>vm_loop</i> ) - <i>vm_dispatcher</i> + <i>vm_handlers</i> - virtual CPU </li><li>  Virtual opcode is an analogue of native opcodes </li><li>  <i>vm_context</i> ( <i>vm_structure</i> ) - the internal structure used by the interpreter </li><li>  <i>vi_params</i> - structure within the structure <i>vm_context</i> ;  virtual command parameters used by <i>vm_handler</i> ;  includes <i>vm_opcode</i> and arguments </li></ul><br>  During the interpretation of the bytecode, the virtual machine uses a virtual stack and a single virtual register: <br><br><ul><li>  <i>vm_stack</i> - analogous to the native stack used by the virtual machine </li><li>  <i>vm_register</i> is an analogue of the native register used by this virtual machine;  hereinafter called tmp_REG </li><li>  <i>vm_instruction</i> - a command defined by the developers of the virtual machine;  the body (implementation) of a command is called by its <i>vm_handler</i> </li></ul><br>  In the following sections, we will describe the elements of a virtual machine in technical details and describe how to analyze them. <br><br>  The deobfuscated graphical representation of the main function of Malvaris consists of three parts: initialization and the other two, which we called <i>vm_start</i> and interpreter ( <i>vm_dispatcher</i> + <i>vm_handlers</i> ). <br><br>  The initialization component sets a unique identifier for what can be interpreted as a bytecode entry point and pushes it onto the stack.  Then comes the transition to the <i>vm_start</i> part, that is, the initialization process of the virtual machine itself.  The decoding of the bytecode occurs and control passes to <i>vm_dispatcher</i> , which starts the cycles of virtual bytecode commands and interprets them with the help of <i>vm_handlers</i> . <br><br>  The <i>vm_dispatcher</i> is <i>launched</i> from the pusha command and ends with the <code>jmp dword ptr [eax+ecx*4]</code> command (or similar), that is, by switching to the corresponding <i>vm_handler</i> . <br><br><h3>  Vm_start </h3><br>  The graphical model created after de-fussing the first level is shown in Figure 4. The part related to <i>vm_start</i> is not so important for the analysis of the interpreter.  However, it helps to understand the implementation of the virtual machine as a whole, how it uses and manages the virtual flags, the virtual stack, etc.  The second part, <i>vm_dispatcher</i> with <i>vm_handlers</i> , is the base. <br><br><img src="https://habrastorage.org/webt/oo/17/fw/oo17fwvzxa0ig8vfdayqjogfovw.png"><br>  <i>Figure 4. Graphic representation of vm_start and vm_dispatcher</i> <br><br>  The call to <i>vm_start is</i> made from almost every function, including the main one. <br><br>  The calling function always pushes the virtual identifier and then makes the transition to <i>vm_start</i> .  Each virtual team has its own virtual identifier.  In this example, the identifier of the virtual entry point, where the execution from the main function starts from, is 0x21CD0554 (Figure 5). <br><br><img src="https://habrastorage.org/webt/al/-g/pg/al-gpgdrl7vwbdomz-zjmvltefw.png"><br>  <i>Figure 5. vm_start is called from each of the 119 virtualized functions.</i> <br><br>  The identifier of the first virtual command of the corresponding function is given as an argument. <br><br>  In this part, most of the code is devoted to preparing the <i>vm_dispatcher</i> - mainly bytecode and memory allocation for the entire interpreter.  The most important pieces of code do the following: <br><br><ol><li>  Allocation for bytecode and several variables 1 MB of memory with permission to read, write and execute. </li><li>  Allocating 0x10000 bytes with the same resolution for local variables in the virtual machine for the current task chain - <i>vm_stack</i> . </li><li>  XOR (exclusive OR) decoding.  The decrypted code is unpacked as aPLib.  The decryption process in the sample uses a slightly modified version of the XOR dword key.  He skips the first six dwords and then applies the XOR to the remaining five dwords using the key.  Below is the process algorithm (hereinafter, we call it XOR decryption_code): <br><br><pre> <code class="hljs pgsql"> <span class="hljs-type"><span class="hljs-type">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">6</span></span>]; <span class="hljs-type"><span class="hljs-type">int</span></span> key; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">6</span></span>; i++) { <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[i] ^= key; }</code> </pre> </li><li>  Call to the aPLib process to unpack the bytecode.  After it, the virtual opcodes still remain encrypted (Figure 6). </li></ol><br>  The preparation of virtual opcodes (steps 1, 3 and 4) is performed only once, at the beginning, and is skipped in subsequent versions of <i>vm_start</i> , while only commands for using flags and registers are executed. <br><br><img src="https://habrastorage.org/webt/on/ar/o3/onaro3pkjat5id3hwofaltfoqas.png"><br>  <i>Figure 6. All code from vm_start to vm_dispatcher is grouped and named depending on the destination.</i> <br><br><h2>  FinFisher Interpreter </h2><br>  This part includes the <i>vm_dispatcher</i> with all the <i>vm_handlers</i> (34 in FinFisher samples) and is an important element for analyzing and / or virtualizing the virtual machine.  The interpreter executes bytecode. <br><br>  The <code>jmp dword ptr [eax+ecx*4]</code> command jumps to one of the 34 <i>vm_handlers</i> .  Each <i>vm_handler</i> implements one virtual machine command.  To understand what each of the <i>vm_handler does</i> , you need to deal with <i>vm_context</i> and <i>vm_dispatcher</i> . <br><br><h4>  1. Creating a graphical structure in IDA </h4><br>  Better understand the interpreter will help create a well-structured diagram.  We recommend its division into two parts - <i>vm_start</i> and <i>vm_dispatcher</i> , that is, you need to define the beginning of the function in the first <i>vm_dispatcher command</i> .  In this case, the <i>vm_handlers</i> themselves <i>referenced</i> by <i>vm_dispatcher</i> are still missing.  You can use the following function to connect these handlers to the <i>vm_dispatcher</i> diagram: <br><br><pre> <code class="hljs lisp">AddCodeXref(<span class="hljs-name"><span class="hljs-name">addr_of_jmp_instr</span></span>, vm_handler,XREF_USER|fl_JN)</code> </pre> <br>  add to the top of the <i>vm_handlers</i> links of the last <i>vm_dispatcher command</i> <br><br><pre> <code class="hljs">AppendFchunk</code> </pre> <br>  produces an addition at the end <br><br>  After adding each <i>vm_handler</i> handler to the dispatcher function, the diagram looks like that shown in Figure 7 below. <br><br><h4>  2. Vm_dispatcher </h4><br>  This part is responsible for processing and decoding bytecode.  She performs the following steps: <br><br><ul><li>  <code>pusha</code> and <code>pusf</code> to prepare virtual registers and virtual flags for the subsequent execution of virtual commands. </li><li>  Gets the address of the program in memory and the address of <i>vm_stack</i> </li><li>  Reads 24 bytes of bytecode defining the next <i>vm_instruction</i> command and its arguments </li><li>  Decrypts bytecode using the previously described XOR procedure. </li><li>  Adds the program address in memory as an argument in bytecode if the argument is a global variable. </li><li>  Receives a virtual opcode (a number in the range of 0-33) from the decrypted bytecode </li><li>  Makes a transition to the appropriate <i>vm_handler</i> handler that interprets the virtual opcode. </li></ul><br>  After the <i>vm_handler</i> for the command is executed, the same sequence is repeated for the one that follows it, starting with the first <i>vm_dispatcher command</i> .  In the case of the <i>vm_call</i> handler <i>,</i> control is passed to <i>vm_start</i> (except when followed by a non-virtualized function). <br><br><img src="https://habrastorage.org/webt/w2/p2/hl/w2p2hlssg6bmrczqndequdt7zam.png"><br>  <i>Figure 7. The vm_dispatcher diagram with all 34 vm_handlers.</i> <br><br><h4>  3. Vm_context </h4><br>  In this part, we describe the <i>vm_context</i> - the structure used by the virtual machine, containing all the information necessary for the execution of the <i>vm_dispatcher</i> and each <i>vm_handler</i> . <br><br>  When we study the <i>vm_dispatcher</i> and <i>vm_handlers</i> code in more detail, we can see that it contains commands related to data processing that refer to <code>ebx+offset</code> , where offset is a number from 0x00 to 0x50.  In Figure 8, you can see what the main part of vm_handler 0x05 looks like in one of the FinFisher samples. <br><br><img src="https://habrastorage.org/webt/nv/n-/3d/nvn-3dlzwuammlx6vp1sxjdksbk.png"><br>  <i>Figure 8. Screenshot of one of the vm_handlers</i> <br><br>  The ebx register points to the structure we called <i>vm_context</i> .  We need an understanding of how this structure is used - what its members are, what they mean, and how they are applied.  To solve this problem for the first time, you will have to guess how <i>vm_context</i> and its parts are used. <br><br>  For example, let's look at the sequence of commands at the end of <i>vm_dispatcher</i> : <br><br><pre> <code class="hljs cs">movzx ecx, <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> ptr [ebx+<span class="hljs-number"><span class="hljs-number">0x3C</span></span>] <span class="hljs-comment"><span class="hljs-comment">//   vm_handler jmp dword ptr [eax+ecx*4] //     34 vm_handlers</span></span></code> </pre> <br>  Since we know that the last command is a transition to <i>vm_handler</i> , we can conclude that ecx contains a virtual opcode, and therefore the 0x3C vm_struct element refers to a virtual opcode. <br><br>  Let's make another unfounded assumption.  At the end of almost every vm_handler there is the following command: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> dword ptr [ebx], <span class="hljs-number"><span class="hljs-number">0x18</span></span>.</code> </pre> <br>  The same <i>vm_context</i> element was used earlier in the <i>vm_dispatcher</i> code - just before going to <i>vm_handler</i> .  <i>vm_dispatcher</i> copies 24 bytes from a structure element to another location ( <code>[ebx+38h]</code> ) and decrypts it by XOR in order to get part of the current bytecode. <br><br>  That is, we can start to consider the <i>vm_context</i> ( <code>[ebx+0h]</code> ) element as the <i>vm_instruction_pointer</i> pointer, and the decoded position (from <code>[ebx+38h]</code> to <code>[ebx+50h]</code> ) as the virtual team ID, its virtual opcode and arguments.  We gave the name <i>vi_params to</i> all this structure. <br><br>  After performing the steps above and using the debugging program, we see which values ‚Äã‚Äãare contained in the corresponding elements of the structure, that is, we can define all the elements of <i>vm_context</i> . <br><br>  After analysis, we can restore the structures and <i>vm_context</i> , and <i>FinFisher's vi_params</i> : <br><br><pre> <code class="hljs ruby">struct vm_context { DWORD vm_instruct_ptr; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     DWORD vm_stack; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  vm_stack DWORD tmp_REG; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   ‚Äú‚Äù    DWORD vm_dispatcher_loop; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  vm_dispatcher DWORD cleanAndVMDispatchFn; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,       vm_dispatcher,     DWORD cleanUpDynamicCodeFn; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,  vm_instr_ptr   cleanAndVMDispatchFn DWORD jmpLoc1; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     DWORD jmpLoc2; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   vm_opcode ‚Äì    vm_instruction DWORD Bytecode_start; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>       DWORD DispatchEBP; DWORD ImageBase; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     DWORDESP0_flags;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  (  vm_code) DWORDESP1_flags;<span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  DWORD LoadVOpcodesSectionFn; vi_params bytecode; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     vm_handler,  DWORD limitForTopOfStack; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   }; struct vi_params { DWORD Virtual_instr_id; DWORD OpCode; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> values <span class="hljs-number"><span class="hljs-number">0</span></span> ‚Äì <span class="hljs-number"><span class="hljs-number">33</span></span> -&gt; ,    DWORD Arg<span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>  dword  vm_handler DWORD Arg4; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    DWORD Arg8; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    DWORD ArgC; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    };</code> </pre><br><h4>  4. Use of virtual teams - vm_handlers </h4><br>  Each <i>vm_handler</i> operates with one virtual opcode, that is, 34 <i>vm_handlers</i> handlers <i>account</i> for a maximum of 34 virtual opcodes.  Execution of one <i>vm_handler</i> means execution of one <i>vm_instruction</i> , therefore, to determine what <i>vm_instruction</i> performs, we need to analyze the corresponding <i>vm_handler</i> . <br><br>  After the reconstruction of <i>vm_context</i> and the name of all indents in ebx, the previously shown vm_handler becomes more readable, it is shown in Figure 9. <br>  At the end of this function, we notice a sequence of commands starting with <i>vm_instruction_pointer</i> , which increases by 24, that is, by the size of the <i>vi_params</i> structure of each of the <i>vm_instruction</i> .  Since this sequence is repeated at the end of almost every <i>vm_handler,</i> we conclude that this is the standard terminating function code, and the <i>vm_handler</i> body <i>itself</i> can be written simply as: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> [tmp_REG], Arg0</code> </pre> <br>  So, we have just analyzed the first command of this virtual machine :-) <br><br><img src="https://habrastorage.org/webt/6n/nl/pz/6nnlpzrwmtn3xpm_twmz81gqvpm.png"><br>  <i>Figure 9. Previous vm_handler after inserting into vm_context structure</i> <br><br>  To illustrate the operation of the analyzed command, let us assume that the filling of the vi_params structure is performed as follows: <br><br><pre> <code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vi_params</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">DWORD</span></span> <span class="hljs-type"><span class="hljs-type">ID_of_virt_instr</span></span> =  ,   ; <span class="hljs-type"><span class="hljs-type">DWORD</span></span> <span class="hljs-type"><span class="hljs-type">OpCode</span></span> = <span class="hljs-number"><span class="hljs-number">0x0C</span></span>; <span class="hljs-type"><span class="hljs-type">DWORD</span></span> <span class="hljs-type"><span class="hljs-type">Arg0</span></span> = <span class="hljs-number"><span class="hljs-number">0x42</span></span>; <span class="hljs-type"><span class="hljs-type">DWORD</span></span> <span class="hljs-type"><span class="hljs-type">Arg4</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">DWORD</span></span> <span class="hljs-type"><span class="hljs-type">Arg8</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-type"><span class="hljs-type">DWORD</span></span> <span class="hljs-type"><span class="hljs-type">ArgC</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span>; };</code> </pre> <br>  From the above, we see that the following command is executed: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> [tmp_REG], 0x42</code> </pre> <br>  At this stage, we should already understand what one of the <i>vm_instructions performs</i> .  The perfect steps should serve as a demonstration of the work of the entire interpreter. <br><br>  However, there are some <i>vm_handlers</i> that are more difficult to analyze.  Conditional jumps of this virtual machine are more difficult to understand because of how the flags are converted. <br><br>  As noted earlier, <i>vm_dispatcher</i> starts with getting native EFLAGS (from <i>vm_code</i> ) to the top of its own stack.  Thus, when the handler of the corresponding transition decides whether or not to perform it, it is checked against EFLAGS on its own stack and applies its own transition method.  Figure 10 illustrates how the JNP (Jump if no parity) virtual handler is applied through parity check. <br><br><img src="https://habrastorage.org/webt/r0/k1/v8/r0k1v8np5s5rq8fv_ymiivx5kz4.png"><br>  <i>Figure 10. Screenshot of JNP_handler</i> <br><br>  For the remaining virtual conditional transitions, it may be necessary to check several signs ‚Äî for example, the result of a virtualized JBE transition (Jump if below or equal) depends on both values, the carry flag and the zero flag, but the principle is the same. <br><br>  After analyzing all 34 <i>vm_handlers</i> in the <i>FinFisher</i> virtual machine, we can describe its virtual commands as follows: <br><br><img src="https://habrastorage.org/webt/ec/cx/wf/eccxwf0fz3aeadzeci2hn3brtgm.png"><br>  <i>Figure 11. vm_table with all 34 vm_handlers</i> <br><br>  Note that the ‚Äú <i>tmp_REG</i> ‚Äù keyword refers to the virtual register used by the virtual machine, the temporary register in the <i>vm_contex</i> t structure, while ‚Äú <i>reg</i> ‚Äù refers to the processor's own register, i.e.  eax. <br><br>  Let's look at the analyzed commands of the virtual machine.  For example, <i>case_3_vm_jcc</i> is a general handler of a transition command that can execute any processor transition command, conditional and unconditional. <br><br>  Obviously, this virtual machine does not virtualize every hardware command, this is where commands from the list above will be useful to us (case 4 and case 6). <br><br>  These two <i>vm_handler</i> are used to execute code directly.  All they do is read the opcode of the processor command as an argument and execute the instruction. <br><br>  It should also be noted that <i>vm_registers are</i> always at the top of their own stack, while the identifier of the executable register is stored in the last byte of the virtual command arg0.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> To access the corresponding virtual register, you can use the following code: </font></font><br><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resolve_reg</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(reg_pos)</span></span></span></span>: stack_regs = [<span class="hljs-string"><span class="hljs-string">'eax'</span></span>, <span class="hljs-string"><span class="hljs-string">'ecx'</span></span>, <span class="hljs-string"><span class="hljs-string">'edx'</span></span>, <span class="hljs-string"><span class="hljs-string">'ebx'</span></span>, <span class="hljs-string"><span class="hljs-string">'esp'</span></span>, <span class="hljs-string"><span class="hljs-string">'ebp'</span></span>, <span class="hljs-string"><span class="hljs-string">'esi'</span></span>, <span class="hljs-string"><span class="hljs-string">'edi'</span></span>] stack_regs.reverse() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> stack_regs[reg_pos] reg_pos = <span class="hljs-number"><span class="hljs-number">7</span></span> ‚Äì (state[arg<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp; <span class="hljs-number"><span class="hljs-number">0x000000FF</span></span>) reg = resolve_reg(reg_pos)</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 5. Writing Your Own Disassembler </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After correct analysis of all </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_instructions, there</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> is still one more step that needs to be done before starting to analyze the sample - we need to write our own bytecode disassembler (manually parsing it will be problematic because of its size). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By making efforts and writing a more reliable disassembler, we will save ourselves the strength later when the FinFisher virtual machine changes and is updated. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's start with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handler 0x0C</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which executes the following command:</font></font><br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">mov</span></span> [tmp_REG], reg</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This command takes exactly one argument ‚Äî the identifier of the own register used as reg. </font><font style="vertical-align: inherit;">This identifier should be displayed with the name of its own register, for example, using the command </font></font><code>resolve_reg</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in the example above. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To disassemble this </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handler,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> you can use the following code:</font></font><br><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_0C</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(state, vi_params)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> instr reg_pos = <span class="hljs-number"><span class="hljs-number">7</span></span> ‚Äì (vi_arams[arg0] &amp; <span class="hljs-number"><span class="hljs-number">0x000000FF</span></span>) tmpinstr = ‚Äúmov [tmp_REG], %s‚Äù % resolve_reg(reg_pos) instr.append(tmpinstr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Again, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handlers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for transitions are harder to understand. </font><font style="vertical-align: inherit;">In the case of transitions, the components </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_context.vi_params.Arg0</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_context. </font><font style="vertical-align: inherit;">vi_params.Arg1</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> store the indent to which the transition occurs. </font><font style="vertical-align: inherit;">This ‚Äújump indent‚Äù is actually indented in bytecode. </font><font style="vertical-align: inherit;">To parse the transition handlers, we need to rearrange the marker to the transition area. </font><font style="vertical-align: inherit;">Such code will suit us:</font></font><br><br><pre> <code class="hljs pgsql">def computeLoc1(pos, vi_params): <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> instr jmp_offset = (vi_params[arg0] &amp; <span class="hljs-number"><span class="hljs-number">0x00FFFFFF</span></span>) + (vi_params[arg1] &amp; <span class="hljs-number"><span class="hljs-number">0xFF000000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> jmp_offset &lt; <span class="hljs-number"><span class="hljs-number">0x7FFFFFFF</span></span>: jmp_offset /= <span class="hljs-number"><span class="hljs-number">0x18</span></span> # their <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">0x18</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> my <span class="hljs-keyword"><span class="hljs-keyword">increment</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: jmp_offset = <span class="hljs-type"><span class="hljs-type">int</span></span>((- <span class="hljs-number"><span class="hljs-number">0x100000000</span></span> + jmp_offset) / <span class="hljs-number"><span class="hljs-number">0x18</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pos+jmp_offset</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, there is a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> responsible for executing native commands with arguments that require special handling. For this we need a disassembler for our own x86 commands, for example, the Distorm tool from open access. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The command length is stored in vm_context.vi_params.OpCode &amp; 0x0000FF00. Opcode own team for execution is stored in the arguments. To parse the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that executes the native code, you can use the code below:</font></font><br><br><pre> <code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vm_04</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vi_params, pos)</span></span></span></span>: global instr nBytes = vi_params[opCode] &amp; <span class="hljs-number"><span class="hljs-number">0x0000FF00</span></span> dyn_instr = pack(‚Äú&lt;LLLL‚Äù, vi_params[arg<span class="hljs-number"><span class="hljs-number">0</span></span>], vi_params[arg4], vi_params[arg8], vi_params[argC])[<span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-symbol"><span class="hljs-symbol">:nBytes</span></span>] dec_instr = distorm3.Decode(<span class="hljs-number"><span class="hljs-number">0x0</span></span>, dyn_instr, distorm3.Decode32Bits) tmpinstr = ‚Äú%s‚Äù % (dec_instr[<span class="hljs-number"><span class="hljs-number">0</span></span>][<span class="hljs-number"><span class="hljs-number">2</span></span>]) instr.append(tmpinstr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At this point, we wrote all the functions in Python to parse each of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handlers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">All of them, including the code responsible for marking the transition areas, determining the virtual team ID after the call, and some others are needed to write your own disassembler. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After all this, it can be driven by bytecode. </font></font><br><br><img src="https://habrastorage.org/webt/4w/5d/jb/4w5djbrxas1nnkgiv52imgogrqi.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Figure 12. Part of the unpacked and decrypted bytecode FinFisher</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> For example, from the bytecode shown in Figure 12, we can get the following output:</font></font><br><br><pre> <code class="hljs cs">mov tmp_REG, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> tmp_REG, EBP <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> tmp_REG, <span class="hljs-number"><span class="hljs-number">0x10</span></span> mov tmp_REG, [tmp_REG] push tmp_REG mov tmp_REG, EAX push tmp_REG</code> </pre> <br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 6. Understanding the use of this virtual machine </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After analyzing all the virtual handlers and building our own custom disassembler, we can again look at the virtual teams in order to understand the basic idea of ‚Äã‚Äãcreating them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">First, we must understand that virtualization protection was applied at the assembler level. The authors transformed their own teams into their own, somehow complicated, which are executed by a special virtual CPU. For this, a temporary "register" ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tmp_REG</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) is used. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We can look at a few examples in order to understand how this transformation works. Take the virtual command from the previous example -</font></font><br><br><pre> <code class="hljs perl">mov tmp_REG, EAX <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> tmp_REG</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- it was converted from its own team </font></font><code>push eax</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">If virtualization is applied, a temporary register is used in the time step to change the command to something more complex. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Take another example:</font></font><br><br><pre> <code class="hljs cs">mov tmp_REG, <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> tmp_REG, EBP <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> tmp_REG, <span class="hljs-number"><span class="hljs-number">0x10</span></span> mov tmp_REG, [tmp_REG] push tmp_REG</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Here are your own commands that have been converted to these virtualized commands (where reg is one of its own registers): </font></font><br><br><pre> <code class="hljs perl">mov reg, [ebp+<span class="hljs-number"><span class="hljs-number">0x10</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">push</span></span> reg</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">However, this is not the only way to virtualize a set of commands. There are other uses of the virtual machine for protection, with other approaches. For example, there is a commercial implementation of protection via a virtual machine that uses the mathematical logic NOR (when both inputs are negative), with several time registers instead of one. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In turn, FinFisher did not go so far and did not transform all its own commands. While many of them are virtualized, some may not be so - these are mathematical commands such as </font></font><code>add</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>imul</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">and </font></font><code>div</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. If these commands appear in the original binary file, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">responsible for executing own commands is invoked to process them in a protected file. The only change that occurs is that EFLAGS and its own registers are retrieved right before the execution of their own command, and then removed after the execution is completed. So it is possible to avoid the virtualization of each own team. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A significant disadvantage of protecting a binary with a virtual machine is the negative impact on performance. In the case of the FinFisher virtual machine, we approximately estimate its speed as more than one hundred times slower than in the case of the internal code, based on counting the number of commands executed for processing each of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_instruction</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ( </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_dispatcher</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Therefore, it makes sense to protect only selected parts of the binaries - and this is what they do in those FinFisher samples that we analyzed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Moreover, as already mentioned, some of the virtual machine's handlers can directly call their own functions. As a result, virtual machine security users (i.e. FinFisher authors) can decide at assembly stage what functions to protect with its help. For the marked functions, their commands will be virtualized; for the rest, the original functions will be called by the corresponding virtual handler. Thus, the execution of the code may be less time consuming, while the most interesting parts of the binary file remain protected (Figure 13).</font></font><br><br><img src="https://habrastorage.org/webt/b5/yq/07/b5yq07ubxhni8ctpvly1zj5aw24.png"><br> <i> 13. ,    FinFisher,  ,         </i> <br><br><h4> 7.        FinFisher </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In addition to the length of the bytecode, which our parser has to handle, it is necessary to remember that in some FinFisher samples there is some mixing. And although the same virtual machine is used for protection, the definition of correspondence between virtual opcodes and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handlers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> does not always coincide. They can be (and this happens) randomly paired, and these pairs are different for different FinFisher samples that we analyze. This means that the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> for the virtual opcode 0x5 in this sample processes the command </font></font><code>mov [tmp_REG], arg0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, and in another protected sample it can be assigned to another virtual opcode. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To solve this problem, we can use the signature for each of the analyzed </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handlers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">The script for IDA Python in Appendix A can be applied after obtaining the diagram from Figure 7 (it is especially important to remove the obfuscation of the jz / jnz transitions, as described in the first section of this guide), to give names to the handlers based on their signatures. </font><font style="vertical-align: inherit;">(With minor modifications, this script can also be used to restore signatures if </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handlers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are modified in the updated version of FinFisher.) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As mentioned above, the first </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handler</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the FinFisher sample that you encounter during the analysis may differ from the JL that we cited the sample as an example, but the script will determine all </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_handlers in the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> right way.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 8. Compiling Disassembled Code Without a Virtual Machine </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">After disassembling and a few changes, it is possible to compile the code. </font><font style="vertical-align: inherit;">We will use virtual teams as our own. </font><font style="vertical-align: inherit;">As a result, we get a pure binary code without protection. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Most of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vm_instructions</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> commands </font><font style="vertical-align: inherit;">can be compiled by simple copying, since at the output of the disassembler, most of the commands look like native ones. </font><font style="vertical-align: inherit;">But some sections need to be refined in a special way: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ tmp_REG ‚Äî since we have defined tmp_REG as a global variable, we need to make changes to the code for those cases when the address stored in it is dereferenced. </font><font style="vertical-align: inherit;">(Since dereferencing an address located in a global variable is not possible for the x86 command set.). </font><font style="vertical-align: inherit;">For example, a virtual machine contains a virtual command.</font></font><code>mov tmp_REG, [tmp_REG]</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> which needs to be rewritten as follows: </font></font><br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">push</span></span> eax mov eax, tmp_REG mov eax, [eax] mov tmp_REG, eax <span class="hljs-keyword"><span class="hljs-keyword">pop</span></span> eax</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Flags - virtual teams do not change flags, and their own math commands do this. Therefore, it is important for us that the virtual math teams in the devirtualized binary do not do this either, which means the need to preserve the flags before executing the commands and restoring them after the completion of execution. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Transitions and calls - we need to move the marker to the area of ‚Äã‚Äãthe virtual team (transition) or function (call). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Call API functions - in most cases they are loaded dynamically, in other cases they are accessed from the IAT (address import table) of the binary file, so they need to be processed accordingly.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Ä¢ Global variables, own code - some global variables must be stored in a devirtualized binary. Also, in the FinFisher dropper there is a function to switch between x64 and x86, which is performed in processor mode (in fact, this is done only with the help of a command </font></font><code>retf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">). All this needs to be kept in the compilation process. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depending on the result, at the output of your disassembler you may still need to make a couple more changes to get your own commands that can be compiled. Then you will need to compile the code using your preferred compiler into a binary without a virtual machine.</font></font><br><br><h2>  Conclusion </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this tutorial, we described how FinFisher uses two ways to protect the main deliverable component. The goal of protection is not to counter anti-virus detection, but to hide configuration files and new techniques used in spyware by creating difficulties for reverse engineering. Since to date, no other detailed analysis of the FinFisher obfuscated spyware has been published, the task of the developers of this protection mechanism could now be considered to have been successfully completed. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We showed how the level of protection opposing disassembling can be overcome by the automatic method, and how to effectively analyze the virtual machine.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> We hope that the guide will help reverse engineering specialists to analyze the virtual machine protected FinFisher samples, as well as provide a better understanding of the specifics of protection using the virtual machine as a whole. </font></font><br><br><h2>  Appendix A </h2><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> IDA Python script to name vm_handlers in FinFisher </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This script is also available in </font></font><a href="https://github.com/eset/malware-research/blob/master/finfisher/ida_finfisher_vm.py"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the ESET repository on GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><pre> <code class="hljs 1c"> import sys SIGS={'8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">9080</span></span>0f95c2a<span class="hljs-number"><span class="hljs-number">980000</span></span>f95c03ac275ff631c':'case_0_JL _loc1','8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">940007</span></span>4ff631c':'case_1_JNP_loc1','8d4b408b432c 8b0a<span class="hljs-number"><span class="hljs-number">94000075</span></span>a<span class="hljs-number"><span class="hljs-number">9080</span></span>0f95c2a<span class="hljs-number"><span class="hljs-number">980000</span></span>f95c03ac275ff631c':'case_2_JLE_loc1','8d4 b408b7b508b432c83e02f8dbc<span class="hljs-number"><span class="hljs-number">38311812</span></span>b5c787cfe7ed4ae92f8b066c787d3e7e 4af9b8e<span class="hljs-number"><span class="hljs-number">80000588</span></span>d80' : 'case_3_vm_jcc', '8b7b508b432c83e02f3f<span class="hljs-number"><span class="hljs-number">8576</span></span>6c77ac<span class="hljs-number"><span class="hljs-number">6668</span></span> <span class="hljs-number"><span class="hljs-number">13731678</span></span>3c728d<span class="hljs-number"><span class="hljs-number">7340</span></span>fb64b3df3a4c67e<span class="hljs-number"><span class="hljs-number">98037818</span></span>b43c<span class="hljs-number"><span class="hljs-number">8947</span></span>1c<span class="hljs-number"><span class="hljs-number">6475</span></span>6c<span class="hljs-number"><span class="hljs-number">8077</span></span>5af<span class="hljs-number"><span class="hljs-number">83318588</span></span>b6 32c' : 'case_4_exec_native_code', '8d4b408b98b<span class="hljs-number"><span class="hljs-number">438898833188</span></span>b43c8b632c' : 'c ase_5_mov_tmp_REGref_arg0', '8b7b508b432c83e02f3f<span class="hljs-number"><span class="hljs-number">8576</span></span>6c77ac<span class="hljs-number"><span class="hljs-number">666813731678</span></span>3c7 28d<span class="hljs-number"><span class="hljs-number">7340</span></span>fb64b3df3a4c67e<span class="hljs-number"><span class="hljs-number">98037818</span></span>b43c<span class="hljs-number"><span class="hljs-number">8947</span></span>1c<span class="hljs-number"><span class="hljs-number">6475</span></span>6c<span class="hljs-number"><span class="hljs-number">8077</span></span>5af<span class="hljs-number"><span class="hljs-number">83318588</span></span>b632c' : 'cas e_6_exec_native_code','8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">94000075</span></span>ff631c':'case_7_JZ_loc1' , '8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">94000075</span></span>a<span class="hljs-number"><span class="hljs-number">9080</span></span>0f95c2a<span class="hljs-number"><span class="hljs-number">980000</span></span>f95c03ac275ff<span class="hljs-number"><span class="hljs-number">6318</span></span>' : 'case_8_ JG_loc1','8d<span class="hljs-number"><span class="hljs-number">4340</span></span>8b<span class="hljs-number"><span class="hljs-number">089438833188</span></span>b43c8b632c':'case_9_mov_tmp_REG_arg0','3 3c<span class="hljs-number"><span class="hljs-number">9894</span></span>b<span class="hljs-number"><span class="hljs-number">883318</span></span>8b632c8b43c' : 'case_A_zero_tmp_REG', '8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">980000</span></span> 75ff631c':'case_B_JS_loc1','8d4b40fb69b<span class="hljs-number"><span class="hljs-number">870002</span></span>bc18b4b2c8b<span class="hljs-number"><span class="hljs-number">548148</span></span>b4b<span class="hljs-number"><span class="hljs-number">889118</span></span> <span class="hljs-number"><span class="hljs-number">3318</span></span>8b43c8b632c' : 'case_C_mov_tmp_REGDeref_tmp_REG', '8d4b40fb69b<span class="hljs-number"><span class="hljs-number">870002</span></span>bc 18b4b2c8b<span class="hljs-number"><span class="hljs-number">44814894388331</span></span>88b43c8b632c' : 'case_D_mov_tmp_REG_tmp_REG', '8d4b 408b432c8b0a<span class="hljs-number"><span class="hljs-number">910007</span></span>5ff631c':'case_E_JB_loc1','8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">910007</span></span>5a94 <span class="hljs-number"><span class="hljs-number">000075</span></span>ff631c':'case_F_JBE_loc1','8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">94000074</span></span>ff631c':'cas e_10_JNZ_loc1','8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">908007</span></span>4ff631c':'case_11_JNO_loc1','8b7 b<span class="hljs-number"><span class="hljs-number">5083435030</span></span>8d4b408b<span class="hljs-number"><span class="hljs-number">414343285766</span></span>c773f<span class="hljs-number"><span class="hljs-number">50668137</span></span>a231c<span class="hljs-number"><span class="hljs-number">6472</span></span>c<span class="hljs-number"><span class="hljs-number">280772</span></span>aa8d57d83c<span class="hljs-number"><span class="hljs-number">7389</span></span> <span class="hljs-number"><span class="hljs-number">1783</span></span>ef3c<span class="hljs-number"><span class="hljs-number">7477</span></span>a<span class="hljs-number"><span class="hljs-number">30008077</span></span>7cb83c<span class="hljs-number"><span class="hljs-number">788978</span></span>3ef8c647cf<span class="hljs-number"><span class="hljs-number">2807</span></span>7c<span class="hljs-number"><span class="hljs-number">3183</span></span>c7dc<span class="hljs-number"><span class="hljs-number">6768</span></span>8b383c<span class="hljs-number"><span class="hljs-number">018894</span></span>7 183c<span class="hljs-number"><span class="hljs-number">7566</span></span>c<span class="hljs-number"><span class="hljs-number">7777</span></span>fe<span class="hljs-number"><span class="hljs-number">668137176283</span></span>c72c672d<span class="hljs-number"><span class="hljs-number">80374589</span></span>5f183c75c<span class="hljs-number"><span class="hljs-number">67848037</span></span>df478b<span class="hljs-number"><span class="hljs-number">4314</span></span>c674 <span class="hljs-number"><span class="hljs-number">08037288947183</span></span>c75c<span class="hljs-number"><span class="hljs-number">6792803751</span></span>5f8b632c' : 'case_12_vm_call', '8d4b40b<span class="hljs-number"><span class="hljs-number">870002</span></span>b 18b532c8b<span class="hljs-number"><span class="hljs-number">44824894388331</span></span>88b43c8b632c' : 'case_13_mov_tmp_REG_tmp_REG_notRly ','8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">940007</span></span>5ff631c':'case_14_JP_loc1','8d4b40fb69b<span class="hljs-number"><span class="hljs-number">870002</span></span> bc18b4b2c8b<span class="hljs-number"><span class="hljs-number">53889548148331</span></span>88b43c8b632c' : 'case_15_mov_tmp_REG_tmp_REG', '8 d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">908007</span></span>5ff631c':'case_16_JO_loc1','8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">9080</span></span>0f 95c2a<span class="hljs-number"><span class="hljs-number">980000</span></span>f95c03ac274ff631c':'case_17_JGE_loc1','8b<span class="hljs-number"><span class="hljs-number">4388</span></span>b<span class="hljs-number"><span class="hljs-number">089438833188</span></span>b4 3c8b632c' : 'case_18_deref_tmp_REG', '8d4b408b<span class="hljs-number"><span class="hljs-number">4388</span></span>b9d3e<span class="hljs-number"><span class="hljs-number">089438833188</span></span>b43c8b6 32c' : 'case_19_shl_tmp_REG_arg0l', '8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">98000074</span></span>ff631c' : 'ca se_1A_JNS_loc1','8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">910007</span></span>4ff631c':'case_1B_JNB_loc1','8b 7b2c8b732c83ef4b<span class="hljs-number"><span class="hljs-number">924000</span></span>fcf3a<span class="hljs-number"><span class="hljs-number">4836</span></span>b2c48b4b2c8b<span class="hljs-number"><span class="hljs-number">43889412483318</span></span>8b43c8b632c' : 'c ase_1C_push_tmp_REG', '8d4b408b432c8b0a<span class="hljs-number"><span class="hljs-number">94000075</span></span>a<span class="hljs-number"><span class="hljs-number">910007</span></span>5ff<span class="hljs-number"><span class="hljs-number">6318</span></span>' : 'case_1D_ JA_loc1','8d4b40b<span class="hljs-number"><span class="hljs-number">870002</span></span>b18b532c8b<span class="hljs-number"><span class="hljs-number">44824143883318</span></span>8b43c8b632c':'case_1E_ad d_stack_val_to_tmp_REG', '8b7b<span class="hljs-number"><span class="hljs-number">508343503066</span></span>c77ac<span class="hljs-number"><span class="hljs-number">37668137315657</span></span>83c728d4b40c6 72e<span class="hljs-number"><span class="hljs-number">803746</span></span>fb<span class="hljs-number"><span class="hljs-number">6433</span></span>d3c783c<span class="hljs-number"><span class="hljs-number">05894718</span></span>3c758d714fb64b3df3a45ac<span class="hljs-number"><span class="hljs-number">67128037</span></span>7a8b383c<span class="hljs-number"><span class="hljs-number">0188</span></span>9 <span class="hljs-number"><span class="hljs-number">4718</span></span>3c<span class="hljs-number"><span class="hljs-number">7566</span></span>c777f<span class="hljs-number"><span class="hljs-number">30668137</span></span>1fac83c72c671f<span class="hljs-number"><span class="hljs-number">80377789</span></span>5f183c75c<span class="hljs-number"><span class="hljs-number">67708037</span></span>2b47c<span class="hljs-number"><span class="hljs-number">679803</span></span>7 618b4b<span class="hljs-number"><span class="hljs-number">1489</span></span>4f183c75c<span class="hljs-number"><span class="hljs-number">67778037</span></span>b48b632c8d12' : 'case_1F_vm_jmp', '8d4b408b914b <span class="hljs-number"><span class="hljs-number">883318</span></span>8b43c8b632c' : 'case_20_add_arg0_to_tmp_REG', '8d4b408b98b<span class="hljs-number"><span class="hljs-number">4388918331</span></span> 88b632c8b43c' : 'case_21_mov_tmp_REG_to_arg0Dereferenced' } SWITCH = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta"># addr of jmp dword ptr [eax+ecx*4] (jump to vm_handlers) SWITCH_SIZE=34 sig = [] def append_bytes(instr, addr): for j in range(instr.size): sig.append(Byte(addr)) addr += 1 return addr defmakeSigName(sig_name,vm_handler): print ‚Äúnaming %x as %s‚Äù % (vm_handler, sig_name) MakeName(vm_handler,sig_name) return if SWITCH == 0: print ‚ÄúFirst specify address of switch jump - jump to vm_handlers!‚Äù sys.exit(1) foriinrange(SWITCH_SIZE): addr = Dword(SWITCH+i*4) faddr = addr sig = [] while 1: instr = DecodeInstruction(addr) if instr.get_canon_mnem() == ‚Äújmp‚Äù and (Byte(addr) == 0xeb or Byte (addr) == 0xe9): addr = instr.Op1.addr continue if instr.get_canon_mnem() == ‚Äújmp‚Äù and Byte(addr) == 0xff and Byte (addr+1) == 0x63 and (Byte(addr+2) == 0x18 or Byte(addr+2) == 0x1C): addr = append_bytes(instr, addr) break if instr.get_canon_mnem() == ‚Äújmp‚Äù and Byte(addr) == 0xff: break if instr.get_canon_mnem() == ‚Äújz‚Äù: sig.append(Byte(addr)) addr += instr.size continue if instr.get_canon_mnem() == ‚Äújnz‚Äù: sig.append(Byte(addr)) addr += instr.size continue if instr.get_canon_mnem() == ‚Äúnop‚Äù: addr += 1 continue addr = append_bytes(instr, addr) sig_str = ‚Äú‚Äù.join([hex(l)[2:] for l in sig]) hsig = ''.join(map(chr, sig)).encode(‚Äúhex‚Äù) for key, value in SIGS.iteritems(): if len(key) &gt; len(sig_str): ifkey.find(sig_str)&gt;=0: makeSigName(value,faddr) else: ifsig_str.find(key)&gt;=0: makeSigName(value,faddr)</span></span></code> </pre> </div><p>Source: <a href="https://habr.com/ru/post/354830/">https://habr.com/ru/post/354830/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../354820/index.html">Program Overview Heisenbug 2018 Piter</a></li>
<li><a href="../354822/index.html">Studies show: people who have ‚Äútoo many interests‚Äù are more likely to succeed</a></li>
<li><a href="../354824/index.html">Payment system architecture. Experience proven banality</a></li>
<li><a href="../354826/index.html">Procedural dungeon generation in roguelike</a></li>
<li><a href="../354828/index.html">The science of emotion: how smart technologies learn to understand people</a></li>
<li><a href="../354832/index.html">Biomechanics. Start</a></li>
<li><a href="../354834/index.html">DevConf: a little about blockchain</a></li>
<li><a href="../354836/index.html">Secure Development Section on the PHDays 8 Forum</a></li>
<li><a href="../354838/index.html">PHDays CTF 2018. Writeup maker-up</a></li>
<li><a href="../354840/index.html">Why employees no longer criticize the sysadmin: managing feedback using chatbot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>