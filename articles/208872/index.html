<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A simple interpreter from scratch in Python (part 3)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content  Simple interpreter from scratch in Python # 1 
 Simple interpreter from scratch in Python # 2 
 Simple interpreter from scratch in Python # 3...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A simple interpreter from scratch in Python (part 3)</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/fc0/be6/122/fc0be61225bee85fbec6ac3ea1eb79d3.png" alt="image"><br><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  <a href="http://habrahabr.ru/post/206320/">Simple interpreter from scratch in Python # 1</a> <br>  <a href="http://habrahabr.ru/post/206454/">Simple interpreter from scratch in Python # 2</a> <br>  <b>Simple interpreter from scratch in Python # 3</b> <br>  <a href="http://habrahabr.ru/post/207662/">Simple interpreter from scratch in Python # 4</a> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Explanation to the publication</b> <div class="spoiler_text">  User @duse previously posted translations of two previous articles, clearly intending to translate the entire series.  Since the topic interests me very much, but there are no new translations, I turned to the original source.  Since English is not very strong, so as not to lose the point, I began to translate into Russian.  So this translation was born.  I apologize to @duse if I had to suffer a little more.  But for the community in any case there should be a benefit. <br><br></div></div><br>  Thus, we wrote a lexer parser combinator library for our interpreter.  In this part, we will create structural data of an abstract syntax tree (AST), and write a parser using our library of combinators that translate the list of tokens returned by the lexer into an abstract syntax tree (AST).  After we parse the AST, it will be very easy to start the program. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="habracut"></a><br><h4>  Determine AST </h4><br>  Before we start writing our parser, we need to define the data structures that our parser will return.  We define them using classes.  Each IMP syntax element will have a corresponding class.  Objects of this class will display the nodes in the AST. <br><br>  There are only three structures in our IMP: arithmetic expressions (used to calculate numbers), logical expressions (used to calculate conditions for if and while statements), and state.  Let's start with arithmetic expressions, as the remaining two depend on it. <br>  An arithmetic expression can take one of three forms: <br><ul><li>  Literal numeric constants like <code>42</code> </li><li>  Variables like <code>x</code> </li><li>  Binary operations such as <code>x + 42</code> .  They are formed from other arithmetic expressions. </li></ul><br><br>  We can also group expressions together with brackets (like <code>(x+2)*3</code> ).  This is not just a different type of expression, but a different way of parsing an expression. <br>  We define three classes for these forms, plus a base class for basic arithmetic expressions.  While classes do nothing but store information.  The <code>__repr__</code> method allows to print <code>AST</code> during debugging.  All <code>AST</code> classes will inherit <code>Equality</code> , so we will be able to verify the similarity of two <code>AST</code> objects, which is also useful in testing. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> equality <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Aexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Equality)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IntAexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Aexp)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, i)</span></span></span><span class="hljs-function">:</span></span> self.i = i <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'IntAexp(%d)'</span></span> % self.i <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VarAexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Aexp)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name)</span></span></span><span class="hljs-function">:</span></span> self.name = name <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'VarAexp(%s)'</span></span> % self.name <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BinopAexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Aexp)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, op, left, right)</span></span></span><span class="hljs-function">:</span></span> self.op = op self.left = left self.right = right <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'BinopAexp(%s, %s, %s)'</span></span> % (self.op, self.left, self.right)</code> </pre><br>  Logical expressions are a bit more complicated.  There are 4 types of logical expressions: <br><ul><li>  Relationship expressions (such as <code>x &lt; 10</code> ) </li><li>  <code>And</code> expressions (such as <code>x &lt; 10 and y &gt; 20</code> ) </li><li>  <code>Or</code> expressions </li><li>  <code>Not</code> expressions </li></ul><br><br>  The left and right sides of relation expressions are arithmetic expressions.  The left and right sides <code>and</code> , <code>or</code> , or <code>not</code> expressions are logical expressions.  This type distinction helps us avoid meaningless expressions like <code>x &lt; 10 and 30</code> . <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Equality)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RelopBexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Bexp)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, op, left, right)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AndBexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Bexp)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, left, right)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OrBexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Bexp)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, left, right)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NotBexp</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Bexp)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, exp)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre><br>  Statements (statements) can contain arithmetic and logical expressions simultaneously.  There are 4 types of expressions: assignment, join, conditions, and cycles. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Statement</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Equality)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssignStatement</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Statement)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, name, aexp)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CompoundStatement</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Statement)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, first, second)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfStatement</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Statement)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, condition, true_stmt, false_stmt)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WhileStatement</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Statement)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, condition, body)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre><br><h4>  Primitives </h4><br>  Now we have our <code>AST</code> classes and a suitable set of combinators - it's time to write our parser.  When writing a parser, it is easier to start with the basic structures of the language, gradually moving to more complex things. <br><br>  The first parser we‚Äôll look at is the <code>keyword</code> parser.  It is just a special version of the <code>Reserved</code> Combinator using the <code>RESERVED</code> tag, which is labeled with all keywords.  Remember, <code>Reserved</code> corresponds to a single token, for which the value and tag are the same as for the transmitted ones. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyword</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(kw)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Reserved(kw, RESERVED)</code> </pre><br>  <code>keyword</code> is an actual combinator, because it is a function that returns a parser.  We will use it directly in other parsers. <br><br>  The <code>id</code> parser is used for matching variable names.  It uses the <code>Tag</code> combinator, which matches the token with the specified tag. <br><br><pre> <code class="python hljs">id = Tag(ID)</code> </pre><br>  The <code>num</code> parser is used to match integers.  It works almost like <code>id</code> , except that we use the <code>Process</code> combinator (more precisely, the operator that calls <code>Process</code> ) to convert the token to a specific integer. <br><br><pre> <code class="python hljs">num = Tag(INT) ^ (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> i: int(i))</code> </pre><br><h4>  Parsing arithmetic expressions </h4><br>  Parsing arithmetic expressions is not easy, but we need to parse arithmetic expressions in order to parse logical expressions or statements, so we must start with them. <br><br>  First we define the <code>aexp_value</code> parser, which will convert the values ‚Äã‚Äãreturned by <code>num</code> and <code>id</code> into actual expressions. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aexp_value</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (num ^ (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> i: IntAexp(i))) | \ (id ^ (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> v: VarAexp(v)))</code> </pre><br>  We used the operator <code>|</code>  which is short for the <code>Alternate</code> combinator.  This allows the first expressions to be parsed.  If they fail, an attempt will be made to parse the expression with the variable. <br><br>  Note that we have defined <code>aexp_value</code> as a function with no arguments instead of a global value, just as we did with <code>id</code> and <code>num</code> .  We will do the same with all remaining parsers.  And we did it because we do not want the code of each parser to be calculated immediately.  If we defined each parser as global, each parser would not be able to refer to the other parsers that follow in the same source file, because they would not have been declared yet.  This would make it impossible to define recursive parsers, and the source code would be less readable. <br><br>  Further, we would like to implement grouping with brackets in our arithmetic expressions.  Although grouping expressions do not require their own <code>AST</code> class, they need another parser to process them. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsed)</span></span></span><span class="hljs-function">:</span></span> ((_, p), _) = parsed <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aexp_group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyword(<span class="hljs-string"><span class="hljs-string">'('</span></span>) + Lazy(aexp) + keyword(<span class="hljs-string"><span class="hljs-string">')'</span></span>) ^ process_group</code> </pre><br>  The <code>process_group</code> function is used with the <code>Process</code> combinator ( <code>^</code> operator).  It simply discards the tokens of the parentheses and returns the expression inside.  In fact, <code>aexp_group</code> also a parser.  Remember, operator <code>+</code> is short for <code>Concat</code> combinator.  So she parses '(', following the arithmetic expression (exploded by <code>aexp</code> , which we will soon define), followed by ')'.  You must avoid calling <code>aexp</code> , because, as <code>aexp</code> calls <code>aexp_group</code> , which will lead to infinite recursion.  We use the <code>Lazy</code> combinator, which postpones the aexp call until the parser is applied to any input data. <br><br>  Next, we combine <code>aexp_value</code> and <code>aexp_group</code> with <code>aexp_term</code> .  The expression <code>aexp_term</code> is any simple independent expression in which we do not have to care about the precedence of operators with respect to other expressions. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aexp_term</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aexp_value() | aexp_group()</code> </pre><br>  Now we are approaching the tricky part: operators and seniority.  It will be easier to define another parser for <code>aexp</code> and throw it together with <code>aexp_term</code> .  This will result in the expression: <br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  To such a wrong analysis: <br><pre> <code class="python hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span>) * <span class="hljs-number"><span class="hljs-number">3</span></span></code> </pre><br>  The parser must be aware of the precedence of the operators, and it must group the operators with higher precedence with each other. <br><br>  We will define several auxiliary functions in order to perform this work. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_binop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(op)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> l, r: BinopAexp(op, l, r)</code> </pre><br>  The <code>process_binop</code> function is what creates the <code>BinopAexp</code> object.  This function accepts any arithmetic operator and returns a function that combines pairs of expressions using this operator ... <br><br>  The <code>process_binop</code> function should be used with the <code>Exp</code> ( <code>*</code> operator) combinator.  Combinator <code>Exp</code> parses a list of expressions with a separator between each pair of expressions.  The left operator <code>Exp</code> is a parser that matches the individual elements of the list (in our case, arithmetic expressions).  The right operator is a parser that maps separators (operators).  No matter which separator is matched, the right parser returns a function that, given the correspondence of the operators, returns a union function.  The union function accepts parsed expressions to the left and right of the separator, and returns a single, unified expression.  Still not confused?  We will quickly go through the use of <code>Exp</code> .  The <code>process_binop</code> function is what the right parser will return. <br>  Next, we will define our levels of seniority and a combinator to help us cope with them. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any_operator_in_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ops)</span></span></span><span class="hljs-function">:</span></span> op_parsers = [keyword(op) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> op <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> ops] parser = reduce(<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> l, r: l | r, op_parsers) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser aexp_precedence_levels = [ [<span class="hljs-string"><span class="hljs-string">'*'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>], [<span class="hljs-string"><span class="hljs-string">'+'</span></span>, <span class="hljs-string"><span class="hljs-string">'-'</span></span>], ]</code> </pre><br>  The <code>any_operator_in_list</code> function takes a list of keyword strings and returns the corresponding parser.  We define <code>aexp_precedence_levels</code> containing a list of operators for each level of precedence (starting with a higher one). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">precedence</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(value_parser, precedence_levels, combine)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">op_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(precedence_level)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> any_operator_in_list(precedence_level) ^ combine parser = value_parser * op_parser(precedence_levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> precedence_level <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> precedence_levels[<span class="hljs-number"><span class="hljs-number">1</span></span>:]: parser = parser * op_parser(precedence_level) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser</code> </pre><br>  <code>precedence</code> is the actual content of the operation.  Its first argument, <code>value_parser</code> , is a parser that can read the simple parts of an expression: numbers, variables, and groups.  This will be <code>aexp_term</code> .  The <code>precedence_levels</code> list contains a list of statements, one list for each level.  For this we use <code>aexp_precedence_levels</code> .  <code>combine</code> will accept a function that, passed by the operator, will return a function for constructing one large expression from two small ones.  This will be the <code>process_binop</code> <br><br>  Inside <code>precedence</code> , we first define <code>op_parser</code> , which, for a given level of precedence, reads only operators with the same level and returns a function that combines two expressions.  <code>op_parser</code> can be used as the right argument to <code>Exp</code> .  We start by calling <code>Exp</code> with <code>op_parser</code> for the highest level of precedence, for these operations must be grouped first.  Next we use the resulting parser as an element of the parser (the left argument <code>Exp</code> ) at the next level.  After the end of the cycle, the resulting parser is able to parse the arithmetic expression correctly. <br><br>  How does it work in practice?  Let's sort it out. <br><pre> <code class="python hljs">E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>&lt;/sub&gt; = value_parser E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;/sub&gt; = E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>&lt;/sub&gt; * op_parser(precedence_levels[<span class="hljs-number"><span class="hljs-number">0</span></span>]) E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>&lt;/sub&gt; = E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;/sub&gt; * op_parser(precedence_levels[<span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre><br>  <code>E <sub>0</sub></code> is the same as <code>value_parser</code> .  It can parse numbers, variables and groups, but not operators.  <code>E <sub>1</sub></code> parsits expressions containing everything that can coincide with <code>E <sub>0</sub></code> , separated by operators from the first level of precedence.  So <code>E <sub>1</sub></code> can match <code>a * b / c</code> , but should cause an error as soon as it encounters the <code>+</code> operator.  <code>E <sub>2</sub></code> can match expressions separated by operators of the next level of precedence.  Since we only have 2 levels of precedence, <code>E <sub>2</sub></code> can match any arithmetic expressions that we support. <br><br>  Let's follow the example.  Take a complex arithmetic expression, and gradually replace each part with its comparison. <br><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">4</span></span> * a + b / <span class="hljs-number"><span class="hljs-number">2</span></span> - (<span class="hljs-number"><span class="hljs-number">6</span></span> + c) E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>(<span class="hljs-number"><span class="hljs-number">4</span></span>)&lt;/sub&gt; * E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>&lt;/sub&gt;(a) + E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>&lt;/sub&gt;(b) / E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>&lt;/sub&gt;(<span class="hljs-number"><span class="hljs-number">2</span></span>) - E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">0</span></span>&lt;/sub&gt;(<span class="hljs-number"><span class="hljs-number">6</span></span>+c) E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;/sub&gt;(<span class="hljs-number"><span class="hljs-number">4</span></span>*a) + E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;/sub&gt;(b/<span class="hljs-number"><span class="hljs-number">2</span></span>) - E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;/sub&gt;(<span class="hljs-number"><span class="hljs-number">6</span></span>+c) E&lt;sub&gt;<span class="hljs-number"><span class="hljs-number">2</span></span>&lt;/sub&gt;((<span class="hljs-number"><span class="hljs-number">4</span></span>*a)+(b/<span class="hljs-number"><span class="hljs-number">2</span></span>)-(<span class="hljs-number"><span class="hljs-number">6</span></span>+c))</code> </pre><br>  We use precedence directly to determine <code>aexp</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">aexp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> precedence(aexp_term(), aexp_precedence_levels, process_binop)</code> </pre><br>  We can probably define seniority less abstractly, but the advantage of our approach is that we apply it in any situation that has the problem of operator precedence.  We will reapply it for parsing logical expressions. <br><h4>  Parsing logical expressions </h4><br>  We can already move from arithmetic expressions to logical ones.  Logical expressions are usually simpler than arithmetic, so we don‚Äôt need new tools to parse them.  Let's start with the simplest logical expressions: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_relop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsed)</span></span></span><span class="hljs-function">:</span></span> ((left, op), right) = parsed <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RelopBexp(op, left, right) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bexp_relop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> relops = [<span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&lt;='</span></span>, <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>, <span class="hljs-string"><span class="hljs-string">'&gt;='</span></span>, <span class="hljs-string"><span class="hljs-string">'='</span></span>, <span class="hljs-string"><span class="hljs-string">'!='</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> aexp() + any_operator_in_list(relops) + aexp() ^ process_relop</code> </pre><br>  We use the <code>process_relop</code> function with the <code>Process</code> combinator.  It takes three connected values ‚Äã‚Äãand creates <code>RelopBexp</code> from them.  In <code>bexp_relop</code> we parse two arithmetic expressions ( <code>aexp</code> ) separated by a relational operator.  And we use our old man - the function <code>any_operator_in_list</code> , so we don‚Äôt need to write a case for each operator.  There is also no need to use combinators like <code>Exp</code> or <code>precedence</code> , since relationship expressions cannot be connected to each other in IMP as they are done in other languages. <br><br>  Next, we define the expression <code>not</code> .  The expression is <code>not</code> a unary operator with high seniority.  This makes it easier to parse than <code>and</code> and <code>or</code> expressions. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bexp_not</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyword(<span class="hljs-string"><span class="hljs-string">'not'</span></span>) + Lazy(bexp_term) ^ (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> parsed: NotBexp(parsed[<span class="hljs-number"><span class="hljs-number">1</span></span>]))</code> </pre><br>  Here we have connected the <code>not</code> keyword with the name of the logical expression (which we will define later).  Since <code>bexp_not</code> will be used to define <code>bexp_term</code> , we need to use the <code>Lazy</code> combinator to avoid endless recursion. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bexp_group</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyword(<span class="hljs-string"><span class="hljs-string">'('</span></span>) + Lazy(bexp) + keyword(<span class="hljs-string"><span class="hljs-string">')'</span></span>) ^ process_group <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bexp_term</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bexp_not() | \ bexp_relop() | \ bexp_group()</code> </pre><br>  We define <code>bexp_group</code> and <code>bexp_term</code> in the same way as for arithmetic equivalents.  This is nothing new. <br>  Next, we need to define expressions that include the <code>and</code> and <code>or</code> operators.  These operators actually work like arithmetic operators;  both are performed from left to right, and <code>and</code> has the highest level of seniority. <br><pre> <code class="python hljs">bexp_precedence_levels = [ [<span class="hljs-string"><span class="hljs-string">'and'</span></span>], [<span class="hljs-string"><span class="hljs-string">'or'</span></span>], ] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process_logic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(op)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> op == <span class="hljs-string"><span class="hljs-string">'and'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> l, r: AndBexp(l, r) <span class="hljs-keyword"><span class="hljs-keyword">elif</span></span> op == <span class="hljs-string"><span class="hljs-string">'or'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> l, r: OrBexp(l, r) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">raise</span></span> RuntimeError(<span class="hljs-string"><span class="hljs-string">'unknown logic operator: '</span></span> + op) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bexp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> precedence(bexp_term(), bexp_precedence_levels, process_logic)</code> </pre><br>  As well as <code>process_binop</code> , <code>process_logic</code> intended for use with the combinator <code>Exp</code> .  It takes an operator and returns a function that combines two subexpressions into one expression using this operator.  We substitute this in accordance with the precedence as in <code>aexp</code> .  Writing a common code here pays off, since we don‚Äôt have to repeat complex expression expression processing code. <br><br><h4>  Parsing allegations </h4><br>  With the end of <code>aexp</code> and <code>bexp</code> , we can begin to parse the IMP statements.  Let's start with a modest assignment statement: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">assign_stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsed)</span></span></span><span class="hljs-function">:</span></span> ((name, _), exp) = parsed <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AssignStatement(name, exp) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> id + keyword(<span class="hljs-string"><span class="hljs-string">':='</span></span>) + aexp() ^ process</code> </pre><br><br>  Nothing particularly interesting.  Next, we look at the <code>stmt_list</code> .  It will parse a series of statements separated by a semicolon. <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stmt_list</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> separator = keyword(<span class="hljs-string"><span class="hljs-string">';'</span></span>) ^ (<span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> x: <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> l, r: CompoundStatement(l, r)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Exp(stmt(), separator)</code> </pre><br><br>  Remember, we need to use the <code>EXP</code> combinator here instead of something simpler like <code>stmt() + keyword(';') + stmt()</code> to avoid left-side recursion. <br>  Next we have an <code>if</code> : <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if_stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsed)</span></span></span><span class="hljs-function">:</span></span> (((((_, condition), _), true_stmt), false_parsed), _) = parsed <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> false_parsed: (_, false_stmt) = false_parsed <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: false_stmt = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IfStatement(condition, true_stmt, false_stmt) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyword(<span class="hljs-string"><span class="hljs-string">'if'</span></span>) + bexp() + \ keyword(<span class="hljs-string"><span class="hljs-string">'then'</span></span>) + Lazy(stmt_list) + \ Opt(keyword(<span class="hljs-string"><span class="hljs-string">'else'</span></span>) + Lazy(stmt_list)) + \ keyword(<span class="hljs-string"><span class="hljs-string">'end'</span></span>) ^ process</code> </pre><br>  Here the only difficulty is that the <code>else</code> clause is optional.  This makes executing a function a little more difficult. <br>  Finally, we have a <code>while</code> : <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">while_stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(parsed)</span></span></span><span class="hljs-function">:</span></span> ((((_, condition), _), body), _) = parsed <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WhileStatement(condition, body) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> keyword(<span class="hljs-string"><span class="hljs-string">'while'</span></span>) + bexp() + \ keyword(<span class="hljs-string"><span class="hljs-string">'do'</span></span>) + Lazy(stmt_list) + \ keyword(<span class="hljs-string"><span class="hljs-string">'end'</span></span>) ^ process</code> </pre><br>  We wrap this with <code>stmt</code> : <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stmt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> assign_stmt() | \ if_stmt() | \ while_stmt()</code> </pre><br>  You may notice that in both <code>if</code> and <code>while</code> <code>if</code> , using <code>stmt_list</code> in the body is better than <code>stmt</code> .  <code>stmt_list</code> is actually our top level definition.  We cannot have <code>stmt</code> directly dependent on <code>stmt_list</code> , since this will lead to left-side recursion of the parser, and since we want to have optional statements in the <code>if</code> and <code>while</code> bodies, we directly use <code>stmt_list</code> . <br><h4>  Putting it all together </h4><br>  Now we have a parser for each part of the language.  We just need to make some high-level definitions: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Phrase(stmt_list())</code> </pre><br>  <code>parser</code> will parse the entire program.  A program is just a list of statements, but the <code>Phrase</code> combinator ensures that we use every token in the file before a premature termination due to garbage (invalid) tokens at the end. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">imp_parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tokens)</span></span></span><span class="hljs-function">:</span></span> ast = parser()(tokens, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ast</code> </pre><br>  The <code>imp_parse</code> function will be called by the client to parse the program.  It accepts the entire list of tokens, calls parser, starts with the first token, and returns the resulting Abstract Syntax Tree (AST). <br><br>  Here is a simple control program to test our parsers (in addition to unit tests): <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> sys <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> imp_parser <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(sys.argv) != <span class="hljs-number"><span class="hljs-number">3</span></span>: sys.stderr.write(<span class="hljs-string"><span class="hljs-string">'usage: %s filename parsername'</span></span> % sys.argv[<span class="hljs-number"><span class="hljs-number">0</span></span>]) sys.exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) filename = sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>] file = open(filename) characters = file.read() file.close() tokens = imp_lex(characters) parser = globals()[sys.argv[<span class="hljs-number"><span class="hljs-number">2</span></span>]]() result = parser(tokens, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> result</code> </pre><br>  This program reads a file (first argument) and parses it with some kind of parser from <b>imp_parse.py</b> (second argument).  Example: <br><br><pre> <code class="bash hljs">$ <span class="hljs-built_in"><span class="hljs-built_in">echo</span></span> <span class="hljs-string"><span class="hljs-string">'1 + 2 * 3'</span></span> &gt;foo.imp $ python imp_parser_driver.py foo.imp aexp Result(BinopAexp(+, IntAexp(1), BinopAexp(*, IntAexp(2), IntAexp(3))), 5)</code> </pre><br>  This should provide a good sandbox for experiments. <br><h4>  Conclusion </h4><br>  In this article, we wrote a combinator library from scratch and used it to write a parser for <b>IMP</b> .  In the next and last article in this series, we will write a performer ( <i>Comment</i> : could not find the best translation of the word <i>evaluator</i> ) for our parsed Abstract Syntax Tree ( <b>AST</b> ). <br><br>  The author of the original article - <a href="http://www.jayconrod.com/posts/39/a-simple-interpreter-from-scratch-in-python-part-3">Jay Conrod</a> <br><br>  <b>PS</b> I see problems with the Sub tag.  There is an assumption that it is too early for a newbie to use such a tag.  What to replace it - I do not know.  I leave to clarify the decision. <br></div><p>Source: <a href="https://habr.com/ru/post/208872/">https://habr.com/ru/post/208872/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../208862/index.html">Where articles are bought and who writes them</a></li>
<li><a href="../208864/index.html">NAVIA - unmanned electric vehicle</a></li>
<li><a href="../208866/index.html">Deploy using Salt</a></li>
<li><a href="../208868/index.html">Reading room of a mobile indie developer: the most interesting thing for the New Year holidays</a></li>
<li><a href="../208870/index.html">10 simple tasks on c # with a trick</a></li>
<li><a href="../208874/index.html">How was the local version of the site Intuit.Ru hacked</a></li>
<li><a href="../208876/index.html">Chase Algorithm</a></li>
<li><a href="../208886/index.html">Tolstoy Startup Camp: how Yandex teaches how to do its business</a></li>
<li><a href="../208890/index.html">GulpJS - fantastically fast project builder</a></li>
<li><a href="../208894/index.html">Conference Bridge, Call Recording Server and Grandstream Fax Server: Overview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>