<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to choose an in-memory NoSQL database wisely. Testing performance</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dmitry Kalugin-Balashov ( Mail.RU ) 
 I have a report on In-Memory NoSQL databases. Who knows what the in-memory NoSQL database is? Raise your hands, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to choose an in-memory NoSQL database wisely. Testing performance</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/170/3ac/e12/1703ace12362cdac58469ebcd14653ea.jpg" alt="image"><br><br><h2>  Dmitry Kalugin-Balashov ( <a href="https://habrahabr.ru/company/mailru/">Mail.RU</a> ) </h2><br>  I have a report on In-Memory NoSQL databases.  Who knows what the in-memory NoSQL database is?  Raise your hands, please ... Shame on you?  Database room, and only half know what it is. <br><br>  If you choose a database, focusing on its popularity, then do not need to.  How, in general, choose the database? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/262/599/8f0/2625998f0394c8b396980b0be75c318f.png"><br><a name="habracut"></a><br><br>  The first option is popularity.  It happened so historically, i.e.  You came to work, and you have such a database there, you did not choose it, you just want, for example, to change it. <br><br>  The second option - I was advised by a friend.  This option is also quite popular. <br><br>  The third option - believe advertising.  This is also related to popularity, read some article: "Oh, Redis is a cool database, let's use it." <br><br>  And now I have a question: who among you considers himself an engineer?  Those.  You graduated from high school and have an engineering education.  I propose to use an engineering approach to the selection of a database.  I suggest testing them.  On their own.  You may reasonably argue that the Internet is already full of database testing, and you can just see how people have tested.  You don‚Äôt need to do that either, because you‚Äôll see that everything depends on a particular situation.  Those.  You can see how the database is tested, run it and not get what that person had.  Those.  you need to test on your load, on your machines - virtual or non-virtual, on your environment.  Therefore, my entire report will be about the engineering approach to the choice of databases. <br><br>  See, this little man is you.  You consider yourself an engineer.  Those.  this man is cool. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e37/33e/b27/e3733eb278022cad148c3061f9460ddf.png"><br><br>  And there is a little man who is not an engineer who can be seduced by advertising, maybe he believed a friend, or simply chose Redis, because everyone chooses him.  So, we are not on the way with him.  And therefore we will choose the green man, we will act as engineers. <br><br>  Now the question is: what will we test?  What do you think you can test?  How much data can I hold? <br><br>  See, there are two parameters - throughput and latency. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/556/fb1/aba/556fb1aba5ce00b08fc3063d480169ae.png"><br><br>  Raise your hands, who understands the difference between these parameters?  Somewhere 10% of students in the hall.  Then I will explain.  Who went to such a shop sometime? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/32a/161/004/32a16100422fe46a7399decab847de97.png"><br><br>  Are there any smokers?  Where do you go for cigarettes, in Auchan or closer?  Closer, probably, yes?  So, this store is special, it has a very small latency.  Latency is the expected time when you go for cigarettes, for example, between making a decision and, in fact, how you got them.  Those.  you realized that you had to buy them, went down to the courtyard, went into the store, took it, went to the cash register, bought it, came back.  It took 15 minutes.  This is your latency. <br><br>  Throughput is already a shop parameter ‚Äî how many people like you can miss per unit of time.  Those.  There is usually one cash register in this store, with a bunch of people, and one person passes there in two minutes. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/758/112/7fd/7581127fd0b25fb2d7a72501a9c3a0fc.png"><br><br>  Those.  slow enough.  On the one hand, for us it is pretty fast, but if there are a lot of people like us, the store will drown, there will be long lines and nothing good will come of it.  If we overload this shop, then we will also grow latency, because everyone will have to stand in lines. <br><br>  There is the other side, the reverse side of the moon.  It looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ce8/cd3/48e/ce8cd348e2bab36333c555921fb4539d.png"><br><br>  Who was in Auchan?  All were.  Fine.  Have you seen how it works?  There are many cass.  And they work in parallel, at the same time. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0c0/dcf/b98/0c0dcfb98c010ce1aa3e70036a3ee247.png"><br><br>  Thus, at one moment Auchan passes more people through itself.  But if you want to buy something in Auchan, you must first get into the car, drive somewhere behind the Moscow Ring Road, park, get out, take a cart, spend two hours there, buy it and come home.  Those.  latency for you will be very large, but throughput at this store is small. <br><br>  Everyone understood what is throughput and latency, if we are talking about databases?  The expected request execution time is latency, and throughput is how many requests per second we are able to process. <br><br>  And one more parameter that needs to be tested is the memory footprint. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7aa/57e/5a4/7aa57e5a40e66cb109ca0d3ad60d7c5a.png"><br><br>  Do you know how ‚Äúfootprint‚Äù is translated from English?  Footprint.  This is it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/703/2ad/40f/7032ad40f46e0144e8e8acac0193ca7e.png"><br><br>  Specially in the morning I circled my wife's leg while she was sleeping, signed it, this is a memory footprint.  What is it?  If we shove a GB of clean data into the database and see how much our program itself is in memory in a DBMS, then it will not be GB, it will be more.  How much more is the footprint memory value.  Even ‚Äúin‚Äù many more times, i.e.  how many bytes are we spending by 1 byte?  This is an important parameter, because it determines how much we need to buy RAM.  Those.  This is such a monetary option. <br><br>  And how are we going to test the database?  There is a utility YCSB - Yahoo!  Cloud Serving Benchmark.  This link has its clone: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cb/9a4/e2a/8cb9a4e2a072e79077010b32290c4a10.png"><br><br>  This is my github repository, there are some changes, I‚Äôll tell you about them. <br><br>  Why should this utility be used? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ed/66c/42e/3ed66c42e9ba1e09a3ca04377023942f.png"><br><br><ol><li>  Firstly, it is an industry standard, everyone trusts it, i.e.  it generally tests NoSQL database. </li><li>  Further, there it is very easy to write your own load profiles, i.e.  if you have some non-standard profile, then you can easily write a configuration and <br>  to test. </li><li>  It is easy to write drivers for other databases there, and there are already many standard ones, but if you have something non-standard, you can write yourself. </li></ol><br>  Why not use it?  I found one big reason: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3ff/c23/d6c/3ffc23d6c209700d24d597eb00ff34c2.png"><br><br>  Those who love Java are probably the best you know, its negative sides.  She spends a lot of resources.  And, just, Kostya was talking about money, it was Java that ate my money, because the tester machine had to be ordered more powerful than if ... I thought it would take a bit there, but Java does not fit into the memory, and CPU there many cores required.  I needed a more expensive machine to test, so I wrote it down to minus.  But this is a minus of my personal, maybe you are a millionaire, and Java will not hurt you in this matter. <br><br>  This YCSB has standard workloads.  Workload is a load profile.  What are they?  Their six standard types are: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/49a/f86/5e9/49af865e946311e9ff736b92d57d4e21.png"><br><br>  A is 50% of read requests, 50% is for write.  Simple workload. <br><br>  B is 95% read, 5% update, write. <br><br>  C is 100% read-only. <br><br>  Further more interesting. <br><br>  D is 95% for reading, 5% for insert, but there is one specificity - it reads only what has been recently inserted.  This, for example, you write news in VK, wrote, sent - this is insert.  5% insert.  And your friends, you have their ton, they begin to read, F5 teasing, and the load is created like this.  Those.  such a profile is something like a news feed. <br><br>  Profile E is a heavy scan type query.  This is a range request.  5% insert and 95% scan.  Those.  This is when you have some kind of search on a pile of data that does not lie nearby. <br><br>  And the last one is also an interesting workload.  There are 50% of bare reads, and 50% of such a composition - first read, then modify, then write.  Those.  we read a piece, changed it and wrote it down.  Quite often such a combination. <br><br>  We can very easily write any layer.  There are very simple configs - in five lines, we just write the percentage and the method of influence, for example, if insert, then we select the most recent data - this is for workload D. <br><br>  So, how to write your driver?  Because there was no memcached driver.  I understand that many memcached are not considered to be a database in general.  What are we doing? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/79d/199/a1f/79d199a1f711af330b3c2be47bdffa1a.png"><br><br>  There is such a java class, we can inherit from it.  We realize these.  There are five methods.  They are simply implementable.  If some workload does not imply a method, for example, we did not have a workload with the delete method, then we can not even implement it. <br><br>  We will build these graphics: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/529/2cf/bd2/5292cfbd2c4d94e4750685150e27ad36.png"><br><br>  Look, horizontally we have the number of streams, and we point the logarithmically points - 8 streams, 16, 32, and so on up to 1024. And vertically - throughput schedule - how many requests per second.  This is a weak, frail virtual.  This is the Tarantool database.  This is workload A. <br><br>  How are we going to test? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/157/b7c/0ab/157b7c0ab4d1da0c38d189e38af07c14.png"><br><br>  It is very important that the tester machine and the database machine are located within the same data center and as close as possible in order to eliminate the influence of the network on latency. <br><br>  Why not test on the same machine?  I tested it.  See, this is the same Tarantool on the same machine.  The green one is on one machine, and the red one is on two machines.  It is separate, it is together. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/df0/cf0/7c1df0cf018c0f738c6229898cc8a162.png"><br><br>  Let's take a look at this hump.  While we have 8, 16, 32 threads, we really have throughput higher on one machine, but as soon as more of the two threads appear, our tester itself begins to compete for resources with the database and begins to take resources, and we fall back. <br><br>  However, with latency the picture is different. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/db0/7ab/9d9/db07ab9d903c4984cb3643d54cc83ae4.png"><br><br>  Latency, when separately, is lower, because we have some kind of network that is latency and eats, i.e.  we have such a distance.  When we test together, our latency will be better. <br><br>  The real story is, of course, separate testing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8d/8ee/707/d8d8ee707862329fd4cf1c28e7e56c86.png"><br><br>  Further, all tests were on very frail virtualkas, very squeezed in resources.  If we have a dedicated server, then we will keep the shape of the curve, but we will have a great distance. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c5a/d82/83b/c5ad8283b051b29e214b07cf33c22097.png"><br><br>  It was Azure the smallest, which is possible, or almost the smallest, with a pair of cores. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a3/287/ee4/6a3287ee49ddd0b8f7a124f4487d3dfc.png"><br><br>  Do you know what WAL is?  This is a persistence storage tool, Write-Ahead Log.  How it works?  You add something to the database, this is a transaction log - there at the end is recorded what you did with the database, i.e.  all changes.  If for some reason we turned off the power, just restarted, at the start we read it - along this log - and we read all the commands, restore the post-mortem state. <br><br>  It will work differently with WAL.  These all tests were without WAL.  How it will work with WAL, I'll show the difference: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d80/428/aad/d80428aad1caf700bdc1b142621699b7.png"><br><br>  See, green is with WAL.  There is a difference.  This is without WAL, this is with WAL.  And there is.  Why the difference?  This is workload A, which means that 50% read, 50% update. <br><br>  If we take latency by read, see what happens: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d0/976/ffe/6d0976ffe9bffcacb71386c21567d1de.png"><br><br>  There is no difference.  Those.  WAL does not affect reading at all.  See how it happened? <br><br>  And when we update, there is a difference: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7c/511/a96/a7c511a96e535bec1585d9f6643408ac.png"><br><br>  Because we have to write to the disk and, of course, it slows down the whole thing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9a5/3b2/978/9a53b297809a142cf7109f605f1f55fe.png"><br><br>  Virtuals are also different.  Those.  why can't we take ready-made test results from the Internet?  See, these are two virtuals: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26a/e88/e3a/26ae88e3accb079d8f3238914ebeb433.png"><br><br>  This is DigitalOcean, this is Azure.  See, they work very differently. <br><br>  And now - how do we, in general, choose a database?  We will have, if we are talking about the engineering approach, several stages.  The first stage - we choose it somehow qualitatively. <br><br>  I took four databases.  The first is radish. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d5/2c2/97a/6d52c297a91c72b46681a47e1a4beca2.png"><br><br>  And I just write out what is important for my project, some qualitative values, i.e.  just that comes to mind, mind map paint.  What does Redis have?  There are Append Only Files - this is WAL, i.e.  we can store some persistence.  What else do you have?  He has what is important for the project, for example, a developed community.  If this is important to me, then I enter it myself.  What else is good for Redis?  It has a text protocol, but this is not good, i.e.  it is written out as a minus.  Typically, text protocols are slower than binary ones.  This is clearly seen in the example of memcached, where there is such and such protocols and binary faster.  And there are stored procedures that we often write in business logic with stored procedures, so they exist. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ff2/5be/6eb/ff25be6ebd7f8f7abe891cd09799943f.png"><br><br>  Tarantool.  Who generally uses Tarantool?  A bit in the hall.  First, Tarantool is a document-oriented database, so real.  Its main competitors are key value.  Secondly, there are wooden indices (or woody? B-tree, binary tree - this is it, in general, it is such a jargon).  There is also WAL in Tarantool, i.e.  may have persistence.  There are also snapshots there.  There are stored procedures on Lua, they can also be compared.  Here I will not have tests, but they can be compared with the same Redis, very interesting results are obtained.  And one more piece was just for me, for you, rather, it was not so, but Tarantool was made with us, at Mail.ru, and if I have any questions (i.e., this is the same thing as the community Redis), but here I can come to Kostya Osipov and ask: ‚ÄúWhat is it?‚Äù.  Therefore, I wrote this to myself in the plus sign.  Specially dotted. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d13/796/914/d13796914e00cac19581e214ff038f3b.png"><br><br>  Next, Memcached.  Do you know where the hare comes from?  There are such hares on the Memcached main page.  Memcached, unlike the previous two, loads all cores, it has a binary protocol, i.e.  uses the old-fashioned text, but it also has a binary one, which is faster.  And he has no persistence, if we fell, we all lost.  Those.  It is possible to use the cache as something else - it is impossible. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d43/9f0/589/d439f058950c71f03d575441d5c45f9e.png"><br><br>  And there is CouchBase.  Why, in general, CouchBase in this collection?  It is slightly different.  It is a complete enterprise solution.  So complete that it is very easy to install.  So easy that a child can handle.  Moreover, it is possible to make a cluster very easily.  And also the child will cope.  Those.  it's at the level of a couple of mouse clicks.  This is very different from previous databases.  And he also has a memcached protocol like memcached, well, it‚Äôs very similar, so you can use the same driver, and it‚Äôs wrong for us not to test it, this CouchBase, so we took it to the test. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e83/9a3/145/e839a31456c7982c5b0000aa8925fe3f.png"><br><br>  And let's test throughput.  What have we got?  It turned out this picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e1/bd4/66d/8e1bd466dc464f4ffa3c7ff31fd46aaa.png"><br><br>  Blue is the Tarantool database.  Dark blue is hash-indices, light blue is tree-indices.  Red we have redis.  Orange, generally speaking, also Redis, but special, it is called Azure Redis Cache.  This is a service from Microsoft.  It is cloudy, you can install it in the same datacenter as your test virtual machine, so you can test it.  We have a gray CouchBase.  And the green one is Memcached.  See how memcached interestingly went.  There is a hypothesis, because it loads all the cores, then it reaches the ceiling later, but it has not been tested yet. <br><br>  If we change Workloads for everyone, the picture doesn‚Äôt change much. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0f9/762/a4e/0f9762a4e937503e4e1684c69cd0c908.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ade/a96/f51/adea96f51bc5f13d50f16fe55537242f.png"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c44/c0e/eef/c44c0eeefacdbbde49dd510045786ae3.png"><br><br>  Workload F is a heavy workload. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f75/1b8/b0e/f751b8b0ecd39223ec6a107107d80633.png"><br><br>  Such is the picture.  Tarantool throughput was much higher than all competitors, just decent. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d26/25b/5be/d2625b5beb5fba50abc1f9b316089f03.png"><br><br>  If you test with WAL, what will happen? <br><br>  This is our picture without WAL: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/981/af1/100/981af1100c9556081b4e6cf37af6ae00.png"><br><br>  And now we add WAL: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5aa/c3c/cce/5aac3ccce653089d0427f7a8aea1c1dd.png"><br><br>  In principle, slightly decreased, but nothing changes.  Tarantool and Redis - the main competition, this picture comes out.  CouchBase and Memcached - they are much lower, but they do not have WAL.  CouchBase has, but has not tested yet, Memcached does not. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53d/b4b/e35/53db4be35e9a352be26a49cc9b1cacf7.png"><br><br>  Concerning latency.  This utility Yahoo !, she counts latency on all types of commands separately.  And Read latency looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8e5/7b6/26c/8e57b626c05e5cc70a935023ae267b33.png"><br><br>  And look, latency the lower the better.  Those.  if throughput we looked up, then we should look down.  The colors are the same, Tarantool below, then Redis.  This is the latency average. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/124/f9d/2cf/124f9d2cfd6f116a8dcc68847a467eff.png"><br><br>  Yahoo!  already gives two percents out of the box, but you can patch, he can build histograms, you can make any percentile, he gives the 95th. <br><br>  And look here: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7e4/f33/aed/7e4f33aed9505e01cf721a711e3db6a6.png"><br><br>  Our Redis is a bit worse than Tarantool on the 95th percentile.  But on the 99th opposite: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7c1/675/deb/7c1675debc333f50c25422ef87145478.png"><br><br>  Those.  they are very close, but they change places at the 95th percentile.  There is no error, there is exact data.  Here the number of requests was 5 million requests, and the percentile built all these data on 5 million requests for 2 million records. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3df/ca9/76a/3dfca976ad5dcb6bdb5406e816e4658d.png"><br><br>  If we have Upadate (we still have workload A), then that will be: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f1e/fd9/95c/f1efd995c06a70ffaff5dc63bc973705.png"><br><br>  Average here we have this will be.  See where Memcached turned out, I wonder how. <br><br>  But the 95th percentile, and Tarantool is again better: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b1c/4be/a0c/b1c4bea0ce6bef1563b7996db6b59952.png"><br><br>  But when we go to the 99th percentile, here again Redis is better, but here the distance between them is stronger: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/37d/ad2/9b4/37dad29b41287e86fb347c897795365d.png"><br><br>  Why so what does this mean?  Tarantool has a lot of fast requests, but there is a tail of slow requests, while Redis has more requests in the middle, i.e.  his histogram slightly to the right goes.  Tarantool has two ‚Äúhumps‚Äù, i.e.  first, fast requests, a lot of them - 95%, and then we go further and a lot of slow requests, somewhere after the 99th, the percentile goes for Redis.  And Redis has one ‚Äúhump‚Äù in the middle.  And if you build a bar chart, Yahoo!  test can build them, then we will see.  The only thing is, if there you build them yourself, then you need to build them on a logarithmic scale in X, otherwise you will not see anything. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2c5/41c/f70/2c541cf70312b865f91d737314391464.png"><br><br>  There is such an interesting command Read-Modify-Write.  This is workload F. That is.  read-modify-write.  This is a hard command, because there throughput depends very much on latency, because we have to wait for data from readers to pass the request through ourselves. <br><br>  See, there comes a picture like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9c3/7b0/512/9c37b051276e1fb2d792654c703bdba6.png"><br><br>  Those.  Tarantool latency much lower.  And look, our Redis cloudy is very high here. <br><br>  If we have the 95th percentile, Redis red pressed against Tarantool, cloudy with memcached escaped: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/771/835/318/77183531881a1aac55cfb4b53edeed69.png"><br><br>  If we have the 99th percentile, then Redis is again a little overtaken by Tarantool, i.e.  on the 99th pertistili Redis slightly Tarantool overtakes.  Tarantool, which is with a wooden index, went up.  Such is the interesting picture: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/365/8ef/9663658effa452e913e1c81317d418b8.png"><br><br>  Now look, this is one way to test, Yahoo!  test.  I tried to write another test, tried to change a little the approach to testing, not much, tried to squeeze the maximum throughput, first of all, from the database, i.e.  right up to the limit to put it on without any workloads.  Such a test consists of two parts: first we hammer the data, then we subtract the data.  There is a page, this is a very simple test. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf5/387/ddd/cf5387ddd63a76bd6c1097e9b734fa5f.png"><br><br>  Now I will tell how it works.  He gave quite interesting results, apart from the fact that he gave four bugs in Tarantool, of which two crusts, which were promptly corrected, i.e.  they already came out in release. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1d1/268/15f/1d126815f6e6bd3d51cfa82e3a1131ce.png"><br><br>  How it works?  We have a bunch of pool threads to push requests to the database for throughput.  There are sockets, there are n of them there, as we want, and we have two threads for each socket.  One writes, generally, indiscriminately, writes, writes, writes, directly by machine.  And the second reads readiness data.  And there are threads for counting latency.  They are few.  There are many first streams and they are in pairs, streams for latency are one, sometimes two or three, and they first write, then wait for a response, read the answer, and what is highlighted there will be summed up.  Special variables are atomically summed, and are considered average.  Those.  the percentile is not considered yet.  In the near future I will do it, but for the time being it is considered average.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Of course, they affect each other, but due to the fact that latency has two or three streams, and though put - there are hundreds of them, they will not be affected much. In addition, throughput strongly injects more without stopping, and latency expects. And there is a stream that once per second by the monitor reads all variables from memory and displays on the screen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And what do we get?</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/a1d/50c/600/a1d50c600152d757412678001cc4362f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">What is bad about the Yahoo! test is that it uses standard clients, i.e. it does not test the database itself, but the database in conjunction with the client. When I wrote a client for Memcached, I used spymemcached. This is a library from the authors of CouchBase, quite fast, but, nevertheless, for us it is a black box. And I set myself a goal, in general, to get rid of clients and make the simplest client, which is only for the test, it doesn‚Äôt carry functionality at all, it‚Äôs impossible to use it, it can only send requests and read answers.</font></font> How to do it?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">See, Tarantool has three pieces there: the first is the size, header + body, and the second is the header, two numbers. We are interested in what is highlighted in blue. This is our return code - either an error or not an error. And knowing the first size field, we counted the first field, counted the header and counted the rest, knowing the size. And we simply read, read, read this business indiscriminately in these pairs of streams (see the slide even higher), there are green and red ones, which are simply read by the dray method. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Msgpack is such a binary implementation protocol. The usual library from him is slow and I tried to get rid of all the libraries, there is an implementation, also written in our company, called msgpuck. She is fast, I have modified her a little for this business.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memcached is still easier. It has a binary protocol, a fixed size structure and plus variable field lengths. Subtracted the structure, got the return code, read the field.</font></font> Everything.  Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">very simple. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With Redis more difficult, he has a text protocol. If we get into the Redis protocol, we will see that any successful answer to select begins with a plus sign, i.e. ‚Äú+‚Äù And then something will come back. Any mistake - with minus. And if we agree that neither in the keys, nor in the values ‚Äã‚Äãof our data sets, which we write and read, there will be neither ‚Äú+‚Äù nor ‚Äú-‚Äù, then reading the bare byte stream from the socket, you can simply count the pros and count the minuses. ‚Äú+‚Äù Is how many successful answers returned, ‚Äú-‚Äù is how many errors returned. This implementation will be fast, i.e. "+" And "-", everything. We read if a byte is not ‚Äú+‚Äù, not ‚Äú-‚Äù, we skip it, if ‚Äú+‚Äù or ‚Äú-‚Äù we simply add the counters. And we begin to drive this thing. She chased Azure and got the following results:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/697/9b2/b67/6979b2b67fd3a4c7413612b854d2ccdb.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I first prepared such pictures. This is the whole test. You see, there is a beginning, these are select phases, something happens there, the RPS are quite high, they were much higher than in the Yahoo test! .. Where the dotted lines are, there is the WAL, where there are no dotted lines - without the WAL. Red - Tarantool, orange - Tarantool with a tree, green - Memcached, blue - Redis version 2. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">So we had inserts: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/421/f6e/a5d/421f6ea5db52ce2a042da869f6a16dce.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The more we have throughput, the less the test lasts, because the data is pushed faster. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And this is how latency is considered here: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/0e0/0ed/4d5/0e00ed4d57f50b9060cca7582663fcdf.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Immediately notice, this test is not based on the number of graphics streams here, but on time.</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/deb/4f4/abc/deb4f4abc20936016a62c72d906a3d64.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here there are ‚Äúfailures‚Äù, i.e. sometimes test yahoo! It can show a good result, but when we start work, at some moments it starts to bluntly. The average, it seems, would be normal, but such stupid ones can pass. And it is desirable to build graphs on time. In Yahoo! This can be done by building small crutches. Here it is built in a rather natural way, there immediately the csv is exported to excel or somewhere else. I brought these schedules to the boss, the boss said, nonsense, unreadable. Therefore, I redraw them. Here so here: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d18/851/aa7/d18851aa716b0cbdbcc67fbb06766dcc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It at us throughput on. Red is Tarantool (hash), and orange is Tarantool (tree). Then Memcached and only then we have Redis and Azure Redis Cached. Here Redis version 2. Not the 3rd, the last, the 3rd a little higher or in the Memcached area will be. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we have with WAL, then the picture does not change:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/ae2/308/e1f/ae2308e1f4dfb4517d90490b07cf9edd.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And if we have latency, then we can see, precisely, those very ‚Äúfailures‚Äù. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/217/3cd/487/2173cd487b1e61ebca019c836a8b7b6b.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ie, it seems, we have a big throughput, but such a thing appears, which may at some moments spoil everything that works for us here. I see. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/6c9/43a/4e6/6c943a4e6c859752b10d44daa6558b1f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If we compare inserts, then the picture is again absolutely predictable, as we see, i.e. again tarantool above. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b6/ca7/e21/8b6ca7e21f3ff3c4559c1b9ed4bffdbd.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And latency. Redis latency is much higher than all the others, i.e. there are three lines - all in one. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f7/803/e91/3f7803e91d75dd0064c9347330f01c9e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And here, too, in this way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And how to measure memory footprint? </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d1/3aa/59e/8d13aa59e06c36672808d31dcfcb79a2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For this, a small script is written. It simply considers how much memory a given bit occupies with us, a given process identifier. The script is like this:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/db3/5ea/5a6/db35ea5a69ea10b9ad338817674cb59c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We read just RSS and we put these pieces of RSS and through bc we summarize. And we output it on the server side with timeout and add. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9d5/5dd/91e/9d55dd91ed9cd13cb964db74a11db48c.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And at the same time, we know how much data we have left, because on the tester side, we know how many queries we sent to the database. And you can build a graph. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The charts are interesting in their own right, but the most interesting is the post-mortem state. And here is a very unexpected picture, i.e. its scope will be very unexpected. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/245/805/12f/24580512ffe908e60214ab154f890f47.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tarantool with a hash, here is Tarantool with a tree ... Here the gray ones are how many bytes we have are physically located in the database, and the gray + red is how much memory our DBMS takes, i.e. how much RAM it spends. See what happens here - we have a lot of memory memory. Memcached is smaller. Such are the pictures.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> And we are coming to an end. </font></font> Those.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I started with an engineering approach, as we generally choose a database, and I will remind him. </font><font style="vertical-align: inherit;">We will have such a funnel: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/edd/892/71d/edd89271d4c50865c8a19491c641f83a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At the entrance, we have some points - these are databases. </font><font style="vertical-align: inherit;">And we sift them out with every move. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There is a reasonable question: "And on hell, in general, to test on synthetics?". </font><font style="vertical-align: inherit;">Immediately answer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We have a lot of databases. I tested four of them, of course, more. Can and should be tested more. We first choose exactly according to quality characteristics, for example, we need select from range from to, we definitely need a B-tree, and we can weed out what we have with just a hash, some Memcached or anything. Or we definitely need WAL, Memcached will also be eliminated. And we will sift first by quality characteristics. We have some kind of task, and we just delete those databases. Reds are those that are not suitable.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Then we test on synthetics. Look, we have a lot of databases, in the picture we have five pieces. Why on synthetics? Because if we immediately test on real data, we die. We will have to implement business logic for all databases, and this is difficult. Synthetics is written very quickly. Any utilities, in general, ‚Äúon the knee‚Äù are being made, debugged, of course, verified, so that it seems to be true, but still they are not made for long. If you write more business logic, then it takes longer, much longer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">And only then, when we have already eliminated on synthetics what is obviously not suitable for us, there are absolutely bad results in some cases, we begin to test on real data and finally choose something. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such an approach. My goal was to show how to choose a database.</font></font><br><br><h3>  Contacts </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href="https://habrahabr.ru/users/rvncerr/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rvncerr</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://www.facebook.com/rvncerr"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">facebook</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ¬ª </font></font><a href="https://habrahabr.ru/company/mailru/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mail.ru company blog</font></font></a> <br><br><blockquote> <font color="gray"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This report is a transcript of one of the best speeches at the conference of developers of high-loaded systems </font></font><a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HighLoad ++</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Now we are actively preparing for the conference in 2016 - this year HighLoad ++ will be held in Skolkovo on November 7 and 8.</font></font><br><br></font>  <font color="gray">Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.</font>  <font color="gray">Already, in our textbook more than 30 unique materials.</font>  <font color="gray">Get connected!</font> </blockquote></div><p>Source: <a href="https://habr.com/ru/post/312062/">https://habr.com/ru/post/312062/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../312052/index.html">Pro security in phpBB</a></li>
<li><a href="../312054/index.html">Immersion in the blockchain technology: Combating counterfeit goods</a></li>
<li><a href="../312056/index.html">Finding Java bytecode vulnerabilities: what to do with the results?</a></li>
<li><a href="../312058/index.html">How we helped conduct a medical census in the Republic of Bangladesh</a></li>
<li><a href="../312060/index.html">The logic of consciousness. Explanation "on the fingers"</a></li>
<li><a href="../312064/index.html">Microsoft StorSimple - automatic disaster recovery</a></li>
<li><a href="../312066/index.html">DBGlass - Open-Source cross-platform PostgreSQL GUI client.</a></li>
<li><a href="../312068/index.html">Live text broadcast from the conference ISDEF-2016. Second day</a></li>
<li><a href="../312070/index.html">3CX for Linux: DIY cloud-based PBX</a></li>
<li><a href="../312072/index.html">Quantum hashing. Lecture in Yandex</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>