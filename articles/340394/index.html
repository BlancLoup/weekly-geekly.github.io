<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C / C ++ code profiling on * nix-systems</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Alexander Alekseev ( Postgres Professional ) 
 An excellent overview report of the HighLoad ++ 2016 conference on how to program code profiling. About...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C / C ++ code profiling on * nix-systems</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/5b2/456/aab/5b2456aabe9e14df3ea4a801ebd153f7.jpg"><br><br><h2>  Alexander Alekseev ( <a href="https://habrahabr.ru/company/postgrespro/">Postgres Professional</a> ) </h2><br>  An excellent overview report of the HighLoad ++ 2016 conference on how to program code profiling.  About the typical errors occurring in the measurements.  And, of course, about the tools: <br><br>  - gettimeofday <br>  - strace, ltrace, truss <br>  - gprof <br>  - gdb / lldb <br>  - perf <br>  - pmcstat <br>  - SystemTap <br>  - DTrace <br>  - HeapTrack <br>  - BPF / bcc 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/getpro/habr/post_images/473/381/13a/47338113a5f786fb1b8b1ec63cabcd2e.png" alt="image"><br><br>  In the beginning I will have a not too technical part, on how not to do benchmarks. <br><br>  I observe that people often make common mistakes when they make benchmarks.  And the first of them ... <br><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/0NU07havVD0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><blockquote>  <font color="gray">If you do not know, then all speakers of HighLoad ++ undergo severe coaching, multiple, for different vectors.</font>  <font color="gray">One coaching is required, the rest are optional.</font>  <font color="gray">Optional coaching - this is how to overcome the fear of the scene, for example.</font>  <font color="gray">That is a very harsh approach to the organization of this whole business.</font>  <font color="gray">And when I submitted a report on HighLoad ++, the organizers suggested removing all this technical part and adding more coolstory, beautiful screenshots, and so on.</font>  <font color="gray">And those who are interested in how to run it, which teams to type, can refer to the documentation - and that's why - a link to <a href="http://eax.me/">my blog</a> , because everything is there.</font> <font color="gray"><br><br></font>  <font color="gray">If you are interested in, for example, how SystemTap is going to be difficult on Linux, then open the link to the blog and everything will be right there.</font>  <font color="gray">And in this report there will be more of such a review, so that you can imagine what tools are in general, what they give and when to use which one.</font> </blockquote>  In the beginning I will have a not too technical part, on how not to do benchmarks. <br><br>  I observe that people often make common mistakes when they make benchmarks. <br><br><ul><li>  First, it is unrepeatability.  When you open a blog, and there is such a cool article that we ‚Äúhave measured something, got such beautiful graphics, and our solution, which is worth it, makes it 500 times faster.‚Äù  No data is given to repeat this experiment, no scripts, and nothing.  Well, it's a bad benchmark, and you need to close this page right away.  If you can't repeat it, how can you believe it? <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/4fa/2e5/53e/4fa2e553ee7d7ece49d74dfcac5a5908.png"><br><br>  You should be able to reproduce at least approximately the same results. <br><br><ul><li>  You measure not what you think.  A typical example: we want to measure how our hard disk works.  We have fun typing dd if something somewhere.  We write to disk and measure, and how quickly he actually writes.  Can anybody in the audience say why this is not a disc speed measurement? <br><br>  That's right - because in fact you have measured the speed with which your file system cache works.  How to get around this is also an interesting problem. <br></li><li>  Taking the average.  It always enraged me at our meetings, and I see in the first row a listener who understands me.  We need to understand how quickly we respond to user requests - let's build a graph of the average response time.  The problem is that on this graph there can be an average beautiful time - 15 milliseconds, but there are peaks for 15 seconds.  They can be very rare, and this taking of the average lubricates them.  You think that everything is great and wonderful with you, in fact it is not.  Therefore, build at least medium and maximum - this will give you a good picture.  If it‚Äôs too easy for you, build Perceptyl, 95th, 99th, it will give you an even better idea.  They are not very cheap to build, but, in principle, solved. <br></li><li>  Who will benchmark benchmarks?  This is such a problem.  For example, you wrote a cool test that measures how many answers per second your application generates.  We measured, received, say, 4000 requests per second.  You think: "Somehow not enough, it is necessary to optimize."  The problem is that your benchmark is single threaded.  And under real load, your application runs in hundreds, in thousands of threads.  And, in fact, you did not take into account that your own benchmark is a bottleneck in this case.  This needs to be understood. <br></li><li>  Lack of analysis.  This is when you have fallen down, say: "Something stupid, you need to do everything, rewrite everything."  That is, you need to understand why it is stupid. <br></li><li>  Ignoring errors.  Again, let's go back to the example with your benchmark.  Suppose this is not your benchmark, this is A / B, and you set it on your service, measured it, received 5 million requests per second, and rejoice: ‚ÄúEverything is very fast here.‚Äù  But you did not see that all these are 404 answers, for example.  That is, you also need to calculate errors. <br></li><li>  Incorrect settings.  In my field, in databases, this is a frequent problem, because the default Postgres settings assume that you are trying to run it in a microwave.  Now the servers are powerful, so all the default settings should be changed very much.  Get plenty of buffers, more work_mem.  And understand what these settings do.  If you see a benchmark, even with the data on which it was tested, and even with scripts, but it says that "we tested with the default settings" - by default MongoDB and Postgres - everything can be closed.  The default settings are a non-constructive way to understand what is faster. <br></li><li>  Atypical load.  You read something 90% of the time, 10% write something, and you decide: we will write a benchmark, which is the FIFT / FIFT - and so, and so it does.  Why test this?  That is, you are optimizing something, it just won't help you much in the product. <br></li><li>  Marketing and customization.  Here I have a small cool story.  I reliably know that there were years ... twenty years ago such iron producers who knew benchmarks for which a certain magazine was testing computers.  They collected their iron so that it looked good on these benchmarks.  As a result, everything was sold very well.  This is the first way to fit. <br><br>  Another way of adjusting - we can give MongoDB.  They always chase their benchmarks on small DataSets, so everything fits in their memory, it works great.  When your DataSet stops storing in memory, everything stops working great. <br><br>  That is, you need to understand that it exists, it is not an illusory thing. <br></li><li>  Well, and other properties.  Close example: Oracle vs. Postgres - which is faster?  Maybe Oracle is 10 times faster, but it stands as if not in itself.  This must also be taken into account.  Or maybe not - I have never been a benchmark for Oracle, and have never seen it at all, to be honest. <br></li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/bdb/477/b41/bdb477b4122e8b0ce4a5cb0d0864602f.png"><br><br>  To create a complete picture, I‚Äôll start by not having to benchmark the code.  The easiest way is gettimeofday ().  The grandfather's method, when we have a piece of code, we want to know how fast or slow it is - we measured the time at the beginning, executed the code, measured the time at the end, counted the delta and concluded that the code runs for so long. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/254/903/890/254903890096ff87cec1520704539880.png"><br><br>  In fact, it is not the most idiotic way, it is convenient, for example, when you have this code <em>sometimes</em> tupit, that is, very rarely - once per 10,000 requests, for example.  Plus, it is not as expensive as it is customary to think that you do not have a system call, as you might think.  In Linux, this mechanism is called VDSO.  In fact, you have a page in the kernel that is mapped into the address space of all processes, and your gettimeofday () turns into a memory access, no syscall occurs. <br><br>  You should not use it, despite the fact that it is cheap, if you are doing something with backslips.  Because spinlok themselves work pretty quickly.  That is, what you measure should be at least a millisecond, otherwise your error will be at the measurement level. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cf1/820/af2/cf1820af22ed4756f8b1a051b926c5a6.png"><br><br>  Tools like strace, ltrace, truss are cool tools, they have a -c checkbox that shows how much time you have which syscalls have been running.  Well, ltrace measures library routines, and strace syscalls, but also, in principle, can be useful somewhere in some tasks.  I can not say that I often use it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/604/0c4/430/6040c4430e772e89f5266f8ae7159c14.png"><br><br>  Gprof, there is such a cool tool, on the slide is an example of its text report.  It is also clear - here we have procedures in the program, so many times they were called, so much time this was done as a percentage.  A simple, visual report, if you wrote a micro-benchmark, you can use it. <br><br>  With gprof, you can still generate these images: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8d7/6a6/981/8d76a6981cae6625ae0a6890ca555707.png"><br><br>  This is rather an example of how not to do.  Memorize this picture, here are 6 squares.  Pay attention to how much space they occupy, here the names of the procedures, something is always written above the arrows, nothing is clear - it takes up a lot of space.  We will see much more visual reports than this.  But, in principle, a beautiful picture, it is possible for the authorities to show, pontatsya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2de/8bc/be1/2de8bcbe1eb89a2f50fbe36f6f294aa5.png"><br><br>  Debuggers  In fact, this is already an example of the tools that have to be used in practice when profiling, because they have cool properties to execute batch commands and you can write backtrace to this set of batch commands (bt).  This is very useful when debugging lock contention, when you have a struggle for locks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c7/42d/d14/4c742dd140b955799762a12aeeaf1097.png"><br><br>  <a href="http://habr.ru/p/310372/">http://habr.ru/p/310372/</a> <br><br>  Here I have a little cool story.  This, in my opinion, was the very first patch I wrote for Postgres.  Or second, I do not remember.  Postgres has its own implementation of hash tables, strongly sharpened for Postgres tasks.  And it, including, can be created with such flags to be used by different processes.  The client came with the problem that "here I have on such and such requests, in such and such a scheme everything is stupid, help me."  Interestingly, at first, with the aid of a back-rake receiver, it looked like you run gdb 10 times, in 5 cases you have a back-rack hanging on a lock, and in half of the cases on something else, that is, you obviously have a process hanging on lock, something is wrong. <br><br><blockquote>  <font color="gray">By the way, we posted in open access the video of the last five years of the conference of developers of high-loaded systems <a href="http://www.highload.ru/">HighLoad ++</a> .</font>  <font color="gray">Watch, learn, share and subscribe to <a href="https://www.youtube.com/user/profyclub">the YouTube channel</a> .</font> </blockquote><br>  By backtracking, it was possible to find out what kind of code this is, which then takes, then releases the lock.  This is a long story, you can follow the link to read the article on Habr√©.  There is also a link to the discussion in the hackers, where there are technical details. <br><br>  On the slide above - a piece of code, between taking and releasing the lock, he, in his turn, was falling somewhere in the dynahash, where he was spinning on taking the spinlock.  This was possible with the help of debuggers to find, fix, suggest a patch.  And that spinlock, which is in dynahash (this is a hash plate in Postgres), was turned into 8 or 16 spin locks, which under certain conditions are taken different.  I managed to get it shuffled and it already exists in 9.6. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/574/219/5fb/5742195fb6bf4c1dc5c41b2f2dd8a17f.png"><br><br>  Perf is a great tool because perf top shows top procedures.  In this case, in the specified process, how much time they run.  At the top we see 30%, 20% and we see ResourceOwner - this is not without reason in the names of the procedures, because the next coolstory is also about the real patch. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/815/9aa/aa7/8159aaaa76b585fe89421917d73a4006.png"><br><br>  A client came and said: ‚ÄúI have such requests and such a scheme.  All tupit.  What to do?".  Started debugging.  And he has an enterprise application, he has tables, a thousand child tables (in Postgres, if anyone does not know, there is table inheritance).  And with the help of perf top, we see that everything is dying in ResourceOwner.  ResourceOwner is such an object (as far as the word object is applicable for the C language), which stores various resources, files, memory, and something else.  And it is written under the assumption that we usually allocate resources and put them into an array, and release them in reverse order.  Therefore, when you delete resources, it starts looking for them from the end.  He knows the size of the array, well, in the sense that he has the index of the last element.  It turned out that this condition is not always met and he has to look in all directions along this array, so he is dull.  The patch is that with a certain amount of resources (about 16 or a number of the order of this), this array turns into a hash table.  When you resolve the conflict, you came to the specified index of the array according to the hash, and then go to one of the sides. <br><br>  By the way, if someone is interested in the question, who in the third millennium has to write his own hash tables, then here I sit and write my own hash tables in two patches, because standard implementations do not suit us.  This is also already in 9.6, where ResourceOwner is not stupid if you have a heavily partitioned table.  I mean, he's still dumb, but weaker. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e29/31b/19a/e2931b19ab65b78d5bd88895559fcc4d.png"><br><br>  With the help of perf you can build such beautiful pictures, they are called flamegraphs.  This is read from the bottom up.  Below we have a procedure, then - in proportion to how much time where she spends and in turn causes - we are divided into other procedures.  Then we go up, we also share in proportion, how much time she spends where.  And further up.  This is very clear, but it may be unusual if you see this for the first time.  In fact, this is a very visual report, much clearer than the example with the graph that Gprof is building.  Notice how space is used sparingly; it cannot be shown on slides, but you can click into it all.  And he has a hint that shows percentages. <br><br>  Here is an enlarged piece, this is somewhere in the middle part: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/473/381/13a/47338113a5f786fb1b8b1ec63cabcd2e.png"><br><br>  Actually, this is probably all.  We use this often.  In previous work, we analyzed the logs in the same way.  There was another story - there was an AK-cluster, a distributed application, and we built such things according to the logs, trying to understand where the code is slowing us down.  Logs, of course, needed to be aggregated from all backends.  In general, a handy thing, I recommend it to everyone. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8b6/0e6/143/8b60e6143d4ea4a9cadc64c750553163.png"><br><br>  <a href="http://youtu.be/tDacjrSCeq4">http://youtu.be/tDacjrSCeq4</a> <br><br>  This is Brandon Gregg.  He invented flame graphs and almost perf himself.  Probably, he was not quite alone in writing, but he significantly invested in it.  He is also known in the video on YouTube, where he yells at the hard drives in the data center, and he has increased latency when accessing these drives - a great video.  If anyone is interested, this is a real topic, though, with SSD it works or not - I do not know. <br><br>  Recently, there was a similar story about how the entire data center was cut down in a bank during fire drills, because the pipes that supply gas that extinguishes the fire were whistling too loudly.  That is, the vibration of the air knocked out all the disks. <br><br>  We will return to Brandon, because he knows everything about profiling and has invested a lot in it, now he is working on it in Netflix. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3b5/f21/23a/3b5f2123af72624863337d8c2c8f8e36.png"><br><br>  <a href="http://eax.me/freebsd-pmcstat/">http://eax.me/freebsd-pmcstat/</a> <br><br>  Pmcstat is a tool exclusively for FreeBSD.  When I made these slides, I thought that no one would have FreeBSD, so there are no special details about pmcstat, since  the rest is not very interesting.  But the summary is that with it you can do the same thing with perf.  He also makes the top, also builds flame graphs and he‚Äôs no worse, just other commands.  Who cares, here is a <a href="http://eax.me/freebsd-pmcstat/">link</a> to a specific article. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ffc/eae/e45/ffceaee45b0f5a28ce7bb932373fa7f4.png"><br><br>  We turn to more serious tools.  SystemTap.  Above this, there was CPU CPUing, where something slows down, and SystemTap allows you to do even more - you can look literally at anything in the kernel, measure how many packets you have on the network, go to disk, try on everything and everything please, limited only by your imagination.  SystemTap allows you to write such scripts, in this case, the ip_rcv call, that is, the receipt of some iP package. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0fb/d63/594/0fbd63594ef007a17522cc4e318fea1d.png"><br><br>  Advantages and disadvantages.  The main drawbacks are 2. Firstly, this is not some official tool for Linux, these are the guys from Red Hat who wrote it down for themselves, to debug their code, as I understand it.  It is very inconvenient to install, you need to download a package with debugging symbols of the kernel, then install it, then SystemTap itself compiles for a very long time, it is also not so easy to compile, versions are needed.  But ultimately it starts working.  The second drawback is that you need to understand well the basis of what you want to analyze, trace.  Not everyone knows by heart the Linux kernel.  But if you know your code well, you can use it. <br><br>  There is an interesting property - the code is translated to C, then it is compiled into a kernel module, which loads and collects all statistics, all traces.  In this case, you can not be afraid to divide by zero, dereference pointers wrong.  If you write this in a scripting language, it will not cause the kernel to crash, it will just gently fold the legs and unload, but your kernel will continue to work. <br><br>  There is an automatic type inference.  True, there are only two or three types, but they are automatically displayed. <br><br>  Personally, I would be scared to use this in production because it does not seem to be a stable tool.  One fact - you have the script for 10 seconds compiled and loaded, and what will be slowing down at this time, not slowing down, is not very clear.  I would not risk it, but maybe you are braver. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fc3/857/d41/fc3857d413ccccb3dc88e62f997611cd.png"><br><br>  DTrace is also a cool tool, not just for FreeBSD, but Linux is also, all is well.  It is similar to SystemTap, in this example we trace the system call poll, and moreover for processes called postgres.  Here traytsya, with what arguments it is called and what is returned. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/488/f66/a95/488f66a954afb30fa3fdeaa03a5a7e1c.png"><br><br>  Advantages and disadvantages.  Firstly, unlike SystemTap, it is directly in the system out of the box, it doesn‚Äôt need to be installed or compiled.  There are in FreeBSD, in Mac OS.  For Linux, it is also there, if you are somehow using Oracle Linux.  In addition, there is a project dtrace4linux on GitHub, it compiles, it works, I checked.  In principle, you can use. <br><br>  Unlike SystemTap, DTrace is not scary to use in production - go to your Mac in a combat environment and treysit whatever you like.  According to my subjective feelings, DTrace is more for admins, because you have a lot of samples in the core for anything, you don‚Äôt need to know the code base, you just say: ‚ÄúI want to collect statistics on IP packets - how many have come, how many have gone‚Äù .  By the way, there are sets of ready-made utilities, you do not need to write all the scripts yourself.  DTrace Toolkit is called. <br><br>  And SystemTap is more likely not for admins, but for developers: ‚ÄúI know the kernel code, I want to go in this place without writing any code, not patching it‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1a1/1af/e00/1a11afe006043828972d8912dc415043.png"><br><br>  Until now, we have been talking about profiling in terms of CPU utilization, but another frequent problem is ‚Äúwhat if I get a lot of memory?‚Äù.  I personally like the HeapTrack tool, if you have ever used Valgrind Massif, it‚Äôs the same, only fast, but with a restriction - it works only on Linux. <br><br>  Here (on the slide above) is an example of a text report, a place is found that eats up the most memory, there are specific line numbers, source file names, and so on. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/681/0ff/246/6810ff24683ea54fccb1f4167d46cc63.png"><br><br>  In addition, he can build such beautiful reports in the Massif Visualizer tool.  It is possible to open everything in it, it is all in dynamics.  There the memory grew, then it reached its peak, then it began to fall, to free itself, to stand out, on the right there are traces.  Everything is very clear and beautiful. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d78/ba7/f53/d78ba7f53f70d6f11df539096b394968.png"><br><br>  Advantages and disadvantages.  It is fast, unlike Valgrind.  Can cling to running processes, you can run processes under it.  Beautiful reports.  He is able to find memorials faces.  He finds them a little crooked, if your standard language library allocated 16 KB for some of its internal needs and then did not release them, because ‚Äúwell, why?‚Äù, He will say that this is a memorial.  But, in principle, quite a useful tool, despite all this. <br><br>  You can build a histogram that I have pieces of 8 bytes in size allocated the most, and pieces of memory of 32 bytes in size are allocated a little less.  Such a beautiful bar chart is obtained. <br><br>  He doesn't know anything about the stack, if you need a stack or need something outside of Linux, then use Valgrind.  I‚Äôm a Linuxoid, so I don‚Äôt know anything about Valgrind. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3f2/0cd/46a/3f20cd46a7dc5eb0b302810aa7024fdf.png"><br><br>  There is such a topic in Linux, called BPF, originally it was Berkeley Packet Filter and, as the name suggests, it is related to Berkeley and some sort of packet filtering, but it landed BPF somewhere in 2.6 at the time.  But as a result, it was finalized and, in fact, it evolved, not without the help of the already mentioned Brandon Gregg, in DTrace in Linux. <br><br>  It allows you to do absolutely the same thing.  Recently, Brandon had a blog post where he writes that in kernel 4.9, which is still a release candidate now, but soon will be, changes to BPF have finally landed there.  There will not be big, major changes, maybe they will zarefachat something, maybe a little corrected, but to actively add - this will not be. <br><br>  Bcc is a set of utilities that uses BPF to profile different parts of the kernel.  The picture is all the names of utilities.  You can virtually any place in the kernel trace, file in the kernel. <br><br>  BPF has the disadvantage that it does not have its own scripting language, as DTrace and SystemTap have, but there are already some developments in this direction.  In particular, the Red Hat guys connected, they took their SystemTap and made it build for BPF.  That is, the SystemTap language is used, but it works on BPF.  It is still limited, does not support the string type at all, but they are working on it. <br><br>  The bottom line is that BPF seems to be our distant bright future, and it is the largest common denominator that all companies eventually came to because there were some Facebook scripts that Red Hat had SystemTap because they needed to develop something to treysit.  They solved their task and they do not need anything else.  And BPF is what should as a result solve the needs of all, and it is already right in the core of the box ready and, it seems, in the end everyone will come to this and in a couple of years there will be great happiness. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6a4/ff2/3b3/6a4ff23b35840c7ef9c4e1406c2dae2a.png"><br><br>  The main question that excites the minds of millions: "Well, a lot of tools, what and when to use?".  What I personally use.  Debuggers  If you suspect lock contention, it is easy to suspect it, you won't see in perf top that someone is eating a lot of time, probably, it is hanging in locks.  Perf, if you think that you have rested against the CPU, it is visible in the usual htop - this is the process, it is eating a lot of CPU.  Pmcstat, if you have FreeBSD, SystemTap, it seems to me a useless tool for the reason that there is a perf - it is more convenient.  This is meant in the context of profiling, that is, I can perf'om, and for SystemTap tracing it is nothing, it is just not about profiling. <br><br>  DTrace is if you are sitting on a Mac, then it is your everything, because it can do everything. <br><br>  HeapTrack for memory, Vagrant Massif - if you are on Linux, and BPF is a bright future, but now I would not put 4. 9 into the product, but maybe you are bolder, again. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d43/0e6/d1e/d430e6d1e0a88450ba049921fdd556fc.png"><br><br>  I would like to recommend books co-authored by Brandon Gregg. <br><br>  The first one is Systems Performance: Enterprise and the Cloud - an amazing book, it must be read to everyone.  This is one of the best books I have read that is related to programming.  She blew my brain, then shrapnel touched my colleagues' brains, in general, just read. <br><br>  The second book about DTrace is also a book by Brandon Gregg in collaboration with a guy who I don‚Äôt know what is remarkable about.  I did not read it, I looked through it, it is such a big collection of recipes about DTrace.  A command is given there, and what it does is sample scripts.  And so on a thousand pages.  It seems to me that this is not very interesting reading, but if you are very interested in DTrace, it will not be harmful to look through the evening. <br><br>  A bunch of online resources: <br><br><ul><li>  This is a <a href="http://eax.me/">link to my blog</a> ; <br></li><li>  <a href="http://www.brendangregg.com/blog/index.html">http://www.brendangregg.com/blog/index.html</a> - Brendon Gregg's blog - be sure to subscribe, he will post mind-blowing things there. <br></li><li>  <a href="http://dtrace.org/blogs/">http://dtrace.org/blogs/</a> - I also read the DTrace blog, there are interesting articles there. <br></li><li>  Farther.  <a href="https://sourceware.org/systemtap/">https://sourceware.org/systemtap/</a> - SystemTap site. <br></li><li>  FreeBSD on the wiki - <a href="https://wiki.freebsd.org/DTrace">https://wiki.freebsd.org/DTrace</a> <br></li><li>  And in the handbook you can read about DTrace.  Even if you are using a Mac, still look through the handbook, there are good examples there - <a href="https://www.freebsd.org/doc/handbook/dtrace.html">https://www.freebsd.org/doc/handbook/dtrace.html</a> <br></li><li>  And at the end of the manual Intel - <a href="http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html">http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html</a> .  There you can read, actually, what parasitizes perf, what RMC is, right in the processors there are instructions that allow you to measure all this. <br></li></ul><br>  That's all I wanted to say. <br><br><blockquote>  <font color="gray">This report is a transcript of one of the best speeches at the conference of developers of high-loaded <a href="http://highload.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad ++</a> systems.</font>  <font color="gray">Less than a month is left before the HighLoad ++ 2017 conference.</font> <font color="gray"><br><br></font>  <font color="gray">We have already prepared <a href="http://www.highload.ru/2017/abstracts">the conference program</a> , now the schedule is being actively formed.</font> <font color="gray"><br><br></font>  <font color="gray">This year, reports on the tag "The <strong>right handles</strong> ":</font> <font color="gray"><br></font> <ul><li>  <a href="http://www.highload.ru/2017/abstracts/2998.html">I want to compress everything</a> / Andrey Aksenov </li><li>  <a href="http://www.highload.ru/2017/abstracts/2891.html">Protection from DDoS at the system design stage</a> / Ramil Hantimirov </li><li>  <a href="http://www.highload.ru/2017/abstracts/2960.html">What to do in the evening, if I know how much ++ i + ++ i will be</a> / Andrey Borodin </li><li>  <a href="http://www.highload.ru/2017/abstracts/2991.html">How to develop a library of components without breaking it</a> / Arthur Udalov </li></ul><br><br>  Also, some of these materials are used by us in an online training course on the development of high-load systems <a href="http://highload.guide/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">HighLoad.Guide</a> is a chain of specially selected letters, articles, materials, videos.  Already, in our textbook more than 30 unique materials.  Get connected! <br></blockquote></div><p>Source: <a href="https://habr.com/ru/post/340394/">https://habr.com/ru/post/340394/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../340382/index.html">Russian Design Cup 2017</a></li>
<li><a href="../340384/index.html">Creating a component library using Storybook</a></li>
<li><a href="../340386/index.html">SOC for beginners. SOC objectives: monitoring</a></li>
<li><a href="../340388/index.html">ATMii worm allows you to steal money from ATMs</a></li>
<li><a href="../340390/index.html">On the issue of strangeness and the impossible</a></li>
<li><a href="../340396/index.html">Writing Arcsight FlexConnector. Log file</a></li>
<li><a href="../340400/index.html">Competition Topcoder "Konica-Minolta Pathological Image Segmentation Challenge". Member Notes</a></li>
<li><a href="../340402/index.html">Open broadcast from the main hall of SmartData 2017: speech is not about solutions - speech is about evolution</a></li>
<li><a href="../340404/index.html">Comparison and creation of morphological analyzers in the NLTK</a></li>
<li><a href="../340406/index.html">Microsoft and Amazon introduced a new library for machine learning - Gluon</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>