<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SObjectizer-5.6.0: cut to pieces to grow further</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On the third day, a new version of SObjectizer became available : 5.6.0 . Its main feature is the rejection of compatibility with the previous stable ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SObjectizer-5.6.0: cut to pieces to grow further</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/vp/ah/jx/vpahjx-dkpsauwtfzyeiktnsfp4.jpeg"></p><br><p>  On the third day, a <a href="https://groups.google.com/d/msg/sobjectizer/tMnkM6H-z-k/NEkM_bxXBQAJ">new version of SObjectizer</a> became available <a href="https://groups.google.com/d/msg/sobjectizer/tMnkM6H-z-k/NEkM_bxXBQAJ">: 5.6.0</a> .  Its main feature is the rejection of compatibility with the previous stable branch 5.5, which has progressively developed over four and a half years. </p><br><p>  The basic principles of SObjectizer-5 work remain the same.  Messages, agents, collaborations, and dispatchers are still with us.  But something seriously changed, something was thrown away altogether.  So just take SO-5.6.0 and recompile your code will not work.  Something needs to be rewritten.  Something may have to be redesigned. </p><br><p>  Why did we care about compatibility for several years, and then decided to take everything and break it?  And what broke the most thoroughly? </p><br><p>  I will try to tell about it in this article. </p><br><h1 id="zachem-voobsche-potrebovalos-chto-to-lomat">  Why do I need to break something? </h1><br><p>  It's just that simple. </p><a name="habracut"></a><br><p>  SObjectizer-5.5 during its development has absorbed so much of all different and diverse, which was not originally planned, and as a result, he had too many crutches and props inside.  With each new version, adding something new to SO-5.5 became harder and harder.  And in the end, the question "Why do we need all this?"  There was no suitable answer. </p><br><p>  So the first reason is the over-complication of the SObjectizer's giblets. </p><br><p>  The second reason is that we are stupidly tired of focusing on the old C ++ compilers.  Branch 5.5 started in 2014, when we had, if I'm not mistaken, gcc-4.8 and MSVS2013.  And at this level, we have so far continued to keep the bar on requirements for the level of support for the C ++ standard. </p><br><p>  Initially, we had this, let's say, "selfish interest."  In addition, for some time we considered the low quality requirements for supporting the C ++ standard as our ‚Äúcompetitive advantage‚Äù. </p><br><p>  But time passes, selfish interest is over.  Some benefits from such a "competitive advantage" is not visible.  Maybe they would be if we worked at all with C ++ 98, then a bloody enterprise might be interested in us.  But a bloody enterprise in such as we are not interested in principle.  Therefore, it was decided to stop limiting yourself and take something fresher.  So we took the freshest of the stable at the moment: C ++ 17. </p><br><p>  Obviously, not everyone will like this solution; after all, for many, C ++ 17 is now an unattainable cutting edge, which is still very, very far away. </p><br><p>  Nevertheless, we decided on such a risk.  All the same, the process of promoting SObjectizer is not going fast, so that when SObjectizer becomes more or less widely demanded, C ++ 17 will no longer be a front edge.  Rather, it will be treated the same way as it is now in C ++ 11. </p><br><p>  In general, instead of continuing to build crutches using a subset of C ++ 11, we decided to seriously rework the insides of SObjectizer using C ++ 17.  To build a base on the basis of which SObjectizer can progressively develop over the next four or five years. </p><br><h1 id="chto-serezno-pomenyalos-v-sobjectizer-56">  What seriously changed in SObjectizer-5.6? </h1><br><p>  And now let's take a quick look at some of the most striking changes. </p><br><h2 id="u-kooperaciy-agentov-bolshe-net-strokovyh-imen">  Agent cooperatives no longer have string names </h2><br><h3 id="problema">  Problem </h3><br><p>  From the very beginning, SObjectizer-5 demanded that each co-operation should have its own unique string name.  This feature was inherited by the fifth SObjectizer in a legacy from the previous, fourth SObjectizer. </p><br><p>  Accordingly, SObjectizer had to keep the names of registered cooperatives.  Check their uniqueness at registration.  Search co-operation by name for deregistration, etc., etc. </p><br><p>  Since the very first versions in SObjectzer-5 a simple scheme has been used: a single dictionary of registered cooperatives protected by mutex.  When registering a cooperation, mutex is captured, the uniqueness of the name of the cooperation, the presence of a parent, etc. is checked  After performing the checks, the dictionary is modified, after which the mutex is released.  This means that if registration / deregistration of several cooperations simultaneously began at once, then at some moments they will be suspended and wait until one of the operations finishes work with the cooperation dictionary.  Because of this, operations with cooperatives did not scale well. </p><br><p>  I wanted to get rid of all this in order to improve the situation with the speed of registration of cooperatives. </p><br><h3 id="reshenie">  Decision </h3><br><p>  Considered two main ways to solve this problem. </p><br><p>  First, the preservation of string names, but changing the way the dictionary is stored so that the cooperation registration operation can scale.  For example, dictionary sharding, i.e.  splitting it into several pieces, each of which would be protected by its mutex. </p><br><p>  Secondly, the complete rejection of string names and the use of some identifiers assigned by SObjectizer. </p><br><p> In the results, we chose the second method and completely abandoned the naming of cooperatives.  Now in SObjectizer there is such a thing as <code>coop_handle</code> , i.e.  some handle whose contents are hidden from the user, but which can be compared with <code>std::weak_ptr</code> . </p><br><p>  SObjectizer returns <code>coop_handle</code> when registering a cooperation: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    .</span></span></code> </pre> <br><p>  This handle should be used when deregistering cooperation: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> coop = env.make_coop(); ... <span class="hljs-comment"><span class="hljs-comment">//    . auto coop_id = env.register_coop(std::move(coop)); // . //   coop_id    . ... // - . // ,     . //       . env.deregister_coop(coop_id, ...);</span></span></code> </pre> <br><p>  Also, this handle should be used when setting up the parent-child relationship: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   . auto parent = env.make_coop(); ... //  parent . auto parent_id = env.register_coop(std::move(parent)); //  . ... //      ,    . auto child = env.make_coop(parent_id); ...</span></span></code> </pre> <br><p>  The storage structure for cooperations within the SObjectizer Environment has also changed dramatically.  If up to version 5.5 inclusive it was one common dictionary, then now each cooperation is a repository of links to subsidiary cooperations.  Those.  cooperatives form a tree with a root in a special root co-operation hidden from the user. </p><br><p>  Such a structure allows scaling of the <code>register_coop</code> and <code>deregister_coop</code> much better: mutual blocking of parallel operations occurs only if they both belong to the same parent cooperation.  For clarity, here is the result of launching a <a href="">special benchmark</a> that measures the performance of cooperation operations on my old Ubuntu 16.04 and GCC-7.3 laptop: </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 15.69s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p>  Those.  version 5.6.0 managed almost 2M cooperations in ~ 15.5 seconds. </p><br><p>  But version 5.5.24.4, the last of the 5.5 branch at the moment: </p><br><pre> <code class="plaintext hljs">_test.bench.so_5.parallel_parent_child -r 4 -l 7 -s 5 Configuration: roots: 4, levels: 7, level-size: 5 parallel_parent_child: 46.856s 488280 488280 488280 488280 Total: 1953120</code> </pre> <br><p>  The same scenario, but the result is three times worse. </p><br><h2 id="ostalsya-vsego-odin-vid-dispetcherov">  Only one type of dispatcher is left. </h2><br><p>  Dispatchers are one of the cornerstones of SObjectizer.  It is the dispatchers who determine where and how agents will process their messages.  So, without the idea of ‚Äã‚Äãcontrollers, there probably wouldn't be a SObjectizer. </p><br><p>  However, the dispatchers themselves evolved, evolved and evolved to the point that it was not difficult for us to make a new dispatcher for SObjectizer-5.5 even for ourselves.  But very troublesome.  However, let's go in order. </p><br><p>  Initially, all dispatchers that are needed by the application could only be created during the start of a SObjectizer: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { <span class="hljs-comment"><span class="hljs-comment">/* -   */</span></span> }, <span class="hljs-comment"><span class="hljs-comment">//    SObjectizer-. []( so_5::environment_params_t &amp; params ) { p.add_named_dispatcher("active_obj", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("shutdowner", so_5::disp::active_obj::create_disp()); p.add_named_dispatcher("groups", so_5::disp::active_group::create_disp()); ... } );</span></span></code> </pre> <br><p>  I didn‚Äôt create the necessary dispatcher before the start - everything is to blame, nothing can be changed. </p><br><p>  It is clear that this is inconvenient and as the use of SObjectizer scenarios has expanded, this problem has to be solved.  Therefore, the <code>add_dispatcher_if_not_exists</code> method <code>add_dispatcher_if_not_exists</code> , which checked for the presence of a dispatcher and, if not, allowed to create a new instance: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Such dispatchers were called public.  Public controllers had unique names.  And with the help of these names, agents were assigned to dispatchers: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . env.add_dispatcher_if_not_exists( "extra_dispatcher", []{ return so_5::disp::active_obj::create_disp(); } ); //         //    . auto coop = env.create_coop( "ping_pong", //     extra_dispatcher. so_5::disp::active_obj::create_disp_binder( "extra_dispatcher" ) ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  But public controllers had one unpleasant feature.  They began to work immediately after their addition to the SObjectizer Environment and continued to work until the SObjectizer Environment completed its work. </p><br><p>  Again, over time, this began to interfere.  It was necessary to make it so that it was possible to add dispatchers as needed and so that dispatchers that became unnecessary were automatically removed. </p><br><p>  So there were "private" dispatchers.  These dispatchers did not have names and lived until references to them existed.  It was possible to create private dispatchers at any time after launching the SObjectizer Environment, they were automatically destroyed. </p><br><p>  In general, private dispatchers proved to be a very successful link in the evolution of dispatchers, but working with them was very different from working with public dispatchers: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::create_private_disp(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp-&gt;binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><p>  Even more private and public controllers differed in implementation.  Therefore, in order not to duplicate the code and not to write separately a public and separately private dispatcher of the same type, it was necessary to use rather complex constructions with patterns and inheritance. </p><br><p>  As a result, I was tired of accompanying all this diversity, and in SObjectizer-5.6 only one type of dispatcher remained.  In fact, it is an analogue of private dispatchers.  But without the explicit mention of the word "private".  So now the fragment shown above will be written as: </p><br><pre> <code class="cpp hljs">so_5::launch( []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) { ... <span class="hljs-comment"><span class="hljs-comment">// - . //     . auto disp = so_5::disp::active_obj::make_dispatcher(env); //         //    . auto coop = env.create_coop( "ping_pong", //      . disp.binder() ); coop-&gt;make_agent&lt; a_pinger_t &gt;(...); coop-&gt;make_agent&lt; a_ponger_t &gt;(...); ... }, //    SObjectizer-. []( so_5::environment_params_t &amp; params ) {...} );</span></span></code> </pre> <br><h2 id="ostalis-tolko-svobodnye-funkcii-send-send_delayed-i-send_periodic">  Only the free functions send, send_delayed and send_periodic remain </h2><br><p>  The development of the API for sending messages in SObjectizer is, in general, probably the most vivid example of how SObjectizer has changed as the support for C ++ 11 has improved in the compilers available to us. </p><br><p>  At first the messages were sent as follows: </p><br><pre> <code class="cpp hljs">mbox-&gt;deliver_message(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...));</code> </pre> <br><p>  Or, if you follow the "recommendations of the best dog breeders" (c): </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt;my_message&gt; msg(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message(...)); mbox-&gt;deliver_message(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg));</code> </pre> <br><p>  However, then we got at our disposal compilers with variadic templates support, and send functions appeared.  It became possible to write like this: </p><br><pre> <code class="cpp hljs">send&lt;my_message&gt;(target, ...);</code> </pre> <br><p>  True, it took some more time to <code>send_to_agent</code> from a simple <code>send</code> whole family, including <code>send_to_agent</code> , <code>send_delayed_to_agent</code> , etc.  And then this family would shrink to the familiar set of <code>send</code> , <code>send_delayed</code> and <code>send_periodic</code> . </p><br><p>  But, despite the fact that the send-functions family was formed quite a long time ago and has been the recommended way of sending messages for several years, the old methods, like <code>deliver_message</code> , <code>schedule_timer</code> and <code>single_timer</code> , were still available to the user. </p><br><p>  But in version 5.6.0 in the public API SObjectizer only the free functions <code>send</code> , <code>send_delayed</code> and <code>send_periodic</code> .  Everything else has either been removed altogether or transferred to internal SObjectizer namespaces. </p><br><p>  So in SObjectizer-5.6, the interface for sending messages has finally become what it should have been if we had compilers with normal support for C ++ 11 from the very beginning.  Well, plus the fact that if we had the experience of using this very normal C ++ 11. </p><br><h2 id="edinyy-format-send_delayed-i-send_periodic">  Single format send_delayed and send_periodic </h2><br><p>  With the functions <code>send_delayed</code> and <code>send_periodic</code> in previous versions of SObjectizer, this is also the case. </p><br><p>  To work with the timer you need to have access to the SObjectizer Environment.  Inside the agent there is a link to the SObjectizer Environment.  And inside mchain, there is such a link.  But inside the mbox, it was not there.  Therefore, if the deferred message was sent to the agent or to mchain, then the <code>send_delayed</code> call was: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...);</code> </pre> <br><p>  For the mbox case, you also had to take a link to the SObjectizer Environment from somewhere else: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;so_environment(), target_mbox, pause, ...);</code> </pre> <br><p>  Such a feature of <code>send_delayed</code> and <code>send_periodic</code> was a fine splinter.  Which is not that much interfered, but pretty annoyed.  And all because initially we did not store in the mbox a link to the SObjectizer Environment. </p><br><p>  Violation of compatibility with previous versions was a good reason to get rid of this splinter. </p><br><p>  Now you can find out from mbox, for which SObjectizer Environment it was created.  And this made it possible to use the uniform format <code>send_delayed</code> and <code>send_periodic</code> for any type of recipient of the timer message: </p><br><pre> <code class="cpp hljs">send_delayed&lt;my_message&gt;(target_agent, pause, ...); send_delayed&lt;my_message&gt;(target_mchain, pause, ...); send_delayed&lt;my_message&gt;(target_mbox, pause, ...);</code> </pre> <br><p>  In the literal sense, "a trifle, but nice." </p><br><h2 id="net-bolshe-ad-hoc-agentov">  No more ad-hoc agents </h2><br><p>  As the saying goes, "Every accident has a name, a middle name and a surname."  In the case of ad-hoc agents, this is my first, middle and last name :( </p><br><p>  The bottom line is this.  When we began to talk about SObjectizer-5 in public, we heard a lot of reproaches about the verbosity of the SObjectizer code of examples.  And to me personally, this verbosity seemed like a serious problem that needs to be seriously addressed. </p><br><p>  One of the sources of verbosity is the need to inherit agents from the special base type <code>agent_t</code> .  And from this, it would seem, can not escape.  Or not? </p><br><p>  So ad-hoc agents appeared, i.e.  agents, for the determination of which there was no need to write out a separate class, it was enough just to set the reaction to messages in the form of lambda functions.  For example, a classic example of ping-pong on ad-hoc agents could be written like this: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pinger = coop-&gt;define_agent(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> ponger = coop-&gt;define_agent(); pinger .on_start( [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ) .event&lt; msg_pong &gt;( pinger, [ponger]{ so_5::send&lt; msg_ping &gt;( ponger ); } ); ponger .event&lt; msg_ping &gt;( ponger, [pinger]{ so_5::send&lt; msg_pong &gt;( pinger ); } );</code> </pre> <br><p>  Those.  no classes  Just call <code>define_agent()</code> from the cooperation and get some object-agent that you can subscribe to incoming messages. </p><br><p>  So in SObjectizer-5, the division into ordinary and ad-hoc agents appeared. </p><br><p>  Which did not bring any visible bonuses, only extra labor costs to support such a division.  And over time, it became clear that ad-hoc agents are like a suitcase without a handle: it's hard to carry and hard to quit.  But when working on SObjectizer-5.6, it was decided to quit after all. </p><br><p>  At the same time, another lesson was learned, perhaps even more important: in any public discussion of the tool on the Internet there will be a huge number of people who care what kind of tool it is, what it is for, why it is like it is supposed to be used, etc.  It is just important for them to express their strong opinion.  In the Russian-speaking segment of the Internet, in addition to this, it is still very important to convey to the developers of the tool how much they are stupid and uneducated, and how much the result of their work is not needed. </p><br><p>  Therefore, you should be very careful what you say.  And you can listen (and only cautiously) to what is said here in this way: "I tried to do it on your tool like this and I don‚Äôt like how much code came out here."  Even here such wishes should be treated very carefully: "I would take your development if you would have been easier here and here." </p><br><p>  Unfortunately, the skill of "filtering" what was said by "well-wishers" on the Internet five years ago was much less than I have now.  Hence, such a specific experiment as ad-hoc agents in SObjectizer. </p><br><h2 id="sobjectizer-56-bolshe-ne-podderzhivaet-sinhronnogo-vzaimodeystviya-agentov">  SObjectizer-5.6 no longer supports synchronous agent interaction. </h2><br><p>  The topic of synchronous interaction between agents is very old and sick. </p><br><p>  It began in the days of SObjectizer-4.  And in SObjectizer-5 continued.  Until finally, the so-called  <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.3.0%2520Synchronous%2520interaction%2520with%2520agents/">service requests</a>  Which initially, it must be admitted, were scary like death.  But then I managed to <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5.9%2520New%2520helper%2520functions%2520request_future%2520and%2520request_value/">give them a more or less decent look</a> . </p><br><p>  But it turned out to be the very case when the first pancake came out lumpy: ( </p><br><p>  Inside SObjectizer, I had to implement the delivery and processing of regular messages in one way, and the delivery and processing of synchronous requests in another way.  It is especially sad that these features had to be reckoned with, including when implementing your own mboxes. </p><br><p>  And after the <a href="https://habr.com/ru/post/426983/">functionality of envelope messages</a> was added to SObjectizer, it became necessary to look even more carefully and more carefully over the differences between ordinary messages and synchronous requests. </p><br><p>  In general, with synchronous requests, when accompanying / developing a SObjectizer, there was too much of a headache.  So much so that at first there appeared a <a href="https://groups.google.com/d/msg/sobjectizer/NLUWxUNinbg/-mjclYjGBwAJ">specific desire to get rid of these very synchronous requests</a> .  And then this desire was realized. </p><br><p>  And in SObjectizer-5.6, agents can interact again only through asynchronous messages. </p><br><p>  And since at times something like a synchronous interaction is still needed, support for this type of interaction <a href="">was brought into the accompanying project so5extra</a> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    "-". using my_request_reply = so_5::extra::sync::request_reply_t&lt;my_request, my_reply&gt;; ... //  ,    . class request_handler final : public so_5::agent_t { ... //  .      . void on_request(typename my_request_reply::request_mhood_t cmd) { ... //  . //      cmd-&gt;request(). //   . cmd-&gt;make_reply(...); //      my_reply. } ... void so_define_agent() override { //       . so_subscribe_self().event(&amp;request_handler::on_request); } }; ... //     . so_5::mbox_t handler_mbox = ...; //        15s. //    ,    . my_reply reply = my_request_reply::ask_value(handler_mbox, 15s, ...); //       my_request.</span></span></code> </pre> <br><p>  Those.  Now working with synchronous requests is fundamentally different in that the request handler does not return a value from the handler method, as it was before.  Instead, the <code>make_reply</code> method is <code>make_reply</code> . </p><br><p>  The new implementation is good in that both the request and the response are sent inside the SObjectizer, as well as ordinary asynchronous messages.  Essentially, <code>make_reply</code> is a slightly more specific implementation of <code>send</code> . </p><br><p>  And, importantly, the new implementation allowed us to obtain functionality that was previously unattainable: </p><br><ul><li>  synchronous requests (i.e. <code>request_reply_t&lt;Request, Reply&gt;</code> objects) can now be saved and / or forwarded to other handlers.  What makes it possible to implement various load balancing schemes; </li><li>  You can make the response to the request come in the usual mbox of the agent initiating the request.  And the initiating agent will process the response in the usual way, like any other message; </li><li>  You can send several requests to different recipients at once, and then sort the answers from them in the order they are received: </li></ul><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> first_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;first_request, first_reply&gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> second_dialog = so_5::extra::sync::<span class="hljs-keyword"><span class="hljs-keyword">request_reply_t</span></span>&lt;second_request, second_reply&gt;; <span class="hljs-comment"><span class="hljs-comment">//         . auto reply_ch = create_mchain(env); //     . first_dialog::initiate_with_custom_reply_to( one_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); second_dialog::initiate_with_custom_reply_to( another_service, reply_ch, so_5::extra::sync::do_not_close_reply_chain, ...); //    . receive(from(reply_ch).handle_n(2).empty_timeout(15s), [](typename first_dialog::reply_mhood_t cmd) {...}, [](typename second_dialog::reply_mhood_t cmd) {...});</span></span></code> </pre> <br><p>  So, it can be said that with synchronous interaction in SObjectizer, the following happened: </p><br><ul><li>  for a long time it was not for ideological reasons; </li><li>  then it was added and it turned out that sometimes this interaction is useful; </li><li>  but experience has shown that the first implementation is not very successful; </li><li>  the old implementation was thrown away altogether, and a new implementation was proposed instead. </li></ul><br><p>  Made work on their own mistakes, in general. </p><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  This article was, quite briefly, told about several changes in SObjectizer-5.6.0 and the reasons behind these changes. </p><br><p>  A more complete list of changes can be found <a href="">here</a> . </p><br><p>  In conclusion, I would like to offer those who have not tried SObjectizer to take and try.  And to share with us our feelings: what you liked, what you didn‚Äôt like, what you didn‚Äôt have enough. </p><br><p>  We carefully listen to all constructive comments / suggestions.  Moreover, in recent years, only what was needed has been included in SObjectizer.  So, if you don‚Äôt tell us what you would like to have in SObjectizer, this will not appear.  And if you tell me, then who knows ...;) </p><br><p>  The project now lives and develops <a href="https://bitbucket.org/sobjectizerteam/sobjectizer">here</a> .  And for those who are used to using only GitHub, there is a <a href="https://github.com/Stiffstream/sobjectizer">GitHub mirror</a> .  This mirror is completely new, so you can ignore the absence of stars. </p><br><p>  Ps.  For news related to SObjectizer, you can follow <a href="https://groups.google.com/forum/">this Google group</a> .  There you can also raise issues related to SObjectizer. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/453256/">https://habr.com/ru/post/453256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../453236/index.html">Prototyping a mobile game, where to start, and how to do it. Part 2</a></li>
<li><a href="../453238/index.html">Running lights on the relay</a></li>
<li><a href="../453242/index.html">Platform for summer events</a></li>
<li><a href="../453246/index.html">ERP - Continuous Degradation System</a></li>
<li><a href="../453248/index.html">Lunar mission ‚ÄúArtemis‚Äù - the production of the main element of the lunar orbital station ‚ÄúLunar Gateway‚Äù has begun</a></li>
<li><a href="../453258/index.html">Making a reverb pedal using PT2399 microcircuits (part 1)</a></li>
<li><a href="../453260/index.html">DPI setting features</a></li>
<li><a href="../453264/index.html">Virtuali-tee: a ‚Äúmedical T-shirt‚Äù that doesn‚Äôt cover but expose</a></li>
<li><a href="../453272/index.html">GitHub Sponsors: a new way to contribute to open source</a></li>
<li><a href="../453274/index.html">Hidden commission Yandex.Money in Samsung Pay</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>