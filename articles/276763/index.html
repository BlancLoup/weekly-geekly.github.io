<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Add reflection for enums in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recently, in our project, it became necessary to programmatically obtain information about enums (enum), for example, the names of constants in the fo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Add reflection for enums in C ++</h1><div class="post__text post__text-html js-mediator-article">  Recently, in our project, it became necessary to programmatically obtain information about enums (enum), for example, the names of constants in the form of strings, as well as a general list of all the constants available in enum. <br><br><pre><code class="hljs swift"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Suit</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-type"><span class="hljs-type">Spades</span></span>, <span class="hljs-type"><span class="hljs-type">Hearts</span></span>, <span class="hljs-type"><span class="hljs-type">Diamonds</span></span>, <span class="hljs-type"><span class="hljs-type">Clubs</span></span> };</code> </pre> <br>  Usually the solution to this problem is based on the duplication of values, for example, inside a switch: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Spades: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Spades"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Hearts: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Hearts"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Diamonds: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Diamonds"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Clubs: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"Clubs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span> };</code> </pre><br>  And perhaps for small transfers such a solution is indeed acceptable, but if there are many values, and especially if they change from time to time, then sooner or later the developer may forget to add or change the corresponding lines in the switch.  Other obvious drawbacks are added here, for example, the fact of the need to duplicate values ‚Äã‚Äãalready causes me some dissatisfaction. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Therefore, I tried to find a way that would not require duplication at all, but at the same time I would completely cope with the task.  I think I did it. <br><br>  Further in the article I will describe a way to organize reflection for enums.  Who cares - welcome under cat. <br><a name="habracut"></a><br><h2>  Why do you need it </h2><br>  There may be many useful uses.  One of them is the serialization of values, for example in JSON. <br>  It can also be useful for the interaction of C ++ code with scripting languages ‚Äã‚Äã(for example, Lua). <br><br><h2>  Requirements </h2><br>  Since we want to avoid duplication of constants in the code, then we need to somehow save information about all the values ‚Äã‚Äãright in the place where the enumeration is defined.  As you may have guessed, you will have to use a macro for this purpose.  Given this, there are some additional requirements: <br><br><ol><li>  The macro syntax for the enum description must be compatible with the normal enum. </li><li>  The enumeration itself (as a type) should not differ from the usual enum (including it should be possible to use typedef later) </li><li>  When describing values, the same possibilities should be retained as in the usual listing. </li></ol>  In other words, we should be able to easily wrap an already existing enumeration into our macro, after which we will immediately (programmatically) access information about it. <br><br>  A prerequisite is also full portability. <br><br><h2>  Result </h2><br>  First, I give a brief description of what happened.  Below in the article will be a description of the implementation details. <br><br>  To add reflection, the enumeration instead of the enum keyword should be declared using the macro <i>Z_ENUM</i> .  For example, for enum CardSuit from the beginning of the article, it looks like this: <br><br><pre> <code class="hljs lisp">Z_ENUM( <span class="hljs-name"><span class="hljs-name">CardSuit</span></span>, Spades, Hearts, Diamonds, Clubs )</code> </pre> <br>  After that, you can get a reference to the EnumReflector object that stores information about it anywhere: <br><br><pre> <code class="hljs pgsql">auto&amp; reflector = EnumReflector::<span class="hljs-keyword"><span class="hljs-keyword">For</span></span>&lt; CardSuit &gt;();</code> </pre><br>  Then everything is simple: <br><br><pre> <code class="hljs ruby">reflector.EnumName(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> == <span class="hljs-string"><span class="hljs-string">"CardSuit"</span></span> reflector.Find(<span class="hljs-string"><span class="hljs-string">"Diamonds"</span></span>).Value(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> == <span class="hljs-number"><span class="hljs-number">2</span></span> reflector.Count(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> == <span class="hljs-number"><span class="hljs-number">4</span></span> reflector[<span class="hljs-number"><span class="hljs-number">1</span></span>].Name(); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> == <span class="hljs-string"><span class="hljs-string">"Hearts"</span></span></code> </pre><hr><br>  The following example shows a more complex listing: <br><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SomeClass</span></span></span><span class="hljs-class"> { public: static const int </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Constant</span></span></span><span class="hljs-class"> = 100; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Z_ENUM</span></span></span><span class="hljs-class">( </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TasteFlags</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">None</span></span></span><span class="hljs-class"> = 0, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Salted</span></span></span><span class="hljs-class"> = 1 &lt;&lt; 0, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sour</span></span></span><span class="hljs-class"> = 1 &lt;&lt; 1, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sweet</span></span></span><span class="hljs-class"> = 1 &lt;&lt; 2, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SourSweet</span></span></span><span class="hljs-class"> = (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sour</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sweet</span></span></span><span class="hljs-class">), </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Other</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Constant</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Last</span></span></span><span class="hljs-class"> ) };</span></span></code> </pre><br>  This time we will get all the available information: <br><br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; reflector = EnumReflector::For&lt; SomeClass::TasteFlags &gt;(); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Enum "</span></span> &lt;&lt; reflector.EnumName() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; val : reflector) { <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"Value "</span></span> &lt;&lt; val.Name() &lt;&lt; <span class="hljs-string"><span class="hljs-string">" = "</span></span> &lt;&lt; val.Value() &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre><br>  Conclusion: <br><br><pre> <code class="hljs pgsql">Enum TasteFlags <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> Salted = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> Sour = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> Sweet = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> SourSweet = <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> Other = <span class="hljs-number"><span class="hljs-number">100</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> Last = <span class="hljs-number"><span class="hljs-number">101</span></span></code> </pre><br><h2>  Special features </h2><br><ul><li>  Unlike the usual enum, a comma is not allowed after the last value. </li><li>  If an enumeration is declared outside the class (at the namespace level), then instead of <i>Z_ENUM</i> , you should use a completely analogous <i>Z_ENUM_NS</i> </li></ul>  The causes of these two points are discussed in the next section. <br><br><h2>  Implementation details </h2><br>  So, the most interesting. <br><br>  <b>Note: The code provided here is simplified in order to improve readability.</b>  <b>You can find the full version on the githab, the link at the end of the article.</b> <br><br>  Macro Z_ENUM: <br><br><pre> <code class="hljs kotlin">#define Z_ENUM(enumName, ...)\ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> enumName : int \ { \ __VA_ARGS__ \ }; \ friend <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ::EnumReflector&amp; _detail_reflector_(enumName) \ { \ static <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ::EnumReflector reflector( []{ \ static int sval; \ sval = <span class="hljs-number"><span class="hljs-number">0</span></span>; \ struct val_t \ { \ val_t(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val_t&amp; rhs) : _val(rhs) { sval = _val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } \ val_t(int <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) : _val(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) { sval = _val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } \ val_t() : _val(sval){ sval = _val + <span class="hljs-number"><span class="hljs-number">1</span></span>; } \ \ val_t&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> val_t&amp;) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } \ val_t&amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=(int) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } \ <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> int() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _val; } \ int _val; \ } __VA_ARGS__; \ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> int vals[] = { __VA_ARGS__ }; \ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ::EnumReflector( vals, sizeof(vals)/sizeof(int), \ #enumName, Z_ENUM_DETAIL_STR((__VA_ARGS__)) ); \ }() ); \ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reflector; \ } #define Z_ENUM_DETAIL_STR(x) #x</code> </pre><br><div class="spoiler">  <b class="spoiler_title">An example of what it turns</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> TasteFlags:<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { None = <span class="hljs-number"><span class="hljs-number">0</span></span>, Salted = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">0</span></span>, Sour = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">1</span></span>, Sweet = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">2</span></span>, SourSweet = (Sour | Sweet), Other = Constant, Last }; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ::EnumReflector&amp; _detail_reflector_(TasteFlags) { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ::<span class="hljs-function"><span class="hljs-function">EnumReflector </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reflector</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( [] { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">static</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sval; sval = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">; struct </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">val_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">val_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">val_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rhs) : _val(rhs) { sval = _val + </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; } </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">val_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val) : _val(val) { sval = _val + </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; } </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">val_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">() : _val(sval){ sval = _val + </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">; } </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">val_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator</span></span></span></span><span class="hljs-function"><span class="hljs-params">=(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">val_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp;) { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">; } </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">val_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator</span></span></span></span><span class="hljs-function"><span class="hljs-params">=(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">) { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">; } </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">operator</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">() </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> { </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _val; } </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> _val; } None = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Salted = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Sour = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Sweet = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, SourSweet = (Sour | Sweet), Other = Constant, Last; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> vals[] = { None = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Salted = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Sour = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, Sweet = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, SourSweet = (Sour | Sweet), Other = Constant, Last }; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">return</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ::EnumReflector( vals, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(vals)/</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">sizeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">), </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"TasteFlags"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"( None = 0, Salted = 1 &lt;&lt; 0, Sour = 1 &lt;&lt; 1, Sweet = 1 &lt;&lt; 2, SourSweet = (Sour | Sweet), Other = Constant, Last)"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ); }())</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reflector; }</code> </pre></div></div><br>  Consider it in parts: <br><br>  At the beginning, <i>Z_ENUM is</i> expanded into a regular enum.  You may notice that the underlying data type is explicitly indicated - <i>int</i> .  This is done only because in <i>EnumReflector</i> , values ‚Äã‚Äãare now stored with type <i>int</i> .  If necessary, <i>int</i> can be replaced by a larger type. <br><br>  After that a <i>friend is</i> declared <i>_detail_reflector_</i> .  It takes a value of the type of our enumeration and returns a reference to the EnumReflector object, which is actually a static object declared inside it. <br><br>  Looking ahead a bit, I‚Äôll give the <i>EnumReflector :: For</i> function, which serves as an external interface for getting the EnumReflector object: <br><br><pre> <code class="hljs kotlin">template&lt;typename EnumType&gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EnumReflector&amp; EnumReflector::For(EnumType <span class="hljs-keyword"><span class="hljs-keyword">val</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _detail_reflector_(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span>); }</code> </pre>  The trick here is that <acronym>ADL is</acronym> used to search for the <i>_detail_reflector_</i> function by argument type.  It is through <acronym>ADL that</acronym> we can get information for enumerations, regardless of their class or namespace. <br><br>  But back to the <i>_detail_reflector_</i> function. <br><br>  To ensure atomicity, the entire initialization of the static object EnumReflector occurs inside an unnamed lambda function.  Consider it in more detail. <br><br>  First, it declares a static counter variable <i>sval</i> .  It is static because we need to access it from the local class <i>val_t</i> , defined below.  Without an additional state, the local class can obviously access only static variables of the external block.  The <i>sval</i> variable will store the following value for the constant.  The next line we initialize it to 0. <br><br><div class="spoiler">  <b class="spoiler_title">What for?</b> <div class="spoiler_text">  At first glance, this is a meaningless action: initially a static variable is already initialized to 0, and this code will be executed only once.  However, after some tests, I noticed that compilers optimize this code much better if we explicitly reset the value before use.  This is probably due to the fact that in this case the compiler does not need to start from possible previous values ‚Äã‚Äãof <i>sval</i> <br></div></div><br>  Further the <i>val_t</i> type is <i>defined</i> .  After the description of the type, <i>__VA_ARGS__</i> (the values ‚Äã‚Äãof our enumeration) is revealed once again.  That is, we define local variables of the <i>val_t</i> type - and their number corresponds to the number of values ‚Äã‚Äãin the enumeration, and the names correspond to the constants themselves (they overlap the real constants of the enum defined before this).  In order for the initialization of these variables to work correctly, the val_t type has three constructors.  Each of them additionally sets <i>sval</i> to the next value after itself, in case the next constant does not have a specially specified value. <br><br>  In this place, if after the last value there is a comma, a syntax error will occur. <br><br>  After, we need to "overtake" the values ‚Äã‚Äãfrom the variables in the array of type <i>int</i> .  Thanks to the conversion operator in <i>int</i> , <i>val_t</i> is quite simple to do this - we can immediately use our variables of type <i>val_t</i> as array initializers, once again revealing <i>__VA_ARGS__</i> .  Since assignments may contain assignments, we add two assignment operators to val_t, which do nothing - so we completely ignore assignments. <br><br>  Now, when we have an array of all values ‚Äã‚Äãand we know their number, we need to get the names of the constants in the form of strings.  To do this, all values ‚Äã‚Äãare wrapped in a string of the form "(__VA_ARGS__)".  This string, along with a pointer to the array and the number of elements, is passed to the constructor of <i>EnumReflector</i> .  He needed only to parse the string, selecting the names of the constants from it, and save all values. <br><br>  The speed parser itself is organized as a simple finite state machine. <br><br><div class="spoiler">  <b class="spoiler_title">Parser code in EnumReflector</b> <div class="spoiler_text"><pre> <code class="hljs ruby">struct EnumReflector::Private { struct Enumerator { std::string name; int value; }; std::vector&lt;Enumerator&gt; values; std::string enumName; }; static bool IsIdentChar(char c) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'A'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'Z'</span></span>) <span class="hljs-params"><span class="hljs-params">||</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'a'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'z'</span></span>) <span class="hljs-params"><span class="hljs-params">||</span></span> (c &gt;= <span class="hljs-string"><span class="hljs-string">'0'</span></span> &amp;&amp; c &lt;= <span class="hljs-string"><span class="hljs-string">'9'</span></span>) <span class="hljs-params"><span class="hljs-params">||</span></span> (c == <span class="hljs-string"><span class="hljs-string">'_'</span></span>); } EnumReflector::EnumReflector(const int* vals, int count, const char* name, const char* body) : _data(new Private) { _data-&gt;enumName = name; _data-&gt;values.resize(count); enum states { state_start, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Before identifier state_ident, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> In identifier state_skip, <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Looking <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> separator comma } state = state_start; assert(*body == <span class="hljs-string"><span class="hljs-string">'('</span></span>); ++body; const char* ident_start = nullptr; int value_index = <span class="hljs-number"><span class="hljs-number">0</span></span>; int level = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;;) { assert(*body); switch (state) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-symbol"><span class="hljs-symbol">state_start:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsIdentChar(*body)) { state = state_ident; ident_start = body; } ++body; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-symbol"><span class="hljs-symbol">state_ident:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!IsIdentChar(*body)) { state = state_skip; assert(value_index &lt; count); _data-&gt;values[value_index].name = std::string(ident_start, body - ident_start); _data-&gt;values[value_index].value = vals[value_index]; ++value_index; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++body; } <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-symbol"><span class="hljs-symbol">state_skip:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*body == <span class="hljs-string"><span class="hljs-string">'('</span></span>) { ++level; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (*body == <span class="hljs-string"><span class="hljs-string">')'</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level == <span class="hljs-number"><span class="hljs-number">0</span></span>) { assert(value_index == count); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } --level; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (level == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; *body == <span class="hljs-string"><span class="hljs-string">','</span></span>) { state = state_start; } ++body; } } }</code> </pre><br></div></div>  We simply follow the string, keeping the identifiers (the names of the constants).  After the next identifier, we look for the beginning of the next identifier, and so on.  At the end we have a ready-made data structure containing all the information about the listing. <br><br>  The rest of the implementation of the <i>EnumReflector</i> class serves to obtain this information and, in my opinion, is not of particular interest for this article.  I remind you that at the end there is a link to the full version. <br><br>  When an enumeration is declared outside the class, the <i>_detail_reflector_</i> function must be declared not as a <i>friend</i> , but as an <i>inline</i> .  Hence the need for a separate macro <i>Z_ENUM_NS</i> .  In order not to accidentally use <i>Z_ENUM_NS</i> in the class body, it also has an empty <i>extern "C" {}</i> block (I remind you that its use in the class body is not allowed by the standard, so we get a compilation error). <br><br>  Also, to avoid the occurrence of name collisions with constants, in the full version all identifiers inside the <i>_detail_reflector_</i> function have the prefix <i>_detail_</i> . <br><br><h2>  What can be improved </h2><br>  You can try parsing to get the titles right at compile time, using user-defined literals for strings and constexpr functions from C ++ 14. <br><br>  It would also be nice to get rid of the need for two different macros to define enumerations in the class and outside the class, but so far I have not found a way to do this without breaking the ADL search. <br><br><h2>  Links </h2><br>  Full version of the code from the article: <a href="https://github.com/thedsi/EnumReflection">github.com</a> . <br>  Argument-Dependent Lookup: <a href="http://en.cppreference.com/w/cpp/language/adl">cppreference.com</a> . <hr><br>  That's all.  I hope the article turned out to be interesting. <br><br>  PS: Welcome suggestions for improving this method. </div><p>Source: <a href="https://habr.com/ru/post/276763/">https://habr.com/ru/post/276763/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276753/index.html">The digest of interesting materials from the world of web development and IT for the last week No. 197 (February 1 - 7, 2016)</a></li>
<li><a href="../276755/index.html">Does Google promote me sell kidney meme in Russia?</a></li>
<li><a href="../276757/index.html">Configuring Intel Edison Board for Microsoft Azure IoT suite</a></li>
<li><a href="../276759/index.html">For the first time in 10 years ... we have redesigned the site.</a></li>
<li><a href="../276761/index.html">Email and Security: Is it possible to protect email correspondence?</a></li>
<li><a href="../276771/index.html">Writing chat on Vert.x 3</a></li>
<li><a href="../276773/index.html">Over-provisioning resources in mesos-based clusters</a></li>
<li><a href="../276775/index.html">New version of Visual Studio Tools for Unity has been released.</a></li>
<li><a href="../276777/index.html">Viber for Windows and message history</a></li>
<li><a href="../276779/index.html">Sign up for new online courses from Mail.Ru Group on Stepic</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>