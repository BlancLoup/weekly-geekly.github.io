<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>C ++ exception handling under the hood. Part 3</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Continuing to translate a series of articles about exception handling in C ++. 

 1 part 
 Part 2 

 C ++ exceptions under the hood: finding the right...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>C ++ exception handling under the hood. Part 3</h1><div class="post__text post__text-html js-mediator-article">  Continuing to translate a series of articles about exception handling in C ++. <br><br>  <a href="https://habrahabr.ru/post/279111/">1 part</a> <br>  <a href="https://habrahabr.ru/post/279151/">Part 2</a> <br><br><h1>  C ++ exceptions under the hood: finding the right landing pad </h1><br>  This is the 15th chapter in our long history.  We have already studied quite a lot about how exceptions work, and even have a written, working personal function with a small amount of reflection that determines where the catch-block is located (landing pad in terms of exceptions).  In the last chapter, we wrote a personal function that can handle exceptions, but it always substitutes only the first landing pad (that is, the first catch block).  Let's improve our personalized function by adding the ability to choose the correct landing pad in functions with several catch blocks. <br><a name="habracut"></a><br>  Following the TDD (test driven development) mode, we can first build a test of our ABI.  Improve our program, throw.cpp, make several try / catch blocks: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre><code class="hljs swift">#include &lt;stdio.h&gt; #include <span class="hljs-string"><span class="hljs-string">"throw.h"</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Fake_Exception</span></span></span><span class="hljs-class"> </span></span>{}; void raise() { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-type"><span class="hljs-type">Exception</span></span>(); } void try_but_dont_catch() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { printf(<span class="hljs-string"><span class="hljs-string">"Running a try which will never throw.\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-type"><span class="hljs-type">Fake_Exception</span></span>&amp;) { printf(<span class="hljs-string"><span class="hljs-string">"Exception caught... with the wrong catch!\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { raise(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-type"><span class="hljs-type">Fake_Exception</span></span>&amp;) { printf(<span class="hljs-string"><span class="hljs-string">"Caught a Fake_Exception!\n"</span></span>); } printf(<span class="hljs-string"><span class="hljs-string">"try_but_dont_catch handled the exception\n"</span></span>); } void catchit() { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { try_but_dont_catch(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-type"><span class="hljs-type">Fake_Exception</span></span>&amp;) { printf(<span class="hljs-string"><span class="hljs-string">"Caught a Fake_Exception!\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-type"><span class="hljs-type">Exception</span></span>&amp;) { printf(<span class="hljs-string"><span class="hljs-string">"Caught an Exception!\n"</span></span>); } printf(<span class="hljs-string"><span class="hljs-string">"catchit handled the exception\n"</span></span>); } extern <span class="hljs-string"><span class="hljs-string">"C"</span></span> { void seppuku() { catchit(); } }</code> </pre> <br>  Before testing, try to think what will happen in the process of running this test?  Focus on the try_but_dont_catch function: the first try / catch block never throws an exception, the second one is forwarding without catching it.  As long as our ABI is a little dumb, the first catch block will handle the exception of the second block.  But what happens after the first catch is processed?  Execution will continue from the point where the first catch / try ends, again right before the second try / catch block, which again throws an exception, the first handler will again handle it, and so on.  Endless cycle!  Well, we again got a very difficult while (true)! <br><br>  We use our knowledge of the start / length fields in the LSDA table to correctly select our landing pad.  To do this, we need to know what the IP was when the exception was thrown, and we can figure it out with the <em>Unwind</em> function already known to us: <strong>_Unwind_GetIP</strong> .  In order to understand what _Unwind_GetIP returns, let's see an example: <br><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f3</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { L1: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ f1(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} L2: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ f2(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} L3: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ f3(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(...) {} }</code> </pre> <br>  In this case, our personal function will be called in the catch block for f2, and the stack will look like this: <br><br><pre> <code class="hljs ruby">+------------------------------+ <span class="hljs-params"><span class="hljs-params">| IP: f2 stack frame: f2 |</span></span> +------------------------------+ <span class="hljs-params"><span class="hljs-params">| IP: L3 stack frame: foo |</span></span> +------------------------------+</code> </pre> <br>  Note that the IP will be set to L3, although an exception is thrown in L2.  This is because the IP indicates the next instruction that should have been executed.  It also means that we have to subtract one if we want to get an IP where an exception was thrown, otherwise the result from _Unwind_GetIP may be outside the landing pad.  Let's return to our personalized function: <br><br><pre> <code class="hljs perl">_Unwind_Reason_Code __gxx_personality_v<span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> version, _Unwind_Action actions, uint64_t exceptionClass, _Unwind_Exception* unwind_exception, _Unwind_Context* context) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actions &amp; _UA_SEARCH_PHASE) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, lookup phase\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _URC_HANDLER_FOUND; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actions &amp; _UA_CLEANUP_PHASE) { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, cleanup\n"</span></span>); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  --    IP //   ,     uintptr_t throw_ip = _Unwind_GetIP(context) - <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    LSDA LSDA_ptr lsda = (uint8_t*)_Unwind_GetLanguageSpecificData(context); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   LSDA LSDA_Header header(&amp;lsda); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  LSDA CS LSDA_CS_Header cs_header(&amp;lsda); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    LSDA CS const LSDA_ptr lsda_cs_table_end = lsda + cs_header.length; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>      CS <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (lsda &lt; lsda_cs_table_end) { LSDA_CS cs(&amp;lsda); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    LP,      ,   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> cs.lp) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; uintptr_t func_start = _Unwind_GetRegionStart(context); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    IP   lp //  LP    ,  // IP         uintptr_t try_start = func_start + cs.start; uintptr_t try_end = func_start + cs.start + cs.len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> :    LP   try  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (throw_ip &lt; try_start) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (throw_ip &gt; try_end) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    landing pad   ;   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r<span class="hljs-number"><span class="hljs-number">0</span></span> = __builtin_eh_return_data_regno(<span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r1 = __builtin_eh_return_data_regno(<span class="hljs-number"><span class="hljs-number">1</span></span>); _Unwind_SetGR(context, r<span class="hljs-number"><span class="hljs-number">0</span></span>, (uintptr_t)(unwind_exception)); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,        ; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     _Unwind_SetGR(context, r1, (uintptr_t)(<span class="hljs-number"><span class="hljs-number">1</span></span>)); _Unwind_SetIP(context, func_start + cs.lp); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _URC_INSTALL_CONTEXT; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, error\n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _URC_FATAL_PHASE1_ERROR; } } }</code> </pre> <br>  As usual: the actual sample code <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v07">by reference</a> . <br><br>  Run again and voila!  No more endless cycles!  Simple changes allowed us to choose the right landing pad.  Next, we will try to teach our personal function to select the correct stack frame instead of the first one. <br><br><h1>  C ++ exceptions under the hood: finding the right catch block in the landing pad </h1><br>  We have already written a personal function that can handle functions with more than one landing pad.  Now we will try to recognize which block can handle certain exceptions, in other words, which catch block to call us. <br><br>  Of course, finding out which block can handle an exception is not an easy task.  However, were you really waiting for something else?  The main problems right now are: <br><br><ul><li>  First and foremost: where and how we can find the accepted exception types by this catch block. </li><li>  Even if we can find the catch type, how can we handle catch (...)? </li><li>  For a landing pad with several catch blocks, how can we know all the possible catch types? </li><li>  Take a look at an example: </li></ul><br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> {</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Child</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base {}; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> Child; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { foo(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Base&amp;){ ... } }</code> </pre> <br>  We must check not only whether the current Landing Pad can accept the current exception, but also all its parents! <br><br>  Let's make our task a bit simpler: we will work with landing pads with only one catch block, and also say that we do not have inheritance.  However, how do we find landing pad types? <br><br>  In general, this is in the .gcc_except_table part that we have not yet analyzed: the action table.  Disassemble at throw.cpp and see what is there, right after the call site table, for our "try but dont catch" function: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">LLSDACSE1</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0<span class="hljs-selector-tag"><span class="hljs-selector-tag">x1</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.byte</span></span> 0 <span class="hljs-selector-class"><span class="hljs-selector-class">.align</span></span> 4 <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">ZTI14Fake_Exception</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.LLSDATT1</span></span>:</code> </pre> <br>  It does not seem that there is a lot of information, but there is a promising pointer to something that has the name of our exception.  Let's look at the definition of _ZTI14Fake_Exception: <br><br><pre> <code class="hljs css">_<span class="hljs-selector-tag"><span class="hljs-selector-tag">ZTI14Fake_Exception</span></span>: <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">ZTVN10__cxxabiv117__class_type_infoE</span></span>+8 <span class="hljs-selector-class"><span class="hljs-selector-class">.long</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">ZTS14Fake_Exception</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.weak</span></span> _<span class="hljs-selector-tag"><span class="hljs-selector-tag">ZTS9Exception</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.section</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.rodata</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">._ZTS9Exception</span></span>,"<span class="hljs-selector-tag"><span class="hljs-selector-tag">aG</span></span>",@<span class="hljs-keyword"><span class="hljs-keyword">progbits</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">_ZTS9Exception</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">comdat</span></span> .type _ZTS9Exception, @object .size _ZTS9Exception, <span class="hljs-number"><span class="hljs-number">11</span></span></code> </pre> <br>  We found something very interesting!  Can you recognize it?  This is std :: type_info for the Fake_Exception structure! <br><br>  Now we know that there is a way to get a pointer to a kind of reflection for our exclusion.  Can we programmatically find this?  Let's look further. <br><br><h1>  C ++ exceptions under the hood: reflection type exceptions and reading .gcc_except_table </h1><br>  Now we know where we can get a lot of exception information by reading the local data store .gcc_except_table;  what we have to implement in the personal function to determine the correct landing pad. <br><br>  We left our ABI implementation and plunged into examining the assembler for .gcc_except_table to see how we can find the types of exceptions that we can handle.  We found that part of the table contains a list of types with the information we need.  We will read this information in the cleanup phase, but first let's recall the definition of our LSDA header: <br><br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LSDA_Header</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> start_encoding; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type_encoding; <span class="hljs-comment"><span class="hljs-comment">//        uint8_t type_table_offset; };</span></span></code> </pre> <br>  The last field for us is new: it indicates the offset for the type table.  Recall also the definition of each call: <br><br><pre> <code class="hljs ruby">struct LSDA_CS { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>         uint8_t start; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  ,    uint8_t len; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> Landing pad uint8_t lp; <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   action table + <span class="hljs-number"><span class="hljs-number">1</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span>  <span class="hljs-string"><span class="hljs-string">" "</span></span>) uint8_t action; };</code> </pre> <br>  Look at the last field, "action".  This is the offset in the action table.  This means that we can find an action for a specific CS (call site).  The trick is that for landing pads, in which there are catch blocks, the action contains an offset to the type table, now we can use the offset to get the type table that we can get from the headers!  Enough talk, better look at the code: <br><br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/     LSDA LSDA_ptr lsda = (uint8_t*)_Unwind_GetLanguageSpecificData(context); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   LSDA LSDA_Header header(&amp;lsda); const LSDA_ptr types_table_start = lsda + header.type_table_offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  LSDA CS LSDA_CS_Header cs_header(&amp;lsda); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    LSDA CS const LSDA_ptr lsda_cs_table_end = lsda + cs_header.length; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   action tables const LSDA_ptr action_tbl_start = lsda_cs_table_end; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  call site LSDA_CS cs(&amp;lsda); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ cs.action --  offset + 1;   cs.action == 0 /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        const size_t action_offset = cs.action - 1; const LSDA_ptr action = action_tbl_start + action_offset; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  landing pad   catch the action table /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   index   int type_index = action[0]; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ types_table_start    ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    type_index.    ptr  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ std::type_info,    catch- const void* catch_type_info = types_table_start[ -1 * type_index ]; const std::type_info *catch_ti = (const std::type_info *) catch_type_info; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,   -  Fake_Exception printf("%s\n", catch_ti-&gt;name());</span></span></code> </pre> <br>  This code looks complicated because of several consecutive indirect addresses before obtaining the type_info structure, but in practice it does not do anything difficult, it only reads the .gcc_except_table that we found during disassembling. <br><br>  Finding the type of exception is a big step in the right direction.  Also, our personal function becomes a little piled up.  Most of the difficulties of reading LSDA can be hidden under the carpet, it should not be very expensive (meaning - to be a separate function). <br><br>  Next, we will learn how to compare the type of exception handled with the type that is thrown. <br><br><h1>  C ++ exceptions under the hood: getting the correct stack frame </h1><br>  Our latest version of the personal function knows where the information is stored on whether this exception can be handled or not (although it works only for one catch block in one try / catch block, well, also without inheritance), but to make it useful - First, we will learn to check whether the exception by type matches the one we can handle. <br><br>  Of course, we first need to know the type of exception.  For this, we need to write it down when <strong>__cxa_throw</strong> is <strong>called</strong> : <br><br><pre> <code class="hljs delphi">void __cxa_throw(void* thrown_exception, std::type_info *tinfo, void <span class="hljs-comment"><span class="hljs-comment">(*dest)(void*)</span></span>) <span class="hljs-comment"><span class="hljs-comment">{ __cxa_exception *header = ((__cxa_exception *) thrown_exception - 1); //       ,   _Unwind_ //          header-&gt;exceptionType = tinfo; _Unwind_RaiseException(&amp;header-&gt;unwindHeader); }</span></span></code> </pre> <br>  And now we can read the type of the exception in our personal function and just compare the type match (the exception names are C ++ strings, so the simple "==" is enough): <br><br><pre> <code class="hljs pgsql">//       const <span class="hljs-type"><span class="hljs-type">void</span></span>* catch_type_info = lsda.types_table_start[ <span class="hljs-number"><span class="hljs-number">-1</span></span> * type_index ]; const std::type_info *catch_ti = (const std::type_info *) catch_type_info; //     __cxa_exception* exception_header = (__cxa_exception*)(unwind_exception+<span class="hljs-number"><span class="hljs-number">1</span></span>) - <span class="hljs-number"><span class="hljs-number">1</span></span>; std::type_info *org_ex_type = exception_header-&amp;amp;gt;exceptionType; printf("%s thrown, catch handles %s\n", org_ex_type-&gt;<span class="hljs-type"><span class="hljs-type">name</span></span>(), catch_ti-&gt;<span class="hljs-type"><span class="hljs-type">name</span></span>()); // :      //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (org_ex_type-&gt;<span class="hljs-type"><span class="hljs-type">name</span></span>() != catch_ti-&gt;<span class="hljs-type"><span class="hljs-type">name</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>;</code> </pre> <br>  Look <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v09">at the gita</a> recent changes. <br><br>  Hmm, of course we have a problem, can you find it yourself?  If an exception is thrown in two phases and in the first we want to process it, the second time we cannot say that we do not want to process it again.  I don‚Äôt know, _Unwind handles this case, there‚Äôs no documentation about it, there‚Äôs likely to be some unspecified behavior, so just saying that we‚Äôre processing everything is not enough. <br><br>  As long as we taught the personal function to find out which landing pad can handle an exception, we lied to <em>Unwind</em> about which exception can be handled, instead we say that we process them all in our ABI 9. The truth is that we don‚Äôt know - we can Do we process it.  It's easy to fix: we can do something like this: <br><br><pre> <code class="hljs bash">_Unwind_Reason_Code __gxx_personality_v0 (...) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Personality function, searching for handler\n"</span></span>); // ... foreach (call site entry <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> lsda) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (call site entry.not_good()) <span class="hljs-built_in"><span class="hljs-built_in">continue</span></span>; //   landing pad   ;   //     ,  _Unwind_,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (actions &amp; _UA_SEARCH_PHASE) <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> _URC_HANDLER_FOUND; //      ,    _UA_CLEANUP_PHASE /*    */ <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> _URC_INSTALL_CONTEXT; } <span class="hljs-built_in"><span class="hljs-built_in">return</span></span> _URC_CONTINUE_UNWIND; }</code> </pre> <br>  What do we get if we launch our personalized function?  The fall!  Who would doubt that.  Remember our falling function?  Here is what our exception should catch: <br><br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">catchit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { try_but_dont_catch(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Fake_Exception&amp;) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Caught a Fake_Exception!\n"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception&amp;) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"Caught an Exception!\n"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"catchit handled the exception\n"</span></span>); }</code> </pre> <br>  Unfortunately, our personal function checks only the first type of errors that the landing pad can handle.  If we remove the Fake_Exception catch block and try again: everything will finally work correctly!  Our personal function can select the correct catch block in the correct frame, supplied by the try-catch block with a single catch block. <br><br>  In the next chapter we will improve it again! <br><br><h1>  C ++ exceptions under the hood: choose the correct catch from the landing pad </h1><br>  The 19th chapter on exceptions in C ++: we wrote a personal function that can read LSDA, choose the right landing pad, the right stack frame to handle the exception, but still find it difficult to find the right catch branch.  For the final version of the working personal function, we have to check the types of exceptions in the entire action table <strong>.gcc_except_table</strong> . <br><br>  Remember the action table?  Let's look at it again, but now with several catch blocks: <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Call</span></span> site <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> .LLSDACSB2: # <span class="hljs-keyword"><span class="hljs-keyword">Call</span></span> site <span class="hljs-number"><span class="hljs-number">1</span></span> .uleb128 ip_range_start .uleb128 ip_range_len .uleb128 landing_pad_ip .uleb128 (action_offset+<span class="hljs-number"><span class="hljs-number">1</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0x3</span></span> # Rest <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> site <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> # Action <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> .LLSDACSE2: # Action <span class="hljs-number"><span class="hljs-number">1</span></span> .byte <span class="hljs-number"><span class="hljs-number">0x2</span></span> .byte <span class="hljs-number"><span class="hljs-number">0</span></span> # Action <span class="hljs-number"><span class="hljs-number">2</span></span> .byte <span class="hljs-number"><span class="hljs-number">0x1</span></span> .byte <span class="hljs-number"><span class="hljs-number">0x7d</span></span> .align <span class="hljs-number"><span class="hljs-number">4</span></span> .long _ZTI9Exception .long _ZTI14Fake_Exception .LLSDATT2: # <span class="hljs-keyword"><span class="hljs-keyword">Types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span></code> </pre> <br>  If we are going to read all the exceptions supported by the landing pad in this example (this LSDA for the catchit function, by the way), we need to do something like this: <br><br><ul><li>  Get the displacement of the action from the call table (do not forget, we read offset + 1, and 0 means no action) </li><li>  Go to action 2 by offset, get a type index 1. The type table is indexed in the reverse order (i.e. we have a pointer to its end and should get access using -1 * index) </li><li>  Go to types_table [-1] to get type_info for Fake_Exception </li><li>  Fake_Exception is not the exception that was thrown, we get the offset to the next action (action) (0x7d) </li><li>  Reading 0x7d in uleb128 returns -3, which from the position from which we read the offset, is three steps back </li><li>  Reading type with index 2 </li><li>  Getting type_info to exclude Exception, which this time matches the forward one, so that we can set the landing pad! </li></ul><br>  It looks complicated, as long as we have a lot of indirect addressing again, but you can see the final code <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v11">in the repository</a> .  Under the link you will find a bonus in the form of a personal function that can read the type table, determine which catch block we need (if the type is null, the block can handle all exceptions in a row).  There is a funny side effect: we can handle errors only thrown out of C ++ programs. <br><br>  Finally, we know how exceptions are thrown, how the stack is unwound, how the personal function selects the correct stack frame and which catch block to choose inside the landing pad, but we still have a problem: launching the destructors.  Well, further we will change our personal function, having provided support of RAII. <br><br><h1>  C ++ exceptions under the hood: launch destructors in promotion </h1><br>  Our <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v11">mini-ABI 11 version</a> can do almost all of the basic possibilities in exception handling, but it still cannot run the destructor.  This is a very important part if we want to write secure code.  We know that the necessary distrkutory stored .gcc_except_table, so we need to look at the assembler code a little more. <br><br><pre> <code class="hljs pgsql"># <span class="hljs-keyword"><span class="hljs-keyword">Call</span></span> site <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> .LLSDACSB2: # <span class="hljs-keyword"><span class="hljs-keyword">Call</span></span> site <span class="hljs-number"><span class="hljs-number">1</span></span> .uleb128 ip_range_start .uleb128 ip_range_len .uleb128 landing_pad_ip .uleb128 (action_offset+<span class="hljs-number"><span class="hljs-number">1</span></span>) =&gt; <span class="hljs-number"><span class="hljs-number">0x3</span></span> # Rest <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">call</span></span> site <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> # Action <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> .LLSDACSE2: # Action <span class="hljs-number"><span class="hljs-number">1</span></span> .byte <span class="hljs-number"><span class="hljs-number">0</span></span> .byte <span class="hljs-number"><span class="hljs-number">0</span></span> # Action <span class="hljs-number"><span class="hljs-number">2</span></span> .byte <span class="hljs-number"><span class="hljs-number">0x1</span></span> .byte <span class="hljs-number"><span class="hljs-number">0x7d</span></span> .align <span class="hljs-number"><span class="hljs-number">4</span></span> .long _ZTI14Fake_Exception .LLSDATT2: # <span class="hljs-keyword"><span class="hljs-keyword">Types</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span></code> </pre> <br>  In the usual landing pad, when action has a type with an index greater than 0, we can get an index into a type table and can use its search for the required catch block.  Otherwise, when the index is 0, we need to run the cleanup code.  Even if the landing pad cannot handle exceptions, it is still able to perform cleanup during spinup.  Of course, the landing pad must call _Unwind_Resume after the cleanup is complete in order to continue the spinup process. <br><br>  I downloaded a new and latest version of the code into <a href="https://github.com/nicolasbrailo/cpp_exception_handling_abi/tree/master/abi_v12">my githab repository</a> , but I have bad news: remember our cheating when we said that uleb128 == char?  When we started adding code for destructors, the offsets in the .gcc_except_table become large (by "large" I mean they are more than 127) and our trick no longer works. <br><br>  For the next version, we should rewrite our LSDA reader so that it correctly processes the uleb128 code. <br><br>  Even in spite of this, we have reached our goal!  They wrote a mini-ABI that can correctly handle exceptions without the help of the libcxxabi library! <br><br>  Of course, there is still something to do, for example, to handle exceptions that are not native for this language, compatibility support between compilers and linkers.  Maybe sometime later ... <br><br><h1>  C ++ exceptions under the hood: results </h1><br>  After 20 chapters on low-level exception handling, it's time to take stock!  What have we learned about how exceptions are thrown and how they are caught? <br><br>  Leaving aside the scary details about reading .gcc_except_table, which is probably the largest part of this article, we can conclude: <br><br><ul><li>  The C ++ compiler actually does very little work related to exception handling, most of the magic happens in libstdc ++ </li><li>  Here are a few things the compiler does: <br><br><ul><li>  Creates CFI information for stack promotion. </li><li>  It creates something called .gcc_except_table with information about landing pads (try / catch blocks).  Part of the reflection. </li><li>  When we write a throw, the compiler translates this into a couple of calls to libstdc ++, which allocate the exception and then run the promotion. </li></ul><br></li><li>  When an exception is thrown at runtime, __cxa_throw delegates the promotion of the stack to the library libstdc </li><li>  In the process of stack promotion, a special function is called, supplied by the libstdc ++ (called the personal function, personality routine), which checks each function in the stack if it can handle the exception. </li><li>  If no matching catch block is found, the std :: terminate is called. </li><li>  If found, stack promotion starts again from the beginning of the stack. </li><li>  During the second pass, cleaning is performed. </li><li>  The personal function checks the .gcc_except_table for the current method.  If it (the table) contains actions to clean up, the personal function "jumps" into the current frame of the stack to start clearing this method. </li><li>  As soon as the advertiser came across a stack frame (consider the function) that can handle this exception, he jumps into the appropriate catch block </li><li>  After the catch block is executed, the memory occupied by the exception is cleared. </li></ul><br>  Having studied in detail how exceptions are handled, we are now able to say why it is so difficult to write an exception safe code. <br><br>  With a superficial glance, exceptions may seem nice and simple, but it‚Äôs only worth digging a little deeper as we stumble upon a bunch of difficulties, the program literally starts digging into itself (reflection), which is not typical of C ++ applications. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Even if we are talking about high-level languages, when an exception is thrown, we cannot rely on our understanding of the normal execution of code: it is usually performed linearly with small ramifications in the form of if and switch statements. </font><font style="vertical-align: inherit;">With exceptions, everything is different: the code starts to run in an incomprehensible order, unfold the stack, interrupt the execution of functions, and ceases to follow the usual rules. </font><font style="vertical-align: inherit;">The pointer to the instruction changes in each landing pad, the stack spins up without our control, in general, a lot of magic happens under the hood. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">As a result, exceptions are difficult because they break our understanding of the natural execution of the program. </font><font style="vertical-align: inherit;">This does not mean that we are strictly forbidden to use them, but only suggests that we must always be careful when working with them!</font></font><br></div><p>Source: <a href="https://habr.com/ru/post/279149/">https://habr.com/ru/post/279149/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../279133/index.html">The digest of interesting materials for the mobile developer # 144 (on March 9-13)</a></li>
<li><a href="../279139/index.html">We invite everyone to the first hackathon in the history of the Stavropol Territory</a></li>
<li><a href="../279143/index.html">A brief course of computer graphics: setting normal maps in a tangent space</a></li>
<li><a href="../279145/index.html">VKontakte launches the third VK Cup championship</a></li>
<li><a href="../279147/index.html">1.4 SFML and Xcode (Mac OS X)</a></li>
<li><a href="../279151/index.html">C ++ exception handling under the hood. Part 2</a></li>
<li><a href="../279155/index.html">MySQL JSON data type decoding</a></li>
<li><a href="../279157/index.html">Analysis of the election results to the State Duma. Getting ready for the 2016 vote</a></li>
<li><a href="../279159/index.html">3CX call center management</a></li>
<li><a href="../279163/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ202 (March 6 - 13, 2016)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>