<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write microservice on KoaJS 2 in the style of ES2017. Part I: Such Different Assynchrony</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Have you ever had a desire to rewrite everything from scratch, ‚Äúscore‚Äù on compatibility and do everything ‚Äúaccording to the mind‚Äù? Most likely KoaJS w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write microservice on KoaJS 2 in the style of ES2017. Part I: Such Different Assynchrony</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e29/6fa/141/e296fa1411546536514bb71e7983ff5f.png" alt="Koa v2"><br><br>  Have you ever had a desire to rewrite everything from scratch, ‚Äúscore‚Äù on compatibility and do everything ‚Äúaccording to the mind‚Äù?  Most likely KoaJS was created that way.  This framework has been developed by the Express team for several years.  Expresovtsy about these 2 frameworks write like this: <a href="">Philosophically, Koa aims to ‚Äúfix and replace node,‚Äù whereas Express ‚Äúaugments node‚Äù</a> [From a philosophical point of view, Koa seeks to ‚Äúfix and replace a node‚Äù while Express ‚Äúexpands a node‚Äù]. <br><br>  Koa is not burdened with legacy-code support, from the first line you dive into the world of modern ES6 (ES2015), and in version 2 there are already constructions from the future standard ES2017.  In my company, this framework has been in production for 2 years already, one of the projects ( <a href="https://auto.ria.com/">AUTO.RIA</a> ) works at a load of half a million visitors per day.  Despite its bias towards modern / experimental standards, the framework is more stable than Express and many other frameworks with the CallBack-style approach.  This is not due to the framework itself, but to the modern JS constructions that it uses. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In this article, I want to share my koa development experience.  In the first part, the framework itself will be described and a bit of theory on the organization of the code on it, in the second we will create a small rest-service on koa2 and bypass all the rakes that I have already stepped on. <br><a name="habracut"></a><br><h2>  Some theory </h2><br>  Let's take a simple example, write a function that reads data into an object from a JSON file.  For clarity, we will do without "reqiure ('my.json')": <br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readJSONSync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(fs.readFileSync(filename, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>)) } <span class="hljs-comment"><span class="hljs-comment">//... try { console.log(readJSONSync('my.json')); } catch (e) { console.log(e); }</span></span></code> </pre> <br><br>  Whatever problem <b>happens</b> when calling <b>readJSONSync</b> , we will handle this exception.  Everything is great here, but there is a big obvious disadvantage: this function runs synchronously and blocks the flow for the entire duration of the reading. <br><br>  Let's try to solve this problem in the nodejs style with the help of callback-functions: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readJSON</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename, callback</span></span></span><span class="hljs-function">) </span></span>{ fs.readFile(filename, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> callback(err); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { res = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(res); callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, res); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (ex) { callback(ex); } }) } <span class="hljs-comment"><span class="hljs-comment">//... readJSON('my.json', function (err, res) { if (err) { console.log(err); } else { console.log(res); } })</span></span></code> </pre><br><br>  Here everything is fine with asynchronous, but the convenience of working with the code has suffered.  There is another possibility that we will forget to check for the presence of the error 'if (err) return callback (err)' and if an exception occurs when reading the file, everything will ‚Äúfall out‚Äù, the second inconvenience is that we have already plunged one step in called, callback hell.  If there are a lot of asynchronous functions, the nesting will grow and the code will be read very hard. <br><br>  Well, let's try to solve this problem in a more modern way, <b>let's</b> <a href="https://learn.javascript.ru/promise">design the</a> function <b>readJSON with</b> <a href="https://learn.javascript.ru/promise">promis</a> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readJSON</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve,reject</span></span></span><span class="hljs-function">) </span></span>{ fs.readFile(filename,<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) reject(err); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { res = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(res); resolve(res); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { reject(e); } }) }) } <span class="hljs-comment"><span class="hljs-comment">//... readJSON('my.json').then(function (res) { console.log(res); }, function(err) { console.log(err); });</span></span></code> </pre><br><br>  This approach is a bit more progressive, because  we can ‚Äúexpand‚Äù a large complex nesting into a chain of then ... then ... then, it looks approximately like this: <br><pre> <code class="javascript hljs">readJSON(<span class="hljs-string"><span class="hljs-string">'my.json'</span></span>) .then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> readJSON(<span class="hljs-string"><span class="hljs-string">'my2.json'</span></span>) }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); } );</code> </pre><br><br>  This situation, for the time being, does not change significantly, there is a cosmetic improvement in the beauty of the code, it may have become clearer what is being done.  The situation has dramatically changed the appearance of <a href="https://learn.javascript.ru/generator">generators</a> and the <a href="https://github.com/tj/co">co</a> library, which became the basis of the koa v1 engine. <br>  Example: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>), co = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'co'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readJSON</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn</span></span></span><span class="hljs-function">) </span></span>{ fs.readFile(filename,<span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) fn(err); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { res = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(res); fn(<span class="hljs-literal"><span class="hljs-literal">null</span></span>,res); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { fn(e); } }) } } <span class="hljs-comment"><span class="hljs-comment">//... co(function *(){ console.log(yield readJSON('my.json')); }).catch(function(err) { console.log(err); });</span></span></code> </pre><br><br>  In the place where the <b>yield</b> directive is used, the execution of the asynchronous <b>readJSON occurs</b> .  readJSON needs to be redone a bit.  This design code is called thunk-function.  There is a special library that makes the function written in nodejs-style into the thunk-function <a href="https://github.com/tj/node-thunkify">thunkify</a> . <br>  What does this give us?  The most important thing is the code in the part where we call yield, is executed sequentially, we can write <br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> readJSON(<span class="hljs-string"><span class="hljs-string">'my.json'</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> readJSON(<span class="hljs-string"><span class="hljs-string">'my2.json'</span></span>));</code> </pre><br>  and get a consistent execution by first reading 'my.json' then 'my2.json'.  And this is already a "callback goodbye."  Here the ‚Äúugliness‚Äù lies in the fact that we use the feature of the generators work not for their intended purpose, the thunk-function is something non-standard and rewrite everything for koa into such a format ‚Äúnot ice‚Äù.  It turned out that not everything is so bad, yield can be done not only for the thunk-function, but also a promise or even an array of promises or an object with promises. <br>  Example: <br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log( <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> { <span class="hljs-string"><span class="hljs-string">'myObj'</span></span>: readJSON(<span class="hljs-string"><span class="hljs-string">'my.json'</span></span>), <span class="hljs-string"><span class="hljs-string">'my2Obj'</span></span>: readJSON(<span class="hljs-string"><span class="hljs-string">'my2.json'</span></span>) } );</code> </pre><br><br>  It seemed that you couldn‚Äôt think better, but they did.  They made it so that everything was ‚Äúdirectly‚Äù designated.  Meet <a href="https://tc39.github.io/ecmascript-asyncawait/">Async Funtions</a> : <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'fs'</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readJSON</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filename</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) </span></span>{ fs.readFile(filename, <span class="hljs-string"><span class="hljs-string">'utf8'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, res</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) reject(err); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { res = <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(res); resolve(res) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { reject(e) } }) }) } <span class="hljs-comment"><span class="hljs-comment">//... (async() =&gt; { try { console.log(await readJSON('my.json')) } catch (e) { console.log(e) } })();</span></span></code> </pre><br><br>  Do not rush to run, your language will not understand this syntax without <a href="https://babeljs.io/">babel</a> .  Koa 2 works exactly in this style.  You have not yet scrambled? <br><br>  Let's look at how this "killer kolbek" works: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> fs <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'fs'</span></span></code> </pre><br>  similarly <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fs = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'fs'</span></span>)</code> </pre><br><br>  with promisam already familiar. <br><br>  <i>() =&gt; {}</i> Is the so-called ‚Äúarrow function‚Äù, similar to the <i>function () {}</i> entry.  The arrow function has a slight difference - context: this refers to the object in which the arrow function is initialized. <br><br>  <i>async</i> before the function indicates that it is asynchronous, the result of such a function is also a promise.  Since, in our case, after executing this function, there is nothing to do there, we omitted the then or catch call.  It could be as shown below, and this will also work: <br><pre> <code class="javascript hljs">(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> readJSON(<span class="hljs-string"><span class="hljs-string">'my.json'</span></span>)) })().catch (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e) })</code> </pre><br><br>  <i>await</i> is a place where you have to wait for the asynchronous function (promise) to be executed and then work with the result that it returned or handle the exception.  To some extent, this resembles the yield of generators. <br><br>  The theory is over - we can start the first launch of KoaJS. <br><br><h2>  Meet koa </h2><br><br>  ‚ÄúHello world‚Äù for koa: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Koa = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'koa'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Koa(); <span class="hljs-comment"><span class="hljs-comment">// response app.use(ctx =&gt; { ctx.body = 'Hello Koa'; }); app.listen(3000);</span></span></code> </pre><br><br>  a function that is passed as an argument in app.use is called middleware.  Minimalist, isn't it?  In this example, we see a shortened version of the record of this function.  In Koa terminology, middleware can be of three types: <br><ul><li>  common function </li><li>  async function </li><li>  generatorFunction </li></ul><br><br>  Also from the point of view of the code execution phase, middleware is divided into two phases: before (upstream) request processing and after (downstream).  These phases are separated by the next function, which is transmitted in middleware. <br><br><h4>  common function </h4><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// Middleware   2  (ctx, next), ctx   , // next        'downstream'  middleware.   ,       then          . app.use((ctx, next) =&gt; { const start = new Date(); return next().then(() =&gt; { const ms = new Date() - start; console.log(`${ctx.method} ${ctx.url} - ${ms}ms`); }); });</span></span></code> </pre><br><br><h4>  async function (works with babel transpiler) </h4><br><pre> <code class="javascript hljs">app.use(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> next(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() - start; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.method}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.url}</span></span></span><span class="hljs-string"> - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ms}</span></span></span><span class="hljs-string">ms`</span></span>); });</code> </pre><br><br><h4>  generatorFunction </h4><br>  In the case of this approach, it is necessary to include the <a href="https://github.com/tj/co">co</a> library, which since version 2.0 is no longer part of the framework: <br><pre> <code class="javascript hljs">app.use(co.wrap(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> *(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx, next</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> next(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ms = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>() - start; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.method}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ctx.url}</span></span></span><span class="hljs-string"> - </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${ms}</span></span></span><span class="hljs-string">ms`</span></span>); }));</code> </pre><br><br>  Legacy middleware from koa v1 is also supported.  I hope in the upstream examples it is clear where upstream / downstream.  (If not - write to the comments) <br><br>  In the <a href="">context of the ctx request,</a> there are 2 important for us <a href="">request</a> and <a href="">response</a> objects.  In the process of writing middleware, we will analyze some properties of these objects; you can get a full list of properties and methods that you can use in your application by the links provided. <br><br>  It's time to move on to practice, until I have quoted all the ECMAScript documentation <br><br><h2>  We write our first middleware </h2><br>  In the first example, we will extend the functionality of our ‚ÄúHello world‚Äù and add an additional header to the response, which will indicate the processing time of the request, another middleware will write to the log all requests to our application.  Go: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Koa = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'koa'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Koa(); <span class="hljs-comment"><span class="hljs-comment">// x-response-time app.use(async function (ctx, next) { const start = new Date(); await next(); const ms = new Date() - start; ctx.set('X-Response-Time', `${ms}ms`); }); // logger app.use(async function (ctx, next) { const start = new Date(); await next(); const ms = new Date() - start; console.log(`${ctx.method} ${ctx.url} - ${ms}`); }); // response app.use(ctx =&gt; { ctx.body = 'Hello World'; }); app.listen(3000);</span></span></code> </pre><br><br>  The first middleware saves the current date and writes a header to the response at the downstream stage. <br>  The second one does the same thing, only writes not to the heading, but outputs it to the console. <br><br>  It should be noted that if the next method is not called in middleware, then all middleware that are connected after the current one will not take part in processing requests. <br><br>  When testing an example, do not forget to connect babel <br><br><h2>  Error handler </h2><br>  With this task, koa is doing great.  For example, we want in case of any error to respond to the user in the json-format 500 error and the message property with information about the error. <br><br>  The very first middleware we write the following: <br><pre> <code class="javascript hljs">app.use(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (ctx, next) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> next(); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { <span class="hljs-comment"><span class="hljs-comment">// will only respond with JSON ctx.status = err.statusCode || err.status || 500; ctx.body = { message: err.message }; } })</span></span></code> </pre><br><br>  Everything, you can try to throw an exception using 'throw new Error ("My error") in any middleware or provoke an error in another way, it will "pop up" to our handler along the chain and the application will respond correctly. <br><br>  I think that this knowledge should be enough for us to create a small REST service.  We will certainly deal with this in the second part of the article, if, of course, it is interesting to someone other than me. <br><br><h2>  useful links </h2><br><ul><li>  <a href="https://github.com/ApelSYN/kojs2-presentation-examples">Examples from the article on gitHub.</a>  <a href="https://github.com/ApelSYN/kojs2-presentation-examples">(don't forget about ‚Äúnpm install‚Äù after cloning)</a> </li><li>  <a href="">Koa 2 on github [eng]</a> </li><li>  <a href="https://github.com/koajs/koa/tree/v2.x/docs">API documentation for Koa v.2 [eng]</a> </li><li>  <a href="https://tc39.github.io/ecmascript-asyncawait/">Draft specification Async Funtions of the future standard ES2017 [eng]</a> </li></ul></div><p>Source: <a href="https://habr.com/ru/post/306816/">https://habr.com/ru/post/306816/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306806/index.html">"Working with a microscope": The data storage revolution</a></li>
<li><a href="../306808/index.html">Remote control server daemon do it yourself</a></li>
<li><a href="../306810/index.html">De-anonymize Windows users and get Microsoft and VPN account credentials</a></li>
<li><a href="../306812/index.html">How not to keep secrets where we have to, or why we need Hashicorp Vault</a></li>
<li><a href="../306814/index.html">Who cares about product bugs if it is successfully sold</a></li>
<li><a href="../306820/index.html">Part 1. Platform DSS Universal Algorithms</a></li>
<li><a href="../306822/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ221 (July 24 - 31, 2016)</a></li>
<li><a href="../306824/index.html">DNA, new technologies and the human genome: Bioinformatics at ITMO University</a></li>
<li><a href="../306828/index.html">PHP Digest number 89 - interesting news, materials and tools (July 17 - 31, 2016)</a></li>
<li><a href="../306832/index.html">5 most promising JavaScript frameworks in 2016</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>