<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CUDA: block synchronization</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="When using parallel computing, it is very likely that a situation may arise when the algorithm contains two such sequential steps: i ) each jth stream...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CUDA: block synchronization</h1><div class="post__text post__text-html js-mediator-article">  When using parallel computing, it is very likely that a situation may arise when the algorithm contains two such sequential steps: <b>i</b> ) each <i>jth</i> stream stores some intermediate calculation result in the <i>jth</i> memory cell, and then <b>ii</b> ) this stream should use the results of one or more "neighboring" threads.  Obviously, it is necessary to organize in the program code a kind of time barrier, which <em>each thread</em> overcomes after <em>all</em> retain their intermediate results in the corresponding memory cells (step ( <b>i</b> )).  Otherwise, some thread may go to stage ( <b>ii</b> ), while some other threads have not yet completed stage ( <b>i</b> ).  Sadly, the creators of CUDA decided that such a <em>special</em> built-in synchronization mechanism for any number of threads on a single GPU is not needed.  So how can you deal with this scourge?  Although Google, judging by the prompts, is familiar with this issue, but it was not possible to find a ready-made satisfactory recipe for its task, but there are some pitfalls on the way to achieving the desired result for a beginner (which I am). <br><br><a name="habracut"></a><br><br><h1>  A few words about the CUDA architecture </h1><br>  To begin with, let me on the basis of official documentation <a href="https://habr.com/ru/post/151897/">[1,2]</a> and slides <a href="https://habr.com/ru/post/151897/">[3,4]</a> , materials of various third-party sites <a href="https://habr.com/ru/post/151897/">[5-11]</a> remind the general picture that a programmer faces when using CUDA.  At the highest level of abstraction, he receives a parallel computing system with the SIMT ( <em>Single-Instruction, Multiple-Thread</em> ) architecture - one command is executed in parallel by many more or less independent <em>threads</em> .  The combination of all these threads running under the same task (see Figure 1) is called the <em>grid</em> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/storage2/735/68b/d34/73568bd3419c8238ead58f470382a8d1.png" alt="Fig. one."><br><br>  The parallel execution of the grid is ensured, first of all, by the presence on the video card of a greater number of identical <em>scalar processors</em> ( <em>scalar processors</em> ), which, in fact, run the threads (see Fig.3).  Physically (see Fig. 2), scalar processors are part of <em>streaming multiprocessors</em> ( <em>SM</em> ). <br><br><img src="https://habrastorage.org/storage2/bec/92e/073/bec92e073d2aaabcaf9d417cd434d42e.png" alt="Fig. 2"><br><br>  For example, in my Tesla there are 30 SM, each with 8 scalar processors.  However, on these 240 cores, it is possible to run grids from a much larger number of threads <sup><a href="https://habr.com/ru/post/151897/">(1)</a></sup> thanks to the hardware mechanisms for the separation of available resources (both the working time of these cores and available memory).  And some features of the implementation of just these mechanisms and determine the method of synchronization of threads when accessing a common memory for them. <br><br>  One of such important features is the grouping of threads of 32 pieces per <em>warp`s</em> , which turn out to be parts of larger formations - <em>blocks</em> ( <em>blocks</em> ).  All threads of each block (for example, for my Tesla block can contain a maximum of 512 threads <sup>(1)</sup> ) are started strictly on one SM, therefore they have access only to its resources.  However, on one SM more than one block can be launched (see Figure 3), and resources will be divided equally between them. <br><br><img src="https://habrastorage.org/storage2/239/881/331/2398813311150f19b073ea6d0bd4d8df.png" alt="Fig. 3"><br><br>  In each SM there is a control unit that distributes the CPU time resource.  This is done in such a way that at each instant of time all the cores of one SM execute strictly one warp.  And upon its completion, the next warp assigned to this SM is chosen in a clever, optimal way.  Thus, it turns out that the streams of one warp are synchronized due to the hardware features of CUDA and are executed in an even closer to SIMD ( <em>Single Instruction, Multiple Data</em> ) method.  But streams of even one block from different warps can turn out to be noticeably out of sync. <br><br>  Another, no less important feature is the organization of memory in CUDA and the access of streams to its various parts.  <em>Global memory</em> has the highest degree of general accessibility for streams, which is physically implemented in the form of integrated circuits sealed on a graphics card - the very same video memory, which is now calculated in gigabytes.  The location outside the processor makes this type of memory the slowest compared to others provided for computing on a video card.  Shared ‚Äúshared access‚Äù has a <em>shared memory</em> (shared memory): located in each SM block (see Fig. 2), usually 16KB <sup><a href="https://habr.com/ru/post/151897/">(1)</a></sup> in size, is available only to threads running on the cores of this SM (see Fig. 1, Fig.3).  Since more than one block can be allocated to parallel execution on one SM, the entire amount of shared memory available in SM is divided equally between these blocks.  It is necessary to mention that the shared memory is physically located somewhere very close to the SM cores, therefore it has a high access speed, comparable to the speed of the <em>register</em> ( <em>registers</em> ) - the main type of memory.  Registers can serve as operands of elementary machine instructions, and are the fastest memory.  All cash registers of one SM are equally divided between all threads running on this SM.  The group of registers allocated for the use of any thread is available to him and only to him.  As an illustration, the power of CUDA (or, on the contrary, the scale of a disaster): in the same Tesla, each SM leases 16,384 32-bit general purpose registers <sup><a href="https://habr.com/ru/post/151897/">(1)</a></sup> . <br><br>  From all the above, we can conclude that the interaction between the streams of one block should be attempted through their common fast shared memory, and between the streams of two different blocks - only using global memory.  This is where the problem indicated in the introduction arises: monitoring the relevance of data in the public domain to different streams for reading and writing memory.  In other words - the problem of synchronization of threads.  As already noted, within one block, the flows of each warp are synchronized with each other.  There are several barrier-type commands to synchronize block streams regardless of their belonging to warpas: <br><ul><li>  <b>__syncthreads ()</b> is the surest way.  This function will cause each thread to wait until (a) all other <em>threads of this block</em> reach this point and (b) all operations on access to shared and global memory completed by the <em>threads of this block</em> are completed and become visible to the <em>threads of this block</em> .  You do not need to place this command inside the conditional <b>if statement</b> , but you should ensure that the unconditional call to this function is performed by all threads of the block. </li><li>  <b>__threadfence_block ()</b> will keep waiting for the <em>thread</em> that <em>caused it</em> until all committed access operations to the shared and global memory are completed and are visible to the <em>threads of this block</em> . </li><li>  <b>__threadfence ()</b> will make the <em>thread</em> that <em>caused it</em> wait until all committed access operations to shared memory become visible to the <em>threads of this block</em> , and global memory operations to <em>all threads on the ‚Äúdevice‚Äù</em> .  The term "device" means a graphic adapter. </li><li>  <b>__threadfence_system ()</b> is similar to <b>__threadfence ()</b> , but turns on synchronization with threads on the CPU ("host"), using a very convenient page-locked memory.  Read more in <a href="https://habr.com/ru/post/151897/">[1,2]</a> and some other sources listed in the list below. </li></ul><br>  The first team sets a single barrier for all streams of one block, the other three - for each stream its own independent barrier.  To synchronize the flow of the entire grid, you will need to come up with something else.  Before considering this ‚Äúmore,‚Äù we specify the task so that we can give an example of a meaningful C code. <br><br><h1>  Task details </h1><br>  So, let's take a closer look at the following example.  Let there be two areas in the adapter's global memory: under the arrays <b>X</b> [] and <b>P</b> [] with 128 elements each.  Let the array <b>X</b> [] is written from the host (the central processor from the computer‚Äôs RAM).  Create a grid of two blocks with 64 streams in each - that is, a total of 128 streams (see Figure 4). <br><br><img src="https://habrastorage.org/storage2/699/f24/a6f/699f24a6ff8607c2b026c0ea33c1f790.png" alt="Fig. four."><br><br>  Now step ( <b>i</b> ) can be performed: each stream with number <i>j</i> will add together all the elements of the array <b>X</b> [], recording the result in <b>P</b> [j].  Next step ( <b>ii</b> ) must be performed: each <i>j</i> -th stream will begin to sum all the elements of the array <b>P</b> [], writing them into the corresponding <b>X</b> [j].  Of course, using CUDA for parallel execution of 128 times the same is meaningless, but in real life each flow will have its own set of weighting factors with which summation takes place, and the <b>X</b> transformation -&gt; <b>P</b> and back, <b>P</b> -&gt; <b>X</b> - occurs multiple times.  In our example, we choose the coefficients equal to unity - for clarity and simplicity, which does not break the generality. <br><br>  Let's move from theory to experiment.  The algorithm is very transparent, and a person who has never dealt with multithreading can immediately suggest the following CUDA core code: <br><pre><code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kernel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *X, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *P)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> N = <span class="hljs-number"><span class="hljs-number">128</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       . const int index = threadIdx.x + blockIdx.x*blockDim.x; //  . float a; //   .   . /*  (i): */ a = X[0]; for(int j = 1; j &lt; N; ++j) // ,   a += X[j]; P[index] = a / N; // ,     . /*   (i). */ /*  (ii): */ a = P[0]; for(int j = 1; j &lt; N; ++j) // ,   a += P[j]; X[index] = a / N; // ,     . /*   (ii). */ }</span></span></code> </pre> <br>  Repeated execution of this kernel will show that the <b>P</b> [] array will be the same from time to time, and, behold, <b>X</b> [] may sometimes differ.  Moreover, if there is a difference, it will not be in one element of <b>X</b> [j], but in a group of consecutive 32 elements!  In this case, the index of the first element in the erroneous block will also be a multiple of 32 - this is just a manifestation of synchronization in those same warpes and some dissynchronization of the streams of different warps.  If the error occurred in some thread, then it will be in all the rest of his warp.  If to apply the synchronization mechanism proposed by CUDA developers <br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">global__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Kernel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *X, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *P)</span></span></span><span class="hljs-function"> </span></span>{ ... <span class="hljs-comment"><span class="hljs-comment">/*   (i). */</span></span> __syncthreads(); <span class="hljs-comment"><span class="hljs-comment">/*  (ii): */</span></span> ... }</code> </pre><br>  then we will ensure that each flow of the block will produce the same result.  And if somewhere it will be wrong - then the whole block.  Thus, it remains to somehow synchronize different blocks. <br><br><h1>  Solution methods </h1><br>  Unfortunately, I know only two methods: <br><ol><li>  The CUDA core terminates if and only if all threads terminate.  Thus, one core can be broken into two and called from the main program sequentially; </li><li>  Come up with a system of flags in the global memory. </li></ol><br><br>  I did not like the first option very much, due to the fact that in my task such kernels should be called up often (thousands of times), and there is reason to fear the presence of additional delays on the very start of the kernel.  At least, because at the beginning of each core, you need to prepare some variables, process the arguments of the kernel function ... It is more logical and faster to do this once in the ‚Äúbig‚Äù core, and then not to interfere with the CPU, leaving the graphics adapter to stew from the data in its own of memory. <br><br>  As for the second option with the system of flags, a similar mechanism is mentioned in the section ‚ÄúB.5 Memory Fence Functions‚Äù in <a href="https://habr.com/ru/post/151897/">[1]</a> .  However, there is considered a slightly different algorithm for the kernel.  To implement block synchronization, we introduce two functions: the first will prepare the values ‚Äã‚Äãof the counter of the spent blocks, and the second will play the role of a barrier ‚Äî delay each flow until all the blocks are completed.  For example, these functions and the kernel using them may look like this: <br><pre> <code class="cpp hljs">__device__ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-comment"><span class="hljs-comment">// -  .    //4     . /*    -: */ __device__ void InitSyncWholeDevice(const int index) { if (index == 0) //    grid` ( 0)   count = 0; //    . if (threadIdx.x == 0) //    block`  ,  - while (count != 0); //   . //     block` ,      : __syncthreads(); // , - .    device -  . } /*     device: */ __device__ void SyncWholeDevice() { //      : unsigned int oldc; //   ,     gmem  smem,    grid`: __threadfence(); //    block`    (  ) //-: if (threadIdx.x == 0) { //  oldc   count  "+1": oldc = atomicInc(&amp;count, gridDim.x-1); //   ,    ""    gmem: __threadfence(); //     (   count      ), //     count,    ,    //  gmem.    ,    "",      //,      ""   . if (oldc != (gridDim.x-1)) while (count != 0); } //      ,      : __syncthreads(); } __global__ void Kernel_Synced(float *X, float *P) { InitSyncWholeDevice(threadIdx.x + blockIdx.x*blockDim.x); ... /*   (i). */ SyncWholeDevice(); /*  (ii): */ ... }</span></span></code> </pre><br>  That seems to be all.  The flag was started, the functions were written.  It remains to compare the performance of the first and second methods.  But, unfortunately, the <b>SyncWholeDevice</b> () function will increment the counter, but the barrier delay will not provide.  It would seem, why?  There is a <b>while loop</b> .  Here we just swim up to the underwater stone mentioned in the abstract, which becomes visible: if you look at the ptx file generated by the <i>nvcc</i> compiler <a href="https://habr.com/ru/post/151897/">[12-14]</a> , it turns out that he kindly throws out an empty cycle from his point of view.  Making the compiler not optimize the loop in this way can be done in at least two ways. <br><br>  By all means working will be an explicit insert in ptx-assembler.  For example, such a function, the call that should replace the <b>while loop</b> : <br><pre> <code class="cpp hljs">__<span class="hljs-function"><span class="hljs-function">device__ </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_while_count_not_eq</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> val)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">asm</span></span>(<span class="hljs-string"><span class="hljs-string">"{\n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"$my_while_label: \n\t"</span></span> <span class="hljs-string"><span class="hljs-string">" .reg .u32 r_count; \n\t"</span></span> <span class="hljs-string"><span class="hljs-string">" .reg .pred p; \n\t"</span></span> <span class="hljs-string"><span class="hljs-string">" ld.global.u32 r_count, [count]; \n\t"</span></span> <span class="hljs-string"><span class="hljs-string">" setp.ne.u32 p, r_count, %0; \n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"@p bra $my_while_label; \n\t"</span></span> <span class="hljs-string"><span class="hljs-string">"}\n\t"</span></span> : : <span class="hljs-string"><span class="hljs-string">"r"</span></span>(val)); }</code> </pre><br>  Another, syntactically more elegant way is to use the <i>volatile</i> specifier when declaring a counter flag.  This will inform the compiler that a variable in global (or shared) memory can be changed by any thread at any time.  Therefore, when accessing this variable, it is necessary to disable any optimization.  The code will need to change only two lines: <br><pre> <code class="cpp hljs">__device__ <span class="hljs-keyword"><span class="hljs-keyword">volatile</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count; <span class="hljs-comment"><span class="hljs-comment">// -  .    //4     . ... //  oldc   count  "+1": oldc = atomicInc((unsigned int*)&amp;count, gridDim.x-1); ...</span></span></code> </pre><br><br><h1>  Evaluation of solution methods </h1><br>  We now give a rough theoretical estimate of the performance of the two methods of block synchronization.  Rumor has it that a kernel call takes ~ 10¬µs - this is the cost of synchronization by repeatedly calling the cores.  In the case of synchronization by introducing a barrier from a cycle, ~ 10 threads (depending on how many blocks) increment and read in a cycle one cell in the global memory, where each I / O operation takes about 500 cycles.  Let each block conduct such operations. Then about 10 * 500 * 3 = 1.5 * 10 ^ 4 cycles will be spent on the synchronization operation.  With a core frequency of 1.5 GHz, we get 1.0 * 10 ^ (- 5) sec = 10 Œºs.  That is, the order of magnitudes is the same. <br><br>  But, of course, it is curious to look at the results of at least some tests.  In Figure 5, a post reader can see a comparison of the time spent on executing 100 consecutive conversions <b>X</b> -&gt; <b>P</b> -&gt; <b>X</b> , repeated 10 times for each configuration of the grid  ªa.  A repetition of 10 times is done to average the time required for 100 transformations <sup><a href="https://habr.com/ru/post/151897/">(2)</a></sup> . <br><br><img src="http://habrastorage.org/storage2/aab/4b1/255/aab4b12557130d4cbf8e39631f39134b.png" alt="Fig. five."><br><br>  In the horizontal plane, the number of blocks launched and the number of threads in each of them are plotted.  On the vertical axis, the time <em>gain</em> in percent for the method <em>‚Äúsingle kernel call, barriers inside‚Äù</em> (we will call single kernel launch) relative to the multi kernel launch method is delayed.  It is clearly seen that the gain on the grid configurations under consideration, although very small, is almost always positive.  However, the more blocks become, the MKL method lags behind in performance.  For 32 blocks, he even slightly beats the method of SQL.  This is due to the fact that the more blocks, the more more threads (having <em>threadIdx.x == 0</em> ) read the <em>count</em> variable from the slow global memory.  And there is no mechanism ‚Äúonce read, gave meaning to all threads‚Äù.  If we consider the change in relative performance depending on the number of threads in the block, with a constant number of blocks themselves, then we can also notice some regularity.  But here, the effects unknown to the author related to the synchronization of threads in the block, the management of warpes in SM work here.  Therefore, we refrain from further comments. <br><br>  It is interesting to look at performance with an unchanged number of working threads (1024), but their different division into blocks.  Figure 6 shows just the graphs of the renormalized time spent on 100 * 10 of the above transformations for the two methods (MKL and SKL). <br><br><img src="http://habrastorage.org/storage2/742/327/47c/74232747c2a534337ceb23ee8985b3b5.png" alt="Fig. 6"><br><br>  In fact, this is a diagonal ‚Äúcut‚Äù in Fig.5.  It is clearly seen that at first, with larger blocks, the performance of both synchronization methods grows the same.  About this effect, the developers of CUDA warn in the official documentation <a href="https://habr.com/ru/post/151897/">[2]</a> , but the author, again, unfortunately, does not have the details of the mechanisms of this phenomenon.  The reduction of the gap and even the loss of the method of SKL with the smallest division into blocks is connected, as already mentioned, with an increase in the number of readings of the variable <em>count</em> . <br><br>  It should be noted that the tests were carried out with the implementation of the method SKL through the replacement of the <b>while loop with a</b> ptx-assembler insert.  Using the <i>volatile</i> specifier sometimes (depending on the grid configuration) slows down the process and sometimes accelerates.  The magnitude of the deceleration reaches 0.20%, and acceleration - 0.15%.  This behavior, apparently, is determined by the peculiarities of the <b>while loop</b> implementation by the compiler and on the ptx-assembly insertion by humans, and allows us to consider both implementations of the SKL method to be equally productive. <br><br><h1>  Conclusion </h1><br>  In this article I have tried to highlight at the basic level the problem of synchronization of streams, methods of synchronizing blocks;  after some tests, give a general description of the CUDA system with pictures.  In addition, in the source code of the test program <sup><a href="https://habr.com/ru/post/151897/">(2), the</a></sup> reader will be able to find another example of reliable buffer utilization in shared memory (threads are synchronized via <b>__ syncthreads ()</b> ).  I hope someone will be useful.  For me personally, this information gathered in one place would save several days of experimenting with the code, and ‚Äúgoogling‚Äù, since I have a stupid penchant for not very attentive reading the documentation. <br><br><a name="footnotes"></a><br>  <sup>(1)</sup> <i>To obtain technical information about the adapters available in the computer, it is proposed to use the C-function CUDA API <b>cudaGetDeviceProperties</b> (...) <a href="https://habr.com/ru/post/151897/">[1-2, 15]</a> .</i> <br>  <sup>(2)</sup> <i><a href="http://pastebin.com/bUqiNn7u">The source code of the</a> test program, pasted on pastebin.com.</i> <br><br><a name="references"></a><br><h1>  List of information sources </h1><br>  [1] <a href="http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/CUDA_C_Programming_Guide.pdf">CUDA C Programming Guide</a> <br>  [2] <a href="http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/CUDA_C_Best_Practices_Guide.pdf">CUDA C Best Practices Guide</a> <br>  [3] Advanced CUDA Webinar: <a href="http://developer.download.nvidia.com/CUDA/training/NVIDIA_GPU_Computing_Webinars_CUDA_Memory_Optimization.pdf">Memory Optimizations</a> <br>  [4] S. Tariq, <a href="http://developer.download.nvidia.com/CUDA/training/GTC_Express_Sarah_Tariq_June2011.pdf">An Introduction to GPU Computing and CUDA Architecture</a> <br>  [5] Vanderbilt University, ACCRE, <a href="http://www.accre.vanderbilt.edu/gpu/">GPU Computing with CUDA</a> <br>  [6] OmGTU, Radio Engineering Faculty, Department "Integrated Information Security", <a href="http://higcis.xirad.ru/cis/index.php/professional-development/35-professional-development-program-cuda.html">retraining program "Programming for graphics processors"</a> <br>  [7] Summer Supercomputer Academy, <a href="http://academy.hpc-russia.ru/node/9">High-Performance Computing on Clusters Using NVIDIA Graphics Accelerators</a> <br>  [8] iXBT.com: <a href="http://www.ixbt.com/video3/cuda-1.shtml">NVIDIA CUDA - Non-graphical Computing on GPUs</a> <br>  [9] cgm.computergraphics.ru: <a href="http://cgm.computergraphics.ru/issues/issue16/cuda">Introduction to CUDA Technology</a> <br>  [10] THG.ru: <a href="http://www.thg.ru/graphic/nvidia_cuda/print.html">nVidia CUDA: calculations on a video card or death of a CPU?</a> <br>  [11] steps3d.narod.ru: <a href="http://steps3d.narod.ru/tutorials/cuda-tutorial.html">CUDA Basics, CUDA</a> <a href="http://steps3d.narod.ru/tutorials/cuda-2-tutorial.html">Programming (Part 2)</a> <br>  [12] <a href="http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/nvcc.pdf">The CUDA Compiler Driver (NVCC)</a> <br>  [13] <a href="http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/Using_Inline_PTX_Assembly_In_CUDA.pdf">Using Inline PTX Assembly in CUDA</a> <br>  [14] <a href="http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/ptx_isa_3.0.pdf">PTX: Parallel Thread Execution ISA Version 3.0</a> <br>  [15] CUDA API Reference Manual ( <a href="http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/CUDA_Toolkit_Reference_Manual.pdf">PDF</a> , <a href="http://developer.download.nvidia.com/compute/cuda/4_2/rel/toolkit/docs/online/modules.html">HTML online</a> ) </div><p>Source: <a href="https://habr.com/ru/post/151897/">https://habr.com/ru/post/151897/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../151890/index.html">Neurobiology and artificial intelligence: part two - intelligence and presentation of information in the brain</a></li>
<li><a href="../151891/index.html">Dangerous 0-day vulnerability in iOS 5.1.1 and 6</a></li>
<li><a href="../151892/index.html">Disturbing bells: when your disk is better to carry to repair</a></li>
<li><a href="../151894/index.html">Apple stole "clock" in iOS 6 from the Swiss railways</a></li>
<li><a href="../151895/index.html">We consider brackets on Oracle SQL</a></li>
<li><a href="../151898/index.html">A look at the Modern (Metro) Windows interface (Phone / RT) 8</a></li>
<li><a href="../151899/index.html">Lumia can be taken from Nokia to try - for two weeks</a></li>
<li><a href="../151902/index.html">Red pill does not exist</a></li>
<li><a href="../151903/index.html">Worldwide IP Surveillance Industry Leader Supported Ivideon</a></li>
<li><a href="../151904/index.html">OpenDKIM + Postfix = just</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>