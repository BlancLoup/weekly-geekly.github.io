<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Create Azure DevOps extension</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We have a project with a customized CI / CD process. When the developer finishes the task and injects his changes into develop \ qa, the build automat...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Create Azure DevOps extension</h1><div class="post__text post__text-html js-mediator-article">  We have a project with a customized CI / CD process.  When the developer finishes the task and injects his changes into develop \ qa, the build automatically launches, which puts the new version of the application on the test environment.  In an ideal world, the tester automatically learns about the tasks that were completed, and on what environment they are deployed.  In this case, the workflow becomes continuous, uninterrupted and requires less communication, distracting from concentrated work.  In practice, everything is not so rosy. <br><br>  So one morning, the team leader asked me: ‚ÄúCan you make such a thing for TFS so that the tags that are attached to the build hang the specified tag after passing through this build?‚Äù <br><br>  I decided to implement my build \ release task for the task.  Moreover, the sources of all build tasks are on <a href="https://github.com/microsoft/azure-pipelines-tasks">github</a> , and all information is available. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Our task marks the color of the task, which is completed, but not tested.  Thanks to this, the developer will immediately notice if he forgot to put the desired tag, and QA immediately sees what needs to be checked.  This visualizes the status of tasks and speeds up work on the project. <br><br>  In this article I will talk about the implementation of the necessary logic, packaging in extension.  So if you are interested in how to create such a plugin, welcome to cat. <br><br>  For the most impatient: <a href="https://github.com/asergeev95/TagLinkedWorkItemsTask">github</a> and a ready extension on the <a href="https://marketplace.visualstudio.com/items%3FitemName%3Dtrue-sergeev.work-items-tagging-task">marketplace</a> . <br><br><img src="https://habrastorage.org/webt/pk/id/hb/pkidhbjiwp_hxtyri2tmrixkgf4.png"><br><a name="habracut"></a><br>  Azure DevOps has the ability to create filters that allow you to color the masks on the board in different colors. <br><br><img src="https://habrastorage.org/webt/eh/nu/lj/ehnuljwjrqsqh862boczyproajc.png"><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ai/z8/pe/aiz8pewcypvkamnobuhpgiavhpo.png"></div><br><br>  We are interested in tasks that: <br><br><ul><li>  completed </li><li>  poured into the test environment </li><li>  not yet verified QA </li></ul><br>  Tags are most suitable for points b and c, but manually setting them is disgusting, and everyone forgets to do it.  So we‚Äôll write an extension, which after the deployment will automatically affix them. <br><br>  Thus, we need the custom build \ release step to reduce the human factor (the developer forgot to put a tag) and to help QA (you can immediately see what needs to be checked). <br><br><h4>  Prerequisites </h4><br>  To develop the extension, we need: <br><br><ol><li>  favorite IDE </li><li>  installed TypeScript + node.js + npm (now I have installed versions 3.5.1 \ 12.4 \ 6.9.0) </li><li>  tfx-cli - library for packaging extension'a (npm i -g tfx-cli). </li></ol><br>  Note the presence of the -g flag <br><br>  Microsoft has some good <a href="https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node%3Fview%3Dazure-devops">documentation</a> in which they are just at the top and tell how to create some kind of extension.  In addition, in the same way there is a dock on creating a build \ release task. <br><br>  In my opinion, there are drawbacks in both articles from the point of view of detailing or explaining certain points, so I will rely on them, focusing on those points that in reality seemed to me not quite obvious. <br><br>  Generally speaking, you can write build \ release step in a fairly large number of languages.  I will give an example on TypeScript. <br><br><h4>  Why TypeScript? </h4><br>  The very first version of build step'a was written in PowerShell'e, only our team and a couple of people knew about it.  Almost immediately, we were faced with the fact that if you try to add task to the build that runs on the docker build agent, then there will be no PowerShell and the task will simply not work.  In addition, from time to time, various kinds of errors took off from people, which were attributed to PowerShell kooky.  Hence the conclusion - the solution should be cross-platform. <br><br><h4>  Project structure </h4><br><pre><code class="plaintext hljs">|--- README.md |--- images |---extension-icon.png |--- TaskFolder (     build\release step'a) |--- vss-extension.json ( )</code> </pre> <br>  Next, we need to install the library for the implementation of build step'a <br><br><ol><li>  cd TaskFolder </li><li>  npm init </li><li>  npm install azure-pipelines-task-lib --save &amp;&amp; npm install @ types / node --save-dev &amp;&amp; npm install @ types / q --save-dev </li><li>  tsc --init </li></ol><br><h4>  Development extension </h4><br>  First of all, inside the TaskFolder we need to create the task.json file - this is the manifest file for the build step itself.  It contains service information (version, creator, description), an environment for launching and configuration of all inputs, which we will see in the future on the form. <br><br>  I propose to study its structure in more detail in the <a href="https://docs.microsoft.com/en-us/azure/devops/extend/develop/add-build-task%3Fview%3Dazure-devops">documentation</a> . <br>  In our case, there will be 2 input'a on the form - the tag that we will add to work items, and the choice of the pipeline type (build or release). <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"inputs"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"pipelineType"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"pickList"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"Specify type of pipeline"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"helpMarkDown"</span></span>: <span class="hljs-string"><span class="hljs-string">"Specify whether task is used for build or release"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"defaultValue"</span></span>: <span class="hljs-string"><span class="hljs-string">"Build"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"options"</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">"Build"</span></span>: <span class="hljs-string"><span class="hljs-string">"Build"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"Release"</span></span>: <span class="hljs-string"><span class="hljs-string">"Release"</span></span> } }, { <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"tagToAdd"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"label"</span></span>: <span class="hljs-string"><span class="hljs-string">"Tag to add to work items"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"defaultValue"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-attr"><span class="hljs-attr">"required"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"helpMarkDown"</span></span>: <span class="hljs-string"><span class="hljs-string">"Specify a tag that will be added to work items"</span></span> } ]</code> </pre><br>  By name, in the code below we will refer to the value of each of the inputs. <br>  Create an index.ts in TaskFolder and write the first piece of code <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> tl <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'azure-pipelines-task-lib/task'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pipelineType = tl.getInput(<span class="hljs-string"><span class="hljs-string">'pipelineType'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { tl.setResult(tl.TaskResult.Failed, err.message); } } run();</code> </pre><br>  It is worth noting that TFS has a very rich documentation on the existing REST API, but for now, all we need to do is get work items attached to the build. <br><br>  Install a library for easy query execution <br><br><pre> <code class="plaintext hljs">npm install request --save &amp;&amp; npm install request-promise-native --save</code> </pre><br>  Add it to index.ts <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> request <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"request-promise-native"</span></span>;</code> </pre><br>  We implement the function, which from the current build will get the attached work items <br><br><h4>  A little bit about authorization </h4><br>  To access the REST API, we need to get accessToken <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> accessToken = tl.getEndpointAuthorization(<span class="hljs-string"><span class="hljs-string">'SystemVssConnection'</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>).parameters.AccessToken;</code> </pre><br>  Next, set the header authorization to ‚ÄúBearer $ {accessToken}‚Äù <br><br>  We return to receiving work items bound to the build. <br><br>  Url Azure DevOps server and the name of TeamProject can be obtained from environment variables as follows <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> collectionUrl = process.env[<span class="hljs-string"><span class="hljs-string">"SYSTEM_TEAMFOUNDATIONCOLLECTIONURI"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> teamProject = process.env[<span class="hljs-string"><span class="hljs-string">"SYSTEM_TEAMPROJECT"</span></span>];</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWorkItemsFromBuild</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> buildId = process.env[<span class="hljs-string"><span class="hljs-string">"BUILD_BUILDID"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uri = <span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${collectionUrl}</span></span></span><span class="hljs-string">/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${teamProject}</span></span></span><span class="hljs-string">/_apis/build/builds/</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${buildId}</span></span></span><span class="hljs-string">/workitems`</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = createGetRequestOptions(uri); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.get(options); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result.value; }</code> </pre><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createGetRequestOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uri: string</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">uri</span></span>: uri, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">"authorization"</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${accessToken}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">"content-type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">json</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> options; }</code> </pre><br>  As a response to a GET request by URL <br><br><pre> <code class="plaintext hljs">${collectionUrl}/${teamProject}/_apis/build/builds/${buildId}/workitems</code> </pre> <br>  we get this kind of JSON <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"count"</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-attr"><span class="hljs-attr">"value"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"55402"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/workItems/55402"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"59777"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/workItems/59777"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"60199"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/workItems/60199"</span></span> } ] }</code> </pre><br>  For each url, through the same REST API, you can get data on the work item. <br><br>  At the moment, our run method is as follows. <br><br>  The method for getting work items from the release is almost identical to that already described. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pipelineType = tl.getInput(<span class="hljs-string"><span class="hljs-string">'pipelineType'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workItemsData = pipelineType === <span class="hljs-string"><span class="hljs-string">"Build"</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getWorkItemsFromBuild() : <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getWorkItemsFromRelease(); <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { tl.setResult(tl.TaskResult.Failed, err.message); }</code> </pre><br>  The next step is to get the current set of tags for each of the received work items and add the one we specified. <br><br>  Let's add the run method: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> pipelineType = tl.getInput(<span class="hljs-string"><span class="hljs-string">'pipelineType'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workItemsData = pipelineType === <span class="hljs-string"><span class="hljs-string">"Build"</span></span> ? <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getWorkItemsFromBuild() : <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> getWorkItemsFromRelease(); workItemsData.forEach(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> (workItem: any) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> addTagToWorkItem(workItem); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (err) { tl.setResult(tl.TaskResult.Failed, err.message); } }</code> </pre> <br>  Let's consider adding a tag to work items. <br><br>  First, we need to get the tag that we indicated on the form. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> tagFromInput = tl.getInput(<span class="hljs-string"><span class="hljs-string">'tagToAdd'</span></span>);</code> </pre><br>  Because  2 steps back we received urls to the API of each work item, then with their help we can easily request a list of current tags: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> uri = workItem.url + <span class="hljs-string"><span class="hljs-string">"?fields=System.Tags&amp;api-version=2.0"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getOptions = createGetRequestOptions(uri) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.get(getOptions);</code> </pre><br>  In response, we get this JSON: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">55402</span></span>, <span class="hljs-attr"><span class="hljs-attr">"rev"</span></span>: <span class="hljs-number"><span class="hljs-number">85</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"System.Tags"</span></span>: <span class="hljs-string"><span class="hljs-string">"added-to-prod-package; test-tag"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"_links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"self"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"href"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/workItems/55402"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"workItemUpdates"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"href"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/workItems/55402/updates"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"workItemRevisions"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"href"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/workItems/55402/revisions"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"workItemHistory"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"href"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/workItems/55402/history"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"html"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"href"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://..../web/wi.aspx?pcguid=e3c978d9-6ea1-406f-987d-5b03e24973a1&amp;id=55402"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"workItemType"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"href"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../602fd27d-4e0d-4aec-82a0-dcf55c8eef73/_apis/wit/workItemTypes"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"href"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/fields"</span></span> } }, <span class="hljs-attr"><span class="hljs-attr">"url"</span></span>: <span class="hljs-string"><span class="hljs-string">"https://.../_apis/wit/workItems/55402"</span></span> }</code> </pre><br>  We take all the old tags and add a new one to them: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> currentTags = result.fields[<span class="hljs-string"><span class="hljs-string">'System.Tags'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> newTags = <span class="hljs-string"><span class="hljs-string">''</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (currentTags !== <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>) { newTags = currentTags + <span class="hljs-string"><span class="hljs-string">";"</span></span> + tagFromInput; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { newTags = tagFromInput; }</code> </pre> <br>  We send a patch request to work item api: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> patchOptions = getPatchRequestOptions(uri, newTags); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> request.patch(patchOptions) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPatchRequestOptions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">uri: string, newTags: string</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">any</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> options = { <span class="hljs-attr"><span class="hljs-attr">uri</span></span>: uri, <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">"authorization"</span></span>: <span class="hljs-string"><span class="hljs-string">`Bearer </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${accessToken}</span></span></span><span class="hljs-string">`</span></span>, <span class="hljs-string"><span class="hljs-string">"content-type"</span></span>: <span class="hljs-string"><span class="hljs-string">"application/json-patch+json"</span></span> }, <span class="hljs-attr"><span class="hljs-attr">body</span></span>: [{ <span class="hljs-string"><span class="hljs-string">"op"</span></span>: <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"/fields/System.Tags"</span></span>, <span class="hljs-string"><span class="hljs-string">"value"</span></span>: newTags }], <span class="hljs-attr"><span class="hljs-attr">json</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> options }</code> </pre><br><h4>  Assembly and packaging extension'a </h4><br>  For the beauty of everything that happens, I propose to add in tsconfig.json to compilerOptions <pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"outDir"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist"</span></span></code> </pre>  .  Now, if we execute the <code>tsc</code> command inside the TaskFolder, we get the dist folder, inside which will be index.js, which will go to the final package. <br><br>  Because  our index.js is located in the dist folder and then we will copy it to the final package as well, we need to fix task.json a bit: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"execution"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"Node"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: <span class="hljs-string"><span class="hljs-string">"dist/index.js"</span></span> } }</code> </pre> <br>  In vss-extension.json in the files section, you must explicitly declare what will be copied to the final package. <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"files"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"TaskFolder/dist"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"packagePath"</span></span>: <span class="hljs-string"><span class="hljs-string">"TaskFolder/dist"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"TaskFolder/node_modules"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"packagePath"</span></span>: <span class="hljs-string"><span class="hljs-string">"TaskFolder/node_modules"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"TaskFolder/icon.png"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"packagePath"</span></span>: <span class="hljs-string"><span class="hljs-string">"TaskFolder/icon.png"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"path"</span></span>: <span class="hljs-string"><span class="hljs-string">"TaskFolder/task.json"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"packagePath"</span></span>: <span class="hljs-string"><span class="hljs-string">"TaskFolder/task.json"</span></span> } ]</code> </pre><br>  Last step - we need to pack our extension. <br><br>  To do this, run the command: <br><br><pre> <code class="plaintext hljs"> tfx extension create --manifest-globs ./vss-extension.json</code> </pre> <br>  After execution, we get a * .vsix file, which will be further installed in TFS. <br><br>  PS * .vsix file is essentially an ordinary archive, you can easily open it through 7-zip, for example, and see that everything you need is really inside. <br><br><h4>  Add some beauty </h4><br>  If you want to have an image when you select your build step while adding it to the pipeline, then this file should be placed next to task.json and named icon.png.  You do not need to make any changes to task.json itself. <br><br>  You can add a section to vss-extension.json: <br><br><pre> <code class="json hljs"><span class="hljs-string"><span class="hljs-string">"icons"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"default"</span></span>: <span class="hljs-string"><span class="hljs-string">"images/logo.png"</span></span> }</code> </pre> <br>  This image will be displayed in the gallery of local extensions. <br><br><h4>  Install extension </h4><br><ol><li>  Go to <a href="https://tfs_server_url/_gallery/manage">tfs_server_url / _gallery / manage</a> </li><li>  Click Upload extension </li><li>  We indicate the path or drag'n'drop'om throw over the previously received * .vsix file </li><li>  After verification passes, in the context menu of the extension, select view extension, on the opened page, select the collection in which you want to install it </li><li>  After this extension, you can start using it. </li></ol><br><h4>  Using build step'a </h4><br><ol><li>  Open the pipeline you need </li><li>  Go to the add build step'a </li><li>  We are looking for extension <br><br><img src="https://habrastorage.org/webt/rx/c0/zm/rxc0zmf88g5xv535rdwop4xfkkc.png"><br></li><li>  We indicate all the necessary settings <br><br><img src="https://habrastorage.org/webt/hu/iv/cs/huivcsdfsc357aqcx7eiwrtbjiw.png"></li><li>  Enjoy life :) </li></ol><br><h4>  Conclusion </h4><br>  In this article, I showed how to make a plug-in for Azure DevOps, which automatically puts the right tag to the tasks for the release.  Colleagues built it into the pipeline, which runs on both windows and linux build agents. <br><br>  Thanks to this plugin, it has become easier for us to work with tasks and build continuous work on the project.  Developers are no longer distracted by extraneous things, and QA quickly learns about new tasks for testing. <br><br>  Once again, I recall the download <a href="https://marketplace.visualstudio.com/items%3FitemName%3Dtrue-sergeev.work-items-tagging-task">link</a> : <a href="https://marketplace.visualstudio.com/items%3FitemName%3Dtrue-sergeev.work-items-tagging-task">link</a> <br><br>  We look forward to feedback and suggestions for revision :) <br><br><h5>  PS </h5><br>  There is also an idea to add the ability to remove the specified tags into the plugin.  If the tester found a bug and had to deploy the task again, it would be possible to get rid of the ‚ÄúVerified‚Äú tags). </div><p>Source: <a href="https://habr.com/ru/post/461389/">https://habr.com/ru/post/461389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../461379/index.html">Museum DataArt. US Robotics Modems</a></li>
<li><a href="../46138/index.html">Using Latex in Open Office</a></li>
<li><a href="../461381/index.html">Anonymity is an illusion. According to data from anonymized datasets, you can identify real people</a></li>
<li><a href="../461385/index.html">Wine and rats: the use of resveratrol to restore muscle under Martian gravity</a></li>
<li><a href="../461387/index.html">From classic and modernism to fantasy and steampunk - what system administrators read</a></li>
<li><a href="../46139/index.html">DebugKit for CakePHP</a></li>
<li><a href="../461393/index.html">Last Friday of July - System Administrator Day</a></li>
<li><a href="../461395/index.html">Fractal of element names</a></li>
<li><a href="../461399/index.html">An unexpected order to initialize inherited classes in JavaScript</a></li>
<li><a href="../4614/index.html">Shares of "Rambler" will go up</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>