<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>10 myths about LINQ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Myth # 1 
 All LINQ queries must begin with the 'var' keyword. In essence, the main purpose of the keyword 'var' is to start a LINQ query! 
 The var k...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>10 myths about LINQ</h1><div class="post__text post__text-html js-mediator-article"><h4>  Myth # 1 </h4><br><h4>  All LINQ queries must begin with the 'var' keyword.  In essence, the main purpose of the keyword 'var' is to start a LINQ query! </h4><br>  The <b>var</b> keyword and LINQ are distinct concepts.  The <b>var</b> keyword allows the compiler to infer the type of a local variable based on the initial assignment <b><i>(implicit typing)</i></b> .  For example, the following code: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> s = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>;</code> </pre> <br>  exact equivalent for: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span> s = <span class="hljs-string"><span class="hljs-string">"Hello"</span></span>;</code> </pre><br>  because the compiler outputs the type of the variable <b>s</b> as <b>string</b> . <br><a name="habracut"></a>  Similarly, the following query: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] people = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-string"><span class="hljs-string">"Tom"</span></span>, <span class="hljs-string"><span class="hljs-string">"Dick"</span></span>, <span class="hljs-string"><span class="hljs-string">"Harry"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filteredPeople = people.Where (p =&gt; p.Length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  exact equivalent for: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] people = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-string"><span class="hljs-string">"Tom"</span></span>, <span class="hljs-string"><span class="hljs-string">"Dick"</span></span>, <span class="hljs-string"><span class="hljs-string">"Harry"</span></span> }; IEnumerable&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt; filteredPeople = people.Where (p =&gt; p.Length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  You can see that all we achieved using the <b>var</b> keyword is to create an abbreviation for <b>IEnumerable &lt;string&gt;</b> .  Many people like this record because it is shorter;  others believe that implicit typing can make code less understandable. <br><br>  There are situations in which LINQ queries <i>require the</i> <b>var</b> keyword.  This happens when projected into <a href="http://www.albahari.com/nutshell/whatsnewcs30.aspx">an anonymous type</a> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] people = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-string"><span class="hljs-string">"Tom"</span></span>, <span class="hljs-string"><span class="hljs-string">"Dick"</span></span>, <span class="hljs-string"><span class="hljs-string">"Harry"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filteredPeople = people.Select (p =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Name = p, p.Length });</code> </pre><br>  The following example shows how to use an anonymous type outside the LINQ context: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> person = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { Name = <span class="hljs-string"><span class="hljs-string">"Foo"</span></span>, Length = <span class="hljs-number"><span class="hljs-number">3</span></span> };</code> </pre><br><h4>  Myth # 2 </h4><br><h4>  All LINQ queries must use query syntax. </h4><br>  There are two ways to write LINQ queries: <b>lambda syntax</b> and <b>query syntax</b> . <br><br>  Example of <b>lambda syntax</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] people = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-string"><span class="hljs-string">"Tom"</span></span>, <span class="hljs-string"><span class="hljs-string">"Dick"</span></span>, <span class="hljs-string"><span class="hljs-string">"Harry"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filteredPeople = people.Where (p =&gt; p.Length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span>);</code> </pre><br>  An example similar to the previous one but using the <b>query syntax</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">string</span></span>[] people = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-string"><span class="hljs-string">"Tom"</span></span>, <span class="hljs-string"><span class="hljs-string">"Dick"</span></span>, <span class="hljs-string"><span class="hljs-string">"Harry"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> filteredPeople = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> people <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> p.Length &gt; <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> p;</code> </pre><br>  Logically, the compiler translates the query syntax into lambda syntax.  This means that everything that can be expressed using query syntax can also be expressed in lambda syntax.  Query syntax can be much simpler with queries involving <i>more than one range variable</i> .  (In this example, we used only one variable of the <b>p</b> range, so that both queries look the same simple). <br><br>  Not all operators are available in query syntax, so these two types of syntax are rather complementary.  To get the best from everyone, you can mix query styles in one expression (see myth # 5). <br><br><h4>  Myth # 3 </h4><br><h4>  To extract all clients from a table, you must use a query like this: <br>  var query = from in db.Customers select c. </h4><br>  Expression <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db.Customers <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c</code> </pre><br>  is too verbose!  You can simply use: <br><br><pre> <code class="cs hljs">db.Customers</code> </pre><br>  Similarly, the following LINQ to XML request: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xe = <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> e <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> myXDocument.Descendants (<span class="hljs-string"><span class="hljs-string">"phone"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> e;</code> </pre><br>  can be simplified to: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> xe = myXDocument.Descendants (<span class="hljs-string"><span class="hljs-string">"phone"</span></span>);</code> </pre><br>  And this request: <br><br><pre> <code class="cs hljs">Customer customer = (<span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db.Customers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.ID == <span class="hljs-number"><span class="hljs-number">123</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> c) .Single();</code> </pre><br>  can be simplified to: <br><br><pre> <code class="cs hljs">Customer customer = db.Customers.Single (c =&gt; c.ID == <span class="hljs-number"><span class="hljs-number">123</span></span>);</code> </pre><br><h4>  Myth # 4 </h4><br><h4>  To reproduce the SQL query in LINQ, you must make the LINQ query as similar to the SQL query as possible. </h4><br>  LINQ and SQL are different languages ‚Äã‚Äãusing different concepts. <br><br>  Perhaps the main barrier to productive use of LINQ is the ‚Äúthink in terms of SQL‚Äù syndrome: mentally present a query in SQL, and then translate it to LINQ.  The result will be a constant struggle with the API! <br><br>  Once you start thinking exclusively in <a href="http://www.linqpad.net/challenge.aspx">LINQ terms</a> , your queries will have very little in common with their SQL counterparts.  In many cases, they will also be significantly easier. <br><br><h4>  Myth # 5 </h4><br><h4>  To effectively join in LINQ, you must use the join keyword. </h4><br>  This is true, but only for querying local collections.  When you create a database query, the join keyword is not at all necessary: ‚Äã‚Äãthe join operation can be replaced by using several froms and subqueries.  Several froms and subqueries are more versatile: you can also implement non-equi-join <i>connections</i> . <br><br>  Moreover, in LINQ to SQL and the Entity Framework, you can query for <i>association properties</i> that reduce the need for join-ah!  For example, the following code shows how to retrieve the names and identifiers of all customers who have not made a single purchase: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db.Customers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> !c.Purchases.Any() <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c.ID, c.Name }</code> </pre><br>  Or extract customers who have not made a purchase in excess of $ 1000: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db.Customers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> !c.Purchases.Any (p =&gt; p.Price &gt; <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c.ID, c.Name }</code> </pre><br>  Notice, we have mixed lambda syntax and query syntax.  For more examples of association properties, connection guidelines, and mixed syntax, see <a href="http://www.linqpad.net/">LINQPad</a> . <br><br><h4>  Myth # 6 </h4><br><h4>  Since the result of an SQL query is a flat data set, LINQ queries must be created to also return a flat data set. </h4><br>  This is a consequence of Myth # 4.  One of the main advantages of LINQ is that you can: <br><ol><li>  Query a <i>structured</i> object through the properties of the association (instead of manually connecting); </li><li>  Project <i>directly</i> into the object hierarchy. </li></ol><br>  In principle, 1 and 2 are independent, but 1 helps 2. For example, if you want to extract customer numbers in WA together with their purchases, you can use the following code: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db.Customers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.State == <span class="hljs-string"><span class="hljs-string">"WA"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c.Name, c.Purchases <span class="hljs-comment"><span class="hljs-comment">// An EntitySet (collection) }</span></span></code> </pre><br>  The hierarchical result of this query is much easier to work with than a flat data set. <br><br>  We can achieve the same result without using the <i>properties of associations</i> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> db.Customers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.State == <span class="hljs-string"><span class="hljs-string">"WA"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> { c.Name, Purchases = db.Purchases.Where (p =&gt; p.CustomerID == c.ID) }</code> </pre><br><br><h4>  Myth # 7 </h4><br><h4>  To implement an external connection in LINQ to SQL, you must always use the DefaultIfEmpty () operator. </h4><br>  This is true if you need a <i>flat</i> data set.  The example in the previous myth is translated to the left outer join in SQL and does not require the <b>DefaultIfEmpty</b> operator. <br><br><h4>  Myth # 8 </h4><br><h4>  LINQ to SQL or Entity Framework queries will be executed as a whole, only if they were built in one step. </h4><br>  LINQ uses the deferred execution model, that is, queries are executed not at the time of <i>creation</i> , but at the time of <i>enumeration</i> .  This means you can construct your queries in as many steps as you want, and they will not get to the server until you start using the result. <br><br>  For example, the following query retrieves the names of all customers who have made two purchases, whose name begins with the letter 'A'.  We built this query in three steps: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> query = db.Customers.Where (c =&gt; c.Name.StartsWith (<span class="hljs-string"><span class="hljs-string">"A"</span></span>)); query = query.Where (c =&gt; c.Purchases.Count() &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = query.Select (c =&gt; c.Name); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span> name <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> result) <span class="hljs-comment"><span class="hljs-comment">//     ! Console.WriteLine (name);</span></span></code> </pre><br><br><h4>  Myth # 9 </h4><br><h4>  A method cannot return a query if it ends with the 'new' operator. </h4><br>  The trick is to project into a regular <b>named type</b> using an object initializer: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IQueryable&lt;NameDetails&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCustomerNamesInState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Customer <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> c.State == state <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NameDetails { FirstName = c.FirstName, LastName = c.LastName }; }</code> </pre><br>  The <b>NameDetails</b> class <b>is</b> defined as follows: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NameDetails</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName, LastName; }</code> </pre><br><h4>  Myth # 10 <br></h4><br><h4>  The best way to use LINQ to SQL is to instantiate a single instance of the DataContext class in a static property and use this shared instance throughout the life of the application. </h4><br>  Such a strategy will lead to stale data, since objects monitored by the DataContext instance are not updated when resubmitted. <br><br>  Using a single instance of the DataContext class will cause you a lot of trouble, since it is not thread safe. <br><br>  The correct strategy is to create a new DataContext instance for each object request, making its life quite short.  The same goes for the Entity Framework. <br><br>  <b>In addition to this article, I also translated LINQ Quiz (test) which I posted <a href="http://timyrguev.blogspot.ru/2013/12/linq-quiz.html">on my blog</a> ( <a href="http://timyrguev.blogspot.ru/2013/12/linq-quiz_28.html">answers</a> ).</b>  <b>I think it will be very useful and interesting to discuss the answers to the questions asked by Joe Albahari!</b> </div><p>Source: <a href="https://habr.com/ru/post/207578/">https://habr.com/ru/post/207578/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../207566/index.html">New educational project Ciklum Dynamics Academy in Minsk</a></li>
<li><a href="../207568/index.html">Online store Wildberries: what happens on the other side of the monitor</a></li>
<li><a href="../207572/index.html">Ruble symbol with CSS</a></li>
<li><a href="../207574/index.html">Sorting machine by color M & M's and Skittles on Arduino Uno</a></li>
<li><a href="../207576/index.html">Looking at popular trends in web design in 2013</a></li>
<li><a href="../207580/index.html">Onda V975 - tablet with a 9.7-inch Retina screen</a></li>
<li><a href="../207582/index.html">Portable Network Javascript</a></li>
<li><a href="../207584/index.html">Fedora / CentOS remote installation in headless mode without media and TFTP</a></li>
<li><a href="../207586/index.html">Intellect, language and WikiPedia - is there a relationship?</a></li>
<li><a href="../207588/index.html">Coworking in the regions - open or let others open?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>