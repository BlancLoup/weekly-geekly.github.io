<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing Node.js projects. Part 1. Anatomy of tests and types of tests</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The author of the material, the first part of which we are publishing today, says that he, as an independent consultant for Node.js, analyzes more tha...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing Node.js projects. Part 1. Anatomy of tests and types of tests</h1><div class="post__text post__text-html js-mediator-article">  The author of the material, the first part of which we are publishing today, says that he, as an independent consultant for Node.js, analyzes more than 10 projects every year.  His clients, which is justified, ask him to pay special attention to testing.  A few months ago, he began to take notes on valuable testing techniques and errors he encountered.  The result was a material containing three dozen recommendations for testing. <br><br> <a href="https://habr.com/company/ruvds/blog/435462/"><img src="https://habrastorage.org/getpro/habr/post_images/f16/1a0/3e2/f161a03e2b08ae35b31f718a083a39a0.jpg" alt="image"></a> <br><br>  In particular, the discussion here will focus on the selection of test types that are appropriate in a particular situation, on their proper design, on the evaluation of their effectiveness, and on exactly where to place them in the CI / CD chains.  Some of the examples given here are illustrated using Jest, some using Mocha.  This material is mainly focused not on tools, but on testing methodologies. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      ‚Üí <a href="https://habr.com/company/ruvds/blog/435464/">Testing Node.js projects.</a>  <a href="https://habr.com/company/ruvds/blog/435464/">Part 2. Evaluation of the effectiveness of tests, continuous integration and analysis of code quality</a> <br><a name="habracut"></a><br><h3>  <font color="#3AC1EF">‚ñç0.</font>  <font color="#3AC1EF">The golden rule: tests should be very simple and straightforward.</font> </h3><br>  Do you know anyone - a friend, family member, hero of the film, who is always charged with a good mood and is always ready to offer a helping hand, without demanding anything in return?  That is how good tests should be designed.  They should be simple, should be useful and cause positive emotions.  This can be achieved by careful selection of test methods, tools and goals.  Such, the use of which justifies the expenditure of time and effort to prepare and conduct tests and at the same time gives good results.  You only need to test what needs to be tested, you need to strive to ensure that the tests are simple and flexible, and sometimes you can even refuse some tests, meaningfully sacrificing the reliability of the project for its simplicity and speed of development. <br><br>  Tests should not be viewed as ordinary application code.  The fact is that a typical team engaged in the development of a project, in any case, does everything possible to support it in working condition, that is, it seeks to ensure that, say, a commercial product works as expected by its users.  As a result, such a team may not be very well aware of the fact that it will have to support another complex ‚Äúproject‚Äù, represented by a set of tests.  If the tests of the main code grow, delaying more and more attention and becoming a cause for constant concern, they either abandon work on them or, trying to maintain at a decent level, give them so much time and effort that it will slow down work on the main project. <br><br>  Therefore, the test code should be as simple as possible, with a minimum number of dependencies and levels of abstraction.  Tests should look like they can be understood at a glance.  Most of the recommendations we consider here stem from this principle. <br><br><h2>  <font color="#3AC1EF">Section 1. Anatomy of tests</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç1.</font>  <font color="#3AC1EF">Design the tests so that the report tells you what is being tested, what scenario, and what is expected from the tests.</font> </h3><br><h4>  Recommendations </h4><br>  The testing report should indicate whether the current version of the application meets the requirements for it.  This should be done in a form that will be clear to those who do not have to be familiar with the application code.  This can be a tester, a DevOps specialist who is involved in the deployment of a project, or the developer himself, who looked at the project some time after writing its code.  This can be achieved in the event that when writing tests to focus on the requirements of the product.  With this approach, the structure of the test can be imagined consisting of three parts: <br><br><ol><li> What exactly is being tested?  For example, the <code>ProductsService.addNewProduct</code> method. </li><li>  What is the scenario and the circumstances under which the test is conducted?  For example, the response of the system is checked in a situation when the price of the goods was not transferred to the method. </li><li>  What are the expected test results?  For example, in such a situation, the system refuses to confirm the addition of a new product to it. </li></ol><br><h4>  Implications of derogation </h4><br>  Suppose the system could not be deployed and at the same time you can only learn from the test report that it did not pass the test, called <code>Add product</code> , which checks for the addition of some product to it.  Will it give information about what exactly went wrong? <br><br><h4>  The right approach </h4><br>  Information about the test consists of three pieces of information. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//1.   describe('Products Service', function() { //2.  describe('Add new product', function() {   // 3. ,       it('When no price is specified, then the product status is pending approval', ()=&gt; {     const newProduct = new ProductService().add(...);     expect(newProduct.status).to.equal('pendingApproval');   }); }); });</span></span></code> </pre> <br><h4>  The right approach </h4><br>  The testing report resembles a document containing a statement of product requirements. <br><br>  Here is how it looks at different levels. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f3/172/8fb/1f31728fba16acd94c79d10fbcbb6c02.jpg"></div><br>  <i><font color="#999999">Product requirements document, test naming, test results</font></i> <br><br><ol><li>  The product requirements document can either be a special document itself, or it can exist as something like an email. </li><li>  When naming tests, describing the purpose of the test, its scenario and expected results, one should adhere to the language that is used in formulating the requirements for the product.  This will help to compare the test code and product requirements. </li><li>  Test results should be clear even to those who are not familiar with the application code or have forgotten it thoroughly.  These are testers, DevOps specialists, developers returning to work with the code a few months after writing it. </li></ol><br><h3>  <font color="#3AC1EF">‚ñç2.</font>  <font color="#3AC1EF">Describe what is expected of the tests in the language of the product: use BDD style statements</font> </h3><br><h4>  Recommendations </h4><br>  Development of tests in a declarative style allows those who work with them, instantly grasp their essence.  If tests are written using the imperative approach, they turn out to be filled with conditional constructions that make their understanding much harder.  Following this principle, expectations should be described in a language close to normal.  In the declarative BDD style, use an <code>expect</code> or <code>should</code> construct, and not some special code of our own design.  If there are no necessary statements in Chai or Jest, and it turns out that the need for such statements often arises, consider <a href="https://jestjs.io/docs/ru/expect">adding new ‚Äúchecks‚Äù to the Jest</a> or writing your own <a href="https://www.chaijs.com/guide/plugins/">plug-ins for Chai</a> . <br><br><h4>  Implications of derogation </h4><br>  If you do not follow the above recommendations, everything will end with the fact that members of the development team will write fewer tests and will skip especially annoying checks using the <code>.skip()</code> method. <br><br><h4>  Wrong approach </h4><br>  The reader of this test will have to look through a rather long imperative code only in order to understand what is being tested in the test. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"When asking for an admin, ensure only ordered admins in results"</span></span> , ()={   <span class="hljs-comment"><span class="hljs-comment">//,       ‚Äî "admin1"  "admin2",   "user1"   const allAdmins = getUsers({adminOnly:true});   const admin1Found, adming2Found = false;   allAdmins.forEach(aSingleUser =&gt; {       if(aSingleUser === "user1"){           assert.notEqual(aSingleUser, "user1", "A user was found and not admin");       }       if(aSingleUser==="admin1"){           admin1Found = true;       }       if(aSingleUser==="admin2"){           admin2Found = true;       }   });   if(!admin1Found || !admin2Found ){       throw new Error("Not all admins were returned");   } });</span></span></code> </pre> <br><h4>  The right approach </h4><br>  You can understand this test literally at a glance. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"When asking for an admin, ensure only ordered admins in results"</span></span> , ()={   <span class="hljs-comment"><span class="hljs-comment">//,        const allAdmins = getUsers({adminOnly:true});     expect(allAdmins).to.include.ordered.members(["admin1" , "admin2"]) .but.not.include.ordered.members(["user1"]); });</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç3.</font>  <font color="#3AC1EF">Perform lint code tests using special plugins</font> </h3><br><h4>  Recommendations </h4><br>  There is a set of plug-ins for ESLint, designed specifically for analyzing test code and for finding problems in such code.  For example, the <a href="https://www.npmjs.com/package/eslint-plugin-mocha">eslint-plugin-mocha plugin</a> gives warnings if the test is written at the global level (and is not a descendant of <code>describe()</code> ), or if the tests are <a href="https://mochajs.org/">skipped</a> , which can give false hopes that all the tests are passed.  The <a href="https://github.com/jest-community/eslint-plugin-jest">eslint-plugin-jest plugin</a> works in a similar way, for example, warning about tests that have no assertions, that is, those that do not check anything. <br><br><h4>  Implications of derogation </h4><br>  The developer will be happy to see that the code is covered by tests for 90% and at the same time 100% of the tests pass successfully.  However, in this state it will remain only until it turns out that many tests, in fact, do not check anything, and some test scripts are simply skipped.  It remains only to hope that no one will begin to develop in production projects that are "tested" in this way. <br><br><h4>  Wrong approach </h4><br>  The test script is full of errors, which, fortunately, can be identified with the help of a linter. <br><br><pre> <code class="javascript hljs">describe(<span class="hljs-string"><span class="hljs-string">"Too short description"</span></span>, () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> userToken = userService.getDefaultToken() <span class="hljs-comment"><span class="hljs-comment">// *error:no-setup-in-describe, use hooks (sparingly) instead it("Some description", () =&gt; {});//* error: valid-test-description. Must include the word "Should" + at least 5 words }); it.skip("Test name", () =&gt; {// *error:no-skipped-tests, error:error:no-global-tests. Put tests only under describe or suite expect("somevalue"); // error:no-assert }); it("Test name", () =&gt; {*//error:no-identical-title. Assign unique titles to tests });</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç4.</font>  <font color="#3AC1EF">Stick to the black box method - test only public methods.</font> </h3><br><h4>  Recommendations </h4><br>  Testing some internal mechanisms of the code means a significant increase in the burden on developers and does not give almost any benefits.  If a certain API gives the correct results, is it worth spending a few hours testing its internal mechanisms and then still maintaining these tests, which very easily ‚Äúbreak‚Äù, up to date?  When testing public methods, their internal implementation, although implicitly, is also verified.  Such a test will give an error if there is some problem in the system, which is expressed in the output of incorrect data.  This approach is also called "behavioral testing."  On the other hand, while testing the internal mechanisms of some API (that is, using the ‚Äúwhite box‚Äù technique), the developer focuses on small implementation details, rather than on the final result of the code.  Tests that check these subtleties may begin to generate errors, for example, after a small refactoring of the code, even though the system continues to produce correct results.  As a result, this approach significantly increases the load on the programmer associated with supporting the test code. <br><br><h4>  Implications of derogation </h4><br>  Tests that are trying to cover the internal mechanisms of a certain system, behave like a shepherd boy from a <a href="https://en.wikipedia.org/wiki/The_Boy_Who_Cried_Wolf">fable</a> who called the peasants to shouts of ‚ÄúHelp!  A wolf! ‚ÄùWhen there was no wolf nearby.  People came running to help only to find that they were deceived.  And when the wolf really appeared, no one came to the rescue.  Such tests give false positive results, for example, in cases when the names of some internal variables change.  As a result, it is not surprising that the person who conducts these tests soon begins to ignore their ‚Äúscreams‚Äù, which, ultimately, leads to the fact that once a real serious mistake may turn out to be unnoticed. <br><br><h4>  Wrong approach </h4><br>  This test checks the internal mechanisms of the class for no particular reason for such checks. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProductService</span></span></span></span>{ <span class="hljs-comment"><span class="hljs-comment">//      //     ,      calculateVAT(priceWithoutVAT){   return {finalPrice: priceWithoutVAT * 1.2};   //           } //  getPrice(productId){   const desiredProduct= DB.getProduct(productId);   finalPrice = this.calculateVATAdd(desiredProduct.price).finalPrice; } } it("White-box test: When the internal methods get 0 vat, it return 0 response", async () =&gt; {   //       VAT,      .  ,   ,        expect(new ProductService().calculateVATAdd(0).finalPrice).to.equal(0); });</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç5.</font>  <font color="#3AC1EF">Choose suitable backup objects: avoid mocks, preferring stubs and spies</font> </h3><br><h4>  Recommendations </h4><br>  The use of duplicate objects (test doubles) for testing is a necessary evil, as they are associated with the internal mechanisms of the application.  Without some of them just really impossible to do.  <a href="https://martinfowler.com/articles/mocksArentStubs.html">Here is</a> useful material on this topic.  However, different approaches to the use of such objects can not be called equivalent.  So, some of them - stubs (stub) and spies (spy), are aimed at testing the requirements for the product, but, as an inevitable side effect, they are forced to slightly affect the internal mechanisms of this product.  Mocks, on the other hand, are aimed at testing the internal mechanisms of the project.  Therefore, their use leads to a huge unnecessary burden on programmers, which we talked about above, offering to adhere to the black box technique when writing tests. <br><br>  Before using backup objects, ask yourself one simple question: ‚ÄúDo I use them to check the functionality that is described, or could it be described in the technical requirements for the project?‚Äù.  If the answer to this question is negative - it may mean that you are going to test the product using the ‚Äúwhite box‚Äù approach, about the shortcomings of which we have already spoken. <br><br>  For example, if you want to find out if your application is working correctly in a situation where a payment service is not available, you can stop this service and make the application get something indicating that there is no response.  This will check the system's response to a similar situation, find out whether it behaves correctly.  In the course of such a test, a check of the behavior, or the response, or the result of the operation of the application under certain conditions is carried out.  In this situation, you can use a spy to check whether, when a drop in the payment service was detected, a certain email was sent.  This, again, will be a test of the system‚Äôs behavior in a certain situation, which is probably fixed in the technical requirements for it, for example, in the following form: ‚ÄúSend an email to the administrator if the payment fails‚Äù.  On the other hand, if you use the mock object to represent the payment service and check the work when accessing it with the transfer of what it expects, then it will be about testing internal mechanisms that are not directly related to the functionality of the application, and quite perhaps they can change frequently. <br><br><h4>  Implications of derogation </h4><br>  With any refactoring code, you have to look for all the mocks, refactoring and their code.  As a result, support for tests will turn into a heavy burden, making them the enemies of the developer, and not his friends. <br><br><h4>  Wrong approach </h4><br>  This example shows a mock object that focuses on testing internal application mechanisms. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"When a valid product is about to be deleted, ensure data access DAL was called once, with the right product and right config"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-comment"><span class="hljs-comment">//,        const dataAccessMock = sinon.mock(DAL);   // ,           dataAccessMock.expects("deleteProduct").once().withArgs(DBConfig, theProductWeJustAdded, true, false);   new ProductService().deletePrice(theProductWeJustAdded);   mock.verify(); });</span></span></code> </pre> <br><h4>  The right approach </h4><br>  Spies aim to test systems for compliance with their requirements, but, as a side effect, inevitably affect the internal mechanisms of the systems. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"When a valid product is about to be deleted, ensure an email is sent"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-comment"><span class="hljs-comment">//,        const spy = sinon.spy(Emailer.prototype, "sendEmail");   new ProductService().deletePrice(theProductWeJustAdded);   //  .       ? ,               (  ) });</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç6.</font>  <font color="#3AC1EF">During testing, use realistic input, not limited to something like "foo"</font> </h3><br><h4>  Recommendations </h4><br>  Often, production errors occur under a very specific and even surprising set of circumstances.  This means that the closer to reality the input data used during testing, the higher the probability of early detection of errors.  Use, to generate data resembling real, specialized libraries, such as <a href="https://www.npmjs.com/package/faker">Faker</a> .  For example, such libraries generate random, but realistic phone numbers, user names, bank card numbers, company names, and even texts in the spirit of "lorem ipsum."  Moreover, consider using data from the production environment in tests.  If you want to raise such tests to an even higher level, refer to our next recommendation on testing, based on property testing. <br><br><h4>  Implications of derogation </h4><br>  When testing a project during its development, all tests can be passed only if they are carried out using unrealistic data, like foo lines.  But in production, the system will fail in a situation where a hacker will give her something like <code>@3e2ddsf . ##' 1 fdsfds . fds432 AAAA</code> <code>@3e2ddsf . ##' 1 fdsfds . fds432 AAAA</code>  <code>@3e2ddsf . ##' 1 fdsfds . fds432 AAAA</code> . <br><br><h4>  Wrong approach </h4><br>  The system successfully passes these tests only because they use unrealistic data. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addProduct = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name, price</span></span></span><span class="hljs-function">) =&gt;</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> productNameRegexNoSpace = <span class="hljs-regexp"><span class="hljs-regexp">/^\S*$/</span></span>;<span class="hljs-comment"><span class="hljs-comment">//  if(!productNameRegexNoSpace.test(name))   return false;// , -   ,  .     //  -    return true; }; it("Wrong: When adding new product with valid properties, get successful confirmation", async () =&gt; {   // "Foo",    ,    ,    false   const addProductResult = addProduct("Foo", 5);   expect(addProductResult).to.be.true;   // :     - ,     //         });</span></span></code> </pre> <br><h4>  The right approach </h4><br>  It uses randomized data, similar to the real ones. <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"Better: When adding new valid product, get successful confirmation"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> addProductResult = addProduct(faker.commerce.productName(), faker.random.number());   <span class="hljs-comment"><span class="hljs-comment">//   : {'Sleek Cotton Computer',  85481}   expect(addProductResult).to.be.true;   //  ,         ,    .   //     ,    ! });</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç7.</font>  <font color="#3AC1EF">Test systems using a variety of input data combinations using property-based testing.</font> </h3><br><h4>  Recommendations </h4><br>  Typically, tests use small sets of input data.  Even if they resemble real data (we talked about this in the previous section), such tests cover only a very limited number of possible combinations of the inputs of the entity under study.  For example, it might look like this: <code>(method('', true, 1), method("string" , false" , 0))</code> . The problem is that in the production API, which is called with five parameters, can get There are thousands of different variants of their combinations, one of which can lead to a crash (it is appropriate to recall <a href="https://ru.wikipedia.org/wiki/%25D0%25A4%25D0%25B0%25D0%25B7%25D0%25B7%25D0%25B8%25D0%25BD%25D0%25B3">fuzzing</a> .) What if you could write a single test that automatically checks a certain method for 1000 combinations of its inputs and finds out which ones it is does the method respond incorrectly? Testing based on checking properties is exactly what  us in such a situation is useful. Namely, in the course of this testing module checks, calling it with all possible combinations of input data, which increases the probability of finding a few bugs. Suppose we have a method <code>addNewProduct(id, name, isDiscount)</code> , and Library , performing the test, calls it with a variety of combinations of numeric, string and logical type parameters, for example - <code>(1, "iPhone", false)</code> , <code>(2, "Galaxy", true)</code> .  Testing based on property verification can be done using a common environment for executing tests (Mocha, Jest, and so on) and using specialized libraries like <a href="https://github.com/jsverify/jsverify">js-verify</a> or <a href="https://github.com/leebyron/testcheck-js">testcheck</a> (this library has very good documentation). <br><br><h4>  Implications of derogation </h4><br>  The developer, unknowingly, selects such test data that covers only those parts of the code that work correctly.  Unfortunately, this reduces the effectiveness of testing as a means to detect errors. <br><br><h4>  The right approach </h4><br>  Testing a variety of input options using the mocha-testcheck library. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'mocha-testcheck'</span></span>).install(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {expect} = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'chai'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> faker = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'faker'</span></span>); describe(<span class="hljs-string"><span class="hljs-string">'Product service'</span></span>, () =&gt; { describe(<span class="hljs-string"><span class="hljs-string">'Adding new'</span></span>, () =&gt; {   <span class="hljs-comment"><span class="hljs-comment">//  100         check.it('Add new product with random yet valid properties, always successful',     gen.int, gen.string, (id, name) =&gt; {       expect(addNewProduct(id, name).status).to.equal('approved');     }); }) });</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç8.</font>  <font color="#3AC1EF">Aim to ensure that the test code is self-sufficient, minimizing external tools and abstractions</font> </h3><br><h4>  Recommendations </h4><br>  It is probably already obvious that I am a supporter of extremely simple tests.  The fact is that otherwise the development team of a certain project, in fact, has to deal with another project.  In order to understand its code, they have to spend valuable time, which they don‚Äôt have much.  <a href="https://mtlynch.io/good-developers-bad-tests/">It is</a> very well written about this phenomenon: ‚ÄúA quality production code is a well thought out code, and a quality test code is a code that is completely understandable ... When you write a test, think about who will see the error message displayed by him.  This person would not like, in order to understand the causes of the error, to read the code of the entire test suite or the inheritance tree code of the utilities used for testing. ‚Äù <br><br>  In order for the reader to understand the test without leaving its code, minimize the use of utilities, hooks, or any external mechanisms when performing a test.  If in order to do this, it is necessary to resort too often to copying and pasting operations, you can stop at one external auxiliary mechanism, the use of which does not violate the comprehensibility of the test.  But, if the number of such mechanisms will grow, the test code will lose clarity. <br><br><h4>  Implications of derogation </h4><br>  ,      4  , 2      ,         ?  !         ,           ,        . <br><br><h4>   </h4><br>       .           ? <br><br><pre> <code class="javascript hljs">test(<span class="hljs-string"><span class="hljs-string">"When getting orders report, get the existing orders"</span></span>, () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> queryObject = QueryHelpers.getQueryObject(config.DBInstanceURL);   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> reportConfiguration = ReportHelpers.getReportConfig();<span class="hljs-comment"><span class="hljs-comment">//   ?        userHelpers.prepareQueryPermissions(reportConfiguration);//  ?         const result = queryObject.query(reportConfiguration);   assertThatReportIsValid();//  ,           -    expect(result).to.be.an('array').that.does.include({id:1, productd:2, orderStatus:"approved"});   //      ?        })</span></span></code> </pre> <br><h4>  The right approach </h4><br>   ,        . <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"When getting orders report, get the existing orders"</span></span>, () =&gt; {   <span class="hljs-comment"><span class="hljs-comment">// ,           const orderWeJustAdded = ordersTestHelpers.addRandomNewOrder();   const queryObject = newQueryObject(config.DBInstanceURL, queryOptions.deep, useCache:false);   const result = queryObject.query(config.adminUserToken, reports.orders, pageSize:200);   expect(result).to.be.an('array').that.does.include(orderWeJustAdded); })</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñç9.        :      </font> </h3><br><h4>  Recommendations </h4><br>     ,      ,    , ,           .               .       ,        (    <a href="https://en.wikipedia.org/wiki/Test_fixture"> </a> )    .   ‚Äî  ,     (  ,      ).      ‚Äî    ,     ,   , ,   .    ,    ,                    .       ‚Äî     , ,   ,       ,      (   , , ,        ). <br><br><h4>  Implications of derogation </h4><br> ,    .   .          .       .     ,     ,            ,       . <br><br><h4>   </h4><br>       .      ,    . <br><br><pre> <code class="javascript hljs">before(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//       .   ? - ,  -   json-. await DB.AddSeedDataFromJson('seed.json'); }); it("When updating site name, get successful confirmation", async () =&gt; { // ,  ,  "Portal", ,           const siteToUpdate = await SiteService.getSiteByName("Portal"); const updateNameResult = await SiteService.changeName(siteToUpdate, "newName"); expect(updateNameResult).to.be(true); }); it("When querying by site name, get the right site", async () =&gt; { // ,  ,  "Portal", ,           const siteToCheck = await SiteService.getSiteByName("Portal"); expect(siteToCheck.name).to.be.equal("Portal"); //!      :[ });</span></span></code> </pre> <br><h4>  The right approach </h4><br>      ,   ,         . <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"When updating site name, get successful confirmation"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-comment"><span class="hljs-comment">//           const siteUnderTest = await SiteService.addSite({   name: "siteForUpdateTest" }); const updateNameResult = await SiteService.changeName(siteUnderTest, "newName"); expect(updateNameResult).to.be(true); });</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñç10.     ,   .      expect</font> </h3><br><h4>  Recommendations </h4><br>         ,  ,      <code>try-catch-finally</code>         <code>catch</code> .   ,  ,         ,         . <br><br>            Chai,    <code>expect(method).to.throw</code> .     Jest: <code>expect(method).toThrow()</code> .         ,    .   ,     ,          . <br><br><h4>  Implications of derogation </h4><br>     ,   , ,             . <br><br><h4>   </h4><br>    ,            <code>try-catch</code> . <br><br><pre> <code class="javascript hljs">it(<span class="hljs-string"><span class="hljs-string">"When no product name, it throws error 400"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> errorWeExceptFor = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> addNewProduct({<span class="hljs-attr"><span class="hljs-attr">name</span></span>:<span class="hljs-string"><span class="hljs-string">'nest'</span></span>});} <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (error) { expect(error.code).to.equal(<span class="hljs-string"><span class="hljs-string">'InvalidInput'</span></span>); errorWeExceptFor = error; } expect(errorWeExceptFor).not.to.be.null; <span class="hljs-comment"><span class="hljs-comment">//    ,         //  ,     null,       });</span></span></code> </pre> <br><h4>  The right approach </h4><br>     <code>expect</code>   ,      ,      . <br><br><pre> <code class="javascript hljs">it.only(<span class="hljs-string"><span class="hljs-string">"When no product name, it throws error 400"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">async</span></span>() =&gt; { expect(addNewProduct)).to.eventually.throw(AppError).with.property(<span class="hljs-string"><span class="hljs-string">'code'</span></span>, <span class="hljs-string"><span class="hljs-string">"InvalidInput"</span></span>); });</code> </pre> <br><h3> <font color="#3AC1EF">‚ñç11.   ,    </font> </h3><br><h4>  Recommendations </h4><br>       . ,        (smoke test),      -,    ,      .           -  .  ,        ,       ,      <code>#cold</code> , <code>#api</code> , <code>#sanity</code> .                    . ,  Mocha      <a href="https://mochajs.org/"></a> <code>-g</code> ( <code>--grep</code> ). <br><br><h4>  Implications of derogation </h4><br>   ,   ,       ,   ,         ,  ,       .        . <br><br><h4>  The right approach </h4><br>  <code>#cold-test</code>         ,       .        ,         -,  ,      ‚Äî      . <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ( ,    ),     // ,        //   describe('Order service', function() { describe('Add new order #cold-test #sanity', function() {   it('Scenario - no currency was supplied. Expectation - Use the default currency #sanity', function() {     //-    }); }); });</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñç12.        </font> </h3><br><h4>  Recommendations </h4><br>       ,   Node.js-.    ,  ,    Node.js  . <br><br>      <a href="https://www.sm-cloud.com/book-review-test-driven-development-by-example-a-tldr/">TDD</a> ‚Äî      ,     ,          .     ,       .       ,    ,    <a href="https://blog.cleancoder.com/uncle-bob/2014/12/17/TheCyclesOfTDD.html">Red-Green-Refactor</a> .   ,      - ,       , ,   ,     ,         .  ,            .        ( ‚Äî   ,  ,   ). <br><br><h4>  Implications of derogation </h4><br>    ‚Äî    ,       .      . <br><br><h2> <font color="#3AC1EF"> 2.  </font> </h2><br><h3> <font color="#3AC1EF">‚ñç13.      ,        </font> </h3><br><h4>  Recommendations </h4><br>  ,    ,      10 ,     .     ,   .    ,         .   ,         (,    ),  ,    ,   ,     ?        - ? <br><br> ,    . ,  2019 ,  , TDD,   ‚Äî          ,     . ,        ,    ,     <a href="https://en.wikipedia.org/wiki/All_models_are_wrong"> </a>    . ,   IoT-, ,   ,    -  Kafka  RabbitMQ,      .      - , ,  ,       .     ,   ,      ,     ,       ?     (,   ,     Alexa)    ,   ,        . <br><br>       ,      (    ).    , ,           , ,   ,   ,     . ,  ,  -    API   ‚Äî     Consumer-Driven Contracts    .   ,     , ,  ,    .  ,  ,       ,  ,    ,  .    ,  ,     . <br><br>    ,    TDD       .  ,  TDD     ,      .         ,  ,       ,  . <br><br><h4>  Implications of derogation </h4><br>          ‚Äî       ( ),       . <br><br><h4>  The right approach </h4><br>       .  <a href="https://medium.com/%40copyconstruct/testing-microservices-the-sane-way-9bb31d158c16"></a>   .  <a href="https://www.youtube.com/watch%3Fv%3D-2zP494wdUY%26feature%3Dyoutu.be"></a>  , ,   Node.js,      . <br><br><h3> <font color="#3AC1EF">‚ñç14. ,       </font> </h3><br><h4>  Recommendations </h4><br>        .      ‚Äî  .    ,       ,        .  ,     ,    - ,   ,   -    ?    ,   .      ,          :       TDD,   ‚Äî       . <br><br>      ¬´¬ª.    API,   -      ,    (,        , ,   ,   ,    ). ,  ,    ,      (,      ).  ,    ,   ,    ,   ,  ,   . <br><br><h4>  Implications of derogation </h4><br>    , ,      , ,        20. <br><br><h4>  The right approach </h4><br>   <a href="https://www.npmjs.com/package/supertest">supertest</a> ,    API,    Express,         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/286/bd8/02d/286bd802d29e7f6eb475567c97c9429d.png"></div><br> <i><font color="#999999"> API,   Express</font></i> <br><br><h3> <font color="#3AC1EF">‚ñç15.       ,        API,   Consumer-Driven Contracts</font> </h3><br><h4>  Recommendations </h4><br> ,      ,  ,   ,        .  ,   ,  - ,    ,    ,  -    .  ¬´-22¬ª  :       .   ,     ,       .        ,   <a href="https://docs.pact.io/">Consumer-Driven Contracts   PACT</a> . <br><br>       .       .  PACT        ,     (  ¬´¬ª).           ,   ,    PACT,    ,   ,      .        ,    ,   ,    ,       . <br><br><h4>  Implications of derogation </h4><br>             . <br><br><h4>  The right approach </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c39/0ef/dcd/c390efdcd01b24f5089bf7160fd5c5c6.png"></div><br> <i><font color="#999999"> Consumer-Driven Contracts</font></i> <br><br>     ,  ,   B  ,     .  B         . <br><br><h3> <font color="#3AC1EF">‚ñç16.     </font> </h3><br><h4>  Recommendations </h4><br>       (middleware) - ,        ,  - ,      Express-.        .   ,    ,         .    ,     ,   JS-  <code>{req,res}</code> .      ,      ¬´¬ª (,  <a href="https://www.npmjs.com/package/sinon">Sinon</a> )  ,      <code>{req,res}</code> .  ,    ,    ,   .  <a href="http">node-mock-http</a>   , ,      ,         . ,     ,    HTTP-,   -. <br><br><h4>  Implications of derogation </h4><br>      Express       . <br><br><h4>  The right approach </h4><br>                 Express-. <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ,     const unitUnderTest = require('./middleware') const httpMocks = require('node-mocks-http'); //  Jest,     Mocha    describe()  it() test('A request without authentication header, should return http status 403', () =&gt; { const request = httpMocks.createRequest({   method: 'GET',   url: '/user/42',   headers: {     authentication: ''   } }); const response = httpMocks.createResponse(); unitUnderTest(request, response); expect(response.statusCode).toBe(403); });</span></span></code> </pre> <br><h3> <font color="#3AC1EF">‚ñç17.         </font> </h3><br><h4>  Recommendations </h4><br>         ,        , ,      , ,  ,  .     ,        ,      - .    ,     ,   ,           ( , ,   ),    ,        ( ‚Äî   )      .       ,    : <a href="https://www.sonarqube.org/">SonarQube</a> ( <a href="https://github.com/SonarSource/sonarqube">2600</a>   GitHub)  <a href="https://codeclimate.com/">Code Climate</a> ( <a href="https://github.com/codeclimate/codeclimate">1500</a> ). <br><br><h4>  Implications of derogation </h4><br>  ,     ,   .      .          ,         . <br><br><h4>  The right approach </h4><br>         Code Climate. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/1fe/d5c/cae1fed5caf16576b4001dfe0235820c.png"></div><br> <i><font color="#999999">  Code Climate</font></i> <br><br><h3> <font color="#3AC1EF">‚ñç18.     ,      Node.js</font> </h3><br><h4>  Recommendations </h4><br>        ,  ,     .    ,  ,    ,  -  ,   . ,    -      ,  ,  ,  ,  ?  ,  ,    ?   ,    API    ? <br><br>           Netflix   <a href="https://principlesofchaos.org/%3Flang%3DRUcontent"> -</a> .    ,        ,    ,  ,              . ,      - ‚Äî <a href="https://github.com/Netflix/chaosmonkey">Chaos Monkey</a> .     ,        ,       ,       .      Kubernetes ‚Äî <a href="https://github.com/asobti/kube-monkey">kube-monkey</a> .         ,                Node.js? ,         ,   ,     V8   1.7  .            .          <a href="https://github.com/i0natan/node-chaos-monkey">node-chaos</a> ,     -. <br><br><h4>  Implications of derogation </h4><br>      , ,     ,         . <br><br><h4>  The right approach </h4><br>   npm- <a href="https://www.npmjs.com/package/chaos-monkey">chaos-monkey</a> ,            Node.js. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/162/bdb/d24162bdb8c2c430f9163a7eda8c6c32.png"></div><br> <i><font color="#999999"> chaos-monkey</font></i> <br><br><h2>  <font color="#3AC1EF">Results</font> </h2><br>         ,   Node.js-.  ,         .             . <br><br>  <b>Dear readers!</b>     -    ? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div><p>Source: <a href="https://habr.com/ru/post/435462/">https://habr.com/ru/post/435462/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../435446/index.html">Verkhuffa algorithm for an arbitrary even number system</a></li>
<li><a href="../435448/index.html">About the experience of communicating with the signal generator through QTcpSocket and SCPI</a></li>
<li><a href="../435450/index.html">Happy new year with new MQTT / UDP</a></li>
<li><a href="../435452/index.html">End-to-end testing of microservices with Catcher</a></li>
<li><a href="../435454/index.html">AOP vs Functions</a></li>
<li><a href="../435464/index.html">Testing Node.js projects. Part 2. Evaluation of the effectiveness of tests, continuous integration and analysis of code quality</a></li>
<li><a href="../435466/index.html">React Tutorial, Part 6: Some Course, JSX, and JavaScript Features</a></li>
<li><a href="../435468/index.html">React Tutorial, Part 7: Inline Styles</a></li>
<li><a href="../435470/index.html">React Part 8 Training Course: Continuing Work on a TODO Application, Introduction to Component Properties</a></li>
<li><a href="../435472/index.html">The release of the command interpreter Bash 5.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>