<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>PL / SQL via dblink</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="On metalink, 
 Oracle can't do that ... 

 Did you have to implement non-standard solutions? And in Oracle? I would like to consider the use of techni...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>PL / SQL via dblink</h1><div class="post__text post__text-html js-mediator-article"><blockquote>  On metalink, <br>  Oracle can't do that ... </blockquote><br><br>  Did you have to implement non-standard solutions?  And in Oracle?  I would like to consider the use of techniques that allow you to better understand the principles of the DBMS, and in the aggregate they provide convenience for the developer. <br><a name="habracut"></a><br><br>  It is much more convenient to carry out the development of database applications in a single space, and transfer the results across the system's landscape in the background, automatically registering the changes made. <br><img src="https://habrastorage.org/files/cd6/9cc/533/cd69cc533dba4a69beec626da07e9130.jpg"><br>  <i>Sample update on the development server</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  Prologue </h5><br>  Have you encountered harmful DBA?  Did you work with such?  In fact, both sides (Developer vs. DBA) achieve the same result, system performance, but from different sides.  However, when the system is expanded, decentralized, but preserves the integrity of the implementation, then maintaining the consistent state of the software tool can begin to cause serious inconvenience.  Development, testing, ‚Äúproductive‚Äù servers appear - and all this is wonderful, but all of them need to be updated. <br>  In Oracle, there are tools seemingly similar to the one under consideration: <br>  ‚Ä¢ <a href="http://docs.oracle.com/cd/E11882_01/server.112/e17118/statements_4007.htm">Audit</a> <br>  ‚Ä¢ <a href="http://docs.oracle.com/cd/B28359_01/server.111/b28321/strms_over.htm">Oracle Streams</a> <br>  ‚Ä¢ <a href="http://docs.oracle.com/cd/B28359_01/appdev.111/b28419/d_alert.htm">Alert</a> <br>  But they all perform other functions.  Some provide audit of changes, others synchronize data.  And I would like to act more transparently, for example: <br><br><pre><code class="sql hljs">connect developer@dev <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> UpdateServer(<span class="hljs-string"><span class="hljs-string">'prod'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dual; <span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> v_id <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>:=<span class="hljs-string"><span class="hljs-string">'Y'</span></span>; v_cnt number; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> a; if v_cnt = 1 then <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (v_id); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> CommitUpdate; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; /</code> </pre> <br><br>  Now all my actions are duplicated on the 'prod' server.  And maybe even so: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> UpdateFilials; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; /</code> </pre><br><br>  And, let's say, seven servers created table ‚ÄúA‚Äù.  Great?  Then - let's go. <br><br><h4>  Training </h4><br>  Perform a connection to the database on behalf of a user who has sufficient privileges for subsequent actions: <br><pre> <code class="sql hljs">connect system<span class="hljs-comment"><span class="hljs-comment">/***@orcl Connected. select banner from v$version; BANNER -------------------------------------------------------------------------- Oracle Database 11g Release 11.2.0.1.0 - 64bit Production</span></span></code> </pre><br><br>  It is assumed that the user performing the updates should not have access to the update system itself, however, just like the system itself is not tied to the target scheme, therefore, it can be used universally.  Therefore, create a new user: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> upd <span class="hljs-keyword"><span class="hljs-keyword">identified</span></span> <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> pass; User created.</code> </pre><br><br>  Since the article is not about restricting the rights of new users: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> dba <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> upd; <span class="hljs-keyword"><span class="hljs-keyword">Grant</span></span> succeded. <span class="hljs-keyword"><span class="hljs-keyword">connect</span></span> upd/pass Connected.</code> </pre><br><br>  Having omitted the reasoning about the ongoing research, I will say that the most difficult was obtaining an anonymous PL / SQL block, which was cited in the example above.  Naturally, some actions ultimately spawn others, for example, the same block from the example will perform insert, but in fact it may not be!  After all, it will be executed on another server.  Therefore, we will be interested in the anonymous PL / SQL block, and not the consequences.  A public synonym for V $ SQL or the V_ $ SQL view to which it refers, stores all queries executed on the server.  Let's try to find our goal in it: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">set</span></span> linesize <span class="hljs-number"><span class="hljs-number">90</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> raise_application_error(<span class="hljs-number"><span class="hljs-number">-20000</span></span>, <span class="hljs-string"><span class="hljs-string">'Find me'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sql_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> v$<span class="hljs-keyword"><span class="hljs-keyword">sql</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> sql_text <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'%error(-20000, ''Find%'</span></span>; SQL_ID <span class="hljs-comment"><span class="hljs-comment">------------- 753c9f808k8hh 1 row selected.</span></span></code> </pre><br><br>  Indeed, it is my anonymous block that is where it should be.  Of course, the SQL_ID doing my example will be different, but does it belong to me?  Check: <br><pre> <code class="sql hljs">connect system<span class="hljs-comment"><span class="hljs-comment">/*** begin raise_application_error(-20000, 'Find me'); end; / select sql_id from v$sql where sql_text like '%error(-20000, ''Find%'; SQL_ID ------------- 753c9f808k8hh 1 row selected.</span></span></code> </pre><br><br>  No, it does not belong, the optimizer sees that such an expression has already been executed, and returns the already registered SQL_ID.  Mark our surveys in the fields, and continue to explore: <br><pre> <code class="sql hljs">connect upd/pass Connected.</code> </pre><br><br>  I managed to find the completed unit, but I would like to know who made it, or rather find out that it was I who performed it at a certain point in time.  Another view of V_ $ SESSION can help me with this: <br>  select sql_id, prev_sql_id from v $ session; <br>  Here it is necessary to clarify that the synonym v $ session provides access to VIEW, and access for the user is organized by the command: <br>  grant select on v_ $ session to upd; <br>  The point here is that the type of the representation v_ $ session is FIXED VIEW, therefore it is prohibited to give rights to its synonym.  However, if you issue rights to a synonym, say the tables, the rights themselves are issued on the table, and NOT on the synonym. <br>  So what's up with the request?  Oh yeah, you need to limit the selection to the current session: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sid</span></span>, sql_id, prev_sql_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> v$<span class="hljs-keyword"><span class="hljs-keyword">session</span></span> <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sid</span></span> = userenv(<span class="hljs-string"><span class="hljs-string">'sid'</span></span>); SID SQL_ID PREV_SQL_ID <span class="hljs-comment"><span class="hljs-comment">---------- ------------- ------------- 95 54mqd9bcxw8nh 753c9f808k8hh</span></span></code> </pre><br><br>  How is it you can not?  Neither SQL_ID nor PREV_SQL_ID - do not contain the previously found 753c9f808k8hh identifier?  Naturally!  The SQL_ID contains the identifier of the query just executed, and the PREV_SQL_ID most likely stores the identifier of the query: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> sql_id, prev_sql_id <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> v$<span class="hljs-keyword"><span class="hljs-keyword">session</span></span>;</code> </pre><br>  I hope that the reader consistently fulfilled the requests, as I quoted them and therefore did not immediately find what was expected.  In order to make sure that the result will be as indicated, it is necessary to execute the anonymous block and the request to the presentation.  Anyway, I think that another stage of research has been completed.  Now we have the source code of the anonymous block, and we know that it was executed by us. <br>  Unfortunately, I don‚Äôt like the solution that automates the binding, because after a certain moment, it is necessary to remember all the possible anonymous blocks that are executed by the user, but does the view of the user‚Äôs history session store exist?  Or does it exist?  But I did not find at the moment, I propose the following approach.  Create a table that will store the session ID, which is interested in listening, and the job query that polls this table and saves the session history. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> UPD.UPD$SESSION_TARGETS (<span class="hljs-keyword"><span class="hljs-keyword">SID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>); Table created. <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> UPD.UPD$SESSION_DATA ( KSUSENUM <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>, KSUSEUNM VARCHAR2 (<span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BYTE</span></span>), KSUSEMNM VARCHAR2 (<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BYTE</span></span>), KSUSESQI VARCHAR2 (<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BYTE</span></span>), KSUSEPSI VARCHAR2 (<span class="hljs-number"><span class="hljs-number">13</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BYTE</span></span>) ); Table created.</code> </pre><br><br>  ‚ÄúWhat are the names of the second table fields?‚Äù I would ask.  Although this does not have a valid excuse, but trying to minimize the load created by the job, I got to the presentation of a higher level sys.x_ $ ksuse which contains sufficient information about the target session.  When bookmarking for the future, several useful fields will be saved to the table, in addition to the required ones: KSUSENUM (SID) and KSUSESQI (SQL_ID).  It will be good to take out the body of the job to the external procedure, and not to add it to the package, in order to avoid errors if the package is not valid: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> UPD.UPD$JobTask <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> v_cnt <span class="hljs-built_in"><span class="hljs-built_in">number</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> upd.upd$session_targets; if (v_cnt = 0) then <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(ksusenum) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> v_cnt <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> upd.upd$session_data; if (v_cnt &gt; 0) then <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">immediate</span></span> <span class="hljs-string"><span class="hljs-string">'truncate table upd.upd$session_data'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; continue; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> upd.upd$session_data (KSUSENUM, KSUSEUNM, KSUSEMNM, KSUSESQI, KSUSEPSI) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ksusenum, ksuseunm, ksusemnm, ksusesqi, ksusepsi <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.x_$ksuse <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ksusenum <span class="hljs-keyword"><span class="hljs-keyword">IN</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ust.sid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> upd.upd$session_targets ust) <span class="hljs-keyword"><span class="hljs-keyword">MINUS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ksusenum, ksuseunm, ksusemnm, ksusesqi, ksusepsi <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> upd.upd$session_data; <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> UPD$JobTask; / Procedure created.</code> </pre><br><br>  The idea of ‚Äã‚Äãprocessing, is to write to the history of the session only if and only what is done by the user in update mode.  Now you can create a job, listen to the user session and check the result: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> X <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> SYS.DBMS_JOB.SUBMIT ( job =&gt; X ,what =&gt; <span class="hljs-string"><span class="hljs-string">'begin /*UPD$SESSION_JOB*/ UPD$JobTask; end;'</span></span> ,next_date =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SYSDATE</span></span> ,<span class="hljs-built_in"><span class="hljs-built_in">interval</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'SYSDATE + 1/1444'</span></span> ,no_parse =&gt; <span class="hljs-literal"><span class="hljs-literal">FALSE</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; / PL/SQL procedure successfully completed. <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> upd.upd$session_targets <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (userenv(<span class="hljs-string"><span class="hljs-string">'sid'</span></span>)); 1 row created. <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> raise_application_error(<span class="hljs-number"><span class="hljs-number">-20000</span></span>, <span class="hljs-string"><span class="hljs-string">'Find me'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; / Error at line 3 ORA-20000: Find me ORA-06512: at line 2 <span class="hljs-keyword"><span class="hljs-keyword">truncate</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> upd.upd$session_targets; Table truncated. <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> KSUSEPSI <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> upd.upd$session_data; KSUSEPSI <span class="hljs-comment"><span class="hljs-comment">------------- 753c9f808k8hh 1 row selected. select sql_text from v$sql where sql_id = '753c9f808k8hh'; SQL_TEXT ---------------------------------------------------------------------------- begin raise_application_error(-20000, 'Find me'); end; 1 row selected.</span></span></code> </pre><br>  As can be seen from the result of the query to V $ SQL, an anonymous block got into the log table written there by a job.  For the test, I turned to the KSUSEPSI log column (the previous query) due to the fact that I had to execute commands to clear the session table at the time of listening.  In the future, this will also turn out to be a certain disadvantage, but we will exclude the ‚Äúinterruption‚Äù of listening from the result set performed on the remote server. <br>  Now you need to collect DLL commands that can also be executed during the upgrade.  But there is a contradiction here, why collect DDL - if a job collects them?  Unfortunately, it will not collect them, since the DDL is not a query, and therefore will not be reflected in v $ session.  For these purposes, Oracle provides database-level triggers that you can use.  Executed DDL, write to the new table, and by analogy with the job, create a procedure and trigger performing it: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GLOBAL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TEMPORARY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> upd.UPD$BUF ( ALIAS_OBJ VARCHAR2 (<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>), SQLTEXT <span class="hljs-keyword"><span class="hljs-keyword">CLOB</span></span>, OBJNAME VARCHAR2 (<span class="hljs-number"><span class="hljs-number">30</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BYTE</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRESERVE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ROWS</span></span>; Table created. <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PROCEDURE</span></span> upd.T_PROC_UPD$<span class="hljs-keyword"><span class="hljs-keyword">DDL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AUTHID</span></span> DEFINER <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> osuser varchar2(<span class="hljs-number"><span class="hljs-number">30</span></span>); machine varchar2(64); cnt number; V_SQL_OUT ORA_NAME_LIST_T; V_SQL_STATEMENT CLOB; V_NUM NUMBER; v_sqlerrm varchar2(2000); <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> cnt <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> upd$session_targets ust <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> ust.sid = userenv(<span class="hljs-string"><span class="hljs-string">'sid'</span></span>); if cnt = 0 then return; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; V_NUM := ORA_SQL_TXT(V_SQL_OUT); FOR I IN 1 .. V_NUM LOOP V_SQL_STATEMENT := V_SQL_STATEMENT || V_SQL_OUT(I); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOOP</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> UPD$BUF (ALIAS_OBJ, SQLTEXT, OBJNAME) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, V_SQL_STATEMENT, ora_dict_obj_name); EXCEPTION WHEN OTHERS THEN raise_application_error(-20000, SQLERRM); <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> T_PROC_UPD$<span class="hljs-keyword"><span class="hljs-keyword">DDL</span></span>; / Procedure created. <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRIGGER</span></span> upd.T_UPD$<span class="hljs-keyword"><span class="hljs-keyword">DDL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AFTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DDL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DATABASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> T_PROC_UPD$<span class="hljs-keyword"><span class="hljs-keyword">DDL</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span>; / Trigger created.</code> </pre><br><br>  The additional table, and its type (GLOBAL TEMPORARY to store data until disconnect), is selected from the following considerations: the job collects information about the session, works in a session different from the one that runs the update scripts, hence the requests recorded in it would become inaccessible for the session;  provide Oracle with table cleaning after the update;  The DDL trigger is triggered in the same session in which the DDL is executed, therefore in this case you can write to the buffer table immediately;  storing the table data after the commit is due to the fact that the DDL performs silent commit. <br>  It is important to note that the procedure is declared with the AUTHID DEFINER directive, which allows you to record actions with UPD user rights, which may be greater than that of the caller.  Next, determine the length of the DDL and save the buffers in the CLOB field. <br>  The trigger is executed after (AFTER) DDL, which implies successful execution of the command, before writing to the buffer. <br>  Summing up the results of the research, now there are all possible types of operations to be performed on the updated database and you can proceed to the final stage - the tool for performing updates. <br><br><h4>  Implementation </h4><br>  I don‚Äôt like publications that, after lengthy reasoning and preparation, end up with something like: ‚ÄúAnd now, (if not a fool) it should be clear to you how to finish the remaining stuff.‚Äù  Of course, there are fools here - no, everyone has long understood what needs to be done next.  But I will give my current implementation, despite the fact that it can be considered a beta version.  Now a lot of code, and then an explanation: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SEQUENCE</span></span> UPD.UPD$SEQ_LOG <span class="hljs-keyword"><span class="hljs-keyword">START</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> MAXVALUE <span class="hljs-number"><span class="hljs-number">9999999999999999999999999999</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MINVALUE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOCYCLE</span></span> NOCACHE <span class="hljs-keyword"><span class="hljs-keyword">NOORDER</span></span>; Sequence created. <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SEQUENCE</span></span> UPD.UPD$SEQ_REV <span class="hljs-keyword"><span class="hljs-keyword">START</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> MAXVALUE <span class="hljs-number"><span class="hljs-number">9999999999999999999999999999</span></span> <span class="hljs-keyword"><span class="hljs-keyword">MINVALUE</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOCYCLE</span></span> NOCACHE <span class="hljs-keyword"><span class="hljs-keyword">NOORDER</span></span>; Sequence created. <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> UPD.UPD$<span class="hljs-keyword"><span class="hljs-keyword">LOG</span></span> ( ID_LOG <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>, DAT_LOG <span class="hljs-built_in"><span class="hljs-built_in">DATE</span></span>, FQDN_UNAME_OBJ VARCHAR2 (<span class="hljs-number"><span class="hljs-number">1000</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>), ALIAS_OBJ VARCHAR2 (<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>), SQL_TEXT <span class="hljs-keyword"><span class="hljs-keyword">CLOB</span></span>, ID_REV <span class="hljs-built_in"><span class="hljs-built_in">NUMBER</span></span>, SQLERRM_LOG VARCHAR2 (<span class="hljs-number"><span class="hljs-number">2000</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>) ); Table created. <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> UPD.UPD$SERVERS ( ALIAS_OBJ VARCHAR2 (<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>), DBLINK_OBJ VARCHAR2 (<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>), USERNAME VARCHAR2 (<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>), CALLBACK_DBLINK_OBJ VARCHAR2 (<span class="hljs-number"><span class="hljs-number">500</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>) ); Table created. <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> UPD$ <span class="hljs-keyword"><span class="hljs-keyword">AUTHID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CURRENT_USER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> BeginUpdateChannel(u_alias varchar2); procedure PrepareUpdateChannel; procedure EndUpdateChannel; procedure CancelUpdate; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> UPD$; / Package created. <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PACKAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span> UPD$ <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> pkg_active_alias varchar2(<span class="hljs-number"><span class="hljs-number">500</span></span>); pkg_prepared_alias varchar2(500):=null; pkg_session number:=null; pkg_dblink varchar2(500):=null; pkg_callback_dblink varchar2(500):=null; procedure SetSession(u_sid number, u_remove boolean default false) as <span class="hljs-keyword"><span class="hljs-keyword">pragma</span></span> autonomous_transaction; l_sid_count number; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> u_sid <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> raise_application_error(<span class="hljs-number"><span class="hljs-number">-20550</span></span>, <span class="hljs-string"><span class="hljs-string">'Needless to set'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">count</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">rownum</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> l_sid_count <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> upd.upd$session_targets ust <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ust.sid = u_sid; if l_sid_count = 0 then <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> <span class="hljs-keyword"><span class="hljs-keyword">into</span></span> upd.upd$session_targets (<span class="hljs-keyword"><span class="hljs-keyword">sid</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">values</span></span> (u_sid); <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; pkg_session:=u_sid; elsif u_remove then <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> upd.upd$session_targets ust <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> ust.sid = u_sid; <span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>; pkg_session:=null; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> SetSession; function JobNumber return number as l_jobid number; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> a.job <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> l_jobid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dba_jobs a <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> a.what <span class="hljs-keyword"><span class="hljs-keyword">like</span></span> <span class="hljs-string"><span class="hljs-string">'%/*UPD$SESSION_JOB*/%'</span></span>; return l_jobid; EXCEPTION WHEN NO_DATA_FOUND THEN return 0; WHEN OTHERS THEN raise; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> JobNumber; procedure JobRun as <span class="hljs-comment"><span class="hljs-comment">--</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> run job is it stopped --v_cnt number:=0; v_job number; begin v_job:=JobNumber; if v_job = 0 then raise_application_error(-20560, 'Unable to find updating job'); end if; --select count(rownum) -- into v_cnt -- from dba_jobs_running a where a.job = v_job; --if v_cnt = 0 then -- dbms_job.run(v_job); -- commit; --end if; end JobRun; procedure SetChannel(u_alias varchar2) as begin SELECT dblink_obj, callback_dblink_obj INTO pkg_dblink, pkg_callback_dblink FROM upd.upd$servers a WHERE upper(a.alias_obj) = upper(u_alias) AND upper(username) = upper(USER); exception when no_data_found then raise_application_error(-20501, 'Unable set channel. Alias '||u_alias||' not found'); when others then raise_application_error(-20500, 'Unable set channel for alias '||u_alias||SQLERRM); end SetChannel; procedure CancelUpdate is begin pkg_active_alias:=null; pkg_prepared_alias:=null; pkg_session:=null; pkg_dblink:=null; execute immediate 'truncate table upd.upd$buf'; delete from upd.upd$session_targets ust where ust.sid = userenv('sid'); end CancelUpdate; procedure BeginUpdateChannel(u_alias varchar2) is begin if pkg_active_alias is not null then raise_application_error(-20500, 'Unable begin update channel. Alias '||u_alias||' allready active.'); end if; SetChannel(u_alias); execute immediate 'truncate table upd.upd$buf'; JobRun; SetSession(userenv('sid'), false); pkg_active_alias:=u_alias; pkg_prepared_alias:=null; end BeginUpdateChannel; procedure PrepareUpdateChannel is begin if pkg_prepared_alias is not null then raise_application_error(-20500, 'Already prepared'); end if; if pkg_active_alias is null then raise_application_error(-20500, 'Needless to prepare'); end if; INSERT INTO upd.upd$buf (ALIAS_OBJ, SQLTEXT) SELECT pkg_active_alias, b.sql_fulltext FROM (select distinct ksusenum, ksusesqi from upd.upd$session_data) a, sys.v_$sql b WHERE a.ksusenum = pkg_session AND a.ksusesqi = b.sql_id AND (trim(upper(sql_text)) not like 'INSERT%' and trim(upper(sql_text)) not like 'UPDATE%' and trim(upper(sql_text)) not like 'DELETE%' and trim(upper(sql_text)) not like 'SELECT%' and trim(upper(sql_text)) not like '%UPD$%' and trim(upper(sql_text)) not like '%AW_TRUNC_PROC%' and trim(upper(sql_text)) not like '%XDB.XDB_PITRIG_PKG%' and sql_text not like '%:B%' and sql_text not like '%:1%' ); SetSession(pkg_session, true); pkg_prepared_alias:=pkg_active_alias; pkg_active_alias:=null; end PrepareUpdateChannel; procedure DropObject(object_name varchar2) is l_owner varchar2(30); l_type varchar2(19); l_purge varchar2(6); begin SELECT OWNER, OBJECT_TYPE, CASE when object_type = 'TABLE' then ' purge' else null end INTO l_owner, l_type, l_purge FROM all_objects WHERE upper(object_name) = upper(DropObject.object_name); execute immediate 'drop '||l_type||' '||DropObject.object_name||l_purge; exception when no_data_found then null; when others then raise; end DropObject; procedure ExecRemote(u_sql varchar2) is c number; r number; begin execute immediate 'begin :1:=dbms_sql.open_cursor@'||pkg_dblink||'(); end;' using out c; execute immediate 'begin dbms_sql.parse@'||pkg_dblink||'(:1, :2, dbms_sql.native); end;' using in c, in u_sql; execute immediate 'begin dbms_sql.close_cursor@'||pkg_dblink||'(:1); end;' using in out c; end ExecRemote; procedure EndUpdateChannel is l_alias varchar2(5000); l_dblink varchar2(500); l_sql varchar2(32000); l_osuser varchar2(30); l_machine varchar2(64); l_log_id number:=null; l_rev_id number:=null; l_error_stack varchar2(30000):=null; l_tmp_tab varchar2(500):=DBMS_RANDOM.STRING('', 8); l_tmp_proc varchar2(500); begin if (pkg_active_alias is null) and (pkg_prepared_alias is null) then raise_application_error(-20500, 'Needless to end'); end if; if pkg_prepared_alias is null then raise_application_error(-20500, 'You must execute PrepareUpdateChannel first'); end if; l_tmp_proc:='up_$proc_'||l_tmp_tab; l_tmp_tab:='up_$tab_'||l_tmp_tab; l_alias:=pkg_prepared_alias; pkg_prepared_alias:=null; begin execute immediate 'create table '||l_tmp_tab||' as select ub.* from upd.upd$buf ub'; execute immediate 'grant select on '||l_tmp_tab||' to '||USER; l_sql:='create table '||l_tmp_tab||' as select * from upd.'||l_tmp_tab||'@'||pkg_callback_dblink; ExecRemote(l_sql); DropObject(l_tmp_tab); l_sql:='create or replace procedure '||l_tmp_proc||' is c number; r number; l_objname varchar2(30); l_sqlforerr varchar2(200); l_error_stack varchar2(30000); begin for c_exec in (select * from '||l_tmp_tab||') loop l_objname:=c_exec.objname; l_sqlforerr:=dbms_lob.substr(c_exec.sqltext, 200); c := dbms_sql.open_cursor(); dbms_sql.parse(c, c_exec.sqltext, dbms_sql.native); r := dbms_sql.execute(c); dbms_sql.close_cursor(c); l_objname:=null; end loop; execute immediate ''drop table '||l_tmp_tab||' purge''; exception when others then execute immediate ''drop table '||l_tmp_tab||' purge''; if l_objname is not null then select replace(wm_concat(text), '','', chr(10)) into l_error_stack from user_errors where name = l_objname; end if; raise_application_error(-20000, ''Obj: ''||l_objname||chr(10)||''SQLERRM: ''||SQLERRM||chr(10)||''Show errors: ''||l_error_stack||chr(10)||''Code: ''||l_sqlforerr); end;'; ExecRemote(l_sql); begin execute immediate 'begin '||l_tmp_proc||'@'||pkg_dblink||'; end;'; commit; exception when others then l_error_stack:=SQLERRM; end; l_sql:='drop procedure '||l_tmp_proc; ExecRemote(l_sql); if l_error_stack is not null then raise_application_error(-20590, null); end if; exception when others then l_dblink:=pkg_dblink; CancelUpdate; DropObject(l_tmp_tab); if sqlcode = -20550 then raise; elsif sqlcode = -20590 then raise_application_error(-20555, 'Error when executing remote SQL'||chr(10)|| 'Compilation errors: ['||l_error_stack||']'); else raise; end if; end; SELECT distinct osuser, machine INTO l_osuser, l_machine FROM v$session WHERE sid = USERENV('sid'); l_rev_id:=UPD$SEQ_REV.NEXTVAL; INSERT INTO upd.upd$log (ID_LOG, DAT_LOG, FQDN_UNAME_OBJ, ALIAS_OBJ, SQL_TEXT, ID_REV, SQLERRM_LOG) SELECT upd$seq_log.nextval, sysdate, l_machine||'\'||l_osuser, pkg_prepared_alias, sqltext, l_rev_id, null FROM upd.upd$buf ub; execute immediate 'truncate table upd.upd$buf'; end EndUpdateChannel; procedure ErrorEnumAccess is begin null; end ErrorEnumAccess; END UPD$; / Package body created.</span></span></code> </pre><br><br>  Two more tables were added to the previously created tables, one of which is used to validate successfully completed updates, and the second to set up a connection to a remote Oracle database. <br>  The package is declared with the AUTHID CURRENT_USER directive - which will lead to the execution of the package procedures, with the user rights of the calling package.  Now, about all the package procedures: <br>  <code>procedure SetSession(u_sid number, u_remove boolean default false)</code> - using a stand-alone transaction, writes the current session identifier to the table that initiates the listen. <br>  <code>function JobNumber return number</code> - gets the ID of the listener. <br>  <code>procedure JobRun</code> - checks for the existence of a job. <br>  <code>procedure SetChannel(u_alias varchar2)</code> - receives remote connection settings and writes them to local variables of the package. <br>  <code>procedure CancelUpdate</code> - clears settings and clears temporary tables. <br>  <code>procedure BeginUpdateChannel(u_alias varchar2)</code> - combines preparatory procedure calls and starts listening. <br>  <code>procedure PrepareUpdateChannel</code> - finishes listening and appends session requests collected by a job to the table buffer.  For my own needs, I don‚Äôt try too hard, discarding DML, select and service commands encountered during the test, as well as a call to the PrepareUpdateChannel procedure, which is also recorded in the session log. <br>  <code>procedure DropObject</code> is an auxiliary procedure for cleaning. <br>  <code>procedure ExecRemote</code> - block execution on a remote server.  This procedure implements one of the key moments of the mechanism.  Here the dbms_sql package is called on the remote server. <br>  <code>procedure EndUpdateChannel</code> ‚Äî apply the update.  And about this separately. <br><br>  I will make a reservation that the first version of the implementation was somewhat simpler than the one given here.  The fact is that dynamic sql does not provide the ability to execute blocks longer than varchar2 (32767 characters or bytes, depending on the declaration).  Although it is not quite so.  Locally, dbms_sql allows this, but the LOB field cannot be transferred to a remote server.  Many thanks to Tom Kite (https://asktom.oracle.com/pls/apex/f?p=100:11): ):::::P11_QUESTION_ID:950029833940), who knows how to forward LOB between remote servers.  I was pleasantly surprised by the fact that the first method, which he gives, was implemented through dbms_lob.substr, with which I cut the CLOB field from the UPD $ BUF table in a loop.  The second method he suggests for this task looks like: create a table on the current host, with the rights of the caller updating the user, and create a remote table over the connection with the current database.  Here you can point out a few shortcomings in the above implementation, namely: the assumption of a possible error, if the user calling the update is not equal to logged in by dblink, because he will not have rights to select from the temporary table;  creating and deleting tables dynamically.  Another problem I already encountered when ‚Äúrolling over‚Äù CLOB between servers was the error ‚ÄúORA-02046: distributed transaction already already‚Äù.  Apparently, during testing, a suspended session occurred, or the remote connection identifier remained open.  I couldn‚Äôt simulate this situation again, but in order to avoid repetitions, I need to think about placing a call: dbms_session.close_database_link (pkg_dblink); <br>      ,     ,       ,          (    ,    Error on SQL level 2),         . <br><br>       ,   AUTHID DEFINER       : <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> ChannelUpdate(u_alias varchar2) <span class="hljs-keyword"><span class="hljs-keyword">AUTHID</span></span> DEFINER <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> upd$.BeginUpdateChannel(u_alias); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ChannelUpdate; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> ChannelPrepare <span class="hljs-keyword"><span class="hljs-keyword">AUTHID</span></span> DEFINER <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> upd$.PrepareUpdateChannel; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ChannelPrepare; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> ChannelApply <span class="hljs-keyword"><span class="hljs-keyword">AUTHID</span></span> DEFINER <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> upd$.EndUpdateChannel; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ChannelApply; <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">replace</span></span> <span class="hljs-keyword"><span class="hljs-keyword">procedure</span></span> ChannelCancel <span class="hljs-keyword"><span class="hljs-keyword">AUTHID</span></span> DEFINER <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> upd$.CancelUpdate; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> ChannelCancel; <span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ChannelUpdate <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> developer; <span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ChannelPrepare <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> developer; <span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ChannelApply <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> developer; <span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">execute</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> ChannelCancel <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> developer; <span class="hljs-keyword"><span class="hljs-keyword">grant</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> upd$<span class="hljs-keyword"><span class="hljs-keyword">log</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> developer;</code> </pre></div><p>Source: <a href="https://habr.com/ru/post/239397/">https://habr.com/ru/post/239397/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../239381/index.html">Storage systems: how to choose?</a></li>
<li><a href="../239385/index.html">YouTrack 6.0, distinct and flexible. What can a new tracker?</a></li>
<li><a href="../239387/index.html">Testing embedded systems</a></li>
<li><a href="../239393/index.html">Hewlett-Packard is divided into two companies</a></li>
<li><a href="../239395/index.html">Vulnerability Yandex money or how to recover a payment password</a></li>
<li><a href="../239399/index.html">What technology has learned from Linus Torvalds</a></li>
<li><a href="../239401/index.html">Modifying a USB-UART converter on a CP2102 chip for use as an Arduino programmer</a></li>
<li><a href="../239403/index.html">Testing embedded systems - one aspect, which for some reason say little</a></li>
<li><a href="../239405/index.html">Snowkit announcement</a></li>
<li><a href="../239407/index.html">Based on the ‚Äúthree interviews about static analyzers,‚Äù or the fourth interview</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>