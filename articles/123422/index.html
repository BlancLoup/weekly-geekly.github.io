<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Haskell Quest Tutorial - Hall</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Most likely, this is the last part, published just in time. My vacation is almost over, and now it will be very difficult to write on the article per ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Haskell Quest Tutorial - Hall</h1><div class="post__text post__text-html js-mediator-article">  <i>Most likely, this is the last part, published just in time.</i>  <i>My vacation is almost over, and now it will be very difficult to write on the article per week.</i>  <i>Thanks to everyone who was interested in the Haskell Quest Tutorial!</i> <br><br><blockquote>  Living room <br>  You are in the living room.  There is a doorway to the west, it is a trophy case, and a large oriental rug in the middle of the room. <br>  Above the trophy case hangs an elvish sword of great antiquity. <br>  A battery-powered brass lantern is on the trophy case. </blockquote><br><br>  Content: <br>  <a href="http://habrahabr.ru/blogs/Haskell/120590/">Greeting</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/120759/">Part 1 - The Threshold</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/121189/">Part 2 - Forest</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/122259/">Part 3 - Polyana</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/122788/">Part 4 - View of the canyon</a> <br>  <a href="http://habrahabr.ru/blogs/Haskell/123422/">Part 5 - Hall</a> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Part 5, <br>  in which we derive significant consequences from a small error, and then add objects to the game. <br><br><a name="habracut"></a><br>  First, let's refresh our memory.  Let's run through the run function, which we got in the fourth part.  As you can see, I worked for you, added the Look action.  The run function now looks impressive: <br><br><blockquote>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66"><b>-&gt;</b></font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  Look <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  run curLoc <br>  Go dir <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> <i><font color="#808080">" <font>\ n</font> You walking to"</font></i> <font color="#339933">++</font> <font>show</font> dir <font color="#339933">++</font> <i><font color="#808080">". <font>\ n</font> "</font></i> <font>)</font> <br>  run <font>(</font> walk curLoc dir <font>)</font> <br>  convertResult <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> evalAction convertResult <font>)</font> <br>  <font>putStrLn</font> <i><font color="#808080">‚ÄúEnd of turn.</font></i>  <i><font color="#808080"><font>\ n</font> "</font></i> <br>  run curLoc </blockquote><br><br>  In assignment number 2 to the last part there was a proposal to think about how to avoid two calls "(describeLocation curLoc)".  We, of course, do not solve the gravitational problem for N bodies in order to fight for resources using the example of one small function, but several important consequences follow from this insignificance.  If we had an imperative language, we would simply assign the result to a variable.  In Haskell, data is considered immutable, so the assignment itself is not.  But there are other mechanisms that, as it turns out, not only generalize the assignment, but also, taking into account the immutable state, produce interesting effects.  For example, determinism of execution.  In fact, if a global state does not affect a function, and inside it, the data is obviously immutable, it means that it will return the same arguments to the same arguments.  By calling a function once, we can memorize its parameters and the result obtained ‚Äî and if we need to call it a second time with the same parameters, we simply return the result calculated earlier, because we are sure of it. <br><br>  But let's get down to business.  There are several solutions to our problem.  First, let's try, for example, to associate the result with some variable, in the same way as we connected the string from getLine and the variable x.  This is like an assignment, and the idea here is simple: you can use the variable as much as you like.  From the first call you get approximately the following code: <br><br><blockquote>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  locDescr <font color="#66cc66"><b>&lt;-</b></font> describeLocation curLoc <br>  <font>putStrLn</font> locDescr <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  <font color="#339933">...</font> <font color="#5d478b">- remaining code</font> </blockquote><br><br>  But this code is a trick because it is no longer compiled. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : r <br>  <font>[</font> <font color="red">2</font> <font color="#06c">of</font> <font color="red">2</font> <font>]</font> Compiling Main <font>(</font> H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font> Hs <font color="#339933">,</font> interpreted <font>)</font> <br><br>  H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font>  hs: <font color="red">58</font> : <font color="red">17</font> : <br>  Couldn't match expected <font color="#06c">type</font> ' <font>[</font> a0 <font>]</font> ' with actual <font color="#06c">type</font> ' <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> ' <br>  In the <font>return</font> <font color="#06c">type</font> <font color="#06c">of</font> a call <font color="#06c">of</font> ' <font>putStrLn</font> ' <br>  In a stmt <font color="#06c">of</font> a ' <font color="#06c">do</font> ' expression: <font>putStrLn</font> locDescr <br>  In the expression: <br>  <font color="#339933">...</font> <br><br>  Failed <font color="#339933">,</font> modules loaded: Types <font color="#339933">.</font> </blockquote><br><br>  What is the difference between "x &lt;- getLine" and "locDescr &lt;- describeLocation curLoc"?  It seems to be the same: the getLine function returns a string that is associated with the variable x;  and the function (describeLocation curLoc) also returns a string that is associated with another locDescr variable.  But the interpreter says that some types do not match.  Let's understand the situation - and for this you need to understand what is actually happening in the run function. <br><br>  Returning to the working code, commenting out the erroneous lines. <br><br><blockquote>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font color="#5d478b">- locDescr &lt;- describeLocation curLoc</font> <br>  <font color="#5d478b">- putStrLn locDescr</font> <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  <font color="#339933">...</font> <font color="#5d478b">- remaining code</font> <br><br>  <font color="#339933">*</font> Types <font color="#339933">&gt;</font> : r <br>  <font>[</font> <font color="red">2</font> <font color="#06c">of</font> <font color="red">2</font> <font>]</font> Compiling Main <font>(</font> H: \ Haskell \ QuestTutorial \ Quest \ QuestMain <font color="#339933">.</font> Hs <font color="#339933">,</font> interpreted <font>)</font> <br>  Ok <font color="#339933">,</font> modules loaded: Main <font color="#339933">,</font> Types <font color="#339933">.</font> <br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> </blockquote><br><br>  We intentionally did not write the definition of the run function in order not to go into the subtleties of its type.  But she has the type, and the compiler dutifully outputs it himself.  Check: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t run <br>  run <font color="#66cc66"><b>::</b></font> Location <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> </blockquote><br><br>  And here we are waiting for a surprise.  It is clear that Location is a type of a single parameter, and for a strange type of IO () there is nothing left but to be a type of return value.  Very interesting!  After all, we do not use any IO () anywhere, where did it come from?  If you have already set out to blame Haskell for its dark deeds and self-righteousness, then do not rush: I very much use it.  The fact is that, according to Haskell, any I / O action (Input-Output, I / O) is potential errors and failures, also known as ‚Äúside effects‚Äù.  Consequently, input / output functions (putStrLn, putStr, putChar, getLine, getChar, readFile, writeFile) are dangerous, they can return different results for the same arguments, and in some cases can even throw an error.  Therefore, they have type IO, which, in the opinion of the language, should alarm us.  In addition, all other functions in which the type IO arises inside also become non-deterministic and are required to adopt it.  Our run function chose unsafe actions, which caused IO () to get infected.  From here it follows, by the way, that the entry point to the program - the main function - did not avoid this fate, since run is called in it. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t main <br>  main <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> </blockquote><br><br><blockquote><blockquote>  It is fair to say that in the explanations it was assumed that functions with IO-actions are non-deterministic.  In fact this is not true;  and such functions in a sense can be deterministic and even pure.  This question, generally speaking, is a stumbling block in the debate about the purity of Haskell, and its discussion can be found on the Internet. </blockquote></blockquote><br><br>  How does this relate to our problem?  Let's look again (without compilation) on the wrong code, assigning to it, for order, the definition of the run function. <br><br><blockquote>  run <font color="#66cc66"><b>::</b></font> Location <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  locDescr <font color="#66cc66"><b>&lt;-</b></font> describeLocation curLoc <br>  <font>putStrLn</font> locDescr <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  <font color="#339933">...</font> <font color="#5d478b">- remaining code</font> </blockquote><br><br>  The keyword do, as we know, links the actions in a chain, but not any ones.  The do-notation requires that all actions in a chain return the same type.  Since we are working with I / O, the type of the functions must contain IO. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t <font>putStrLn</font> <br>  <font>putStrLn</font> <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t <font>putStr</font> <br>  <font>putStr</font> <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> </blockquote><br><br>  In addition to the String argument, these two functions have the same type of return value - IO ().  Empty brackets here show that nothing else is returned to the useful function.  In fact, it doesn't matter to us what putStrLn returns there, so long as it prints its argument to the console.  On the contrary, we expect something ‚Äúuseful‚Äù from the getLine function, and this is reflected in its own way in its type: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t <font>getLine</font> <br>  <font>getLine</font> <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> </blockquote><br><br>  getLine receives a string from the user and packs it, as a gift, into an IO type.  And do with a gift what you want.  We, for example, pass it to the convertStringToAction function: <br><br><blockquote>  <font color="#339933">...</font> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  <font color="#339933">...</font> </blockquote><br><br>  But the convertStringToAction function has a different type!  - exclaim you and you will be right.  She is waiting for a String at the input, not an IO String!  What is the focus?  Well, somewhere in these two lines, the gift unfolds, the IO box is thrown away, and the blank line already goes further.  And this is the arrow.  It takes the packed result from the right side and unpacks it into the variable on the left.  Therefore, by the way, this operation is called binding, and not assignment.  And if you think about it, our expression ‚ÄúlocDescr &lt;- describeLocation curLoc‚Äù is erroneous, because in the right side nothing is packed anywhere - read, the result is not put into the IO box. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> : t <font>(</font> describeLocation Home <font>)</font> <br>  <font>(</font> describeLocation Home <font>)</font> <font color="#66cc66"><b>::</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> </blockquote><br><br>  Well, we arrived ... They wanted to be as simple as that, but they got what kind of effect even a few pages.  But I have good news for you: there is a solution!  We ourselves will pack what is right on the IO type, and let the arrow choke.  For this there is a function return.  The following code will work as intended: <br><br><blockquote>  run <font color="#66cc66"><b>::</b></font> Location <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  locDescr <font color="#66cc66"><b>&lt;-</b></font> <font>return</font> <font>(</font> describeLocation curLoc <font>)</font> <br>  <font>putStrLn</font> locDescr <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66"><b>-&gt;</b></font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  Look <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> locDescr <br>  run curLoc <br>  <font color="#339933">...</font> <font color="#5d478b">- remaining code</font> </blockquote><br><br>  Yes, the return function will pack the string into the do (IO) block type, and the arrow will unpack it and bind it to the locDescr variable.  And no longer need to calculate the location description several times.  The logic, of course, is unusual, but you must agree: there is some inner beauty in it.  It's worth the drink! <br><br><blockquote><blockquote> Behind the do-notation and type of IO, there are even more consequences and pitfalls.  If we drop deeper, we will see a universal way of taming not only side effects, but also many other calculations, which can be related to each other by different laws than the actions of IO.  Making calculations using the so-called <i>monads</i> , we end up with a surprisingly simple and convenient logic, and the code becomes concise, understandable and expressive.  It is important that such code is strictly mathematical and very convenient.  It is very suitable for describing specific tasks such as parsing, DSL, mutable states, and more.  Maybe someday we will return to this topic - but not before it really is needed. </blockquote></blockquote><br><br>  Well, we solved the puzzle, which turned out to be unexpectedly capacious.  So why do we need to strain and come up with some other solutions?  Yes, in general, for the same: to learn something else about Haskell. <br><br>  Our next solution will use the where construct.  This is a special construction where you can describe functions that are available only here and now, like nested functions in some other programming languages.  Within the where-block, variables of the parent function are available, and all laws that apply to normal functions apply.  This means that you can create several variants of the same function, use pattern matching, security expressions, and even create nested where constructs. <br><br>  The where-construct does not require any special explanation, just look at the example: <br><br><blockquote>  run <font color="#66cc66"><b>::</b></font> Location <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> locDescr <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66"><b>-&gt;</b></font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  Look <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> locDescr <br>  run curLoc <br>  <font color="#339933">...</font> <font color="#5d478b">- remaining code</font> <br>  <font color="#06c">where</font> <br>  locDescr <font color="#66cc66"><b>=</b></font> describeLocation curLoc </blockquote><br><br>  We made the same indent before the where-construct as the do block.  In essence, we defined where for this block.  It may seem that we assign the result to the variable locDescr, but this is not the case.  There are no variables and assignments;  locDescr is a function that returns a location description.  We call this function from the parent code, and two times;  however, it is most likely calculated only once.  Haskell compilers can save past results for reuse.  When data is no longer needed, it is deleted by the built-in garbage collector.  Remember the frame from the last part, where the Fibonacci numbers are calculated.  How would the program work if at each step of the recursion the values ‚Äã‚Äãwere calculated from the very beginning? <br><br>  Finally, the last solution - the so-called let-expressions - is the simplest and, perhaps, the most suitable here.  Although the let-expressions are very similar to where, they define expression aliases, and not functions with such names.  Inside the do block, a let-expression looks like this: <br><br><blockquote>  run <font color="#66cc66"><b>::</b></font> Location <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font color="#06c">let</font> locDescr <font color="#66cc66"><b>=</b></font> describeLocation curLoc <br>  <font>putStrLn</font> locDescr <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66"><b>-&gt;</b></font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  Look <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> locDescr <br>  run curLoc <br>  <font color="#339933">...</font> <font color="#5d478b">- remaining code</font> </blockquote><br><br>  If we use a let-expression outside the do block, ‚Äîfor example, within other expressions ‚Äî the record will change a little.  The in keyword is added: <br><br><blockquote>  run <font color="#66cc66"><b>::</b></font> Location <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">IO</a></font> <font>(</font> <font>)</font> <br>  run curLoc <font color="#66cc66"><b>=</b></font> <br>  <font color="#06c">let</font> locDescr <font color="#66cc66"><b>=</b></font> describeLocation curLoc <font color="#06c">in</font> <br>  <font color="#06c">do</font> <br>  <font>putStrLn</font> locDescr <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Quit <font color="#66cc66"><b>-&gt;</b></font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  Look <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> locDescr <br>  run curLoc <br>  <font color="#339933">...</font> <font color="#5d478b">- remaining code</font> </blockquote><br><br>  In fact, you can define as many such expressions as you want between in and in, you will see how easy it is when we move on to adding objects.  For now we will leave the previous option where the let-expression is inside the do-block. <br><br><blockquote><blockquote>  Let-expressions are good not only because they are shorter, but also because they can be used in some special cases.  So, for example, let can be inserted into list generators (list comprehensions) for the same purpose: to define an expression with a limited scope.  However, in comparison with where there are drawbacks: you cannot use security expressions and pattern matching.  Of course, since we set pseudonyms, they should not be repeated within their scope. </blockquote></blockquote><br><br>  You ask when we go to the objects?  I have already passed.  Are you not yet, or what?  Then catch up.  Create an ADT type for objects, like this: <br><br><blockquote>  <font color="#06c">data</font> Object <font color="#66cc66"><b>=</b></font> Table <br>  <font color="#339933">|</font>  Umbrella <br>  <font color="#339933">|</font>  Drawer <br>  <font color="#339933">|</font>  Phone <br>  <font color="#339933">|</font>  Mailbox <br>  <font color="#339933">|</font>  Friend'sKey <br>  <font color="#06c">deriving</font> <font>(</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Eq</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Show</a></font> <font color="#339933">,</font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Read</a></font> <font>)</font> </blockquote><br><br>  In the image of locations, add a function with a description of the objects: <br><br><blockquote>  describeObject <font color="#66cc66"><b>::</b></font> Object <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  describeObject Umbrella <font color="#66cc66"><b>=</b></font> <i><font color="#808080">"Nice red mechanic Umbrella."</font></i> <br>  describeObject Table <font color="#66cc66"><b>=</b></font> <i><font color="#808080">"Good wooden table with drawer."</font></i> <br>  describeObject Phone <font color="#66cc66"><b>=</b></font> <i><font color="#808080">"The Phone has some voice messages for you."</font></i> <br>  describeObject MailBox <font color="#66cc66"><b>=</b></font> <i><font color="#808080">"The MailBox is closed."</font></i> <br>  describeObject obj <font color="#66cc66"><b>=</b></font> <i><font color="#808080">"There is nothing special about"</font></i> <font color="#339933">++</font> <font>show</font> obj </blockquote><br><br>  There are no dirty tricks, all that we already know and can do.  New starts when we need to define objects for locations.  We would like, of course, that everything was ready, Take and Drop actions worked, there was an inventory, composite objects ... But this does not happen.  Now we will make a draft of the objects in the locations where they can neither be taken nor thrown, and on the basis of it we will come up with other, more advanced and suitable mechanisms. <br><br>  Suppose, in the Home location where the game begins, there are several objects, and among them are a table, a drawer of a table, a telephone and an umbrella.  Let's set the locationObjects function, which would return the list of objects for this location: <br><br><blockquote>  locationObjects <font color="#66cc66"><b>::</b></font> Location <font color="#66cc66"><b>-&gt;</b></font> <font>[</font> Object <font>]</font> <br>  locationObjects Home <font color="#66cc66"><b>=</b></font> <font>[</font> Umbrella <font color="#339933">,</font> Drawer <font color="#339933">,</font> Phone <font color="#339933">,</font> Table <font>]</font> <br>  locationObjects <font color="#339933">_</font> <font color="#66cc66"><b>=</b></font> <font>[</font> <font>]</font> </blockquote><br><br>  In general, lists look simple.  The list of objects is of type [Object].  For the Home location, we return a list of four objects.  An empty list is indicated by empty square brackets - let it be while all other locations are without objects.  It is worth testing the code before moving on. <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> locationObjects Home <br>  <font>[</font> Umbrella <font color="#339933">,</font> Drawer <font color="#339933">,</font> Phome <font color="#339933">,</font> Table <font>]</font> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> locationObjects Garden <br>  <font>[</font> <font>]</font> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> describeObject Table <br>  <i><font color="#808080">‚ÄúGood wooden table with drawer.‚Äù</font></i> </blockquote><br><br>  Since the Object type is inherited from the Show type class, we can use the show function not only for type constructors, but also for a list of this type: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>show</font> Umbrella <br>  <i><font color="#808080">"Umbrella"</font></i> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>show</font> <font>[</font> Umbrella <font color="#339933">,</font> Table <font>]</font> <br>  <i><font color="#808080">"[Umbrella, Table]"</font></i> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>show</font> <font>(</font> locationObjects Home <font>)</font> <br>  <i><font color="#808080">"[Umbrella, Drawer, Phone, Table]"</font></i> <br><br>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>putStrLn</font> <font>(</font> <font>show</font> <font>(</font> locationObjects Home <font>)</font> <font>)</font> <br>  <font>[</font> Umbrella <font color="#339933">,</font> Drawer <font color="#339933">,</font> Phone <font color="#339933">,</font> Table <font>]</font> </blockquote><br><br>  The reverse is also true.  If the elements of the list can be parsed using the read function, then the entire list can also be parsed: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> <font>read</font> <i><font color="#808080">"[Table, MailBox]"</font></i> <font color="#66cc66"><b>::</b></font> <font>[</font> Object <font>]</font> <br>  <font>[</font> Table <font color="#339933">,</font> MailBox <font>]</font> </blockquote><br><br>  Now, when we have dealt with the syntax, we will make it so that for the current location not only its description is displayed, but also a list of the objects that are there is printed.  We use let-expressions: <br><br><blockquote>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font color="#06c">let</font> locDescr <font color="#66cc66"><b>=</b></font> describeLocation curLoc <br>  <font color="#06c">let</font> objectsDescr <font color="#66cc66"><b>=</b></font> <i><font color="#808080">" <font>\ n</font> There are some objects here:"</font></i> <font color="#339933">++</font> <font>show</font> <font>(</font> locationObjects curLoc <font>)</font> <br>  <font color="#06c">let</font> fullDescr <font color="#66cc66"><b>=</b></font> locDescr <font color="#339933">++</font> objectsDescr <br>  <font>putStrLn</font> fullDescr <br>  <font color="#339933">...</font> <font color="#5d478b">- the rest of the code, do not forget to update the Look action.</font> </blockquote><br><br>  The output of the program now looks like this: <br><br><blockquote>  <font color="#339933">*</font> Main <font color="#339933">&gt;</font> main <br>  Quest adventure on Haskell <font color="#339933">.</font> <br><br>  Home <br>  You are standing <font color="#06c">in</font> the middle of the wooden table <font color="#339933">.</font> <br>  There are some objects here: <font>[</font> Umbrella <font color="#339933">,</font> Drawer <font color="#339933">,</font> Phone <font color="#339933">,</font> Table <font>]</font> <br>  Enter command: </blockquote><br><br>  The code has a little trouble.  Even if there are no objects in the location, the inscription ‚ÄúThere are some objects here:‚Äù will still make us an eyesore. <br><br><blockquote>  Enter command: Go North <br><br>  You walking to North <font color="#339933">.</font> <br><br>  Garden <br>  You are <font color="#06c">in</font> the garden <font color="#339933">.</font>  <font color="#339933">.....</font> <br>  There are some objects here: <font>[</font> <font>]</font> <br>  Enter command: </blockquote><br><br>  In order not to display it for an empty list of objects, we will move all the code describing objects into a separate function, let's call it enumerateObjects.  At the input, it takes a list, and at the output it passes a string with the listed objects. <br><br><blockquote>  enumerateObjects <font color="#66cc66"><b>::</b></font> <font>[</font> Object <font>]</font> <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">String</a></font> <br>  enumerateObjects <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> <i><font color="#808080">""</font></i> <br>  enumerateObjects objects <font color="#66cc66"><b>=</b></font> <i><font color="#808080">" <font>\ n</font> There are some objects here:"</font></i> <font color="#339933">++</font> <font>show</font> objects </blockquote><br><br>  The first variant of the enumerateObjects function returns an empty string, but only when the list of transferred objects is empty.  If it is not empty, the first option will be rejected, and the second will work.  Run function: <br><br><blockquote>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font color="#06c">let</font> locDescr <font color="#66cc66"><b>=</b></font> describeLocation curLoc <br>  <font color="#06c">let</font> objectsDescr <font color="#66cc66"><b>=</b></font> enumerateObjects <font>(</font> locationObjects curLoc <font>)</font> <br>  <font color="#06c">let</font> fullDescr <font color="#66cc66"><b>=</b></font> locDescr <font color="#339933">++</font> objectsDescr <br>  <font>putStrLn</font> fullDescr <br>  <font color="#339933">...</font> <font color="#5d478b">- ...</font> </blockquote><br><br>  Or, if you want, you can take out the let-expressions from the do block: <br><br><blockquote>  run curLoc <font color="#66cc66"><b>=</b></font> <br>  <font color="#06c">let</font> <br>  locDescr <font color="#66cc66"><b>=</b></font> describeLocation curLoc <br>  objectsDescr <font color="#66cc66"><b>=</b></font> enumerateObjects <font>(</font> locationObjects curLoc <font>)</font> <br>  fullDescr <font color="#66cc66"><b>=</b></font> locDescr <font color="#339933">++</font> objectsDescr <br>  <font color="#06c">in</font> <font color="#06c">do</font> <br>  <font>putStrLn</font> fullDescr <br>  <font color="#339933">...</font> <font color="#5d478b">- ...</font> </blockquote><br><br>  Thanks to this simple refactoring, we can now change the function enumerateObjects, without affecting the run.  Here we wanted, say, not only to list the objects, but also to describe them, so we climbed our playful pens into enumerateObjects and corrected what was clever there.  But somehow later.  Now add a custom Investigate action.  At this command, the program should produce a detailed description of the object.  It is clear that the user must enter something like this: <br><br><blockquote>  Enter command: Investigate Umbrella </blockquote><br><br>  The string "Investigate Umbrella" will have to be parsed.  Familiar, right?  We have already done this with the Go team.  Here is the same thing: just put an Object type parameter into the Investigate constructor. <br><br><blockquote>  <font color="#06c">data</font> Action <font color="#66cc66"><b>=</b></font> <br>  <font color="#339933">...</font> <br>  <font color="#339933">|</font>  Investigate Object <br>  <font color="#339933">...</font> </blockquote><br><br>  Only a little remains - to correct the run function: <br><br><blockquote>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font color="#339933">...</font> <br>  <font color="#339933">...</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Investigate obj <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> describeObject obj <font>)</font> <br>  run curLoc <br>  <font color="#339933">...</font> </blockquote><br><br>  And voila!  You have implemented the next user action!  Congratulations!  You can check that if you enter the "Investigate Umbrella" command, the program will display the line "Nice red mechanic Umbrella.", I do not cheat. <br><br>  Just ... Do you know what is wrong with us?  If we, while in the Home location, enter the ‚ÄúInvestigate MailBox‚Äù command, we will be given a description of the mailbox, which cannot be seen from here at all!  Well, then we will invent the function isVisible, which returns True if we see an object - and only in this case we will give a description of the object.  What are the arguments of the isVisible function?  We need an object under study, as well as a list of all objects in a location.  Something like this: <br><br><blockquote>  isVisible <font color="#66cc66"><b>::</b></font> Object <font color="#66cc66"><b>-&gt;</b></font> <font>[</font> Object <font>]</font> <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Bool</a></font> </blockquote><br><br>  Now you need to somehow find out if there is an object in this list.  We will not come up with "stupid" options with the enumeration of all objects in the list, although this is very possible, but simply use the regular function elem.  It takes two parameters: an element and a list.  If the item is found in the list, returns True.  Exactly what is needed! <br><br><blockquote>  isVisible <font color="#66cc66"><b>::</b></font> Object <font color="#66cc66"><b>-&gt;</b></font> <font>[</font> Object <font>]</font> <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Bool</a></font> <br>  isVisible obj objects <font color="#66cc66"><b>=</b></font> <font>elem</font> obj objects </blockquote><br><br><blockquote><blockquote>  In Haskell, there is a special form of writing in which a function is placed between its arguments, for greater clarity and clarity of meaning.  To do this, you need to enclose the function in reverse apostrophes, - those that are located on the "E" button. <br><br><blockquote>  isVisible ' <font color="#66cc66"><b>::</b></font> Object <font color="#66cc66"><b>-&gt;</b></font> <font>[</font> Object <font>]</font> <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Bool</a></font> <br>  isVisible 'obj objects <font color="#66cc66"><b>=</b></font> obj ` <font>elem`</font> objects </blockquote><br><br>  But the "stupid" versions of the same function.  In them, we manually search for an object inside the list. <br><br><blockquote>  isVisible '' <font color="#66cc66"><b>::</b></font> Object <font color="#66cc66"><b>-&gt;</b></font> <font>[</font> Object <font>]</font> <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Bool</a></font> <br>  isVisible '' obj <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> False <br>  isVisible '' obj <font>(</font> o: os <font>)</font> <font color="#66cc66"><b>=</b></font> <font>(</font> obj <font color="#339933">==</font> o <font>)</font> <font color="#339933">||</font>  <font>(</font> isVisible '' obj os <font>)</font> <br><br>  isVisible '' ' <font color="#66cc66"><b>::</b></font> Object <font color="#66cc66"><b>-&gt;</b></font> <font>[</font> Object <font>]</font> <font color="#66cc66"><b>-&gt;</b></font> <font color="green"><a href="http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html">Bool</a></font> <br>  isVisible '' 'obj <font>[</font> <font>]</font> <font color="#66cc66"><b>=</b></font> False <br>  isVisible '' 'obj objects <font color="#66cc66"><b>=</b></font> <font>(</font> obj <font color="#339933">==</font> <font>head</font> objects <font>)</font> <font color="#339933">||</font>  <font>(</font> isVisible '' 'obj <font>(</font> <font>tail</font> objects <font>)</font> <font>)</font> </blockquote><br><br>  They work the same way, the only difference is in the means used.  Both there and there the list is split into parts: the head element and the tail of the remaining elements.  In the first example, the list is split using an entry (o: os).  It is clear that the variable "o" contains the head, and the variable "os" - everything else.  In the second example, we do the same thing, only using the built-in functions on the head and tail lists.  Next, we simply check if the object matches the head element, and if not, call isVisible recursively for the remaining elements.  In order for the recursion not to be infinite, we added a variant of the function ‚ÄúisVisible obj [] = False‚Äù - it will work if we suddenly bite off all the elements from the list and nothing remains. </blockquote></blockquote><br><br>  Well, it remains only to use this feature.  As usual, we change run, and in order not to request objects of the current location several times, we put them into a let-expression: <br><br><blockquote>  run curLoc <font color="#66cc66"><b>=</b></font> <font color="#06c">do</font> <br>  <font color="#06c">let</font> locObjects <font color="#66cc66"><b>=</b></font> locationObjects curLoc <br>  <font color="#06c">let</font> locDescr <font color="#66cc66"><b>=</b></font> describeLocation curLoc <br>  <font color="#06c">let</font> objectsDescr <font color="#66cc66"><b>=</b></font> enumerateObjects locObjects <br>  <font color="#06c">let</font> fullDescr <font color="#66cc66"><b>=</b></font> locDescr <font color="#339933">++</font> objectsDescr <br>  <font>putStrLn</font> fullDescr <br>  <font>putStr</font> <i><font color="#808080">"Enter command:"</font></i> <br>  x <font color="#66cc66"><b>&lt;-</b></font> <font>getLine</font> <br>  <font color="#06c">case</font> <font>(</font> convertStringToAction x <font>)</font> <font color="#06c">of</font> <br>  Investigate obj <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font color="#06c">if</font> <font>(</font> isVisible obj locObjects <font>)</font> <br>  <font color="#06c">then</font> <font>putStrLn</font> <font>(</font> describeObject obj <font>)</font> <br>  <font color="#06c">else</font> <font>putStrLn</font> <font>(</font> <i><font color="#808080">‚ÄúYou don't see any‚Äù</font></i> <font color="#339933">++</font> <font>show</font> obj <font color="#339933">++</font> <i><font color="#808080">"here."</font></i> <font>)</font> <br>  run curLoc <br>  Quit <font color="#66cc66"><b>-&gt;</b></font> <font>putStrLn</font> <i><font color="#808080">"Be seen you ..."</font></i> <br>  <font color="#339933">...</font> <font color="#5d478b">- the rest of the code</font> </blockquote><br><br>  That's all.  On this positive note, we will stop, - it's time to relax, and so we got a huge cart of knowledge. <br><br><blockquote><blockquote>  Tasks for fixing. <br><br>  1. Move all functions related to objects to the Objects module, and all functions related to locations to the Locations module. <br>  2. To make an experimental conclusion of location objects in the following form: <br><br><blockquote><pre>  Home
 You are standing in the middle of the wooden table.
   There are some objects here:
      Umbrella: Nice red mechanic Umbrella.
      Table: Good wooden table with drawer.
      Phone: The Phone has some voice messages for you.
      Drawer: There is nothing special about Drawer. </pre></blockquote><br><br>  3. To refactor the processing of the Investigate action, creating a separate function for this.  The code of the run function after refactoring should look like this: <br><br><blockquote>  <font color="#339933">...</font> <br>  Investigate obj <font color="#66cc66"><b>-&gt;</b></font> <font color="#06c">do</font> <br>  <font>putStrLn</font> <font>(</font> investigate obj locObjects <font>)</font> <br>  run curLoc <br>  <font color="#339933">...</font> </blockquote></blockquote></blockquote><br><br>  <a href="https://github.com/graninas/Quest-Tutorial-Code/archives/158714f261854dfddd8e04a7ec59bc6ac3210bb2">Sources to this part</a> . <br><br>  Table of contents, list of references and additional information can be found in the <a href="http://habrahabr.ru/blogs/Haskell/120590/">"Welcome"</a> . </div><p>Source: <a href="https://habr.com/ru/post/123422/">https://habr.com/ru/post/123422/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../123414/index.html">Verification of SMS spam mailers with the application to the prosecutor's office</a></li>
<li><a href="../123415/index.html">New Javascript framework based on Scriptographer</a></li>
<li><a href="../123416/index.html">Network: what future awaits my son, can I help him</a></li>
<li><a href="../123418/index.html">Application for finding work and company information (for Windows Phone 7)</a></li>
<li><a href="../123419/index.html">Problems in the eBay chain, Mail, Russia</a></li>
<li><a href="../123423/index.html">As I developed the device, from idea to production. Part 3</a></li>
<li><a href="../123425/index.html">Anonymous launched HackerLeaks.tk to dump hacking information</a></li>
<li><a href="../123426/index.html">Travel Design</a></li>
<li><a href="../123427/index.html">Three ways to worry less</a></li>
<li><a href="../123428/index.html">Identity Management - basic account management</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>