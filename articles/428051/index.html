<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to make even more incorrect states even more inexpressible</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Not so long ago on Habr√© translated an article about how using algebraic data types to ensure that incorrect states were ineffable. Today we will look...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to make even more incorrect states even more inexpressible</h1><div class="post__text post__text-html js-mediator-article"><p>  Not so long ago on Habr√© <a href="https://habr.com/post/424895/">translated an article</a> about how using algebraic data types to ensure that incorrect states were ineffable.  Today we will look at a slightly more generalized, scalable and secure way to express the inexpressible, and haskel will help us in this. </p><a name="habracut"></a><br><p>  In short, in this article some entity is considered with a postal address and an e-mail address, as well as with an additional condition that there must be at least one of these addresses.  How is it proposed to express this condition at the type level?  It is proposed to record addresses as follows: </p><br><pre><code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> ContactInfo = | EmailOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo | PostOnly <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> PostalContactInfo | EmailAndPost <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> EmailContactInfo * PostalContactInfo</code> </pre> <br><p>  What are the problems with this approach? </p><br><p>  The most obvious (and it was noted several times in the comments to that article) - this approach is not scalable at all.  Imagine that we have not two types of addresses, but three or five, and the condition of correctness looks like ‚Äúthere must be either a postal address or an email address and an office address at the same time, and there should not be several addresses of the same type‚Äù.  Anyone can write the appropriate type as an exercise for self-checking.  The task with an asterisk is to rewrite this type for the case when the condition about the absence of duplicates disappeared from the TZ. </p><br><h3>  We divide </h3><br><p>  How can this problem be solved?  Let's try to fantasize.  Only first we will decompose and divide the address class (for example, mail / email / table number in the office) and the contents corresponding to this class: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> | </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  We will not think about the content yet, because there is nothing about it in the statement of work on the condition of the validity of the address list. </p><br><p>  If we checked the corresponding condition in the runtime of some constructor of some ordinary OOP-language, then we would just write a function like </p><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">valid</span></span> :: [<span class="hljs-type"><span class="hljs-type">AddrType</span></span>] -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> valid xs = <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hasNoDups = nub xs == xs <span class="hljs-comment"><span class="hljs-comment">--      hasPost = Post `elem` xs hasEmail = Email `elem` xs hasOffice = Office `elem` xs in hasNoDups &amp;&amp; (hasPost || (hasEmail &amp;&amp; hasOffice))</span></span></code> </pre> <br><p>  And would throw any, if it returns <code>False</code> . </p><br><p>  Can we instead check for a similar condition using a tip checker when compiling?  It turns out that yes, we can, if the type system of the language is sufficiently expressive, and the rest of the article we will pick this approach. </p><br><p>  Here dependent types will help us a lot, and since the most adequate way to write seized code on a Haskel is to first write it on aqda or Idris, we will sharply change our shoes and we will write on Idris.  Idris syntax is close enough to a Haskel: for example, the above function only needs to change the signature a little: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> : List AddrType -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span></code> </pre> <br><p>  Now remember that in addition to the address classes, we also need their contents, and encode the dependence of the fields on the address class as GADT: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrType</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">PostFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">city</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">street</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">EmailFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">String</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Email</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">OfficeFields</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">floor</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">desk</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nat</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AddrFields</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Office</span></span></span></span></code> </pre> <br><p>  That is, if we are given a value of <code>fields</code> type <code>AddrFields t</code> , then we know that <code>t</code> is some class of <code>AddrType</code> , and that in <code>fields</code> lies a set of fields corresponding to this particular class. </p><br><div class="spoiler">  <b class="spoiler_title">About this post</b> <div class="spoiler_text"><p>  This is not the most type-safe encoding, since GADT does not have to be injective, and it would be better to declare three separate data types <code>PostFields</code> , <code>EmailFields</code> , <code>OfficeFields</code> and write a function </p><br><pre> <code class="hljs pgsql">addrFields : AddrType -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> addrFields Post = PostFields addrFields Email = EmailFields addrFields Office = OfficeFields</code> </pre> <br><p>  but this is too much writings, which for the prototype does not give a significant gain, but in Haskel there are still shorter and more pleasant mechanisms for this. </p></div></div><br><p>  What is the entire address in this model?  This is a pair from the address class and the corresponding fields: </p><br><pre> <code class="hljs pgsql">Addr : <span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> Addr = (t : AddrType ** AddrFields t)</code> </pre> <br><p>  Fans of type theory will say that this is an existential dependent type: if we are given some value of type <code>Addr</code> , then this means that there is a value <code>t</code> type <code>AddrType</code> and a corresponding set of fields <code>AddrFields t</code> .  Naturally, the addresses of different classes are of the same type: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (Email ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (Office ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Moreover, if we are given <code>EmailFields</code> fields, then the only address class that matches is <code>Email</code> , so you can leave it out, the type checker will display it himself: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">someEmailAddr</span></span> : Addr someEmailAddr = (_ ** EmailFields <span class="hljs-string"><span class="hljs-string">"that</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">@feel</span></span></span><span class="hljs-string">.bro"</span></span>) someOfficeAddr : Addr someOfficeAddr = (_ ** OfficeFields (-<span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-number"><span class="hljs-number">762</span></span>)</code> </pre> <br><p>  Let us write an auxiliary function, which according to the list of addresses gives the corresponding list of classes of addresses, and immediately generalize it before working on an arbitrary functor: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">types</span></span> : Functor f =&gt; f Addr -&gt; f AddrType <span class="hljs-keyword"><span class="hljs-keyword">types</span></span> = map fst</code> </pre> <br><p>  Here the existential type <code>Addr</code> behaves like a familiar couple: in particular, you can ask for its first component <code>AddrType</code> (task with an asterisk: why ask the second component so it does not work out?). </p><br><h4>  Raise </h4><br><p>  Now we come to the key part of our story.  So, we have a <code>List Addr</code> address list and some <code>valid : List AddrType -&gt; Bool</code> predicate <code>valid : List AddrType -&gt; Bool</code> , the execution of which for this list we want to guarantee at the level of types.  How can we combine them?  Of course, another type! </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">) = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">True</span></span></span><span class="hljs-class">) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Now we will understand what we have written here. </p><br><p>  <code>data ValidatedAddrList : List Addr -&gt; Type where</code> means that the type <code>ValidatedAddrList</code> parameterized by the address list itself. </p><br><p>  Let's look at the signature of the only <code>MkValidatedAddrList</code> constructor of this type: <code>(lst : List Addr) -&gt; (prf : valid (types lst) = True) -&gt; ValidatedAddrList lst</code> .  That is, it takes some list of addresses <code>lst</code> and one more argument <code>prf</code> type <code>valid (types lst) = True</code> .  What does this type mean?  It means that the value to the left of <code>=</code> is equal to the value to the right of <code>=</code> , that is, <code>valid (types lst)</code> is actually True. </p><br><p>  How it works?  The signature <code>=</code> looks like <code>(x : A) -&gt; (y : B) -&gt; Type</code> .  That is, <code>=</code> takes two arbitrary values ‚Äã‚Äãof <code>x</code> and <code>y</code> (perhaps even different types of <code>A</code> and <code>B</code> , which means that the inequality in Idris is heterogeneous, and that is somewhat ambiguous from the point of view of type theory, but this is a topic for a separate discussion).  Due to what then equality is demonstrated?  And due to the fact that the only constructor <code>=</code> - <code>Refl</code> with a signature of <em>almost</em> <code>(x : A) -&gt; x = x</code> .  That is, if we have a value of type <code>x = y</code> , then we know that it was built using <code>Refl</code> (because there are no other constructors), which means that <code>x</code> is actually equal to <code>y</code> . </p><br><p>  Note that this is why, at best, we will always pretend at best that we are proving something, because there is <code>undefined</code> in Haskel, which populates any type, so the above reasoning does not work there: for any <code>x</code> , <code>y</code> term is type <code>x = y</code> could be created via <code>undefined</code> (or through infinite recursion, let's say that by and large the same thing from the point of view of type theory). </p><br><p>  We also note that equality here is not in the sense of Haskell's <code>Eq</code> or some kind of <code>operator==</code> in C ++, but significantly more rigorous: structural, which, simplifying, means that two values ‚Äã‚Äãhave the same <em>form</em> .  That is, to deceive him so simply will not work.  But equality issues are traditionally pulled into a separate article. </p><br><p>  In order to consolidate our understanding of equality, we write unit tests on the <code>valid</code> function: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> testPostValid = Refl testEmptyInvalid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testEmptyInvalid = Refl testDupsInvalid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post, Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testDupsInvalid = Refl testPostEmailValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post, Email] = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> testPostEmailValid = Refl</code> </pre> <br><p>  These tests are good because you don‚Äôt even need to run them; it‚Äôs enough that the TIP checker checked them.  Indeed, let's replace <code>True</code> with <code>False</code> , for example, in the very first of them and see what happens: </p><br><pre> <code class="hljs pgsql">testPostValid : <span class="hljs-keyword"><span class="hljs-keyword">valid</span></span> [Post] = <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> testPostValid = Refl</code> </pre> <br><p>  Typcheker cuss </p><br><p><img src="https://habrastorage.org/webt/l7/to/xm/l7toxmndt6lzzbpmjersntiujfg.png"></p><br><p>  as expected.  Wonderful. </p><br><h4>  Simplified </h4><br><p>  Now let's review our <code>ValidatedAddrList</code> bit. </p><br><p>  First, the pattern of comparing some value with <code>True</code> quite common, so there is a special type <code>So</code> for this: you can take <code>So x</code> as a synonym for <code>x = True</code> .  Let's fix the definition of <code>ValidatedAddrList</code> : </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)) -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  In addition, there is a convenient auxiliary function for <code>choose</code> for <code>So</code> , which in its sense raises a check for the level of types: </p><br><pre> <code class="hljs pgsql">&gt; :doc choose Data.So.choose : (b : <span class="hljs-type"><span class="hljs-type">Bool</span></span>) -&gt; Either (So b) (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> b)) <span class="hljs-keyword"><span class="hljs-keyword">Perform</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> analysis <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> a <span class="hljs-type"><span class="hljs-type">Boolean</span></span>, providing clients <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> a So proof</code> </pre> <br><p>  We need it when we write functions that modify this type. </p><br><p>  Secondly, sometimes (especially with interactive development), the idris can find a suitable <code>prf</code> value <code>prf</code> its own.  In order in such cases it was not necessary to design it by hand, there is an appropriate syntactic sugar: </p><br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class"> -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Type</span></span></span><span class="hljs-class"> where </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkValidatedAddrList</span></span></span><span class="hljs-class"> : (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">List</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Addr</span></span></span><span class="hljs-class">) -&gt; {</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">auto</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">prf</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">So</span></span></span><span class="hljs-class"> (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">valid</span></span></span><span class="hljs-class"> $ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">types</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lst</span></span></span><span class="hljs-class">)} -&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">ValidatedAddrList</span></span></span><span class="hljs-class"> lst</span></span></code> </pre> <br><p>  Curly brackets mean that this is an implicit argument that idris will try to pull out of context, and <code>auto</code> means that he will also try to construct it himself. </p><br><p>  So, what does this new <code>ValidatedAddrList</code> give us?  And it gives this chain of reasoning: let <code>val</code> be a value of type <code>ValidatedAddrList lst</code> .  This means that <code>lst</code> is some address list, and besides, <code>val</code> was created using the <code>MkValidatedAddrList</code> constructor, to which we passed this same <code>lst</code> and another <code>prf</code> value of type <code>So (valid $ types lst)</code> , which is almost <code>valid (types lst) = True</code> .  And in order for us to build <code>prf</code> , we need, in fact, to prove that this equality holds. </p><br><p>  And the most beautiful thing is that everything is checked by the tickpicker.  Yes, validation will have to be performed at runtime (because addresses can be read from a file or from a network), but the type checker guarantees that this check will be done: without it, <code>ValidatedAddrList</code> cannot be created.  At least in Idris.  In Haskel it is possible, alas. </p><br><h4>  We insert </h4><br><p>  To make sure that verification is inevitable, we will try to write a function to add an address to the list.  First try: </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) insert addr (MkValidatedAddrList lst) = MkValidatedAddrList (addr :: lst)</code> </pre> <br><p>  Nope, the typchecker gives on the fingers (although not very readable, the cost of <code>valid</code> too complicated): </p><br><p><img src="https://habrastorage.org/webt/au/oa/6j/auoa6jeo10ucav7rffetqmvylec.png"></p><br><p>  How do we get a copy of this here <code>So</code> ?  No other than the above <code>choose</code> .  Second attempt: </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; ?rhs</code> </pre> <br><p>  It is almost secret check.  ‚ÄúAlmost‚Äù because it is not clear what to substitute for <code>rhs</code> .  Rather, it is clear: in this case, the function must somehow report the error.  So, we need to change the signature and wrap the return value, for example, in <code>Maybe</code> : </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; Just $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  This is tipped and works as it should. </p><br><p>  But now the following is not a very obvious problem, which was, in fact, in the original article.  The type of this function does not interfere with writing such an implementation: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Maybe (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">Nothing</span></span></code> </pre> <br><p>  That is, we always say that we could not build a new address list.  Tips?  Yes.  Correctly?  Well, hardly.  Can this be avoided? </p><br><p>  It turns out that it is possible, and we have all the necessary tools for this.  In case of success, <code>insert</code> returns <code>ValidatedAddrList</code> , which contains evidence of this very success.  So add elegant symmetry and ask the function to return more and proof of failure! </p><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> : (addr : Addr) -&gt; ValidatedAddrList lst -&gt; Either (So (<span class="hljs-keyword"><span class="hljs-keyword">not</span></span> $ valid $ types (addr :: lst))) (ValidatedAddrList (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">insert</span></span> addr (MkValidatedAddrList lst) = <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-keyword"><span class="hljs-keyword">choose</span></span> (valid $ types (addr :: lst)) <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> l =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> $ MkValidatedAddrList (addr :: lst) <span class="hljs-keyword"><span class="hljs-keyword">Right</span></span> r =&gt; <span class="hljs-keyword"><span class="hljs-keyword">Left</span></span> r</code> </pre> <br><p>  Now we can not just take and always return <code>Nothing</code> . </p><br><p>  Similarly, you can do for address removal functions and the like. </p><br><p>  Let's see how it all looks in the end now. </p><br><p>  Let's try to create an empty address list: </p><br><p><img src="https://habrastorage.org/webt/9l/pf/a_/9lpfa_ytfrgfsvxbvy4lkk0a8uy.png"></p><br><p>  It is impossible, the empty list is not valid. </p><br><p>  How about a list of just one email address? </p><br><p><img src="https://habrastorage.org/webt/au/d2/jq/aud2jqe2malfgrjg2txzsncdom4.png"></p><br><p>  OK, let's try to insert the postal address into the list, in which there is already an postal address: </p><br><p><img src="https://habrastorage.org/webt/xl/cx/ri/xlcxrimioc_dutfysgtdmr2srmc.png"></p><br><p>  Let's try to insert an email: </p><br><p><img src="https://habrastorage.org/webt/sn/1n/zw/sn1nzwqz5erm1vjnq59dkel3zzi.png"></p><br><p>  In the end, everything works exactly as expected. </p><br><p>  Ffuh.  I thought it would be three lines, but it worked a little longer.  So explore how far we can go to Haskel, we will be in the next article.  In the meantime, a little </p><br><h4>  Ponder </h4><br><p>  What is the result of the profit of such a decision in comparison with the one given in the article to which we referred at the very beginning? </p><br><ol><li>  It is, again, much more scalable.  Complex validation functions are easier to write. </li><li>  It is more isolated.  The client code is generally not obliged to know what is inside the validation function, whereas the <code>ContactInfo</code> form from the original article requires you to tie it up. </li><li>  The logic of validation is written in the form of ordinary and familiar functions, so that you can immediately check it with thoughtful reading and test with time-tests, and not deduce the meaning of the test from the form of the data type representing the already verified result. </li><li>  It becomes possible to slightly more accurately specify the behavior of functions that work with the type of data that we are interested in, especially in the case of failure to check.  For example, the <code>insert</code> written as a result cannot simply be written <em>incorrectly</em> .  Similarly, one could write <code>insertOrReplace</code> , <code>insertOrIgnore</code> and the like, whose behavior is fully specified in the type. </li></ol><br><p>  What is the profit compared to the OOP solution in this spirit? </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">class</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">ValidatedAddrListClass</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">ValidatedAddrListClass</span></span>(std::vector&lt;Addr&gt; addrs) { if (!<span class="hljs-built_in"><span class="hljs-built_in">valid</span></span>(addrs)) throw ValidationError {}; } };</code> </pre> <br><ol><li>  The code is more modularized and secure.  In the case of the above, verification is an <em>action</em> that is checked once and which was later forgotten.  Everything rests on the word of honor and agreement that if you have a <code>ValidatedAddrListClass</code> , then its implementation once there made a check.  The very fact of this check from the class as some value can not be picked out.  In the case of <em>values ‚Äã‚Äãof</em> some type, this value can be transferred between different parts of the program, used to build more complex values ‚Äã‚Äã(for example, again, negating this test), explore (see the next paragraph) and generally do the same thing that we used to do. with values. </li><li>  Such checks can be used with (dependent) pattern matching.  True, not in the case of this <code>valid</code> function and not in the case of Idris, it is painfully complicated, and Idris is painfully stupid so that information useful for patterns can be extracted from the <code>valid</code> structure.  Nevertheless, <code>valid</code> can be rewritten in a slightly more pattern-friendly style, but this is beyond the scope of this article and is generally nontrivial in itself. </li></ol><br><p>  What are the disadvantages? </p><br><p>  I see only one serious fundamental flaw: <code>valid</code> is too stupid a function.  It returns only one bit of information - validated or not.  In the case of smarter types, we could achieve something more interesting. </p><br><p>  For example, imagine that the requirement of unique addresses is missing from the TK.  In this case, it is obvious that adding a new address to an existing list of addresses will not make the list invalid, so one could <em>prove this theorem</em> by writing a function of type <code>So (valid $ types lst) -&gt; So (valid $ types $ addr :: lst)</code> , and use it, for example, to write a type-safe always successful </p><br><pre> <code class="hljs coffeescript">insert : <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr : Addr)</span></span></span><span class="hljs-function"> -&gt;</span></span> ValidatedAddrList lst -&gt; ValidatedAddrList (addr :: lst)</code> </pre> <br><p>  But, alas, theorems like recursion and induction, and in our problem there is no elegant inductive structure, therefore, in my opinion, the code with <code>valid</code> oak boolean is also not bad. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/428051/">https://habr.com/ru/post/428051/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../428039/index.html">Government does not plan to legally protect network neutrality</a></li>
<li><a href="../428041/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ336 (October 22 - 28, 2018)</a></li>
<li><a href="../428043/index.html">Waiting for the sixth, Winamp 5.8: the ‚Äúmystery‚Äù of origin, the possibilities of the official version</a></li>
<li><a href="../428045/index.html">PHP Digest number 142 (October 15 - 29, 2018)</a></li>
<li><a href="../428047/index.html">Analysis of the performance of WSGI-servers: return uWSGI to the place</a></li>
<li><a href="../428053/index.html">How to create a testing strategy: the version of real engineers</a></li>
<li><a href="../428055/index.html">Retrospective of technology startups. Z3 - the first relay computer</a></li>
<li><a href="../428057/index.html">A new look at documenting API and SDK in Yandex. Lecture on Hyperbaton</a></li>
<li><a href="../428059/index.html">Connecting Multipath LUN storage to VMware ESXi and Debian GNU / Linux</a></li>
<li><a href="../428061/index.html">Manage project cost with Earned Value Management</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>