<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>High-performance NIO server on Netty</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Preamble 
 Hello. I am the main developer of the largest Minecraft server in the CIS (I won‚Äôt advertise who I need, they know). For almost a year we h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>High-performance NIO server on Netty</h1><div class="post__text post__text-html js-mediator-article"><h5>  Preamble </h5><br>  Hello.  I am the main developer of the largest Minecraft server in the CIS (I won‚Äôt advertise who I need, they know).  For almost a year we have been writing our server implementation, designed for more than 40 people (we want to see a figure of 500 at least).  So far everything has been successful, but lately the system has begun to rest on the fact that, due to the not very successful network implementation (1 stream for input, 1 for output + 1 for processing), more than 980 streams (+ systemic) work online with 300 players That, combined with the performance of Java's default io, gives a huge performance drop, and already with 100 players the server is mainly engaged in what it writes / reads to / from the network. <br><br>  So I decided to switch to NIO.  <a href="http://www.jboss.org/netty">Netty</a> got into the hands quite by accident, the structure of which seemed just perfect to integrate it into a ready-made working solution.  Unfortunately, Netty manuals are not only not only in Russian, but also in English, so I had to experiment a lot and search the library code to find the best way. <br><br>  Here I will try to paint the server part of working with the network through Netty, maybe it will be useful to someone. <a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Server creation </h4><br><pre><code class="java hljs">ExecutorService bossExec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderedMemoryAwareThreadPoolExecutor(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">400000000</span></span>, <span class="hljs-number"><span class="hljs-number">2000000000</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, TimeUnit.SECONDS); ExecutorService ioExec = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> OrderedMemoryAwareThreadPoolExecutor(<span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span>, <span class="hljs-number"><span class="hljs-number">400000000</span></span>, <span class="hljs-number"><span class="hljs-number">2000000000</span></span>, <span class="hljs-number"><span class="hljs-number">60</span></span>, TimeUnit.SECONDS); ServerBootstrap networkServer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServerBootstrap(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NioServerSocketChannelFactory(bossExec, ioExec, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span>)); networkServer.setOption(<span class="hljs-string"><span class="hljs-string">"backlog"</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>); networkServer.setOption(<span class="hljs-string"><span class="hljs-string">"connectTimeoutMillis"</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>); networkServer.setPipelineFactory(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ServerPipelineFactory()); Channel channel = networkServer.bind(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InetSocketAddress(address, port));</code> </pre> <br>  <i>OrderedMemoryAwareThreadPoolExecutor is</i> used to perform Netty tasks; they are the most effective from the experience of French colleagues.  You can use other Executors, for example, <i>Executors.newFixedThreadPool (n)</i> .  In no case do not use <i>Executors.newCachedThreadPool ()</i> , it creates unreasonably many threads and there is almost no netty gain from Netty.  It makes no sense to use more than 4 worker threads, because  they more than cope with a huge load (programmers from Xebia-France pulled over 100,000 simultaneous connections on 4 threads).  Boss streams should be one for each listening port.  <i>The channel</i> that the bind function returns, as well as the <i>ServerBootsrap,</i> must be saved so that you can stop the server later. <br><br><h4>  PipelineFactory </h4><br>  How the connections and client packages will be handled is determined by <i>PipelineFactory</i> , which, when opened with a client, creates a pipeline for it, in which event handlers are defined that occur on the channel.  In our case, this is <i>ServerPipelineFactory</i> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServerPipelineFactory</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ChannelPipelineFactory</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> ChannelPipeline </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPipeline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ PacketFrameDecoder decoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PacketFrameDecoder(); PacketFrameEncoder encoder = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PacketFrameEncoder(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Channels.pipeline(decoder, encoder, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PlayerHandler(decoder, encoder)); } }</code> </pre><br>  In this code, <i>PacketFrameDecoder</i> , <i>PacketFrameEncoder,</i> and <i>PlayerHandler</i> are event handlers that we define.  The <i>Channels.pipeline ()</i> function creates a new pipeline with the handlers passed to it.  Be careful: events pass handlers in the order in which you passed from the pipeline function! <br><br><h4>  Protocol </h4><br>  I will describe the protocol a little so that it will be clear further. <br><br>  Data exchange takes place using class objects that extend the Packet class, in which two functions are defined, <i>get (ChannelBuffer input)</i> and <i>send (ChannelBuffer output)</i> .  Accordingly, the first function reads the necessary data from the channel, the second one writes the packet data to the channel. <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Packet</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Packet </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelBuffer buffer)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> IOException </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id = buffer.readUnsignedShort(); <span class="hljs-comment"><span class="hljs-comment">//  ID  ,  ,     Packet packet = getPacket(id); //      ID if(packet == null) throw new IOException("Bad packet ID: " + id); //         ,   packet.get(buffer); //       return packet; } public statuc Packet write(Packet packet, ChannelBuffer buffer) { buffer.writeChar(packet.getId()); //  ID  packet.send(buffer); //    } // ,       public abstract void get(ChannelBuffer buffer); public abstract void send(ChannelBuffer buffer); }</span></span></code> </pre><br>  An example of a pair of packages for clarity: <br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ,       public class Packet1Login extends Packet { public String login; public void get(ChannelBuffer buffer) { int length = buffer.readShort(); StringBuilder builder = new StringBuilder(); for(int i = 0; i &lt; length ++i) builder.append(buffer.readChar()); login = builder.toString(); } public void send(ChannelBuffer buffer) { //   , ..      } } // ,       ,      public class Packet255KickDisconnect extends Packet { public String reason; public void get(ChannelBuffer buffer) { int length = buffer.readShort(); StringBuilder builder = new StringBuilder(); for(int i = 0; i &lt; length ++i) builder.append(buffer.readChar()); reason = builder.toString(); } public void send(ChannelBuffer buffer) { buffer.writeShort(reason.length()); for(int i = 0; i &lt; reason.length(); ++i) { buffer.writeChar(reason.getCharAt(i)); } } }</span></span></code> </pre><br>  <b>ChannelBuffer is</b> very similar to DataInputStream and DataOutputStream in one person.  Most functions, if not the same, are very similar.  Notice that I do not care about checking whether there are enough bytes in the buffer for reading, as if I were working with a blocking IO.  About this further ... <br><br><h4>  Work with the client </h4><br>  Work with the client is mainly determined by the class <i>PlayerHandler</i> : <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PlayerHandler</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SimpleChannelUpstreamHandler</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> PlayerWorkerThread worker; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelConnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, ChannelStateEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     .    Worker  ‚Äî ,      . //      ( e.getChannel()),        worker = new PlayerWorkerThread(this, e.getChannel()); } @Override public void channelDisconnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { //   .   ,   ,    ,     .    ,     ,   ,       ,    . worker.disconnectedFromChannel(); } @Override public void messageReceived(ChannelHandlerContext ctx, MessageEvent e) { //     Packet'  ,       worker.      . if(e.getChannel().isOpen()) worker.acceptPacket((Packet) e.getMessage()); } @Override public void exceptionCaught(ChannelHandlerContext ctx, ExceptionEvent e) { //    .  ,  . Server.logger.log(Level.WARNING, "Exception from downstream", e.getCause()); ctx.getChannel().close(); } }</span></span></code> </pre><br>  A Worker can send data to a player simply by the function channel.write (packet), where channel is the player's channel that is sent to him when connected, and packet is an object of the Packet class.  Encoder will be responsible for encoding packages. <br><br><h4>  Decoder and Encoder </h4><br>  Actually, the most important part of the system is that they are responsible for the formation of Packet packets from the user's stream and for sending the same packets to the stream. <br><br>  The encoder is very simple, it sends packets to the player: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PacketFrameEncoder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">OneToOneEncoder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext channelhandlercontext, Channel channel, Object obj)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!(obj <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Packet)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> obj; <span class="hljs-comment"><span class="hljs-comment">//    ,      Packet p = (Packet) obj; ChannelBuffer buffer = ChannelBuffers.dynamicBuffer(); //          .      ,       ‚Äî ChannelBuffers     ,    . Packet.write(p, buffer); //     return buffer; //  ,       } }</span></span></code> </pre><br><br>  Decoder is much more complicated.  The fact is that in the buffer that came from the client, there may simply not be enough bytes to read the entire packet.  In this case, the ReplayingDecoder class will help us.  We just need to implement its decode function and read the data from the stream in it, not caring about nothing: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PacketFrameDecoder</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ReplayingDecoder</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoidEnum</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelClosed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, ChannelStateEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ctx.sendUpstream(e); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">channelDisconnected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext ctx, ChannelStateEvent e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ ctx.sendUpstream(e); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> Object </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ChannelHandlerContext arg0, Channel arg1, ChannelBuffer buffer, VoidEnum e)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Packet.read(buffer); } }</code> </pre><br>  The question is, how does this work?  Very simple, before calling the decode function, the decoder marks the current reading index, if there is not enough data in the buffer when reading from the buffer, an exception will be generated.  This will return the buffer to its initial position and the decode will be repeated when more data is received from the user.  In case of successful reading (returned is not null), the decoder will try to call the decode functions again, already on the data remaining in the buffer, if there is at least one more byte in it. <br><br>  Does it all work slowly if it throws an exception?  Slower than, for example, checking the amount of data in the buffer and evaluating whether it is enough to read a packet.  But it uses a cached exception, so it does not waste time filling out stacktrace and even creating a new exception object.  Read more about some other efficiency-enhancing features of ReplayingDecoder <a href="http://bruno.biasedbit.com/blag/2010/12/06/netty-tutorial-replaying-decoder/">here.</a> <br><br>  You can also experiment with FrameDecoder if, for example, you can pre-determine the size of a packet by its ID. <br><br><h4>  It seems to be all </h4><br>  The results were excellent.  First, the server no longer spills thousands of threads - 4 Netty + 4 threads of data processing do an excellent job with 250+ clients (testing continues).  Secondly, the load on the processor has become much smaller and has ceased to grow linearly on the number of connections.  Thirdly, the response time in some cases has become less. <br><br>  I hope someone it will be useful.  I tried to transfer as much important data as possible, I could overdo it.  After all, there aren't many examples?  Ask your answers and do not judge strictly - the first time I write on Habr. <br><br><h4>  Postscript: a few more useful things </h4><br>  Netty has a few more interesting features that deserve a special mention: <br><br>  First, stop the server: <br><pre> <code class="java hljs">ChannelFuture future = channel.close(); future.awaitUninterruptibly();</code> </pre><br>  Where <i>channel</i> is the channel that the bind function returned at the beginning.  <i>future.awaitUninterruptibly () will</i> wait until the channel closes and the code continues. <br><br>  Highlights: ChannelFuture.  When we send a packet to a channel, the function channel.write (packet), it returns ChannelFuture - this is a special object that tracks the status of the action taken.  Through it, you can check whether the action was performed. <br><br>  For example, we want to send a disconnect packet to the client and close the channel behind it.  If we do <br><pre> <code class="java hljs">channel.write(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Packet255KickDisconnect(<span class="hljs-string"><span class="hljs-string">"!"</span></span>)); channel.close();</code> </pre><br>  then with a probability of 99%, we will get a ChannelClosedException and the packet will not reach the client.  But you can do this: <br><pre> <code class="java hljs">ChannelFuture future = channel.write(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Packet255KickDisconnect(<span class="hljs-string"><span class="hljs-string">"!"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { future.await(<span class="hljs-number"><span class="hljs-number">10000</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    10 ,    } catch(InterruptedException e) {} channel.close();</span></span></code> </pre><br>  Everything will be great, except that it can block the flow of execution until the package is sent to the user.  Therefore, on ChannelFuture, you can hang a listener - an object that will be notified that an event has occurred and will perform some actions.  To close the connection, there is a ready listener <i>ChannelFutureListener.CLOSE</i> .  Example of use: <br><pre> <code class="java hljs">ChannelFuture future = channel.write(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Packet255KickDisconnect(<span class="hljs-string"><span class="hljs-string">"!"</span></span>)); furute.addListener(ChannelFutureListener.CLOSE);</code> </pre><br>  The effect is the same, no locks.  Understanding how to create your own listener is not difficult - there is only one function.  Open any ready class, here I will not give an example. <br><br><h5>  More important information </h5><br>  As it was correctly noted in the comments, you should be warned that in handlers (handler-ahs that hang on the pipeline) it is better not to use blocking operations or waiting.  Otherwise, you risk permanently losing the processing flow or simply slowing down the processing of other clients' events. <br><br>  Also in the handler, in no case can you ‚Äúwait for the future‚Äù, i.e.  perform .await () or .awaitUninterruptibly () on any ChannelFuture.  First, you will fail, they cannot be called from handlers - the system will not allow you to do such nonsense and will generate an exception.  Secondly, if this were not, your stream could again die leaving other customers without service. <br><br>  In general, all actions performed in ChannelHandlers should be as simple and non-blocking as possible.  In no case do not process the data directly in them - put the packets in a queue and process them in another stream. </div><p>Source: <a href="https://habr.com/ru/post/136456/">https://habr.com/ru/post/136456/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../136450/index.html">Dynamic password</a></li>
<li><a href="../136451/index.html">Hello to readers Habra</a></li>
<li><a href="../136453/index.html">Cut the Rope to HTML5</a></li>
<li><a href="../136454/index.html">Sketch - 100 seconds about SONY</a></li>
<li><a href="../136455/index.html">How users see programmers, and programmers see users</a></li>
<li><a href="../136458/index.html">Lean in brief on the example of pizza delivery</a></li>
<li><a href="../136459/index.html">Application integration on Windows Phone with SkyDrive</a></li>
<li><a href="../136460/index.html">A simple Dropbox based blog service.</a></li>
<li><a href="../136461/index.html">Controller Hierarchy</a></li>
<li><a href="../136463/index.html">Application for drawing under the Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>