<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Masking the class under the Boost graph. Part 1: Do not touch the interface</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologue: Boost Concepts 
 Part 2: Completing the implementation of concept support 

 It took recently to alter the path finding algorithm for our ga...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Masking the class under the Boost graph. Part 1: Do not touch the interface</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/e6a/b7a/f80/e6ab7af80bd2bdba0d725529e3c5cc65.png" align="left"><br>  <a href="http://habrahabr.ru/post/210838/">Prologue: Boost Concepts</a> <br>  <a href="http://habrahabr.ru/post/212089/">Part 2: Completing the implementation of concept support</a> <br><br>  It took recently to alter the path finding algorithm for our game.  The past was completely samopisny - step aside, and everything is bad ... I wanted to take it ready from a good source.  It was then that I remembered that boost has functionality for working with graphs.  Unfortunately, the approach, ‚Äúfind a function, call - and everything will work‚Äù did not take place.  The emphasis in the library is placed on maximum flexibility of use, which negatively affected simplicity.  At the same time, nothing deadly is better than from scratch to do (and then correct).  There was no desire to communicate with other libraries either, while the boost in the project has been used for a long time ... <br><a name="habracut"></a><br>  Given - the class of the playing field with the following (significant for this article) interface <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameField</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: GameField(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">canPass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; };</code> </pre> <br>  The field is a regular grid of square cells.  You can go to the neighboring cells, both directly and diagonally.  The <b>GameField :: canPass method</b> allows <b>you</b> to check whether it is possible to pass into a given cell (that is, it exists and there is no barrier in it) 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      First of all, it was necessary to get acquainted with the concepts of boost - I wrote about them in the <a href="http://habrahabr.ru/post/210838/">last article</a> .  Without this, all the requirements of the library to the graphs would have to be met at random, read eternity.  I will not repeat, I will dwell only on a small addition to the previous article.  It introduced the following way to test the concept <br><br><pre> <code class="cpp hljs">BOOST_CONCEPT_ASSERT((SomeFuncAppropriate&lt;SomeClass&gt;));</code> </pre><br>  I also complained that double brackets of the eye are cutting.  It turns out that they cut not only me, and boost offers a more familiar option. <br><br><pre> <code class="cpp hljs">boost::function_requires&lt;SomeFuncAppropriate&lt;SomeClass&gt; &gt;();</code> </pre><br>  This is the form I will use in the future. <br><br>  So.  There is an initial class which needs to be disguised under the graph in order for boost to accept it.  At the same time, the game field class itself (GameField) would not be desirable to change - here I present a simplified version of it, in fact, the interface of the class is already rather big, and changing it for the sake of a task not related to the direct functionality is impractical.  To find the path we will use the algorithm <a href="http://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B8%25D1%2582%25D0%25BC_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_A*">A * (AStar)</a> .  The <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/astar_search.html">documentation</a> states that the function boost :: astar_search requires two concepts from the graph: <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/VertexListGraph.html">Vertex List Graph</a> and <a href="http://www.boost.org/doc/libs/1_55_0/libs/graph/doc/IncidenceGraph.html">Incidence Graph</a> . <br><br><ul><li>  <b>VertexListGraph</b> suggests the possibility of effectively traversing all the vertices of the graph.  To do this, you will need to provide a means of determining the number of vertices and their search. </li><li>  <b>IncidenceGraph</b> must have an interface for iterating over all outgoing edges from a vertex.  Also, for graphs of this type, it should be possible to obtain initial and final vertices for a given edge. </li></ul><br>  In addition, graph concepts require the definition of a number of special types, based on which boost will be able to manipulate our class.  Let us dwell on them in more detail. <br><br>  <b>vertex_descriptor</b> defines the type of vertex.  In the GameField class, a vertex is defined by two cell coordinates.  The first thought is to repeat this definition with the help of a structure or a pair of values ‚Äã‚Äã(std :: pair).  However, depending on the type of graph, the <b>vertex_descriptor</b> must satisfy different concepts, that is, you will have to implement operators, constructors, etc.  Not to say that it is very difficult, but it is easier to think and understand that the two coordinates of the peak are simply a feature of the realization of our playing field.  In itself, the representation of the graph does not benefit from this (in our case).  So it was decided that in the graph model the vertices would be simply numbered ((0, 0) -&gt; 0, (0, 1) -&gt; 1, and so on).  This will allow using the standard <b>int</b> as the vertex type, which already supports all the necessary functionality.  Of course, you have to implement two functions - to translate the index of the vertex in the coordinates of the graph <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; getCoordinates(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Vertex position, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GameField&amp; graph) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_pair(position % graph.getWidth(), position / graph.getWidth()); }</code> </pre><br>  and back <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vertex </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> GameField&amp; graph)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y * graph.getWidth(); }</code> </pre><br>  Where the Vertex type comes from will be explained below. <br><br>  <b>edge_descriptor</b> is an edge type.  The edge is two vertices, and write: std :: pair &lt;vertex_descriptor, vertex_descriptor&gt; <br><br>  <b>directed_category</b> - must match one of the special tag types (in fact, these are structures without data and methods) that will determine whether the graph is directed.  In our case, it is not; therefore, we will use the value of boost :: undirected_tag <br><br>  <b>edge_parallel_category</b> Another tag type that determines whether parallel edges are allowed in our graph (when there can be more than one edge between two vertices).  Not allowed - use boost :: disallow_parallel_edge_tag <br><br>  <b>traversal_category</b> Also tag.  Defines ways to bypass the graph.  Everything is a little more complicated here.  For VertexListGraph, this should be boost :: vertex_list_graph_tag, and for IncidenceGraph, respectively, boost :: incidence_graph_tag.  This is solved by creating a new tag type that would inherit both traversal options. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">game_field_traversal_catetory</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::vertex_list_graph_tag, <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> boost::incidence_graph_tag { };</code> </pre><br>  <b>vertex_iterator</b> Iterator for traversing vertices.  Its implementation will be considered in the next part of the article. <br><br>  <b>out_edge_iterator An</b> iterator for traversing outgoing edges from a vertex will also be implemented later. <br><br>  <b>degree_size_type</b> Type in which the degree of the vertex (the number of outgoing edges) is expressed.  Integer. <br><br>  <b>vertices_size_type A</b> type in which the number of graph vertices is expressed.  Also take for integer. <br><br>  I‚Äôll dwell on tag types (this is called <a href="http://www.boost.org/community/generic_programming.html">tag dispatching</a> correctly).  They are used to overload functions to take advantage of a particular feature of the model.  For example, by defining the tag boost :: undirected_tag, we inform the library that the edges of the graph are not directed.  As a result, it will use functions that do not require separate assignment of outgoing and incoming edges. <br><br>  Now you need to match the types of the playing field.  The first binding option is to place additional definitions directly in the class. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">GameField</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertex_descriptor; ...</code> </pre><br>  However, I want to leave the GameField interface unchanged.  Fortunately, boost provides this opportunity.  All necessary types are retrieved by the library not from the class of the graph directly, that is, not so <br><br><pre> <code class="cpp hljs">GameField::vertex_descriptor</code> </pre><br>  Instead, use the special template <b>boost :: graph_traits</b> <br><br><pre> <code class="cpp hljs">boost::graph_traits&lt;GameField&gt;::vertex_iterator</code> </pre><br>  By default, it simply gets the appropriate type from the parameter class, i.e.  does the following <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Graph&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">graph_traits</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Graph::vertex_descriptor vertex_descriptor; ...</code> </pre><br>  You can write your own graph_traits specialization for the GameField class, which will work with it as we like, i.e.  Do not try to look for the necessary types in the playing field.  Above, the choice of types was described by words; now we consider the final implementation.  Do not forget to put it in the namespace boost. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> boost { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">graph_traits</span></span></span><span class="hljs-class">&lt;GameField&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertex_descriptor; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair &lt;vertex_descriptor, vertex_descriptor&gt; edge_descriptor; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::undirected_tag directed_category; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::disallow_parallel_edge_tag edge_parallel_category; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> game_field_traversal_catetory traversal_category; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> VertexIteratorImpl vertex_iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> OutEdgeIteratorImpl out_edge_iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> degree_size_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vertices_size_type; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> in_edge_iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> edge_iterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> edges_size_type; }; }</code> </pre><br>  Please note that the structure contains several types that were not previously mentioned: in_edge_iterator, edge_iterator, edges_size_type.  They are not needed to implement the concepts of VertexListGraph and IncidenceGraph, respectively, they can not specify (make <b>void</b> ). <br><br>  In further work, it is advisable to refer to types in graph_traits (i.e., use vertex_descriptor instead of int, if we are talking about a vertex), so that you can leave yourself the opportunity to change if necessary in one place.  Since the construction of the type <b>boost :: graph_traits &lt;GameField&gt; :: vertex_descriptor is too</b> heavy for writing and reading, we will introduce simple type names that we will use in the future <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::graph_traits&lt;GameField&gt;::vertex_descriptor Vertex; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::graph_traits&lt;GameField&gt;::edge_descriptor Edge; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::graph_traits&lt;GameField&gt;::vertex_iterator VertexIterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::graph_traits&lt;GameField&gt;::out_edge_iterator OutEdgeIterator; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::graph_traits&lt;GameField&gt;::degree_size_type DegreeSizeType; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> boost::graph_traits&lt;GameField&gt;::vertices_size_type VerticesSizeType;</code> </pre><br>  All the necessary types are defined.  In <b>graph_traits &lt;GameField&gt;</b> , <b>VertexIteratorImpl</b> and <b>OutEdgeIteratorImpl</b> were used - we will consider the implementation of these iterators in the <a href="http://habrahabr.ru/post/212089/">next part of the article</a> .  Also, the necessary functions for working with graphs will be implemented. </div><p>Source: <a href="https://habr.com/ru/post/211558/">https://habr.com/ru/post/211558/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../211540/index.html">CarPC Functionality</a></li>
<li><a href="../211542/index.html">Developers who want to increase their value in the labor market</a></li>
<li><a href="../211550/index.html">April 18: world day of launching balloons into the stratosphere</a></li>
<li><a href="../211554/index.html">Steve Jobs wanted to put OS X on Sony Vaio</a></li>
<li><a href="../211556/index.html">Interface Digest, December 2013-January 2014</a></li>
<li><a href="../211560/index.html">SyncNet: BitTorrent Sync based decentralized peer-to-peer browser</a></li>
<li><a href="../211564/index.html">British intelligence used DDoS attacks against Anonymous</a></li>
<li><a href="../211566/index.html">Google will show ads on competitors in search results: EU antitrust investigation results</a></li>
<li><a href="../211568/index.html">Freedom from habits. Myth or fiction?</a></li>
<li><a href="../211570/index.html">IBM improves graphene transistors</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>