<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The dangers of designers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, Habr! I present to you the translation of the article "Perils of Constructors" by Aleksey Kladov. 


 One of my favorite Rust blog posts is Thi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The dangers of designers</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello, Habr!  I present to you the translation of the article "Perils of Constructors" by Aleksey Kladov. </p><br><p>  One of my favorite Rust blog posts is <a href="https://graydon2.dreamwidth.org/218040.html">Things Rust Shipped Without by Graydon Hoare</a> .  For me, the lack of any feature in the language that can shoot in the leg is usually more important than expressiveness.  In this slightly philosophical essay, I want to talk about my particularly favorite feature missing from Rust - about constructors. </p><br><h1 id="chto-takoe-konstruktor">  What is a constructor? </h1><br><p>  Constructors are commonly used in OO languages.  The task of the constructor is to fully initialize the object before the rest of the world sees it.  At first glance, this seems like a really good idea: </p><br><ol><li>  You <strong>set the invariants</strong> in the constructor. </li><li>  Each method takes care of the <strong>conservation of</strong> invariants. </li><li>  Together, these two properties mean that you can think of objects as invariants, and not as specific internal states. </li></ol><br><p>  The constructor here plays the role of an induction base, being the only way to create a new object. </p><br><p>  Unfortunately, there is a hole in these arguments: the designer himself observes the object in an unfinished state, which creates many problems. <a name="habracut"></a></p><br><h1 id="znachenie-this">  This value </h1><br><p>  When the constructor initializes the object, it starts with some empty state.  But how do you define this empty state for an arbitrary object? </p><br><p>  The easiest way to do this is to set all fields to their default values: false for bool, 0 for numbers, null for all links.  But this approach requires all types to have default values, and introduces the infamous null into the language.  This is the path that Java has taken: at the beginning of the creation of the object, all fields are 0 or null. </p><br><p>  With this approach, it will be very difficult to get rid of null afterwards.  A good example to learn is Kotlin.  Kotlin uses non-nullable types by default, but it is forced to work with pre-existing JVM semantics.  The design of the language well hides this fact and is well applicable in practice, but is <strong>untenable</strong> .  In other words, using constructors, it is possible to bypass null checks in Kotlin. </p><br><p>  The main feature of Kotlin is the encouragement of creating so-called "primary constructors" that <strong>simultaneously</strong> declare a field and assign a value to it before any custom code is executed: </p><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String ) { ... }</code> </pre> <br><p>  Another option: if the field is not declared in the constructor, the programmer should immediately initialize it: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String = <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$firstName</span></span></span><span class="hljs-string"> </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$lastName</span></span></span><span class="hljs-string">"</span></span> }</code> </pre> <br><p>  Attempting to use a field before initialization is statically denied: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> firstName: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> lastName: String) { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> fullName: String <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { println(fullName) <span class="hljs-comment"><span class="hljs-comment">// :     fullName = "$firstName $lastName" } }</span></span></code> </pre> <br><p>  But with a bit of creativity, anyone can get around these checks.  For example, a method call is suitable for this: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { observeNull() x = <span class="hljs-number"><span class="hljs-number">92</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observeNull</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null } fun main() { A() }</span></span></code> </pre> <br><p>  Capturing this with a lambda (which is created in Kotlin as follows: {args -&gt; body}) is also suitable: </p><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = { y }() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> y: Any = x } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { println(B().x) <span class="hljs-comment"><span class="hljs-comment">//  null }</span></span></code> </pre> <br><p>  Examples like these seem unrealistic in reality (and it is), but I found similar errors in real code (Kolmogorov's probability rule 0-1 in software development: in a fairly large database, any piece of code is almost guaranteed to exist, at least if not forbidden statically by the compiler; in this case, it almost certainly does not exist). </p><br><p>  The reason Kotlin may exist with this failure is the same as with covariant arrays in Java: checks still occur in runtime.  In the end, I would not want to complicate the Kotlin type system in order to make the above cases incorrect at the compilation stage: considering the existing limitations (JVM semantics), the price / benefit ratio of validations in runtime is much better than that of static ones. </p><br><p>  But what if the language does not have a reasonable default value for each type?  For example, in C ++, where user-defined types are not necessarily references, you cannot just assign null to each field and say that this will work!  Instead, C ++ uses special syntax to set initial values ‚Äã‚Äãfor fields: initialization lists: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;utility&gt; class person { person(std::string first_name, std::string last_name) : first_name(std::move(first_name)) , last_name(std::move(last_name)) {} std::string first_name; std::string last_name; };</span></span></span></span></code> </pre> <br><p>  Since this is a special syntax, the rest of the language does not work flawlessly.  For example, it is difficult to put arbitrary operations into initialization lists, since C ++ is not an expression-oriented language (which is normal in itself).  To work with exceptions that occur in initialization lists, you must use one more <a href="https://en.cppreference.com/w/cpp/language/function-try-block">obscure feature of the language</a> . </p><br><h1 id="vyzov-metodov-iz-konstruktora">  Calling methods from the constructor </h1><br><p>  As the examples from Kotlin hint, everything shatters into chips as soon as we try to call a method from the constructor.  Basically, methods expect that the object accessible through this is already fully constructed and correct (consistent with invariants).  But in Kotlin or Java, nothing prevents you from invoking methods from the constructor, and so we can accidentally operate on a semi-constructed object.  The designer promises to establish invariants, but at the same time this is the easiest place for their possible violation. </p><br><p>  Particularly strange things happen when the base class constructor calls a method overridden in a derived class: </p><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { initialize() } <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span><span class="hljs-class">: </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Base</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> x: Any = <span class="hljs-number"><span class="hljs-number">92</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> = println(x) <span class="hljs-comment"><span class="hljs-comment">//  null! }</span></span></code> </pre> <br><p>  Just think about it: the code of an arbitrary class is executed <strong>before</strong> calling its constructor!  Similar C ++ code will lead to even more interesting results.  Instead of calling the function of the derived class, the function of the base class will be called.  This makes little sense because the derived class has not yet been initialized (remember, we cannot just say that all fields are null).  However, if the function in the base class is pure virtual, its call will lead to UB. </p><br><h1 id="signatura-konstruktora">  Designer Signature </h1><br><p>  Violation of invariants is not the only problem for designers.  They have a signature with a fixed name (empty) and return type (the class itself).  This makes design overloads difficult for people to understand. </p><br><blockquote>  Backfill question: what does std :: vector &lt;int&gt; xs (92, 2) correspond to? <br><br>  a.  Vector of two lengths 92 <br><br>  b.  [92, 92] 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      c.  [92, 2] </blockquote><p>  Problems with the return value arise, as a rule, when it is impossible to create an object.  You cannot just return Result &lt;MyClass, io :: Error&gt; or null from the constructor! </p><br><p>  This is often used as an argument that it is difficult to use C ++ without exceptions, and that using constructors also forces you to use exceptions.  However, I do not think this argument is correct: factory methods solve both of these problems because they can have arbitrary names and return arbitrary types.  I believe that the following pattern can sometimes be useful in OO languages: </p><br><ul><li><p>  Create one <strong>private</strong> constructor that takes the values ‚Äã‚Äãof all fields as arguments and simply assigns them.  Thus, such a constructor would work as a structure literal in Rust.  It can also check for any invariants, but it should not do anything else with arguments or fields. </p><br></li><li><p>  public factory methods are provided for the public API with appropriate names and return types. </p><br></li></ul><br><p>  A similar problem with constructors is that they are specific and therefore cannot be generalized.  In C ++, ‚Äúthere is a default constructor‚Äù or ‚Äúthere is a copy constructor‚Äù cannot be expressed more simply than ‚Äúcertain <em>syntax</em> works‚Äù.  Compare this to Rust, where these concepts have suitable signatures: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Default</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">default</span></span></span></span>() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Clone</span></span></span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Self</span></span>; }</code> </pre> <br><h1 id="zhizn-bez-konstruktorov">  Life without designers </h1><br><p>  Rust has only one way to create a structure: to provide values ‚Äã‚Äãfor all fields.  Factory functions, such as the generally accepted new, play the role of constructors, but, most importantly, they do not allow you to call any methods until you have at least a more or less correct instance of the structure. </p><br><p>  The disadvantage of this approach is that any code can create a structure, so there is no single place, such as a constructor, to maintain invariants.  In practice, this is easily solved by privacy: if the fields of a structure are private, then this structure can only be created in the same module.  Within <em>one</em> module, it is not difficult to adhere to the agreement "all methods of creating a structure must use the new method".  You can even imagine a language extension that allows you to mark some functions with the # [constructor] attribute, so that the syntax of the structure literal is available only in marked functions.  But, again, additional linguistic mechanisms seem redundant to me: following <strong>local</strong> conventions requires little effort. </p><br><blockquote>  Personally, I believe that this compromise looks exactly the same for contract programming in general.  Contracts like "not null" or "positive value" are best encoded in types.  For complex invariants, just writing assert! (Self.validate ()) in each method is not so difficult.  Between these two patterns there is little room for # [pre] and # [post] conditions implemented at the language level or based on macros. </blockquote><br><h1 id="a-chto-naschet-swift">  What about Swift? </h1><br><p>  Swift is another interesting language that is worth a look at the design mechanisms.  Like Kotlin, Swift is a null safe language.  Unlike Kotlin, Swift's null checks are stronger, so the language uses interesting tricks to mitigate the damage caused by the constructors. </p><br><p>  <em>First</em> , Swift uses named arguments, and it helps a little with "all constructors have the same name."  In particular, two constructors with the same types of parameters are not a problem: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromFahrenheit: <span class="hljs-number"><span class="hljs-number">212.0</span></span>) <span class="hljs-type"><span class="hljs-type">Celsius</span></span>(fromKelvin: <span class="hljs-number"><span class="hljs-number">273.15</span></span>)</code> </pre> <br><p>  <em>Secondly</em> , to solve the problem "the constructor calls the virtual method of the object class that has not yet been fully created" Swift uses a well-thought-out two-phase initialization protocol.  Although there is no special syntax for initialization lists, the compiler statically checks that the body of the constructor has the correct and safe form.  For example, calling methods is possible only after all the fields of the class and its descendants are initialized. </p><br><p>  <em>Thirdly</em> , at the language level, there is support for designers, the call of which may fail.  The constructor can be designated as nullable, which makes the result of calling the class an option.  The constructor may also have a throws modifier, which works better with the semantics of two-phase initialization in Swift than with the syntax of initialization lists in C ++. </p><br><p>  Swift manages to close all the holes I complained about in the constructors.  This, however, comes at a price: the <a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html">initialization chapter is</a> one of the largest in the Swift book. </p><br><h1 id="kogda-konstruktory-deystvitelno-neobhodimy">  When constructors are really needed </h1><br><p>  Against all odds, I can come up with at least two reasons why constructors cannot be replaced with structure literals, such as in Rust. </p><br><p>  <em>First</em> , inheritance to one degree or another forces the language to have constructors.  You can imagine an extension of the syntax of structures with support for base classes: </p><br><pre> <code class="rust hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span></span> { ... } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Derived</span></span></span></span>: Base { foo: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Derived { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">new</span></span></span></span>() -&gt; Derived { Derived { Base::new().., foo: <span class="hljs-number"><span class="hljs-number">92</span></span>, } } }</code> </pre> <br><p>  But this will not work in a typical object layout of an OO language with simple inheritance!  Typically, an object begins with a title followed by class fields, from the base to the most derived.  Thus, the prefix of an object of a derived class is a valid object of a base class.  However, for such a layout to work, the designer needs to allocate memory for the entire object at a time.  It cannot just allocate memory only for the base class, and then attach derived fields.  But such a allocation of memory in pieces is necessary if we want to use the syntax to create a structure where we could specify a value for the base class. </p><br><p>  <em>Secondly</em> , unlike the structure literal syntax, constructors have an ABI that works well with placing object subobjects in memory (placement-friendly ABI).  The constructor works with a pointer to this, which points to the area of ‚Äã‚Äãmemory that the new object should occupy.  Most importantly, a constructor can easily pass a pointer to subobject constructors, thereby allowing the creation of complex value trees "in place."  In contrast, in Rust, constructing structures semantically includes quite a few copies, and here we hope for the grace of the optimizer.  It is no coincidence that Rust does not yet have an accepted working proposal regarding the placement of subobjects in memory! </p><br><p>  Upd 1: fixed a typo.  Replaced the "write literal" with "structure literal". </p></div><p>Source: <a href="https://habr.com/ru/post/460831/">https://habr.com/ru/post/460831/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460819/index.html">WorldSkills: Review from the participant of the Olympiad</a></li>
<li><a href="../460821/index.html">The digest of interesting materials for the mobile developer # 307 (July 15 - 21)</a></li>
<li><a href="../460823/index.html">Digital events in Moscow from July 22 to July 28</a></li>
<li><a href="../460825/index.html">Introduction to Screen Capture API - Scan QR codes in a browser</a></li>
<li><a href="../460827/index.html">PGP problem</a></li>
<li><a href="../460833/index.html">Physics and Economics. Gnoseological difference and its manifestation in IT</a></li>
<li><a href="../460837/index.html">Beginner Podcast Handbook</a></li>
<li><a href="../460839/index.html">Releasing Predator - Precompiled Data Repositories</a></li>
<li><a href="../46084/index.html">Zend Framework Tuning + Doctrine</a></li>
<li><a href="../460843/index.html">Introducing the New 3CX Call Flow Designer and 3CX CRM Template Generator</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>