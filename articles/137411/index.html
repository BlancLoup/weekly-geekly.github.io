<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Without knowing the ford, do not go into the water. Part two</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This time I want to talk about the printf function. Everyone has heard about program vulnerabilities, and that functions like printf are outlawed. But...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Without knowing the ford, do not go into the water. Part two</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/03d/9f4/f39/03d9f4f39df2cb34ea8bb815cf5cf8bc.png" alt="Horrible printf"><br>  This time I want to talk about the printf function.  Everyone has heard about program vulnerabilities, and that functions like printf are outlawed.  But one thing to know that it is better not to use these functions.  But quite another is to understand why.  In this article I will describe two classic vulnerabilities of printf related programs.  After that, you will not become a hacker, but perhaps take a fresh look at your code.  Suddenly, you are implementing similar vulnerabilities without even knowing it. <br><br>  <b>STOP.</b>  Wait reader, do not pass by.  I know you saw the word printf.  And I am sure that the author of the article will now tell a banal story that the function does not control the types of arguments passed.  Not!  The article will not be about it, but about vulnerabilities.  Come to read. <br><a name="habracut"></a><br>  <b>The previous note is here: <a href="http://habrahabr.ru/blogs/cpp/137039/">Part One</a> .</b> <br><br><h2>  Introduction </h2><br>  Let's take a look at this line: <br><pre> printf (name); </pre><br>  It seems simple and harmless.  Meanwhile, it hides at least two ways to attack the program. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We start the article with a demo where this line is.  The code may seem strange to you.  The way it is.  It turned out that it was not so easy to write a program in order to attack it later.  The point is the optimization that the compiler produces.  It turns out that if you write too simple a program, the compiler creates such code that there‚Äôs nothing to break.  It uses registers, not a stack for storing data, embeds functions, and the like.  You can write code with unnecessary actions and cycles, so that the compiler does not have enough free registers, and he began to push data onto the stack.  Unfortunately, the example is too big and confusing.  About all this you can write a separate detective story, but we will not. <br><br>  The presented example is a compromise between complexity and the need to prevent the compiler from ‚Äúcollapsing into nothing‚Äù in too simple code.  I admit, I helped myself a little bit anyway.  I disabled some types of optimization used in Visual Studio 2010. First, the / GL (Whole Program Optimization) key was disabled.  Secondly, I used the attribute __declspec (noinline). <br><br>  I apologize for such a long introduction.  I wanted to explain the clumsiness of the program code.  And immediately stop the discussion on the topic that this code can be written better.  I know what you can.  But it‚Äôs impossible to make the code both short at the same time, and so that you can show the vulnerability. <br><br><h2>  Demo </h2><br>  The full code and project for Visual Studio 2010 is available <a href="">here</a> . <br><pre>  const size_t MAX_NAME_LEN = 60;
 enum ErrorStatus {
   E_ToShortName, E_ToShortPass, E_BigName, E_OK
 };<font></font>
<font></font>
 void PrintNormalizedName (const char * raw_name)
 {
   char name [MAX_NAME_LEN + 1];
   strcpy (name, raw_name);<font></font>
<font></font>
   for (size_t i = 0; name [i]! = '\ 0'; ++ i)
     name [i] = tolower (name [i]);
   name [0] = toupper (name [0]);<font></font>
<font></font>
   printf (name);
 }<font></font>
<font></font>
 ErrorStatus IsCorrectPassword (
   const char * universalPassword,
   BOOL &amp; retIsOkPass)
 {
   string name, password;
   printf ("Name:");  cin &gt;&gt; name;
   printf ("Password:");  cin &gt;&gt; password;
   if (name.length () &lt;1) return E_ToShortName;
   if (name.length ()&gt; MAX_NAME_LEN) return E_BigName;
   if (password.length () &lt;1) return E_ToShortPass;<font></font>
<font></font>
   retIsOkPass = 
     universalPassword! = NULL &amp;&amp;
     strcmp (password.c_str (), universalPassword) == 0;
   if (! retIsOkPass)
     retIsOkPass = name [0] == password [0];<font></font>
<font></font>
   printf ("Hello,");
   PrintNormalizedName (name.c_str ());<font></font>
<font></font>
   return E_OK;
 }<font></font>
<font></font>
 int _tmain (int, char * [])
 {
   _set_printf_count_output (1);
   char universal [] = "_Universal_Pass_!";
   BOOL isOkPassword = FALSE;
   ErrorStatus status =
     IsCorrectPassword (universal, isOkPassword);
   if (status == E_OK &amp;&amp; isOkPassword)
     printf ("\ nPassword: OK \ n");
   else
     printf ("\ nPassword: ERROR \ n");
   return 0;
 } </pre><br>  The _tmain () function calls the IsCorrectPassword () function.  If the password is correct or if it coincides with the magic word "_Universal_Pass_!", Then the program displays the string "Password: OK".  The purpose of the attacks will be to ensure that the program displays exactly this line. <br><br>  The IsCorrectPassword () function prompts the user for a username and password.  The password is considered correct if it coincides with the magic word passed to the function.  It is also correct if the first letter of the password matches the first letter of the name. <br><br>  Regardless of whether the correct password is entered or not, the program welcomes the user.  To do this, call the PrintNormalizedName () function. <br><br>  The PrintNormalizedName () function is all the fun.  It is there that the ‚Äúprintf (name);‚Äù is discussed.  Think about how you can trick the program with this line.  If you know how, then you can not read further. <br><br>  What does the PrintNormalizedName () function do?  She prints the name, making the first letter capitalized, and the rest small.  For example, if you enter the name "andREy2008", it will print "Andrey2008". <br><br><h2>  First attack </h2><br>  Suppose we do not know the correct password.  But we know that somewhere there is a certain magic password.  Let's try to search for it using printf ().  If the address of this password is somewhere on the stack, then we have a chance of success.  Any idea how to see this password on the screen? <br><br>  I give a hint.  The printf () function refers to a family of functions with a variable number of arguments.  Such functions work as follows.  An arbitrary amount of data is written to the stack.  The printf () function does not know how much data is written to the stack and what type they have.  It is guided solely by the format string.  If it says "% d% s", it means that one int type and one pointer should be retrieved from the stack.  Since the printf () function does not know how many arguments were passed to it, it can look deeper into the stack and print data that has nothing to do with it.  Typically, this leads to <a href="http://www.viva64.com/ru/t/0063/">access violation</a> or print garbage.  However, this garbage can be used. <br><br>  Consider what the stack might look like when we call the printf () function: <br><img src="https://habrastorage.org/getpro/habr/post_images/2fb/073/650/2fb073650815293411f063ed71ebe8e4.png" alt="Figure 1. Schematic data layout on the stack."><br>  Figure 1. Schematic data layout on the stack. <br><br>  The call to the ‚Äúprintf (name);‚Äù function has only one argument, which is a format string.  This means that if we enter ‚Äú% d‚Äù instead of the name, we will print the data that is on the stack before the return address to the PrintNormalizedName () function.  Let's try: <br><br>  Name:% d <br>  Password: 1 <br>  Hello, 37 <br>  Password: ERROR <br><br>  While this action is little meaningful.  At a minimum, at first we have to print the return addresses and the entire contents of the buffer char name [MAX_NAME_LEN + 1]; which is also located on the stack.  And only then, perhaps, we will get to something interesting. <br><br>  If the attacker does not have the ability to disassemble or debug the program, then it is difficult for him to understand whether he will find something on the stack or not.  However, it can act as follows. <br><br>  At the beginning, enter: "% s".  Then enter "% x% s".  Then enter "% x% x% s" and so on.  This way, the hacker will iterate through the data on the stack, and try to print them as a string.  Here he is helped by the fact that all the data in the stack is aligned, at least on the border of 4 bytes. <br><br>  To be honest, by acting in this way, we will fail.  We will exceed the limit of 60 characters, without printing anything useful.  We will come to the aid of "% f", which is designed to print double values.  Therefore, with its help we will be able to move along the stack immediately to 8 bytes. <br><br>  And here it is - the long-awaited line: <br><br>  % f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% x (% s) <br><br>  Result: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/079/989/c8d/079989c8d4a0908e3316ab15723906a5.png" alt="Figure 2. Password printout. Click on the picture to enlarge."></a> <br>  Figure 2. Password printout.  Click on the picture to enlarge. <br><br>  Let's try this line as a magic password: <br><br>  Name: Aaa <br>  Password: _Universal_Pass_! <br>  Hello, Aaa <br>  Password: OK <br><br>  Hooray!  We were able to find and display private data to which the program did not plan to give us access.  Moreover, note that for this there is no need to have access to the binary code of the program.  Enough diligence and perseverance. <br><br><h2>  Conclusions on the first attack </h2><br>  This method of obtaining private data should be considered more broadly.  When developing programs containing functions with a variable number of arguments, consider whether there are situations when data can flow through them to the outside world.  This can be a log file, a packet transmitted over the network, and so on. <br><br>  In the case considered, the attack became possible due to the fact that the input to the printf () function is a string that can contain control commands.  To avoid this, it was enough to write this: <br><pre>  printf ("% s", name); </pre><br><br><h2>  Second attack </h2><br>  Do you know that the printf () function can modify memory?  Most likely, you read about it, but forgot.  This is the "% n" specifier.  It allows you to write to the specified address the number of characters that printf () has already printed. <br><br>  To be honest, an attack based on the specifier "% n" is purely historical.  Starting with Visual Studio 2005, the option to use "% n" is disabled by default.  To carry out this attack I had to explicitly allow this specifier.  Here is this magical effect: <br><pre>  _set_printf_count_output (1); </pre><br>  To make it clearer, I will give an example of using "% n": <br><pre>  int i;
 printf ("12345% n6789 \ n", &amp; i);
 printf ("i =% d \ n", i); </pre><br>  The output of the program: <br><br>  123456789 <br>  i = 5 <br><br>  We have already learned how to get to the required pointer that is in the stack.  And now we have a tool in our hands that allows us to modify the memory according to this pointer. <br><br>  Of course, it is inconvenient to use.  First, we can only write 4 bytes at once (the size of the int type).  If we need a large number, then the printf () function will first have to output a lot of characters.  To avoid this, the% 00u specifier can help.  The qualifier affects the value of the current number of bytes output.  More detail to delve into the subtleties will not. <br><br>  In our case, everything is easier.  It is enough for us to write in the isOkPassword variable any unequal value 0. The address of this variable is passed to the IsCorrectPassword () function, which means it is somewhere on the stack.  Do not be confused by the fact that the variable is transmitted as a link.  At a low level, the link is an ordinary pointer. <br><br>  Here is the line that allows us to modify the IsCorrectPassword variable: <br><br>  % f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% f% n <br><br>  The qualifier "% n" does not take into account the number of characters derived from specifiers such as "% f".  Therefore, we put one space before "% n" to write the value 1 to isOkPassword. <br><br>  We try: <br> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/db0/ad3/9f4/db0ad39f46c41cae1b3ecc6bf980159f.png" alt="Figure 3. Write to memory. Click on the picture to enlarge."></a> <br>  Figure 3. Write to memory.  Click on the picture to enlarge. <br><br>  Impressive?  But that's not all.  You can record almost any address.  If the output string is on the stack, then we can get to the desired characters and use them as an address. <br><br>  For example, we can write a string containing consecutive characters with the codes 'xF8', 'x32', 'x01', 'x7F'.  It turns out that the string has a hard-coded number, which is equivalent to the value 0x7F0132F8.  At the end we put the specifier "% n".  Using "% x" or other specifiers, we can get to the coded number 0x7F0132F8 and record the number of characters displayed at this address.  This method has limitations, but it is still very curious. <br><br><h2>  Conclusions on the second attack </h2><br>  We can say that the attack of the second kind is now hardly possible.  As you can see, support for the "% n" specifier in modern libraries is disabled by default.  However, you can create your own homemade mechanism, which will be predisposed to this type of vulnerability.  Be careful when the data entered from the outside, control what and where to write to memory. <br><br>  Specifically, in this case, the problem will not arise again, if you write this: <br><pre>  printf ("% s", name); </pre><br><br><h2>  General conclusions </h2><br>  Only two simple examples of vulnerability are considered here.  Of course, there are many more.  It does not attempt to describe or at least list them.  The article planned to show that even such a simple construct as printf (name) can be dangerous. <br><br>  This implies an important conclusion.  If you are not a security professional, then it is better to follow all the recommendations that are written about.  The essence of the recommendations is too thin to assess the whole range of threats on their own.  After all, you probably read that printf () is a dangerous function.  But I am sure that many of those reading this article first learned about the depth of the rabbit hole. <br><br>  If you are writing an application that could potentially serve as an object of attack, observe the maximum accuracy.  The fact that in your opinion is completely innocent code may contain a vulnerability.  If you do not see a dirty trick in the code, this does not mean that it does not exist. <br><br>  Follow all compiler recommendations for using updated versions of string functions.  This means using sprintf_s instead of sprintf and so on. <br><br>  Even better, discard the low-level work with strings altogether.  These functions are the heritage of the C language.  Now there is a std :: string.  There are safe ways to form strings, such as boost :: format or std :: stringstream. <br><br>  <b>PS</b> Someone, having read the conclusion, said - ‚Äúit was clear that way‚Äù.  But be honest.  Before reading this article, did you know and remember that printf () can write to memory?  But this is a big vulnerability.  At least, it was before.  Now there are others, no less insidious. </div><p>Source: <a href="https://habr.com/ru/post/137411/">https://habr.com/ru/post/137411/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../137405/index.html">Serialization of static objects in C #</a></li>
<li><a href="../137407/index.html">ECM-educational program, part 1: electronic document flow and electronic archive</a></li>
<li><a href="../137408/index.html">A couple of git tricks</a></li>
<li><a href="../137409/index.html">SAPER on the fields of CAD</a></li>
<li><a href="../137410/index.html">How do you usually unpack the archive through the context menu</a></li>
<li><a href="../137412/index.html">Creating animated tooltips with CSS3</a></li>
<li><a href="../137413/index.html">It is finished! Website iCloud "spoke" in Russian</a></li>
<li><a href="../137414/index.html">Integration of the physics engine Box2D into the UIKit application for iOS</a></li>
<li><a href="../137415/index.html">User Attributes in Python</a></li>
<li><a href="../137416/index.html">Anonymization and de-anonymization on the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>