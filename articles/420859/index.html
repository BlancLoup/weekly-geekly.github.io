<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>On the issue of virt and chains</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Algorithms + data structures = programs - Virt N. 
 ‚ÄúWe had a wonderful opportunity to conduct a small but extremely instructive tactical exercise‚Äù 
 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>On the issue of virt and chains</h1><div class="post__text post__text-html js-mediator-article"><h2>  Algorithms + data structures = programs - Virt N. </h2><br><img src="https://habrastorage.org/webt/00/wp/ch/00wpchad9zptu4pxyqszkymsin4.jpeg" align="left"><h3>  ‚ÄúWe had a wonderful opportunity to conduct a small but extremely instructive tactical exercise‚Äù </h3><br>  Despite the first epigraph to this post, I will allow myself to disagree with the author and try to show that in some cases the correct choice of data structure may be more significant than the correct choice of algorithms.  To illustrate such a seditious thesis, let us consider the simple but promising task of investigating the game ‚ÄúChain‚Äù. <br><a name="habracut"></a><br>  First, about the rules of the game - two players play, the starting position consists of H adjacent objects.  The next move is to remove any one or two adjacent objects (you can try to give a formal definition of "near location", but it is understandable at an intuitive level).  The player who wins away the last object wins - a direct game, or the one who has to lose (it is impossible to skip a move) to pick up the last object wins - an inverse game.  Since in this version of the rules, the direct game will simply be uninteresting (more on this later), they introduce an additional restriction - in the first move you can only delete one object. <br><br>  First of all, we will determine that the game is finite, because with each move the number of objects strictly decreases and the game ends when the number of objects, calculated as zero, is reached, so we can count on success in the study of this game.  Moreover, it is obvious that the game can not last more than H moves, remember this fact. <br><br>  The study of the game consists in determining whether for a particular initial number of objects the player making the first move wins (since this is a zero-sum game, otherwise it is a losing player) with optimal play of both sides and at what minimum number of moves does the gain reach (or What is the maximum number of moves the loss moves away). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      For some of H, the answer is obvious - with one object, the first one wins in one move in a direct game and loses in one move in an inverse one (P1 = 1, I1 = -1).  With two objects, the first player loses in two moves in a direct game and wins in two moves in an inverse (2 = -2, 2 = 2), which may give rise to a hypothesis about the simplicity of the evaluation of this game, which is confirmed by the case of three objects (3 = 3, I3 = -3).  Fortunately (otherwise this post would not have been published) a game with four objects changes the picture somewhat (A4 = -4, but I4 = -3), so research of the game is really required. <br><br>  For some of the H and for a certain type of game there are heuristic algorithms that give a guaranteed win.  For example, for a direct game with an odd initial H, it is guaranteed to win, if you remove the central object by the first move and then repeat the opponent's moves using the central place as the axis of symmetry, then we are guaranteed to take the last object and win.  The same strategy would have worked with an even number of objects, if not for the restrictions on the first move, which makes the game not so trivial.  Generally speaking, the use of symmetric strategies is quite a frequent occurrence in a counting game, but not a panacea, because, for example, in our inverse game this strategy succumbs.  It should be noted that heuristics provide an algorithm for winning, but do not give an accurate assessment of the position, since there may be strategies leading to winning faster (for this particular game, it is). <br><br>  How we can evaluate the game - exactly as I received previous estimates for 1-4 objects - the method is called brute force from top to bottom - we must consider the complete game tree, that is, all possible moves for both sides and evaluate each position, including the original, according to certain rules.  It should be noted that the existence of successful heuristics does not guarantee us an accurate assessment, since it answers only the first half of the question - who wins, but does not give the minimum required number of moves. <br><br>  So, we have to build a complete tree of the game, but before we start building, we need to create a model of the object being studied, in our case, the game. <br><br>  Why I am focusing attention at this stage - because we cannot explore the object in its material embodiment.  No, theoretically it is possible (‚Äúin the world there is very little that is impossible theoretically‚Äù) and I can imagine a picture where a very large number of robots play a lot of games in the real world, but the material costs for such a solution to the game evaluation problem are reasonably representable values, so we are forced to embark on the path of modeling real objects with their software counterparts.  And here it is very important to go along a thin line that combines a sufficient level of model adequacy and the necessary simplification. <br><br>  But first, a bit of mathematics to assess the complexity of the task - we need to go through all possible moves in the game (attention is not all possible positions, this is a topic of another method, namely, moves) and we would like to evaluate the required amount of resources before starting work - to determine the order of the problem.  On the first move, we have the opportunity to remove any piece (I will continue to call objects) from the H available, on the next move - any of the remaining H-1 or two adjacent chips (there will be no more such pairs than H-2) that gives the total number of Hx variants (H-1 + H-2).  It is easy to see that after the third move we have Hx (H-1 + H-2) x (H-2 + H-3 + Œî) and so on. <br><br>  If we restrict ourselves in each bracket to only the first terms of the sum, we obtain an estimate of the total number of moves, like H !, which gives us an estimate in quadratures H ^ H. <br><br>  This is a very unpleasant result, which claims that we will have very big problems with significant H, so most likely head-in-front modeling will entail significant computational costs.  For example, for 16 chips in the initial position, we will have to consider approximately 16! = 10E13 moves, and if performing one move is 10E-9 seconds (quite an optimistic estimate), then the total time will be about 10E4 seconds or almost 3 hours, which is a bit too much , but acceptable, but for only 20 chips the expected settlement time will be 77 years, which is clearly unacceptable.  Factorial is growing very quickly and nothing can be done about it. <br><br>  Let us pay attention to the fact that the number of moves significantly exceeds the number of possible positions, which is only 2 ^ N, and it is obvious that for 16 chips we will fall into a separate position 10E (13-5) = 10E7 times, which is pretty commonplace for reboring tasks.  Remember this fact, it will be useful to us later. <br><br>  Nevertheless, let's start writing the program, for which we will determine the model.  To begin with, let's number the chips from 1 to H, then create an array with the number of elements H, and determine that the number 1 in the array element with the index n means the presence of the chip number n, and the number 0 - its absence in a specific position.  Such a model is adequate, simple, intuitive, and allows you to make effective operations of removing the chips, as well as determining the condition ‚Äúnear location‚Äù. <br><br>  Now that we have a model (data structure), we can proceed to stringing (owls on the globe) the algorithm on this model.  The algorithm of complete enumeration with return is simple in the block diagram and consists of two independent parts - the actual enumeration and evaluation of positions, for the beginning we will implement the first part.  Let's pay attention to the fact that this algorithm is not best implemented in the framework of the structural programming paradigm and would be somewhat more efficient if we allow ourselves to use the transition or code repetition, but without these deviations from the style, the implementation is not at all arty (cyclomatic complexity is quite acceptable) .  Since we have not yet introduced the assessment, but we would like to get the result from the program, for the time being we will simply deduce the positions under consideration and examine them with our eyes to assess the correctness of the implementation and make sure that the results are as expected. <br><br>  Now we will add a position estimate - of course, well-written code is self-documenting (although there are different opinions regarding this statement), but this part is better described with words.  The idea is that we give an unambiguous assessment of the final positions (in our case, it is unique and consists of zero chips), based on the rules of the game, and all other positions are given a preliminary neutral assessment, and then we begin to refine it by transferring the estimates up the tree .  The evaluation of the current position when moving backwards is changed by one from zero, then inverted and transferred to the previous position, where it is combined with the previous estimate according to the following rules: <br><br><ol><li>  the neutral score changes to a new one, </li><li>  positive score changes to less positive </li><li>  a negative score changes to a large negative or a positive one. </li></ol><br>  After we have completely gone through all the moves, the assessment of the initial position is final. <br><br>  We add estimates to our procedure for generating all positions and we can admire the results of the analysis, which we display in the form of a table, add another stroke counter and a time meter spent on the analysis.  I have a gcc compiler (in optimization mode -O2) on a machine with a processor that has turned out a table that fully confirms our initial assumptions about the factorial order of the complexity of the problem.  From the same table, we see that I stopped expecting results with H exceeding 11, since the computation time became unacceptable (for me, it is possible, you are ready to wait half an hour) and our assumption about the progress and the nanosecond does not correspond to reality (average time consideration of the position is 100 ns).  The question arises - what should we do if we want to have an estimate for more than 11 chips in the initial position. <br><br>  We could take the path of small optimizations, play with transitions and flags, go into assembly inserts, apply tricky vector operations from the system of our processor‚Äôs commands, and we can win several times in this way, by an order of magnitude - maybe two orders of magnitude - highly unlikely, but we need a gain of many orders of magnitude, since the order (and even more) we will eat an increase of N per unit over 10. By the way, if you just turn on the optimization of the compiler, then it will do something for us and the execution time reduces  I have 4 times - not bad at all and in line with our expectations. <br><br>  Therefore, we must first try to improve the applied algorithms, and the first of these (and the main) improvement is the brute force method with clipping or the ‚Äúalpha-beta procedure‚Äù.  Its main idea looks quite sensible and consists in the fact that if we evaluate a certain position as a winning one, we stop improving the estimate for this one and go back through the tree.  Such an approach can greatly increase the speed of the algorithm, especially if we examine the successful moves (leading to the gain) in the first place.  But it can also increase the time, because checking the current assessment is added and the procedure for choosing the course is complicated, it is very difficult to estimate the effect of this method in advance, it is necessary to conduct an experiment.  And one more consideration - we should not forget that in the case of busting with pruning, in the case of a winning position, we give an estimate that is correct, but not accurate, because some of the options are not considered, and they could give a win in fewer moves.  If we are satisfied with such a decrease in accuracy, then why not apply this method, but for an accurate assessment, nothing but complete enumeration does not work. <br><br>  The results of the implementation of brute force with clipping are shown in the following table, and we see that there is a performance boost, and the gain is significant, but not sufficient for the study of large values ‚Äã‚Äãof N. In which direction we will continue our research - first consider another data structure, and then, As you may have guessed (it's nice to deal with a thoughtful audience) another algorithm. <br><br>  Note that the data structure we have adopted makes the chips unique and, for example, a single (not having nearby) chip in a position is not equivalent to a single chip in the position n + 2, which is completely wrong.  Select the key element of the game position - a group of adjacent chips and determine its main characteristic - the number of chips in the group.  It is this information that uniquely identifies any position in the game and we must present it in a convenient form for programming.  We choose the simplest and most obvious data structure ‚Äî we start an array on H elements and in the n element of the array we store the number of groups with exactly n chips in it.  Then, for example.  For the initial position with 3 chips, we will have the representation {0,0,1}.  The procedure for performing a move in this submission is still simple and effective, although, of course, more complicated than in the first version.  After the first move (which was two instead of three), we get the positions {0,1,0} and {2,0,0}. <br><br>  Let us try to estimate the expected gain in the number of moves for a given data structure.  For the first move, we have (H-1) / 2 + 1 options, for the second (we have broken the group H into m and Hm-1) (m-1) / 2 + (Hm-1-1) / 2 (take 1 chip) + (m-2) / 2 + (H-m-1-2) / 2 (take 2 chips) = (H-3) / 2 + (H-5) / 2 and by analogy , we conclude that at each step we save at least half of the moves.  Then our gain should be at least 2 ^ H, which for large H is very, very good.  In fact, the gain will be even greater, for example, for the position {8.0 ...} in the first variant, 8 moves must be enumerated, and in the second only 1 and the gain in this case will be 8 times.  So we can firmly count on 2 ^ H, but expect much more, which we will check.  And precisely, for the program on such a presentation we get table 4, the last line shows the increase in performance when switching to the second version of the data structure (calculated by hands).  The increase is simply enormous and we are confident (have reached the bottom) have broken the ceiling of the possibility of analyzing up to 20 chips in the initial position at reasonable time costs. <br><br>  Next, we can tackle the fine optimization of the algorithm with this data structure and get another performance gain, but we will not get such a dramatic (by orders of magnitude) growth, which means that Wirth was wrong.  For example, in the program above, the procedure of creating the next candidate in the course was deliberately not optimal and its obvious correction (we leave it to the inquisitive reader) leads to an increase in the speed of work 3 times, but this is a trifle, albeit a pleasant one. <br><br>  Pay attention to the results and see some not obvious things.  For example, the program claims that a guaranteed win in a direct game for 9 chips is achieved not at all in 9 moves, as follows from the heuristic symmetric algorithm, but in only 7, with the first move coinciding with the heuristic one (and moreover, it is the only winning ), but the third and subsequent ones should not repeat the moves of the enemy, as follows from the naive algorithm, and the key position here is {1,0,0,1}, which has a +4 rating.  Now that we have given an accurate assessment of the game, we can ask interesting questions about the presence of positions with a stable assessment (in which we can let the opponent walk for himself), the presence of key positions in the tree, find positions with a single correct move, and so on (and even get answers to these questions, and they are correct). <br><br>  Here is the final rating table. <br><table><tbody><tr><th>  Chips </th><th>  Straight </th><th>  Feedback </th><th>  Positions / Time </th><th>  Positions / Time </th></tr><tr><td>  one </td><td>  one </td><td>  -one </td><td>  ten </td><td>  ten </td></tr><tr><td>  2 </td><td>  -2 </td><td>  2 </td><td>  4/0 </td><td>  20 </td></tr><tr><td>  3 </td><td>  3 </td><td>  -3 </td><td>  17/0 </td><td>  7/0 </td></tr><tr><td>  four </td><td>  -four </td><td>  -3 </td><td>  82/0 </td><td>  20/0 </td></tr><tr><td>  five </td><td>  five </td><td>  four </td><td>  463/0 </td><td>  71/0 </td></tr><tr><td>  6 </td><td>  five </td><td>  -five </td><td>  3032/0 </td><td>  263/0 </td></tr><tr><td>  7 </td><td>  7 </td><td>  6 </td><td>  22693/0 </td><td>  1107/0 </td></tr><tr><td>  eight </td><td>  -eight </td><td>  -7 </td><td>  191422/0 </td><td>  4945/0 </td></tr><tr><td>  9 </td><td>  7 </td><td>  -7 </td><td>  1798427 / 0.1 </td><td>  24283/0 </td></tr><tr><td>  ten </td><td>  9 </td><td>  eight </td><td>  18634228 / 0.8 </td><td>  125419/0 </td></tr><tr><td>  eleven </td><td>  eleven </td><td>  -9 </td><td>  211177537 / 10.4 </td><td>  699165 / 0.1 </td></tr><tr><td>  12 </td><td>  -ten </td><td>  -9 </td><td>  *** / 127 </td><td>  4057686 / 0.6 </td></tr><tr><td>  13 </td><td>  eleven </td><td>  ten </td><td></td><td>  25056975 / 3.84 </td></tr><tr><td>  14 </td><td>  -12 </td><td>  -eleven </td><td></td><td>  160643971/28 </td></tr><tr><td>  15 </td><td>  13 </td><td>  12 </td><td></td><td>  1082854607/213 </td></tr><tr><td>  sixteen </td><td>  -14 </td><td>  -13 </td><td></td><td>  *** / 1698 </td></tr></tbody></table>  Nevertheless, we see that the estimate of the time of work remained factorial, albeit with a significant decrease in the growth rate.  Look for other ways to explore the game tree. <br><br>  We have brought the perfection algorithm from top to bottom (well, of course, in that ugly form that I sketched on the back of the envelope, we didn‚Äôt finish it; you can significantly improve the speed by carefully rewriting the basic procedures, and this is sure to be done, but the problem is not decides), then let's go the other way - from the bottom up.  The idea of ‚Äã‚Äãthis method is intuitively simple and understandable, but it is very difficult for a person to use - we start from the final position, the assessment of which is given according to the rules of the game, and begin to transfer the assessment up the tree using the same rules as for going from top to bottom.  Of course, in this case, we are not considering possible moves down from the current position, but considering all positions from which we could get into the current one in one move.  The assessment is transferred according to the rules given earlier.  Further, we apply this procedure iteratively and when it ceases to produce results, that is, in the next round no position has changed the assessment, the task is completed and the assessment of the initial position is correct and accurate.  This approach allows you to greatly reduce the search time, especially if you make some improvements, but it has a strong drawback (and this is a classic - we change time for memory), which significantly limits its scope - high memory requirements, since we must keep estimates for all possible positions at the same time, so the limit is the amount of RAM available to us (taking into account our ability to save it).            ,   ,      (         ), , ,   ,     .   ,    ,  20,       2^20,        ,    -20  20,   8- ,          .             ,       .     ,  ,       . ,       ,   ,         ,   ,  2* (  ).          *2*  , ,           ,        *2**. <br><br>        2^**2^=2^(2*)* (  ,      ) , ,  =20    -  20!~1018,    -  2^40*20=(2^10)^4*40=(10^3)^4*40~10^14,    20          106 ,   .    9  ,     9!~106,     2^9*2^9*18~106,         .    ,         ‚Äî       ,              (1). <br><br>        ,       .        9  ,       : 1+(1+4)+(1+3+2)+(1+3+3+2)+(1+2+2+1+1)+(1+2+1+1)+(1+1+1)+(1+1)+1=1+5+6+9+7+5+3+2+1=39. <br>          **=39*39*9~104,            ,         .              ,    ,    . <br><br> ,      -,    .    ,         .           .      ‚Äî             (    ,  /2),            ,       2 . <br><br><h4>   ‚Äî        ,         ,      .       ,     ,       (    )   . </h4><br><br>        ,         ()  ‚Äî    ,               ,     ,             ,        (    )  .       ,      ‚Äî             ,        . <br><br>  Ps.      (, ),        ‚Äî , ,       ,        ,        -   (  ,  ),            (   ),      1.878^    (     ). ,      ,   ,     ,              (ars longa, vita brevis). <br><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;ctime&gt; #include "stdio.h" #define MaxMax 17 #define Forward 1 // 1-   0 -  #define Version 1 // 0-   1 -   int hod[MaxMax+1],nf[MaxMax+1],oc[MaxMax+1],sm[MaxMax+1]; int lvl,count,nhod; #if Version==0 int pos[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;Max; ++i) pos[i]=1; pos[Max]=0; }; inline void FirstStep(int Max) { hod[lvl]=0; nf[lvl]=1; }; inline int ValidStep() { if ( (pos[hod[lvl]]==1) &amp;&amp; ((nf[lvl]==1) || (pos[hod[lvl]+1]==1)) ) return 1; else return 0; }; inline void MakeStep(void) { pos[hod[lvl]]=0; --count; if (nf[lvl]==2) { pos[hod[lvl]+1]=0; --count; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=-1; nf[lvl]=2; }; inline void RemoveStep(void) { pos[hod[lvl]]=1; ++count; if (nf[lvl]==2) { pos[hod[lvl]+1]=1; ++count; }; }; inline void NextStep(void) { if ((nf[lvl]==1) &amp;&amp; (lvl&gt;0)) nf[lvl]=2; else { ++hod[lvl]; nf[lvl]=1; }; }; inline int LastStep(int Max) {if (hod[lvl]&gt;=Max) return 1; else return 0; }; void print(int Max) { for (int i=0; i&lt;Max; ++i) if (pos[i]==1) printf("*"); else printf("."); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf ("%2d,%1d",hod[i],nf[i]); else printf(" "); printf("%3d ",count); for (int i=0; i&lt;Max; ++i) printf("%3d",oc[i]); printf("\n"); }; #endif #if Version==1 int gr[MaxMax+1]; inline void Start(int Max) { for (int i=0; i&lt;Max; i++) oc[i]=0; for (int i=0; i&lt;MaxMax; ++i) { gr[i]=0; }; gr[Max]=1; }; inline void FirstStep(int Max) { hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline int ValidStep(void) { if ( (gr[hod[lvl]]&gt;0) &amp;&amp; (hod[lvl]&gt;=nf[lvl]) ) return 1; else return 0; }; inline void MakeStep(void) { gr[hod[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]+=1; if (sm[lvl]&gt;0) gr[sm[lvl]]+=1; count-=nf[lvl]; }; inline void NextStep(void) { sm[lvl]++; if ( sm[lvl]*2 &gt; (hod[lvl]-nf[lvl]) ) { if ( (lvl&gt;0) &amp;&amp; (nf[lvl]==1) ) { nf[lvl]=2; sm[lvl]=0; } else { hod[lvl]-=1; sm[lvl]=0; nf[lvl]=1; }; }; }; inline void DownStep(int Max) { ++lvl; oc[lvl]=0; hod[lvl]=Max; nf[lvl]=1; sm[lvl]=0; }; inline void RemoveStep(void) { if (sm[lvl]&gt;0) gr[sm[lvl]]-=1; gr[hod[lvl]-nf[lvl]-sm[lvl]]-=1; gr[hod[lvl]]+=1; count+=nf[lvl]; }; inline int LastStep(int Max) {if (hod[lvl]&lt;=0) return 1; else return 0; }; void print(int Max) { if (Max==18) { for (int i=1; i&lt;=Max; ++i) printf("%2d,",gr[i]); for (int i=0; i&lt;Max; ++i) if (i&lt;=lvl) printf (" =&gt;%2d:%2d,%1d,%2d",i,hod[i],nf[i],sm[i]); else printf(" "); printf(" %3d:: ",count); for (int i=0; i&lt;Max; ++i) printf("%2d",oc[i]); printf("\n"); }; }; #endif inline void MoveOc(void) { int newoc=-oc[lvl+1]; if (newoc&gt;0) ++newoc; else --newoc; if ( (oc[lvl]==0) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&gt;0) ) || ( (oc[lvl]&gt;0) &amp;&amp; (newoc&gt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) || ( (oc[lvl]&lt;0) &amp;&amp; (newoc&lt;0) &amp;&amp; (newoc&lt;oc[lvl]) ) ) { oc[lvl]=newoc; // if (oc[0]&gt;0) --ur; }; }; int ocenka(int Max) { Start(Max); count=Max; nhod=0; lvl=0; FirstStep(Max); while (lvl&gt;=0) { //print(Max); if ( ValidStep()==1) { MakeStep(); ++nhod; //print(Max); if (count&gt;0) DownStep(Max); else { #if Forward==1 oc[lvl]=1; #else if (oc[lvl]==0) oc[lvl]=-1; #endif RemoveStep(); }; //print(Max); }; NextStep(); if (LastStep(Max)==1) { --lvl; if (lvl&gt;-1) { MoveOc(); RemoveStep(); NextStep(); }; }; }; return nhod; }; void reverse(void); int main(void) { int last=1; for (int i=1; i&lt;=MaxMax; ++i) { clock_t start_time = clock(); int j=ocenka(i); printf("%2d %3d %12d %5.2f %5.2f\n",i,oc[0],j,(float)j/last,(clock()-start_time)/1000.); last=j; }; return 1; };</span></span></span></span></code> </pre> <br></div></div></div><p>Source: <a href="https://habr.com/ru/post/420859/">https://habr.com/ru/post/420859/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420843/index.html">September 7, Ekaterinburg - mitap for .NET developers</a></li>
<li><a href="../420845/index.html">Taming of the Shrew with the use of a crutch: WF2190 Wi-Fi Hole (Realtek8812AU Wireless LAN 802.11ac USB)</a></li>
<li><a href="../420847/index.html">An introduction to programming shaders for web designers</a></li>
<li><a href="../420853/index.html">Meet the Windows pseudo console (ConPTY)</a></li>
<li><a href="../420857/index.html">Seamless Wi-Fi roaming: theory in practice</a></li>
<li><a href="../420861/index.html">Preparing for C ++ 20. Coroutines TS on a real example</a></li>
<li><a href="../420863/index.html">As we did the first Russian smartphone, continued</a></li>
<li><a href="../420865/index.html">The principle of least action. Part 1</a></li>
<li><a href="../420867/index.html">Calculation of certain integrals: basic algorithms</a></li>
<li><a href="../420869/index.html">Evacuation, HAMR and MAMR - three ways to increase the capacity of modern HDD to the maximum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>