<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>AngularJS: Migration from 1.2 to 1.4, Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A lot of articles have been written about the advantages of the transition from version 1.2. However, according to statistics, more than 45% of sites ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>AngularJS: Migration from 1.2 to 1.4, Part 1</h1><div class="post__text post__text-html js-mediator-article">  A lot of articles have been written about the advantages of the transition from version 1.2.  However, according to statistics, more than 45% of sites still use version 1.2, only 31% switched to a newer 1.3 and only 5% use 1.4. <br><br>  And this is when <s>space ships plow the expanses of the universe,</s> version 1.2.0 was released almost two years ago, version 1.3.0 - a year ago, version 1.4.0 - this spring, and 1.5.0 is already in beta. <br><br><img src="https://habrastorage.org/files/156/e6e/ba8/156e6eba836b4d388f7effb442ca43f9.png">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As a rule, large projects from transition restrain the opacity of this process and the scarcity of materials on this subject. <br>  In the official guide you can find only a small piece of all possible problems, and blogs, as a rule, only retell it. <br><br>  In this article we will talk about what you can encounter when migrating to new versions, and analyze the most problematic places. <br><a name="habracut"></a><br>  Unfortunately, the post came out too big, so in this part I will focus on breaking changes of this transition, and we will talk about features and merits in the next part.  But I note that the main advantage of the transition is a significant increase in the speed of work, as well as a solid list of fixed bugs (after all, the latest fixes for 1.2 were a year ago at 1.2.28). <br><br>  I divided this post into two parts.  One of them is my personal experience of translating two projects into new versions (I hid it under the spoiler), the second is a list of problems found, read and translated with explanations and examples. <br><br><div class="spoiler">  <b class="spoiler_title">The history of our transition</b> <div class="spoiler_text">  The first relatively large project that required a transition (from 1.2 to 1.3) was the E-Learning platform, where, despite more than 12,000 lines of code (mostly directives), no problems arose. <br><br>  The second project required migration from version 1.2.16 to 1.4.4 and was significantly larger (about 75,000 lines of pure angular), and product specifics (accounting) implied complex relationships, many forms and inevitable problems, but previous experience inspired. <br><br>  The first result of the migration was expected to get a non-working application with a bunch of errors in the console, but the application started, and there were no problems.  It was extremely strange, so I began my journey through the official guide, where, however, none of the problems described were reproduced.  Having decided that the job was done, I gave the task to the QA and automatic tests. <br><br>  And the next day I received 9 bugs, then another 9, and more.  The insidiousness of all the errors found was not in the fact that they break the work of the application, but in the fact that it imperceptibly changes its behavior. <br><br>  Here, <a href="">Change Log</a> and discussions inside the commits found there became a friend and companion in search of reasons. <br><br>  First of all, asynchronous checks on the server side, which did not work with statuses, but with responses in the form of an ‚ÄúOK‚Äù text primitive, fell off.  Not a single break change was notified about this, but there was a corresponding <a href="https://github.com/angular/angular.js/commit/7b6c1d08aceba6704a40302f373400aed9ed0e0b">bug fix</a> . <br><br>  <strong>Tip:</strong> Check your work with XHR requests.  If the server does not send you an object, but a primitive with the ‚Äúapplication / json‚Äù headers, you will have problems. <br><br>  The next came the spinners embedded in the pop-ups, ceasing to correctly determine the width of the parent.  The problem was two things.  First, the spinners lay in <i>ng-show</i> , which means they were initialized before the parent container could be displayed.  Secondly, the spinner showed / hid, following the attribute through <i>$ observe</i> .  For some reason, in the old version, the attribute changed later than the parent became <i>: visible</i> , and in the new one, vice versa. <br><br>  <strong>Tip:</strong> <br><ol><li>  Do not store dynamic directives for which the moment of initialization is important in <i>ng-show / ng-hide</i> , use <i>ng-if</i> for this.  This advice is also relevant for version 1.2. </li><li>  Do not use <i>$ observe</i> to track attributes if you need to monitor external changes to other data (DOM or $ scope).  Use <i>$ watch (function () {}, function () {}) for this</i> .  Moreover, both options add their votcher to a dirty check, the only difference is in the conditions of calling a callback. </li></ol><br><br>  The same problem affected the conditions in the expressions inside <i>$ eval</i> : some blocks began to disappear.  But the problem turned out to be another <a href="https://github.com/angular/angular.js/commit/bdfc9c02d021e08babfbc966a007c71b4946d69d">bug-fix</a> and was already <a href="http://habrahabr.ru/post/225243/">covered in Habr√©</a> . <br><br>  <strong>Tip:</strong> Do not use the undocumented features of the framework, examine the code for use when checking the following values ‚Äã‚Äãin <i>$ scope</i> : <i>'f'</i> , <i>'0'</i> , <i>'false'</i> , <i>'no'</i> , <i>'n'</i> , <i>'[]'</i> . <br><br>  The main problem that has arisen is validation.  Starting with version <strong>1.3</strong> , new methods for checking forms have appeared in the anguly, and with them new pitfalls.  But there are problems that will affect you, even if you do not plan to use the new validation.  These are the <i>maxlength / minlength directives</i> and the new <i>$ setValidity</i> logic that threatens to make your form permanently invalid (this is what happened to us). <br><br>  It was found that we kept in <i>ngModelCtrl. $ Error the</i> special property <i>showError</i> (for conveniently displaying errors one by one), which led to a permanent invalidation of the form, because in the new version one of the validity conditions is the empty hash <i>ngModelCtrl. $ Error</i> . <br><br>  <strong>Tip:</strong> Do not put in properties that start with <i>$</i> nothing that is not listed in the official API. <br><br>  Another problem arose with inputs that use a mask (for phone, contract numbers, etc.) in tandem with the <i>ng-maxlength / ng-minlength directives</i> . <br><br>  Both of these directives now check <i>ngModelCtrl. $ ViewValue</i> instead of <i>ngModelCtrl. $ ModelValue</i> , which means that the maximum length for the value ‚Äúxx-xx‚Äù is no longer 4, but 5 (taking into account the ‚Äú-‚Äù character).  I would have had to rewrite hundreds of verification rules throughout the application, so it was decided to replace all <i>ng-maxlength</i> with a custom <i>model-maxlength with autocorrect</i> , which would only check the model again.  And this decision was terrible!  Angulyar reserved himself the maxlength attribute limiter, which means we could no longer limit the number of characters entered.  As a result, it was decided to change all the rules for new ones, taking into account the mask symbols.  However, the custom <i>model-minlength directive</i> found its use in directives where there are predefined characters (for example, "+7" for the phone), allowing you to check only the model without the prefixes set in <i>ngModelCtrl. $ ViewValue</i> . <br><br>  <strong>Tip:</strong> If you use a mask or otherwise manipulate the value of <i>ngModelCtrl. $ ViewValue</i> , change the validation taking into account mask characters.  Use the <i>placeholder</i> attribute for the predefined values ‚Äã‚Äãin the input with the <i>ng-minlength</i> check or replace the check with the custom one.  The working code of such a directive is in the break changes list. <br><br>  The second wave of problems went after the transition to our new validation (goodbye, <i>$ formatters</i> and <i>$ parsers</i> ).  We are faced with the fact that a number of forms again became permanently invalid. <br><br>  With synchronous validations ( <i>$ validators</i> ), the problem came to light quickly.  It consisted in the fact that the fields contained hidden fields via <i>ng-show</i> with their validation checks.  Due to the peculiarities of working in the old version ( <i>$ formatters</i> and <i>$ parsers</i> ), these fields were not included in the form verification, however, in the new version ( <i>$ validators</i> ) this results in a hidden <i>non-valid</i> field. <br><br>  <strong>Tip:</strong> If you have forms with hidden dynamic fields, then hide these fields or show them through <i>ng-if</i> , do not use <i>ng-show / ng-hide</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Remark: How asynchronous validators work</b> <div class="spoiler_text">  Asynchronous validators are stored in the <i>ngModelCtrl. $ AsyncValidators collection</i> and are a function that returns a <i>Promise</i> .  Promises return various services (for example, $ timeout and $ http), and are also generated by the special service <i>$ q</i> .  The validity of the field depends on the resolved or rejected return.  Asynchronous validation starts only after all synchronous validators become valid.  At the time of the validator call, its validity ( <i>$ setValidity</i> ) will be equal to <i>undefined</i> , and the name of the expected validator will appear in <i>ngModelCtrl. $ Pending</i> .  As soon as the resolve of the promise resolves, its validity will be set to <i>null</i> . <br><br>  If you call the validation function several times, the last promise will wipe the previous ones.  This means that if the field was validated twice, and the first promise was resolved and the second rejected, the field would be invalid. <br><br>  <strong>An example from the API documentation:</strong> <br><pre><code class="javascript hljs">ngModel.$asyncValidators.uniqueUsername = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">modelValue, viewValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value = modelValue || viewValue; <span class="hljs-comment"><span class="hljs-comment">// Lookup user by username return $http.get('/api/users/' + value). then(function resolved() { //username exists, this means validation fails return $q.reject('exists'); }, function rejected() { //username does not exist, therefore this validation passes return true; }); };</span></span></code> </pre> <br></div></div><br>  With asynchronous validation, it turned out to be more difficult: the form was invalid, but did not contain any errors. <br><br>  Here, due to the <i>nature of the</i> mask (via <i>$ formatters</i> and <i>$ parsers</i> ), asynchronous validation was called before the completion of synchronous validations, and it was called several times in 1 changed symbol.  This caused a multiple creation bug of promises, which led to the fact that the last promise was not resolved or rejected.  Accordingly, the input received infinite pending, and the form was invalid without any errors. <br><br><div class="spoiler">  <b class="spoiler_title">An example of building a validator for such cases</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pendingPromise; ngModelCtrl.$asyncValidators.checkPhoneUnique = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">modelValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pendingPromise) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pendingPromise; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> deferred = $q.defer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (modelValue) { pendingPromise = deferred.promise; $http.post(<span class="hljs-string"><span class="hljs-string">'/'</span></span>, {<span class="hljs-attr"><span class="hljs-attr">value</span></span>: modelValue}) .success(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.Result === <span class="hljs-string"><span class="hljs-string">'   '</span></span>) { deferred.resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { deferred.reject(); } }).error(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ deferred.reject(); }).finally(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ pendingPromise = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { deferred.resolve(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> deferred.promise; };</code> </pre><br></div></div><br>  <strong>Tip:</strong> Test the behavior of asynchronous validators: make sure the return promise will always be resolved or rejected. <br><br>  The strangest problem of validation was the custom directive for entering the amount (it looked like two input lines for rubles and kopecks, giving to ngModel the ready result of concatenating these numbers).  It was not only invalid, but it also reported an error to the console from the depths of the framework. <br><br>  Time was spent on the problem fairly, the problem was again in ng-maxlength, and the solution was simple: add directives in $ formatters to convert the value of <i>$ viewValue</i> to a string. <br><br>  But why the problem arose at all?  Let's figure it out! <br><br>  It's all about <i>$ compile</i> : the behavior of the main directives is described inside.  For example, for <i>input</i> and <i>textarea</i> , the <i>inputDirective</i> control is <i>called</i> , which takes <i>attr.type</i> and, based on it, calls one of the functions in the <i>inputType</i> collection.  For text types, this is <i>textInputType</i> .  He, in turn, passes our control into the function <i>stringBasedInputType</i> , which adds in <i>$ formatters the</i> code that converts our value to a string. <br><br>  Thus, when <i>ngModel is</i> not tied to some existing base element such as <i>input</i> , but, for example, hangs on a simple diva or custom directive (in our case it is a directive to input the amount), the data is thrown into <i>$ viewModel</i> "as is", which causes an error for filter directives like maxlength, which for their work use the property <i>.length</i> , which is absent in numbers. <br><br>  <a href="http://embed.plnkr.co/kLDwFg9BtbkdfoSeE7qa">Working example on Plunker</a> . <br><br>  <strong>Tip:</strong> All custom directives that work with numbers must have the appropriate formatter to convert numbers to strings. <br><br><h3>  Total: </h3><br>  As a result, about 6 iterations of tests were driven off and 54 problems were found, but most of them had a similar nature.  Part of the problem could not be at all, do not use some parts of the code for their work bugs and undocumented features.  A total of 56 commits and 3 weeks of working time per person were spent on migration, taking into account refactoring and the transition to a new validation. <br></div></div><br><br><h1>  Part One: Breaking Changes </h1><br>  Immediately, I note that from now on we are losing support for IE8.  However, it can be returned by connecting the necessary polyfills. <br><br><h2>  Job $ parse </h2><br><h3>  .bind, .call and .apply </h3><br>  You can no longer call <i>.bind</i> , <i>.call,</i> and <i>.apply</i> inside an expression (for example, <i>{{}}</i> ). <br><br>  This allows you to be sure that the behavior of existing functions cannot be changed. <br><br><h3>  __proto__ </h3><br>  Since version <strong>1.3, the</strong> deprecated ( <i>deprecated</i> ) property <i>__proto__</i> has <i>been</i> removed. <br><br>  Previously, it could be used to access global prototypes. <br><br><h3>  Object </h3><br>  It is forbidden to use <i>Object</i> inside expressions. <br><br>  This is due to the ability to execute arbitrary code in expressions. <br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-string"><span class="hljs-string">''</span></span>.sub.call.call( ({})[<span class="hljs-string"><span class="hljs-string">"constructor"</span></span>].getOwnPropertyDescriptor(<span class="hljs-string"><span class="hljs-string">''</span></span>.sub.__proto__, <span class="hljs-string"><span class="hljs-string">"constructor"</span></span>).value, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"alert('evil')"</span></span> )()</code> </pre><br></div></div><br>  If someone needs <i>Object.key</i> or some other method, pass it through <i>scope</i> . <br><br><h3>  {define, lookup} {Getter, Setter} </h3><br>  Since version <strong>1.3</strong> , the <i>{define, lookup} {Getter, Setter}</i> properties, which allowed to execute arbitrary code inside an expression, are prohibited. <br><br>  If you need these properties, wrap them in the controller and push them into the <i>scope</i> with your hands. <br><br><h3>  $ parseProvider </h3>  <a href="https://github.com/angular/angular.js/pull/4317">[commit]</a> <br><br>  Removed obsolete <i>$ parseProvider.unwrapPromises</i> and <i>$ parseProvider.logPromiseWarnings methods</i> . <br><br><h3>  $ interpolate </h3><br>  The functions returned by <i>$ interpolate</i> no longer contain an array of <i>.parts</i> .  Instead, they contain: <br><br><ul><li>  <i>.expressions</i> , which contains all the expressions in the text. <br></li><li>  <i>.separators</i> , in which there are delimiters between expressions in the text.  It is always 1 element longer than <i>.expressions</i> , for the convenience of combining. <br></li></ul><br><h3>  toBoolean </h3><br>  In an angular, the true implementation of <i>toBoolean () is</i> used to test for truth, which equates to <i>false</i> some non-standard values ‚Äã‚Äãin the form of the following lines: <br><br>  <i>'f'</i> , <i>'0'</i> , <i>'false'</i> , <i>'no'</i> , <i>'n'</i> , <i>'[]'</i> <br><br>  Starting with version <strong>1.3</strong> , only the same values ‚Äã‚Äãas in the normal JS are equal to false: <br><br>  <i>false</i> , <i>null</i> , <i>undefined</i> , <i>NaN</i> , <i>0</i> , <i>""</i> <br><br>  <a href="http://habrahabr.ru/post/225243/">About it wrote on Habr√©</a> <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> $scope.isEnabled = <span class="hljs-string"><span class="hljs-string">'no'</span></span>;</code> </pre><br>  <strong>&lt;1.3:</strong> <br><br><pre> <code class="javascript hljs"> {{ isEnabled ? <span class="hljs-string"><span class="hljs-string">' '</span></span> : <span class="hljs-string"><span class="hljs-string">''</span></span> }}</code> </pre><br>  <strong>1.3+:</strong> <br><br><pre> <code class="javascript hljs"> {{ isEnabled ? <span class="hljs-string"><span class="hljs-string">''</span></span> : <span class="hljs-string"><span class="hljs-string">' '</span></span> }}</code> </pre><br></div></div><br><hr><br><h2>  Helpers </h2><br><h3>  .copy () </h3><br>  Previously, when working with <i>copy</i> objects, I copied all the properties of the object, including those in the prototype, which led to the loss of the prototype chain (except for Date, RegExp and Array). <br><br>  Starting with version <strong>1.3</strong> , it copies only its own properties (something like <i>iteration</i> with <i>hasOwnProperty</i> ), and then refers to the prototype of the original. <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; Foo.prototype.bar = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fooCopy = angular.copy(foo); foo.bar = <span class="hljs-number"><span class="hljs-number">3</span></span>;</code> </pre><br>  <strong>&lt;1.3:</strong> <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Foo); <span class="hljs-comment"><span class="hljs-comment">// =&gt; true console.log(fooCopy instanceof Foo); // =&gt; false console.log(foo.bar); // =&gt; 3 console.log(fooCopy.bar); // =&gt; 1</span></span></code> </pre><br>  <strong>1.3+:</strong> <br><br><pre> <code class="javascript hljs"> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(foo <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Foo); <span class="hljs-comment"><span class="hljs-comment">// =&gt; true console.log(fooCopy instanceof Foo); // =&gt; true console.log(foo.bar); // =&gt; 3 console.log(fooCopy.bar); // =&gt; 3</span></span></code> </pre><br>  <strong>IE8:</strong> <i>Object.create</i> and <i>Object.getPrototypeOf polyfills are required</i> <br></div></div><br><h3>  .forEach () </h3><br>  Previously, if the array increased in the process of iteration, then the cycle went through the newly appeared elements too. <br><br>  Starting with version <strong>1.3</strong> , it caches the number of elements in the array and passes only through them, here it is closer to the native <i>Array.forEach</i> . <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>];</code> </pre><br><br>  <strong>&lt;1.3:</strong> <br><br><pre> <code class="javascript hljs"> angular.forEach(foo, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, key</span></span></span><span class="hljs-function">) </span></span>{ foo.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt;     null    console.log(value); });</span></span></code> </pre><br>  <strong>1.3+:</strong> <br><br><pre> <code class="javascript hljs"> angular.forEach(foo, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, key</span></span></span><span class="hljs-function">) </span></span>{ foo.push(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">// =&gt;  1,  2    console.log(value); });</span></span></code> </pre><br></div></div><br><h3>  .toJson () </h3><br>  The salt of this helper is primarily in the fact that it does not serialize all the data, but only those that do not begin with the special character $. <br><br>  Starting with version <strong>1.3</strong> , it does not serialize only properties whose names begin with $$. <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> foo = {<span class="hljs-attr"><span class="hljs-attr">bar</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">baz</span></span>: <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-attr"><span class="hljs-attr">$qux</span></span>: <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre><br>  <strong>&lt;1.3:</strong> <br><br><pre> <code class="javascript hljs"> angular.toJson(value); <span class="hljs-comment"><span class="hljs-comment">// =&gt; {"bar": 1}</span></span></code> </pre><br>  <strong>1.3+:</strong> <br><br><pre> <code class="javascript hljs">angular.toJson(value); <span class="hljs-comment"><span class="hljs-comment">// =&gt; {"bar": 1, "$bar": 2}</span></span></code> </pre><br></div></div><br><hr><br><h2>  jqLite </h2><br>  Briefly about the main thing: <br><ul><li>  You can no longer set data nodes for text and comments  This is due to memory leakage and cleansing hemorrhoids; </li><li>  Calling element.detach () now does not trigger the $ destroy event; </li></ul><br><h3>  Select </h3><br><h4>  Controller </h4><br>  <i>SelectController is</i> now one abstraction for the <i>Select</i> directive and for the <i>ngOptions</i> directive. <br><br>  This means that now <i>ngOptions</i> can be removed from <i>Select</i> , without fear that it could somehow affect it. <br><br>  Different variations of the <i>Select</i> directive have their own <i>SelectController.writeValue</i> and <i>SelectController.readValue methods</i> , which are responsible for working with the <i>$ viewValue of the</i> <i>&lt;select&gt; tag</i> and its children <i>&lt;option&gt;</i> . <br><br><h4>  value for ngOptions </h4><br>  Previously, in <i>ngOptions, the</i> surrogate key used the index or the item key in the passed collection. <br><br>  Starting with version <strong>1.4</strong> , this is done using the <i>hashKey</i> call for the item in the collection. <br><br>  Accordingly, if you read the <i>value</i> directly from the <i>DOM</i> , then problems may arise. <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">select</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"model"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-option</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"i in items"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">select</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  <strong>&lt;1.4:</strong> <br><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">&gt;</span></span>a<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"2"</span></span></span><span class="hljs-tag">&gt;</span></span>b<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"3"</span></span></span><span class="hljs-tag">&gt;</span></span>c<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"4"</span></span></span><span class="hljs-tag">&gt;</span></span>d<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  <strong>1.4+:</strong> <br><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string:a"</span></span></span><span class="hljs-tag">&gt;</span></span>a<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string:b"</span></span></span><span class="hljs-tag">&gt;</span></span>b<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string:c"</span></span></span><span class="hljs-tag">&gt;</span></span>c<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"string:d"</span></span></span><span class="hljs-tag">&gt;</span></span>d<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">option</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br></div></div><br><h4>  Comparing ngModel with option value </h4><br>  Starting with version <strong>1.4</strong> , the <i>select</i> directive begins to compare the value of <i>option</i> and <i>ngModel</i> , using strict comparison. <br><br>  This means that the value <i>1 is</i> not equivalent to <i>"1"</i> as it is not equivalent to the value <i>false</i> or <i>true</i> . <br>  If you put the value <i>1</i> in the model, you get <i>unknown option</i> . <br><br>  To avoid this, you need to put a string in the model, for example, <i>scope.model = "1"</i> . <br><br>  If the model needs exactly a number, it is proposed to use conversion via formatters and parsers. <br><br><div class="spoiler">  <b class="spoiler_title">Example:</b> <div class="spoiler_text"><pre> <code class="javascript hljs">ngModelCtrl.$parsers.push(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value, <span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    }); ngModelCtrl.$formatters.push(function(value) { return value.toString(); //    });</span></span></code> </pre><br></div></div><br><h4>  Sorting </h4><br>  As in the case of <i>ngRepeat</i> , sorting in alphabetical order no longer works, but corresponds in sequence to the call to <i>Object.keys (obj)</i> . <br><hr><br><h2>  ngRepeat </h2><br><h3>  Sorting </h3>  <a href="https://github.com/angular/angular.js/commit/c260e7386391877625eda086480de73e8a0ba921">[commit]</a> <a href="https://github.com/angular/angular.js/issues/6210">[issue]</a> <a href="https://github.com/angular/angular.js/issues/1286">[holy war]</a> <br><br>  Previously, ngRepeat, sorting an object, sorted it alphabetically by keys.  Starting with version <strong>1.4</strong> , it returns it in an order dependent on the browser, as if you were sorting it out <i>for key in obj</i> . <br><br>  This is due to the fact that browsers usually return object keys in the order in which they were declared, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/delete">unless</a> the keys were deleted or reinstalled. <br><br>  To iterate over an object, it is proposed to use <a href="https://github.com/petebacondarwin/angular-toArrayFilter">custom</a> filters that convert the object into an array. <br><hr><br><h2>  $ compile </h2><br><h3>  controllerAs, bindToController </h3><br>  In version <strong>1.3</strong> <i>bindToController</i> was introduced.  Starting with version <strong>1.4</strong> , an object can be passed into it to specify an isolated scope. <br><br>  In this regard, now the object returned from the controller constructor overwrites the scope. <br><br>  The views that used the <i>controllerAs</i> syntax no longer receive a reference to the function itself, but to the object it returns. <br><br>  If the directive uses <i>bindToController</i> , then all previous bindings are reinstalled into the new controller, all installed watches are deleted ( <i>unwatch</i> ). <br><br><h3>  Expression '&amp;' in isolated scope </h3><br>  Previously, a function with an <i>&amp; was</i> always created, even if the attribute along with an expression was missing (in this case, a function was created that returns <i>undefined</i> ). <br><br>  Starting at <strong>1.4</strong> , the behavior <i>&amp;</i> approached <i>@</i> .  Now, if the expression is missing, then the corresponding method in $ scope is also missing.  When you access it, you get <i>undefined</i> instead of a function that returns <i>undefined</i> . <br><br><h3>  Replace directive property </h3><br>  Starting from <strong>1.3</strong> , it becomes <i>deprecated</i> and should be removed in the next major release. <br><br>  This is explained by the fact that there are some problems with merge attributes. <br><br><div class="spoiler">  <b class="spoiler_title">More details:</b> <div class="spoiler_text">  If you combine <br><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{hasHeader: true}"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  WITH <br><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{active: true}"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  That will get <br><br><pre> <code class="html hljs xml"> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">ng-class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"{active: true}{hasHeader: true}"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  With the corresponding error that the expression is not valid. <br><br>  And an insufficient level of encapsulation of such directives and in general. <br><br>  Holivar on this topic is available <a href="https://github.com/angular/angular.js/commit/eec6394a342fb92fba5270eee11c83f1d895e9fb">here</a> . <br></div></div><br><h3>  $ observer </h3><br>  Starting from version <strong>1.3</strong> , we finally got a convenient way to remove the attribute observatory: the destructor function returns when you call attr.observe (as watch does).  Previously, he returned a link to the function of the Observer. <br><br>  Now, in order to have a link to the function of the Observer, you must save it somewhere beforehand. <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text">  <strong>&lt;1.3:</strong> <br><br><pre> <code class="javascript hljs">directive(<span class="hljs-string"><span class="hljs-string">'directiveName'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, elm, attr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer = attr.$observe(<span class="hljs-string"><span class="hljs-string">'someAttr'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value); }); } }; });</code> </pre><br>  <strong>As it is now:</strong> <br><br><pre> <code class="javascript hljs">directive(<span class="hljs-string"><span class="hljs-string">'directiveName'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, elm, attr</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> observer = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(value); }; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> destructor = attr.$observe(<span class="hljs-string"><span class="hljs-string">'someAttr'</span></span>, observer); destructor(); <span class="hljs-comment"><span class="hljs-comment">//   } }; });</span></span></code> </pre><br></div></div><br><h3>  Access to isolated scope from outside </h3><br>  It is no longer possible to get the isolated scope property through the attribute of the element where the isolated directive is defined. <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text">  The following directive is given: <br><br><pre> <code class="javascript hljs"> app.controller(<span class="hljs-string"><span class="hljs-string">'testController'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{ $scope.controllerScope = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }); app.directive(<span class="hljs-string"><span class="hljs-string">'testDirective'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">template</span></span>:<span class="hljs-string"><span class="hljs-string">'&lt;span ng-if="directiveScope"&gt;world!&lt;/span&gt;'</span></span>, <span class="hljs-attr"><span class="hljs-attr">scope</span></span>: {<span class="hljs-attr"><span class="hljs-attr">directiveScope</span></span>: <span class="hljs-string"><span class="hljs-string">'='</span></span>}, <span class="hljs-attr"><span class="hljs-attr">controller</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope</span></span></span><span class="hljs-function">) </span></span>{}, <span class="hljs-attr"><span class="hljs-attr">replace</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">'E'</span></span> } });</code> </pre> <br>  <strong>&lt;1.3:</strong> <br><br><pre> <code class="html hljs xml"> Hello <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">test-directive</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">directive-scope</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"controllerScope"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">test-directive</span></span></span><span class="hljs-tag">&gt;</span></span> // Hello</code> </pre><br>  <strong>1.3+:</strong> <br><br><pre> <code class="html hljs xml"> Hello <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">test-directive</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">directive-scope</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"controllerScope"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">test-directive</span></span></span><span class="hljs-tag">&gt;</span></span> // Hello world!</code> </pre><br></div></div><br><hr><br><h2>  ngModelController </h2><br><h3>  $ setViewValue () </h3><br>  The behavior of <i>$ setViewValue ()</i> has changed a bit, now it does not pass changes to $ modelValue immediately, as before. <br><br>  Now the model is updated depending on the two settings <i>ngModelOptions</i> , and in particular: <br><br><ul><li>  <i>updateOn</i> : The model will not be updated until one of the events specified in this trigger is called. </li><li>  <i>debounce</i> : The model will not update until the time specified in one of the <i>debounce passes.</i> </li></ul><br>  By default, <i>updateOn</i> is <i>default</i> , and <i>debounce</i> is <i>0</i> , so $ modelValue runs as before, instantly. <br>  However, you should take into account the features described above when working with old code. <br><br><h4>  $ commitViewValue </h4><br><br>  If you want to update $ modelValue instantly at all costs, ignoring <i>updateOn</i> and <i>debounce</i> , use <i>$ commitViewValue ()</i> . <br><br>  <i>$ commitViewValue ()</i> takes no arguments.  Previously, he had an undocumented argument, <i>revalidate</i> , used by <br>  in private api as a hack for the forced launch of revalidation and related processes, even if <i>$$ lastCommittedViewValue</i> <br>  not updated, but in recent versions it is removed. <br><br><h3>  $ cancelUpdate () </h3><br>  Renamed to <i>$ rollbackViewValue ()</i> . <br><br>  The call allows you to ‚Äúroll back‚Äù <i>$ viewValue</i> to the state <i>$$ lastCommittedViewValue</i> , cancel all <i>debounce</i> processes that are in progress, and redraw the view (for example, input). <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text">  <strong>&lt;1.3:</strong> <br><pre> <code class="javascript hljs">$scope.resetWithCancel = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ $scope.myForm.myInput.$cancelUpdate(); $scope.myValue = <span class="hljs-string"><span class="hljs-string">''</span></span>; };</code> </pre><br><br>  <strong>1.3+:</strong> <br><pre> <code class="javascript hljs">$scope.resetWithCancel = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) </span></span>{ $scope.myForm.myInput.$rollbackViewValue(); $scope.myValue = <span class="hljs-string"><span class="hljs-string">''</span></span>; };</code> </pre><br></div></div><br><h3>  input: date, time, datetime-local, month, week </h3><br>  Since version <strong>1.3,</strong> Angulyar normally supports HTML5 inputs associated with numbers. <br><br>  In the <i>ng-model of</i> such inputs there must be a strictly <i>Date</i> object <br><br>  In older browsers that do not support these inputs, the user will see the text.  In such cases, he will have to enter the correct ISO format for the required date. <br><hr><br><h2>  Validation </h2><br><h3>  $ Error collection </h3>  <a href="https://github.com/angular/angular.js/commit/6046e14bd22491168116e61ffdf5fd3fed5f135c">[commit]</a> <br><br>  Previously, arbitrary properties could be stored in <i>$ error by</i> controlling the validity of the control manually via <i>$ setValidity</i> . <br><br>  Starting with version <strong>1.3</strong> , final validation depends on whether the <i>$ error</i> hash is empty.  Throwing a property into <i>ngModelCtrl. $ Error</i> manually and not removing it from there manually, you will get permanently invalid control, regardless of the value of this property. <br><br><h3>  result in $ setValidity </h3>  <a href="https://github.com/angular/angular.js/commit/6046e14bd22491168116e61ffdf5fd3fed5f135c">[commit]</a> <br><br>  <i>$ setValidity</i> allows <i>you</i> to set the validity of certain properties of the control, taking two arguments: <i>name</i> and <i>result</i> . <br><br>  Previously, <i>result was</i> always cast to <i>true</i> or <i>false</i> , regardless of what was passed there. <br><br>  Starting with version <strong>1.3</strong> , <i>$ setValidity</i> begins to distinguish between <i>false</i> , <i>undefined</i> and <i>null</i> passed to <i>result</i> .  It is necessary now to take care of the fact that the <i>result is</i> exactly the boolean value. <br><br>  The values <i>undefined</i> and <i>null</i> are used, for example, internally for asynchronous validators.  So, if not all synchronous validators are valid, then the asynchronous values ‚Äã‚Äãwill be set to <i>null</i> .  If the synchronous validators are ready and asynchronous validation has begun, then as long as the <i>pending</i> is going on, the value of the validator will be set to <i>undefined</i> . <br><br><h3>  $ parsers and undefined. </h3>  <a href="https://github.com/angular/angular.js/commit/92f05e5a5900713301e64373d7b7daa45a88278b">[commit]</a> <br><br>  Previously, you could prokidykivat <i>undefined</i> in the chain <i>$ parsers</i> if, for example, you want to break it. <br><br>  Starting with version <strong>1.3</strong> , the parsers no longer handle <i>undefined</i> and make the control invalid, setting the value <i>{parse: true}</i> to <i>$ error</i> . <br><br>  This is done to prevent parsers from running in cases where <i>$ viewValue</i> ( <a href="https://github.com/angular/angular.js/issues/9106">not yet installed</a> ) <br><br><h3>  ngPattern </h3>  <a href="https://github.com/angular/angular.js/commit/0e001084ffff8674efad289d37cb16cc4e46b50a">[commit]</a> <br><br>  Starting from <strong>1.4.5</strong> , the <i>ngPattern</i> directive performs validation based on <i>$ viewValue</i> (previously based on <i>$ modelValue</i> ), before the <i>$ parsers</i> chain <i>works</i> . <br><br>  This is related to the <a href="https://github.com/angular/angular.js/issues/12344">problem</a> when <i>input [date]</i> and <i>input [number] are</i> not validated due to the fact that the parsers have converted <i>$ viewValue</i> to <i>Date</i> and <i>Number</i> respectively. <br><br>  If you use <i>$ viewValue</i> modifiers with this directive and you need to check <i>$ modelValue</i> as before, then you should use a custom directive. <br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> .directive(<span class="hljs-string"><span class="hljs-string">'patternModelOverwrite'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">patternModelOverwriteDirective</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-attr"><span class="hljs-attr">require</span></span>: <span class="hljs-string"><span class="hljs-string">'?ngModel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">priority</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-attr"><span class="hljs-attr">compile</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> regexp, patternExp; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">pre</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, elm, attr, ctrl</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ctrl) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; attr.$observe(<span class="hljs-string"><span class="hljs-string">'pattern'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">regex</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** * The built-in directive will call our overwritten validator * (see below). We just need to update the regex. * The preLink fn guaranetees our observer is called first. */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isString(regex) &amp;&amp; regex.length &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { regex = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">RegExp</span></span>(<span class="hljs-string"><span class="hljs-string">'^'</span></span> + regex + <span class="hljs-string"><span class="hljs-string">'$'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (regex &amp;&amp; !regex.test) { <span class="hljs-comment"><span class="hljs-comment">//The built-in validator will throw at this point return; } regexp = regex || undefined; }); }, post: function(scope, elm, attr, ctrl) { if (!ctrl) return; regexp, patternExp = attr.ngPattern || attr.pattern; //The postLink fn guarantees we overwrite the built-in pattern validator ctrl.$validators.pattern = function(value) { return ctrl.$isEmpty(value) || isUndefined(regexp) || regexp.test(value); }; } }; } }; });</span></span></code> </pre><br></div></div><br><h3>  ngMinlength / ngMaxlength </h3><br>  Starting from <strong>1.3</strong> , the <i>ngMinlength</i> and <i>ngMaxlength directives</i> perform validation based on <i>$ viewValue</i> (previously based on <i>$ modelValue</i> ). <br><br>  This can lead to incorrect validation when using these directives along with directives that modify the <i>$ viewValue</i> , for example, the masks for entering the phone. <br><br>  To avoid problems, there are two solutions: <br><br><ol><li>  Change the number of maximum characters in accordance with <i>$ viewValue</i> (for example, masks of the form ‚Äúxx-xx‚Äù, if the model contains only ‚Äúxxxx‚Äù, should be taken into account as <i>maxlength = ‚Äú5‚Äù</i> , not 4, as it was before) <br></li><li>  Use your own custom directives that check <i>$ modelValue</i> .  However, there may be problems with <i>maxlength</i> , because, according to the specification, it limits the number of characters entered, so you have to implement your limit. <br></li></ol><br><br>  I recommend for most cases to use the first option as the least problematic. <br>  The second option may be useful for minLength.  In cases when there is an optional mask with input where n characters are pre-entered (for example, phone with the set "+7" installed), this is due to the fact that minLength does not validate the field only as long as it is empty. <br><br><div class="spoiler">  <b class="spoiler_title">Custom maxlength example</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">angular</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>; angular .module(<span class="hljs-string"><span class="hljs-string">'mainModule'</span></span>) .directive(<span class="hljs-string"><span class="hljs-string">'maxModelLength'</span></span>, maxlengthDirective); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">maxlengthDirective</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-attr"><span class="hljs-attr">require</span></span>: <span class="hljs-string"><span class="hljs-string">'?ngModel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, elm, attr, ctrl</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ctrl) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> maxlength = <span class="hljs-number"><span class="hljs-number">-1</span></span>; attr.$observe(<span class="hljs-string"><span class="hljs-string">'maxModelLength'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> intVal = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value); maxlength = <span class="hljs-built_in"><span class="hljs-built_in">isNaN</span></span>(intVal) ? <span class="hljs-number"><span class="hljs-number">-1</span></span> : intVal; ctrl.$validate(); }); ctrl.$validators.maxlength = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">modelValue, viewValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (maxlength &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) || ctrl.$isEmpty(modelValue) || (<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(modelValue).length &lt;= maxlength); }; <span class="hljs-comment"><span class="hljs-comment">/* *  ,      - maxlength *      ,      * */</span></span> elm.bind(<span class="hljs-string"><span class="hljs-string">'keydown keypress'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> stringModel = <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(ctrl.$modelValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxlength &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; !ctrl.$isEmpty(ctrl.$modelValue) &amp;&amp; stringModel.length &gt;= maxlength) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ([<span class="hljs-number"><span class="hljs-number">8</span></span>, <span class="hljs-number"><span class="hljs-number">37</span></span>, <span class="hljs-number"><span class="hljs-number">38</span></span>, <span class="hljs-number"><span class="hljs-number">39</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>, <span class="hljs-number"><span class="hljs-number">46</span></span>].indexOf(event.keyCode) === <span class="hljs-number"><span class="hljs-number">-1</span></span>) { event.preventDefault(); } } }); } }; } })(angular);</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Custom minlength example</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">angular</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-string"><span class="hljs-string">'use strict'</span></span>; angular .module(<span class="hljs-string"><span class="hljs-string">'mainModule'</span></span>) .directive(<span class="hljs-string"><span class="hljs-string">'minModelLength'</span></span>, minlengthDirective); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">minlengthDirective</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">restrict</span></span>: <span class="hljs-string"><span class="hljs-string">'A'</span></span>, <span class="hljs-attr"><span class="hljs-attr">require</span></span>: <span class="hljs-string"><span class="hljs-string">'?ngModel'</span></span>, <span class="hljs-attr"><span class="hljs-attr">link</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">scope, elm, attr, ctrl</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ctrl) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> minlength = <span class="hljs-number"><span class="hljs-number">0</span></span>; attr.$observe(<span class="hljs-string"><span class="hljs-string">'minModelLength'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">) </span></span>{ minlength = <span class="hljs-built_in"><span class="hljs-built_in">parseInt</span></span>(value) || <span class="hljs-number"><span class="hljs-number">0</span></span>; ctrl.$validate(); }); ctrl.$validators.minlength = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">modelValue, viewValue</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ctrl.$isEmpty(modelValue) || <span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(modelValue).length &gt;= minlength; }; } }; } })(angular);</code> </pre><br></div></div><br>  <strong>Virtual ngModel issue:</strong> <br><br>  If you use ngMinlength / ngMaxlength on an element that is not intended for direct data entry (for example, at the root of a directive that contains several inputs that work with the root <i>ngModel</i> ), and use numerical data, you will get incorrect data validation (there will always be an error) . <br><br>  More specifically, a <i>number</i> will always be stored in <i>$ viewValue</i> , which the validator cannot verify, since  can't get it <i>.length</i> . <br><br><div class="spoiler">  <b class="spoiler_title">Why it happens?</b> <div class="spoiler_text">  The <i>$ compile</i> contains the main directives.  For example, for <i>input</i> and <i>textarea</i> , the <i>inputDirective</i> control is <i>called</i> , which takes <i>attr.type</i> and, based on it, calls one of the functions in the <i>inputType</i> collection.  For text types, this is, respectively, <i>textInputType</i> , it, in turn, passes our control to the function <i>stringBasedInputType</i> , which adds to <i>$ formatters the</i> code for converting our value to a string. <br><br>  When <i>ngModel is</i> not tied to some existing base element like <i>input</i> , but, for example, hangs on a simple diva or custom directive, the data is thrown into the <i>$ viewModel</i> ‚Äúas it is‚Äù, without additional conversion to the string, which causes an error in the directives filters like <i>ngMaxlength</i> . <br><br>  Based on this, all custom directives that work with numbers must have the appropriate formatter for converting numbers to strings. <br><br>  <a href="http://embed.plnkr.co/kLDwFg9BtbkdfoSeE7qa">Working example on Plunker</a> . <br></div></div><br><hr><br><h2>  Scopes and Digests </h2><br><h3>  $ id </h3><br>  Now integer compounded. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, due to fears that the numbers might not be enough to count the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scope</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's, they decided to use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ id for the</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> string (and in fact it is an array of the form [' 0 ',' 0 ',' 0 ']), but the concerns about this the bill didn't come true. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead, we got some extra load (adds a few milliseconds) when creating a large amount of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">scope</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 's (for example, when working with large tables). </font><font style="vertical-align: inherit;">Going to prime numbers solves this problem.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"> <strong>&lt;1.3:</strong> <a href="http://embed.plnkr.co/Ivovz13sVj1uPgPGKD7t/preview">[  Plunker]</a> <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log($rootScope.$id); <span class="hljs-comment"><span class="hljs-comment">// =&gt; 001</span></span></code> </pre><br> <strong>1.3+:</strong> <a href="http://embed.plnkr.co/FUlXo9L34hYsVbGEsxUZ/preview">[  Plunker]</a> <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log($rootScope.$id); <span class="hljs-comment"><span class="hljs-comment">// =&gt; 1</span></span></code> </pre><br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> broadcast and emit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now set the currentScope to null as soon as the event reaches the end of the distribution chain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is due to a hard </font><font style="vertical-align: inherit;">-to- </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">track</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bug when using </font><i><font style="vertical-align: inherit;">event.currentScope incorrectly</font></i><font style="vertical-align: inherit;"> , when someone tries to access it from an asynchronous function. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event.currentScope</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in this case was equal to the last </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ scope</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in the chain, imperceptibly leading to incorrect application operation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now in a similar case when using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event.currentScope there</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will be an error. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">For asynchronous access to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event.currentScope, you</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> now need to use </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">event.targetScope</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text">      scope: <br><br><pre> <code class="javascript hljs"> <span class="hljs-number"><span class="hljs-number">001</span></span> ($rootScope) ‚îî <span class="hljs-number"><span class="hljs-number">002</span></span> ($scope <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ParentCtrl) ‚îî <span class="hljs-number"><span class="hljs-number">003</span></span> ($scope <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> ChildCtrl) ‚îî <span class="hljs-number"><span class="hljs-number">004</span></span> ($scope <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> GrandChildCtrl)</code> </pre><br>    <i>customEvent</i>  <i>GrandChildCtrl</i> <br><br> <strong>&lt;1.3:</strong> <a href="http://embed.plnkr.co/q6XCxw/preview">[  Plunker]</a> <br><br><pre> <code class="javascript hljs"> .controller(<span class="hljs-string"><span class="hljs-string">'ParentCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, $timeout</span></span></span><span class="hljs-function">) </span></span>{ $scope.$on(<span class="hljs-string"><span class="hljs-string">'customEvent'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(event.currentScope); <span class="hljs-comment"><span class="hljs-comment">// $id  002 $timeout(function() { console.log(event.targetScope) // =&gt; $id  004 console.log(event.currentScope) // =&gt; $id  001 }); }) }) .controller('ChildCtrl', function($scope, $timeout) { $scope.$on('customEvent', function(event) { console.log(event.currentScope); // $id  003 $timeout(function() { console.log(event.targetScope) // =&gt; $id  004 console.log(event.currentScope) // =&gt; $id  001 }); }) })</span></span></code> </pre><br> <strong>1.3+:</strong> <a href="http://embed.plnkr.co/nAokeD/preview">[  Plunker]</a> <br><br><pre> <code class="javascript hljs"> .controller(<span class="hljs-string"><span class="hljs-string">'ParentCtrl'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$scope, $timeout</span></span></span><span class="hljs-function">) </span></span>{ $scope.$on(<span class="hljs-string"><span class="hljs-string">'customEvent'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(event.currentScope); <span class="hljs-comment"><span class="hljs-comment">// $id  2 $timeout(function() { console.log(event.targetScope) // =&gt; $id  4 console.log(event.currentScope) // =&gt; null }); }) }) .controller('ChildCtrl', function($scope, $timeout) { $scope.$on('customEvent', function(event) { console.log(event.currentScope); // $id  3 $timeout(function() { console.log(event.targetScope) // =&gt; $id  4 console.log(event.currentScope) // =&gt; null }); }) })</span></span></code> </pre><br></div></div><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> http and resource </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> JSON primitives </font></font></h3> <a href="https://github.com/angular/angular.js/commit/7b6c1d08aceba6704a40302f373400aed9ed0e0b"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[commit]</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Starting with version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , responses with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Content-Type: application / json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> containing primitives start parsing as JSON. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In general, this is a bug fix, it allows you to avoid some crutches when working with the answer, but in some cases it may break the existing code.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text">     <i>¬´OK¬ª</i> , ,    . <br><br> <strong>&lt;1.3:</strong> <br><br><pre> <code class="javascript hljs"> response === <span class="hljs-string"><span class="hljs-string">'OK'</span></span> <span class="hljs-comment"><span class="hljs-comment">// =&gt; false response === '"OK"' // =&gt; true</span></span></code> </pre><br> <strong>1.3+:</strong> <br><br><pre> <code class="javascript hljs"> response === <span class="hljs-string"><span class="hljs-string">'OK'</span></span> <span class="hljs-comment"><span class="hljs-comment">// =&gt; true response === '"OK"' // =&gt; false</span></span></code> </pre><br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ http transformRequest </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting with version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the transformRequest function is no longer supported and does not change the request headers. </font><font style="vertical-align: inherit;">Instead, use the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">headers</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> property </font><font style="vertical-align: inherit;">and the getter functions corresponding to the desired header </font><font style="vertical-align: inherit;">in the request parameters </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The function of the first argument pretends to object </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">the config</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , which allows to determine and establish the headlines dynamically.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text">     'X-MY_HEADER' <br><br> <strong>&lt;1.4:</strong> <br><br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">requestTransform</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data, headers</span></span></span><span class="hljs-function">) </span></span>{ headers = angular.extend(headers(), { <span class="hljs-string"><span class="hljs-string">'X-MY_HEADER'</span></span>: <span class="hljs-string"><span class="hljs-string">'test'</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> angular.toJson(data); }</code> </pre><br> <strong>1.4+:</strong> <br><br><pre> <code class="javascript hljs"> $http.get(url, { <span class="hljs-attr"><span class="hljs-attr">headers</span></span>: { <span class="hljs-string"><span class="hljs-string">'X-MY_HEADER'</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">config</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span>; } } })</code> </pre><br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ http interceptor </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">responseInterceptors</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> collection </font><font style="vertical-align: inherit;">in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ httpProvider</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> already had the status of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deprecated</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and had two different APIs (one of which is not completely obvious), which led to various embarrassments. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting with version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , this collection [deleted], as well as its functionality. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead, a new, transparent API is available for registering interceptors.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text">  <i>myHttpInterceptor</i>        . <br><br> <strong>&lt; 1.3:</strong> <a href="http://embed.plnkr.co/q6XCxw/preview">[  Plunker]</a> <br><br><pre> <code class="javascript hljs"> $provide.factory(<span class="hljs-string"><span class="hljs-string">'myHttpInterceptor'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$q, dependency1, dependency2</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promise</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> promise.then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  success return response; }, function(response) { //  error if (canRecover(response)) { return responseOrNewPromise } return $q.reject(response); }); } }); $httpProvider.responseInterceptors.push('myHttpInterceptor');</span></span></code> </pre><br> <strong>1.3+:</strong> <a href="http://embed.plnkr.co/nAokeD/preview">[  Plunker]</a> <br><br><pre> <code class="javascript hljs"> $provide.factory(<span class="hljs-string"><span class="hljs-string">'myHttpInterceptor'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$q</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">response</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">response</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  success return response; }, responseError: function(response) { //  error if (canRecover(response)) { return responseOrNewPromise } return $q.reject(response); } }; }); $httpProvider.interceptors.push('myHttpInterceptor');</span></span></code> </pre><br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ httpBackend and JSONP </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now the angular catches errors in the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">‚Äúsuccess‚Äù</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> events, an empty response (missing data in the callback) in JSONP does not lead to an error (it previously generated an error and set the status to -2).</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is interesting to know (or not) that:</font></font></b> <div class="spoiler_text">     <i>onload</i>  <i>onerror</i>    JSONP <i>script</i> . <br>     <i>jQuery</i>        <i>event</i> . <br><br>    ,    ,    . <br><br>       <i>$.data(¬´events¬ª)</i> ,      <i>jqLite</i>  . <br></div></div><br> <strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">IE8:</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">onreadystatechanged</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> event is no longer supported </font><font style="vertical-align: inherit;">.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ resource </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you call </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toJson ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ resource</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> instance </font><font style="vertical-align: inherit;">, it will contain the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ promise</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> and </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ resolved</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> properties </font><font style="vertical-align: inherit;">that were previously cut during serialization, as well as all properties starting with a single </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">According </font></font><a href="https://github.com/angular/angular.js/commit/c054288c9722875e3595e6e6162193e0fb67a251"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">to</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">toJson ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> change </font><a href="https://github.com/angular/angular.js/commit/c054288c9722875e3595e6e6162193e0fb67a251"><font style="vertical-align: inherit;">described above</font></a><font style="vertical-align: inherit;"> , properties starting with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> are no longer serialized. Now only those properties that start with </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$$ are</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> serialized </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Based on this, it can be expected that the serialized </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ resource</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> will contain these properties, but this is not the case. Specifically, </font></font><a href="https://github.com/angular/angular.js/commit/d3c50c845671f0f8bcc3f7842df9e2fb1d1b1c40"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">he cuts</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> these two properties </font><font style="vertical-align: inherit;">during the serialization itself.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">All other properties, including those added by the user, will be serialized and will be contained in the final </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">json</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ inject </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modules: .config () and .provider () </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, it was possible to call .config () before .provider () worked. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Since version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , this behavior is impossible, .config () will always be called only after all the .provider () modules have worked.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text"><pre> <code class="javascript hljs"> app .provider(<span class="hljs-string"><span class="hljs-string">'$rootProvider1'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Provider 1'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$get = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; }) .config(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Config'</span></span>); }) .provider(<span class="hljs-string"><span class="hljs-string">'$rootProvider2'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Provider 2'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$get = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{}; });</code> </pre><br> <strong>&lt;1.3:</strong> <a href="http://embed.plnkr.co/L0og4KjoHSMvqYHsP68f/preview">[  Plunker]</a> <br><br>  <i>Provider 1, Config, Provider 2</i> <br><br> <strong>1.3+:</strong> <a href="http://embed.plnkr.co/lZKQNt/preview">[  Plunker]</a> <br><br>  <i>Provider 1, Provider 2, Config</i> <br></div></div><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ngAnimate </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> All methods </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, for all </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ animate</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> methods, the </font><font style="vertical-align: inherit;">last argument was a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">done</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> callback </font><font style="vertical-align: inherit;">, which was executed at the end of the animation. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting with version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.3</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , a set of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">options</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> styles is passed there </font><font style="vertical-align: inherit;">, which is applied to the element. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Instead of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">done,</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> all functions now return a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">promise</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> whose </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resolve</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> means the completion of the animation.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> animate.enter () and animate.move () </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">These methods have four arguments (element, parent, after, options). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Previously, if the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argument </font><font style="vertical-align: inherit;">was not specified, then a new element was added after the specified </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">element</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , and if it was specified, after </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The problem is that with a similar API it is impossible to add a new element to the beginning of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> container </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting </font></font><a href="https://github.com/angular/angular.js/commit/1cb8584e8490ecdb1b410a8846c4478c6c2c0e53"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">with version 1.3</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , if the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">after</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> argument is </font><font style="vertical-align: inherit;">not specified, then this element is added to the beginning of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">parent</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> container </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Accordingly, it is now necessary to always indicate after which particular element you want to insert a new one.</font></font><br><br><div class="spoiler">  <b class="spoiler_title">For example:</b> <div class="spoiler_text">     <i>$animate.enter</i> <br><br> <strong>&lt;1.3:</strong> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//     `element` `$animate.enter(element, parent);`</span></span></code> </pre><br> <strong>1.3+:</strong> <br><br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">//      `parent` `$animate.enter(element, parent);` //     `element` `$animate.enter(element, parent, angular.element(parent[0].lastChild));`</span></span></code> </pre><br></div></div><br><hr><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Filters </font></font></h2><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Internal context </font></font></h3> <a href="https://github.com/angular/angular.js/commit/8863b9d04c722b278fa93c5d66ad1e578ad6eb1f"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[commit]</font></font></a> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Previously, all filters had an undocumented feature: the internal context of their control </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">this</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> referred to </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ scope</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> in which this filter was invoked.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Why you can not do this, and how to do it correctly:</font></font></b> <div class="spoiler_text">      , ,     <i>$scope</i>  .  ,             <i>ng-repeat</i> . <br><br>   Andy Joslin's    : <br><br><pre> <code class="javascript hljs"> yourModule.filter(<span class="hljs-string"><span class="hljs-string">"as"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">$parse</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value, path</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $parse(path).assign(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, value); }; });</code> </pre><br>    <strong>1.3</strong> , <i>$scope</i>        ( <i>this</i> )   <i>undefined</i> . <br><br>   <i>$scope</i>        ,  **       **,   <i>$scope</i>       10%,   <i>$scope</i>         <i>$digest</i>      <br> <i>Error: 10 $digest() iterations reached. Aborting!</i>  . <br><br> <strong>      :</strong> <br><br><ul><li>     :   ,      . </li><li>      <i>$scope</i>        . </li></ul><br> <strong>        ng-repeat:</strong> <br><br>    <i>item in (filterResults = (items | filter:query))</i>  ,  ,    <i>as</i> : <i>item in items | filter:query as filterResults)</i> . <br></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filter </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now it works only with arrays. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">With version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4,</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> an attempt to call a </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">filter</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on an object will result in an error. </font><font style="vertical-align: inherit;">Previously, it simply "quietly" returned an empty array. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">To iterate over an object, it is proposed to use </font></font><a href="https://github.com/petebacondarwin/angular-toArrayFilter"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">custom</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> filters that convert the object into an array.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> limitTo </font></font></h3><br> ,   <i>limitTo</i>    (, <i>undefined</i> ),       . <br><br>    <strong>1.4</strong> ,         , ..      . <br><hr><br><h2> ngCookies </h2><br><h3> $cookies </h3><br>    <strong>1.4</strong> ,          <i>$cookies</i> ,        /,     API    : <br><br><ul><li> <i>get</i> </li><li> <i>put</i> </li><li> <i>getObject</i> </li><li> <i>putObject</i> </li><li> <i>getAll</i> </li><li> <i>remove</i> </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is due to data synchronization bugs, when there are no longer actual data in the object. </font><font style="vertical-align: inherit;">Which means that you can no longer use votchery, tracking changes </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cookies</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> through an object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Such manipulations were necessary in the past, for example, for communication between browser tabs, but these days there are more convenient tools, such as </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">localStorage</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> $ cookieStore </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Starting from version </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1.4</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cookieStore</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">received the status of </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">deprecated</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , all useful logic was transferred to the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cookies</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">, and the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cookieStore request</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> now returns the instance of the </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ cookies</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> service </font><font style="vertical-align: inherit;">.</font></font><br><hr><br><h2>  Conclusion: </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">There will be no problems with the transition unless the project uses an excessive number of </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">crutches of</font></font></s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> non-trivial solutions based on bugs and undocumented features of the framework. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It will be completely painless for those who have not used the means of an angular to animate and validate the application. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In the next article I will talk about all the benefits of new versions and how to improve performance with their help. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you have met with any other interesting problems during the transition, please share them in the comments.</font></font></div><p>Source: <a href="https://habr.com/ru/post/268265/">https://habr.com/ru/post/268265/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../268251/index.html">Welcome to GDG DevFest Voronezh 2015</a></li>
<li><a href="../268253/index.html">Usability Authorization Forms</a></li>
<li><a href="../268257/index.html">Integration of CoreSpotlight on the example of "Rambler. Mail"</a></li>
<li><a href="../268259/index.html">The problem of cheats in online games</a></li>
<li><a href="../268261/index.html">Three-Way Bitwise Quick Sort</a></li>
<li><a href="../268267/index.html">Sometimes less is better - why only Google authorization? + channel Rusbase</a></li>
<li><a href="../268269/index.html">Why I chose Yii2</a></li>
<li><a href="../268271/index.html">ECFG: put ~ / .emacs on a diet</a></li>
<li><a href="../268273/index.html">Compalex: comparing schemas of two databases</a></li>
<li><a href="../268275/index.html">Why the Internet needs IPFS before it's too late</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>