<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>MAM: front-end assembly without pain</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello, my name is Dmitry Karlovsky, and I ... adore MAM. M AM governs A gnostic M moduli, saving me from the lion's share of the routine. 





 The A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>MAM: front-end assembly without pain</h1><div class="post__text post__text-html js-mediator-article"><p>  Hello, my name is Dmitry Karlovsky, and I ... adore MAM.  <strong>M</strong> AM governs <strong>A</strong> gnostic <strong>M</strong> moduli, saving me from the lion's share of the routine. </p><br><p><img src="https://habrastorage.org/webt/m2/5h/ps/m25hpsfevki-o6lwx4v_ukfxvtu.png" alt="Typical Agnostic Module"></p><br><p> <strong>The Agnostic Module</strong> , unlike the traditional one, is not a source file, but a directory within which there can be source codes in various languages: program logic on <code>JS</code> / <code>TS</code> , tests for it on <code>TS</code> / <code>JS</code> , composition of components on <code>view.tree</code> , styles on <code>CSS</code> , localization in <code>locale=*.json</code> , images, etc., and so on.  If desired, it is not difficult to fasten support for any other language.  For example, Stylus for writing styles, or HTML for describing templates. </p><br><p>  Dependencies between modules are tracked automatically by analyzing the sources.  If the module is turned on, then it is turned on entirely - each source of the module is transpiled and falls into the corresponding bundle: scripts - separately, styles - separately, tests - separately.  For different platforms - their own bundles: for nodes - their own, for the browser - their own. </p><br><p>  Full automation, the lack of configuration and boilerplate, the minimum size of bundles, automatic extrusion of dependencies, the development of hundreds of alienable libraries and applications in the same code base without pain and suffering.  <strong>Wow, what a drug addiction!</strong>  Remove from the monitors pregnant, faint of heart, children and welcome to the submarine! </p><a name="habracut"></a><br><h1 id="filosofiya">  Philosophy </h1><br><p>  MAM is a bold experiment to radically change the way the code is organized and how it is handled.  Here are the basic principles: </p><br><p>  <strong>Conventions instead of configuring.</strong>  Reasonable, simple and universal agreements allow you to automate the entire routine, while maintaining convenience and uniformity between different projects. </p><br><p>  <strong>Infrastructure separately, code separately.</strong>  It is not uncommon to develop dozens or even hundreds of libraries and applications.  Do not deploy the same infrastructure assembly, development, deployment and TP for each of them.  It is enough to set it once and then rivet applications like patties. </p><br><p>  <strong>Do not pay for what you do not use.</strong>  You use some kind of module - it is included in the bundle with all its dependencies.  Do not use - does not turn on.  The smaller the modules, the greater the granularity and less extra code in the bundle. </p><br><p>  <strong>Minimum excess code.</strong>  Breaking code into modules should be as easy as writing all code in one file.  Otherwise, the developer will be lazy to break large modules into small ones. </p><br><p>  <strong>No version conflicts.</strong>  There is only one version - current.  There is no need to spend resources on support of old versions if it is possible to spend them on actualization of the last. </p><br><p>  <strong>Keep your finger on the pulse.</strong>  The fastest possible feedback regarding incompatibilities will not allow the code to rot. </p><br><p>  <strong>The easiest way is the surest one.</strong>  If the right way requires additional efforts, then be sure that no one will go. </p><br><h1 id="importyeksporty">  Import / Export </h1><br><p>  We open the first available project using a modern system of modules: <a href="">The module is less than 300 lines, 30 of them are imports.</a> </p><br><p>  But these are flowers: <a href="">A function of 9 lines requires 8 imports.</a> </p><br><p>  And my favorite: <a href="">Not a single line of useful code.</a>  20 lines of shifting values ‚Äã‚Äãfrom a heap of modules to one, then to import from one module, and not from twenty. </p><br><p>  All this is a boilerplate, which leads to the fact that developers are lazy to allocate small pieces of code into separate modules, preferring large modules to small ones.  And even if they are not lazy, it turns out either a lot of code for importing small modules, or special modules that import many modules into themselves and export them all in a crowd. </p><br><p>  All this leads to low granularity of the code and bloat of unused code sizes, which are lucky to be close to the one used.  This problem for JS is at least trying to be solved by complicating the assembly pipeline by adding the so-called "tree-shaking", cutting out the excess from what you imported.  This slows down the assembly, but cuts away not everything. </p><br><p>  Idea: <strong>What if we don‚Äôt import, but just take and use, and the assembler already understands what needs to be imported?</strong> </p><br><p>  Modern IDEs can automatically generate imports for the entities you use.  If an IDE can do this, then what's stopping the assembler from doing this?  It is enough to have a simple naming and file arrangement that is convenient for the user and understandable to the machine.  In PHP, there has long been such a standard convention: <a href="https://www.php-fig.org/psr/psr-4/">PSR-4</a> .  MAM introduces the same for <em>.ts and</em> .jam.js files: names starting with $ are a <a href="https://en.wikipedia.org/wiki/Fully_qualified_name">Fully Qualified Name of</a> a global entity whose code is loaded along the path obtained from the FQN by replacing separators with slashes.  A simple example of two modules: </p><br><p>  <strong>my / alert / alert.ts</strong> </p><br><pre> <code class="plaintext hljs">const $my_alert = alert // FQN   </code> </pre> <br><p>  <strong>my / app / app.ts</strong> </p><br><pre> <code class="plaintext hljs">$my_alert( 'Hello!' ) // ,   /my/alert/</code> </pre> <br><p>  A whole module from one line - what could be simpler?  The result is not long in coming: the simplicity of creating and using modules leads to minimization of their size.  As a result - to maximize the granularity.  And like a cherry - minimizing the size of bundles without any tree-shaking. </p><br><p>  A good example is the JSON <a href="https://github.com/eigenmethod/mol/tree/master/data">/ mol / data</a> family of validation modules.  If you use the <code>$mol_data_integer</code> function anywhere in your code, then the <code>/mol/data/integer</code> and <code>/mol/data/number</code> modules on which <code>$mol_data_integer</code> depends will be included in the bundle.  But, for example, the <code>/mol/data/email</code> collector will not even read from the disk, since nobody depends on it. </p><br><h1 id="razgrebaya-bardak">  Raking a mess </h1><br><p>  Since we started to kick Angular, we will not stop.  What do you think, where to look for the declaration of the <code>applyStyles</code> function?  You would never guess in <a href=""><code>/packages/core/src/render3/styling_next/bindings.ts</code></a> .  The ability to put anything anywhere leads to the fact that in each project we observe a unique file layout system, often incapable of any logic.  And if the IDE often saves the "jump to the definition", then viewing the code on the githaba or reviewing the pullrexest is deprived of this possibility. </p><br><p>  Idea: <strong>What if entity names strictly correspond to their location?</strong> </p><br><p>  To place the code in the file / <code>/angular/packages/core/src/render3/stylingNext/bindings.ts</code> .  But the names in the code you want to see short and concise, so the developer will try to exclude all unnecessary from the name, leaving only the important: <code>$angular_render3_applyStyles</code> .  And it will be located respectively in <code>/angular/render3/applyStyles/applyStyles.ts</code> . </p><br><p>  Notice how MAM uses the weaknesses of the developers to achieve the desired result: each entity has a short, globally unique name that can be used in any context.  For example, in the <a href="https://github.com/eigenmethod/mol/commits/master">messages of komitov</a> these names allow you to quickly and accurately catch what they are: </p><br><pre> <code class="plaintext hljs">73ebc45e517ffcc3dcce53f5b39b6d06fc95cae1 $mol_vector: range expanding support 3a843b2cb77be19688324eeb72bd090d350a6cc3 $mol_data: allowed transformations 24576f087133a18e0c9f31e0d61052265fd8a31a $mol_data_record: support recursion</code> </pre> <br><p>  Or, say, you want to <a href="https://www.google.com/search%3Fq%3D%2524mol_fiber">find all the references to the $ mol_fiber module on the Internet</a> - to make it easier than ever, thanks to FQN. </p><br><h1 id="ciklicheskie-zavisimosti">  Cyclic dependencies </h1><br><p>  Let's write in one file 7 lines of simple code: </p><br><pre> <code class="plaintext hljs">export class Foo { get bar() { return new Bar(); } } export class Bar extends Foo {} console.log(new Foo().bar);</code> </pre> <br><p>  Despite the cyclical dependency, it works correctly.  We divide it into 3 files: </p><br><p>  <strong>my / foo.js</strong> </p><br><pre> <code class="plaintext hljs">import { Bar } from './bar.js'; export class Foo { get bar() { return new Bar(); } }</code> </pre> <br><p>  <strong>my / bar.js</strong> </p><br><pre> <code class="plaintext hljs">import { Foo } from './foo.js'; export class Bar extends Foo {}</code> </pre> <br><p>  <strong>my / app.js</strong> </p><br><pre> <code class="plaintext hljs">import { Foo } from './foo.js'; console.log(new Foo().bar);</code> </pre> <br><p>  Opa, <code>ReferenceError: Cannot access 'Foo' before initialization</code> .  What kind of nonsense?  To fix this, our <code>app.js</code> needs to know that <code>foo.js</code> depends on <code>bar.js</code>  Therefore, we must first import <code>bar.js</code> , which imports <code>foo.js</code>  After that we can import <code>foo.js</code> without error: </p><br><p>  <strong>my / app.js</strong> </p><br><pre> <code class="plaintext hljs">import './bar.js'; import { Foo } from './foo.js'; console.log(new Foo().bar);</code> </pre> <br><p>  What browsers, what NodeJS, what Webpack, what Parcel - all of them work crookedly with circular dependencies.  And it would be okay if they simply forbade them - one could immediately complicate the code so that there were no cycles.  But they can work normally, and then bang, and give an incomprehensible error. </p><br><p>  Idea: <strong>What if during assembly we just stick the files together in the correct order, as if all the code were originally written in one file?</strong> </p><br><p>  Let's divide the code using the principles of MAM: </p><br><p>  <strong>my / foo / foo.ts</strong> </p><br><pre> <code class="plaintext hljs">class $my_foo { get bar() { return new $my_bar(); } }</code> </pre> <br><p>  <strong>my / bar / bar.ts</strong> </p><br><pre> <code class="plaintext hljs">class $my_bar extends $my_foo {}</code> </pre> <br><p>  <strong>my / app / app.ts</strong> </p><br><pre> <code class="plaintext hljs">console.log(new $my_foo().bar);</code> </pre> <br><p>  All the same 7 lines of code that were originally.  And they just work without additional shamanism.  The thing is that the collector understands that the dependence of <code>my/bar</code> on <code>my/foo</code> more rigid than <code>my/foo</code> on <code>my/bar</code> .  This means that these modules should be included in the bundle in this order: <code>my/foo</code> , <code>my/bar</code> , <code>my/app</code> . </p><br><p>  How does a collector understand this?  Now the heuristics is simple - according to the number of indents in the line in which the dependency is found.  Note that the stronger dependency in our example has zero indent, and the weak one double. </p><br><h1 id="raznye-yazyki">  Different languages </h1><br><p>  It so happens that for different things we have different languages ‚Äã‚Äãfor these different things sharpened.  The most common ones are: JS, TS, CSS, HTML, SVG, SCSS, Less, Stylus.  Each has its own system of modules that does not interact with other languages.  What to say about 100,500 types of more specific languages.  As a result, in order to connect a component, you have to separately connect its scripts, separate styles, separately register templates, separately configure the static files needed for it, etc., and so on. </p><br><p>  Webpack thanks to loaders trying to solve this problem.  But his entry point is a script that already includes files in other languages.  And if we do not need a script?  For example, we have a module with beautiful styles for tablets and we want them to have some colors in a light theme, and others in a dark theme: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.dark-theme</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: black; } <span class="hljs-selector-class"><span class="hljs-selector-class">.light-theme</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br><p>  At the same time, if we depend on the topic, then the script should be loaded, which will set the desired topic depending on the time of day.  That is, CSS actually depends on JS. </p><br><p>  Idea: <strong>What if the modular system is language independent?</strong> </p><br><p>  Since in MAM the modular system is separated from languages, the dependencies can be cross-language.  CSS may depend on JS, which may depend on TS, which may depend on another JS.  This is achieved due to the fact that source codes show dependencies on modules, and the modules are connected entirely and can contain source codes in any languages.  In the case of an example with themes, it looks like this: </p><br><p>  <strong>/my/table/table.css</strong> </p><br><pre> <code class="css hljs"><span class="hljs-comment"><span class="hljs-comment">/* ,   /my/theme */</span></span> <span class="hljs-selector-attr"><span class="hljs-selector-attr">[my_theme="dark"]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: black; } <span class="hljs-selector-attr"><span class="hljs-selector-attr">[my_theme="light"]</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">table</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: white; }</code> </pre> <br><p>  <strong>/my/theme/theme.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.documentElement.setAttribute( <span class="hljs-string"><span class="hljs-string">'my_theme'</span></span> , ( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().getHours() + <span class="hljs-number"><span class="hljs-number">15</span></span> ) % <span class="hljs-number"><span class="hljs-number">24</span></span> &lt; <span class="hljs-number"><span class="hljs-number">12</span></span> ? <span class="hljs-string"><span class="hljs-string">'light'</span></span> : <span class="hljs-string"><span class="hljs-string">'dark'</span></span> , )</code> </pre> <br><p>  Using this technique, by the way, you can implement your <a href="https://modernizr.com/">Modernizr</a> , but without 300 checks you don't need, because only those checks that your CSS really depends on will be included in the bundle. </p><br><h1 id="mnogo-bibliotek">  Many libraries </h1><br><p>  Typically, the entry point for assembling a bundle is some kind of file.  In the case of a webpack this is js.  If you are developing a lot of alienable libraries and applications, then you also need a lot of bundles.  And for each bundle you need to create a separate entry point.  In the case of Parcel, the entry point is HTML, which for applications will have to be created anyway.  But for libraries it is somehow not very suitable. </p><br><p>  Idea: <strong>What if any module can be assembled into an independent bundle without prior preparation?</strong> </p><br><p>  Let's build the latest version of the $ mol_build MAM project builder: </p><br><pre> <code class="plaintext hljs">mam mol/build</code> </pre> <br><p>  And now run this collector and let it assemble itself again to make sure that it is still able to assemble itself: </p><br><pre> <code class="plaintext hljs">node mol/build/-/node.js mol/build</code> </pre> <br><p>  Although, no, let's along with the assembly, we ask it to also run the tests: </p><br><pre> <code class="plaintext hljs">node mol/build/-/node.test.js mol/build</code> </pre> <br><p>  And if everything went well, we will publish the result in NPM: </p><br><pre> <code class="plaintext hljs">npm publish mol/build/-</code> </pre> <br><p>  As you can see, when assembling a module, a subdirectory with the name <code>-</code> created <code>-</code> and all the artifacts of the assembly are placed there.  Let's go through the files that can be found there: </p><br><ul><li>  <code>web.dep.json</code> - all information on the dependency graph </li><li>  <code>web.js</code> - browser scripts </li><li>  <code>web.js.map</code> - sorsmapu for him </li><li>  <code>web.esm.js</code> - it's in the form of an es-module </li><li>  <code>web.esm.js.map</code> - and for it sorsmap </li><li>  <code>web.test.js</code> - test bundle </li><li>  <code>web.test.js.map</code> - and for sorsmapu tests </li><li>  <code>web.d.ts</code> - bundle with the types of everything that is in the script bundle </li><li>  <code>web.css</code> - style bundle </li><li>  <code>web.css.map</code> - and sorsmaps for it </li><li>  <code>web.test.html</code> - entry point to run execution tests in the browser </li><li>  <code>web.view.tree</code> - declarations of all components included in the bundle view.tree </li><li>  <code>web.locale=*.json</code> - bundles with localized texts, for each detected language its own bundle </li><li>  <code>package.json</code> - allows you to immediately publish the assembled module in NPM </li><li>  <code>node.dep.json</code> - all information about the dependency graph </li><li>  <code>node.js</code> - bandl scripts for nodes </li><li>  <code>node.js.map</code> - sorsmapy for it </li><li>  <code>node.esm.js</code> - it's in the form of an es-module </li><li>  <code>node.esm.js.map</code> - and for it sorsmap </li><li>  <code>node.test.js</code> - the same bundle, but also with tests </li><li>  <code>node.test.js.map</code> - and for it sorsmap </li><li>  <code>node.d.ts</code> - a bundle with the types of everything in the script bundle </li><li>  <code>node.view.tree</code> - declarations of all components included in the bundle view.tree </li><li>  <code>node.locale=*.json</code> - bundles with localized texts, for each detected language its own bundle </li></ul><br><p>  Statics are simply copied along with the paths.  As an example, take an <a href="http://mol.js.org/app/quine/">application that displays its own source code</a> .  Its sources are here: </p><br><ul><li> <code>/mol/app/quine/quine.view.tree</code> </li> <li> <code>/mol/app/quine/quine.view.ts</code> </li> <li> <code>/mol/app/quine/index.html</code> </li> <li> <code>/mol/app/quine/quine.locale=ru.json</code> </li> </ul><br><p>  Unfortunately, in general, the collector cannot know that we will need these files in runtime.  But we can tell him this by putting a special file next to it: </p><br><p>  <strong>/mol/app/quine/quine.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">deploy \/mol/app/quine/quine.view.tree deploy \/mol/app/quine/quine.view.ts deploy \/mol/app/quine/index.html deploy \/mol/app/quine/quine.locale=ru.json</code> </pre> <br><p>  As a result of the build <code>/mol/app/quine</code> , they will be copied in the following ways: </p><br><ul><li> <code>/mol/app/quine/-/mol/app/quine/quine.view.tree</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/quine.view.ts</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/index.html</code> </li> <li> <code>/mol/app/quine/-/mol/app/quine/quine.locale=ru.json</code> </li> </ul><br><p>  Now the directory <code>/mol/app/quine/-</code> can be put on any static hosting and the application will be fully operational. </p><br><h1 id="celevye-platformy">  Target platforms </h1><br><p>  JS can be executed both on the client and on the server.  And how cool it is to write one code and it will work everywhere.  However, sometimes the implementation of the same thing on the client and the server is completely different.  And I want one implementation to be used for the node, for example, and another for the browser. </p><br><p>  Idea: <strong>What if the file's purpose is reflected in its name?</strong> </p><br><p>  MAM uses a tag system in file names.  For example, the <code>$mol_state_arg</code> module provides access to user-defined application parameters.  In the browser, these parameters are set via the address bar.  And in the node - through the command line arguments.  <code>$mol_sate_arg</code> abstracts the rest of the application from these nuances by implementing both options with a single interface, placing them in files: </p><br><ul><li>  / mol / state / arg / arg.  <strong>web</strong> .ts - implementation for browsers </li><li>  / mol / state / arg / arg.  <strong>node</strong> .ts - implementation for node </li></ul><br><p>  Sources not marked with these tags are included regardless of the target platform. </p><br><p>  A similar situation is observed with the tests - they want to be stored next to the other sources, but I do not want to include them in the bundle that will go to the end user.  Therefore, tests are also marked with a separate tag: </p><br><ul><li>  / mol / state / arg / arg.  <strong>test</strong> .ts - module tests, they will get into the test bundle </li></ul><br><p>  Tags can be parametric.  For example, with each module can go texts in various languages ‚Äã‚Äãand they should be included in the appropriate language bundles.  The text file is a regular JSON dictionary named with a locale in the name: </p><br><ul><li>  / mol / app / life / life.  <strong>locale = en</strong> .json - texts for the Russian language </li><li>  / mol / app / life / life.  <strong>locale = jp</strong> .json - texts for the Japanese language </li></ul><br><p>  Finally, what if we want to place files side by side, but we want the builder to ignore them and not automatically include them in the bundle?  It is enough to add any non-alphanumeric character at the beginning of their name.  For example: </p><br><ul><li>  / hyoo / toys / <strong>.</strong>  git - starts with a dot, so the collector will ignore this directory </li></ul><br><h1 id="versionirovanie">  Versioning </h1><br><p>  First, Google released AngularJS and published it in NPM as <code>angular</code> .  Then he created a completely new framework with a similar name - Angular and published it under the same name, but version 2. Now these two frameworks develop independently.  Only one API breaking change occurs between major versions.  And the other - <a href="">between the minor</a> .  And since it is impossible to put two versions of the same dependency on the same level, then there can be no question of a smooth transition, when two versions of the library coexist at the same time for some time at the same time. </p><br><p>  It seems the Angulyar team has already attacked all possible rakes.  And here's another one: the framework code is broken into several large modules.  At first they versioned them independently, but very quickly even they themselves began to get confused about which versions of the modules were compatible with each other, what to speak of common developers.  Therefore, <a href="https://habr.com/ru/post/318682/">Angular has switched to pass-through versioning</a> , where the major version of the module can change even without any changes in the code.  Supporting multiple versions of multiple modules is a big problem for both the maintainers themselves and the ecosystem as a whole.  After all, a lot of resources of all community members are spent on ensuring compatibility with already outdated modules. </p><br><p>  The beautiful idea of <a href="https://semver.org/">Semantic Versioning is</a> broken about the harsh reality - you never know if something will break if you change a minor version <a href="">or even a patch version</a> .  Therefore, in many projects they fix a specific version of the dependency.  However, such a fixation does not affect transitive dependencies, which can be attracted by the latest version when installed from scratch, but can remain the same if they are already.  This confusion leads to the fact that you can never rely on a fixed version and you regularly need to check compatibility with current versions (at least transitive) dependencies. </p><br><p>  What about <a href="">lock files</a> ?  If you are developing a library that is installed through dependencies, the lock file will not help you, because it will be ignored by the package manager.  For the final application, the lock file will give you a so-called ‚Äúreproducible build‚Äù.  But let's be honest.  How many times do you need to build the final application from the same source?  Exactly once.  Receiving at the output, independent of any NPM, an assembly artifact: an executable binary, a docker-container or just an archive with everything you need to run the code.  I hope you do not do <code>npm install</code> on the prod? </p><br><p>  Some find the use of lock-files in that the CI server collects exactly what the developer commits.  But wait, the developer himself can just collect on his local machine.  Moreover, he must do this to make sure that he has not broken anything. <a href="https://ru.wikipedia.org/wiki/%25D0%259D%25D0%25B5%25D0%25BF%25D1%2580%25D0%25B5%25D1%2580%25D1%258B%25D0%25B2%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B3%25D1%2580%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Continuous Integration is</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> not only and not so much about the assembly, as about checking the compatibility of what one developer wrote with what someone else wrote. </font><font style="vertical-align: inherit;">The concept of CI is to detect incompatibilities as soon as possible, and as a result, to start work to eliminate them as soon as possible.</font></font></p><br><p>        ,     ,  . ,            Angular@4 (  3).  ,     ,  "     "  "     ".      Angular@4     ,      Angular@5.      Angular@6,         .  Angular   TypeScript    .     .  ,   2  ,  ‚Ä¶      ,   business value    ,     ,  ,  ,  . </p><br><p>                   ,    ,       ,   ,       2 .    :      ,  ‚Äî ,  ‚Äî .       3 React, 5 jQuery, 7 lodash. </p><br><p> : <strong>         ‚Äî ?</strong> </p><br><p>         .     -   .     ,       .     ,     .  ,    .  ,       .        ,    .   ,        ,            .      :  issue,    ,  workaround,  pull request,    ,      .          ,    ,    .        .            . </p><br><p>               ,        . ,        ,       .        .        .  :  ,       ,     -.     -      ‚Äî       .  ,            ,    -  .         , ,  ,   NPM <a href="https://renovatebot.com/"> </a>     .  ,      .       . </p><br><p>         ,      ?   ‚Äî   .  <code>mobx</code> ,  <code>mobx2</code>     API  .   ‚Äî    ,    :     ,       .     <code>mobx</code>        <code>mobx2</code> ,      API.         API,     . </p><br><p>        .           ‚Äî .  ,      : </p><br><pre> <code class="plaintext hljs">var pages_count = $mol_atom2_sync( ()=&gt; $lib_pdfjs.getDocument( uri ).promise ).document().numPages</code> </pre> <br><p>  <strong> </strong>   <code>mol_atom2_sync</code>  <code>lib_pdfjs</code> ,      : </p><br><pre> <code class="plaintext hljs">npm install mol_atom2_sync@2.1 lib_pdfjs@5.6</code> </pre> <br><p> ,   , ‚Äî   ,       .        ?    ‚Äî    ,    <code>*.meta.tree</code> ,          : </p><br><p> <strong>/.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">pack node git \https://github.com/nin-jin/pms-node.git pack mol git \https://github.com/eigenmethod/mol.git pack lib git \https://github.com/eigenmethod/mam-lib.git</code> </pre> <br><p>    .             . </p><br><h1 id="integraciya-s-npm">   NPM </h1><br><p> MAM ‚Äî    NPM . ,         ‚Äî . ,    ,     NPM      . </p><br><p>          NPM ,     $node. ,   -        -: </p><br><p> <strong>/my/app/app.ts</strong> </p><br><pre> <code class="plaintext hljs">$node.portastic.find({ min : 8080 , max : 8100 , retrieve : 1 }).then( ( ports : number[] ) =&gt; { $node.express().listen( ports[0] ) })</code> </pre> <br><p>       ,     . -    <code>lib</code>      NPM . ,     NPM- <code>pdfjs-dist</code> : </p><br><p> <strong>/lib/pdfjs/pdfjs.ts</strong> </p><br><pre> <code class="plaintext hljs">namespace $ { export let $lib_pdfjs : typeof import( 'pdfjs-dist' ) = require( 'pdfjs-dist/build/pdf.min.js' ) $lib_pdfjs.disableRange = true $lib_pdfjs.GlobalWorkerOptions.workerSrc = '-/node_modules/pdfjs-dist/build/pdf.worker.min.js' }</code> </pre> <br><p> <strong>/lib/pdfjs/pdfjs.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">deploy \/node_modules/pdfjs-dist/build/pdf.worker.min.js</code> </pre> <br><p>        ,    . </p><br><h1 id="okruzhenie-razrabotchika">   </h1><br><p>          .     <code>create-react-app</code>  <code>angular-cli</code> ,       . , ,   <code>eject</code>       .          .       ,         ,       . </p><br><p> : <strong>      ?</strong> </p><br><p>    MAM      .          . </p><br><p>      MAM  <a href="https://github.com/eigenmethod/mam">   MAM </a> ,    : </p><br><pre> <code class="plaintext hljs">git clone https://github.com/eigenmethod/mam.git ./mam &amp;&amp; cd mam npm install npm start</code> </pre> <br><p>   8080   . ,    ‚Äî        MAM. </p><br><p>     (  ‚Äî <code>acme</code> )         (  ‚Äî <code>hello</code>  <code>home</code> ): </p><br><p> <strong>/acme/acme.meta.tree</strong> </p><br><pre> <code class="plaintext hljs">pack hello git \https://github.com/acme/hello.git pack home git \https://github.com/acme/home.git</code> </pre> <br><p>           <code>npm start</code> : </p><br><pre> <code class="plaintext hljs">npm start acme/hello acme/home</code> </pre> <br><p>         .     ‚Äî  . ,  ,   .     ‚Äî   : <a href="https://t.me/mam_mol">https://t.me/mam_mol</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/456288/">https://habr.com/ru/post/456288/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456274/index.html">Psychologists: sex robots will lead to an increase in the number of people without a couple who do not need relationships with other people</a></li>
<li><a href="../456276/index.html">What is information?</a></li>
<li><a href="../45628/index.html">8 tips for job seekers</a></li>
<li><a href="../456280/index.html">Getting started with stm32 or do not repeat my mistakes</a></li>
<li><a href="../456282/index.html">Multidimensional graphics in Python - from three-dimensional to six-dimensional</a></li>
<li><a href="../45629/index.html">Habrabagi</a></li>
<li><a href="../456290/index.html">Telegram. Unlimited network drive. Free</a></li>
<li><a href="../456294/index.html">Differences LabelEncoder and OneHotEncoder in SciKit Learn</a></li>
<li><a href="../456298/index.html">Microelectronics technology on the fingers: "Moore's law", marketing moves, and why nanometers are not the same today. Part 2</a></li>
<li><a href="../4563/index.html">262 thousand Muscovites have paid TV</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>