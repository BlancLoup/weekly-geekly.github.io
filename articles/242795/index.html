<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As in Yandex use PyTest and other frameworks for functional testing.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! My name is Sergey, and in Yandex I work in the automation team testing monetization services. Each team involved in test automation tasks is as...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As in Yandex use PyTest and other frameworks for functional testing.</h1><div class="post__text post__text-html js-mediator-article">  Hello!  My name is Sergey, and in Yandex I work in the automation team testing monetization services.  Each team involved in test automation tasks is asked: ‚ÄúWhat [framework | tool] should I choose to write my tests?‚Äù In this post I want to help you answer it.  More specifically, we will talk about testing tools in the Python language, but many of the ideas and conclusions can be extended to other programming languages, since the approaches are often independent of a specific technology. <br><br> <a href="http://habrahabr.ru/company/yandex/blog/242795/"><img src="https://habrastorage.org/files/54e/5d1/310/54e5d1310790471ca78a084c7b15879a.png"></a> <br><br>  In Python, there are many tools for writing tests and the choice between them is not obvious.  I will describe interesting options for using PyTest and talk about its [pluses | minuses | implicit possibilities].  In the article you will find a detailed example of the use of <a href="http://habrahabr.ru/company/yandex/blog/232697/">Allure</a> , which serves to create simple and understandable autotest reports.  Also, the examples will use the framework for writing matchmakers - <a href="http://hamcrest.org/">Hamcrest</a> for Python.  I hope that in the end, those who are now searching for tools for testing can, based on the examples presented, quickly implement functional testing in their environment.  Those who already use some tool will be able to learn new approaches, use cases and concepts. <br><a name="habracut"></a><br>  Historically, in our project a whole zoo of technologies lives with complex schemes of interaction with each other.  At the same time, their API and functionality only grow, so you need to implement integration tests. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      As automatists, we need the most convenient and flexible tool for writing tests to establish an optimal testing process.  Python was chosen because it is easy to learn, the code on it, as a rule, is easy to read, and, most importantly, it has a rich standard library and lots of extension packages. <br><br>  Having looked at the list of tools for functional testing, one involuntarily falls into a stupor and thinks about which tool to choose to quickly write tests, have no problems with their support and easily train new employees to work with it. <br><br>  At one time there was an opportunity to experiment, and the choice fell on the promising framework PyTest.  Then he was not yet so popular, and very few people used it.  We liked the concept of using fixtures and writing tests as a normal Python module without using the API.  As a result, PyTest shot, and now we have a very flexible solution with many features, for example: <br><br><ul><li>  fixtures in the form of test function arguments, which allow to separate the auxiliary functionality from the test itself; </li><li>  built-in assert, which displays an error in a convenient form; </li><li>  pytest.mark.parametrize to run tests on different data sets without duplicating code; </li><li>  the ability to put tags on tests to mark falling tests or highlight long-playing and run them separately; </li><li>  JUnit support for reports using the --junit-xml argument, besides the ability to generate reports in a different format. </li></ul><br>  Now let's talk more about how fixtures, parameterization and marking work in PyTest.  How to write your matchmakers using the PyHamcrest framework and generate result reports using Allure. <br><br><h3>  Writing tests </h3><br><h4>  Fixtures </h4><br>  In the conventional sense, <a href="http://en.wikipedia.org/wiki/Test_fixture">fixture</a> is a fixed state of the bench on which the tests are performed.  This also applies to the action that brings the system into a certain state. <br><br>  In <b>pytest, a</b> fixture is a function wrapped in a <code>@pytest.fixture.</code> decorator <code>@pytest.fixture.</code>  The function itself is executed at the moment when it is needed (before the test class, module or function) and when the value returned to it is available in the test itself.  In this case, fixtures can use other fixtures, in addition, you can determine the lifetime of a specific fixture: in the current session, module, class, or function.  They help us to contain tests in a modular form.  And when testing integration, reuse them from neighboring test libraries.  Flexibility and ease of use were among the main criteria for choosing <b>pytest</b> .  To use the fixture, you need to specify its name as a parameter to the test. <br><br>  Fixtures come to the rescue when needed: <br><ul><li>  generate test data; </li><li>  prepare a test stand; </li><li>  change the behavior of the stand; </li><li>  write <code>setUp/tearDown</code> ; </li><li>  collect service logs or <code>crashdump</code> ; </li><li>  use system emulators or plugs; </li><li>  and much more. </li></ul><br><h5>  Test server </h5><br><br>  The examples below will describe tests that check the functionality of a web server on <a href="http://flask.pocoo.org/">Flask</a> , waiting for a connection on port <code>8081</code> and receiving <code>GET</code> requests.  The server takes a line from the <code>text</code> parameter and in the response changes each word to its flipped word.  It is given to json, if the client is able to receive it: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> flask <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Flask, request, make_response <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response app = Flask(__name__) @app.route(<span class="hljs-string"><span class="hljs-string">"/"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">index</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> text = request.args.get(<span class="hljs-string"><span class="hljs-string">'text'</span></span>) json_type = <span class="hljs-string"><span class="hljs-string">'application/json'</span></span> json_accepted = json_type <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> request.headers.get(<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>, <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> text: words = text.split() reversed_words = [word[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> json_accepted: res = response(json.dumps({<span class="hljs-string"><span class="hljs-string">'text'</span></span>: reversed_words}), <span class="hljs-number"><span class="hljs-number">200</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = response(<span class="hljs-string"><span class="hljs-string">' '</span></span>.join(reversed_words), <span class="hljs-number"><span class="hljs-number">200</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = response(<span class="hljs-string"><span class="hljs-string">'text not found'</span></span>, <span class="hljs-number"><span class="hljs-number">501</span></span>) res.headers[<span class="hljs-string"><span class="hljs-string">'Content-Type'</span></span>] = json_type <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> json_accepted <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">'text/plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: app.run(host=<span class="hljs-string"><span class="hljs-string">'0.0.0.0'</span></span>, port=<span class="hljs-number"><span class="hljs-number">8081</span></span>)</code> </pre> <br><br>  Let's write a test for the server being tested, which will check its availability on the specified port.  Check that our server exists.  For this we use the socket module.  Let's create a fixture that will prepare the socket and close it after the end of the test. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> socket <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> s @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socket</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> _socket = s.socket(s.AF_INET, s.SOCK_STREAM) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">socket_teardown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> _socket.close() request.addfinalizer(socket_teardown) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _socket <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_server_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket)</span></span></span><span class="hljs-function">:</span></span> socket.connect((<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">8081</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> socket</code> </pre> <br><br>  But it is better to use the new decorator <code>yield_fixture</code> , which represents a fixture in the form of a context manager that implements <code>setUP/tearDown</code> and returns an object. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.yield_fixture def socket(): _socket = s.socket(s.AF_INET, s.SOCK_STREAM) yield _socket _socket.close()</span></span></code> </pre> <br><br>  Using <code>yield_fixture</code> looks more concise and clearer.  It should be noted that the default fixtures have a lifetime <code>scope=function</code> .  This means that each test run with its parameters causes a new instance of the fixture. <br><br>  For our test, we write the <code>Server</code> fixture, describing where the web server under test is located.  Since it returns an object that stores static information, and we don‚Äôt need to generate it every time, we set the <code>scope=module</code> .  The result that this fixture generates will be cached and will exist all the time the current module is launched: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture(scope='module') def Server(): class Dummy: host_port = 'localhost', 8081 uri = 'http://%s:%s/' % host_port return Dummy def test_server_connect(socket, Server): socket.connect(Server.host_port) assert socket</span></span></code> </pre> <br><br>  There is also <code>scope=session</code> and <code>scope=class</code> - the lifetime of the fixture.  And you can not use inside the fixture with a high level fixture with a lower value of <code>scope=</code> . <br><br>  Beware of using <code>autouse</code> .  They are dangerous because they can change the data unnoticed.  For their flexible use, you can check the presence of the required fixture for the called test: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.yield_fixture(scope='function', autouse=True) def collect_logs(request): if 'Server' in request.fixturenames: with some_logfile_collector(SERVER_LOCATION): yield else: yield</span></span></code> </pre> <br><br>  Among other things, you can specify fixtures on test classes.  In the following example, there is a class in which the tests change the time on the test bench.  For example, we need to update the current time after each test.  In the following example, the <code>Service</code> fixture returns the object of the service being tested and has a <code>set_time</code> method with which you can change the date and time: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.yield_fixture def reset_shifted_time(Service): yield Service.set_time(datetime.datetime.now()) @pytest.mark.usefixtures("reset_shifted_time") class TestWithShiftedTime(): def test_shift_milesecond(self, Service): Service.set_time() assert ... def test_shift_time_far_far_away(self, Service): Service.set_time() assert ...</span></span></code> </pre> <br><br>  Typically, small fixtures that are specific to a situation are described inside the test module.  But if the fixture becomes popular among many test suites, then it is usually carried to a special <b>pytest</b> file: <code>conftest.py</code> .  After the fixture is described in this file, it becomes visible for all tests, and you do not need to <code>import</code> . <br><br><h3>  Matchers </h3><br>  It is obvious that no one needs tests without checks.  When using <b>pytest,</b> you can do checks in the easiest way - using a <a href="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html">matcher</a> such as <code>assert</code> .  <a href="http://en.wikipedia.org/wiki/Assertion_(software_development)">Assert</a> is a standard Python instruction that verifies the statement described in it.  We follow the rule ‚ÄúIn one test - one <code>assert</code> ‚Äù.  It allows you to test a specific functionality without affecting the steps of data preparation or bringing the service to the desired state.  If the test uses data preparation steps that may cause an error, then it is better for them to write a separate test.  Using this structure, we describe the expected behavior of the system. <br><br>  If an error was detected, then a human readable launch report is required from the test.  And more recently, <b>pytest</b> began to support very informative <code>assert</code> .  I advise you to use them until you need something more complicated. <br><br>  For example, the following test: <br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_dict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> dict(foo=<span class="hljs-string"><span class="hljs-string">'bar'</span></span>, baz=<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>).items() == list({<span class="hljs-string"><span class="hljs-string">'foo'</span></span>: <span class="hljs-string"><span class="hljs-string">'bar'</span></span>}.iteritems())</code> </pre> <br>  will return a detailed answer about where the error is: <br><pre> <code class="python hljs">E <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> [(<span class="hljs-string"><span class="hljs-string">'foo'</span></span>, <span class="hljs-string"><span class="hljs-string">'bar...('</span></span>baz<span class="hljs-string"><span class="hljs-string">', None)] == [('</span></span>foo<span class="hljs-string"><span class="hljs-string">', '</span></span>ba<span class="hljs-string"><span class="hljs-string">r')] E Left contains more items, first extra item: ('</span></span>baz<span class="hljs-string"><span class="hljs-string">', None)</span></span></code> </pre><br><br>  In the test verifying our <i>Test server</i> on Flask, we will rewrite the test inside the <code>test_server_connect</code> method to more accurately determine that we do not expect a specific <code>exception</code> .  To do this, use the <a href="https://github.com/hamcrest/PyHamcrest">PyHamcrest</a> framework: <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hamcrest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * SOCKET_ERROR = s.error <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_server_connect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(socket, Server)</span></span></span><span class="hljs-function">:</span></span> assert_that(calling(socket.connect).with_args(Server.host_port), is_not(raises(SOCKET_ERROR)))</code> </pre> <br><br>  <a href="http://en.wikipedia.org/wiki/Hamcrest">PyHamcrest</a> allows you to combine the built-in gamers.  <code>has_property</code> and <code>contains_string,</code> in this way <code>contains_string,</code> we get easy-to-use simple matchmakers: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">has_content</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> has_property(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, item <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(item, BaseMatcher) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> contains_string(item)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">has_status</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(status)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> has_property(<span class="hljs-string"><span class="hljs-string">'status_code'</span></span>, equal_to(status))</code> </pre> <br><br>  Next, we will need to write matchers that modify the value being tested and pass it on to the next specified match player.  To do this, we write the <code>BaseModifyMatcher</code> class, which forms such a matcher based on the class attributes: <code>description</code> - the description of the matcher, <code>modify</code> - the modifier function of the value being checked, <code>instance</code> - the type of the class that is expected in the modifier: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> hamcrest.core.base_matcher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> BaseMatcher <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseModifyMatcher</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseMatcher)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item_matcher)</span></span></span><span class="hljs-function">:</span></span> self.item_matcher = item_matcher <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_matches</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(item, self.instance) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> item: self.new_item = self.modify(item) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self.item_matcher.matches(self.new_item) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">describe_mismatch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, item, mismatch_description)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isinstance(item, self.instance) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> item: self.item_matcher.describe_mismatch(self.new_item, mismatch_description) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: mismatch_description.append_text(<span class="hljs-string"><span class="hljs-string">'not %s, was: '</span></span> % self.instance) \ .append_text(repr(item)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">describe_to</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, description)</span></span></span><span class="hljs-function">:</span></span> description.append_text(self.description) \ .append_text(<span class="hljs-string"><span class="hljs-string">' '</span></span>) \ .append_description_of(self.item_matcher)</code> </pre> <br><br>  We know that the server being tested forms a response from the inverted words given to it in the <code>text</code> parameter.  Using <code>BaseModifyMatcher</code> , we will write a matcher who will receive a list of ordinary words and will wait in the answer for a line of inverted words: <br><pre> <code class="python hljs">rom hamcrest.core.helpers.wrap_matcher <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> wrap_matcher reverse_words = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> words: [word[::<span class="hljs-number"><span class="hljs-number">-1</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> word <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> words] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">contains_reversed_words</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item_match)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Example: &gt;&gt;&gt; from hamcrest import * &gt;&gt;&gt; contains_reversed_words(contains_inanyorder('oof', 'rab')).matches("foo bar") True """</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IsStringOfReversedWords</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseModifyMatcher)</span></span></span><span class="hljs-class">:</span></span> description = <span class="hljs-string"><span class="hljs-string">'string of reversed words'</span></span> modify = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> _, item: reverse_words(item.split()) instance = basestring <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsStringOfReversedWords(wrap_matcher(item_match))</code> </pre> <br><br>  The following matcher, using <code>BaseModifyMatcher</code> , will check for a line containing json: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> json <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> j <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_json</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(item_match)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Example: &gt;&gt;&gt; from hamcrest import * &gt;&gt;&gt; is_json(has_entries('foo', contains('bar'))).matches('{"foo": ["bar"]}') True """</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsJson</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(BaseModifyMatcher)</span></span></span><span class="hljs-class">:</span></span> description = <span class="hljs-string"><span class="hljs-string">'json with'</span></span> modify = <span class="hljs-keyword"><span class="hljs-keyword">lambda</span></span> _, item: j.loads(item) instance = basestring <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> AsJson(wrap_matcher(item_match))</code> </pre> <br><br>  We will complement the test, checking our <em>Test server</em> on Flask, with two more tests, which will check what forms the server in response to different requests.  To do this, use the <code>has_status</code> , <code>has_content</code> and <code>contains_reversed_words</code> <code>has_content</code> described above: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_server_response</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Server)</span></span></span><span class="hljs-function">:</span></span> assert_that(requests.get(Server.uri), all_of(has_content(<span class="hljs-string"><span class="hljs-string">'text not found'</span></span>), has_status(<span class="hljs-number"><span class="hljs-number">501</span></span>))) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_server_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Server)</span></span></span><span class="hljs-function">:</span></span> text = <span class="hljs-string"><span class="hljs-string">'Hello word!'</span></span> assert_that(requests.get(Server.uri, params={<span class="hljs-string"><span class="hljs-string">'text'</span></span>: text}), all_of( has_content(contains_reversed_words(text.split())), has_status(<span class="hljs-number"><span class="hljs-number">200</span></span>) ))</code> </pre> <br>  About <em>Hamcrest</em> can be read on <a href="http://habrahabr.ru/company/yandex/blog/184634/">Habr√©</a> .  You should also pay attention to <a href="http://www.should-dsl.info/">should-dsl</a> . <br><br><h3>  Parameterization </h3><br><br>  When you want to run the same test with <a href="http://blogs.msdn.com/b/jledgard/archive/2003/11/03/53722.aspx">many different parameters</a> , <em>parameterization of</em> test data comes to the rescue.  Using parameterization, recurring code is recycled in tests.  Visually highlighting the parameter list helps improve readability and further support.  Fixtures describe the system, prepare it, or lead to the desired state.  Parameterization is used to form a set of different test parameters describing test cases. <br><br>  In <strong>PyTest</strong> , you need to parameterize tests using the special decorator <code>@pytest.mark.parametrize</code> .  You can specify several parameters in one <code>parametrize</code> .  If the parameters are divided into several <code>parametrize</code> , then they are multiplied. <br><br>  Keeping static data inside a test is not a good practice.  In the example of the test that our <em>Test server</em> checks on Flask, it is worth parametrizing the <code>test_server_request</code> method, describing the <code>text</code> options: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.mark.parametrize('text', ['Hello word!', ' 440 005 ', 'one_word']) def test_server_request(text, Server): assert_that(requests.get(Server.uri, params={'text': text}), all_of( has_content(contains_reversed_words(text.split())), has_status(200) ))</span></span></code> </pre> <br>  We forgot to check <code>json</code> answer if the client supports it.  Rewrite the test using objects instead of the usual parameters.  Matcher will vary depending on the type of answer.  I advise you to give more understandable names to the matcher: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultCase</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text)</span></span></span><span class="hljs-function">:</span></span> self.req = dict( params={<span class="hljs-string"><span class="hljs-string">'text'</span></span>: text}, headers={}, ) self.match_string_of_reversed_words = all_of( has_content(contains_reversed_words(text.split())), has_status(<span class="hljs-number"><span class="hljs-number">200</span></span>), ) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JSONCase</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(DefaultCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text)</span></span></span><span class="hljs-function">:</span></span> DefaultCase.__init__(self, text) self.req[<span class="hljs-string"><span class="hljs-string">'headers'</span></span>].update({<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>}) self.match_string_of_reversed_words = all_of( has_content(is_json(has_entries(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, contains(*reverse_words(text.split()))))), has_status(<span class="hljs-number"><span class="hljs-number">200</span></span>), ) @pytest.mark.parametrize(<span class="hljs-string"><span class="hljs-string">'case'</span></span>, [testclazz(text) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'Hello word!'</span></span>, <span class="hljs-string"><span class="hljs-string">' 440 005 '</span></span>, <span class="hljs-string"><span class="hljs-string">'one_word'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testclazz <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> JSONCase, DefaultCase]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_server_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(case, Server)</span></span></span><span class="hljs-function">:</span></span> assert_that(requests.get(Server.uri, **case.req), case.match_string_of_reversed_words)</code> </pre><br><br>  If we run such a parameterized test using the <code>py.test -v test_server.py</code> , we get the report: <br><br><pre> <code class="python hljs">$ py.test -v test_server.py ============================= test session starts ============================= platform linux2 -- Python <span class="hljs-number"><span class="hljs-number">2.7</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> -- py<span class="hljs-number"><span class="hljs-number">-1.4</span></span><span class="hljs-number"><span class="hljs-number">.20</span></span> -- pytest<span class="hljs-number"><span class="hljs-number">-2.5</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> -- /usr/bin/python plugins: timeout, allure-adaptor collected <span class="hljs-number"><span class="hljs-number">8</span></span> items test_server.py:<span class="hljs-number"><span class="hljs-number">26</span></span>: test_server_connect PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">89</span></span>: test_server_response PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">109</span></span>: test_server_request[case0] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">109</span></span>: test_server_request[case1] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">109</span></span>: test_server_request[case2] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">109</span></span>: test_server_request[case3] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">109</span></span>: test_server_request[case4] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">109</span></span>: test_server_request[case5] PASSED ========================== <span class="hljs-number"><span class="hljs-number">8</span></span> passed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.11</span></span> seconds ===========================</code> </pre> <br><br>  In such a report it is completely incomprehensible which parameter was used in a particular launch. <br><br>  To make the output more understandable, you need to implement the <code>__repr__</code> method for the <code>Case</code> class and write an auxiliary <code>idparametrize</code> decorator, in which we use the additional parameter <code>ids=</code> decorator <code>pytest.mark.parametrize</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">idparametrize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name, values, fixture=False)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> pytest.mark.parametrize(name, values, ids=map(repr, values), indirect=fixture) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DefaultCase</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text)</span></span></span><span class="hljs-function">:</span></span> self.text = text self.req = dict( params={<span class="hljs-string"><span class="hljs-string">'text'</span></span>: self.text}, headers={}, ) self.match_string_of_reversed_words = all_of( has_content(contains_reversed_words(self.text.split())), has_status(<span class="hljs-number"><span class="hljs-number">200</span></span>), ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__repr__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'text="{text}", {cls}'</span></span>.format(cls=self.__class__.__name__, text=self.text) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JSONCase</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(DefaultCase)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, text)</span></span></span><span class="hljs-function">:</span></span> DefaultCase.__init__(self, text) self.req[<span class="hljs-string"><span class="hljs-string">'headers'</span></span>].update({<span class="hljs-string"><span class="hljs-string">'Accept'</span></span>: <span class="hljs-string"><span class="hljs-string">'application/json'</span></span>}) self.match_string_of_reversed_words = all_of( has_content(is_json(has_entries(<span class="hljs-string"><span class="hljs-string">'text'</span></span>, contains(*reverse_words(text.split()))))), has_status(<span class="hljs-number"><span class="hljs-number">200</span></span>), ) @idparametrize(<span class="hljs-string"><span class="hljs-string">'case'</span></span>, [testclazz(text) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> text <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-string"><span class="hljs-string">'Hello word!'</span></span>, <span class="hljs-string"><span class="hljs-string">' 440 005 '</span></span>, <span class="hljs-string"><span class="hljs-string">'one_word'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> testclazz <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> JSONCase, DefaultCase]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_server_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(case, Server)</span></span></span><span class="hljs-function">:</span></span> assert_that(requests.get(Server.uri, **case.req), case.match_string_of_reversed_words)</code> </pre> <br><br><pre> <code class="python hljs">$ py.test -v test_server.py ============================= test session starts ============================= platform linux2 -- Python <span class="hljs-number"><span class="hljs-number">2.7</span></span><span class="hljs-number"><span class="hljs-number">.3</span></span> -- py<span class="hljs-number"><span class="hljs-number">-1.4</span></span><span class="hljs-number"><span class="hljs-number">.20</span></span> -- pytest<span class="hljs-number"><span class="hljs-number">-2.5</span></span><span class="hljs-number"><span class="hljs-number">.2</span></span> -- /usr/bin/python plugins: ordering, timeout, allure-adaptor, qabs-yadt collected <span class="hljs-number"><span class="hljs-number">8</span></span> items test_server.py:<span class="hljs-number"><span class="hljs-number">26</span></span>: test_server_connect PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">89</span></span>: test_server_response PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">117</span></span>: test_server_request[text=<span class="hljs-string"><span class="hljs-string">"Hello word!"</span></span>, JSONCase] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">117</span></span>: test_server_request[text=<span class="hljs-string"><span class="hljs-string">"Hello word!"</span></span>, DefaultCase] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">117</span></span>: test_server_request[text=<span class="hljs-string"><span class="hljs-string">" 440 005 "</span></span>, JSONCase] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">117</span></span>: test_server_request[text=<span class="hljs-string"><span class="hljs-string">" 440 005 "</span></span>, DefaultCase] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">117</span></span>: test_server_request[text=<span class="hljs-string"><span class="hljs-string">"one_word"</span></span>, JSONCase] PASSED test_server.py:<span class="hljs-number"><span class="hljs-number">117</span></span>: test_server_request[text=<span class="hljs-string"><span class="hljs-string">"one_word"</span></span>, DefaultCase] PASSED ========================== <span class="hljs-number"><span class="hljs-number">8</span></span> passed <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0.12</span></span> seconds ===========================</code> </pre> <br><br>  If you look at the <code>idparametrize</code> decorator <code>idparametrize</code> and pay attention to the <code>fixture</code> parameter, you can see that you can parameterize the fixtures.  In the following example, we check that the server is responding correctly, both on the real ip and on the local one.  To do this, you need to tweak the <code>Server</code> fixture a bit so that it can take parameters: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> collections <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> namedtuple Srv = namedtuple(<span class="hljs-string"><span class="hljs-string">'Server'</span></span>, <span class="hljs-string"><span class="hljs-string">'host port'</span></span>) REAL_IP = s.gethostbyname(s.gethostname()) @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dummy</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, srv)</span></span></span><span class="hljs-function">:</span></span> self.srv = srv @property <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uri</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'http://{host}:{port}/'</span></span>.format(**self.srv._asdict()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Dummy(request.param) @idparametrize(<span class="hljs-string"><span class="hljs-string">'Server'</span></span>, [Srv(<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">8081</span></span>), Srv(REAL_IP, <span class="hljs-number"><span class="hljs-number">8081</span></span>)], fixture=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) @idparametrize(<span class="hljs-string"><span class="hljs-string">'case'</span></span>, [Case(<span class="hljs-string"><span class="hljs-string">'Hello word!'</span></span>), Case(<span class="hljs-string"><span class="hljs-string">'Hello word!'</span></span>, json=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>)]) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_server_request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(case, Server)</span></span></span><span class="hljs-function">:</span></span> assert_that(requests.get(Server.uri, **case.req), case.match_string_of_reversed_words)</code> </pre> <br><br><h3>  Marking </h3><br><br>  By marking, you can mark a test as causing an error, skip the test, or add a <em>user-defined</em> label.  All of this is metadata for grouping, or tagging necessary tests, cases, or parameters.  In the case of grouping, we use this feature to indicate <em>severity</em> to tests and classes, as there are more and less important tests. <br><br>  In <strong>pytest,</strong> tests and test parameters can be tagged using the special decorator <code>@pytest.mark.MARK_NAME</code> .  For example, each testpack can go for a few minutes, or even more.  Therefore, I would like to get rid of the critical tests first and then the others: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.mark.acceptance def test_server_connect(socket, Server): assert_that(calling(socket.connect).with_args(Server.host_port), is_not(raises(SOCKET_ERROR))) @pytest.mark.acceptance def test_server_response(Server): assert_that(requests.get(Server.uri), all_of(has_content('text not found'), has_status(501))) @pytest.mark.P1 def test_server_404(Server): assert_that(requests.get(Server.uri + 'not_found'), has_status(404)) @pytest.mark.P2 def test_server_simple_request(Server, SlowConnection): with SlowConnection(drop_packets=0.3): assert_that(requests.get(Server.uri + '?text=asdf'), has_content('fdsa'))</span></span></code> </pre> <br><br>  Tests with such markings can be used in CI.  For example, in Jenkins you can create a <code>multi-configuration project</code> .  For this task, in the <code>Configuration Matrix</code> section, define the <code>User-defined Axis</code> as a <code>TESTPACK</code> containing <code>['acceptance', 'P1', 'P2', 'other']</code> .  This task runs the tests in turn, and <code>acceptance</code> tests will be started first, and their successful execution will be a condition for running other tests: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash PYTEST="py.test $WORKSPACE/tests/functional/ $TEST_PARAMS --junitxml=report.xml --alluredir=reports" if [ "$TESTPACK" = "other" ] then $PYTEST -m "not acceptance and not P1 and not P2" || true else $PYTEST -m $TESTPACK || true fi</span></span></code> </pre> <br>  Another type of marking is to mark the test as <code>xfail</code> .  In addition to how to mark the entire test, you can mark the test parameters.  So in the following example, when specifying the ipv6 address <code>host='::1',</code> , the server does not respond.  To solve this problem, you need to use in the server code instead of <code>0.0.0.0</code> .  We will not fix it yet to see how our test responds to this situation.  Additionally, you can describe the reason in the optional parameter <code>reason</code> .  This text will appear in the launch report: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.yield_fixture def Server(request): class Dummy: def __init__(self, srv): self.srv = srv self.conn = None @property def uri(self): return 'http://{host}:{port}/'.format(**self.srv._asdict()) def connect(self): self.conn = s.create_connection((self.srv.host, self.srv.port)) self.conn.sendall('HEAD /404 HTTP/1.0\r\n\r\n') self.conn.recv(1024) def close(self): if self.conn: self.conn.close() res = Dummy(request.param) yield res res.close() SERVER_CASES = [ pytest.mark.xfail(Srv('::1', 8081), reason='ipv6 desn`t work, use `::` instead of `0.0.0.0`'), Srv(REAL_IP, 8081), ] @idparametrize('Server', SERVER_CASES, fixture=True) def test_server(Server): assert_that(calling(Server.connect), is_not(raises(SOCKET_ERROR)))</span></span></code> </pre> <br>  Tests and parameters can be marked with the <code>pytest.mark.skipif()</code> tag.  It allows you to skip these tests using a specific condition. <br><br><h3>  Execution and debugging </h3><br><h4>  Launch </h4><br>  You can run tests in different ways.  Just with the <code>py.test</code> command, or as the <code>python -m pytest</code> module <code>python -m pytest</code> . <br><br>  <strong>Running pytest</strong> <br><ul><li>  starts collecting tests using command line arguments that point to directories or file paths; </li><li>  continues to review recursively within directories, until stumbles on the parameter <code>norecursedirs</code> ; </li><li>  all files that match <code>test_*.py</code> or <code>*_test.py</code> ; </li><li>  classes in the name, starting with <code>Test</code> , that have no <code>__init__</code> method; </li><li>  functions or methods of classes whose names are prefixed with <code>test_</code> ; </li></ul><br>  Separately, I would like to mention a special <a href="http://tox.readthedocs.org/en/latest/">tox</a> test <a href="http://tox.readthedocs.org/en/latest/">launcher</a> , with which you can store in one place all the test run parameters.  To do this, we write the <code>tox.ini</code> config in the root folder with the tests: <br><br><pre> <code class="python hljs">[tox] envlist=py27 [testenv] deps= builders pytest pytest-allure-adaptor PyHamcrest commands= py.test tests/functional/ \ --junitxml=report.xml \ --alluredir=reports \ --verbose \ {posargs}</code> </pre><br><br>  And then one command to run the tests: <code>tox</code> .  He will do his <code>virtualenv</code> in the <code>.tox</code> folder, <code>.tox</code> up the dependencies needed to run the tests, and eventually run <strong>pytest</strong> with the parameters specified in the config. <br><br>  Alternatively, if you arrange the tests as a module for python, you can run the <code>python setup.py test</code> .  To do this, you need to arrange your <code>setup.py</code> in accordance with the <a href="http://pytest.org/latest/goodpractises.html">documentation</a> . <br><br>  By specifying the docstring, as in the example above for Allure, you can use <strong>pytest</strong> to test the docs.  <strong>Pytest</strong> has doctest, <a href="https://pypi.python.org/pypi/pytest-pep8">pep8</a> , unittest and nose <code>py.test --pep8 --doctest-modules -v --junit-xml report.xml self_tests/ ft_lib/</code> : <code>py.test --pep8 --doctest-modules -v --junit-xml report.xml self_tests/ ft_lib/</code> <br><br>  Additionally, I would like to note that <strong>pytest</strong> can run <a href="https://docs.python.org/2/library/unittest.html">UnitTest</a> and <a href="https://nose.readthedocs.org/en/latest/">nose</a> tests. <br><br><h3>  Debugging </h3><br><img align="right" width="400" alt="pudb" src="https://habrastorage.org/files/bf4/f8e/445/bf4f8e4455b24c9f95a267d30bcd69db.png"><br><br>  Like normal code, tests need debugging.  It is usually used if <em>it</em> is still not clear from <em>stacktrace</em> why the test fell with an <code>ERROR</code> status.  There are several approaches to this in <strong>pytest</strong> : <br><ul><li>  plugin for <a href="https://pypi.python.org/pypi/pytest-pycharm">PyCharm</a> ; </li><li>  by writing <code>pytest.set_trace()</code> anywhere in your test, you can immediately drop out to <code>pdb</code> in the specified location; </li><li>  you can simply configure debugging in your IDE; </li><li>  use the <code>--pdb</code> parameter, which will launch the debugger when an error occurs; </li><li>  or write <code>import pudb;pudb.set_trace()</code> in front of suspicious places (the main thing is to remember to add the <code>-s</code> parameter to the test launch line). </li></ul><br><br>  Parameters <strong>pytest</strong> that help debug tests: <br><ul><li>  <code>-k</code> when you need to run a separate test.  It should be borne in mind that if you want to run two tests or use additional filters, then you need to follow the new syntax of this parameter.  <code>py.test -k "prepare or http and proxy" tests/functional/</code> ; </li><li>  <code>-x</code> when you need to stop executing tests at the first test or error that has fallen; </li><li>  <code>--collect-only</code> when you need to check the correctness and the number of generated parameters to the tests and the list of tests that will be run (similar to the dry-run); </li><li>  <code>--no-magic</code> hints at us that there is magic here :) </li></ul><br><br><h3>  Results analysis </h3><br>  The resulting report is the resulting set of data for successfully passed, missed, and dropped tests.  Fallen tests should describe the state of the system, the steps leading to the system to such a result, the parameters at which the test fell, and what was expected of the system when using these parameters.      :     ,    ,     ,       ,   : <em>smoke</em>  <em>functional</em> ,     .  ,          . <br><br>  <strong>pytest</strong>    <em>JUnit</em> ,      <a href="https://wiki.jenkins-ci.org/display/JENKINS/xUnit%2BPlugin">Jenkins-CI</a> .   ,      <a href="http://habrahabr.ru/company/yandex/blog/232697/">Allure</a> ,        . <br><br>      <strong>pytest</strong> : <br><ul><li> PASSED ‚Äî , ,  ; </li><li> FAILED ‚Äî ,  ,    <code>assert</code> ; </li><li> ERROR ‚Äî   ,         .,       ; </li><li> SKIPPED ‚Äî ,      <code>depends</code>  <code>pytest.mark.skip[if]</code>    ; </li><li> xfail ‚Äî      , <code>assert</code>    ; </li><li> XPASS ‚Äî ,   <code>xfail</code>  .    ,   ,    ,   . </li></ul><br><br>    <a href="http://allure.qatools.ru/">Allure</a>   <strong>PyTest</strong> ,   <a href="https://pypi.python.org/pypi/pytest-allure-adaptor">Allure   PyTest</a> .     , : <br><ul><li>  Step'      ; </li><li>  description       docstring; </li><li>  attachment',     ; </li><li>  . </li></ul><br><br> Step'   ,    ,   .      ,       .                   -. <br><br> Attachment' ‚Äî      ,       . ,  -,     .      Step'.           <code>type</code> .    attachemnt'    : <code>txt</code> , <code>html</code> , <code>xml</code> , <code>png</code> , <code>jpg</code> , <code>json</code> . <br><br>       <code>error_if_wat</code> ,    ,     <code>ERROR_CONDITION</code> .       <code>Server</code> .      <code>allure.step</code> .      <code>socket</code> .       <code>requests</code> .           <code>allure.attach</code> .     <em>docstring</em> ,      ,     . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> allure ERROR_CONDITION = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> @pytest.fixture <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error_if_wat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> request.getfuncargvalue(<span class="hljs-string"><span class="hljs-string">'Server'</span></span>).srv != ERROR_CONDITION SERVER_CASES = [ pytest.mark.xfail(Srv(<span class="hljs-string"><span class="hljs-string">'::1'</span></span>, <span class="hljs-number"><span class="hljs-number">8081</span></span>), reason=<span class="hljs-string"><span class="hljs-string">'ipv6 desn`t work, use `::` instead of `0.0.0.0`'</span></span>), Srv(<span class="hljs-string"><span class="hljs-string">'127.0.0.1'</span></span>, <span class="hljs-number"><span class="hljs-number">8081</span></span>), Srv(<span class="hljs-string"><span class="hljs-string">'localhost'</span></span>, <span class="hljs-number"><span class="hljs-number">80</span></span>), ERROR_CONDITION, ] @idparametrize(<span class="hljs-string"><span class="hljs-string">'Server'</span></span>, SERVER_CASES, fixture=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_server</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Server, error_if_wat)</span></span></span><span class="hljs-function">:</span></span> assert_that(calling(Server.connect), is_not(raises(SOCKET_ERROR))) <span class="hljs-string"><span class="hljs-string">""" Step 1: Try connect to host, port, and check for not raises SOCKET_ERROR. Step 2: Check for server response 'text not found' message. Response status should be equal to 501. """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> allure.step(<span class="hljs-string"><span class="hljs-string">'Try connect'</span></span>): assert_that(calling(Server.connect), is_not(raises(SOCKET_ERROR))) <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> allure.step(<span class="hljs-string"><span class="hljs-string">'Check response'</span></span>): response = requests.get(Server.uri) allure.attach(<span class="hljs-string"><span class="hljs-string">'response_body'</span></span>, response.text, type=<span class="hljs-string"><span class="hljs-string">'html'</span></span>) allure.attach(<span class="hljs-string"><span class="hljs-string">'response_headers'</span></span>, j.dumps(dict(response.headers), indent=<span class="hljs-number"><span class="hljs-number">4</span></span>), type=<span class="hljs-string"><span class="hljs-string">'json'</span></span>) allure.attach(<span class="hljs-string"><span class="hljs-string">'response_status'</span></span>, str(response.status_code)) assert_that(response, all_of(has_content(<span class="hljs-string"><span class="hljs-string">'text not found'</span></span>), has_status(<span class="hljs-number"><span class="hljs-number">501</span></span>)))</code> </pre> <br><br>    <code>py.test --alluredir=/var/tmp/allure/ test_server.py</code> . <br><br>   ,      ,   ,    Ubuntu: <br><br><pre> <code class="python hljs">sudo add-apt-repository ppa:yandex-qatools/allure-framework sudo apt-get install yandex-allure-cli allure generate -o /var/tmp/allure/output/ -- /var/tmp/allure/</code> </pre> <br>   <code>/var/tmp/allure/output</code>         .       <code>index.html</code> . <br><br><img src="https://habrastorage.org/files/8ef/86a/679/8ef86a6798da4e2fb9e1e1dffc147fc0.png" alt="allure passed with headers"> allure passed with headers <br><br>               ,    <a href="http://stackoverflow.com/questions/23997449/allure-report-nothing-shown-in-chrome">  </a> ,   allure  javascript   . <br><br>    ,     ,    : <br><br><ul><li> <a href="https://bitbucket.org/basti/pytest-localserver/">PyTest-localserver</a> ,       . </li><li> <a href="https://pypi.python.org/pypi/pytest-timeout">PyTest-timeout</a>   ,     . </li><li> <a href="https://pypi.python.org/pypi/pytest-xdist">PyTest-xdist</a> ‚Äî musthave,      . </li><li> <a href="https://pypi.python.org/pypi/pytest-capturelog">PyTest-capturelog</a>    ,    <code>logging</code> . </li><li> <em>PyTester</em>  ,           .     <strong>pytest</strong> . </li><li> <a href="httpretty">PyTest-httpretty</a>     <code>uri</code> ,     .    <code>pytest-localserver</code> </li><li> <a href="https://pypi.python.org/pypi/pytest-ordering">PyTest-ordering</a> ‚Äî   . -       . </li><li> <a href="https://pypi.python.org/pypi/pytest-incremental">PyTest-incremental</a> ,     ,    ,  ,       .    Jenkins. </li></ul><br><br>  ,   <a href="http://pytest.org/latest/apiref.html"></a>  <strong>PyTest</strong> .     <a href="http://pythontesting.net/framework/pytest"> </a>   . </div><p>Source: <a href="https://habr.com/ru/post/242795/">https://habr.com/ru/post/242795/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../242779/index.html">New Raspberry Pi model introduced: Model A + priced at $ 20</a></li>
<li><a href="../242781/index.html">H.265 / HEVC. Intel Architecture Optimization</a></li>
<li><a href="../242787/index.html">Encoders / Modulators from ZeeVee</a></li>
<li><a href="../242789/index.html">Financial data transfer methods: FIX protocol</a></li>
<li><a href="../242791/index.html">How Internet advertising works: Traffic arbitration</a></li>
<li><a href="../242797/index.html">Publisher List for Mobile Game Developer</a></li>
<li><a href="../242799/index.html">Reissue certificate with SHA-2 - if Webnames does not go to Mahomet ...</a></li>
<li><a href="../242801/index.html">Creating a universal UIAlertController for various versions of iOS</a></li>
<li><a href="../242803/index.html">Protection of automated process control systems in Russia: we investigate new requirements of FSTEC</a></li>
<li><a href="../242807/index.html">Development of the program in Multimedia Builder on the example of a utility for remote work with cash register software</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>