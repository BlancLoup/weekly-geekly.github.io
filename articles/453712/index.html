<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How eBay did a barcode scanner on WebAssembly</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Since its announcement, the WebAssembly technology has immediately attracted the attention of front-end developers. The web community enthusiastically...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How eBay did a barcode scanner on WebAssembly</h1><div class="post__text post__text-html js-mediator-article">  Since its announcement, the <a href="https://webassembly.org/">WebAssembly</a> technology has immediately attracted the attention of front-end developers.  The web community enthusiastically accepted the idea of ‚Äã‚Äãrunning code written in languages ‚Äã‚Äãother than JavaScript in the browser.  Most importantly, WebAssembly guarantees a much higher speed than JavaScript. <br><br>  Our engineers closely followed the development of the standard.  As soon as WebAssembly 1.0 support was implemented in all major browsers, the developers immediately wanted to try it out. <br><br>  But there was a problem.  Although <a href="https://webassembly.org/docs/use-cases/">many applications</a> benefit from WebAssembly, the scope of e-commerce technology is still primitive.  We could not immediately find the correct version of its use.  There were a few suggestions, but in all versions of JavaScript fit better.  When we evaluate new technologies in eBay, the first question is: ‚ÄúWhat is the potential benefit for our customers?‚Äù If there is no clarity here, we don‚Äôt go on to the next step.  It is very easy to get carried away with new fashionable technology, even if it doesn‚Äôt matter to customers and only complicates the existing workflow.  User experience is always more important than developer experience.  But with WebAssembly different.  This technology has a huge potential, we just could not find the right use case.  However, in the end still found. <br><a name="habracut"></a><br><h2>  Barcode Scanner </h2><br>  In native eBay applications on iOS and Android, there is a <a href="https://en.wikipedia.org/wiki/Universal_Product_Code">UPC</a> barcode scanning feature for automatic form entry.  It works only in applications and requires intensive image processing on the device in order to recognize bar code digits in the stream of images from the camera.  The resulting code is then sent to the server service, which, in turn, fills out the form.  This means that the image processing logic on the device must be very efficient.  For native applications, we compiled our own C ++ library into native code for iOS and Android.  It recognizes bar codes exceptionally well.  We are gradually switching to native APIs in iOS and Android, but our C ++ library is still reliable. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Barcode scanner - an intuitive feature for sellers, it greatly simplifies filling out the form.  Unfortunately, this feature did not work on the mobile version of the site, and the sellers had to manually enter the UPC, which is inconvenient. <br><br><h2>  Web Barcode Scanner </h2><br>  We used to look for a barcode scanning option on the web.  Two years ago, they even released a prototype based on the <a href="https://github.com/EddieLa/JOB">BarcodeReader</a> open JavaScript library.  The problem was that it worked well only in 20% of cases.  The remaining 80% of the time the scanner worked extremely slowly or did not work at all.  In most cases it was a time out.  Quite expectedly: JavaScript can be compared in speed with native code only if it is on a ‚Äúhot path‚Äù, i.e. it is highly optimized by <a href="https://slidr.io/bmeurer/javascript-engines-a-tale-of-types-classes-and-maps">JIT</a> compilers.  The trick is that JavaScript engines use multiple heuristics to determine if a path is ‚Äúhot‚Äù, without guaranteeing results.  This inconsistency, obviously, led to the frustration of users, and we had to disable this feature.  But now everything is different.  With the rapid development of the web platform, the question arose: "Is it possible to implement a reliable barcode scanner on the web?" <br><br>  One option is to wait for the <a href="https://wicg.github.io/shape-detection-api/">Shape Detection API</a> to exit with built-in image detection, including <a href="https://wicg.github.io/shape-detection-api/">barcodes</a> .  But these interfaces are still at a very early development stage and far from cross-browser compatibility.  And even in this case, work is <a href="https://developers.google.com/web/updates/2019/01/shape-detection">not guaranteed</a> on all platforms.  Therefore, we will have to consider other options. <br><br>  This is where WebAssembly comes into play.  If the barcode scanner is implemented on WebAssembly, then it will be guaranteed to work.  Strong typing and the structure of the WebAssembly byte-code make it possible to always keep the ‚Äúhot path‚Äù of execution.  In addition, we already have a C ++ library for native applications.  C ++ libraries are ideal candidates for compiling to WebAssembly.  We thought the problem was solved.  It turned out not quite. <br><br><h2>  Architecture </h2><br>  The working prototype architecture for a barcode scanner on WebAssembly was fairly simple. <br><br><ul><li>  Compile the C ++ library using <a href="https://emscripten.org/">Emscripten</a> .  It will issue the link code and the .wasm file. <br></li><li>  Select a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Worker">worker</a> thread from the main thread.  The JavaScript code for the worker imports the generated JavaScript junction code, which in turn creates the .wasm file. <br></li><li>  The main stream sends a snapshot from the stream from the camera to the worker's stream, and it will call the corresponding WASM API through the linking code.  The API response is transmitted to the main thread.  The response can be a UPC string (which is transmitted to the backend) or an empty string if no barcode is detected. <br></li><li>  For an empty response, the above step is repeated until a bar code is detected.  This cycle runs for the specified time interval in seconds.  Once the threshold is reached, we will display the warning message <i>‚ÄúInvalid product code.</i>  <i>Try a different barcode or search by text</i> . <i>‚Äù</i>  Either the user did not focus the camera on a real bar code, or the scanner is not effective enough.  We track timeout statistics as an indicator of the quality of the scanner. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50e/08c/b99/50e08cb9985f38e32a51caefe0a0356d.png"></div><br>  <i><font color="gray">WebAssembly Workflow</font></i> <br><br><h4>  Compilation </h4><br>  The first step in any WebAssembly project is to define a clear compilation pipeline.  Emscripten has become the de facto standard for compiling WebAssembly, but it is important to have a consistent environment that produces a deterministic result.  Our frontend is based on Node.js, so you need to find a solution that is compatible with the npm workflow.  Fortunately, at about that time <a href="https://twitter.com/dassurma">Surma Das</a> published an article <a href="https://developers.google.com/web/updates/2019/01/emscripten-npm">called ‚ÄúEmscripten and npm‚Äù</a> .  The <a href="https://www.docker.com/">Docker-</a> based approach to compiling WebAssembly makes sense because it eliminates a lot of overhead.  As recommended in the article, we took the Docker <a href="https://hub.docker.com/r/trzeci/emscripten/">image of Emscripten</a> from <a href="https://github.com/trzecieu/">trzeci</a> .  That compilation in WebAssembly became possible, the native C ++ library had to be corrected a little.  Basically, we acted at random by trial and error.  In the end, we managed to compile it, as well as set up a neat WebAssembly workflow within the existing assembly pipeline. <br><br><h4>  It works fast, but ... </h4><br>  Scanner performance is measured by the number of frames processed by the Wasm API per second.  The Wasm API takes a frame from the camera's video stream, performs calculations and returns a response.  This is done on an ongoing basis until a bar code is detected.  Performance is measured in FPS. <br><br>  Our WebAssembly implementation showed an amazing 50 FPS speed during testing.  However, it worked only in 60% of cases, and in the rest it took off on a timeout.  Even with such a high FPS, they could not quickly detect the bar code for the remaining 40% of scans, producing a warning message at the end.  For comparison, the previous JavaScript implementation usually worked at a speed of 1 FPS.  Yes, WebAssembly is much faster (50 times), but for some reason it does not work in almost half the time.  It should also be noted that in some situations, JavaScript worked very well and immediately found the barcode.  One of the obvious options was to increase the timeout, but this would only increase the frustration of users, and so we do not solve the real problem.  Therefore, we abandoned this idea. <br><br>  At first, we could not understand why the native C ++ library, which worked perfectly in native applications, did not show the same result on the web.  After extensive testing and debugging, we found that the recognition speed depends on the focusing angle of the object and the background shadow.  But how then does everything work in native applications?  The fact is that in native applications, we use the built-in API for autofocusing and allow the user to focus manually by pointing the barcode with his finger.  Therefore, native applications always provide the library with high-quality clear images. <br><br>  Realizing the essence of what is happening, we decided to try another native library: a fairly popular and stable open source <a href="https://github.com/ZBar/ZBar">ZBar</a> barcode scanner.  More importantly, it works well with blurred and grainy images.  Why not try?  Since we already had the WebAssembly workflow, the compilation and deployment of ZBar to WebAssembly went smoothly.  Performance was decent, around 15 FPS, although not as good as our own C ++ library.  But the success rate was close to 80% for the same timeout.  An obvious improvement compared to our C ++ library, but still not 100%. <br><br>  The result did not satisfy us yet, but we noticed something unexpected.  Where Zbar crashed on time-out, our own C ++ library did the work very quickly.  It was a pleasant surprise.  It seems that libraries processed images of different quality in different ways.  This led us to the idea. <br><br><h4>  Multithreading and speed racing </h4><br>  Probably, you already understood.  Why not create two threads of workers: one for Zbar and the other for our C ++ library, and not run them in parallel.  Whoever won (who first sends a valid barcode) sends the result to the main stream, and both workers stop.  We implemented such a scenario and started testing ourselves, trying to imitate as many scripts as possible.  This setting showed 95% of successful scans.  Much better than previous results, but still not 100%. <br><br>  One of the strange suggestions was to add the original JavaScipt library to the competition.  It will be three streams.  We honestly did not think that this would change anything.  But such a test did not require any effort, because we standardized the working interface.  To our surprise, with three streams, the success rate was really close to 100%.  This again was completely unexpected.  As mentioned earlier, JavaScript worked very well in some situations.  Apparently, he closed the gap.  So popular wisdom is right - <a href="https://brendaneich.github.io/ModernWeb.tw-2015/">‚ÄúJavaScript always wins</a> . <a href="https://brendaneich.github.io/ModernWeb.tw-2015/">‚Äù</a>  If no joke, the following illustration provides an overview of the final architecture that we implemented. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/422/f91/050/422f9105014e7571197453c7d2c9f6ec.png"></div><br>  <i><font color="gray">Barcode Scanner Web Architecture</font></i> <br><br>  The following figure shows the high-level function diagram: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4a6/a74/005/4a6a740059f1599e759d9641a3251233.png"></div><br>  <i><font color="gray">Barcode Scanner Functional Diagram</font></i> <br><br><h4>  Resource Download Note </h4><br>  The resources necessary for the operation of the scanner are preloaded after rendering the main page.  This way, the landing page loads quickly and is ready for interaction.  WebAssembly resources (wasm files and glue code scripts) and the JavaScript scanner library are preloaded and cached using <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a> after loading the main page.  It is important here that they are not executed immediately in order to leave the main thread free for the user to interact with the page.  Execution occurs only when the user clicks on the barcode icon.  If the user clicks on the icon before loading the resources, they will be loaded on demand and immediately executed.  The barcode scanner event handler and the worker controller are loaded along with the page, but they are very small. <br><br><h2>  results </h2><br>  After rigorous testing and internal use by employees, we launched A / B testing on users.  The test group was shown the scanner icon (screenshot below), and the control group was not. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb5/a30/074/bb5a300749c27008137e8f45c9bdced9.png"></div><br>  <i><font color="gray">Final product</font></i> <br><br>  To assess success, we introduced the metric ‚ÄúDraft Completion Rate‚Äù.  This is the time between the start of editing a draft and submitting the form.  The metric should show how a barcode scanner helps people fill out forms.  The test lasted several weeks, and the results were very pleasant.  They are completely consistent with our original hypothesis.  <b>Draft completion time decreased by 30% for flow with barcode scanner.</b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c7f/f62/177/c7ff62177f92bc9f19059c569f2531ed.png"></div><br>  <i><font color="gray">A / B test results</font></i> <br><br>  We also added profiling to evaluate the effectiveness of all types of scanners.  As expected, Zbar made the largest contribution (53% of successful scans), then our C ++ library (34%) and, finally, the JavaScript library from 13%. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a31/359/c5c/a31359c5c4211bf10548d8162370da89.png"></div><br><br><h2>  Conclusion </h2><br>  The experience of implementing WebAssembly has become very informative for us.  Engineers are very pleased with the emergence of new technologies and immediately want to try them out.  If the technology is also useful for customers, then this is a double joy.  We repeat the idea expressed at the beginning of the article.  Technology is developing at a very fast pace.  Every day something new appears.  But few technologies matter to customers, and WebAssembly is one of them.  Our biggest conclusion from this exercise is to say ‚Äúno‚Äù in 99 situations and ‚Äúyes‚Äù in the only case where it is really important for customers. <br><br>  In the future, we plan to expand the use of a barcode scanner and implement it on the buyers side so that they can scan product codes offline for their search and purchase on eBay.  Also consider the option to extend the function using the Shape Detection API and other functions in the browser.  But we are glad that we have found the right way to use WebAssembly on eBay and successfully applied the technology in e-commerce. <br><br>  Special thanks to Surme Das and <a href="https://twitter.com/linclark">Lin Clark</a> for the many articles on WebAssembly.  They really helped us break the deadlock several times. </div><p>Source: <a href="https://habr.com/ru/post/453712/">https://habr.com/ru/post/453712/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../4537/index.html">Podcasting is changing traditional media.</a></li>
<li><a href="../45370/index.html">HolyWar: ‚Äã‚ÄãTemplate engines. Do they need? Are they wealthy? Forum.</a></li>
<li><a href="../453700/index.html">SDL 2 Tutorials: Lesson 1 - Hello, SDL 2</a></li>
<li><a href="../453706/index.html">How I passed the Google Cloud Professional Data Engineer certification exam</a></li>
<li><a href="../453708/index.html">Real-time OS AQUA RTOS for AVR MK in BASCOM AVR environment</a></li>
<li><a href="../453714/index.html">Test client TON (Telegram Open Network) and new language Fift for smart contracts</a></li>
<li><a href="../45372/index.html">Our VoIP startup Octopus</a></li>
<li><a href="../453720/index.html">Subtleties of Lambda Expressions in C #</a></li>
<li><a href="../453722/index.html">On the study of non-stationary processes</a></li>
<li><a href="../453728/index.html">Battle of Hyperstar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>