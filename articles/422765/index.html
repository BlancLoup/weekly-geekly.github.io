<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>OpenID Connect 1.0 On Fingers</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At OpenID Connect there is a specification , there are tutorials, articles on habr and not on habr. It is rather senseless to sculpt the next step-by-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>OpenID Connect 1.0 On Fingers</h1><div class="post__text post__text-html js-mediator-article"><p>  At <strong>OpenID Connect</strong> there is a <a href="http://openid.net/specs/openid-connect-core-1_0.html">specification</a> , there are tutorials, articles on <a href="https://habr.com/post/281406/">habr</a> and not on habr.  It is rather senseless to sculpt the next step-by-step instructions leading from deep bewilderment to working through authorization and authentication.  The task of the text below is different, to describe the ideas underlying the specifications (there are more than one). </p><br><p>  I will not bounce on the topic of the article right away, but I will start with simple things and many obvious ones.  I will continue with how they developed and what they drew upon them according to the requirements of the customers.  I approach him historically, that is, the very way he came into being. </p><br><p><img src="https://habrastorage.org/webt/bh/5i/br/bh5ibr5bu0wxmial0gdp6uxy_bg.png"></p><a name="habracut"></a><br><p>  one. </p><br><p>  The task at least - just do not let anyone get to some of its resources.  We close it with a username / password, who knows the appropriate pair from the login and password will get to the resource, who does not - no.  This thing is called <strong>authentication</strong> , for it you can use not only logins with passwords (code from SMS, for example, or a hardware USB key), but these details are not essential for our topic.  I will also omit the obligatory paragraph about the danger of transmitting passwords over the Internet in open form, for which we all do not like <a href="https://en.wikipedia.org/wiki/Basic_access_authentication">Basic access authentication</a> . </p><br><p>  I'd rather note this: none of the users like to enter logins with passwords.  SMS codes are no better, and USB keys just hate it at all.  In order not to force the user to enter a login with a password for each request, the server in response to them sends a line of abracadabra, called a <strong>session key</strong> .  And then this key clings the client to each request to the server (usually an HTTP header, but this is not essential), and the server checks if it has such a session. </p><br><p>  <em>Session with the key - phenomena, by definition, temporary, the golden ratio for the session lifetime is approximately ‚Äúwhile the browser tab is open, but not longer than a day‚Äù</em> </p><br><p>  2 </p><br><p>  Let someone go - it's good.  Now you need to understand who we let.  And not only to bring out what he entered as a name in the upper right corner, but also to decide what to allow him and what not. </p><br><p>  And all this is called - <strong>authorization</strong> .  And I'm not sure about you, but I confuse it with authentication all the time.  In order not to be confused - with regard to the mnemonic rule, ‚Äúauthorization‚Äù - from the word ‚Äúauthor‚Äù, ‚Äúauthor‚Äù they write on the covers of books, and there they never write ‚Äúa validated member of the Writers' Union‚Äù.  The author is always a very specific person.  So, authorization is a process, when we understand who exactly we started by login and password. </p><br><p>  3 </p><br><p>  OK.  We have a website, there is something secret on the website, we require a password at the entrance to the secret part, we only show each person his secrets, and do not show others.  Life does not stand still, and we have another site.  And here we again meet the problem from point 1, no one likes to enter logins and passwords!  You can combine the user base and it will save them from having to register twice, but how to save them from re-entering their login and password at the entrance?  Given the existence of such a thing as the <a href="https://en.wikipedia.org/wiki/Same-origin_policy">Same Origin Policy</a> (and our sites are located, of course, on different domains, it means that cookies with the session key are not visible to another)?  Here, to give importance to the moment, I will start a new item. </p><br><p>  four. </p><br><p><img src="https://habrastorage.org/webt/yg/4j/7l/yg4j7l4kjiavq0v3jictaduihw4.jpeg"></p><br><p>  <strong>SSO</strong> , <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D1%2585%25D0%25BD%25D0%25BE%25D0%25BB%25D0%25BE%25D0%25B3%25D0%25B8%25D1%258F_%25D0%25B5%25D0%25B4%25D0%25B8%25D0%25BD%25D0%25BE%25D0%25B3%25D0%25BE_%25D0%25B2%25D1%2585%25D0%25BE%25D0%25B4%25D0%25B0">Single Sign On</a> - whatever the implementation, Microsoft's Kerberos, SAML or something <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a> , on top of which <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a> is built, about which I am writing to you here, in fact, under the hood is always the same: there is a separate <strong>server authorization</strong> , and anyone who wants to authorize the user redirects the user to him.  If the user is already authorized, the session is picked up, and he immediately flies away from the authorization server and gets where he wanted.  If not authorized, the authorization server solves this problem as best it can, asking for a login with a password, as a rule, and, if successfully resolved, sends the user back. </p><br><p>  At the same time, SAML is currently an outdated solution.  And Kerberos is a completely separate, closed Maycrosoft magic that goes far beyond the HTTP protocol.  Well, we focus on it.  And then we come to the next problem. </p><br><br><p>  There is already a clear scenario of work - in any incomprehensible situation, send the user to the authorization server, let him decide what to do with it and return the finished answer.  But how exactly will the authorization server tell the other server that the user is authorized?  Here we return again to the ideas of the first point, namely, to the session key.  Let's return to the sources: the presence of the session key is a sign of authorization, the session key itself unlocks the door to the user information, and, you won‚Äôt believe, the information about the session.  This means that the authorization server authorizes and gives the session key to another server. </p><br><p>  Now, however, it is called a <strong>token</strong> , not a session key. <br>  Or rather, (using the <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a> protocol, on top of which OpenID Connect is written), there are two tokens at once - <strong>Access Token</strong> , to cling it to all requests like grandfathers hooked session keys, and <strong>Refresh Token</strong> , to update Access Token when it goes dead. </p><br><p>  Let's summarize the subtotal.  Instead of asking the user for a username and password, the server sends it to another server, a separate authorization server.  He does all the work, and then gives the first tokens.  Exactly according to this scenario, applications, mobile and sometimes desktop, are authorized. They do not make any redirects, they simply send JSON with login and password to the authorization server, and the latter sends them tokens in response. </p><br><p>  Mobile and desktop applications as you can.  They are somehow considered safer than the web, but life on the web is more complicated. </p><br><p>  6 </p><br><p>  On the one hand, it is not more complicated, but vice versa is simpler  You can make a redirect and not bother yourself with drawing a login and password form.  On the other hand, I really, really don't want to drag the tokens through the browser in the open form.  It is almost as disgustingly insecure as an unencrypted password in <a href="https://en.wikipedia.org/wiki/Basic_access_authentication">Basic access authentication</a> .  But no one wants to repeat that old terrible mistake. </p><br><p>  The solution to the problem was found not to say that it is very elegant, but working.  At first, everything goes as usual, the transition to authorization, the actual authorization.  Then, when it comes time to go back with tokens, a reverse redirect occurs.  But instead of tokens, a one-time code is attached to the return address.  The one-time code is just generated by the authorization server only for this particular point.  He has a very short lifetime.  As soon as a one-time code was received, another server had to tuck the skirts, eyes bulging and rush to the authorization server again in order to receive the desired tokens using the one-time code. </p><br><p>  For a hike with a code for tokens on the authorization server there is a special resource.  It accepts, according to the specification, not GET, but POST.  What as it hints to us that this request should be done not from the browser, but from server to server. </p><br><p>  <em>For the same reason, on any self-respecting authorization CORS server for POST requests is prohibited.</em> </p><br><p>  7 </p><br><p>  By the way, do you still remember about authentication and authorization?  Authentication is when someone is simply allowed to login and password, or not allowed.  And authorization is when already started up, they start to figure out who exactly was allowed. </p><br><p>  Do you remember about <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a> ?  I mentioned it a couple of times above, as some kind of foundation for OpenID Connect. </p><br><p>  And remember about <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a> ?  This is just an article about him. </p><br><p> So, <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a> is authentication.  All the previously described slightly complicated procedure with three participants, a password, a code and a token is all about authentication, just about launching someone somewhere.  OAuth 2.0 protocol. </p><br><p>  <a href="http://openid.net/specs/openid-connect-core-1_0.html">OpenID Connect</a> is authorization.  That is, to OAuth, he adds those parts where it turns out who was allowed. </p><br><p>  To do this, another one is added to the list of tokens, it is called <a href="https://jwt.io/">ID Token</a> .  Those who followed the link are probably surprised not having encountered anything about any ID Token.  Let surprise not turn into fright, <strong>ID Token</strong> is <a href="https://jwt.io/">JWT</a> , returned as a base64-encoded matryoshka in the same JSON as Access Token and Refresh Token.  In any case, everything you wanted to know about the user is in it. </p><br><p>  And there is also a special resource on the authorization server called userinfo, where you can knock on Access Token, and get back the same JSON as in ID Token.  But why is it needed if you already have an ID Token?  Question to the authors of the specs. </p><br><p>  OpenID Connect also contains descriptions of various user information fields.  Togo how you can get this information, directly during the authorization or at any time after.  And a description of how and when the user will allow you to use this information. <br>  Or not allowed.  So, in short, and OpenID Connect 1.0 is arranged. </p><br><p>  eight. </p><br><p>  A little tinsel in the protocol.  I hope that you are tired enough of reading the article at the moment, so as not to give this item a lot of attention, just running through his eyes.  Here I will mention the parameters that are in the specification, and they carry some semantic load, but the implementation of the idea itself is not directly related.  Basically, they add security, well, or simply allow you to pass some information from one of the participants to the other, if necessary. </p><br><p>  <strong>Client ID and Client Secret</strong> .  Client in the language of the OpenID Connect protocol is not a browser at all, but the other server that needs to be authorized by the user.  Suppose you have a website, and you want to fasten to it a trendy authorization through Facebook.  And through googol.  And not so fashionable through Twitter.  Implementing a protocol in code is not enough.  You will also need to register on Facebook, and Google, and Twitter, but not as a user, but as the same client who, as a server, can use their authorization.  When registering, you will receive from the conditional Facebook Client ID and Client Secret.  And when requesting authorization, among other things, send the Client ID.  And when you go with a one-time code for a token, Client Secret will also be required from you. </p><br><p>  <strong>Redirect URI</strong> .  It's simple.  When sending a user to a conditional Facebook login, you need to tell Facebook where to return the codes and tokens after authorization.  Of course, you still give him your Client ID.  But a separate Redirect URI allows you to transfer after authorization different users to different pages, for example admins on the admin area, and ordinary users to their personal pages.  Practical  In addition, the permitted list of possible Redirect URIs set in the client settings on the conditional Facebook is an additional security. </p><br><p>  <strong>Scope</strong> .  This is a list of what the server wants to know about the user from the authorization server.  The values ‚Äã‚Äãin the list are separated by spaces, openid among them must be necessary, and then read the specification. </p><br><p>  <strong>State</strong> .  Remember about the one-time code on which tokens are issued, like a coupon in an electronic queue?  So, a state is a code on the contrary, if the authorization server issues a code to another server so that it will soon return it, that state another server issues to the authorization server so that it returns it during a redirect.  I need it, as far as I understand, in case the other server has already managed to create its own session so that it is not lost in all these redirects. </p><br><p>  There are other parameters, such as the type of request for authorization and the lifetime of tokens, but to understand why you don‚Äôt need them. </p><br><br><p>  In conclusion.  I really hope that not too thoughtful and focused reading of the text above somewhere helped you catch the ideas that underlie some modern access control protocols.  But starting the implementation, or just setting up any of them, open the spec, find a good tutorial, and carefully follow each word and each letter.  And let the understanding of ideas wake up in you and intuition.  But let your intuition bite you in the crown every time you miss a parameter or setting that is not so essential at first glance, and leave it a hole for sweaty playful little hands. </p><br><p>  Remember that this is all the same security, and its rules, no matter how stupid and meaningless they seem, are written in blood.  Well, maybe not entirely in blood, this is not a safety technique in the foundry, in the end, but money and reputation for sure, and money and reputation are also not the kind of things that should be scattered like that. </p><br><p>  Thank you <strong>JM</strong> for the fact that the text you read was much better than the one I wrote. </p><br><p>  Good luck and do not forget to renew certificates in time. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/422765/">https://habr.com/ru/post/422765/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../422755/index.html">Will the portfolio protect against crypt drawdowns?</a></li>
<li><a href="../422757/index.html">Without politics. How to permanently transform street protests using a mobile application?</a></li>
<li><a href="../422759/index.html">Interactive map for a web application in a couple of hours</a></li>
<li><a href="../422761/index.html">Four paths from the Yandex Data Analysis School</a></li>
<li><a href="../422763/index.html">Digital events in Moscow from 10 to 16 September</a></li>
<li><a href="../422767/index.html">Conference DEFCON 16. Fedor, hacker InSecure.org. NMAP Internet Scan</a></li>
<li><a href="../422769/index.html">Winners Startup Battlefield TechCrunch Disrupt San Francisco 2018</a></li>
<li><a href="../422771/index.html">Design rules, a new level and design thinking</a></li>
<li><a href="../422773/index.html">Nvidia. Revealing the secrets of the next generation GPU Turing architecture: double Ray Tracing, GDDR6, and more</a></li>
<li><a href="../422775/index.html">Conference DEFCON 22. Andrew "Zoz" Brooks. Don't screw it up! Part 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>