<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Unmanaged C ++ library in .NET. Full integration</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article describes the full integration of C ++ libraries in a managed environment using Platform Invoke. Full integration implies the possibility ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Unmanaged C ++ library in .NET. Full integration</h1><div class="post__text post__text-html js-mediator-article">  The article describes the full integration of C ++ libraries in a managed environment using Platform Invoke.  Full integration implies the possibility of class inheritance of the library, the implementation of its interfaces (the interfaces will be represented in managed code as abstract classes).  Instances of the heirs can be "transferred" to the unmanaged environment. <br><a name="habracut"></a><br>  The issue of integration has been raised more than once in Habr√©, but, as a rule, it is dedicated to the integration of a couple of methods that cannot be implemented in managed code.  We had the task to take a module from C ++ and make it work in .NET.  The option to write anew, for several reasons, was not considered, so we started the integration. <br><br>  This article does not reveal all the integration issues of the unmanaged module in .NET.  There are also nuances with the transfer of strings, logical values, etc. ... There are documentation on these issues and several articles on Habr√©, so here these questions were not considered. <br><br>  It is worth noting that the .NET wrapper based on Platform Invoke is cross-platform, it can be assembled on Mono + gcc. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <a name="first"></a><h2>  Sealed class integration </h2><br>  The first thing to realize when integrating with Platform Invoke is that this tool allows you to integrate only individual functions.  You can't just take a class and integrate it.  The solution to the problem looks simple: <br><br>  On the Unmanaged side, we write a function: <br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">SomeType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ClassName_methodName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassName * instance, SomeOtherType someArgument)</span></span></span><span class="hljs-function"> </span></span>{ instance-&gt;methodName(someArgument); }</code> </pre> <br>  Do not forget to add extern "C" to such functions so that their names are not decorated with a C ++ compiler.  This would prevent us from integrating these features into .NET. <br><br>  Then we repeat the procedure for all public methods of the class and integrate the functions obtained into the class written in .NET.  The resulting class cannot be inherited, so in .NET such a class is declared as sealed.  How to get around this limitation and what it is connected with - see below. <br>  In the meantime, here is a small example: <br><br>  Unmanaged class: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> mField; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: A( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> someArgument); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> someArgument)</span></span></span></span>; };</code> </pre><br>  Functions for integration: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">A * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A_createInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> someArgument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> A(someArgument); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A_someMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A *instance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> someArgument)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance-&gt;someMethod( someArgument); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A_deleteInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(A *instance)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> instance; }</code> </pre><br>  Implementation in .Net: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">A</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IntPtr mInstance; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mDelete; [ DllImport( <span class="hljs-string"><span class="hljs-string">"shim.dll"</span></span>, CallingConvention = CallingConvention .Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A_createInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> someArgument</span></span></span><span class="hljs-function">)</span></span>; [ DllImport( <span class="hljs-string"><span class="hljs-string">"shim.dll"</span></span>, CallingConvention = CallingConvention .Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A_someMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr instance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> someArgument</span></span></span><span class="hljs-function">)</span></span>; [ DllImport( <span class="hljs-string"><span class="hljs-string">"shim.dll"</span></span>, CallingConvention = CallingConvention .Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A_deleteInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr instance</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr instance</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(instance != IntPtr.Zero); mInstance = instance; mDelete = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> someArgument</span></span></span><span class="hljs-function">)</span></span> { mInstance = A_createInstance(someArgument); mDelete = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">someMethod</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> someArgument</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> A_someMethod(mInstance, someArgument); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUnmanaged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mInstance; } ~A() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mDelete) A_deleteInstance(mInstance); } }</code> </pre><br>  The internal constructor and method are needed to get class instances from unmanaged code and pass them back.  It is with the transfer of a class instance back to the unmanaged environment that the problem of inheritance is related.  If class A is inherited in .NET and overridden a number of its methods (imagine that someMethod is declared with the virtual keyword), we will not be able to call the redefined code from the unmanaged environment. <br><img src="https://habrastorage.org/files/079/f21/473/079f2147399f46d4b499f51fe9dd8765.png"><br><a name="second"></a><h2>  Interface integration </h2><br>  For the integration of interfaces, we need feedback.  Those.  To fully use the integrated module, we need the ability to implement its interfaces.  The implementation is associated with the definition of methods in a managed environment.  These methods will need to be called from unmanaged code.  This is where Callback Methods, described in the Platform Invoke documentation, comes to our rescue. <br><br>  On the unmanaged side, the Callback environment is represented as a function pointer: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*PFN_MYCALLBACK )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> _MyFunction(PFN_MYCALLBACK callback);</code> </pre><br>  And in .NET, the delegate will play his role: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">UnmanagedFunctionPointerAttribute( CallingConvention.Cdecl)</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCallback</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; [ DllImport(<span class="hljs-string"><span class="hljs-string">"MYDLL.DLL"</span></span>,CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyFunction</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> MyCallback callback</span></span></span><span class="hljs-function">)</span></span>;</code> </pre><br>  With a feedback tool, we can easily provide a call to the overridden methods. <br><br>  But in order to transfer an instance of an interface implementation, in an unmanaged environment, we will also have to present it as an instance of an implementation.  So you have to write another implementation in an unmanaged environment.  In this implementation, we, by the way, lay calls to Callback functions. <br><br>  Unfortunately, this approach will not allow us to do without logic in the managed interfaces, so we will have to present them in the form of abstract classes.  Let's look at the code: <br><br>  Unmanaged interface: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IB</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~IB() {}; };</code> </pre><br>  Unmanaged implementation <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*IB_method_ptr)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnmanagedB</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IB { IB_method_ptr mIB_method_ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMethodHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( IB_method_ptr ptr)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//... / }; void UnmanagedB ::setMethodHandler(IB_method_ptr ptr) { mIB_method_ptr = ptr; } int UnmanagedB ::method(int arg ) { return mIB_method_ptr( arg); }</span></span></code> </pre><br>  UnmanagedB methods simply call the callbacks that the managed class gives it.  Here we are waiting for another trouble.  Until someone has a pointer to UnmanagedB in the unmanaged code, we do not have the right to delete an instance of the class in the managed code that reacts to a callback call.  The last part of the article will be devoted to solving this problem. <br><br>  Functions for integration: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">UnmanagedB *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmanagedB_createInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UnmanagedB(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmanagedB_setMethodHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnmanagedB *instance, IB_method_ptr ptr)</span></span></span><span class="hljs-function"> </span></span>{ instance-&gt;setMethodHandler( ptr); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmanagedB_deleteInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(UnmanagedB *instance)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> instance; }</code> </pre><br>  And here is the interface representation in managed code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">AB</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IntPtr mInstance; [DllImport(<span class="hljs-string"><span class="hljs-string">"shim"</span></span>, CallingConvention = CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmanagedB_createInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>; [DllImport(<span class="hljs-string"><span class="hljs-string">"shim"</span></span>, CallingConvention = CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmanagedB_setMethodHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr instance, [MarshalAs(UnmanagedType.FunctionPtr</span></span></span><span class="hljs-function">)] MethodHandler ptr)</span></span>; [DllImport(<span class="hljs-string"><span class="hljs-string">"shim"</span></span>, CallingConvention = CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmanagedB_deleteInstance</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr instance</span></span></span><span class="hljs-function">)</span></span>; [UnmanagedFunctionPointerAttribute( CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">impl_method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> method(arg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">abstract</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AB</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { mInstance = UnmanagedB_createInstance(); UnmanagedB_setMethodHandler(mInstance, impl_method); } ~AB() { UnmanagedB_deleteInstance(mInstance); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUnmanaged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mInstance; } }</code> </pre><br>  Each interface method has a pair: <br><ol><li>  The public abstract method that we will override </li><li>  The "caller" abstract method (private method with the prefix impl).  It may seem that it does not make sense, but it is not.  This method may contain additional transformations of the arguments and execution results.  It can also contain additional logic for passing exceptions (as you may have guessed, it is not possible to simply transfer an exception from the environment to the environment, exceptions must also be integrated) </li></ol><br>  That's all.  Now we can inherit the class AB and override its method method.  If we need to pass a successor to unmanaged code, we will give mInstance instead, which will call the overridden method via a pointer to a function / delegate.  If we get a pointer to the IB interface from the unmanaged environment, it will need to be represented as an AB instance in a managed environment.  To do this, we implement an AB "default" heir: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BImpl</span></span> : <span class="hljs-title"><span class="hljs-title">AB</span></span> { [DllImport(<span class="hljs-string"><span class="hljs-string">"shim"</span></span>, CallingConvention = CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BImpl_method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr instance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IntPtr mInstance; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BImpl</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr instance</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(instance != IntPtr.Zero); mInstance = instance; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> BImpl_method(mInstance, arg); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUnmanaged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mInstance; } }</code> </pre><br>  Functions for integration: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BImpl_method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(IB *instance , </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg )</span></span></span><span class="hljs-function"> </span></span>{ instance-&gt;method( arg); }</code> </pre><br>  By and large this is the same class integration without support for inheritance, described <a href="https://habr.com/ru/company/simbirsoft/blog/276011/">above</a> .  It's not hard to notice that when creating an instance of BImpl, we also create an instance of UnmanagedB and make unnecessary callback bindings.  If desired, this can be avoided, but these are subtleties; we will not describe them here. <br><img src="https://habrastorage.org/files/520/6a8/d8d/5206a8d8ddbb424fb520db8fd40cba21.png"><br><h2>  Integration of classes with inheritance support </h2><br>  The task is to integrate the class and provide the ability to override its methods.  We will give the pointer to the class to unmanaged, so it is necessary to provide the class with callbacks in order to be able to call the overridden methods. <br><br>  Consider a C class that has an implementation in unmanaged code: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">C</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~C() {}; };</code> </pre><br>  To begin with, we pretend that this is an interface.  We integrate it as well, as was done <a href="https://habr.com/ru/company/simbirsoft/blog/276011/">above</a> : <br><br>  Unmanaged heir for callbacks: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*_method_ptr )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnmanagedC</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> cpp::C { _method_ptr m_method_ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMethodHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _method_ptr ptr)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UnmanagedC ::setMethodHandler(_method_ptr ptr) { m_method_ptr = ptr; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> UnmanagedC ::method(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arg ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_method_ptr( arg); }</code> </pre><br>  Functions for integration: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//...   createInstance  deleteInstance void UnmanagedC_setMethodHandler(UnmanagedC *instance , _method_ptr ptr ) { instance-&gt;setMethodHandler( ptr); }</span></span></code> </pre><br>  And the implementation in .Net: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> IntPtr mHandlerInstance; [DllImport(<span class="hljs-string"><span class="hljs-string">"shim"</span></span>, CallingConvention = CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmanagedC_setMethodHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> IntPtr instance, [MarshalAs(UnmanagedType.FunctionPtr</span></span></span><span class="hljs-function">)] MethodHandler ptr)</span></span>; [UnmanagedFunctionPointerAttribute( CallingConvention.Cdecl)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MethodHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-comment"><span class="hljs-comment">//...     /   private int impl_method( int arg) { return method(arg); } public virtual int method(int arg) { throw new NotImplementedException(); } public C() { mHandlerInstance = UnmanagedC_createInstance(); UnmanagedC_setMethodHandler(mHandlerInstance, impl_method); } ~C() { UnmanagedC_deleteInstance(mHandlerInstance); } internal IntPtr getUnmanaged() { return mHandlerInstance; } }</span></span></code> </pre><br>  So, we can override the C.method method and it will be correctly called from the unmanaged environment.  But we did not provide a default implementation call.  Here the code from the <a href="https://habr.com/ru/company/simbirsoft/blog/276011/">first part of the</a> article will help us: <br>  To call the default implementation, we need to integrate it.  Also, for her work, we need a corresponding instance of the class, which will have to be created and deleted.  We get the already familiar code: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//...    createInstance  deleteInstance int C_method(C *instance, int arg) { return instance-&gt;method( arg); }</span></span></code> </pre><br>  Finish the .Net implementation: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... [DllImport("shim", CallingConvention = CallingConvention.Cdecl)] private static extern int C_method(IntPtr instance, int arg); public virtual int method(int arg) { return C_method(mInstance, arg); } public C() { mHandlerInstance = UnmanagedC_createInstance(); UnmanagedC_setMethodHandler(mHandlerInstance, impl_method); mInstance = C_createInstance(); } ~C() { UnmanagedC_deleteInstance(mHandlerInstance); C_deleteInstance(mInstance); } //... }</span></span></code> </pre><br><img src="https://habrastorage.org/files/e8e/b9a/b62/e8eb9ab628a4472495afea24ca6ce1b6.png"><br>  Such a class can be safely applied in managed code, inherit, redefine its methods, and pass a pointer to it in an unmanaged environment.  Even if we did not override any methods, we still pass the pointer to UnmanagedC.  This is not very rational, given that unmanaged code will call unmanaged class C methods by translating calls through managed code.  But such is the price for the possibility of overriding methods.  In the example attached to the article, this case is demonstrated by calling the method method of class D. If you look at the callstack, you can see the following sequence: <br><img src="https://habrastorage.org/files/6a3/01a/8d1/6a301a8d10634ef8b585cab0a99f06b4.png"><br><h2>  Exceptions </h2><br>  Platform Invoke does not allow you to pass exceptions and to work around this problem, we intercept all exceptions before going from environment to environment, wrap the exception information in a special class and pass it.  On that side, we generate an exception based on the information received. <br><br>  We were lucky.  Our C ++ module generates only exceptions of type ModuleException or its heirs.  So it is enough for us to catch this exception in all methods in which it can be generated.  To forward an exception object to the managed environment, we need to integrate the ModuleException class.  In theory, the exception should contain a text message, but I don‚Äôt want to bother with the topic of marshaling the lines in this article, so the example would be ‚Äúerror codes‚Äù: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ModuleException</span></span> : <span class="hljs-title"><span class="hljs-title">Exception</span></span> { IntPtr mInstance; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mDelete; <span class="hljs-comment"><span class="hljs-comment">//...  create/delete instance [DllImport("shim", CallingConvention = CallingConvention.Cdecl)] private static extern int ModuleException_getCode( IntPtr instance); public int Code { get { return ModuleException_getCode(mInstance); } } public ModuleException( int code) { mInstance = ModuleException_createInstance(code); mDelete = true; } internal ModuleException( IntPtr instance) { Debug.Assert(instance != IntPtr.Zero); mInstance = instance; mDelete = false; } ~ModuleException() { if (mDelete) ModuleException_deleteInstance(mInstance); } //...  getUnmanaged }</span></span></code> </pre><br>  Now suppose that the C :: method method can throw a ModuleException exception.  Rewrite the class with exception support: <br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//    ,     typedef int (*_method_ptr )(int arg, ModuleException **error); int UnmanagedC ::method(int arg ) { ModuleException *error = nullptr; int result = m_method_ptr( arg, &amp;error); if (error != nullptr) { int code = error-&gt;getCode(); //...    error      throw ModuleException(code); } return result; }</span></span></code> </pre><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">C_method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(C *instance, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg, ModuleException ** error)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance-&gt;method( arg); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> ( ModuleException&amp; ex) { *error = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ModuleException(ex.getCode()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">C</span></span> { <span class="hljs-comment"><span class="hljs-comment">//... [DllImport("shim", CallingConvention = CallingConvention.Cdecl)] private static extern int C_method(IntPtr instance, int arg, ref IntPtr error); [UnmanagedFunctionPointerAttribute( CallingConvention.Cdecl)] private delegate int MethodHandler( int arg, ref IntPtr error); private int impl_method( int arg, ref IntPtr error) { try { return method(arg); } catch (ModuleException ex) { error = ex.getUnmanaged(); return 0; } } public virtual int method(int arg) { IntPtr error = IntPtr.Zero; int result = C_method(mInstance, arg, ref error); if (error != IntPtr.Zero) throw ModuleException(error); return result; } //... }</span></span></code> </pre><br>  Here we are also in trouble with memory management.  In the impl_method method, we pass a pointer to an error, but Garbage Collector can remove it before it is processed in unmanaged code.  It's time to deal with this problem! <br><br><h2>  Garbage collector against callbacks </h2><br>  Here I must say that we are more or less lucky.  All classes and interfaces of the integrated module inherit from a certain IObject interface containing the addRef and release methods.  We knew that everywhere in the module, passing the pointer made the call to addRef.  And whenever the need for a pointer disappeared, release was called.  Due to this approach, we could easily track whether the pointer needed by the unmanaged module or whether the callbacks can already be deleted. <br><br>  To avoid deleting the managed objects used in the unmanaged environment, we need a manager of these objects.  It will take the addRef and release calls from the unmanaged code and release the managed objects when they are no longer needed. <br><br>  The addRef and release calls will be forwarded from unmanaged code to managed, so the first thing we need is a class that will provide such a forwarding: <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">long</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*UnmanagedObjectManager_remove )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * instance)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">typedef</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">void</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*UnmanagedObjectManager_add )</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * instance)</span></span></span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnmanagedObjectManager</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> UnmanagedObjectManager mInstance; UnmanagedObjectManager_remove mRemove; UnmanagedObjectManager_add mAdd; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *instance)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">long</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *instance)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAdd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( UnmanagedObjectManager_add ptr)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setRemove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( UnmanagedObjectManager_remove ptr)</span></span></span></span>; }; UnmanagedObjectManager UnmanagedObjectManager ::mInstance; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UnmanagedObjectManager ::add(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * instance ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mInstance.mAdd == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; mInstance.mAdd( instance); } <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> UnmanagedObjectManager ::remove(<span class="hljs-keyword"><span class="hljs-keyword">void</span></span> * instance ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mInstance.mRemove == <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mInstance.mRemove( instance); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UnmanagedObjectManager ::setAdd(UnmanagedObjectManager_add ptr ) { mInstance.mAdd = ptr; } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> UnmanagedObjectManager ::setRemove(UnmanagedObjectManager_remove ptr) { mInstance.mRemove = ptr; }</code> </pre><br>  The second thing we need to do is redefine the addRef and release of the IObject interface so that they change the values ‚Äã‚Äãof our manager‚Äôs counter stored in the managed code: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TObjectManagerObjectImpl</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T { <span class="hljs-keyword"><span class="hljs-keyword">mutable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> mManagedObjectReleased; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TObjectManagerObjectImpl() : mManagedObjectReleased( <span class="hljs-literal"><span class="hljs-literal">false</span></span>) { } <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~TObjectManagerObjectImpl() { UnmanagedObjectManager::remove(getInstance()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getInstance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> *) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addRef</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ UnmanagedObjectManager::add(getInstance()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">release</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> result = UnmanagedObjectManager::remove(getInstance()); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mManagedObjectReleased) <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result == <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">resetManagedObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ mManagedObjectReleased = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } };</code> </pre><br>  Now the UnmanagedB and UnmanagedC classes need to be inherited from the TObjectManagerObjectImpl class.  Consider the example of UnmanagedC: <br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UnmanagedC</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> TObjectManagerObjectImpl &lt;C&gt; { _method_ptr m_method_ptr; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: UnmanagedC(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setMethodHandler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( _method_ptr ptr)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">method</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> arg)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~UnmanagedC(); };</code> </pre><br>  Class C implements the IObject interface, but now the addRef and release methods are redefined by the TObjectManagerObjectImpl class, so the object manager in a managed environment will be responsible for counting the number of pointers. <br>  It's time to take a look at the code of the manager himself: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">ObjectManager</span></span> { <span class="hljs-comment"><span class="hljs-comment">//...  ,  , .  private static AddHandler mAddHandler; private static RemoveHandler mRemoveHandler; private class Holder { internal int count; internal Object ptr; } private static Dictionary&lt; IntPtr, Holder&gt; mObjectMap; private static long removeImpl( IntPtr instance) { return remove(instance); } private static void addImpl(IntPtr instance) { add(instance); } static ObjectManager() { mAddHandler = new AddHandler(addImpl); UnmanagedObjectManager_setAdd(mAddHandler); mRemoveHandler = new RemoveHandler(removeImpl); UnmanagedObjectManager_setRemove(mRemoveHandler); mObjectMap = new Dictionary&lt;IntPtr , Holder &gt;(); } internal static void add(IntPtr instance, Object ptr = null) { Holder holder; if (!mObjectMap.TryGetValue(instance, out holder)) { holder = new Holder(); holder.count = 1; holder.ptr = ptr; mObjectMap.Add(instance, holder); } else { if (holder.ptr == null &amp;&amp; ptr != null) holder.ptr = ptr; holder.count++; } } internal static long remove(IntPtr instance) { long result = 0; Holder holder; if (mObjectMap.TryGetValue(instance, out holder)) { holder.count--; if (holder.count == 0) mObjectMap.Remove(instance); result = holder.count; } return result; } }</span></span></code> </pre><br>  Now we have an object manager.  Before transferring the instance of a managed object to the unmanaged environment, we must add it to the manager.  So the getUnmanaged method for classes AB and C needs to be changed.  I will give the code for class C: <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">internal</span></span></span><span class="hljs-function"> IntPtr </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getUnmanaged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ObjectManager.<span class="hljs-keyword"><span class="hljs-keyword">add</span></span>(mHandlerInstance, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mHandlerInstance; }</code> </pre><br>  Now we can be sure that callbacks will work as long as necessary. <br><br>  Given the specifics of the module, you will need to rewrite the classes, replacing all calls to ClassName_deleteInstance with calls to IObject :: release, and also remember to do IObject :: addRef where it is needed.  In particular, this will avoid the premature removal of ModuleException, even if the garbage collector removes the managed wrapper, the unmanaged instance being an IObject descendant will not be deleted until the unmanaged module handles the error and causes IObject_release for it. <br><br><h2>  Conclusion </h2><br>  In fact, while we were engaged in the integration of the module, we experienced a huge amount of emotions, learned a lot of obscene words and learned how to sleep while standing.  Perhaps we should want this article to be useful to someone, but God forbid.  Of course, addressing memory management, inheritance, and passing exceptions was fun.  But we did not integrate three classes and it was not in them by one method.  It was a test of endurance. <br><br>  If, nevertheless, you encounter such a task, then here is a tip for you: love Sublime Text, regular expressions and snippets.  This small set saved us from alcoholism. <br><br>  PS A working library integration example is available at <a href="https://github.com/simbirsoft-public/pinvoke_example">github.com/simbirsoft-public/pinvoke_example</a> </div><p>Source: <a href="https://habr.com/ru/post/276011/">https://habr.com/ru/post/276011/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../275999/index.html">Processing a temporary or permanent replacement of a 1C: Enterprise 8.2-8.3 authentication password</a></li>
<li><a href="../276003/index.html">Cach√© Class Explorer - explore Cach√© in UML notation</a></li>
<li><a href="../276005/index.html">Unsafe to Swift</a></li>
<li><a href="../276007/index.html">Office lighting control over Wi-Fi. Part 3: Driving the Light</a></li>
<li><a href="../276009/index.html">In Lenovo software, the immutable password was sewn 12345678</a></li>
<li><a href="../276013/index.html">Practical use of Linux Deploy on desktops</a></li>
<li><a href="../276015/index.html">HPE Proactive Care Advanced - a new service for a new type of IT</a></li>
<li><a href="../276017/index.html">Adjusted sliding exam, coclassifiers, fractal classifiers and local error probability</a></li>
<li><a href="../276019/index.html">Fuzzy search in the dictionary with the universal Levenshtein automaton. Part 2</a></li>
<li><a href="../276023/index.html">Install / Update Veeam B & R v9 on Hyper-V Server</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>