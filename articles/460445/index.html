<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Lecture course "Basics of digital signal processing"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello! 

 I am often approached by people with questions on problems in the field of digital signal processing (DSP). I tell in detail the nuances, su...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Lecture course "Basics of digital signal processing"</h1><div class="post__text post__text-html js-mediator-article">  Hello! <br><br>  I am often approached by people with questions on problems in the field of digital signal processing (DSP).  I tell in detail the nuances, suggest the necessary sources of information.  But, as time has shown, all listeners lack practical tasks and examples in the process of learning this area.  In this regard, I decided to write a short online course on digital signal processing and put it in <a href="https://github.com/capitanov/dsp-theory">open access</a> . <br><br>  Most of the training material for visual and interactive presentation is implemented using <i>Jupyter Notebook</i> .  It is assumed that the reader has a basic knowledge of higher mathematics, and also knows a little programming language Python. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/vh/4z/ci/vh4zciifrdxclttqfvmpul0zv5a.png"><br><a name="habracut"></a><br><h2>  List of lectures </h2><br>  This course contains materials in the form of complete lectures on various topics in the field of digital signal processing.  Materials are presented using Python libraries (numpy, scipy, matplotlib, etc.).  The main information for this course is taken from my lectures, which I, as a graduate student, read to students of the Moscow Energy Institute (NIU MEI).  Part of the information from these lectures was used at training seminars at the <a href="http://www.sovel.org/">Center for Modern Electronics</a> , where I acted as a lecturer.  In addition, this material includes the translation of various scientific articles, compilation of information from reliable sources and literature on the subject of digital signal processing, as well as official documentation on the application packages and built-in functions of the scipy and numpy libraries of the Python language. <br><br>  For users of MATLAB (GNU Octave), mastering the material in terms of program code is not difficult, since the main functions and their attributes are largely identical and similar to the methods from the Python libraries. <br><br>  All materials are grouped by the main topics of digital signal processing: <br><br><ol><li>  Signals: analog, discrete, digital.  Z-transform </li><li>  Fourier transform: amplitude and phase signal, DFT and FFT, </li><li>  Convolution and correlation.  Linear and cyclic convolution.  Fast convolution </li><li>  Random processes.  White noise.  Probability density function </li><li>  Deterministic signals.  Modulation: AM, FM, FM, chirp.  Manipulation </li><li>  Signal filtering: IIR, FIR filters </li><li>  Window functions in filtering problems.  Detection of weak signals. </li><li>  Resampling: decimation and interpolation.  CIC filters, moving average filters </li></ol><br><br>  The list of lectures is sufficient <s>but, of course, incomplete</s> for an introductory acquaintance with the area of ‚Äã‚ÄãDSP.  With free time, I plan to support and develop this project. <br><br><h3>  Where to find? </h3><br>  All materials are <b>absolutely free</b> and available as an open repository on <a href="https://github.com/capitanov/dsp-theory">my githaba as an opensource project</a> .  The materials are presented in two formats - in the form of notebooks Jupyter Notebook for interactive work, study and editing, and in the form of HTML files compiled from these notebooks (after downloading from the github they have quite a suitable format for reading and printing). <br><br>  Below is a very <u>brief</u> description of the course sections with some explanations, terms and definitions.  Basic information is available in the original lectures, here is only a brief overview! <br><br><h3>  Signals.  Z-transform </h3><br>  The introductory section, which contains basic information on the types of signals.  The concept of a discrete sequence, delta functions and Heaviside functions (a single jump) is introduced. <br><br>  All signals according to the method of representation on the set can be divided into four groups: <br><ul><li>  analog - described by continuous functions in time, </li><li>  discrete - interrupted in time with a step specified discretization, </li><li>  quantized - have a set of final levels (as a rule, in amplitude), </li><li>  digital - a combination of properties of discrete and quantized signals. </li></ul><br><br><img src="https://habrastorage.org/webt/1f/l4/te/1fl4te_9ataaovtla-4morc9uwa.png" alt="Signals"><br><br>  To correctly restore an analog signal from digital without distortion and loss, a sampling theorem known as the <b>Kotelnikov (Nyquist-Shannon)</b> theorem is used. <br><blockquote>  Any continuous signal with a limited spectrum can be recovered unambiguously and without loss in its discrete readings taken at a frequency strictly greater than twice the upper frequency of the spectrum of the continuous signal. </blockquote><br>  Such an interpretation is valid provided that the continuous function of time occupies a frequency band from 0 to the value of the upper frequency.  If the quantization and sampling steps are chosen incorrectly, the conversion of the signal from analog to discrete form will occur with distortion. <br><br>  Also in this section <b>Z-transformation</b> and its properties are described, the representation of discrete sequences in Z-form is shown. <br><br>  Example of a finite discrete sequence: <br><pre><code class="python hljs">x(nT) = {<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">-2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>}</code> </pre>  . <br>  An example of the same sequence in Z-form: <br><br>  X (z) = 2 + z <sup>-1</sup> - 2z <sup>-2</sup> + 2z <sup>-4</sup> + 3z <sup>-5</sup> + 1z <sup>-6</sup> <br><br><h3>  Fourier transform.  Properties  DFT and FFT </h3><br>  This section describes the concept of the time and frequency domain of a signal.  The definition of the discrete Fourier transform (DFT) is introduced.  Considered direct and inverse DFT, their main properties.  The transition from the DFT to the fast Fourier transform (FFT) algorithm at base 2 (frequency and time decimation algorithms) is shown.  Reflects the effectiveness of the FFT in comparison with the DFT. <br><br>  In particular, this section describes the Python package scipy.ffpack for computing various Fourier transforms (sine, cosine, direct, inverse, multidimensional, real). <br><br>  Fourier transform allows you to represent any function as a set of harmonic signals!  The Fourier transform underlies the convolution methods and the design of digital correlators, is actively used in spectral analysis, and is used when working with long numbers. <br><br>  Features of the spectra of discrete signals: <br>  1. The spectral density of a discrete signal is a periodic function with a period equal to the sampling frequency. <br>  2. If the discrete sequence is <i>real</i> , then the modulus of the spectral density of such a sequence is an <i>even</i> function, and the argument is <i>an odd</i> function of frequency. <br><br>  Harmonic spectrum: <br><br><img src="https://habrastorage.org/webt/if/gy/k4/ifgyk4dlgjakj-zrkd3vpzq8c24.png" alt="FFT for cosine"><br><br><h4>  Comparison of the effectiveness of DFT and FFT </h4><br>  The effectiveness of the FFT algorithm and the number of operations performed linearly depends on the length of the sequence N: <br><br><div class="scrollable-table"><table><thead><tr><th rowspan="2">  N </th><th colspan="2">  DFT </th><th colspan="2">  FFT </th><th rowspan="2">  The ratio of the number of complex additions </th><th rowspan="2">  The ratio of the number of complex multiplications </th></tr><tr><th>  The number of multiplication operations </th><th>  The number of additions </th><th>  The number of multiplication operations </th><th>  The number of additions </th></tr></thead><tbody><tr><td>  2 </td><td>  four </td><td>  2 </td><td>  one </td><td>  2 </td><td>  four </td><td>  one </td></tr><tr><td>  four </td><td>  sixteen </td><td>  12 </td><td>  four </td><td>  eight </td><td>  four </td><td>  1.5 </td></tr><tr><td>  eight </td><td>  64 </td><td>  56 </td><td>  12 </td><td>  24 </td><td>  5.3 </td><td>  2.3 </td></tr><tr><td>  sixteen </td><td>  256 </td><td>  240 </td><td>  32 </td><td>  64 </td><td>  eight </td><td>  3.75 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  992 </td><td>  80 </td><td>  160 </td><td>  12.8 </td><td>  6.2 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  4032 </td><td>  192 </td><td>  384 </td><td>  21.3 </td><td>  10.5 </td></tr><tr><td>  128 </td><td>  16384 </td><td>  16256 </td><td>  448 </td><td>  896 </td><td>  36.6 </td><td>  18.1 </td></tr><tr><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td><td>  ... </td></tr><tr><td>  4096 </td><td>  16777216 </td><td>  16773120 </td><td>  24576 </td><td>  49152 </td><td>  683 </td><td>  341 </td></tr><tr><td>  8192 </td><td>  67108864 </td><td>  67100672 </td><td>  53248 </td><td>  106496 </td><td>  <b>1260</b> </td><td>  <b>630</b> </td></tr></tbody></table></div><br>  As you can see, the longer the conversion, the greater the savings in computing resources (in terms of processing speed or the number of hardware blocks)! <br><br>  Any arbitrary waveform can be represented as a set of harmonic signals of different frequencies.  In other words, a complex waveform in the time domain has a set of complex samples in the frequency domain, which are called * harmonics *.  These readings express the amplitude and phase of the harmonic impact at a specific frequency.  The larger the set of harmonics in the frequency domain, the more accurate the signal of complex shape. <br><br><img src="https://habrastorage.org/webt/vj/i1/dg/vji1dgvf4ak0dsvjhlmx7mmhj6q.png" alt="FFT Gibbs"><br><br><h3>  Convolution and correlation </h3><br>  This section introduces the notion of correlation and convolution for discrete random and deterministic sequences.  The connection of the autocorrelation and mutual correlation functions with convolution is shown.  The properties of convolution are described, in particular, methods of linear and cyclic convolution of a discrete signal with detailed analysis are considered using the example of a discrete sequence.  In addition, a method for calculating ‚Äúfast‚Äù convolution using FFT algorithms is shown. <br><br>  In real problems, it is often asked about the degree of similarity of one process to another, or about the independence of one process from another.  In other words, it is required to determine the relationship between the signals, that is, to find a <i>correlation</i> .  Correlation methods are used in a wide range of tasks: signal searching, computer vision and image processing, in radar tasks to determine the characteristics of targets and determine the distance to an object.  In addition, using the correlation search for weak signals in the noise. <br><br>  <b>Convolution</b> describes the interaction of signals with each other.  If one of the signals is the impulse response of the filter, then the convolution of the input sequence with the impulse response is nothing like the response of the circuit to an input.  In other words, the resulting signal reflects the signal passing through the filter. <br><br>  <i>Autocorrelation function</i> (ACF) is used in coding information.  The choice of the coding sequence according to the parameters of length, frequency and shape is largely due to the correlation properties of this sequence.  The best code sequence has the lowest probability of false detection or response (for detecting signals, for threshold devices) or false synchronization (for transmitting and receiving code sequences). <br><br>  This section presents a table comparing the efficiency of fast convolution and convolution calculated by a direct formula (the number of real multiplications). <br><br>  As you can see, for FFT lengths up to 64, fast convolution <u>loses</u> from the direct method.  However, with an increase in the length of the FFT, the results change in the opposite direction ‚Äî fast convolution begins to outperform the direct method.  Obviously, the greater the length of the FFT, the better the gain of the frequency method. <br><br><div class="scrollable-table"><table><thead><tr><th>  N </th><th>  Convolution </th><th>  Fast convolution </th><th>  Attitude </th></tr></thead><tbody><tr><td>  eight </td><td>  64 </td><td>  448 </td><td>  0.14 </td></tr><tr><td>  sixteen </td><td>  256 </td><td>  1088 </td><td>  0.24 </td></tr><tr><td>  32 </td><td>  1024 </td><td>  2560 </td><td>  0.4 </td></tr><tr><td>  64 </td><td>  4096 </td><td>  5888 </td><td>  0.7 </td></tr><tr><td>  128 </td><td>  16K </td><td>  13312 </td><td>  1.23 </td></tr><tr><td>  ... </td><td>  ... </td><td>  .. </td><td>  ... </td></tr><tr><td>  2048 </td><td>  4M </td><td>  311296 </td><td>  <b>13.5</b> </td></tr></tbody></table></div><br><h3>  Random signals and noise </h3><br>  In this section we introduce the concept of random signals, the density of the probability distribution, the law of distribution of a random variable.  Mathematical moments are considered - the mean (expected value) and the variance (or the root of this quantity is the standard deviation).  Also in this section we consider the normal distribution and the concept of <i>white noise</i> associated with it, as the main source of noise (interference) in signal processing. <br><br>  <i>A random signal</i> is a function of time, the values ‚Äã‚Äãof which are unknown in advance and can be predicted only with a certain <i>probability</i> .  The main characteristics of random signals include: <br><br><ul><li>  distribution law (relative time of a signal's value in a certain interval), </li><li>  spectral power distribution of the signal. </li></ul><br><br><img src="https://habrastorage.org/webt/sh/02/ft/sh02ftx_0_ynupvdlzo7uvgmeds.png" alt="Noise AWGN"><br><br>  In DSP tasks, random signals are divided into two classes: <br><br><ul><li>  noise - random fluctuations, consisting of a set of different frequencies and amplitudes, </li><li>  Signals that carry information for which processing it is required to resort to probabilistic methods. </li></ul><br><br>  Using random variables, it is possible to simulate the effect of a real medium on the passage of a signal from a source to a data receiver.  When a signal passes through a noisy link, so-called white noise is added to the signal.  As a rule, the spectral density of such noise is uniformly (equally) distributed at all frequencies, and the noise values ‚Äã‚Äãin the time domain are normally distributed (Gaussian distribution law).  Since white noise is physically added to the amplitudes of the signal at selected time samples, it is called additive white Gaussian noise (AWGN). <br><br><h3>  Signals, modulation and manipulation </h3><br>  This section shows the main ways to change one or more parameters of a harmonic signal.  The concepts of amplitude, frequency and phase modulation are introduced.  In particular, linear frequency modulation applied in radar tasks is highlighted.  The main characteristics of the signals, the spectra of the modulated signals depending on the modulation parameters are shown. <br><br><img src="https://habrastorage.org/webt/b9/sw/c6/b9swc66eoj37yobhgypvjmwizni.png" alt="Freq modulation"><br><br>  For convenience, Python has created a set of functions that implement the listed types of modulation.  An example of the implementation of the chirp signal: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">signal_chirp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(amp=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, freq=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, beta=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0.25</span></span></span></span><span class="hljs-function"><span class="hljs-params">, period=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">100</span></span></span></span><span class="hljs-function"><span class="hljs-params">, **kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Create Chirp signal Parameters ---------- amp : float Signal magnitude beta : float Modulation bandwidth: beta &lt; N for complex, beta &lt; 0.5N for real freq : float or int Linear frequency of signal period : integer Number of points for signal (same as period) kwargs : bool Complex signal if is_complex = True Modulated by half-sine wave if is_modsine = True """</span></span> is_complex = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_complex'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) is_modsine = kwargs.get(<span class="hljs-string"><span class="hljs-string">'is_modsine'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) t = np.linspace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, period) tt = np.pi * (freq * t + beta * t ** <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_complex <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: res = amp * (np.cos(tt) + <span class="hljs-number"><span class="hljs-number">1j</span></span> * np.sin(tt)) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = amp * np.cos(tt) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> is_modsine <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res * np.sin(np.pi * t) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res</code> </pre><br><img src="https://habrastorage.org/webt/ug/ad/85/ugad85xkc0ml7p2e4kgv5niqnbs.png" alt="Chirp modulation"><br><br>  Also in this section from the theory of transmission of discrete messages describes the types of digital modulation - manipulation.  As in the case of analog signals, digital harmonic sequences can be manipulated in amplitude, phase and frequency (or in several parameters at once). <br><br><img src="https://habrastorage.org/webt/yl/w9/8q/ylw98qsdcnn3kaivfz2cdasrxry.png" alt="Freq manipulation"><br><br><h3>  Digital filters - IIR and KIH </h3><br>  A large enough section on digital filtering of discrete sequences.  In digital signal processing tasks, data passes through circuits called <b>filters</b> .  Digital filters, like analog ones, have different characteristics ‚Äî frequency response: frequency response, phase response, time response: impulse response, and filter response.  Digital filters are used primarily to improve the quality of the signal ‚Äî to extract a signal from a data sequence, or to degrade unwanted signals ‚Äî to suppress certain signals in incoming sample sequences. <br><br><img src="https://habrastorage.org/webt/mp/2m/oy/mp2moyuibf5qgzlb19d8ne_gw-q.png" alt="IIR FIR signals"><br><br>  The section lists the main advantages and disadvantages of digital filters (compared to analog filters).  The concept of impulse and transfer filter characteristics is introduced.  Two classes of filters are considered - with infinite impulse response (IIR) and finite impulse response (FIR).  A method of designing filters in <b>canonical</b> and <b>direct</b> form is shown.  For FIR filters, the question of how to transition to a recursive form is considered. <br><br><img src="https://habrastorage.org/webt/qn/m5/x5/qnm5x5wguwanmzjfst2erf0orsa.png" alt="IIR FIR scheme"><br><br>  For FIR filters, the filter design process is shown from the development stage of the technical specification (with indication of the main parameters), to the software and hardware implementation - search for filter coefficients (taking into account the form of number representation, data length, etc.).  The definitions of symmetric FIR filters, linear phase response and its connection with the concept of group delay are introduced. <br><br><img src="https://habrastorage.org/webt/7d/ng/vy/7dngvygzcdsyc4dacklcae2ddsa.png" alt="FIR full path"><br><br><h3>  Window functions in filtering tasks </h3><br>  In the tasks of digital signal processing, window functions of various forms are used, which, when applied to a signal in the time domain, allow to qualitatively improve its spectral characteristics.  A large number of various windows is primarily due to one of the main features of any window overlay.  This feature is expressed in the relationship between the level of side lobes and the width of the central lobe.  Rule: <br><blockquote>  The stronger the suppression of the side lobes of the spectrum, the wider the main lobe of the spectrum and vice versa. </blockquote><br><img src="https://habrastorage.org/webt/lc/mx/em/lcmxemylmukc0mf5xtbwrudsbrm.png" alt="Wins (time)"><br><br>  One of the applications of window functions: the detection of weak signals against the background of stronger by suppressing the level of side lobes.  The main window functions in DSP tasks are ** triangular, sinusoidal, Lanczos window, Hannah, Hamming, Blackman, Harris, Blackman-Harris, flat top window, Natall, Gauss, Kaiser ** window and many others.  Most of them are expressed in a finite series by summing up the harmonic signals with specific weighting factors.  Such signals are perfectly implemented in practice on any hardware devices (programmable logic circuits or signal processors). <br><br><img src="https://habrastorage.org/webt/qo/vo/qg/qovoqg__dcfm--hjd0ibos_m-fm.png" alt="Wins (freq)"><br><br><h3>  Resampling.  Decimation and interpolation </h3><br>  This section deals with multi-speed signal processing ‚Äî changes in the sampling rate.  Multirate processing of signals (multirate processing) assumes that in the process of linear conversion of digital signals it is possible to change the sampling frequency in the direction of reduction, increase or fractional number of times.  This leads to more efficient signal processing, as it opens up the possibility of using the minimum allowable sampling rates and, as a consequence, a significant reduction in the required computing performance of the designed digital system. <br><br>  <i>Decimation</i> (thinning) - lowering the sampling rate.  <i>Interpolation</i> - increasing the sampling rate. <br><br>  The section also discusses a class of homogeneous FIR filters, which are called integral-comb filters (CIC, Cascaded integrator ‚Äì comb).  The implementation, basic properties and features of CIC filters are shown.  Due to the linearity of mathematical operations occurring in the CIC filter, a cascade connection of several filters in a row is possible, which gives a proportional decrease in the side lobe level, but also increases the main lobe of the amplitude-frequency characteristic. <br><br><img src="https://habrastorage.org/webt/qg/ef/ye/qgefyerrdczmun9os1vetvxxdsy.png" alt="Cascade CIC filter"><br><br>  Graph of the frequency response of the filter, depending on the decimation factor: <br><br><img src="https://habrastorage.org/webt/b8/lh/qz/b8lhqzdsk-tcnqxkq9pimvteq4g.png" alt="CIC Freq Responce"><br><br>  Also in this section, the issue of increasing the data width at the output of the CIC filter is discussed depending on its parameters.  This is especially important in the tasks of software implementation, in particular on the FPGA. <br><br>  For the practical implementation of CIC filters in Python, a separate class <b>CicFilter has been developed</b> that implements the methods of decimation and interpolation.  Examples of changing the sample rate using built-in methods from the Python scipy package are also shown. <br><br><div class="spoiler">  <b class="spoiler_title">Python CicFilter Class for Digital Signal Processing</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CicFilter</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Cascaded Integrator-Comb (CIC) filter is an optimized class of finite impulse response (FIR) filter. CIC filter combines an interpolator or decimator, so it has some parameters: R - decimation or interpolation ratio, N - number of stages in filter (or filter order) M - number of samples per stage (1 or 2)* * for this realisation of CIC filter just leave M = 1. CIC filter is used in multi-rate processing. In hardware applications CIC filter doesn't need multipliers, just only adders / subtractors and delay lines. Equation for 1st order CIC filter: y[n] = x[n] - x[n-RM] + y[n-1]. Parameters ---------- x : np.array input signal """</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, x)</span></span></span><span class="hljs-function">:</span></span> self.x = x <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">decimator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, r, n)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" CIC decimator: Integrator + Decimator + Comb Parameters ---------- r : int decimation rate n : int filter order """</span></span> <span class="hljs-comment"><span class="hljs-comment"># integrator y = self.x[:] for i in range(n): y = np.cumsum(y) # decimator y = y[::r] # comb stage return np.diff(y, n=n, prepend=np.zeros(n)) def interpolator(self, r, n, mode=False): """ CIC inteprolator: Comb + Decimator + Integrator Parameters ---------- r : int interpolation rate n : int filter order mode : bool False - zero padding, True - value padding. """ # comb stage y = np.diff(self.x, n=n, prepend=np.zeros(n), append=np.zeros(n)) # interpolation if mode: y = np.repeat(y, r) else: y = np.array([i if j == 0 else 0 for i in y for j in range(r)]) # integrator for i in range(n): y = np.cumsum(y) if mode: return y[1:1 - n * r] else: return y[r - 1:-n * r + r - 1]</span></span></code> </pre><br></div></div><br><br><img src="https://habrastorage.org/webt/mt/ri/b5/mtrib5pqroyzezup5m9ulqsklzg.png" alt="CIC Decimation / Interpolation"><br><br>  Finally, this section presents a special class of filters - the moving average.  Three ways of implementation are shown: through convolution of signals, using an FIR filter and an IIR filter. <br><br><img src="https://habrastorage.org/webt/0m/b7/rf/0mb7rfvv_e6vuzt9xqsumvgs7eq.png" alt="MAF Moving Average filter"><br><br><h3>  Conclusion </h3><br>  I hope this course of lectures in conjunction with my previous articles on digital signal processing on FPGA will bring practical benefits and help the reader better understand the basics of digital signal processing.  This project will be improved and complemented by new useful and equally interesting material.  Follow the development! <br><br>  In addition to this material, I support and develop <a href="https://github.com/capitanov/dsppy">my project</a> on the main DSP modules (in Python).  It contains a package for generating various signals, a class of CIC filters for decimation and interpolation problems, an algorithm for calculating correction coefficients of an FIR filter, a moving average filter, an algorithm for calculating an over-long FFT through two-dimensional transformation methods (the latter is very useful in hardware implementation on the FPGA) . <br><br>  Thanks for attention! </div><p>Source: <a href="https://habr.com/ru/post/460445/">https://habr.com/ru/post/460445/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../460437/index.html">How we put out a tech bike</a></li>
<li><a href="../460439/index.html">P4 programming language</a></li>
<li><a href="../46044/index.html">The British company requires you to give Odnoklassniki and income from them.</a></li>
<li><a href="../460441/index.html">Gleb Nitsman: ‚ÄúI found the very end of an era when people had not yet chased the gold contained in radio elements‚Äù</a></li>
<li><a href="../460443/index.html">Designers vs developers: about the history of creating the application "My smart city"</a></li>
<li><a href="../46045/index.html">Linux Teacher Test</a></li>
<li><a href="../460451/index.html">The man made a third ear for himself to be used by the whole world - for the sake of art</a></li>
<li><a href="../460453/index.html">Smart printer. Improving Octoprint</a></li>
<li><a href="../460457/index.html">Solar power plant on the house 200 m2 do it yourself</a></li>
<li><a href="../46046/index.html">Are you interested in authoring articles on game dev under Windows, XBOX360 and Zune using XNA?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>