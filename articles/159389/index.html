<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We write our std :: function (boost :: function)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The std :: function and boost :: function classes are high-level wrappers for functions and functional objects. Objects of such classes allow you to s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We write our std :: function (boost :: function)</h1><div class="post__text post__text-html js-mediator-article">  The std :: function and boost :: function classes are high-level wrappers for functions and functional objects.  Objects of such classes allow you to store and call functions and functors with a given signature, which is convenient, for example, when creating callback calls (for example, we can register several handlers, and these can be both normal functions and objects with a specific operator =) <br><br>  If you are interested in how this functionality is implemented, then I ask for the cat <br><a name="habracut"></a><br><br><h4>  Brief introduction, examples of use </h4><br>  If you are not familiar with boost :: function and std :: function, you can read them <a href="http://www.boost.org/doc/libs/1_52_0/doc/html/function.html">here</a> and <a href="http://ru.cppreference.com/w/cpp/utility/functional/function">here.</a> <br>  std :: function is included in the c ++ 11 standard, and the gcc-4.7 and msvc-2012 compilers support it (perhaps earlier versions also have support).  In principle, within this article, the implementation from boost and the standard can be considered completely identical, so you can use any of the implementations 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Actually use example: <br><pre><code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func1</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> callable { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } }; <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">... boost::function</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;int (void)&gt;</span></span></span><span class="hljs-comment"> x; x = func1; int res = x(); //  0    callable c; x = c; res = x(); //  1   </span></span></code> </pre> <br><br><h4>  Go to the implementation itself. </h4><br>  We will do the implementation itself in several stages: <br><ul><li>  The simplest use-case is to initialize our object with a function pointer or function object and call the () operator </li><li>  Support for assignment and copy constructors </li><li>  Support pointers to member functions </li></ul><br><h5>  The simplest implementation, the concept of Type erasure </h5><br>  The implementation of this class is based on the <a href="http://www.cplusplus.com/forum/articles/18756/">Type Erasure</a> pattern, more readily available <a href="http://prograholic.blogspot.ru/2011/11/type-erasure.html">here</a> Its purpose is that we can hide behind a single interface various entities (objects, pointers, etc.) that provide similar capabilities (for example, to call functions with three arguments).  Type erasure can also be represented as a bridge that links the runtime polymorphism (runtime polymorfism) and the compile-time polymorphism (compile-time polymorfism). <br><br>  So, go to the implementation. <br>  We will use variadic templates from the standard C ++ 11.  For example, gcc supports this functionality since version <a href="http://gcc.gnu.org/gcc-4.3/cxx0x_status.html">4.3</a> , so you can safely use it. <br><br>  Let's not be original and call our class function.  It is obvious that the class will be a template, it is also obvious that it will have one parameter of the template - the signature (type) of the function being called.  The overall implementation of the template is missing, all work will occur in a partial specialization of the template.  Partial specialization is needed so that we can use the types of the arguments and the return value from our signature. <br>  The implementation itself: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> UnusedType&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ReturnType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... ArgumentTypes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function</span></span></span><span class="hljs-class"> &lt;ReturnType (ArgumentTypes ...)&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: function() : mInvoker() {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FunctionT&gt; function(FunctionT f) : mInvoker(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> free_function_holder&lt;FunctionT&gt;(f)) {} <span class="hljs-function"><span class="hljs-function">ReturnType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArgumentTypes ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mInvoker-&gt;invoke(args ...); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function_holder_base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: function_holder_base() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~function_holder_base() {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReturnType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArgumentTypes ... args)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;function_holder_base&gt; <span class="hljs-keyword"><span class="hljs-keyword">invoker_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FunctionT&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">free_function_holder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> function_holder_base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: free_function_holder(FunctionT func) : function_holder_base(), mFunction(func) {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReturnType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArgumentTypes ... args)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> mFunction(args ...); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: FunctionT mFunction; }; <span class="hljs-keyword"><span class="hljs-keyword">invoker_t</span></span> mInvoker; };</code> </pre> <br>  The function class defines the () operator corresponding to the function signature and transfers control to the invoke method from the function_holder_base class.  This class has the invoke virtual function, which also matches the specified signature (except for the implicit parameter this). <br>  Also, the function class has a template constructor that takes one argument; in this constructor, a descendant of the function_holder_base class free_function_holder is created.  This descendant is a template class ‚Äî it retains the argument passed to it (usually, it is a functor or a function pointer).  It also defines the invoke method, which calls the saved functor with the given arguments. <br><br>  Here it is necessary to note several features of templates in C ++: <br><ul><li>  The type of the return value can be any (including void), that is, the design return mFunction (args ...);  valid even if the return value is void.  This is done specifically for template metaprogramming, in order not to produce specializations for the void type. </li><li>  Variadic templates work in a similar way if the number of input arguments is 0 (a function without parameters). </li><li>  We can write a template class, which is the heir of some base class (and not necessarily a template class) - this is the entire Type erasure pattern </li></ul><br><br>  In principle, we got a workable analogue of std :: function and boost :: function, we can easily write the following code: <pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func2</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (*x) + y; } <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment">... typedef function</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;int (const int * , int)&gt;</span></span></span><span class="hljs-comment"> int_function_with_two_args_t; int_function_with_two_args_t f2(func2); int x = 10; cout </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;&lt; "calling function with signature int (const int * , int): " &lt;&lt; f2(&amp;x, 20) &lt;&lt; endl;</span></span></span></span></code> </pre> <br>  Moving on to improvements in our class: <br><br><h5>  Copy the behavior of a regular function pointer - an assignment statement and a copy constructor </h5><br>  In order to copy or assign an object, we must be able to copy (clone) a pointer to the base class function_holder_base.  To do this, we expand the interface of this class as follows: <br><pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">function_holder_base</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: function_holder_base() {} <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> ~function_holder_base(){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReturnType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ArgumentTypes ... args)</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">auto_ptr</span></span>&lt;function_holder_base&gt; clone() = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: function_holder_base(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> function_holder_base &amp; ); <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> function_holder_base &amp;); };</code> </pre> <br>  We make our class uncopyable (we declare the corresponding operator and constructor in the private section), and declare the clone method so that the heirs themselves determine the correct cloning strategy. <br><br>  Also, assignment statements and a copy constructor are added to the function class: <br><pre> <code class="hljs php"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(const function &amp; other)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mInvoker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(other.mInvoker-&gt;clone</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">()</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(const function &amp; other)</span></span></span><span class="hljs-function"> </span></span>{ mInvoker = other.mInvoker-&gt;clone(); }</code> </pre> <br>  Here we use auto_ptr and its destructive assignment. <br><br>  It remains to write the implementation of the clone method in the heir - free_function_holder: <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> free_function_holder&lt;FunctionT&gt; self_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> invoker_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">invoker_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> self_type(mFunction)); }</code> </pre> <br><br>  That's all, now our class behaves like a normal function pointer, and we can do this: <br><pre> <code class="hljs lua">int func1() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } ///... typedef <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(void)</span></span></span></span>&gt; int_function_t; int_function_t f1(func1); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"calling function with signature int (void): "</span></span> &lt;&lt; f1() &lt;&lt; endl; int_function_t f2; f2 = f1; cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"calling function after assignment operator with signature int (void): "</span></span> &lt;&lt; f2() &lt;&lt; endl; int_function_t f3(f2); cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"calling function after copying ctor with signature int (void): "</span></span> &lt;&lt; f3() &lt;&lt; endl;</code> </pre> <br><br>  Go to the final part: <br><h5>  Add support for pointers to member functions </h5><br>  I got support for method pointers rather limited: you can pass an object to which a pointer to a method is applied only by value (and I would also like a link (const and not const) and a pointer (const and not const)), but in principle for An example of this will be sufficient. <br><br>  When using boost (std) and our function implementation, we adhere to the rule that the first argument must be an object to which the pointer to the method is applied, respectively, the arguments are now divided into two types: the object itself, and the method arguments.  Accordingly, we have a guarantee that the number of arguments is strictly greater than 0, and we will use this further: <br><pre> <code class="hljs cpp"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> FunctionType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ClassType, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> ... RestArgumentTypes&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">member_function_holder</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> function_holder_base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> FunctionType ClassType::* <span class="hljs-keyword"><span class="hljs-keyword">member_function_signature_t</span></span>; member_function_holder(<span class="hljs-keyword"><span class="hljs-keyword">member_function_signature_t</span></span> f) : mFunction(f){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> ReturnType </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ClassType obj, RestArgumentTypes ... restArgs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (obj.*mFunction)(restArgs ...); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> invoker_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">clone</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">invoker_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> member_function_holder(mFunction)); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">member_function_signature_t</span></span> mFunction; };</code> </pre> <br>  Implementing a constructor that takes a pointer to a method is trivial: <br><pre> <code class="hljs php"> template &lt;typename FunctionType, typename ClassType&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FunctionType ClassType::* f)</span></span></span><span class="hljs-function"> : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mInvoker</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(new member_function_holder&lt;FunctionType, ArgumentTypes ...&gt;</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(f)</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{}</code> </pre> <br>  We have made another heir function_holder_base specifically for method pointers.  Here the variadic templates feature is used: a variable number of types (which is specified by the ellipsis) can be split into a fixed part, and the remainder of a variable length (in which the number of types is smaller by the size of the fixed part).  In the constructor, we pass in the template parameters a fixed part consisting of one type ‚Äî the function signature, and an arbitrary part ‚Äî everything else (these are the types of all arguments), and in implementing member_function_holder, we require that the fixed part consist of two elements ‚Äî the function signature, class, in which our method is located, and the arguments to call directly (here we just use the above guarantee that the number of all arguments is strictly greater than 0).  Thus, we save the pointer to the method in the constructor, and call it in the implementation of the invoke method. <br><br><blockquote>  Separately, I would like to say about the extremely inconvenient and unintuitive way of declaring the type of "pointer to a method" and about the method of calling such a method.  In this regard, in the <a href="http://www.parashift.com/c%2B%2B-faq/macro-for-ptr-to-memfn.html">C ++ FAQ</a> there is a warning about how to minimize the amount of headache when working with method pointers (I googled for half an hour how to write this expression correctly) </blockquote><br><br>  Here is an example of use: <br><pre> <code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">smth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + <span class="hljs-number"><span class="hljs-number">1</span></span>; } }; <span class="hljs-comment"><span class="hljs-comment">///... typedef function&lt;int (Foo, int)&gt; member_function_t; member_function_t f1 = &amp;Foo::smth; Foo foo; cout &lt;&lt; "calling member function with signature int (int): " &lt;&lt; f1(foo, 5) &lt;&lt; endl;</span></span></code> </pre><br><br><h4>  Conclusion </h4><br>  Thanks to the support of the variadic templates implementation, the function turned out to be quite concise, in the same boost because of the need to support old compilers (which do not have variadic templates), this functionality is implemented using boost.preprocessor (and has a limit on the number of arguments - 10 by default, you can change by defining the appropriate define: BOOST_FUNCTION_MAX_ARGS).  Roughly speaking, the implementation is done for functions with one argument, and then ‚Äúcloned‚Äù into a larger number of arguments using preprocessor magic. <br><br>  The complete example is <a href="https://github.com/prograholic/blog/tree/master/cxx_function">here.</a> </div><p>Source: <a href="https://habr.com/ru/post/159389/">https://habr.com/ru/post/159389/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../159371/index.html">The deputy director of the National Highway Traffic Safety Management took on Google</a></li>
<li><a href="../159373/index.html">Solitaire.exe offline</a></li>
<li><a href="../159377/index.html">Monkey programming language</a></li>
<li><a href="../159381/index.html">A young, dynamic company ...</a></li>
<li><a href="../159387/index.html">uLogin a year later. Social Authorization Facts</a></li>
<li><a href="../159391/index.html">Hyper-V Extensible Switch in Windows Server 2012</a></li>
<li><a href="../159393/index.html">Faxes in Freeswitch without fax</a></li>
<li><a href="../159395/index.html">Reader Pocketbook BASIC 613: first impressions</a></li>
<li><a href="../159401/index.html">Convenient interface Habra?</a></li>
<li><a href="../159403/index.html">The final version of Firefox for Android now supports devices with ARMv6 architecture</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>