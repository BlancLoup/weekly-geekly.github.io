<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Great power newtypes</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A newtype is a specialized data type declaration. Such that it contains only one constructor and a field. 



newtype Foo a = Bar a newtype Id = MkId ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Great power newtypes</h1><div class="post__text post__text-html js-mediator-article">  A <b>newtype</b> is a specialized data type declaration.  Such that it contains only one constructor and a field. <br><br><pre><code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre> <br><img src="https://habrastorage.org/webt/_5/zw/n9/_5zwn9jwjjngjatmg_y57dwddaq.png"><br><h3>  Common Beginner Questions </h3><br>  <i>What is the difference from <b>data</b> type data?</i> <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foo</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bar</span></span></span><span class="hljs-class"> a </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  The main specificity of a <b>newtype</b> is that it consists of the same parts as its only field.  More precisely, it differs from the original at the type level, but it has the same memory representation, and it is calculated strictly (not lazily). <br>  In short, the <b>newtype is</b> more efficient due to its presentation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      <i>Yes, it does not mean anything to me ... I will use <b>data</b></i> <br>  No, well, in the end, you can always include the <b>-funpack-strict-fields</b> :) extension for strict (not lazy) fields or specify directly <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> !</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  Yet the power of <b>newtype is</b> not limited to the efficiency of the calculations.  They are much stronger! <a name="habracut"></a><br><br><h2>  3 <b>newtype</b> roles </h2><br><img src="https://habrastorage.org/webt/6t/zt/kp/6tztkpdj2y4fosehxg3_ogz-ark.jpeg"><br><br><h3>  Hiding implementation </h3><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">module</span></span> Data.Id (<span class="hljs-type"><span class="hljs-type">Id</span></span>()) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  <b>A newtype is</b> different from the original, internally just <b>Word</b> . <br>  But we hide the <b>MkId</b> constructor outside the module. <br><br><h3>  Distribution implementation </h3><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Num</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Eq</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  Although this is not in the Haskell2010 standard, thanks to the expansion of the generalized newTypes output, you can automatically infer <b>newtype</b> behavior the same as the internal field behavior.  In our case, the behavior of <b>Eq Id</b> and <b>Num Id</b> is the same as the <b>Eq Word</b> and <b>Num Word</b> . <br><br>  Much more can be achieved through the expansion of the refined derivation ( <b>DerivingVia</b> ), but more on that later. <br><br><h3>  Implementation of choice </h3><br>  Despite your own constructor, in some cases you can use your own internal representation. <br><br><h4>  Task </h4><br>  There is a list of integers.  Find the maximum and total amount for just one pass through the list. <br>  And do not use the <b>foldl</b> and <b>folds packages</b> . <br><br><h4>  Typical answer </h4><br>  Of course, <b>fold</b> !  :) <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">foldr</span></span> :: <span class="hljs-type"><span class="hljs-type">Foldable</span></span> t =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; ta -&gt; b <span class="hljs-comment"><span class="hljs-comment">{- -- instance Foldable [] foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b -}</span></span></code> </pre><br>  And, the final function is described as: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">aggregate</span></span> :: [<span class="hljs-type"><span class="hljs-type">Integer</span></span>] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = foldr (\el (m, s) -&gt; (<span class="hljs-type"><span class="hljs-type">Just</span></span> el `max` m, el + s)) (<span class="hljs-type"><span class="hljs-type">Nothing</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">{- ghci&gt; aggregate [1, 2, 3, 4] (Just 4, 10) -}</span></span></code> </pre><br>  If you look closely, you can see similar operations on both sides: <b>Just el `max` m</b> and <b>el + s</b> .  In both cases - mapping and binary operation.  And the empty elements are <b>Nothing</b> and <b>0</b> . <br><br>  Yes, these are monoids! <br><br><div class="spoiler">  <b class="spoiler_title">Monoid and Semigroup more details</b> <div class="spoiler_text">  A semigroup is a property of an associative binary operation. <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ‚ãÑ (y ‚ãÑ z) == (x ‚ãÑ y) ‚ãÑ z</code> </pre><br>  A monoid is a property of an associative operation (that is, a semigroup) <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ‚ãÑ (y ‚ãÑ z) == (x ‚ãÑ y) ‚ãÑ z</code> </pre><br>  which has an empty element that does not change any element either to the right or to the left <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">x</span></span> ‚ãÑ empty == x == empty ‚ãÑ x</code> </pre><br></div></div><br>  Both <b>max</b> and <b>(+)</b> are associative, both have empty elements - <b>Nothing</b> and <b>0</b> . <br><br>  And the union of the mapping of monoids together with the convolution is the same <b>Foldable</b> ! <br><br><div class="spoiler">  <b class="spoiler_title">Foldable more details</b> <div class="spoiler_text">  Recall the definition of coagulation: <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Foldable</span></span></span><span class="hljs-class"> t </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">where</span></span></span></span> foldMap :: (<span class="hljs-type"><span class="hljs-type">Monoid</span></span> m) =&gt; (a -&gt; m) -&gt; ta -&gt; m ...</code> </pre><br></div></div><br>  Let's apply the rollover behavior to <b>max</b> and <b>(+)</b> .  We will be able to organize no more than one implementation of the <b>Word</b> monoid.  It's time to use the <b>newtype</b> option! <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span> <span class="hljs-comment"><span class="hljs-comment">-- already in Data.Semigroup &amp; Data.Monoid newtype Sum a = Sum {getSum :: a} deriving (Num, Eq, Ord) instance (Num a, Ord a) =&gt; Semigroup (Sum a) where (&lt;&gt;) = (+) instance (Num a, Ord a) =&gt; Monoid (Sum a) where mempty = Sum 0 newtype Max a = Max {getMax :: a} deriving (Num, Eq, Ord) instance (Num a, Ord a) =&gt; Semigroup (Max a) where (&lt;&gt;) = max</span></span></code> </pre><br>  It is necessary to make a remark. <br><br>  The fact is that in order to be a monoid for the <b>Max a</b> data type, we need a minimum element, that is, for an empty element to exist.  So, a monoid can only be a limited <b>Max a</b> . <br><br><div class="spoiler">  <b class="spoiler_title">Theoretically correct monoid of maximal element</b> <div class="spoiler_text"><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> a = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> a instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Ord</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">) instance </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Bounded</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br></div></div><br>  So somehow we have to convert our data type so that an empty element appears and we can use clotting. <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Prelude data Maybe a = Nothing | Just a instance Semigroup a =&gt; Semigroup (Maybe a) where Nothing &lt;&gt; b = b b &lt;&gt; Nothing = b (Just a) &lt;&gt; (Just b) = Just (a &lt;&gt; b) instance Semigroup a =&gt; Monoid (Maybe a) where mempty = Nothing -- ------ instance Functor Maybe where fmap _ Nothing = Nothing fmap f (Just b) = Just (fb)</span></span></code> </pre><br>  The conjugate element <b>Maybe</b> turns a semigroup into a monoid! <br><br><div class="spoiler">  <b class="spoiler_title">Liberalization of restrictions in fresh versions of GHC</b> <div class="spoiler_text">  Even in GHC 8.2, a monoid was required in the type constraint <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br>  which means we needed another newType: <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Data.Semigroup &amp; Data.Monoid newtype Option a = Option {getOption :: Maybe a} deriving (Eq, Ord, Semigroup) instance (Ord a, Semigroup a) =&gt; Monoid (Option a) where mempty = Option Nothing</span></span></code> </pre><br>  And it is much simpler already in GHC 8.4, where only a semigroup is needed to restrict the type, and even there is no need to create the type Option. <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class"> a =&gt; </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Maybe</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">a</span></span></span><span class="hljs-class">)</span></span></code> </pre><br></div></div><br><h4>  Cooldown response </h4><br>  Well, now let's update the code using the rollover and arrows. <br>  Recall that (.) Is just a functional composition: <br><br><pre> <code class="haskell hljs"> (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c f . g = \x -&gt; f (gx)</code> </pre> <br>  And remember that <b>fmap</b> is a functor: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">fmap</span></span> :: <span class="hljs-type"><span class="hljs-type">Functor</span></span> f =&gt; (a -&gt; b) -&gt; fa -&gt; fb</code> </pre> <br>  its implementation for <b>Maybe</b> is described just above. <br><br><div class="spoiler">  <b class="spoiler_title">Arrow more details</b> <div class="spoiler_text">  Arrows are the properties of some functions that allow you to work with them flowchart. <br>  For more details, see here: <a href="https://www.haskell.org/arrows/">Arrows: A General Interface to Computation</a> <br>  In our case, we use the function arrows. <br>  I.e <br><br><pre> <code class="haskell hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">instance</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Arrow</span></span></span><span class="hljs-class"> (-&gt;)</span></span></code> </pre> <br>  We will use the functions: <br><br><pre> <code class="haskell hljs">(***) :: <span class="hljs-type"><span class="hljs-type">Arrow</span></span> a =&gt; abc -&gt; ab' c' -&gt; a (b, b') (c, c') (&amp;&amp;&amp;) :: <span class="hljs-type"><span class="hljs-type">Arrow</span></span> a =&gt; abc -&gt; abc' -&gt; ab (c, c')</code> </pre> <br>  For our case <pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">abc</span></span> == (-&gt;) bc == b -&gt; c</code> </pre> <br>  And, accordingly, the signature of our functions is reduced to: <br><br><pre> <code class="haskell hljs">(***) :: (b -&gt; c) -&gt; (b' -&gt; c') -&gt; ((b, b') -&gt; (c, c')) (&amp;&amp;&amp;) :: (b -&gt; c) -&gt; (b -&gt; c') -&gt; (b -&gt; (c, c'))</code> </pre> <br>  Or in very simple words, the function <b>(***)</b> combines two functions with one argument (and one output type) into a function with the operation of a pair of arguments at the input and at the output, respectively, a pair of output types. <br><br>  The function <b>(&amp;&amp;&amp;)</b> is a truncated version <b>(***)</b> , where the type of the input arguments of the two functions is the same, and at the input we do not have a pair of arguments, but one argument. <br></div></div><br>  Total, unifying function acquired the form: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Semigroup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Arrow aggregate :: [Integer] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = (<span class="hljs-title"><span class="hljs-title">fmap</span></span> <span class="hljs-title"><span class="hljs-title">getMax</span></span> *** <span class="hljs-title"><span class="hljs-title">getSum</span></span>) . (<span class="hljs-title"><span class="hljs-title">foldMap</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> . <span class="hljs-type"><span class="hljs-type">Max</span></span> &amp;&amp;&amp; <span class="hljs-type"><span class="hljs-type">Sum</span></span>)) <span class="hljs-comment"><span class="hljs-comment">{- -- for GHC 8.2 aggregate = (fmap getMax . getOption *** getSum) . (foldMap (Option . Just . Max &amp;&amp;&amp; Sum)) -}</span></span></code> </pre><br>  It turned out very briefly! <br><br>  But, it is still tiring to wrap and wrap data from nested types! <br>  You can still cut, and we will help resourceless forced conversion! <br><br><h2>  Safe non-resource forced conversion and role roles </h2><br>  There is a function from the package <b>Unsafe.Coerce</b> - <b>unsafeCoerce</b> <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Unsafe.Coerce(<span class="hljs-title"><span class="hljs-title">unsafeCoerce</span></span>) unsafeCoerce :: a -&gt; b</code> </pre><br>  The function forcibly converts the type: from <b>a</b> to <b>b</b> . <br>  In essence, the function is magic, it tells the compiler to consider data of type <b>a as</b> type <b>b</b> , without taking into account the consequences of this step. <br><br>  It can be used to convert nested types, but you must act very carefully. <br><br>  In 2014, a revolution occurred with a <b>newtype</b> , namely, a secure resource-free forced conversion appeared! <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Coerce(<span class="hljs-title"><span class="hljs-title">coerce</span></span>) coerce :: Coercible ab =&gt; a -&gt; b</code> </pre><br>  This function has opened a new era in working with <b>newtype</b> . <br><br>  The <b>coercible</b> force converter works with types that have the same structure in memory.  It looks like a class-type, but in fact GHC converts types during compilation and it is impossible to independently determine instances. <br>  The <b>Data.Coerce.coerce</b> function allows nonresource type conversions, but for this we need access to the type constructors. <br><br>  Now simplify our function: <br><br><pre> <code class="haskell hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Semigroup <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Monoid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Control.Arrow <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Data.Coerce aggregate :: [Integer] -&gt; (<span class="hljs-type"><span class="hljs-type">Maybe</span></span> <span class="hljs-type"><span class="hljs-type">Integer</span></span>, <span class="hljs-type"><span class="hljs-type">Integer</span></span>) aggregate = coerce . (<span class="hljs-title"><span class="hljs-title">foldMap</span></span> (<span class="hljs-type"><span class="hljs-type">Just</span></span> . <span class="hljs-type"><span class="hljs-type">Max</span></span> &amp;&amp;&amp; <span class="hljs-type"><span class="hljs-type">Sum</span></span>)) <span class="hljs-comment"><span class="hljs-comment">-- coerce :: (Maybe (Max Integer), Sum Integer) -&gt; (Maybe Integer, Integer)</span></span></code> </pre><br>  We avoided the routine of pulling out nested types; we did it without wasting resources with just one function. <br><br><h3>  Roles of nested data types </h3><br>  With the <b>coerce</b> function <b>,</b> we can forcefully convert any nested types. <br>  But should this feature be so widely used? <br><br><pre> <code class="haskell hljs"><span class="hljs-comment"><span class="hljs-comment">-- already in Data.Ord -- Down a - reversed order newtype Down a = Down a deriving (Eq, Show) instance Ord a =&gt; Ord (Down a) where compare (Down x) (Down y) = y `compare` x import Data.List(sort) -- Sorted data Sorted a = Sorted [a] deriving (Show, Eq, Ord) fromList2Sorted :: Ord a =&gt; [a] -&gt; Sorted a fromList2Sorted = Sorted . sort -- minimum: O(1) ! minView :: Sorted a -&gt; Maybe a minView (Sorted []) = Nothing minView (Sorted (a : _)) = Just a</span></span></code> </pre><br>  Semantically, it is absurd to convert to <b>Sorted a</b> from <b>Sorted (Down a)</b> . <br>  However, you can try: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> h = fromList2Sorted [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span> ghci&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> hDown = fromList2Sorted $ fmap <span class="hljs-type"><span class="hljs-type">Down</span></span> [<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>,<span class="hljs-number"><span class="hljs-number">3</span></span>] :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>) ghci&gt; minView h <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) ghci&gt; minView (coerce h :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>)) <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>) ghci&gt; minView hDown <span class="hljs-type"><span class="hljs-type">Just</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>)</code> </pre><br>  All anything, but the correct answer is <b>Just (Down 3)</b> . <br>  It was in order to cut off the wrong behavior that type roles were introduced. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE RoleAnnotations #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> role </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Sorted</span></span></span><span class="hljs-class"> nominal</span></span></code> </pre><br>  Let's try now: <br><br><pre> <code class="haskell hljs"><span class="hljs-title"><span class="hljs-title">ghci</span></span>&gt; minView (coerce h :: <span class="hljs-type"><span class="hljs-type">Sorted</span></span> (<span class="hljs-type"><span class="hljs-type">Down</span></span> <span class="hljs-type"><span class="hljs-type">Int</span></span>)) error: <span class="hljs-type"><span class="hljs-type">Couldn't</span></span> match <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int'</span></span></span><span class="hljs-class"> with '</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Down</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Int'</span></span></span><span class="hljs-class"> arising from a use of 'coerce'</span></span></code> </pre><br>  Much better! <br><br>  In total there are 3 roles ( <b>type role</b> ): <br><br><ul><li>  <b>representational</b> - equivalent if the representation is the same. </li><li>  <b>nominal</b> - must be exactly the same type </li><li>  <b>phantom</b> - does not depend on real content.  Equivalent to anything </li></ul><br>  In most cases, the compiler is smart enough to reveal the role of the type, but it can be helped. <br><br><h2>  Specified Injection DerivingVia Behavior </h2><br>  Thanks to the expansion of the language <b>DerivingVia</b> , the <b>newtype</b> distribution role has improved. <br><br>  Starting with GHC 8.6, which was recently released, this new extension has appeared. <br><br><pre> <code class="haskell hljs"><span class="hljs-meta"><span class="hljs-meta">{-# LANGUAGE DerivingVia #-}</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">newtype</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Id</span></span></span><span class="hljs-class"> = </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">MkId</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">deriving</span></span></span><span class="hljs-class"> (</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Semigroup</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Monoid</span></span></span><span class="hljs-class">) via </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Max</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Word</span></span></span></span></code> </pre><br>  As you can see, the type behavior is automatically derived due to the clarification of how to output. <br>  <b>DerivingVia</b> can be applied to any type that supports <b>Coercible</b> and what's important - completely without the consumption of resources! <br><br>  Even more, <b>DerivingVia</b> can be applied not only to <b>newtype</b> , but also to any isomorphic types, if they support generics <b>Generics</b> and forced conversion <b>Coercible</b> . <br><br><h2>  findings </h2><br>  Types <b>newtype</b> is a powerful force that greatly simplifies and improves the code, eliminates the routine and reduces resource consumption. <br><br>  <i>Original translation</i> : <a href="https://speakerdeck.com/konn/the-great-power-of-newtypes">The Great Power of newtypes</a> <i>(Hiromi Ishii)</i> <br><br>  <i><b>PS</b> I think, after this article, published more than a year ago [not mine] article <a href="https://habr.com/post/323526/">The newtype Magic in Haskell</a> about newTypes will become a little clearer!</i> </div><p>Source: <a href="https://habr.com/ru/post/425405/">https://habr.com/ru/post/425405/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../425393/index.html">QIWI server party 3.0: report + full videos of all reports</a></li>
<li><a href="../425395/index.html">10 physical facts that you should have learned in school, but may not have learned</a></li>
<li><a href="../425397/index.html">10 libraries every Android developer should know about</a></li>
<li><a href="../425401/index.html">Rome Club Report 2018, Chapter 1.11: ‚ÄúDisruptive Technologies and the Digital Revolution‚Äù</a></li>
<li><a href="../425403/index.html">Craigslist creator finances: site against fake news, discrimination and inflection of Internet giants</a></li>
<li><a href="../425407/index.html">Firecore - a fun AVR game</a></li>
<li><a href="../425409/index.html">DevBoy: make a signal generator</a></li>
<li><a href="../425411/index.html">Scrum is dead</a></li>
<li><a href="../425413/index.html">Are the junas good?</a></li>
<li><a href="../425415/index.html">Perl 5: as in macros, errors were hidden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>