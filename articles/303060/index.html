<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Virtual GPIO driver with QEMU-based ivshmem interrupt controller for Linux</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="It's hard to underestimate the role of GPIO , especially in the world of embedded ARM systems. In addition to being an extremely popular material for ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Virtual GPIO driver with QEMU-based ivshmem interrupt controller for Linux</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/files/778/60c/29e/77860c29e6024e7e818a102b55319904.jpg" alt="Nature of interruptions"><br><br>  It's hard to underestimate the role of <strong>GPIO</strong> , especially in the world of embedded ARM systems.  In addition to being an extremely popular material for all beginner manuals, <strong>GPIO</strong> provides a way to manage many peripherals, act as a source of valuable interruptions, or may even be the only available way to communicate with the world for SOC. <br><br>  Based on my own humble experience, I can say that interruption is not the most consecrated topic in the Linux community.  Because of its features, as well as a strong binding to the hardware, all training materials on interrupts are devoid of a real and easily reproducible example.  This fact prevents understanding that very often interrupts and GPIO are inseparable, especially in the field of embedded Linux.  Many people start to believe that GPIO is a very simple and boring thing (which, by the way, has become such thanks to the sysfs subsystem). <br><a name="habracut"></a>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Even in the example given in LDD3 (snull driver), interrupts are emitted by explicitly calling the pair device function.  There are also examples in USFCA courses ( <a href="http://cs.usfca.edu/~cruse/cs686s08/">http://cs.usfca.edu/~cruse/cs686s08/</a> ), but they use someone else's interrupt, are closely related to x86 architecture and are very outdated. <br><br>  The proposed solution can solve these problems.  From the point of view of user space and, in many respects, in the internal implementation, the driver is indistinguishable from most of the ‚Äúreal‚Äù ones that provide interrupts for general purpose I / O ports.  At the moment, the driver supports interrupts on the leading or trailing edge and can be used as a source of interruptions for other devices. <br><br><h2>  ivshmem - Inter-VM shared memory </h2><br><br>  Designed for sharing shared memory (allocated on the host platform through the POSIX shared memory API mechanism) by multiple QEMU processes with different guest platforms.  In order for all guest platforms to have access to the shared memory area, ivshmem models a PCI device by providing memory access as a PCI BAR. <br><br><img src="https://habrastorage.org/files/cbe/643/193/cbe643193d4a4b2d8524b2087bedf0ef.png"><br><br>  From the point of view of the virtual machine, the ivshmem PCI device contains three basic address registers (BAR). <br><ul><li>  BAR0 is a MMIO domain that supports registers and interrupts in case MSI is not used, one kilobyte in size. </li><li>  BAR1 is used for MSI-X if MSI support is enabled. </li><li>  BAR2 to access the shared memory object. </li></ul><br><br>  This mechanism was introduced by Cam Macdonnel in the original report <a href="http://www.linux-kvm.org/images/e/e8/0.11.Nahanni-CamMacdonell.pdf">‚ÄúNahanni - a shared memory interface for KVM‚Äù</a> (later became known as ivshmem), in which he put forward the following theses: <br><ul><li>  zero-copy data access </li><li>  interrupt mechanism </li><li>  guest / guest and host / guest interaction </li></ul><br><br>  and analyzed the overall performance. <br><br>  At the moment, officially, nobody escorts ivshmem, however, Red Hat employees are making a big contribution to the development of ivshmem. <br><br><h2>  purpose </h2><br><br>  ivshmem can serve as the basis for simulating and debugging many classes of devices. <br>  In this article, we look at the general-purpose input / output (GPIO) virtual pci, which is also a source of interrupts, and the corresponding driver with access and control through the sysfs mechanism. <br><br>  Prerequisites: <br><ul><li>  Qemu 2.5.1.1 source code (not recommended for a lower version) </li><li>  Linux-kernel 4.1 source code </li></ul><br><br>  For development and testing, the virtual board qemu versatilepb (system ARM) was used. <br><br>  Optional: <br><ul><li>  arm-cross-toolchain </li><li>  <a href="http://nairobi-embedded.org/linux_pci_device_driver.html">nairobi-embedded</a> - Guest-side ivshmem PCI device test sources </li></ul><br><br>  Legend: <br><br>  <strong>g &gt;&gt; - commands or output executed on the guest system.</strong> <br>  <strong>h &gt;&gt; on the main one.</strong> <br><br><h2>  Sample and original code </h2><br><br>  To begin with, we will demonstrate the original code based on the original code ( <a href="https://github.com/henning-schild/ivshmem-guest-code">https://github.com/henning-schild/ivshmem-guest-code</a> ), and modified, subsequently, Siro Mugabi. <br><pre><code class="bash hljs">h&gt;&gt; qemu: += -device ivshmem,shm=ivshmem,size=1 g&gt;&gt; <span class="hljs-comment"><span class="hljs-comment"># insmod ne_ivshmem_ldd_basic.ko ivshmem 0000:00:0d.0: data_mmio iomap base = 0xc8c00000 ivshmem 0000:00:0d.0: data_mmio_start = 0x60000000 data_mmio_len = 1048576 ivshmem 0000:00:0d.0: regs iomap base = 0xc88ee400, irq = 27 ivshmem 0000:00:0d.0: regs_addr_start = 0x50002400 regs_len = 256 g&gt;&gt; # ./ne_ivshmem_shm_guest_usr -w "TEST STRING" h&gt;&gt; $ xxd -l 16 /dev/shm/ivshmem 0000000: 5445535420535452 494e 4700 0000 0000 TEST STRING.....</span></span></code> </pre> <br><br>  In principle, this is quite enough to emulate GPIO already in this form.  And in many cases they did this when a simple input or output state is enough, using sysfs and interrupts implies a small add-on to I / O mem. <br><br><h1>  Implementation </h1><br><br>  Note that <strong>/ dev / ivshmem0</strong> and <strong>ne_ivshmem_shm_guest_usr.c</strong> are no longer needed, all work from the guest machine from the user space (user-space) will be handled using the <strong>sysfs</strong> interface. <br><br>  Before marking our device in memory, I would like to note that we simply duplicate the scheme used in most gpio drivers. <br><br>  Firstly, all gpio inputs / outputs are divided into ports, usually 8, 16, 32 inputs.  Each port has at least an input status register ( <strong>GPIO_DATA</strong> ), a direction register if in / out switching is supported ( <strong>GPIO_OUTPUT</strong> ).  Further (if there is support in the device itself), the interrupt status register, the interrupt registers on the rising edge (rising) and the falling edge and on the level (high and low).  The hardware interrupt supplied by the main interrupt controller is usually one for the entire port and is shared between all the inputs of the port. <br><br><h2>  Examples of existing implementations with comments </h2><br><br><h3>  Sitara am335x </h3><br><br>  <em>better known in the beaglebone board</em> <br><br>  <strong>Developer:</strong> Texas Instruments <br>  <strong>Documentation:</strong> <a href="http://www.ti.com/lit/ug/spruh73m/spruh73m.pdf">AM335x Sitara Processors Technical Reference Manual</a> (page 4865) <br>  <strong>Its corresponding gpio driver is:</strong> <a href="">linux / drivers / gpio / gpio-omap.c</a> <br>  <strong>Corresponding title:</strong> <a href="">linux / include / linux / platform_data / gpio-omap.h</a> <br>  <strong>Number of inputs / outputs:</strong> 128 (4 gpio ports - 32 contacts each) <br><br><div class="spoiler">  <b class="spoiler_title">am335x Sitara gpio register table - port A</b> <div class="spoiler_text"><table><thead><tr><th>  Register Name </th><th>  Bias </th><th>  Driver Name </th><th>  Comment </th></tr></thead><tbody><tr><td>  GPIO_IRQSTATUS_0 </td><td>  0x02 </td><td>  OMAP4_GPIO_IRQSTATUS_0 </td><td>  Interrupt status for specified input </td></tr><tr><td>  GPIO_IRQSTATUS_1 </td><td>  0x030 </td><td>  OMAP4_GPIO_IRQSTATUS_1 </td><td>  Interrupt status for specified input </td></tr><tr><td>  GPIO_IRQSTATUS_SET_0 </td><td>  0x034 </td><td>  OMAP4_GPIO_IRQSTATUS_SET_0 </td><td>  Enable interrupts on a given input. </td></tr><tr><td>  GPIO_IRQSTATUS_SET_1 </td><td>  0x038 </td><td>  OMAP4_GPIO_IRQSTATUS_SET_1 </td><td>  Enable interrupts on a given input. </td></tr><tr><td>  GPIO_IRQSTATUS_CLR_0 </td><td>  0x03 </td><td>  OMAP4_GPIO_IRQSTATUS_CLR_0 </td><td>  Turns off interrupts on a given input. </td></tr><tr><td>  GPIO_IRQSTATUS_CLR_1 </td><td>  0x040 </td><td>  OMAP4_GPIO_IRQSTATUS_CLR_1 </td><td>  Turns off interrupts on a given input. </td></tr><tr><td>  GPIO_OE </td><td>  0x134 </td><td>  OMAP4_GPIO_OE </td><td>  Monitors the input / output status (in / out) </td></tr><tr><td>  GPIO_DATAIN </td><td>  0x138 </td><td>  OMAP4_GPIO_DATAIN </td><td>  I / O status </td></tr><tr><td>  GPIO_DATAOUT </td><td>  0x13C </td><td>  OMAP4_GPIO_DATAOUT </td><td>  Setting the status for the outputs (low / high) </td></tr><tr><td>  GPIO_LEVELDETECT0 </td><td>  0x140 </td><td>  OMAP4_GPIO_LEVELDETECT0 </td><td>  Enable / disable interrupts for low signal input </td></tr><tr><td>  GPIO_LEVELDETECT1 </td><td>  0x144 </td><td>  OMAP4_GPIO_LEVELDETECT1 </td><td>  Enable / disable interrupts for high signal input </td></tr><tr><td>  GPIO_RISINGDETECT </td><td>  0x148 </td><td>  OMAP4_GPIO_RISINGDETECT </td><td>  Enable / Disable Interrupts for Front-End Entry </td></tr><tr><td>  GPIO_FALLINGDETECT </td><td>  0x14 </td><td>  OMAP4_GPIO_FALLINGDETECT </td><td>  Enable / disable interrupts for trailing edge input </td></tr><tr><td>  GPIO_CLEARDATAOUT </td><td>  0x190 </td><td>  OMAP4_GPIO_CLEARDATAOUT </td><td>  Toggles the corresponding input to low </td></tr><tr><td>  GPIO_SETDATAOUT </td><td>  0x194 </td><td>  OMAP4_GPIO_SETDATAOUT </td><td>  Switches the corresponding input to the high state. </td></tr></tbody></table></div></div><br><br>  <em>Note: GPIO_IRQSTATUS_N is also used for IRQ ACK.</em>  <em>Managing bounce, as well as nutrition is beyond the scope of this article.</em> <br><br>  The presence of the GPIO_CLEARDATAOUT and GPIO_SETDATAOUT registers in addition to the GPIO_DATAOUT register, as well as GPIO_IRQSTATUS_SET_N and GPIO_IRQSTATUS_CLR_N in addition to GPIO_IRQSTATUS_N, is explained by two ways of recording the output status: <br><ul><li>  Standard: Read register entry completely at main address </li><li>  Task and cleaning (recommended by the manufacturer): Two corresponding registers are used to set and clear the corresponding contact as an output, the same applies to interrupt control. <br><br></li></ul><br><h3>  ep9301 </h3><br><br>  <strong>Developer:</strong> Cirrus Logic <br>  <strong>Documentation:</strong> <a href="https://www.embeddedarm.com/documentation/third-party/ts-7000_ep9301-ug.pdf">EP9301 User's Guide</a> (page 523) <br>  <strong>Its corresponding gpio driver is:</strong> <a href="">linux / drivers / gpio / gpio-ep93xx.c</a> <br>  <strong>Corresponding header:</strong> <a href="">linux / arch / arm / mach-ep93xx / include / mach / gpio-ep93xx.h</a> <br>  <strong>Number of inputs / outputs:</strong> 56 (7 gpio ports - 8 contacts each) <br><br><div class="spoiler">  <b class="spoiler_title">ep9301 gpio register table - port A</b> <div class="spoiler_text"><table><thead><tr><th>  Register Name </th><th>  Bias </th><th>  Driver Name </th><th>  Description </th></tr></thead><tbody><tr><td>  PADR </td><td>  0x00 </td><td>  EP93XX_GPIO_REG (0x0) </td><td>  The I / O status register is readable. </td></tr><tr><td>  Paddr </td><td>  0x10 </td><td>  EP93XX_GPIO_REG (0x10) </td><td>  Monitors the input / output status (in / out) </td></tr><tr><td>  GPIOAIntEn </td><td>  0x9C </td><td>  int_en_register_offset [0] </td><td>  Enable interrupts on a given input. </td></tr><tr><td>  GPIOAIntType1 </td><td>  0x90 </td><td>  int_type1_register_offset [0] </td><td>  Sets the level / edge interrupt type </td></tr><tr><td>  GPIOAIntType2 </td><td>  0x94 </td><td>  int_type2_register_offset [0] </td><td>  Sets high / rising or low / falling depending on the type of interrupt selected </td></tr><tr><td>  GPIOAEOI </td><td>  0x98 </td><td>  eoi_register_offset [0] </td><td>  Register for notification of a processed interrupt </td></tr><tr><td>  IntStsA </td><td>  0xA0 </td><td>  EP93XX_GPIO_A_INT_STATUS </td><td>  Register interrupt status </td></tr></tbody></table></div></div><br><br>  <em>Note:</em> <br>  <em>Of these, 7 ports are available for 8, 8, 1, 2, 3, 2, 4 inputs / outputs, with only the first, second and fifth ports having interrupt registers.</em> <br>  <em>The table only considers port A.</em> <br>  <em>One of the features of ep9301, is that the type of interrupts both at the hardware level is not supported; the driver switches to the moment the interrupt is triggered.</em>  <em>Another interesting feature is that on port F each contact has its own interruption.</em> <br><br><h3>  Bt848 </h3><br><br>  <em>Last example: pci board Bt848, with gpio.</em> <br><br>  <strong>Developer:</strong> Intel <br>  <strong>Documentation:</strong> <a href="http://www.ai.mit.edu/projects/VariableViewpointReality/DataSheets/l848a_a.pdf">Bt848 / 848A / 849A</a> (page 68) <br>  <strong>The corresponding gpio driver is:</strong> <a href="">linux / drivers / gpio / gpio-bt8xx.c</a> <br>  <strong>Corresponding header:</strong> <a href="">linux / drivers / media / pci / bt8xx / bt848.h</a> <br>  <strong>Number of inputs / outputs:</strong> 24 <br><br>  <em>Bt848 is a video capture card.</em> <br><br><div class="spoiler">  <b class="spoiler_title">Bt848 gpio register table</b> <div class="spoiler_text"><table><thead><tr><th>  Register Name </th><th>  Bias </th><th>  Driver Name </th><th>  Description </th></tr></thead><tbody><tr><td>  BT848_GPIO_OUT_EN </td><td>  0x118 </td><td>  BT848_GPIO_OUT_EN </td><td>  The status of the inputs / outputs is readable and writeable. </td></tr><tr><td>  BT848_GPIO_DATA </td><td>  0x200 </td><td>  BT848_GPIO_DATA </td><td>  Monitors the input / output status (in / out) </td></tr></tbody></table></div></div><br><br>  <em>There is no support for interrupts.</em>  <em>Only two registers - the state and setting in / out.</em> <br><br><h2>  We mark our device in memory </h2><br><br>  To begin, select a place for data and state management. <br><br>  Let the device have 8 general purpose inputs / outputs, then: <br><table><thead><tr><th>  Register Name </th><th>  Bias </th><th>  Driver Name </th><th>  Description </th></tr></thead><tbody><tr><td>  DATA </td><td>  0x00 </td><td>  VIRTUAL_GPIO_DATA </td><td>  The status of the inputs / outputs is readable and writeable. </td></tr><tr><td>  OUTPUTEN </td><td>  0x01 </td><td>  VIRTUAL_GPIO_OUT_EN </td><td>  Monitors the input / output status (in / out) </td></tr></tbody></table><br><br><h2>  Gpio interface quick reference </h2><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> gpio_chip { <span class="hljs-comment"><span class="hljs-comment">/*   gpio */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *label; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*direction_input)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> gpio_chip *chip, unsigned offset); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> gpio_chip *chip, unsigned offset); <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> (*direction_output)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> gpio_chip *chip, unsigned offset, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> (*<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>)(<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> gpio_chip *chip, unsigned offset, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*      ,       -1 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> u16 ngpio; };</code> </pre> <br><br>  Documentation: <br>  <a href="https://www.kernel.org/doc/Documentation/gpio/sysfs.txt">https://www.kernel.org/doc/Documentation/gpio/sysfs.txt</a> <br><br>  Link to source code: <br>  <a href="">linux-kernel 4.1</a> <br><br><h4>  Output state when switching </h4><br><br>  It is necessary to note the <strong>int value</strong> parameter in the <strong>direction_output</strong> function, which serves the file / sys / class / gpio / gpioN / direction, which takes a value not only ‚Äúin‚Äù / ‚Äùout‚Äù, but also ‚Äúhigh‚Äù / ‚Äúlow‚Äù, the values ‚Äã‚Äãof which are transmitted as the <strong>value</strong> parameter ( <em>this simple fact, for some reason, is rarely mentioned in the beginner's guides</em> ). <br><pre> <code class="bash hljs">g&gt;&gt; /sys/class/gpio <span class="hljs-comment"><span class="hljs-comment"># echo low &gt; gpio0/direction g&gt;&gt; /sys/class/gpio # cat gpio0/value 0 g&gt;&gt; /sys/class/gpio # echo high &gt; gpio0/direction g&gt;&gt; /sys/class/gpio # cat gpio0/value 1</span></span></code> </pre> <br><br><h4>  Dynamic assignment int base and legacy ARCH_NR_GPIOS </h4><br><br>  Historically, the number of GPIOs in the kernel was limited to the <strong>ARCH_NR_GPIOS</strong> parameter, <strong>defaulting</strong> to 256 and subsequently increased to 512 ( <a href="https://github.com/torvalds/linux/commit/7ca267faba8ad097f57cb71c32ae1865de83241a">version 3.18</a> ). <br><br>  Its meaning is quite simple, in the kernel there can be no more GPIO than the parameter value, if the planned quantity was greater than the default value, it was redefined in the corresponding platform header file. <br><br>  The reason for this behavior was the definition of the GPIO description table as static and the maximum offset for each port was limited: <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio_desc</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio_desc</span></span></span><span class="hljs-class">[</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ARCH_NR_GPIOS</span></span></span><span class="hljs-class">];</span></span></code> </pre> <br><br>  GPIO ports and their offsets were rigidly defined in files describing the hardware of a particular SOC, for example: <br><div class="spoiler">  <b class="spoiler_title">EP93XX_GPIO_BANK</b> <div class="spoiler_text">  <a href="">/source/arch/arm/mach-ep93xx/gpio.c</a> <br><pre> <code class="hljs swift">#define <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(name, dr, ddr, base_gpio) \ { \ .chip = { \ .label = name, \ .direction_input = ep93xx_gpio_direction_input, \ .direction_output = ep93xx_gpio_direction_output,\ .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> = ep93xx_gpio_get, \ .<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> = ep93xx_gpio_set, \ .dbg_show = ep93xx_gpio_dbg_show, \ .base = base_gpio, \ .ngpio = <span class="hljs-number"><span class="hljs-number">8</span></span>, \ }, \ .data_reg = <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_REG</span></span>(dr), \ .data_dir_reg = <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_REG</span></span>(ddr), \ } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ep93xx_gpio_chip</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ep93xx_gpio_banks</span></span></span><span class="hljs-class">[] = </span></span>{ <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(<span class="hljs-string"><span class="hljs-string">"A"</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x10</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(<span class="hljs-string"><span class="hljs-string">"B"</span></span>, <span class="hljs-number"><span class="hljs-number">0x04</span></span>, <span class="hljs-number"><span class="hljs-number">0x14</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>), <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(<span class="hljs-string"><span class="hljs-string">"C"</span></span>, <span class="hljs-number"><span class="hljs-number">0x08</span></span>, <span class="hljs-number"><span class="hljs-number">0x18</span></span>, <span class="hljs-number"><span class="hljs-number">40</span></span>), <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(<span class="hljs-string"><span class="hljs-string">"D"</span></span>, <span class="hljs-number"><span class="hljs-number">0x0c</span></span>, <span class="hljs-number"><span class="hljs-number">0x1c</span></span>, <span class="hljs-number"><span class="hljs-number">24</span></span>), <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(<span class="hljs-string"><span class="hljs-string">"E"</span></span>, <span class="hljs-number"><span class="hljs-number">0x20</span></span>, <span class="hljs-number"><span class="hljs-number">0x24</span></span>, <span class="hljs-number"><span class="hljs-number">32</span></span>), <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(<span class="hljs-string"><span class="hljs-string">"F"</span></span>, <span class="hljs-number"><span class="hljs-number">0x30</span></span>, <span class="hljs-number"><span class="hljs-number">0x34</span></span>, <span class="hljs-number"><span class="hljs-number">16</span></span>), <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(<span class="hljs-string"><span class="hljs-string">"G"</span></span>, <span class="hljs-number"><span class="hljs-number">0x38</span></span>, <span class="hljs-number"><span class="hljs-number">0x3c</span></span>, <span class="hljs-number"><span class="hljs-number">48</span></span>), <span class="hljs-type"><span class="hljs-type">EP93XX_GPIO_BANK</span></span>(<span class="hljs-string"><span class="hljs-string">"H"</span></span>, <span class="hljs-number"><span class="hljs-number">0x40</span></span>, <span class="hljs-number"><span class="hljs-number">0x44</span></span>, <span class="hljs-number"><span class="hljs-number">56</span></span>), };</code> </pre> </div></div><br><br>  Starting from <a href="https://github.com/torvalds/linux/commit/14e85c0e69d5c7fdbd963edbbec1dc5cdd385200">version 3.19, the</a> static array was replaced with a dynamic array for each GPIO port allocated in the <strong>gpiochip_add () function</strong> . <br><br>  However, <strong>ARCH_NR_GPIOS</strong> is still here (at the time of version 4.7) and is used to search for an offset when dynamically assigning a base. <br><pre> <code class="hljs cs"><span class="hljs-comment"><span class="hljs-comment">/* dynamic allocation of GPIOs, eg on a hotplugged device */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gpiochip_find_base</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> ngpio</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><br>  The <strong>base</strong> parameter of the <strong>gpio_chip</strong> structure can be defined as -1, then the offset will be defined as the first free range starting from the end, that is, if the port has the number of contacts equal to 8, the offset will be 248 with the <strong>ARCH_NR_GPIOS</strong> parameter equal to 256 ( <strong>ARCH_NR_GPIOS</strong> - ngpio) if the port is logged in first. <br><br><h2>  Define the following features of our driver </h2><br><br>  Set the appropriate contact as input: <br><div class="spoiler">  <b class="spoiler_title">static int virtual_gpio_direction_input (struct gpio_chip * gpio, unsigned nr)</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">static</span></span> int virtual_gpio_direction_input(struct gpio_chip *gpio, unsigned nr) { struct virtual_gpio *vg = to_virtual_gpio(gpio); unsigned long flags; u8 outen, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; spin_lock_irqsave(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vg</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = vgread(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_DATA</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> &amp;= ~(1 &lt;&lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr</span></span></span><span class="hljs-class">); vgwrite(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_DATA</span></span></span><span class="hljs-class">); outen = vgread(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_OUT_EN</span></span></span><span class="hljs-class">); outen &amp;= ~(1 &lt;&lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr</span></span></span><span class="hljs-class">); vgwrite(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">outen</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_OUT_EN</span></span></span><span class="hljs-class">); spin_unlock_irqrestore(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vg</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">); return 0; }</span></span></code> </pre> </div></div><br><br>  Reading current contact status: <br><div class="spoiler">  <b class="spoiler_title">static int virtual_gpio_get (struct gpio_chip * gpio, unsigned nr)</b> <div class="spoiler_text"><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virtual_gpio_get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> gpio_chip *gpio, unsigned nr</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> virtual_gpio *vg = to_virtual_gpio(gpio); unsigned <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flags; u8 data; spin_lock_irqsave(&amp;vg-&gt;<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>, flags); data= vgread(VIRTUAL_GPIO_DATA); spin_unlock_irqrestore(&amp;vg-&gt;<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>, flags); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !!(data &amp; (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr)); }</code> </pre> </div></div><br><br>  Set corresponding contact as output: <br><div class="spoiler">  <b class="spoiler_title">static int virtual_gpio_direction_output (struct gpio_chip * gpio, unsigned nr, int val)</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">static</span></span> int virtual_gpio_direction_output(struct gpio_chip *gpio, unsigned nr, int val) { struct virtual_gpio *vg = to_virtual_gpio(gpio); unsigned long flags; u8 outen, <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; spin_lock_irqsave(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vg</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">); outen = vgread(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_OUT_EN</span></span></span><span class="hljs-class">); outen |= (1 &lt;&lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr</span></span></span><span class="hljs-class">); vgwrite(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">outen</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_OUT_EN</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = vgread(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_DATA</span></span></span><span class="hljs-class">); if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> |= (1 &lt;&lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr</span></span></span><span class="hljs-class">); else </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> &amp;= ~(1 &lt;&lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr</span></span></span><span class="hljs-class">); vgwrite(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_DATA</span></span></span><span class="hljs-class">); spin_unlock_irqrestore(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vg</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">); return 0; }</span></span></code> </pre> </div></div><br><br>  Set exit status: <br><div class="spoiler">  <b class="spoiler_title">static void virtual_gpio_set (struct gpio_chip * gpio, unsigned nr, int val)</b> <div class="spoiler_text"><pre> <code class="hljs haskell"><span class="hljs-title"><span class="hljs-title">static</span></span> void virtual_gpio_set(struct gpio_chip *gpio, unsigned nr, int val) { struct virtual_gpio *vg = to_virtual_gpio(gpio); unsigned long flags; u8 <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class">; spin_lock_irqsave(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vg</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">); </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> = vgread(</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_DATA</span></span></span><span class="hljs-class">); if (</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> |= (1 &lt;&lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr</span></span></span><span class="hljs-class">); else </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">data</span></span></span><span class="hljs-class"> &amp;= ~(1 &lt;&lt; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">nr</span></span></span><span class="hljs-class">); vgwrite(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">data</span></span></span><span class="hljs-class">, </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">VIRTUAL_GPIO_DATA</span></span></span><span class="hljs-class">); spin_unlock_irqrestore(&amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vg</span></span></span><span class="hljs-class">-&gt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">lock</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">flags</span></span></span><span class="hljs-class">); }</span></span></code> </pre> </div></div><br><br>  The function of registering our driver as a gpio_chip device: <br><div class="spoiler">  <b class="spoiler_title">static void virtual_gpio_setup (struct virtual_gpio * gpio)</b> <div class="spoiler_text"><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void virtual_gpio_setup(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual_gpio</span></span></span></span> *gpio) { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio_chip</span></span></span></span> *chip = &amp;gpio-&gt;chip; chip-&gt;label = dev_name(&amp;gpio-&gt;pdev-&gt;dev); chip-&gt;owner = THIS_MODULE; chip-&gt;direction_input = virtual_gpio_direction_input; chip-&gt;get = virtual_gpio_get; chip-&gt;direction_output = virtual_gpio_direction_output; chip-&gt;set = virtual_gpio_set; chip-&gt;dbg_show = NULL; chip-&gt;base = modparam_gpiobase; chip-&gt;ngpio = VIRTUAL_GPIO_NR_GPIOS; chip-&gt;can_sleep = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">// gpio never sleeps! }</span></span></code> </pre> </div></div><br><br>  <em>vgread and vgwrite are just wrappers for the iowrite8 and ioread8 functions:</em> <br><pre> <code class="hljs lisp">#define vgwrite(<span class="hljs-name"><span class="hljs-name">dat</span></span>, adr) iowrite8((<span class="hljs-name"><span class="hljs-name">dat</span></span>), vg-&gt;data_base_addr+(<span class="hljs-name"><span class="hljs-name">adr</span></span>)) #define vgread(<span class="hljs-name"><span class="hljs-name">adr</span></span>) ioread8(<span class="hljs-name"><span class="hljs-name">vg-&gt;data_base_addr+</span></span>(<span class="hljs-name"><span class="hljs-name">adr</span></span>))</code> </pre> <br><br><h2>  Passing the gpiobase value as a parameter when dynamically loading a module </h2><br><br>  <em>Note: <a href="https://github.com/torvalds/linux/commit/af6c235d1a5c112964c3029eb0ed4b52c7aa33bf">Starting from version 4.2, this is the recommended way to register a GPIO port.</a></em> <br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> modparam_gpiobase = <span class="hljs-number"><span class="hljs-number">-1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* dynamic */</span></span> module_param_named(gpiobase, modparam_gpiobase, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-number"><span class="hljs-number">0444</span></span>); MODULE_PARM_DESC(gpiobase, <span class="hljs-string"><span class="hljs-string">"The GPIO base number. -1 means dynamic, which is the default."</span></span>);</code> </pre> <br><br><h2>  Loading and testing module </h2><br><pre> <code class="bash hljs">h&gt;&gt; $ rm /dev/shm/ivshmem h&gt;&gt; Adding parameters to qemu launch <span class="hljs-built_in"><span class="hljs-built_in">command</span></span> line += -device ivshmem,shm=ivshmem,size=1 g&gt;&gt; <span class="hljs-comment"><span class="hljs-comment"># ls /sys/class/gpio/ export unexport g&gt;&gt; # insmod virtual_gpio_basic.ko PCI: enabling device 0000:00:0d.0 (0100 -&gt; 0102) ivshmem_gpio 0000:00:0d.0: data_mmio iomap base = 0xc8a00000 ivshmem_gpio 0000:00:0d.0: data_mmio_start = 0x60000000 data_mmio_len = 1048576 ivshmem_gpio 0000:00:0d.0: regs iomap base = 0xc88e6400, irq = 27 ivshmem_gpio 0000:00:0d.0: regs_addr_start = 0x50002400 regs_len = 256 g&gt;&gt; # ls /sys/class/gpio/ export gpiochip248 unexport g&gt;&gt; # cat /sys/class/gpio/gpiochip248/label 0000:00:0d.0 g&gt;&gt; # cat /sys/class/gpio/gpiochip248/base 248 g&gt;&gt; # cat /sys/class/gpio/gpiochip248/ngpio 8 g&gt;&gt; # rmmod virtual_gpio_basic Unregister virtual_gpio device. g&gt;&gt; # insmod virtual_gpio_basic.ko gpiobase=0 g&gt;&gt; # ls /sys/class/gpio/ export gpiochip0 unexport g&gt;&gt; # echo 0 &gt; /sys/class/gpio/export g&gt;&gt; # echo high &gt; /sys/class/gpio/gpio0/direction</span></span></code> </pre> <br><br>  Simple check: <br><pre> <code class="bash hljs">h&gt;&gt; $ xxd -b -l 2 -c 2 /dev/shm/ivshmem 0000000: 00000001 00000001 ..</code> </pre> <br><br>  DATA is set, OUTPUTEN is set. <br><br><h2>  Add interrupts </h2><br><br><h3>  Tagging interrupt registers and basic interrupt handling </h3><br><br>  <em>Note: The virtual driver only considers EDGEDETECT_RISE and EDGEDETECT_FALL.</em> <br><br>  <em>Note: Please use only qemu versions older than 2.5.0 or qemu-linaro.</em>  <em>Idshmem interrupt support is broken in 2.5.0 or simply does not work in some versions earlier than 2.5.0.</em>  <em>If using 2.5.0 you must use a patch for 2.5.0 ( <a href="http://lists.gnu.org/archive/html/qemu-stable/2015-12/msg00034.html">http://lists.gnu.org/archive/html/qemu-stable/2015-12/msg00034.html</a> ).</em> <br><br>  Add the following registers: <br><table><thead><tr><th>  Register Name </th><th>  Bias </th><th>  Driver Name </th><th>  Description </th></tr></thead><tbody><tr><td>  INTERRUPT_EN </td><td>  0x01 </td><td>  VIRTUAL_GPIO_INT_EN </td><td>  Enable interrupts on a given input. </td></tr><tr><td>  INTERRUPT_ST </td><td>  0x02 </td><td>  VIRTUAL_GPIO_INT_ST </td><td>  Interrupt Status Register </td></tr><tr><td>  INTERRUPT_EOI </td><td>  0x03 </td><td>  VIRTUAL_GPIO_INT_EOI </td><td>  Register for notification of a processed interrupt </td></tr><tr><td>  EDGEDETECT_RISE </td><td>  0x04 </td><td>  VIRTUAL_GPIO_RISING </td><td>  Enable / Disable Interrupts for Front-End Entry </td></tr><tr><td>  EDGEDETECT_FALL </td><td>  0x05 </td><td>  VIRTUAL_GPIO_FALLING </td><td>  Enable / disable interrupts for trailing edge input </td></tr><tr><td>  LEVELDETECT_HIGH </td><td></td><td>  NC </td><td>  NOT CONNECTED </td></tr><tr><td>  LEVELDETECT_LOW </td><td></td><td>  NC </td><td>  NOT CONNECTED </td></tr></tbody></table><br><br>  The following function is responsible for handling the pci bus interrupt, at the moment its role is only in the notification of the processed interrupt: <br><div class="spoiler">  <b class="spoiler_title">static irqreturn_t virtual_gpio_interrupt (int irq, void * data)</b> <div class="spoiler_text"><pre> <code class="hljs rust"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> irqreturn_t virtual_gpio_interrupt(int irq, void *data) { <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span> status; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual_gpio</span></span></span></span> *vg = (<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual_gpio</span></span></span></span> *)data; status = readl(vg-&gt;regs_base_addr + IntrStatus); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!status || (status == <span class="hljs-number"><span class="hljs-number">0xFFFFFFFF</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IRQ_NONE; printk(KERN_INFO <span class="hljs-string"><span class="hljs-string">"VGPIO: interrupt (status = 0x%04x)\n"</span></span>, status); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IRQ_HANDLED; }</code> </pre> </div></div><br><br>  This stage will require an external daemon, which is included in the standard qemu-ivshmem-server delivery.  The -chardev path to the UNIX socket is added to the qemu startup line, messages exchanged between running qemu, ivshmem-server and ivshmem-client exchanges are implemented using the eventfd mechanism. <br><pre> <code class="bash hljs">h&gt;&gt; $ ivshmem-server -v -F -p ivshmem.pid -l 1M <span class="hljs-comment"><span class="hljs-comment">#  qemu    h&gt;&gt; $ += -chardev socket,path=/tmp/ivshmem_socket,id=ivshmemid -device ivshmem,chardev=ivshmemid,size=1,msi=off g&gt;&gt; # echo 8 &gt; /proc/sys/kernel/printk g&gt;&gt; # insmod virtual_gpio_basic.ko h&gt;&gt; $ ivshmem-client #   qemu ivshmem    ivshmem-server     id cmd&gt; int 0 0 # :       cmd&gt; help #   : g&gt;&gt; VGPIO: interrupt (status = 0x0001)</span></span></code> </pre> <br><br><h3>  irq_chip and chained_interrupt concept </h3><br><br>  We will not go into details, this topic is well <a href="https://github.com/torvalds/linux/commit/d1bef4ed5faf7d9872337b33c4269e45ae1bf960">covered</a> in the <a href="https://github.com/torvalds/linux/commit/d1bef4ed5faf7d9872337b33c4269e45ae1bf960">first patch presented by irq_chip</a> , the kernel documentation and the book ‚ÄúProfessional Linux Kernel Architecture‚Äù (currently it is outdated, but irq_chip is also not a new thing). <br><br>  At the moment, the main thing for us is the fact that GPIO ports that provide interrupts are a common practice in the days of Linux that interrupt cascading from the parent interrupt controller. <br><br>  This is why part of the GPIO driver responsible for interrupts uses <strong>irq_chip</strong> .  In other words, such a driver uses two subsystems simultaneously: <strong>gpio_chip</strong> and <strong>irq_chip</strong> . <br><br>  A quick look at the irq subsystem gives us the following picture: <br><br><img src="https://habrastorage.org/files/8f2/428/084/8f2428084091403aab3add32b0573516.png"><br><blockquote>  <strong>High-Level Interrupt Service Routines (ISRs)</strong> - Performs all necessary interrupt service work on the device driver.  For example, if an interrupt is used to indicate readable new data, the work of the ISR will be to copy the data to the appropriate place. <br><br>  <strong>Interrupt Flow Handling</strong> - This subsystem is responsible for features in the implementation of interrupt processing, such as triggering on a signal level (level) or on a front (edge). <br><br>  Edge triggering occurs when determining that a potential change has occurred on the line.  Triggering by level (Level-triggering), is defined as a specific value of the potential, and the change in potential does not matter. <br><br>  From the point of view of the kernel, the level triggering is a more complicated case, since, at the beginning of each interrupt, it must be masked. <br><br>  <strong>Chip-Level Hardware Encapsulation</strong> - Used to encapsulate the features of the implementation of working with the hardware.  This subsystem can be considered as a kind of ‚Äúdevice driver‚Äù for interrupt controllers. </blockquote><br><br>  As we can see, the kernel takes control of the processing of the interrupt chain and the difference in the implementation of types (by front and level), if we provide the appropriate infrastructure. <br><br><h3>  IRQ Domains </h3><br><br>  The <a href="https://www.kernel.org/doc/Documentation/IRQ-domain.txt">IRQ Domain</a> subsystem, which appeared in the <a href="https://github.com/torvalds/linux/commit/08a543ad33fc188650801bd36eed4ffe272643e1">irq: add irq_domain translation infrastructure</a> patch, allowed separating the interrupt controller numbers from the interrupt numbers in the kernel, providing a common array of interrupt numbers.  Quoting official documentation: <strong>‚ÄúToday the IRQ number is just a number</strong> . <strong>‚Äù</strong> <br><br>  Prior to this update, hardware numbers were mapped to kernel numbers as 1: 1, and cascading was not supported.  By hardware numbers, we mean local interrupt numbers for the controller, which in our case coincide with local GPIO numbers. <br><br>  The following types of mapping exist in the IRQ Domain: <br><ul><li>  Linear </li><li>  Tree view </li><li>  And type "No map" (No display) </li></ul><br><br>  Since our interrupt vector is rather small, and we definitely have no interest in the "No map" map, our map is linear, in fact the numbers are matched 1: 1 with the offset, the difference with the old approach is that the assignment of irq numbers and the calculation of the offset core, while ensuring continuity of the allocated range. <br><br>  In each function of the irq_chip interface, a pointer is passed to the <strong>struct irq_data</strong> structure, where <strong>irq_data-&gt; irq</strong> is the interrupt number in the linux kernel, and <strong>irq_data-&gt; hwirq</strong> is our local interrupt number within the driver.  Also, a pointer to our <strong>struct virtual_gpio</strong> structure is passed to <strong>struct irq_data</strong> , which is not surprising. <br><br><h3>  Binding irq_chip and gpio_chip </h3><br><br>  If we were guided by younger versions of the kernel, we would have to use the <strong>irq_domain_add_simple</strong> function to display our number, but from version 3.15 in the <a href="https://github.com/torvalds/linux/commit/1425052097b53de841e064dc190a9009480c208c">gpio</a> patch <a href="https://github.com/torvalds/linux/commit/1425052097b53de841e064dc190a9009480c208c">: add IRQ chip helpers in gpiolib patch</a> there is no need to directly use the IRQ Domain interface. <br><br>  Therefore, instead of using the IRQ Domain interface directly and providing the infrastructure for mapping local numbers to global ( <strong>.map ()</strong> ops), we will use the functions <strong>gpiochip_irqchip_add</strong> and <strong>gpiochip_set_chained_irqchip</strong> (depend on the GPIOLIB_IRQCHIP parameter Kconfig). <br><br>  A great example of use and ease of use is the <a href="">gpio-pl061 driver</a> . <br><br>  <strong>Bind</strong> our <strong>irq_chip</strong> to an existing <strong>gpio_chip</strong> : <br><pre> <code class="hljs lisp">gpiochip_irqchip_add(<span class="hljs-name"><span class="hljs-name">&amp;vg-&gt;chip</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;virtual_gpio_irq_chip</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, handle_edge_irq, IRQ_TYPE_NONE)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  <strong>handle_edge_irq</strong> is one of the built-in stream handlers that takes control of the chain of interrupts on fronts. <br><br>  <em>Note: Frontal interrupts are the most common.</em>  <em>The main difference from level interrupts lies in the management of the chain, the level interruption is masked in the kernel immediately upon receipt.</em> <br><pre> <code class="hljs lisp">gpiochip_set_chained_irqchip(<span class="hljs-name"><span class="hljs-name">&amp;vg-&gt;chip</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;virtual_gpio_irq_chip</span></span>, pdev-&gt;irq, NULL)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre> <br><br>  <strong>By calling the gpiochip_set_chained_irqchip</strong> function <strong>,</strong> we tell the kernel that our <strong>irq_chip</strong> uses a PCI bus interrupt and our interrupts are cascaded from <strong>pdev-&gt; irq</strong> . <br><br>  We <strong>‚Äôll modify</strong> our handler to generate interrupts depending on the state of <strong>VIRTUAL_GPIO_INT_ST</strong> : <br><pre> <code class="hljs perl">pending = vgread(VIRTUAL_GPIO_INT_ST); <span class="hljs-regexp"><span class="hljs-regexp">/* check if irq is really raised */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(pending) { for_each_set_bit(i, &amp;pending, VIRTUAL_GPIO_NR_GPIOS) generic_handle_ir<span class="hljs-string"><span class="hljs-string">q(irq_find_mapping(vg-&gt;chip.irqdomain, i)</span></span>); }</code> </pre> <br><br>  <strong>irq_find_mapping</strong> is an auxiliary function for translating the local input number into the global interrupt number. <br><br><h3>  Putting it all together </h3><br><br>  First of all, we note that the irq_chip interface of our driver looks like this: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_chip</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual_gpio_irq_chip</span></span></span><span class="hljs-class"> = </span></span>{ .name = <span class="hljs-string"><span class="hljs-string">"GPIO"</span></span>, .irq_ack = virtual_gpio_irq_ack, .irq_mask = virtual_gpio_irq_mask, .irq_unmask = virtual_gpio_irq_unmask, .irq_set_type = virtual_gpio_irq_type, };</code> </pre> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ack ()</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> function is </font><font style="vertical-align: inherit;">always closely related to the hardware specificity of the controller. </font><font style="vertical-align: inherit;">Some devices, for example, require confirmation of the processing of an interruption request before subsequent requests can be served.</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static void virtual_gpio_irq_ack (struct irq_data * d)</font></font></b> <div class="spoiler_text"><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void virtual_gpio_irq_ack(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_data</span></span></span></span> *d) { unsigned long flags; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> nr = d-&gt;hwirq; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> mask = <span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio_chip</span></span></span></span> *gc = irq_data_get_irq_chip_data(d); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual_gpio</span></span></span></span> *vg = to_virtual_gpio(gc); spin_lock_irqsave(&amp;vg-&gt;lock, flags); vgwrite(mask, VIRTUAL_GPIO_INT_EOI); spin_unlock_irqrestore(&amp;vg-&gt;lock, flags); }</code> </pre> </div></div><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In our case, the program vg_get_set - rather rough emulation of the eoi register is used. </font><font style="vertical-align: inherit;">After setting the interrupt status flag, the eoi register is constantly polled in the loop. </font><font style="vertical-align: inherit;">When the interrupt notification input bit is set by the driver, the eoi register is cleared and the interrupt status bit is cleared at the input. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masking and unmasking is done by writing the corresponding value to the </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">INTERRUPT_EN</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> register </font><font style="vertical-align: inherit;">. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interrupt masking:</font></font><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">static void virtual_gpio_irq_mask (struct irq_data * d)</font></font></b> <div class="spoiler_text"><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void virtual_gpio_irq_mask(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_data</span></span></span></span> *d) { <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> mask; unsigned long flags; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> nr = d-&gt;hwirq; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio_chip</span></span></span></span> *gc = irq_data_get_irq_chip_data(d); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual_gpio</span></span></span></span> *vg = to_virtual_gpio(gc); spin_lock_irqsave(&amp;vg-&gt;lock, flags); mask = vgread(VIRTUAL_GPIO_INT_EN); mask &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr); vgwrite(mask, VIRTUAL_GPIO_INT_EN); spin_unlock_irqrestore(&amp;vg-&gt;lock, flags); }</code> </pre> </div></div><br><br>  : <br><div class="spoiler"> <b class="spoiler_title">static void virtual_gpio_irq_unmask(struct irq_data *d)</b> <div class="spoiler_text"><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> void virtual_gpio_irq_unmask(<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_data</span></span></span></span> *d) { <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> mask; unsigned long flags; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> nr = d-&gt;hwirq; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio_chip</span></span></span></span> *gc = irq_data_get_irq_chip_data(d); <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual_gpio</span></span></span></span> *vg = to_virtual_gpio(gc); spin_lock_irqsave(&amp;vg-&gt;lock, flags); mask = vgread(VIRTUAL_GPIO_INT_EN); mask |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr); vgwrite(mask, VIRTUAL_GPIO_INT_EN); spin_unlock_irqrestore(&amp;vg-&gt;lock, flags); }</code> </pre> </div></div><br><br> <strong>irq_type</strong>     ‚Äî        : <br> IRQ_TYPE_NONE ‚Äî    <br> IRQ_TYPE_EDGE_RISING ‚Äî    <br> IRQ_TYPE_EDGE_FALLING ‚Äî    <br> IRQ_TYPE_EDGE_BOTH ‚Äî      <br> IRQ_TYPE_LEVEL_HIGH ‚Äî    <br> IRQ_TYPE_LEVEL_LOW ‚Äî    <br><div class="spoiler"> <b class="spoiler_title">static int virtual_gpio_irq_type(struct irq_data *d, unsigned int type)</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virtual_gpio_irq_type</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(struct irq_data *d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">unsigned</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flags; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gpio_chip</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gc</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">irq_data_get_irq_chip_data</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">d</span></span></span><span class="hljs-class">);</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">virtual_gpio</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">vg</span></span></span><span class="hljs-class"> = </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">to_virtual_gpio</span></span></span><span class="hljs-class">(</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">gc</span></span></span><span class="hljs-class">);</span></span> u8 mask; u8 nr = d-&gt;hwirq; spin_lock_irqsave(&amp;vg-&gt;lock, flags); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IRQ_TYPE_EDGE_RISING: mask = vgread(VIRTUAL_GPIO_RISING); mask |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr); vgwrite(mask, VIRTUAL_GPIO_RISING); mask = vgread(VIRTUAL_GPIO_FALLING); mask &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr); vgwrite(mask, VIRTUAL_GPIO_FALLING); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> IRQ_TYPE_EDGE_FALLING: mask = vgread(VIRTUAL_GPIO_FALLING); mask |= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr); vgwrite(mask, VIRTUAL_GPIO_FALLING); mask = vgread(VIRTUAL_GPIO_RISING); mask &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr); vgwrite(mask, VIRTUAL_GPIO_RISING); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: retval = -EINVAL; <span class="hljs-keyword"><span class="hljs-keyword">goto</span></span> end; } <span class="hljs-comment"><span class="hljs-comment">/* enable interrupt */</span></span> mask = vgread(VIRTUAL_GPIO_INT_EN); mask &amp;= ~(<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; nr); vgwrite(mask, VIRTUAL_GPIO_INT_EN); end: spin_unlock_irqrestore(&amp;vg-&gt;lock, flags); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> retval; }</code> </pre> </div></div><br><h1>    </h1><br><br>        user space,     vg_guest_client.    gpio_sysfs, <a href="http://lxr.free-electrons.com/source/Documentation/gpio/sysfs.txt%3Fv%3D4.1">‚Äú   select   ,    ()  exceptfds‚Äù</a> . <br><br>  : <br><pre> <code class="hljs pgsql"> FD_ZERO(&amp;efds); maxfd = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; gpio_size; i++) { FD_SET(gpios[i].fd, &amp;efds); maxfd = (maxfd &lt; gpios[i].fd) ? gpios[i].fd : maxfd; } ready = pselect(maxfd + <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, &amp;efds, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(ready &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; gpio_size; i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(FD_ISSET(gpios[i].fd, &amp;efds)) { <span class="hljs-keyword"><span class="hljs-keyword">read</span></span>(gpios[i].fd, &amp;<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*    lseek  http://lxr.free-electrons.com/source/fs/kernfs/file.c?v=4.1#L769 */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lseek(gpios[i].fd, <span class="hljs-number"><span class="hljs-number">0</span></span>, SEEK_SET) == <span class="hljs-number"><span class="hljs-number">-1</span></span>) perror("lseek"); printf("gpio number=%d interrupt caught\n", gpios[i].number); }</code> </pre> <br><br>       <strong>sysfs</strong> : <br><pre> <code class="bash hljs">g&gt;&gt; <span class="hljs-comment"><span class="hljs-comment"># echo 504 &gt; /sys/class/gpio/export g&gt;&gt; # echo 505 &gt; /sys/class/gpio/export g&gt;&gt; # echo 506 &gt; /sys/class/gpio/export g&gt;&gt; # echo rising &gt; /sys/class/gpio/gpio504/edge g&gt;&gt; # echo rising &gt; /sys/class/gpio/gpio505/edge g&gt;&gt; # echo rising &gt; /sys/class/gpio/gpio506/edge</span></span></code> </pre> <br><br> <em>: gpio         .</em> <br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#      gpiochip   g&gt;&gt; # ./vg_guest_client 504 gpio_chip: base: 504 ngpio: 8 Added gpio 504 to watchlist. Added gpio 505 to watchlist. Added gpio 506 to watchlist. Entering loop with 3 gpios. h&gt;&gt; $ ./vg_get_set -p 1 -i 0 g&gt;&gt; gpio number=504 interrupt caught</span></span></code> </pre> <br><br>         pselect: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> irqreturn_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">virtual_gpio_interrupt</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> irq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *data</span></span></span><span class="hljs-function">) </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">generic_handle_irq</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">unsigned </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> irq</span></span></span><span class="hljs-function">)</span></span>; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> irqreturn_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gpio_sysfs_irq</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> irq, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *priv</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> inline </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sysfs_notify_dirent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernfs_node *kn</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernfs_notify</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> kernfs_node *kn</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kernfs_notify_workfn</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">struct</span></span></span></span><span class="hljs-function"><span class="hljs-params"> work_struct *work</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br><br><h1>  Conclusion </h1><br><br>    ,    ,  ,   ,   -  . Qemu    ivshmem        .            . <br><br>    gpio sysfs          sysfs,     GPIO        ,       .        . <br><br>  ,     ,       .       <a href="">generic-gpio</a> , ,   ,    mmio gpio ,  , ,   .        ,         . <br><br>   ,      ,       : <br><ul><li>    Device Tree       </li><li>   generic-gpio    mmio gpio  </li><li>     ,  GPIO   </li><li>     gpio ‚Äî , ,    </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It is also impossible to lose sight of the latest changes in </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpiolib</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> - </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sysfs gpio is</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> now outdated. </font><font style="vertical-align: inherit;">A new </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ioctl-</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> based interface for </font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gpiolib</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> on the way to becoming a new standard for communicating with GPIO. </font><font style="vertical-align: inherit;">But the younger versions will be used for a long time, besides, no one is going to remove the old interface from the kernel at the moment. </font><font style="vertical-align: inherit;">For example, I still have devices that successfully work on the 2.6.34 kernel version. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">List of materials:</font></font><br><ol><li> <a href="http://nairobi-embedded.org/category/device-drivers.html"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://nairobi-embedded.org/category/device-drivers.html</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> [Siro Mugabi]</font></font></li><li> <a href="http://lxr.free-electrons.com/source"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">http://lxr.free-electrons.com/source</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Professional Linux Kernel Architecture [Wolfgang Mauerer] </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDD3 [Jonathan Corbet, Alessandro Rubini, and Greg Kroah-Hartman] </font></font></li></ol><br><br>     : <br><ol><li> <a href="http://derekmolloy.ie/writing-a-linux-kernel-module-part-1-introduction/">http://derekmolloy.ie/writing-a-linux-kernel-module-part-1-introduction/</a> (  ) </li><li> <a href="https://developer.ridgerun.com/wiki/index.php%3Ftitle%3DGpio-int-test.c">https://developer.ridgerun.com/wiki/index.php?title=Gpio-int-test.c</a> </li><li> <a href="http://www.assert.cc/2015/01/03/selects-exceptional-conditions.html">http://www.assert.cc/2015/01/03/selects-exceptional-conditions.html</a> </li></ol><br><br>  , Makefile  README: <br> <a href="https://github.com/maquefel/virtual_gpio_basic">https://github.com/maquefel/virtual_gpio_basic</a> <br></div><p>Source: <a href="https://habr.com/ru/post/303060/">https://habr.com/ru/post/303060/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303044/index.html">Marketing is war</a></li>
<li><a href="../303046/index.html">Digest of gaming industry events for 2016</a></li>
<li><a href="../303050/index.html">DevOps - automate everything</a></li>
<li><a href="../303052/index.html">Oh, I have these databases: Sybase (ASE) and datetime</a></li>
<li><a href="../303058/index.html">Where to get logins or VoIP to help</a></li>
<li><a href="../303062/index.html">Dlink switch study after thunderstorms</a></li>
<li><a href="../303064/index.html">Creating an Android application or a project without a name</a></li>
<li><a href="../303066/index.html">DevConf :: Go - June 17 in Skolkovo, an exclusive workshop on Go June 18 in TASS</a></li>
<li><a href="../303068/index.html">Free webinar "WebLogic Application Server 12.2: multi-lending, high availability, Docker-containers"</a></li>
<li><a href="../303074/index.html">Investigation: where your site redirects users, and you don‚Äôt even know about it</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>