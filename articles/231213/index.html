<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Why you should never use MongoDB</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Disclaimer from the author (the author is a girl): I do not develop database engines. I create web applications. I participate in 4-6 different projec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Why you should never use MongoDB</h1><div class="post__text post__text-html js-mediator-article">  Disclaimer from the author (the author is a girl): I do not develop database engines.  I create web applications.  I participate in 4-6 different projects every year, that is, I create <b>many</b> web applications.  I see many applications with different requirements and different data storage needs.  I unwrapped most of the repositories that you‚Äôve heard about, and several that you don‚Äôt even suspect. <br><br>  Several times I made the wrong choice of DBMS.  This story is about one such choice - why we made such a choice, how we would know that the choice was wrong and how we struggled with it. It all happened on an open source project called Diaspora. <br><a name="habracut"></a><br><h4>  Project </h4><br>  Diaspora is a distributed social network with a long history.  A long time ago, in 2010, four students at New York University published a video on Kickstarter asking them to donate $ 10,000 to develop a distributed alternative to Facebook.  They sent the link to friends, family and hoped for the best. <br><br>  But they hit the nail on the head.  Another scandal has just died down because of privacy on Facebook, and when the dust settled they received $ 200,000 investment from 6,400 people for a project that had not yet written a single line of code. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Diaspora was one of the first Kickstarter projects that managed to significantly exceed the target.  As a result, they were written about in the New York Times newspaper, which turned out to be a scandal, because an indecent joke was written on the board against the photograph of the team, but nobody noticed that until the photo was printed ... in the New York Times.  So I found out about this project. <br><br>  As a result of the success on Kickstarter, the guys quit studying and moved to San Francisco to start writing code.  So they were in my office.  At that time, I worked at Pivotal Labs and one of the elder brothers of the Diaspora developers also worked at this company, so Pivotal offered the guys jobs, the Internet, and, of course, access to the fridge with beer.  I worked with the company's official clients, and in the evenings I hung out with the guys and wrote the code on weekends. <br><br>  They ended up staying at Pivotal for more than two years.  However, by the end of the first summer they had a minimal, but working (in a sense) implementation of a distributed social network on Ruby on Rails, using MongoDB for data storage. <br><br>  Quite a few baszvorodov - let's see. <br><br><h4>  Distributed social network </h4><br>  If you've seen Facebook, then you know everything you need to know about Facebook.  This web application, it exists in a single copy and allows you to communicate with people.  The Diaspora interface looks almost the same as Facebook. <br><img src="https://habrastorage.org/getpro/habr/post_images/af7/892/a82/af7892a820e83eabfb89cd8ee718ce7c.jpg" alt="image" width="512"><br>  The message line in the middle shows the posts of all your friends, and around it is a pile of garbage that no one pays attention to.  The main difference between Diaspora and Facebook is invisible to users, this is the ‚Äúdistributed‚Äù part. <br><br>  The infrastructure of Disapora is not located behind a single web address.  There are hundreds of independent copies of Diaspora.  The code is open, so you can deploy your servers.  Each copy is called a pod.  It has its own database and its own set of users.  Each Pod interacts with other Pods, which also have their own base and their users. <br><img src="https://habrastorage.org/getpro/habr/post_images/47a/391/f5d/47a391f5d5587bbae83239a8274debca.png" alt="image" width="512"><br><br>  Pods communicate using API based on the HTTP protocol (now it is fashionable to call it REST API - <i>approx. Lane</i> ).  When you unwrap your Pod, it will be pretty boring until you add friends.  You can add as a friend to users in your Pod, or in other Pods.  When someone publishes something, this is what happens: <br><ol><li>  The message will be saved in the author‚Äôs database. </li><li>  Your Pod will be notified through the API. </li><li>  The message will be saved in your Pod database. </li><li>  In your feed you will see a message along with messages from other friends. </li></ol><br>  Comments work the same way.  Each message can be commented on by users from the same Pod as well as people from other Pods.  Anyone who has permission to view the message will also see all comments.  As if everything happens in one application. <br><br><h4>  Who cares? </h4><br>  There are technical and legal advantages of this architecture.  The main technical advantage is fault tolerance. <br><img src="https://habrastorage.org/getpro/habr/post_images/349/b79/3e9/349b793e93449475b5a03fc5fcfddfb7.jpg" alt="image" width="512"><br>  <i>(such a fail-safe system should be available in every office)</i> <br><br>  If one of the pods falls, then all others continue to work.  The system causes, and even expects, network separation.  The political implications of this are, for example, if in your country they block access to Facebook or Twitter, your local Pod will be available to other people in your country, even if everyone else is not available. <br><br>  The main legal advantage is server independence.  Each Pod is a legally independent entity, governed by the laws of the country where the Pod is located.  Each Pod can also set its own terms, on most you do not give up rights to all content, such as on Facebook or Twitter.  Diaspora is free software, both in the ‚Äúfree‚Äù sense, and in the ‚Äúindependent‚Äù sense.  Most of those who run their Pods are very concerned. <br><br>  This is the system architecture, let's look at the architecture of a single Pod. <br><br><h4>  This is a Rails application. </h4><br>  Each Pod is a Ruby on Rails application with its MongoDB base.  In a sense, this is a ‚Äútypical‚Äù Rails application ‚Äî it has a user interface, a programming API, Ruby logic, and a database.  But in all other respects it is far from typical. <br><img src="https://habrastorage.org/getpro/habr/post_images/9e2/129/7ad/9e21297adcd1f694c4a16990f17c3466.png" alt="image" width="512"><br>  The API is used for mobile clients and for "federation", that is, for interaction between Pods.  Distribution adds several layers of code that are absent in a typical application. <br><br>  And, of course, MongoDB is far from a typical choice for web applications.  Most Rails applications use PostgreSQL or MySQL.  (as of 2010 - <i>approx. lane.</i> ) <br><br>  So here's the code.  Consider what data we store. <br><br><h4>  I don't think that word means what you think it means </h4><br>  ‚ÄúSocial data‚Äù is information about our network of friends, their friends and their activities.  Conceptually, we think of it as a network ‚Äî an undirected graph in which we are in the center, and our friends are around us. <br><img src="https://habrastorage.org/getpro/habr/post_images/bf0/3a5/c07/bf03a5c07a10f600e1d6206657b2d23c.png" alt="image" width="512"><br>  <i>(Photos from rubyfriends.com. Thanks to Matt Rogers, Steve Klabnik, Nell Shamrell, Katrina Owen, Sam Livingston Gray, Josh Sasser, Akshay Khole, Pradyumna Dandwate and Hefziba Watharkar for contributing to # rubyfriends!)</i> <br><br>  When we store social data, we save both topology and actions. <br><br>  For several years now we have known that social data is not relational, if you store social data in a relational database, then you are doing it wrong. <br><br>  But what are the alternatives?  Some argue that graph databases are best suited, but I will not consider them, since they are too niche for mass projects.  Others say that documentary data is ideal for social data, and they are fairly mainstream for real use.  Let's take a look at why people think that MongoDB is much better suited for social data than PostgreSQL. <br><br><h4>  How MongoDB stores data </h4><br>  MongoDB is a document database.  Instead of storing data in <b>tables</b> consisting of separate <b>rows</b> , as in relational databases, MongoDB stores data in <b>collections</b> consisting of <b>documents</b> .  A document is a large JSON object with no predefined format and schema. <br><br>  Let's look at the set of links that you need to model.  This is very similar to the projects in Pivotal for which MongoDB was used, and this is the best use case for a document database engine I have ever seen. <br><img src="https://habrastorage.org/getpro/habr/post_images/178/4e7/a92/1784e7a92ac1c3b04a7ff1125b9de31b.png" alt="image" width="512"><br>  At the root we have a series of TV shows.  Each series can have many seasons, each season has many episodes, each episode has many reviews and many actors.  When a user comes to the site, he usually gets to the page of a particular series.  The page displays all seasons, episodes, reviews and actors, all on one page.  From the point of view of the application, when the user hits the page we want to get all the information related to the series. <br><br>  This data can be modeled in several ways.  In a typical relational repository, each of the rectangles will be a table.  You will have the tv_shows table, the seasons table with a foreign key in tv_shows, the episodes table with a foreign key in seasons, reviews, and cast_members of a table with foreign keys in the episodes.  Thus, to get all the information about the series, you need to join five tables. <br><br>  We could also model this data as a set of nested objects (a set of key-value pairs).  A lot of information about a particular series is one big structure of nested key-value sets.  Inside the series, there are many seasons, each of which is also an object (a set of key-value pairs).  Within each season, an array of episodes, each of which represents an object, and so on.  So in MongoDB model the data.  Each series is a document that contains all the information about one series. <br><br>  Here is an example of a document of one series, Babylon 5: <br><img src="https://habrastorage.org/getpro/habr/post_images/5aa/d58/9d0/5aad589d00ad5a74db58ab01865d9cc0.png" alt="image" width="512"><br>  The show has a name and an array of seasons.  Each season - an object with metadata and an array of episodes.  In turn, each episode has metadata and arrays of reviews and actors. <br><br>  Looks like a huge fractal data structure. <br><img src="https://habrastorage.org/getpro/habr/post_images/d0f/dab/a24/d0fdaba249d7325668b889862ce6b9f1.jpg" alt="image" width="512"><br>  <i>(Many sets of sets. Delicious fractals.)</i> <br><br>  All data needed for the series is stored in one document, so you can get all the information very quickly at once, even if the document is very large.  There is a series called General Hospital, which has 12,000 episodes for 50+ seasons.  On my laptop, PostgreSQL runs for about a minute to get denormalized data for 12,000 episodes, while retrieving a document by ID in MongoDB takes a fraction of a second. <br><br>  So in many ways, this application implements the ideal use for the document base. <br><br><h4>  Good.  But what about social data? </h4><br>  Right.  When you get into a social network, there is only one important part of the page: your activity feed.  The request feed activity gets all the posts from your friends, sorted by date.  Each post contains attachments such as photos, likes, reposts and comments. <br><br>  The nested structure of the activity tape looks very similar to the serials. <br><img src="https://habrastorage.org/getpro/habr/post_images/7f1/3d4/299/7f13d42995ab3f2ac48620c87caa197a.png" alt="image" width="512"><br><br>  Users have friends, friends have posts, posts have comments and likes, each of which is associated with one commentator or likes.  From the point of view of connections, this is not much more complicated than the structure of television series.  And as in the case of serials, we want to get the whole structure at once as soon as the user enters the social network.  In a relational DBMS, this would be a join of seven tables to pull out all the data. <br><br>  The connection of seven tables, oh.  Suddenly, saving the entire user tape as a single denormalized data structure, instead of doing joins, looks very attractive.  (In PostgreSQL, such joins are slowly working cause pain - <i>approx. Lane.</i> ) <br><br>  In 2010, the Diaspora team made such a decision, Esty‚Äôs articles on using documentary DBMS turned out to be very convincing, even though they publicly rejected MongoDB in consequence.  In addition, at this time, the use of Cassandra on Facebook spawned a lot of talk about abandoning relational databases.  The choice of MongoDB for Disapora was in the spirit of the time.  It was not an unreasonable choice at that time, given the knowledge that they had. <br><br><h4>  What could go wrong? </h4><br>  There is a very important difference between the social data of Diaspora and Mongo-ideal data about serials, which no one noticed at first glance. <br><br>  With serials, each rectangle in the relationship diagram has a different type.  Series differ from seasons, differ from episodes, differ from reviews, differ from actors.  None of them is even a subtype of another type. <br><br>  But with social data, some of the rectangles in the relationship diagram are of the same type.  In fact, all these green rectangles of the same type are all users of the diaspora. <br><img src="https://habrastorage.org/getpro/habr/post_images/95e/65b/f8a/95e65bf8a73c713790db69a95193676e.png" alt="image" width="512"><br><br>  The user has friends, and each friend can be a user.  Or it may not be, because it is a distributed system.  (This is a whole layer of complexity that I‚Äôll skip today.) In the same way, commentators and likes can also be users. <br><br>  Such duplication of types greatly complicates the denormalization of the tape of activity into a single document.  This is because in different places in the document, you can refer to the same entity - in this case, the same user.  The user who liked the post can also be a user who commented on another activity. <br><br><h4>  Data duplication data duplication </h4><br>  We can model it differently in MongoDB.  The easiest way is to duplicate data.  All information about the user is copied to the like in the first post, and then a separate copy is saved in the comment to the second post. The advantage is that all data is present wherever you need it, and you can still pull out the entire stream of activity in another document. <br><br>  This is approximately the density of a denormalized activity tape. <br><img src="https://habrastorage.org/getpro/habr/post_images/9cf/04f/ffe/9cf04fffe4e1550264de46f54ff19df9.png" alt="image" width="512"><br><br>  All copies of user data are embedded in the document.  This is Joe's tape, and he has copies of user data, including his name and URL, at the top level.  His tape contains a post Jane.  Joe limped Jane's post, so that in lacquers to Jane's post, a separate copy of Joe's data was saved. <br><br>  You can understand why this is attractive: all the data you need is already where you need it. <br><br>  You can also see why this is dangerous.  Updating user data means traversing all activity tapes to change data in all places where it is stored.  This is very error prone, and often leads to data inconsistencies and mysterious errors, especially when working with deletions. <br><br><h4>  Is there no hope? </h4><br>  There is another approach to solving a problem in MongoDB, which will be familiar to those who have experience with relational databases.  Instead of duplicating data, you can save links to users in the activity feed. <br><br>  With this approach, instead of embedding the data where it is needed, you give each user an ID.  After that, instead of embedding user data, you save only links to users.  In the picture, the IDs are highlighted in green: <br><img src="https://habrastorage.org/getpro/habr/post_images/64e/959/9bc/64e9599bc7c6d614c666592c132a5fda.png" alt="image" width="512"><br>  <i>(MongoDB actually uses BSON identifiers - strings that look like GUIDs. The numbers in the image make it easier to read.)</i> <br><br>  This eliminates our duplication problem.  When changing user data, there is only one document that needs to be changed.  However, we created a new problem for ourselves.  Because we can no longer build a tape of activity from a single document.  This is a less effective and more complex solution.  Building an activity feed now requires us to 1) get an activity feed document, and then 2) get all user documents to fill out names and avatars. <br><br>  What MongoDB lacks is join operations like in SQL, which allows you to write one query that brings together the activity tape and all users that have links from the tape.  In the end, you have to manually make joins in the application code. <br><br><h4>  Simple denormalized data </h4><br>  Back to the series for a second.  A lot of relationships for TV shows do not have much difficulty.  Because all the rectangles in the relationship diagram are different entities, the entire request can be denormalized into one document, without duplication and without references.  In this database, there are no links between documents.  Therefore, joins are not required. <br><br>  There are no self-sufficient entities in the social network.  Every time when you see the username or avatar you expect that you can click and see the user profile, his posts.  TV shows do not work this way.  If you are on episode 1 of season 1 of Babylon 5, you do not expect to be able to move on to episode 1 of season 1 of General Hospital. <br><br><h4>  Not.  It is necessary.  Refer.  On.  Documents. </h4><br>  After we started making ugly joins manually in the Diaspora code, we realized that this was only the first sign of problems.  It was a signal that our data is actually relational, that there is value in this structure of connections and we are moving against the basic idea of ‚Äã‚Äãdocumentary DBMS. <br><br>  Do you duplicate important data (fie), or use links and make joins in the application code (double fie), if you need links between documents, then you have outgrown MongoDB.  When MongoDB apologists say ‚Äúdocuments,‚Äù they mean things you can print on paper and work that way.  Documents have an internal structure - headings and subheadings, paragraphs and footers, but do not have links to other documents.  Self-contained element of semi-structured data. <br><br>  If your data looks like a set of paper documents - congratulations!  This is a good case for Mongo.  But if you have links between documents, then you actually have no documents.  MongoDB is a bad decision in this case.  For social data, this is a really bad decision, since the most important part is communication between documents. <br><br>  Thus, social data is not documentary.  Does this mean that social data is actually ... relational? <br><br><h4>  Again this word </h4><br>  When people say ‚Äúsocial data is not relational,‚Äù it means not what they mean.  They mean one of two things: <br><br><h5>  1. "Conceptually, social data is more a graph than a set of tables." </h5><br>  This is absolutely true.  But there are actually very few concepts in the world that, naturally, can be modeled as normalized tables.  We use this structure because it is efficient, because it avoids duplication, and because when it really becomes slow, we know how to fix it. <br><br><h5>  2. "It is much faster to obtain all social data when they are denormalized in one document" </h5><br>  This is also absolutely true.  When your social data is in a relational repository, you need to make the connection of many tables in order to get activity tape for a specific user, and that is slower with the growth of the table volumes.  However, we have a well-understood solution to this problem.  It is called caching. <br><br>  At the <a href="http://allyourbaseconf.com/">All Your Base Conf</a> conference in Oxfort, where I gave a talk on the topic of this post, <a href="http://nehanaru.la/">Neha Narula</a> presented a great talk about caching, which I recommend watching.  In short, caching normalized data is a complex, but fully understood problem.  I saw projects in which the tape activity was denormalized in a document database, like MongoDB, which made it possible to get data much faster.  The only problem is cache invalidation. <br><blockquote><h4>  ‚ÄúThere are only two difficult tasks in the field of computer science: disabling the cache and inventing names.‚Äù </h4><br>  <i>Phil carlton</i> <br></blockquote><br>  It turns out that disabling the cache is actually quite difficult.  Phil Carlton has written most of the SSL versions 3, X11 and OpenGL, so he knows something about computer science. <br><br><h4>  cache invalidation as a service </h4><br>  But what is cache invalidation, and why is it so difficult? <br><br>  Cache invalidation is the knowledge when your data in the cache is out of date and you need to update or replace it.  Here is a typical example that I see every day in web applications.  We have long-term storage, usually PostgreSQL or MySQL, and in front of them we have a caching layer, based on Memcached or Redis.  The request for <i>reading the</i> user's activity tape is processed from the cache, and not directly from the database, which makes the execution of the request very fast. <br><img src="https://habrastorage.org/getpro/habr/post_images/bba/7b1/3d3/bba7b13d386c2349de31739a4a87be79.png" alt="image" width="512"><br><br>  <i>Writing</i> is a much more complicated process.  Suppose a user with two friends creates a new post.  The first thing that happens is that the post is written to the database.  After that, the background thread writes the post to the cached tape of the activity of both users who are friends of the author. <br><br>  This is a very common pattern.  Tweeter keeps in-memory cache tapes of the latest active users, to which posts are added when someone from the followers creates a new post.  Even small applications that use something like activity tapes do this (see: joining seven tables). <br><br>  Let's return to our example.  When an author changes an existing post, the update is processed the same way as the creation, except that the item in the cache is updated, not added to the existing one. <br><br>  What happens if the background thread, updating the cache, is interrupted in the middle?  The server may fall, the network cables will be disconnected, the application will restart.  Instability is the only stable fact in our work.  When this happens, the data in the cache becomes inconsistent.  Some copies of posts have the old name, and others - new.  This is not an easy task, but with the cache, there is always the nuclear option. <br><img src="https://habrastorage.org/getpro/habr/post_images/f7b/096/ce1/f7b096ce15d5c67b35d2e2098184cd34.jpg" alt="image" width="512"><br><br>  You can always completely remove an item from the cache and rebuild it from the <i>agreed long-term</i> storage. <br><br>  But what if there is no long-term storage?  <b>What if the cache is the only thing you have?</b> <br><br>  In the case of MongoDB, this is exactly the case.  This is a cache, without a long-term consistent storage.  And he <b>will definitely become</b> inconsistent.  Not ‚Äúfinally agreed‚Äù ( <i>eventually consistent</i> ), but simply uncoordinated all the time (This is not so difficult to achieve, it is enough that updates occur more often than than the average time to reach a coordinated state - <i>approx. Lane</i> ).  In this case, you have no options, even "nuclear".  You have no way to rebuild the cache in a consistent state. <br><br>  When Diaspora decided to use MongoDB, they combined the database with a cache.  Database and cache are very different things.  They are based on different ideas about stability, speed, duplication, connections and data integrity. <br><br><h4>  Transformation </h4><br>  As soon as we realized that we had randomly selected a cache for the database, what could we do? <br><br>  Well, that's a million dollar question.  But I have already answered the billion dollar question.  In this post, I talked about how we used MongoDB compared to what it was designed for.  I talked about this as if all the information was obvious, and the Dispora team was simply not able to do the research before choosing. <br><br>  <i>But it was not at all obvious.</i>  Documentation MongoDB says that is good, and does not say that is not good. This is natural.  Everybody does it.  But as a result, it took about 6 months and a lot of user complaints and a lot of investigations to find out that we used MongoDB for other purposes. <br><br>  There was nothing to do, other than extracting data from MongoDB and putting it into a relational database management system, solving data inconsistencies on the go.  The process of extracting data from MongoDB and placing it in MySQL was straightforward.  More details in the <a href="https://speakerdeck.com/sarahmei/switching-data-stores-a-postmodern-comedy">report on All Your Base Conf</a> . <br><br><h4>  Damage </h4><br>  We had data for 8 months of work, which turned into 1.2 million rows in MySQL.  We spent eight weeks developing the code for the migration and when the process started the main site went downstairs for 2 hours.  This was a more than acceptable result for a project in the pre-alpha stage.  We could reduce the downtime, but we laid 8 hours, so two hours looked fantastic. <br><img src="https://habrastorage.org/getpro/habr/post_images/8ef/805/865/8ef8058654c7df279fae0d8550b24e17.jpg" alt="image" width="512"><br>  <i>(NOT BAD)</i> <br><br><h4>  Epilogue </h4><br>  Remember the app for the television series?  It was the perfect use for MongoDB.  Each series was one self-contained document.  No references to other documents, no duplication, and no way to make the data inconsistent. <br><br>  After three months in development, everything worked fine with MongoDB.  But once on Monday at the meeting, the client said that one of the investors wanted a new feature.  He wants to be able to click on the name of the actor and watch his career in the television series.  He wants a list of all the episodes in all serials in chronological order, in which this actor starred. <br><br>  We stored each series as a document in MongoDB containing all the data, including the actors.  If this actor met in two episodes, even in one series, the information was stored in two places.  We could not even find out that this is the same actor, except by comparing names.  To implement the features, it was necessary to bypass all documents, find and deduplicate all instances of actors.  Wow ... You had to do this at least once, and then maintain the external index of all the actors, who will experience the same problems with consistency, like any other cache. <br><br><h4>  See what happens? </h4><br>  The client expects that the feature will be trivial.  If the data were in a relational repository, then this would be true.  First of all, we tried to convince the manager that this feature is not needed.  But the manager did not sag and we came up with several cheaper alternatives, such as links to IMDB by the name of the actor.  But the company made money on advertising, so they needed to prevent the client from leaving the site. <br><br>  This feature pushed the project to switch to PosgreSQL.  After talking with the customer, it turned out that the business sees a lot of value in linking the episodes to each other.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">They envisioned watching TV shows filmed by one director and episodes released in one week and much more. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">It was ultimately a communication problem, not a technical problem. </font><font style="vertical-align: inherit;">If these conversations are what happened before, if we took the time to really understand how the client wants to see the data and what he wants to do with it, then we probably would have switched PostgreSQL earlier when there was less data and it was easier.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Study, study and study again </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">From the experience I learned something: the perfect MongoDB case is even narrower than our serial data. </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only thing</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> that is conveniently stored in MongoDB is arbitrary JSON fragments. ‚Äú </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Custom</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ‚Äù in this context means that you absolutely </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">don't care</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> what's inside JSON. You do not even look there. there is no schema, not even an implicit schema, as was the case with our serial data. Each document is a set of bytes, and you do not make any assumptions about what is inside. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">At RubyConf, I ran into </font></font><a href="https://twitter.com/conradirwin"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Conrad Irwin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , who proposed this script. He saved arbitrary data from clients in the form of JSON. It is reasonable. CAP theorem does not matter when your data does not make sense. But in any interesting application, the data makes sense.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">I heard from many people that MongoDB is used as a replacement for PostgreSQL or MySQL. There are no circumstances under which this might be a good idea. </font><font style="vertical-align: inherit;">The flexibility of the scheme (in fact, the absence of a scheme - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">note lane</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) looks like a good idea, but in fact it is useful only when your data does not carry value. </font><font style="vertical-align: inherit;">If you have an implicit scheme, that is, you expect some structure in JSON, then MongoDB is the wrong choice. </font><font style="vertical-align: inherit;">I suggest looking at hstore in PostgreSQL (anyway faster than MongoDB) and learning how to make schema changes. </font><font style="vertical-align: inherit;">They really aren't that complicated, even in large tables.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Find value </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When you choose a data warehouse, the most important thing is to understand where the value for the customer is in the data and connections. </font><font style="vertical-align: inherit;">If you still do not know, then you need to choose something that does not drive you into a corner. </font><font style="vertical-align: inherit;">Cramming arbitrary JSON data into a database looks like a flexible solution, but the real flexibility is simply to add business features. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Make valuable things simple.</font></font><br><br><h4>  the end </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Thank you for reading here. </font></font></div><p>Source: <a href="https://habr.com/ru/post/231213/">https://habr.com/ru/post/231213/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../231201/index.html">Modern Tornado Part 2: Blocking Operations</a></li>
<li><a href="../231203/index.html">We draw a ruble sign in the Android application</a></li>
<li><a href="../231207/index.html">How to send a message that is understandable after 10,000 years</a></li>
<li><a href="../231209/index.html">System / 360 - hardware</a></li>
<li><a href="../231211/index.html">This is Science: Putting triboelectricity at the service of humanity</a></li>
<li><a href="../231215/index.html">Dronie and Cyber-Hand from Navigator Campus on Seliger</a></li>
<li><a href="../231219/index.html">Installing OpenFOAM on Ubuntu 14.04</a></li>
<li><a href="../231225/index.html">How to become an independent game developer</a></li>
<li><a href="../231227/index.html">Attribute deprecated in C ++ 14</a></li>
<li><a href="../231229/index.html">Using the principles of psychology to increase the conversion of sites. Part 5: Face Effect</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>