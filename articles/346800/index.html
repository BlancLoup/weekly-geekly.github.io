<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Basic API sets for implementing transparent proxying services</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most important parts of any corporate data protection system against leaks is the outgoing network traffic analysis module. Most often, the...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Basic API sets for implementing transparent proxying services</h1><div class="post__text post__text-html js-mediator-article">  One of the most important parts of any corporate data protection system against leaks is the outgoing network traffic analysis module.  Most often, the module is implemented as a service of transparent proxying, i.e.  a service that ‚Äútransparently‚Äù stands between the network application and the target server, and whose task is to intercept the flow of data between the application and the server. <br><br><img src="https://habrastorage.org/webt/_r/8l/6o/_r8l6osttaozggbnoge66b4hixu.png" alt="image"><br><br>  The article is devoted to the service of transparent proxying and how to implement traffic proxying.  It will not consider the issues of redirecting network traffic to the transparent proxying service, although this is also quite an interesting technical problem. <br><a name="habracut"></a><br>  Since the target applications can work on any, including non-standard, ports, all traffic needs to be processed.  The number of connections that are created during the work of "high-performance" network applications, exceeds 100 per second.  In this regard, the transparent proxying service should be as efficient as possible.  The general algorithm of actions of the service is as follows: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  Accept redirected connection. </li><li>  Get information about where you need to establish a "proxied" connection. </li><li>  Create a connection to the server (from step 2). </li><li>  Get data from the application and transfer it to the server. </li><li>  Get data from the server and transfer it to the application. </li><li>  Repeat steps 4 and 5 until either the server or the application closes the connection. </li><li>  Close the "pair" connection. </li></ol><br>  What APIs in the Microsoft Windows operating system can help solve this problem? <br><br><h4>  Sockets + WSA events </h4><br>  To organize proxying using this API, do the following: <br><br>  1. Create a socket <br><br><pre><code class="cpp hljs">SOCKET socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</code> </pre> <br>  2. Create an event that will monitor the change of the socket state <br><br><pre> <code class="cpp hljs">WSAEVENT sock_event = WSACreateEvent();</code> </pre> <br>  3. Associate the socket with the event, indicating, at the same time, what changes in the state of the socket we are interested in.  When transmitting traffic, we are interested in the completion of data transmission and the completion of data reception.  In addition, the moment of closing the connection is interesting, as this is a sign that it is time to finish processing traffic <br><br><pre> <code class="cpp hljs">WSAEventSelect(socket, sock_event, FD_READ|FD_WRITE|FD_CLOSE);</code> </pre> <br>  4. Initiate data reading from the socket <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = recv(socket, buf, buf_len, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>  5. Arrange for waiting for socket status changes.  Most often this is done as follows: a separate thread is started, and the function of waiting for a state change is called in it <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> res = WSAWaitForMultipleEvents(<span class="hljs-number"><span class="hljs-number">1</span></span>, sock_event, FALSE, INFINITE, FALSE);</code> </pre> <br>  The event associated with the socket will come to a signal state if data is received, or data is sent, or the connection is closed.  I / O errors also cause the event to be signaled. <br><br>  6. Check how exactly the state of the socket has changed, and make the appropriate processing <br><br><pre> <code class="cpp hljs">WSANETWORKEVENTS wsaNetworkEvents; WSAEnumNetworkEvents(socket, sock_event, &amp;wsaNetworkEvents); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( wsaNetworkEvents.lNetworkEvents &amp; FD_READ) ) { <span class="hljs-comment"><span class="hljs-comment">// ,       ¬´¬ª ProcessReceivedData(); } if( ( wsaNetworkEvents.lNetworkEvents &amp; FD_WRITE) ) { // ,      ¬´¬ª IssuerRead(); } if( ( wsaNetworkEvents.lNetworkEvents &amp; FD_CLOSE) ) { // , //   (   ,     ) ClosePeer(); }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/cp/m0/0p/cpm00pwa4xhevydvwn_ztdasvom.png" alt="image"><br><br><h4>  Advantages and disadvantages </h4><br>  What pitfalls await us when using this API: <br>  Programs can install dozens of connections at the same time, and the transparent proxying service should create twice as many sockets, i.e.  The proxy service creates two sockets for one connection of the program.  The WSAWaitForMultipleEvents function used has a limitation - it cannot accept more than 64 objects at a time.  Therefore, you need to run several wait threads and somehow distribute the sockets between them. <br><br>  Long-term processing of data in one of the wait threads may cause events from other sockets that are expected in this thread to not be processed.  To solve this problem, you need to run separate data processing threads and monitor their loading. <br>  Retrieving data from a socket requires calling three functions: recv, WSAWaitForMultipleEvents, and WSAEnumNetworkEvents.  Each of these functions potentially ‚Äúgoes into kernel mode,‚Äù which is quite a costly operation. <br><br>  If the pool of threads waiting for events of sockets and data processing is implemented inefficiently, an increase in the amount of computing resources (processor cores) will not lead to an increase in the speed of proxying connections, and for terminal servers this possibility is very important. <br><br>  Thus, this API is not very suitable for implementing an efficient transparent proxying method.  Consider another set of APIs. <br><br><h4>  Overlapped I / O + Thread Pool + Completion Ports </h4><br>  1. Create a socket.  But now to perform asynchronous operations, we need some contextual structure that describes an asynchronous operation.  A feature of this structure is that its first element is the standard data type OVERLAPPED.  This procedure will allow for the correct operation of the callback functions. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AsyncOperationContext</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">//,       OVERLAPPED ov; //   ‚Äì    // ) CALLBACK_FUNC pfFunc; //   PVOID pContex; } SOCKET sock = ::WSASocket( AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);</span></span></code> </pre> <br>  2. We bind the socket to the input / output completion port, events from which are processed within the system thread pool.  Since we will use a pointer to an OVERLAPPED structure to initiate an asynchronous operation, no one is stopping us from allocating more memory for our needs with this structure.  And we will get the address of this particular structure in the callback of the I / O completion port. <br><br><pre> <code class="cpp hljs">BindIoCompletionCallback(sock, IoSockCompletionRoutine, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-function"><span class="hljs-function">VOID CALLBACK </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IoCompletionRoutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( DWORD error, DWORD bytes, LPOVERLAPPED ov)</span></span></span><span class="hljs-function"> </span></span>{ AsyncOperationContext* actx = <span class="hljs-keyword"><span class="hljs-keyword">reinterpret_cast</span></span>&lt; AsyncOperationContext*&gt;(ov); actx-&gt;pfFunc(actx-&gt;pContext,error,bytes); }</code> </pre> <br>  3. Initiate an asynchronous read operation from the socket.  It should be remembered that if the operation was completed immediately, i.e.  either without error, or with an error other than ERROR_IO_PENDING, then you need to complete the processing in the thread that initiated the reading.  The I / O completion port callback function will not be called in this case.  The context of an asynchronous operation should be stored in a structure that describes the intercepted connection, since the lifetime of this structure coincides with the lifetime of the connection context.  Moreover, this structure can be reused for reading from a socket. <br><br><pre> <code class="cpp hljs">AsyncOperationContext receive_ov; <span class="hljs-comment"><span class="hljs-comment">//    memset(&amp;receive_ov, 0, sizeof(OVERLAPPED)); //        receive_ov.pfFunc = ReceiveDoneCallback; receive_ov.pContext = this; //     BOOL res = ReadFile((HANDLE)sock, buf, buf_len, &amp;received, (LPOVERLAPPED)&amp;receive_ov); if(res) { //  . //  /    if(received &gt; 0) { //  ,   ProcessReceivedData(); //    InitiateRead(); } else { //  . ,    //  . ProcessConnectionClose(); } } else { DWORD error = GetLastError(); if(error != ERROR_IO_PENDING) { //  .   ProcessConnectionClose(); } }</span></span></code> </pre><br>  The implementation of ReceiveDoneCallback is similar to the synchronous case. <br><br>  4. We process the received data.  Since we are already using the system thread pool for I / O processing, we need to use the system thread pool for data processing.  It should be remembered: the data must be processed and transmitted to our paired socket in the same sequence in which they were received.  Therefore, a queue of processed and transmitted data must be organized.  The system pool function should work with the queue.  It is important that the queue handles only one thread of the pool.  You can organize a queue in any way. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//         AddReceivedDataToQueue(buf, buf_len); //,       // ,    If(!IsQueueProcessingAndMark()) { QueueUserWorkItem(DataProcessingRoutine, this, 0); } DWORD WINAPI WorkRoutine(LPVOID param) { DataItem* dataItem; while( dataItem = GetQueueProcessingItem() ) { ProcessDataItem(dataItem); //   InitiateWrite(); } MarkQueueProcessing(FALSE); }</span></span></code> </pre> <br>  Access to the queue of processed items, as well as access to information on the status of processing must be synchronized.  Asynchronous data transfer to our ‚Äúpair‚Äù is organized in a similar way, but instead of ReadFile, the WriteFile function is used. <br><br><img src="https://habrastorage.org/webt/nx/ko/-q/nxko-qbu5mcr_svxh4yqy2vs71i.png" alt="image"><br><br><h4>  Advantages and disadvantages </h4><br>  What we got when we started using this API set: <br><br><ul><li>  We no longer need our own implementation of the thread pool ‚Äî the thread pool is used, which is implemented by the operating system. </li><li>  There are no restrictions that are associated with the number of treated compounds. </li><li>  The data that is received on the socket is immediately passed to the callback function.  Accordingly, you just need to initiate the operation and process the result.  No additional API calls are required. </li></ul><br>  This set of API allows you to increase the number of processed compounds by increasing the number of process cores, i.e.  This scheme will work on the terminal server. <br><br>  But this API still has flaws: <br><br><ol><li>  The API does not allow to manage the pool, i.e.  we can not limit the number of threads in the pool. </li><li>  We cannot "guaranteed" separate the threads that deal with I / O processing and the threads that do business with the intercepted data. </li><li>  It is necessary to organize in a special way the waiting for "stuck" I / O operations. </li></ol><br>  These problems can be solved using a different set of APIs. <br><br><h4>  Using the Vista Thread Pool API </h4><br>  This set of functions allows you to create separate thread pools and configure each of them.  Consider the steps you need to take to organize proxying network connections using this API. <br><br>  1. Create and configure the environment in which the thread pool will work.  This environment allows you to correctly wait for the completion of all tasks that were transferred to the specified pool <br><br><pre> <code class="cpp hljs">PTP_CALLBACK_ENVIRON io_pool_env; InitializeThreadpoolEnvironment(io_pool_env); PTP_CLEANUP_GROUP io_pool_cleanup = CreateThreadpoolCleanupGroup(); SetThreadpoolCallbackCleanupGroup(io_pool_env,io_pool_cleanup,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br>  2. Create and configure thread pool <br><br><pre> <code class="cpp hljs">PTP_POOL io_pool = CreateThreadpool(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); SetThreadpoolThreadMaximum(io_pool,<span class="hljs-number"><span class="hljs-number">10</span></span>); SetThreadpoolMinimum(io_pool,<span class="hljs-number"><span class="hljs-number">2</span></span>); SetThreadpoolCallbackPool(&amp;io_pool_env, io_pool);</code> </pre> <br>  Now we have a dedicated thread pool, in which there can not be less than two and more than ten threads.  In addition, we can use the io_pool_cleanup variable to wait for the completion of all operations that were initiated in this pool.  Similarly, you can configure a thread pool for processing captured data (processing_pool). <br><br>  3. Create a socket and structures that are required to initiate asynchronous operations <br><br><pre> <code class="cpp hljs">SOCKET sock = WSASocket( AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, WSA_FLAG_OVERLAPPED); PTP_IO io_item = CreateThreadpoolIo((HANDLE)sock, IoDoneCallback, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, io_pool); PTP_WORK process_item = CreateThreadpoolWork(WorkRoutine,<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, processing_env);</code> </pre> <br>  The implementation of the IoDoneCallback (ReceiveDoneCallback) and WorkRoutine functions is similar to the implementations given for the previous API set.  Those.  You can reuse the already existing business logic for processing the intercepted data. <br><br>  4. Initiate an asynchronous data read operation from the socket <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//,    /     StartThreadpoolIo(io_item) //  /. BOOL res = ReadFile((HANDLE)sock, buf, buf_len, &amp;received, &amp;ov);</span></span></code> </pre> <br>  Processing the results of the operation is similar to that described for the version with the I / O completion port, but with one feature.  If we do not want to receive a callback in the pool for the case of a synchronous completion of the operation (and it will be executed ‚Äúby default‚Äù), we need to mark the socket in a special way after its creation: <br><br><pre> <code class="cpp hljs">SetFileCompletionNotificationModes((HANDLE), FILE_SKIP_COMPLETION_PORT_ON_SUCCESS)</code> </pre> <br>  In addition, it is important to remember that each I / O operation initiated must either be completed or canceled, i.e.  if the operation was completed synchronously, with or without an error, you need to call: <br><br><pre> <code class="cpp hljs">CancelThreadpoolIo(io_item);</code> </pre> <br>  5. We initiate the processing of the received data.  The processing function is similar to the QueueUserWorkItem variant. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//        AddReceivedDataToQueue(buf, buf_len); //,       // ,    If(!IsQueueProcessingAndMark()) { SubmitThreadpoolWork(processing_item); }</span></span></code> </pre> <br><img src="https://habrastorage.org/webt/oi/bu/bq/oibubq52hfge-kdfxg8rvw52uq4.png" alt="image"><br><br><h4>  Advantages and disadvantages </h4><br>  The described API set is good for everyone, but it exists only in versions of the operating system starting from Windows Vista.  For Windows XP and Windows Server 2003, you need to use the I / O completion ports and the old system pool.  However, the interface of both options allows you to handle the intercepted data in the same way, so the codebase is the same, although it is built for different operating systems. <br><br><h4>  findings </h4><br>  Any high-quality software product should use the most efficient ways to solve technical problems from those provided by the operating system.  The service of transparent proxying of our product has come a long way of development, and at the moment it is implemented, as it seems to me, as efficiently as possible.  Hopefully, the conclusions from the path we have passed will help others to more quickly understand the technologies and make the right decision. </div><p>Source: <a href="https://habr.com/ru/post/346800/">https://habr.com/ru/post/346800/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346790/index.html">Addition to the article "Subtleties of resume in German IT-companies"</a></li>
<li><a href="../346792/index.html">Implementation of an asynchronous secure communication system based on TCP sockets and central OpenVPN server</a></li>
<li><a href="../346794/index.html">How to make friends team admins with development teams?</a></li>
<li><a href="../346796/index.html">ICO analysis: technical approach. Part I - general conclusions</a></li>
<li><a href="../346798/index.html">X.509 Certificate Spurs</a></li>
<li><a href="../346802/index.html">Using Docker CE (Community Edition) with Kubernetes</a></li>
<li><a href="../346804/index.html">Reverse Engineering iPhone 2G</a></li>
<li><a href="../346806/index.html">Who is a Data Scientist - the eyes of the employer</a></li>
<li><a href="../346808/index.html">How to kill a techie in tmlide</a></li>
<li><a href="../346812/index.html">Frequency method of identification of linear dynamic systems: theory and practice</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>