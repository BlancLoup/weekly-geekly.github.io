<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>SObjectizer: from simple to complex. Part I</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the first article, we talked about what a SObjectizer is and why it turned out exactly like this. In the second, let's try to show what a more or l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>SObjectizer: from simple to complex. Part I</h1><div class="post__text post__text-html js-mediator-article">  <a href="https://habrahabr.ru/post/304386/">In the first article,</a> we talked about what a SObjectizer is and why it turned out exactly like this.  In the second, let's try to show what a more or less real code on SObjectizer can look like.  With a demonstration of the direction in which this code usually evolves.  For initially, when the developer has the opportunity to work with the Actor Model, he begins to abuse this opportunity, creating problems both for himself and those who will exploit the software product written in the ‚Äúactor for every sneeze‚Äù style.  Only after some time and a certain amount of stuffed cones comes an understanding that the beauty of the model of actors is not at all in the ability to create them by tens of thousands or even just thousands.  But let's go consistently, not ahead of the event. <br><a name="habracut"></a><br>  To demonstrate, we will invent this abstract task: there is a file name with an email (roughly speaking, this file saved everything that came via the POP3 protocol, including headers, letter body, attachments, etc.).  It is necessary to give the result of assessing the suspicion of the contents of this file: whether the letter looks safe or suspicious, or when trying to evaluate its contents, some kind of problem arose and it is impossible to issue a current assessment.  The task is abstract, any coincidences with something similar from real life are an unintended coincidence. <br><br>  Naturally, we will have more than one of these names with email files.  There will be a stream of these names that you need to deal with.  It is desirable, using the capabilities of modern multi-core iron, i.e., starting processing of several emails in parallel. <br><br>  We schematically show how this problem can be solved on the SObjectizer head-on.  After that we indicate the problems of the chosen approach, we will do the next iteration, etc.  In order, as a result of examples, to lead the reader to the understanding of the ‚Äúconvenient use of the model of actors in C ++‚Äù that we have developed over ten years of working with SObjectizer in real projects. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      To begin with, we will decide how requests are issued for checking files with emails and how the results of checks are returned.  We use for this purpose simple messages: <br><br><pre><code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/      so_5  std. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     using-   , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,    . using namespace so_5; using namespace std; using namespace chrono_literals; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       email-. struct check_request { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . string email_file_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     . mbox_t reply_to_; }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,      . enum class check_status { safe, suspicious, dangerous, check_failure, check_timedout }; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        email. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ,     . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   . struct check_result { string email_file_; check_status status_; };</span></span></code> </pre> <br>  It turns out that when we need to check email, we send the message check_request to a certain <abbr title="Message Box. In SObjectizer messages are sent to mailboxes. Agents must subscribe to the appropriate mailboxes in order to receive messages from the subscribed mailboxes.">mbox</abbr> .  In this message, the file name and the return address are sent to where the test result should be sent.  Accordingly, the next step we need to determine where exactly the check_request messages will be sent. <br><br>  You can, of course, create a single agent that receives all the check_request messages and processes them independently.  But such an agent would very quickly become a bottleneck.  Therefore, we will make it so that we have one agent-manager, who receives the check_request messages and creates an analyzer agent for each received message.  It is the analyzer-agent that will be engaged in checking email, and the agent-manager will act as a factory of analyzer-agents. <br><br>  Immediately, you can write the simplest version of the agent manager: <br><pre> <code class="hljs ruby">/<span class="hljs-regexp"><span class="hljs-regexp">/ ,       email_analyzer. class analyzer_manager final : public agent_t { public : analyzer_manager( context_t ctx ) : agent_t( ctx ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    final,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   .   final  ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     so_define_agent(),     /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . so_subscribe_self() /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ,    , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  . .event( &amp;analyzer_manager::on_new_check_request ); } private : void on_new_check_request( const check_request &amp; msg ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/        -. /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ .. SObjectizer Environment ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ -     ,  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      -. introduce_child_coop( *this, [&amp;]( coop_t &amp; coop ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/       . coop.make_agent&lt; email_analyzer &gt;( msg.email_file_, msg.reply_to_ ); } ); } };</span></span></code> </pre><br>  To process emails, we will need to register in the SObjectizer Environment an instance of the agent type analyzer_manager and somehow make its personal mbox (the so-called direct_mbox) accessible to all.  The one who needs to check the email, sends the check_request message to this mbox, the message reaches the analyzer_manager, the email_analyzer agent will be created, and then everything as intended ... <br><br>  Now you need to implement the email_analyzer agent, which will analyze emails.  The simplest thing that comes to mind is an agent who performs all operations himself: i.e.  loads content from a file, parses this content into its constituent parts (headers, body, attachments), analyzes all this and produces a conclusion. <br><br>  In fact, the email_analyzer agent will need to define only its own implementation of the so_evt_start () method, which is automatically called for each agent after the agent successfully registers within the SObjectizer Environment.  Therefore, the email_analyzer agent will look very simple: <br><pre> <code class="hljs lua">//      email-. //       , //        so_evt_start. class email_analyzer : public agent_t { public : email_analyzer( context_t ctx, //    email  . <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> email_file, //     . mbox_t reply_to ) : agent_t(ctx), email_file_(move(email_file)), reply_to_(move(reply_to)) {} virtual void so_evt_start() override { try { //     . auto raw_data = load_email_from_file( email_file_ ); auto parsed_data = parse_email( raw_data ); auto <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = check_headers( parsed_data-&gt;headers() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( check_status::safe == <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = check_body( parsed_data-&gt;body() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( check_status::safe == <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> ) <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> = check_attachments( parsed_data-&gt;attachments() ); send&lt; check_result &gt;( reply_to_, email_file_, <span class="hljs-built_in"><span class="hljs-built_in">status</span></span> ); } catch( const exception &amp; ) { //   -      //    email-   . send&lt; check_result &gt;( reply_to_, email_file_, check_status::check_failure ); } //    ,   , //   . so_deregister_agent_coop_normally(); } private : const <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> email_file_; const mbox_t reply_to_; };</code> </pre><br>  So, we have very trivial implementations of the analyzer_manager and email_analyzer agents.  Which, unfortunately, have several serious problems. <br><br>  The first problem is that email_analyzer agents will not work in parallel.  The fact is that when they are created, the <abbr title="In SObjectizer, the worker threads on which agents process their messages belong to special entities ‚Äî dispatchers. Dispatchers are responsible for creating and deleting work threads, for maintaining message queues, for calling the appropriate message handler for the receiving agent on the corresponding work thread. To do this, the agent must be tied to one or another dispatcher.">dispatcher</abbr> to which they should be attached is not specified.  Therefore, these agents are automatically linked to the default dispatcher of the SObjectizer Environment, and this default dispatcher is single-threaded: i.e.  he has only one working thread on which the events associated with the dispatcher agents are sequentially triggered. <br><br>  Therefore, if we want email_analyzer agents to work independently of each other, we need to explicitly bind them to the appropriate type of dispatcher.  In this case, a dispatcher with a pool of worker threads is well suited.  Accordingly, someone must create an instance of such a dispatcher and someone must attach email_analyzer-s to this instance.  Obviously, this someone is an analyzer_manager agent: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> analyzer_manager final : public agent_t { public : analyzer_manager( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> ) : agent_t( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> ) , analyzers_disp_( //  , ..     // ,      -. </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">disp</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_pool</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create_private_disp</span></span></span><span class="hljs-class">( // ,    </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">SObjectizer</span></span></span><span class="hljs-class"> </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Environment</span></span></span><span class="hljs-class"> //   .      //   . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_environment</span></span></span><span class="hljs-class">(), //       . //         //  , , thread::hardware_concurrency()  //   . 16 ) ) { so_subscribe_self() .event( &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">analyzer_manager</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on_new_check_request</span></span></span><span class="hljs-class"> ); } private : disp::thread_pool::private_dispatcher_handle_t analyzers_disp_; void on_new_check_request( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check_request</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class"> ) { introduce_child_coop( *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">, //          //      (    //   ). analyzers_disp_-&gt;binder( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">disp</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_pool</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">bind_params_t</span></span></span><span class="hljs-class">() ), [&amp;]( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">coop_t</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">coop</span></span></span><span class="hljs-class"> ) { //       . coop.make_agent&lt; email_analyzer &gt;( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">email_file_</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">reply_to_</span></span></span><span class="hljs-class"> ); } ); } };</span></span></code> </pre><br>  Such a simple modification of analyzer_manager allowed us to get rid of the first problem.  But there is still the second: the uncontrolled creation of an unlimited number of agents email_analyzer. <br><br>  The current implementation of analyzer_manager works on the principle: received a check_email message with the name of the file to check, created the email_analyzer agent and forgot about everything.  But, obviously, this option is not suitable for more or less high loads.  If you immediately create 100,500 email_analyzer agents that will work on a pool of N workflows, then there will be nothing good except extra memory consumption.  It is better to immediately limit the number of concurrent agents and create new ones after the previous ones are completed.  Plus, keep a queue of tasks for processing, from which elements for new agents will be taken. <br><br>  Therefore, once again, we modify our analyzer_manager: add a queue of requests and a limit on the number of concurrent agents to it. <br><pre> <code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">analyzer_manager</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">agent_t</span></span></span><span class="hljs-class"> { //      ,     //     . </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">try_create_next_analyzer</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">public</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">signal_t</span></span></span><span class="hljs-class"> {};</span></span> /<span class="hljs-regexp"><span class="hljs-regexp">/        ,   /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . struct analyzer_finished : public signal_t {}; public : analyzer_manager( context_t ctx ) : agent_t( ctx ) , analyzers_disp_( disp::thread_pool::create_private_disp( so_environment(), 16 ) ) { so_subscribe_self() .event( &amp;analyzer_manager::on_new_check_request ) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     -   , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -  . .event&lt; try_create_next_analyzer &gt;( &amp;analyzer_manager::on_create_new_analyzer ) .event&lt; analyzer_finished &gt;( &amp;analyzer_manager::on_analyzer_finished ); } private : const size_t max_parallel_analyzers_{ 16 }; size_t active_analyzers_{ 0 }; disp::thread_pool::private_dispatcher_handle_t analyzers_disp_; list&lt; check_request &gt; pending_requests_; void on_new_check_request( const check_request &amp; msg ) { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     :    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,      /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -     . pending_requests_.push_back( msg ); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . send&lt; try_create_next_analyzer &gt;( *this ); } void on_create_new_analyzer() { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/          /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    . if( active_analyzers_ &gt;= max_parallel_analyzers_ ) return; lauch_new_analyzer(); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,    . if( !pending_requests_.empty() &amp;&amp; active_analyzers_ &lt; max_parallel_analyzers_ ) send&lt; try_create_next_analyzer &gt;( *this ); } void on_analyzer_finished() { /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,    . --active_analyzers_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  ,    ,  . if( !pending_requests_.empty() ) lauch_new_analyzer(); } void lauch_new_analyzer() { introduce_child_coop( *this, analyzers_disp_-&gt;binder( disp::thread_pool::bind_params_t() ), [this]( coop_t &amp; coop ) { coop.make_agent&lt; email_analyzer &gt;( pending_requests_.front().email_file_, pending_requests_.front().reply_to_ ); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/     ,    /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  .      , /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      analyzer_finished. coop.add_dereg_notificator( /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    ,      . [this]( environment_t &amp;, const string &amp;, const coop_dereg_reason_t &amp; ) { send&lt; analyzer_finished &gt;( *this ); } ); } ); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   ,    . ++active_analyzers_; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/         . pending_requests_.pop_front(); } };</span></span></code> </pre><br>  In principle, we got a more or less normal solution that could be considered satisfactory.  If it were not for one "but." <br><br>  This "but" is that although we have the opportunity to run several analyzer agents in parallel work, parallelization will turn out so-so.  If, say, five agents start at the same time, then all five will immediately begin I / O operations and while these operations will be performed, no one can do anything else.  Then I / O operations will end and all five agents will begin to analyze the data read from the disk.  This will take the processor.  This could be used to start I / O operations for the next few analyzer agents.  But we cannot do this while the first five agents are busy with their work. <br><br>  This problem can be solved by removing the operation from email_analyzer I / O.  Instead of loading the data from the file itself, the email_analyzer agent can delegate this task to a special IO agent.  Those.  The email_analyzer agent starts, sends a message to an IO agent, and then receives the result of an I / O operation in the form of a response message.  Thereby enabling another email_analyzer to do its part (send a message to an IO agent or process a response message from an IO agent).  But the conversation about how it will look and how good this decision will be will be continued in the next article. <br><br>  In the meantime, you can show one important opportunity that we received in our current implementation of the agent manager with its waiting list: we can easily control the waiting time for requests in this list. <br><br>  Indeed, the operation of checking the letter will surely have some reasonable limits on the waiting time for an answer.  And if during this time it was not possible to assess security, then, most likely, it will not be necessary to try to do it.  Based on this, we can easily modify the agent manager so that he throws out from the waiting list those requests that have spent waiting too long (for example, more than 10 seconds).  To do this, use a periodic message that will come to the manager twice a second.  Having received this message, the manager will run through the waiting list and drop those requests that have been waiting for more than 10 seconds.  The approach, of course, is not very accurate, but it is very simple and reliable: <br><pre> <code class="hljs haskell"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> analyzer_manager final : public agent_t { struct try_create_next_analyzer : public signal_t {}; struct analyzer_finished : public signal_t {}; //          //    . struct check_lifetime : public signal_t {}; //  ,        //   .        //      . using clock = chrono::steady_clock; struct pending_request { clock::time_point stored_at_; check_request request_; }; public : analyzer_manager( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">context_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> ) : agent_t( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ctx</span></span></span><span class="hljs-class"> ) , analyzers_disp_( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">disp</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">thread_pool</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">create_private_disp</span></span></span><span class="hljs-class">( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so_environment</span></span></span><span class="hljs-class">(), 16 ) ) { so_subscribe_self() .event( &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">analyzer_manager</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on_new_check_request</span></span></span><span class="hljs-class"> ) .event&lt; try_create_next_analyzer &gt;( &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">analyzer_manager</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on_create_new_analyzer</span></span></span><span class="hljs-class"> ) .event&lt; analyzer_finished &gt;( &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">analyzer_manager</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on_analyzer_finished</span></span></span><span class="hljs-class"> ) //        -. .event&lt; check_lifetime &gt;( &amp;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">analyzer_manager</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">on_check_lifetime</span></span></span><span class="hljs-class"> ); } //     ,    . virtual void so_evt_start() override { //       timer_id, //     . check_lifetime_timer_ = send_periodic&lt; check_lifetime &gt;( *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class">, 500</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ms</span></span></span><span class="hljs-class">, 500</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ms</span></span></span><span class="hljs-class"> ); } private : const size_t max_parallel_analyzers_{ 16 }; size_t active_analyzers_{ 0 }; disp::thread_pool::private_dispatcher_handle_t analyzers_disp_; //        . const chrono::seconds max_lifetime_{ 10 }; //      check_lifetime. timer_id_t check_lifetime_timer_; list&lt; pending_request &gt; pending_requests_; void on_new_check_request( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">const</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">check_request</span></span></span><span class="hljs-class"> &amp; </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg</span></span></span><span class="hljs-class"> ) { //     . pending_requests_.push_back( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pending_request</span></span></span><span class="hljs-class">{ </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">clock</span></span></span><span class="hljs-class">::</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">now</span></span></span><span class="hljs-class">(), msg } ); send&lt; try_create_next_analyzer &gt;( *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> ); } void on_create_new_analyzer() { if( </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">active_analyzers_</span></span></span><span class="hljs-class"> &gt;= </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">max_parallel_analyzers_</span></span></span><span class="hljs-class"> ) return; lauch_new_analyzer(); if( !</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">pending_requests_</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">empty</span></span></span><span class="hljs-class">() &amp;&amp; active_analyzers_ &lt; max_parallel_analyzers_ ) send&lt; try_create_next_analyzer &gt;( *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">this</span></span></span><span class="hljs-class"> ); } void on_analyzer_finished() { </span><span class="hljs-comment"><span class="hljs-class"><span class="hljs-comment">--active_analyzers_; if( !pending_requests_.empty() ) lauch_new_analyzer(); } void on_check_lifetime() { //         ,  //  . while( !pending_requests_.empty() &amp;&amp; pending_requests_.front().stored_at_ + max_lifetime_ &lt; clock::now() ) { //     email- . send&lt; check_result &gt;( pending_requests_.front().request_.reply_to_, pending_requests_.front().request_.email_file_, check_status::check_timedout ); pending_requests_.pop_front(); } } void lauch_new_analyzer() { introduce_child_coop( *this, analyzers_disp_-&gt;binder( disp::thread_pool::bind_params_t() ), [this]( coop_t &amp; coop ) { coop.make_agent&lt; email_analyzer &gt;( pending_requests_.front().request_.email_file_, pending_requests_.front().request_.reply_to_ ); coop.add_dereg_notificator( [this]( environment_t &amp;, const string &amp;, const coop_dereg_reason_t &amp; ) { send&lt; analyzer_finished &gt;( *this ); } ); } ); ++active_analyzers_; pending_requests_.pop_front(); } };</span></span></span></span></code> </pre><br>  Perhaps, at this point, you can stop in order to preserve a reasonable amount of article.  In subsequent articles, we will continue to consider this example and describe more complex implementations of agents, demonstrating some specific features of SObjectizer. <br><br>  In the meantime, it can be noted that in the examples shown, we have already come up against one of the most important problems faced by a developer using Actorl Model: overload protection. <br><br>  This problem occurs, for example, when there are too many agents on the system so that their events can be managed normally.  So, if we allow email_analyzer agents to be created without limiting their number, then at one fine moment we may find ourselves in a situation where several thousand such agents wait for their turn to handle the event and wait a very long time (the bill can go for minutes and even tens of minutes per most pathological cases).  In this article, we have shown one of the most effective ways to solve this manifestation of the overload problem: limiting the number of agents and creating new agents only as suitable opportunities appear for this (as old agents are destroyed). <br><br>  There are other problems with overload.  For example, the occurrence of such a number of messages that the application does not have time to process in a reasonable time.  This is also a very unpleasant problem and SObjectizer provides some tools to deal with it.  But we will touch on this issue in more detail in one of the following articles. <br><br>  In addition to the problem of overloads, there is one more problem inherent in systems built on actors / agents: the complexity of the visibility of what is happening in the application.  This is when there are 100,500 agents in the application, each of which, it seems, works correctly, but it‚Äôs not easy to understand whether the entire application is working properly.  We will also touch upon this question, but in subsequent articles. <br><br>  In the meantime, we hope that the examples and arguments given in this article have been understood.  Well, if something remains unclear, then we will be happy to answer questions in the comments. <br><br>  Source codes for the examples shown in the article can be found <a href="https://bitbucket.org/sobjectizerteam/habrhabr_article_2">in this repository</a> . </div><p>Source: <a href="https://habr.com/ru/post/306858/">https://habr.com/ru/post/306858/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306846/index.html">MVNO adult</a></li>
<li><a href="../306848/index.html">HOCON - configurable</a></li>
<li><a href="../306850/index.html">Review and programming for stationary Internet radio</a></li>
<li><a href="../306852/index.html">Summer internship at Positive Technologies: selection results and some statistics</a></li>
<li><a href="../306856/index.html">I / O tracer in the Linux kernel</a></li>
<li><a href="../306860/index.html">GitLab 8.10 released</a></li>
<li><a href="../306862/index.html">All kernel mode drivers for Windows 10 (1607) should now be signed by Microsoft</a></li>
<li><a href="../306864/index.html">A brief reminder of the demiurge</a></li>
<li><a href="../306866/index.html">Automate the installation of updates on the client machine with the elimination of erroneous updates</a></li>
<li><a href="../306868/index.html">Connecting Intel Internet of Things Gateways to IBM Watson</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>