<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Learn OpenGL. Lesson 4.8 - Advanced GLSL</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Advanced GLSL 
 This lesson will not show you new advanced tools that significantly improve the visual quality of the scene. In this lesson we will go...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Learn OpenGL. Lesson 4.8 - Advanced GLSL</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/web/c9e/9b2/a3b/c9e9b2a3baf749ab8e2b385c6d93d966.png" alt="Ogl3" align="left" width="300"><h1>  Advanced GLSL </h1><br>  This lesson will not show you new advanced tools that significantly improve the visual quality of the scene.  In this lesson we will go through more or less interesting aspects of GLSL and touch on some pretty good moves that can help you in your aspirations.  Basically, the <i>knowledge</i> and <i>tools</i> that <i>make your life easier</i> when creating OpenGL applications in conjunction with GLSL. <br><br>  We will discuss some interesting <b>built-in variables</b> , new approaches in the organization of input-output shaders, and a very useful tool - <b>the uniform-buffer object</b> . <br><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Content</b> <div class="spoiler_text">  Part 1. Start <br><br><ol><li>  <a href="https://habrahabr.ru/post/310790/">Opengl</a> </li><li>  <a href="https://habrahabr.ru/post/311198/">Creating a window</a> </li><li>  <a href="https://habrahabr.ru/post/311234/">Hello window</a> </li><li>  <a href="https://habrahabr.ru/post/311808/">Hello triangle</a> </li><li>  <a href="https://habrahabr.ru/post/313380/">Shaders</a> </li><li>  <a href="https://habrahabr.ru/post/315294/">Textures</a> </li><li>  <a href="https://habrahabr.ru/post/319144/">Transformations</a> </li><li>  <a href="https://habrahabr.ru/post/324968/">Coordinate systems</a> </li><li>  <a href="https://habrahabr.ru/post/327604/">Camera</a> </li></ol><br>  Part 2. Basic lighting 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <ol><li>  <a href="https://habrahabr.ru/post/329592/">Colors</a> </li><li>  <a href="https://habrahabr.ru/post/333932/">Lighting Basics</a> </li><li>  <a href="https://habrahabr.ru/post/336166/">Materials</a> </li><li>  <a href="https://habrahabr.ru/post/337550/">Texture Cards</a> </li><li>  <a href="https://habrahabr.ru/post/337642/">Sources of light</a> </li><li>  <a href="https://habrahabr.ru/post/338254/">Multiple light sources</a> </li></ol><br>  Part 3. Loading 3D Models <br><br><ol><li>  <a href="https://habrahabr.ru/post/338436/">Assimp library</a> </li><li>  <a href="https://habrahabr.ru/post/338436/">Mesh mesh class</a> </li><li>  <a href="https://habrahabr.ru/post/338998/">Model class</a> </li></ol><br>  Part 4. OpenGL advanced features <br><br><ol><li>  <a href="https://habrahabr.ru/post/342610/">Depth test</a> </li><li>  <a href="https://habrahabr.ru/post/344238/">Stencil test</a> </li><li>  <a href="https://habrahabr.ru/post/343096/">Mixing colors</a> </li><li>  <a href="https://habrahabr.ru/post/346964/">Face clipping</a> </li><li>  <a href="https://habrahabr.ru/post/347354/">Frame buffer</a> </li><li>  <a href="https://habrahabr.ru/post/347750/">Cubic cards</a> </li><li>  <a href="https://habrahabr.ru/post/350008/">Advanced data handling</a> </li></ol></div></div><br><h2>  GLSL embedded variables </h2><br>  Shaders are self-sufficient, if we need data from any other source, we will have to transfer them to the shader.  We learned how to do this with vertex attributes, uniforms, and samplers.  However, there are several other variables defined in GLSL with the prefix <i>gl_</i> , which gives us additional opportunities to read and / or write data.  We have already seen two representatives, the resulting vectors: the vertex shader <i>gl_Position</i> and the fragment shader <i>gl_FragCoord</i> . <br><br>  We will discuss some of the interesting input and output variables that are embedded in GLSL, and explain how they are useful.  I note that we will not discuss all the embedded variables in GLSL, so if you want to see all the embedded variables, you can do this on the corresponding OpenGL <a href="https://www.khronos.org/opengl/wiki/Built-in_Variable_(GLSL)">page</a> . <br><br><h2>  Vertex Shader Variables </h2><br>  We have already worked with the variable <i>gl_Position</i> , which is the output vector of the vertex shader, defining the position vector in the clipping space.  Setting the <i>gl_Position</i> value is a prerequisite for displaying something on the screen.  Nothing new for us. <br><br><h2>  gl_PointSize </h2><br>  One of the processed primitives that we can choose is <i>GL_POINTS</i> .  In this case, each vertex is a primitive and is treated as a point.  You can also set the size of the points to be processed using the <i>glPointSize</i> function.  But we can also change this value through a shader. <br><br>  In the output <i>float of the</i> <i>gl_PointSize</i> variable declared in GLSL, you can set the height and width of dots in pixels.  By describing the size of the point in the vertex shader, you can influence this value for each vertex. <br><br>  By default, resizing a point in the vertex shader is disabled, but if you want, you can <i>cast the Open_PL GL_PROGRAM_POINT_SIZE</i> flag: <br><br><pre><code class="cpp hljs">glEnable(GL_PROGRAM_POINT_SIZE);</code> </pre> <br>  A simple example of resizing a point is to set the size of the point equal to the value of the z component of the clipping space, which, in turn, is equal to the distance from the vertex to the observer.  The size of the point will increase, the further we are from the top. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ gl_Position = projection * view * model * vec4(aPos, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); gl_PointSize = gl_Position.z; }</code> </pre> <br>  As a result, the farther we are from the points, the larger they are displayed. <br><br><div style="text-align:center;"><img src="https://learnopengl.com/img/advanced/advanced_glsl_pointsize.png" alt="point_size"></div><br>  Resizing a point for each vertex will be useful for such techniques as particle generation. <br><br><h2>  gl_VertexID </h2><br>  The variables <i>gl_Position</i> and <i>gl_PointSize</i> are <i>output</i> variables, since their values ‚Äã‚Äãare read as output from the fragment shader stage, and by writing we can influence them.  The vertex shader also provides the <i>gl_VertexID</i> <i>input</i> variable, from which only reads are possible. <br><br>  The integer variable <i>gl_VertexID</i> contains the identifier of the vertex to be drawn.  During the execution of the <i>index render</i> (using <i>glDrawElements</i> ), this variable contains the current index of the vertex to be drawn.  During rendering without indices (via <i>glDrawArrays</i> ), the variable contains the number of vertices processed at the moment since the render call. <br><br>  Although it is not very necessary now, knowing about the presence of such a variable is useful. <br><br><h2>  Fragment shader variables </h2><br>  Inside the fragment shader, we also have access to some curious variables.  GLSL provides us with two input variables <i>gl_FragCoord</i> and <i>gl_FrontFacing</i> . <br><br><h2>  gl_FragCoord </h2><br>  We already saw <i>gl_FragCoord a</i> couple of times while we were discussing depth checking, because  The z component of the <i>gl_FragCoord</i> vector is equal to the depth value of a particular fragment.  However, we can also use x and y components for some effects. <br><br>  The x and y components of the <i>gl_FragCoord</i> variable are the coordinates of a fragment in the window's coordinate system, originating from the lower left corner of the window.  We specified the 800x600 window size using <i>glViewport</i> , so the fragment coordinates in the window coordinate system will be between 0-800 in x and a range of 0-600 in y. <br><br>  Using the fragment shader, we can calculate various color values ‚Äã‚Äãbased on the screen coordinates of the fragment.  The usual use of the <i>gl_FragCoord</i> variable is to compare the apparent result of the calculations of various fragments, as is usually done in technical demo versions.  For example, we can divide the screen into two parts, rendering the part on the left half of the screen, and the other part - on the right half of the screen.  Below is an example of a fragment shader that displays various colors based on screen coordinates. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(gl_FragCoord.x &lt; <span class="hljs-number"><span class="hljs-number">400</span></span>) FragColor = vec4(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> FragColor = vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre><br>  Since  the width of the window is 800, if the pixel coordinates are less than 400, it should be on the left side of the screen, and this gives us an object of a different color. <br><br><div style="text-align:center;"><img src="https://learnopengl.com/img/advanced/advanced_glsl_fragcoord.png" alt="fragcoord"></div><br>  Now we can calculate two completely different results in the fragment shader and display each on its own part of the screen.  This is great for testing various light mechanics. <br><br><h2>  gl_FrontFacing </h2><br>  Another interesting variable in the fragment shader is <i>gl_FrontFacing</i> .  In the lesson, <a href="https://habrahabr.ru/post/346964/">face cut</a> - we mentioned that OpenGL can determine whether a face is a face in the order of traversing vertices.  If we do not use face clipping (by activating the <i>GL_FACE_CULL</i> flag), then the <i>gl_FrontFacing</i> variable tells us whether the current fragment is a front or non-part.  We can count different colors for the front part for example. <br><br>  The <i>boolean</i> variable <i>gl_FrontFacing is</i> set to <i>true</i> if the fragment is on the front face, otherwise it is <i>false</i> .  For example, we can create a cube with different textures inside and outside. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D frontTexture; uniform sampler2D backTexture; void main() { </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta">(gl_FrontFacing) FragColor = texture(frontTexture, TexCoords); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> FragColor = texture(backTexture, TexCoords); }</span></span></code> </pre><br>  If we look inside the container, we will see that a different texture is used there. <br><br><div style="text-align:center;"><img src="https://learnopengl.com/img/advanced/advanced_glsl_frontfacing.png" alt="frontfacing"></div><br>  I note that if you activate face clipping, you will not see any faces within the container, so using <i>gl_FronFacing</i> will be useless. <br><br><h2>  gl_FragDepth </h2><br>  <i>gl_FragCoord</i> is an input variable that allows us to read the coordinates in the window coordinate system and get the value of the depth of the current fragment, but this variable is <b>read only</b> .  We cannot change the coordinates of the fragment in the coordinate system of the window, but we can set the value of the depth of the fragment.  GLSL provides us with the output variable, <i>gl_FragDepth</i> , using which we can set the value of the fragment depth inside the shader. <br><br>  Setting the depth value is simple - you just need to write the <i>float</i> value from 0.0 to 1.0 in the variable <i>gl_FragDepth</i> . <br><br><pre> <code class="cpp hljs">gl_FragDepth = <span class="hljs-number"><span class="hljs-number">0.0</span></span>; <span class="hljs-comment"><span class="hljs-comment">//       </span></span></code> </pre> <br>  If the shader does not write the value to <i>gl_FragDepth</i> , then the value for this variable will be automatically taken from <i>gl_FragCoord.z</i> . <br><br>  However, self-setting of the depth value has a significant drawback, since  OpenGL disables all <b>early depth checks</b> (as discussed in the <a href="https://habrahabr.ru/post/342610/">depth test</a> ) as soon as the fragment shader has an entry in <i>gl_FragDepth</i> .  This is done due to the fact that OpenGL cannot know what depth value the fragment will have <b>before</b> the fragment shader is launched, since  a fragment shader could completely change this value. <br><br>  Writing to <i>gl_FragDepth</i> , you should think about a possible drop in performance.  However, starting with version 4.2 of OpenGL, we can find a compromise by redefining the gl_FragDepth variable at the beginning of the fragment shader with <b>the depth condition</b> . <br><br><pre> <code class="cpp hljs">layout (depth_&lt;condition&gt;) out <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> gl_FragDepth;</code> </pre> <br>  The <i>condition</i> parameter can take the following values: <br><table><tbody><tr><th width="130">  Condition </th><th>  Description </th></tr><tr><td>  <i>any</i> </td><td>  Default value.  <i>Early depth check</i> disabled - you lose performance </td></tr><tr><td>  <i>greater</i> </td><td>  You can set the depth value only greater than <i>gl_FragCoord.z</i> </td></tr><tr><td>  <i>less</i> </td><td>  You can set the depth value only less than <i>gl_FragCoord.z</i> </td></tr><tr><td>  <i>unchanged</i> </td><td>  In gl_FragDepth, you write a value equal to gl_FragCoord.z </td></tr></tbody></table>  By specifying <i>greater</i> or <i>less</i> as a condition for depth, OpenGL can make the assumption that you will only write values ‚Äã‚Äãgreater or less than fragment depths.  In this scenario, OpenGL can still produce an early test of the depth value, if the value is less than the fragment depth value. <br><br>  In the example below, we increase the depth value in the fragment shader, but also want to keep the early depth check in the fragment shader. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 420 core </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     OpenGL out vec4 FragColor; layout (depth_greater) out float gl_FragDepth; void main() { FragColor = vec4(1.0); gl_FragDepth = gl_FragCoord.z + 0.1; }</span></span></span></span></code> </pre><br>  This property is only available in OpenGL 4.2 and higher. <br><br><h2>  Interface blocks </h2><br>  Until now, whenever we wanted to transfer data from a vertex shader to a fragment shader, we declared several corresponding input / output variables.  This method is the easiest to transfer data from one shader to another.  As applications become more complex, you may want to pass more than a few variables, which may include arrays and / or structures. <br><br>  To help us organize variables GLSL provides such a thing as <b>interface blocks</b> , which allows you to group variables together.  The declaration of such interface blocks is in many ways similar to the <i>structure</i> declaration, except for the use of the <i>in</i> and <i>out</i> keywords, based on the use of the block (input or output). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec3 aPos; layout (location = 1) in vec2 aTexCoords; uniform mat4 model; uniform mat4 view; uniform mat4 projection; out VS_OUT { vec2 TexCoords; } vs_out; void main() { gl_Position = projection * view * model * vec4(aPos, 1.0); vs_out.TexCoords = aTexCoords; }</span></span></code> </pre> <br>  Here we declared the interface block <i>vs_out</i> , grouping all output variables together, which will be sent to the next shader.  This is a trivial example, but just imagine how this can help you organize your I / O in shaders.  This will also be useful in the next lesson on geometry shaders when you need to combine shader I / O into arrays. <br><br>  Then we need to declare the input interface block in the next shader - the fragment one.  <b>The block name</b> ( <i>VS_OUT)</i> should be the same, but <b>the instance name</b> ( <i>vs_out</i> , used in the vertex shader) can be any, the main thing to avoid confusion in the names (for example, calling the instance containing the input data <i>vs_out</i> ). <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core out vec4 FragColor; in VS_OUT { vec2 TexCoords; } fs_in; uniform sampler2D texture; void main() { FragColor = texture(texture, fs_in.TexCoords); }</span></span></code> </pre> <br>  Since the names of the interface units are the same, their corresponding I / O is combined together.  This is another useful feature that helps you organize your code and prove its usefulness when switching between specific stages like a geometric shader. <br><br><h2>  Uniform buffer </h2><br>  We have been using OpenGL for quite some time and have learned some good moves, but also received some inconveniences.  For example, when we constantly use more than one shader, we have to set uniforms, while most of them are the same in each shader - why do we have to do it again? <br><br>  OpenGL provides us with a tool called <b>Uniform Buffer</b> , which allows us to declare a set of global Uniform variables that remain the same in each shader.  When using Uniform Buffer, we need to set the required Uniform variables only <b>once</b> .  But we still have to take care of the unique variables for a particular shader.  However, to configure the object uniform-buffer, we will have to sweat a little. <br><br>  Since the uniform-buffer is a buffer, like any other buffer, we can create it through the function <i>glGenBuffers</i> , bind it to the target <i>GL_UNIFORMS_BUFFER</i> , and put all the necessary data of the uniform variables there.  There are certain rules for placing data in a uniform buffer - we will return to this later.  First we place our <i>projection</i> and <i>view</i> matrices in the so-called <b>uniform block</b> in the vertex shader. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec3 aPos; layout (std140) uniform Matrices { mat4 projection; mat4 view; }; uniform mat4 model; void main() { gl_Position = projection * view * model * vec4(aPos, 1.0); }</span></span></code> </pre> <br>  In most of our examples, we set the projection and view matrices in each rendering iteration for each shader used.  This is an ideal example for demonstrating the usefulness of a uniform buffer, since  now we need to ask them only once.  We announced and named the uniforms-block - <i>Matrices</i> , which stores two 4x4 matrices.  Variables in a block can be accessed directly without specifying the block prefix.  Then we put the values ‚Äã‚Äãof these matrices into a buffer somewhere in the code, and each shader declaring this unit-block has access to the matrices. <br><br>  You are now probably thinking what the expression <i>std140</i> means.  It says that the uniform block uses a special method of placing its contents in memory;  This expression specifies the <b>markup (layout) of the</b> uniform block. <br><br><h2>  Uniformed block layout </h2><br>  The content of the uniform block is stored in the buffer object, which is essentially nothing more than a reserved area of ‚Äã‚Äãmemory.  Since this section of memory does not contain information what type of data it stores, we need to tell OpenGL which section of memory corresponds to each of the uniforms in the shader. <br><br>  Imagine the following uniform block in the shader: <br><br><pre> <code class="cpp hljs">layout (std140) uniform ExampleBlock { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> value; vec3 <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>; mat4 matrix; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> values[<span class="hljs-number"><span class="hljs-number">3</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> integer; };</code> </pre><br>  We want to know the size (in bytes) and the offset (from the beginning of the block) for each of these variables, so that we can place them in a buffer in the appropriate order.  The size of each element is explicitly defined in OpenGL and is directly related to C ++ types;  vectors and matrices are large arrays of floating point numbers.  What OpenGL clearly does not define is the <b>space</b> between the variables.  This allows the hardware to allocate variables as it sees fit.  For example, some instances place <i>vec3</i> next to a <i>float</i> .  Not everyone can handle this and therefore align vec3 to an array of four <i>floats</i> before adding a <i>float</i> .  Wonderful property, but uncomfortable for us. <br><br>  GLSL by default uses the so <b>-called shared</b> markup (layout) for the memory of the uniform-buffer.  <i>Shared</i> markup is called because the hardware-defined offsets are shared by several programs.  With the help of shared markup, GLSL has the right to move the uniforms for optimization, with the condition that the order of the variables does not change.  Since  we do not know at which offset each uniform is a variable, we will not know how to accurately fill our uniform buffer.  We may request this information with functions like <i>glGetUniformIndices</i> , but this is outside the scope of our lesson. <br><br>  While the shared markup provides us with some optimization of the memory we spend, we need to request an offset from each Uniform variable, which turns into a lot of work.  However, a common practice is not to use shared markup, but to use <b>std140</b> markup.  Std140 <b>explicitly</b> specifies the layout in memory for each type of variable, setting the corresponding offset according to special rules.  Since  mixing explicitly indicated, we can manually figure out the offset for each variable. <br><br>  Each variable corresponds to a <b>basic alignment</b> equal to the amount of variable memory occupied (including alignment bytes (padding)) inside a uniform block ‚Äî the value of this basic alignment is calculated according to <i>std140</i> markup <i>rules</i> .  Then for each variable, we calculate the <b>aligned offset</b> in bytes from the beginning of the block.  The byte offset of the variable <b>must</b> be a multiple of the base alignment. <br><br>  You can find exact markup rules in the OpenGL Uniform Buffer Specification - <a href="http://www.opengl.org/registry/specs/ARB/uniform_buffer_object.txt">here</a> .  But we will list the general rules below.  Each type of variable in GLSL, such as <i>int</i> , <i>float,</i> and <i>bool,</i> is defined as four-byte, each four-byte object is denoted by N. <br><table><tbody><tr><th>  Type of </th><th>  Layout rule (markup) </th></tr><tr><td>  Scalar ( <i>int</i> , <i>bool</i> ) </td><td>  Each scalar type has a base alignment of N </td></tr><tr><td>  Vector </td><td>  2N or 4N.  This means that <i>vec3</i> has a basic 4N alignment. </td></tr><tr><td>  An array of vectors or scalars </td><td>  Each element has a basic alignment equal to the alignment <i>vec4</i> </td></tr><tr><td>  Matrices </td><td>  Stored as large arrays of vector columns, where each vector has a base <i>vec4</i> alignment </td></tr><tr><td>  Structure </td><td>  It is equal to the calculated size of all elements, in accordance with the previous rule, but supplemented to the multiplicity of size vec4 </td></tr></tbody></table>  Like most OpenGL specifications, it's easier to understand by example.  We will look at the previously presented uniform block- <i>ExampleBlock</i> and calculate the aligned offset of each member using the <i>std140</i> markup. <br><br><pre> <code class="cpp hljs">layout (std140) uniform ExampleBlock { <span class="hljs-comment"><span class="hljs-comment">//   //   float value; // 4 // 0 vec3 vector; // 16 // 16 (   16,   4  16) mat4 matrix; // 16 // 32 (column 0) // 16 // 48 (column 1) // 16 // 64 (column 2) // 16 // 80 (column 3) float values[3]; // 16 // 96 (values[0]) // 16 // 112 (values[1]) // 16 // 128 (values[2]) bool boolean; // 4 // 144 int integer; // 4 // 148 };</span></span></code> </pre><br>  As an exercise, try to calculate the offset value yourself and compare with this table.  With the calculated offset values, based on the std140 markup rules, we can fill the buffer with data at each offset using functions such as <i>glBufferSubData</i> .  Std140 is not the most efficient, but it guarantees that the markup memory will remain the same for each program that declares this uniform block. <br><br>  By adding a layout expression (std140) before defining a uniform block, we tell OpenGL that this block uses the std140 markup.  There are two more layouts that we can use, requiring us to request each offset before filling the buffer.  We have already seen in the <b>shared</b> markup, and the remaining markup - <b>compacted</b> .  When using compressed markup, there is no guarantee that the markup will remain the same between programs (not shared), because it allows the compiler to optimize uniforms, throwing out separate uniforms, which can lead to differences in different shaders. <br><br><h2>  Using Uniform Buffers </h2><br>  We discussed the definition of uniform blocks in shaders and an indication of the memory allocation scheme, but we have not yet discussed how to use them. <br><br>  The first thing we need is a uniform buffer, which has already been done with <i>glGenBuffers</i> .  Having created a buffer object, we bind it to <i>GL_UNIFORM_BUFFER</i> and allocate the required amount of memory by calling <i>glBufferData</i> . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uboExampleBlock; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;uboExampleBlock); glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock); glBufferData(GL_UNIFORM_BUFFER, <span class="hljs-number"><span class="hljs-number">152</span></span>, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_STATIC_DRAW); <span class="hljs-comment"><span class="hljs-comment">//  150   glBindBuffer(GL_UNIFORM_BUFFER, 0);</span></span></code> </pre><br>  In the case when we want to update or insert data into the buffer, we bind to <i>uboExampleBlock</i> and use <i>glBufferSubData</i> to update the memory.  We only need to update this buffer once, and all shaders using this buffer will use the updated data.  But how does OpenGL know which uniforms-buffers correspond to which uniforms-blocks? <br><br>  In the context of OpenGL, there are a number <b>of anchor points</b> that determine where we can bind the uniform buffer.  Having created a uniforms-buffer, we connect it with one of the anchor points, as well as connect the uniform block with the same point, essentially connecting them together.  The diagram below clearly shows this: <br><br><div style="text-align:center;"><img src="https://learnopengl.com/img/advanced/advanced_glsl_binding_points.png" alt="binding_points"></div><br>  As you can see, we can bind several uniforms-buffers to different anchor points.  Since Shader A and Shader B have a uniform block, which is connected to the same anchor point 0, the information <i>uboMatrices</i> in uniform blocks becomes common to them;  These shaders are required to define the same Matrices Uniform Block. <br><br>  To bind a uniform block to a binding point, we need to call <i>glUnifomBlockBinding</i> , which takes the shader program object identifier with the first argument, the uniform block index with the second argument, and the binding point with the third one (where we bind).  <b>Uniform block</b> index - index of the location of a specific block in the shader.  This information can be obtained by calling <i>glGetUnifromBlocIndex</i> , the host, as arguments the object identifier of the shader program and the name of the uniforms-block.  We can bind the uniform-block <i>Lights</i> as in Figure 3 to the anchor point 2 as follows. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lights_index = glGetUniformBlockIndex(shaderA.ID, <span class="hljs-string"><span class="hljs-string">"Lights"</span></span>); glUniformBlockBinding(shaderA.ID, lights_index, <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre><br>  I note that we will have to repeat this for each shader. <br><blockquote>   <b>OpenGL 4.2</b>      -   <b></b> ,     ,       <i>glGetUniformBlockIndex</i>  <i>glUniformBlockBinding</i> .         - Lights . <br><pre> <code class="cpp hljs">layout(std140, binding = <span class="hljs-number"><span class="hljs-number">2</span></span>) uniform Lights { ... };</code> </pre> </blockquote><br>     -        <i>glBindBufferBase</i>  <i>glBindBufferRange</i> . <br><br><pre> <code class="cpp hljs">glBindBufferBase(GL_UNIFORM_BUFFER, <span class="hljs-number"><span class="hljs-number">2</span></span>, uboExampleBlock); <span class="hljs-comment"><span class="hljs-comment">//  glBindBufferRange(GL_UNIFORM_BUFFER, 2, uboExampleBlock, 0, 152);</span></span></code> </pre><br>  <i>glBindBufferBase</i>         ‚Äì     -.    <i>uboExampleBlock</i>    2      2   .      <i>glBindBufferRange</i> ,       ‚Äì          -   .  <i>glBindBufferRange</i> ,     -   -. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Now everything is set up, we can start adding data to the uniform-buffer. </font><font style="vertical-align: inherit;">We could add all the data as a single array or update parts of the buffer when we need it, using </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">glBufferSubData</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">To update the boolean uniforms, we could update the uniforms-buffer like this:</font></font><br><br><pre> <code class="cpp hljs">glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    GLSL   ,        glBufferSubData(GL_UNIFORM_BUFFER, 144, 4, &amp;b); glBindBuffer(GL_UNIFORM_BUFFER, 0);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> The same operation is done with all the uniforms-variables inside the uniforms-block, but with different arguments. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Simple example </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Let's demonstrate the true benefit of uniforms. If you look at the previous sections of the code, we used 3 matrices all the time: projections, views and model ones. Of all these matrices, only the model matrix often changes. If we have several shaders using a set of the same matrices, it is probably more beneficial for us to use the uniform-buffer object. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We will store the matrix of the projection and the form in the uniform block - </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrices</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . We will not store a model matrix here, because it changes quite often in shaders, we would not receive much benefit from such actions.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 330 core layout (location = 0) in vec3 aPos; layout (std140) uniform Matrices { mat4 projection; mat4 view; }; uniform mat4 model; void main() { gl_Position = projection * view * model * vec4(aPos, 1.0); }</span></span></code> </pre><br>     ,     std 140.      4 ,      .          ,    ,    . <br><br>    -      0. ,        . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, <span class="hljs-string"><span class="hljs-string">"Matrices"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, <span class="hljs-string"><span class="hljs-string">"Matrices"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, <span class="hljs-string"><span class="hljs-string">"Matrices"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, <span class="hljs-string"><span class="hljs-string">"Matrices"</span></span>); glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, <span class="hljs-number"><span class="hljs-number">0</span></span>); glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, <span class="hljs-number"><span class="hljs-number">0</span></span>); glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, <span class="hljs-number"><span class="hljs-number">0</span></span>); glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br>    -        0. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">unsigned</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> uboMatrices </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">glGenBuffers</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, &amp;uboMatrices)</span></span></span></span>; glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferData(GL_UNIFORM_BUFFER, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(glm::mat4), <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, GL_STATIC_DRAW); glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>); glBindBufferRange(GL_UNIFORM_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>, uboMatrices, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(glm::mat4));</code> </pre> <br>       ,     <i>glm::mat4</i> .   GLM      <i>mat4</i> GLSL.      ,      ,    0. <br><br>     ‚Äì  .   <i> </i>     (   ),        ‚Äî         .         ,    <i>glBufferSubData</i>           : <br><br><pre> <code class="cpp hljs">glm::mat4 projection = glm::perspective(glm::radians(<span class="hljs-number"><span class="hljs-number">45.0f</span></span>), (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)width/(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)height, <span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">100.0f</span></span>); glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(glm::mat4), glm::value_ptr(projection)); glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Here we put the first part of the uniforms-buffer - the matrix of projections. </font><font style="vertical-align: inherit;">Before rendering objects, at each iteration of the rendering, we update the second part of the buffer - the view matrix.</font></font><br><br><pre> <code class="cpp hljs">glm::mat4 view = camera.GetViewMatrix(); glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices); glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(glm::mat4), <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(glm::mat4), glm::value_ptr(view)); glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">That's all for uniforms-buffer. </font><font style="vertical-align: inherit;">Each vertex shader containing </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Matrices</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> uniform block will now contain data stored in </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">uboMatrices</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Now if we drew 4 cubes using 4 different shaders, their projection and view matrices would remain the same.</font></font><br><br><pre> <code class="cpp hljs">glBindVertexArray(cubeVAO); shaderRed.use(); glm::mat4 model; model = glm::translate(model, glm::vec3(<span class="hljs-number"><span class="hljs-number">-0.75f</span></span>, <span class="hljs-number"><span class="hljs-number">0.75f</span></span>, <span class="hljs-number"><span class="hljs-number">0.0f</span></span>)); <span class="hljs-comment"><span class="hljs-comment">//      shaderRed.setMat4("model", model); glDrawArrays(GL_TRIANGLES, 0, 36); // ...    // ...    // ...   </span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The only uniform variable we need to set is </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">model</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Using uniforms-buffer in such a configuration saves us from calls to setting the value of uniforms for each shader. </font><font style="vertical-align: inherit;">The result looks something like this:</font></font><br><br><div style="text-align:center;"><img src="https://learnopengl.com/img/advanced/advanced_glsl_uniform_buffer_objects.png" alt="unifrom_buffer_objects"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thanks to different shaders and changing the model matrix, 4 cubes have moved to their parts of the screen and have a different color. This is a relatively simple scenario where we can use uniform buffers, but any other large project with rendering could have over a hundred active shaders; This is exactly the case when uniforms-buffers show themselves in all their glory. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">You can find the source code for the sample uniforms </font></font><a href="https://learnopengl.com/code_viewer_gh.php%3Fcode%3Dsrc/4.advanced_opengl/8.advanced_glsl_ubo/advanced_glsl_ubo.cpp"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">here</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br> -         -. -,   -   ‚Äì     -  . -,         -   ,    -    -.   ,   ,       -  ,  -. OpenGL       .        <i>GL_MAX_VETEX_UNIFORM_COMPONENTS</i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">While using uniforms-buffer, this limitation is significantly higher. </font><font style="vertical-align: inherit;">When you reach the limit of using uniforms, for example, when you are engaged in skeletal animation, you can always use uniforms-buffers.</font></font></div><p>Source: <a href="https://habr.com/ru/post/350156/">https://habr.com/ru/post/350156/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../350142/index.html">Development of an external battery on four LiFePO4 batteries</a></li>
<li><a href="../350144/index.html">Richard Hamming: Chapter 29. You get what you measure</a></li>
<li><a href="../350148/index.html">Flask Mega-Tutorial, Part XIII: I18n and L10n (Edition 2018)</a></li>
<li><a href="../350152/index.html">We are testing the array of OceanStor Dorado V3: so ordinary that right at all</a></li>
<li><a href="../350154/index.html">ViyaDB: analytical database for unsorted data</a></li>
<li><a href="../350158/index.html">SMEV 3. Electronic signature of messages in Java and CryptoPro</a></li>
<li><a href="../350160/index.html">30 seconds CSS</a></li>
<li><a href="../350162/index.html">Event digest for HR-specialists in IT for March 2018</a></li>
<li><a href="../350164/index.html">TOP-10: analysis of the best reports of HolyJS 2017 Moscow</a></li>
<li><a href="../350166/index.html">Using CSS Grid to Design User Interfaces</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>