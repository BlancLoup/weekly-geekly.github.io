<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Bitwise sorting with a human face</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despite the fame of the bitwise sorting algorithm, it is difficult to find a decent implementation of it in the C ++ language on the Internet (to be h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Bitwise sorting with a human face</h1><div class="post__text post__text-html js-mediator-article">  Despite the fame of the bitwise sorting algorithm, it is difficult to find a decent implementation of it in the C ++ language on the Internet (to be honest, I think that in other languages ‚Äã‚Äãtoo).  Almost everything that is located by search engines is monstrous either in terms of code or in terms of efficiency.  And most often bad, and then, and more. <br><br>  The main mistake is that the authors are trying to bring universality where it is not needed, and do not provide universality where it is really necessary.  The result is something that is slow and impossible to use. <br><br>  Perhaps that is why many people still consider deconstruction an algorithm of purely academic interest and of little use in reality.  However, this is a misconception. <br><a name="habracut"></a><br>  Recently, however, began to appear tolerable options.  <a href="https://github.com/jeremy-murphy/algorithm/tree/radix_sort/include/boost/algorithm/integer_sort">One of them</a> tried to get into Bust, but was not missed, and the <a href="http://www.boost.org/doc/libs/1_58_0/libs/sort/doc/html/index.html">second one</a> even got. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Moreover, if the first one is simply not very well designed and implemented, then the second one - which got into boost - is not a completely bit-sort sort at all, but a kind of hybrid that on small arrays reduces to calling std :: sort.  Accordingly, its interface contains everything else, and a function of comparing elements, which must be passed to std :: sort. <br><br>  Both of these options, in my opinion, do not reach the true, faithful, Orthodox bitwise sorting, neither in terms of the interface, nor in terms of speed. <br><br><blockquote>  <i>Please note that the purpose of the article is neither an analysis of the algorithm nor a detailed description of the implementation details.</i>  <i>The algorithm is considered from the point of view of its ‚Äúuser characteristics‚Äù: it should work quickly and should be convenient to use.</i> </blockquote><br><br>  To begin with, to show that I am not just theoretical, I will give a comparison of my bitwise sorting with std :: sort and boost :: integer_sort. <br><br><div class="spoiler">  <b class="spoiler_title">8 bits, 100-1000 elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/7ff/c39/ce9/7ffc39ce9cdb4b679dee760a07a5b8ac.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">8 bits, 1000-10000 elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/fff/87c/15f/fff87c15fefd4fe0b1867ca537355bcb.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">8 bits, 10,000‚Äì100,000 items</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/965/230/967/965230967ceb4285b1ad92f188c713d1.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">16 bits, 100-1000 elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/515/f59/c80/515f59c807674c6abe0bb3f055b3ad7d.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">16 bits, 1000‚Äî10000 elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/f76/3dd/771/f763dd771e8b41a8ac2e1af17b1346b9.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">16 bits, 10,000‚Äì100,000 items</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/117/4da/642/1174da642f794c4cbe49120cc43765bf.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">32 bits, 100-1000 elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/3c4/100/762/3c410076203745cf9e8ce210dfdbab99.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">32 bits, 1000-10000 elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a35/e08/dd2/a35e08dd2ae64dea9f5133d71ee0cd09.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">32 bits, 10,000-100,000 items</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a72/cb7/947/a72cb7947a12491b9e2fcd345be6d5b2.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">64 bits, 100-1000 elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/d51/a2e/3db/d51a2e3db6334b3a97dd77c8d77fd1de.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">64 bits, 1000-10000 elements</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/3da/20e/3b5/3da20e3b5e49434aa220e2afc0de35a9.png"><br></div></div><br><div class="spoiler">  <b class="spoiler_title">64 bits, 10,000-100,000 items</b> <div class="spoiler_text"><img src="https://habrastorage.org/files/a74/ab3/9b1/a74ab39b1e9c4740afc735c23f77be1c.png"><br></div></div><br>  Measurements were made on a machine with a Core i7 3.40GHz processor.  On a laptop with a Core 2 Duo 2.26GHz processor, the advantage of bitwise sorting is even more obvious. <br><br>  And now we proceed to the design. <br><br><h3>  First approach </h3><br>  To get a competent interface, it is naturally best to turn to the standard library for enlightenment. <br><br>  Take the standard algorithm std :: sort.  The first option takes only two iterators.  Iterators set the range to be sorted, and about the elements of the range it is known that they have an order relationship defined - the ‚Äúless‚Äù operator.  This is enough to sort. <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span></span>;</code> </pre> <br>  But what if the ‚Äúless‚Äù operator is not defined for the elements or does it need to compare the elements somehow differently?  Then the user must set the order relation himself and pass it as the third argument. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Compare&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Compare comp)</span></span></span></span>;</code> </pre><br>  So, what will the bitwise sorting look like if you start from this example?  In the first version - about the same.  If it is known that the elements of the input range are integers, then we get the same thing as std :: sort: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radix_sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last)</span></span></span></span>;</code> </pre><br>  But what if the input elements are not numbers?  It's simple: you need to set the mapping from these elements to numbers.  This mapping, as well as the order relation in std :: sort, will be the third argument of the function. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radix_sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Map to_integer)</span></span></span></span>;</code> </pre><br>  This interface does not provide any possibility to influence the selection of digits from numbers.  On the other hand, it is clear that the majority of non-distracting users will have enough of the existing interface, because the user wants to sort the numbers and do it quickly.  Implementation details, as a rule, are not very interesting. <br><br>  This means that all the arguments of the function that will be associated directly with the discharge of digits will be somewhere in the end. <br><br>  Therefore, in this step, we believe that the discharges are selected somehow automatically, and you can still be distracted by other problems. <br><br><h3>  Additional memory </h3><br>  The algorithm of bitwise sorting requires additional memory to work: <br><br><ul><li>  Array for storing intermediate results of sorting one by one. </li><li>  Array for counters elements. </li></ul><br>  The problem of storing intermediate results has two solutions: <br><br><ol><li>  Allocate memory for an array inside a function. </li><li>  Transfer buffer outside. </li></ol><br>  And if you think a little, the right decision is obvious - the user must transfer the buffer outside.  And the buffer will be set as an iterator at the beginning of a piece of memory, the size of which is not less than the size of the sorted range. <br><br><ol><li>  It is more flexible. <br><br>  The user is not required to allocate a piece of memory, strictly equal to the size of the sorted range.  If he wants, he can select one large piece and use it to sort the differently sized ranges. <br><br></li><li>  It is more efficient. <br><br>  If sorting is performed repeatedly, then it is enough to allocate memory once for the buffer, and then transfer it to sorting.  And the sorting itself will not waste precious time on allocation. <br></li></ol><br>  Given the chosen solution, the updated interface will be as follows: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radix_sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator1 first, RandomAccessIterator1 last, RandomAccessIterator2 buffer)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radix_sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator1 first, RandomAccessIterator1 last, RandomAccessIterator2 buffer, Map to_integer)</span></span></span></span>;</code> </pre><br>  If the user is too lazy to create a buffer before sorting each time, then he can write an elementary wrapper for himself: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">im_too_lazy_to_create_a_buffer_for_the_radix_sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator first, RandomAccessIterator last, Map to_integer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> value_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::iterator_traits&lt;RandomAccessIterator&gt;::value_type; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;value_type&gt; buffer(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::distance(first, last)); radix_sort(first, last, buffer.begin(), to_integer); }</code> </pre><br>  With an array of counters, too, in principle, it is clear. <br><br>  It is clear that the work on calculating the size and number of digits, the allocation of the necessary arrays for the counters and the transfer of these counters to the sorting function is too complicated to pass it to the user.  The user wants to sort an array.  The rest is not interesting to him. <br><br>  And here we come to the most important thing - the problem of discharge, and this should be discussed separately. <br><br><h3>  Separation of numbers from numbers </h3><br>  The favorite way to isolate the digits of most unfortunate developers of bitwise sorting is to transfer the function of an integer base, the remainder of the division by which is considered a single digit.  And the most common such basis is 10. This can be understood.  But do not forgive. <br><br>  A small improvement of this method, which some developers guess is to make - they take the power of two as the base, and in the arguments of the function they set this degree, and not the base itself.  Accordingly, the discharge is allocated with the help of bit operations, which in itself is already better than simple division, but still bad. <br><br>  Some, like, for example, the author of the first of the above examples, prompts the user to specify the width and minimum and maximum values ‚Äã‚Äãof a single digit.  Which is also unacceptable, because the user can easily break a function by passing incorrect or inconsistent parameters to it. <br><br>  So, to choose the right interface, we formulate a few important thoughts. <br><br><ol><li>  The user wants to use for sorting all digits of the sorted numbers. <br><br>  Indeed, the main case is sorting by the first category, then by the second, by the third, and so on.  until the last without gaps. <br><br>  Although omissions of discharges or parts of discharges are the only non-trivial possibility that the user may need from the mechanism for selecting discharges - you can arrange it, and I will tell about it later. <br><br></li><li>  The best bit is one byte. <br><br>  On all processors, in all operating systems and compilers, which I was able to check, the fastest sorting works if you take one byte in one bit.  For the car is the most convenient case. <br><br>  In fact, for sorting microscopic arrays (10-20 elements) of eight-bit numbers, it would be more profitable to take half a byte as a discharge, but on such sizes the bitwise sorting is in any case inferior (or not particularly winning) to sorting by comparisons, so this case does not interest us. <br></li></ol><br>  Based on these statements, we will create a discharge extraction mechanism, which will be the radix mapping from the result of the to_integer function to an integer.  Moreover, the type returned by the function radix will be considered as one digit.  For example, if radix returns std :: uint8_t, then one byte will be taken as a bit. <br><br>  Based on this, <i>at the compilation stage,</i> you can get all the necessary information: the size of the discharge and shift to obtain the next digit (in this case - 8), the range of possible values ‚Äã‚Äãof the discharge (in this case - [0, 256)), the number of digits in the sorted numbers etc. <br><br>  It will also allow to completely get rid of dynamic memory, and even for counters of discharges to start arrays on the stack. <br><br>  The final interface will look like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator2&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radix_sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator1 first, RandomAccessIterator1 last, RandomAccessIterator2 buffer)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radix_sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator1 first, RandomAccessIterator1 last, RandomAccessIterator2 buffer, Map to_integer)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> RandomAccessIterator2, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Map, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Radix&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">radix_sort</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RandomAccessIterator1 first, RandomAccessIterator1 last, RandomAccessIterator2 buffer, Map to_integer, Radix radix)</span></span></span></span>;</code> </pre><br>  The last two arguments are optional.  Moreover, the latter will be used only in some exceptional cases, and the penultimate - relatively often.  Perhaps, approximately the same as the order relation in std :: sort. <br><br>  By default, the radix function returns the low byte of a number, and the to_integer function is the identical transformation.  Thus, if ordinary integers are sorted, you do not need to specify anything further. <br><br><div class="spoiler">  <b class="spoiler_title">About passes</b> <div class="spoiler_text">  If someone is still interested in how to arrange the skipping of discharges or individual numbers when sorting, I tell.  To do this, you either need to throw away unnecessary bits in the radix display, or make a more cunning display to_integer, in which you need to zero all unnecessary digits. <br><br>  For example, to discard the older half-byte from each digit, the radix mapping must be written like this: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> radix = [] (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x &amp; <span class="hljs-number"><span class="hljs-number">0xf</span></span>; }; <span class="hljs-comment"><span class="hljs-comment">//     .</span></span></code> </pre><br></div></div><br><h3>  findings </h3><br><br>  The advantages of this approach to bitwise sorting are: <br><br><ol><li>  High speed default <br><br>  The user can try different options, for example, take std :: uint16_t as a discharge or even bool, but, rather, everything, the result will only get worse. <br><br></li><li>  Compatibility with the standard library <br><br>  The algorithm uses one of the basic design patterns of the standard library - an iterator.  Besides the fact that the algorithm on iterators is more convenient to use, it is also faster than on containers.  This requires a separate explanation, but it does not fit into the scope of this article. <br><br>  In addition, the converter (to_integer) is also familiar to the SBSH user through algorithms such as std :: transform. <br><br></li><li>  The user is maximally excluded from implementation details, but retains control over what is happening. <br><br>  The user cannot ‚Äúspoil‚Äù the algorithm, pass incorrect arguments to the function, etc.  - in the worst case, its code will not compile.  At the same time, he still has full control over the process (with the exception of those very ‚Äúacademic‚Äù experiments, such as ‚Äúsort by base 97‚Äù). <br><br></li><li>  All that is possible is done at compile time. <br><br>  There is no allocation in the function.  All additional memory that is used, either comes from the outside, or is allocated on the stack. <br><br>  In addition, the template metaprogramming allows you to unwind cycles by digits, since the number of digits is also known at the compilation stage. <br></li></ol><br>  So bitwise sorting is an algorithm that is quite suitable for practical use in the combat code.  Checkmate, "academicians"! <br><br>  If the internal implementation is interesting, then the <a href="">code lies here</a> . </div><p>Source: <a href="https://habr.com/ru/post/271677/">https://habr.com/ru/post/271677/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271665/index.html">Become a member of the 1st Free International School on Software Development Techniques</a></li>
<li><a href="../271669/index.html">Sidechains: how many-sided cryptocurrencies?</a></li>
<li><a href="../271671/index.html">Expansion of EPLAN functionality. Creating a simple Add-Ina in C #</a></li>
<li><a href="../271673/index.html">Free hosting control panels. Beautiful perfection</a></li>
<li><a href="../271675/index.html">Return support for Windows XP in the new assembly Vivaldi 1.0.334.3</a></li>
<li><a href="../271679/index.html">What's new in the field of data storage</a></li>
<li><a href="../271681/index.html">Young hackers 414s</a></li>
<li><a href="../271683/index.html">Come November 26th to Visual Studio Workshop</a></li>
<li><a href="../271685/index.html">Spreadsheets under the hood</a></li>
<li><a href="../271687/index.html">Httplug - abstraction from HTTP client for PHP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>