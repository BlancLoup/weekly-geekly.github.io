<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Reflective Metaprogramming on Go: loop for each by means of the reflect package</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="For many programmers who use or wish to use Go in practice, the lack of parametric polymorphism mechanisms in the language is a great sadness. But not...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Reflective Metaprogramming on Go: loop for each by means of the reflect package</h1><div class="post__text post__text-html js-mediator-article"><p>  For many programmers who use or wish to use Go in practice, the lack of parametric polymorphism mechanisms in the language is a great sadness.  But not everything is as bad as it may seem at first glance. </p><br><p>  Of course, you cannot write generic programs in Go, for example in the C ++ templates style, which would have practically no effect on CPU time.  There is no such mechanism in the language and it is quite possible that it is not expected. </p><br><p> On the other hand, the language is a fairly powerful built-in package <code>reflect</code> , which allows for the reflection of both objects and functions.  If you do not put speed at the center, then with the help of this package you can achieve interesting and flexible solutions. </p><br><p>  In this article, I will show how to implement <code>for each</code> in the form of a type-independent reflexive function. </p><br><a name="habracut"></a><br><h2>  Problem </h2><br><p>  In the Go language, for searching elements of a collection ( <code>Array</code> , <code>Slice</code> , <code>String</code> ), the <code>for range</code> construct is used: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i, item := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> items { <span class="hljs-comment"><span class="hljs-comment">// do something }</span></span></code> </pre> <br><p>  Similarly, you can select items from the <code>Channel</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> item := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> queue { <span class="hljs-comment"><span class="hljs-comment">// do something }</span></span></code> </pre> <br><p>  In general, this covers 80% of the needs for the for each loop.  But the built-in construction <code>for range</code> has pitfalls that are easy to demonstrate with a small example. </p><br><p>  Suppose we have two structures <code>Car</code> and <code>Bike</code> (imagine that we are writing code for a car shop): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Car <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Count <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Bike <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Count <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> Price <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> }</code> </pre> <br><p>  We need to calculate the cost of all the cars and motorcycles that we have in stock. <br>  To do this with a single loop in Go, a new type is needed that summarizes the access to the fields: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Vehicle <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{ GetCount() <span class="hljs-keyword"><span class="hljs-keyword">uint</span></span> GetPrice() <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Car)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c Car)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.Price; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b Bike)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetCount</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">uint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Count; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b Bike)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> b.Price; }</code> </pre><br><p>  Now the total cost can be calculated by traversing <code>vehicles</code> using <code>for range</code> : </p><br><pre> <code class="go hljs">vehicles := []Vehicle{ Car{<span class="hljs-string"><span class="hljs-string">"Banshee "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>}, Car{<span class="hljs-string"><span class="hljs-string">"Enforcer "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">15000</span></span>}, Car{<span class="hljs-string"><span class="hljs-string">"Firetruck"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>}, Bike{<span class="hljs-string"><span class="hljs-string">"Sanchez"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5000</span></span>}, Bike{<span class="hljs-string"><span class="hljs-string">"Freeway"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5000</span></span>}, } total := <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, vehicle := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> vehicles { total += <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(vehicle.GetCount()) * vehicle.GetPrice() } fmt.Println(<span class="hljs-string"><span class="hljs-string">"total"</span></span>, total) <span class="hljs-comment"><span class="hljs-comment">// $ total 155000</span></span></code> </pre> <br><p>  In order not to write a loop each time we can write a function that takes the type <code>[]Vehicle</code> as an input and returns a numerical result: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTotalPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vehicles []Vehicle)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> total <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, vehicle := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> vehicles { total += <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(vehicle.GetCount()) * vehicle.GetPrice() } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total }</code> </pre> <br><p>  Separating this code into a separate function, oddly enough, we lose flexibility because  The following problems appear: </p><br><ul><li>  Restriction of strict typing of elements.  Since  Since the for / range construction is strongly typed and does not produce element types, it is necessary to explicitly indicate the expected type of elements in the function signature.  As a consequence, it is not possible to transfer the <code>[]Car</code> or <code>[]Bike</code> slice directly, although both types - both <code>Car</code> and <code>Bike</code> - satisfy the conditions of the <code>Vehicle</code> interface: </li></ul><br><pre> <code class="go hljs">cars := []Car{ Car{<span class="hljs-string"><span class="hljs-string">"Banshee "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>}, Car{<span class="hljs-string"><span class="hljs-string">"Enforcer "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">15000</span></span>}, Car{<span class="hljs-string"><span class="hljs-string">"Firetruck"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>}, } fmt.Println(<span class="hljs-string"><span class="hljs-string">"total"</span></span>, GetTotalPrice(cars)) <span class="hljs-comment"><span class="hljs-comment">// Compilation error: cannot use cars (type []Car) as type []Vehicle in argument to GetTotalPrice</span></span></code> </pre> <br><ul><li>  Restriction of strict typing of the collection.  For example, there is no possibility to pass instead of the <code>[]Vehicle</code> slice the <code>map[int]Vehicle</code> dictionary: </li></ul><br><pre> <code class="go hljs">cars := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]Vehicle{ <span class="hljs-number"><span class="hljs-number">1</span></span>: Car{<span class="hljs-string"><span class="hljs-string">"Banshee "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>: Car{<span class="hljs-string"><span class="hljs-string">"Enforcer "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">15000</span></span>}, <span class="hljs-number"><span class="hljs-number">3</span></span>: Car{<span class="hljs-string"><span class="hljs-string">"Firetruck"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>}, } fmt.Println(<span class="hljs-string"><span class="hljs-string">"total"</span></span>, GetTotalPrice(cars)) <span class="hljs-comment"><span class="hljs-comment">// Compilation error: cannot use vehicles (type map[int]Vehicle) as type []Vehicle in argument to GetTotalPrice</span></span></code> </pre> <br><p>  In other words, for / range does not allow you to select an arbitrary part of the code and wrap it in a function without losing flexibility. </p><br><h2>  Decision </h2><br><p>  The described problem in many languages ‚Äã‚Äãwith strict typification is solved by involving the parametric polymorphism mechanism (generics, templates).  But instead of parametric polyformism, the authors of Go presented a built-in <code>reflect</code> package that implements the mechanism of reflection. <br>  On the one hand, reflection is a more resource-intensive solution, but on the other hand, it allows you to create more flexible and intelligent algorithms. </p><br><h3>  Type Reflection (reflect.Type) </h3><br><p>  In fact, in the package <code>reflect</code> there are two types of reflection - this is reflection.Type type <code>reflect.Type</code> and reflection.Value value <code>reflect.Value</code> .  Type reflection describes only type properties, therefore two different variables with the same type will have the same type reflection. </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i, j <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">float32</span></span> fmt.Println(reflect.TypeOf(i) == reflect.TypeOf(j)) <span class="hljs-comment"><span class="hljs-comment">// true fmt.Println(reflect.TypeOf(i) == reflect.TypeOf(k)) // false</span></span></code> </pre> <br><p>  Since  in Go, types are constructed on the basis of basic types, then for classification there is a special enumeration with the type Kind: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( Invalid Kind = <span class="hljs-literal"><span class="hljs-literal">iota</span></span> Bool Int Int8 Int16 Int32 Int64 Uint Uint8 Uint16 Uint32 Uint64 Uintptr Float32 Float64 Complex64 Complex128 Array Chan Func Interface Map Ptr Slice String Struct UnsafePointer )</code> </pre> <br><p>  Thus, having access to the reflection.Type type of <code>reflect.Type</code> , you can always find out the type of type that allows you to dispatch without defining the full type of the variable.  For example, it is enough to know that a variable is a function, without going into details which particular type this function has: </p><br><pre> <code class="go hljs">valueType := reflect.TypeOf(value) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> valuteType.Kind() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> reflect.Func: fmt.Println(<span class="hljs-string"><span class="hljs-string">"It's a function"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: fmt.Println(<span class="hljs-string"><span class="hljs-string">"It's something else"</span></span>) }</code> </pre> <br><p>  For convenience of writing, we will call the type reflection a certain variable with the same name, but with the <code>Type</code> suffix: </p><br><pre> <code class="go hljs">callbackType := reflect.TypeOf(callback) collectionType := reflect.TypeOf(collection)</code> </pre> <br><p>  In addition to the type to which the type belongs, with the help of reflection of the type, you can find out the remaining static information about the type (that is, information that does not change at run time).  For example, you can find out the number of function arguments and the type of expected argument at a certain position: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> callbackType.NumIn() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> { keyType := callbackType.In(<span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// expected argument type at zeroth position }</span></span></code> </pre> <br><p>  Similarly, you can access the description of the members of the structure: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Person <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Email <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } structType := reflect.TypeOf(Person{}) fmt.Println(structType.Field(<span class="hljs-number"><span class="hljs-number">0</span></span>).Name) <span class="hljs-comment"><span class="hljs-comment">// Name fmt.Println(structType.Field(1).Name) // Email</span></span></code> </pre> <br><p>  The size of the array can also be found through reflection type: </p><br><pre> <code class="go hljs">array := [<span class="hljs-number"><span class="hljs-number">3</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} arrayType := reflect.TypeOf(array) fmt.Println(arrayType.Len()) <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre> <br><p>  But the size of the slice through the reflection of the type is already impossible to know, because  this information changes at run time. </p><br><pre> <code class="go hljs">slice := []<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>{<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>} sliceType := reflect.TypeOf(slice) fmt.Println(sliceType.Len()) <span class="hljs-comment"><span class="hljs-comment">// panic!</span></span></code> </pre> <br><h3>  Reflection values ‚Äã‚Äã(reflect.Value) </h3><br><p>  Similar to type reflection, in Go there is a reflection of the <code>reflect.Value</code> value, which reflects the properties of a particular value stored in a variable.  It may seem like a rather trivial reflection, but because  in Go, a variable with the <code>interface{}</code> type can store anything - a function, a number, a structure, etc., and the reflection of the value is forced to provide access to all the probable possibilities of the object in a more or less safe form.  Which, of course, generates a rather long list of methods. </p><br><p>  For example, the reflection of a function can be used to call - just pass the list of arguments to the type <code>reflect.Value</code> : </p><br><pre> <code class="go hljs"> _callback := reflect.ValueOf(callback) _callback.Call([]reflect.Value{ values })</code> </pre> <br><p>  Reflection of the collection (slice, array, string, etc.) can be used to access the elements: </p><br><pre> <code class="go hljs">_collection := reflect.ValueOf(collection) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _collection.Len(); i++ { fmt.Println(_collection.Index(i)) }</code> </pre> <br><p>  Reflection of the dictionary works in a similar way - to get around it, you need to get a list of keys through the <code>MapKeys</code> method and select elements via <code>MapIndex</code> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, k := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> _collection.MapKeys() { keyValueCallback(k, _collection.MapIndex(k)) }</code> </pre> <br><p>  With the help of the reflection of the structure you can get the values ‚Äã‚Äãof the members  The names and types of members should be derived from the reflection of the type of structure: </p><br><pre> <code class="go hljs">_struct := reflect.ValueOf(aStructIstance) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _struct.NumField(); i++ { name := structType.Field(i).Name fmt.Println(name, _struct.Field(i)) }</code> </pre> <br><h3>  Reflective loop for each </h3><br><p>  So, if you go back to for each, then it is desirable to get a function that would accept a collection and a callback function of an arbitrary type, thus the responsibility for the type negotiation would be on the user. </p><br><p>  Since  the only possibility in Go to transfer an arbitrary type of function is to specify the <code>interface{}</code> type, then in the function body it is necessary to perform checks based on the information contained in the <code>callbackType</code> type reflection: </p><br><ul><li>  make sure that the callback function is really a function (via the <code>calbackType.Kind()</code> method) </li><li>  find out the number of expected arguments ( <code>callbackType.NumIn()</code> method) </li><li>  in case of failure, call <code>panic()</code> </li></ul><br><p>  The result is approximately the following code: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(collection, callback </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { callbackType := reflect.TypeOf(callback) _callback := reflect.ValueOf(callback) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> callbackType.Kind() != reflect.Func { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(<span class="hljs-string"><span class="hljs-string">"foreach: the second argument should be a function"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> callbackType.NumIn() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-comment"><span class="hljs-comment">// Callback expects only value case 2: // Callback expects key-value pair default: panic("foreach: the function should have 1 or 2 input arguments") } }</span></span></code> </pre> <br><p>  Now you need to design a helper function that will crawl the collection. <br>  It is more convenient to pass the callback to it not in a typeless form, but as a function with two arguments that accepts the reflection of the key and the element: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">eachKeyValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(collection </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, keyValueCallback </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(k, v reflect.Value)</span></span></span><span class="hljs-function">)</span></span> { _collection := reflect.ValueOf(collection) collectionType := reflect.TypeOf(collection) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> collectionType.Kind() { <span class="hljs-comment"><span class="hljs-comment">// loops } }</span></span></code> </pre> <br><p>  Since  Since the collection passage algorithm depends on the type that can be obtained through the <code>Kind()</code> method of reflection type, then for dispatching it is convenient to use the <code>switch-case</code> construction: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> collectionType.Kind() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> reflect.Array: <span class="hljs-keyword"><span class="hljs-keyword">fallthrough</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> reflect.Slice: <span class="hljs-keyword"><span class="hljs-keyword">fallthrough</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> reflect.String: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _collection.Len(); i++ { keyValueCallback(reflect.ValueOf(i), _collection.Index(i)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> reflect.Map: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, k := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> _collection.MapKeys() { keyValueCallback(k, _collection.MapIndex(k)) } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> reflect.Chan: i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { elementValue, ok := _collection.Recv() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> } keyValueCallback(reflect.ValueOf(i), elementValue) i += <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> reflect.Struct: <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; _collection.NumField(); i++ { name := collectionType.Field(i).Name keyValueCallback(reflect.ValueOf(name), _collection.Field(i)) } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: keyValueCallback(reflect.ValueOf(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>), _collection) }</code> </pre> <br><p>  As you can see from the code, traversing an array, a slice and a string is the same.  The dictionary, channel and structure have their own traversal algorithm.  If the genus of the collection does not fall under one of the above, the algorithm tries to pass the collection itself to the callback, note that the reflection index <code>nil</code> (which returns a call to <code>IsValid()</code> returns <code>false</code> ) as the key. </p><br><p>  Now that you have a function that produces a typeless bypass of the collection, you can adapt it to a call from the <code>ForEach</code> function by wrapping it into a closure.  This is the final decision: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ForEach</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(collection, callback </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span></span> { callbackType := reflect.TypeOf(callback) _callback := reflect.ValueOf(callback) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> callbackType.Kind() != reflect.Func { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(<span class="hljs-string"><span class="hljs-string">"foreach: the second argument should be a function"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> callbackType.NumIn() { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: eachKeyValue(collection, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_key, _value reflect.Value)</span></span></span></span>{ _callback.Call([]reflect.Value{ _value }) }) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: keyType := callbackType.In(<span class="hljs-number"><span class="hljs-number">0</span></span>) eachKeyValue(collection, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(_key, _value reflect.Value)</span></span></span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !_key.IsValid() { _callback.Call([]reflect.Value{reflect.Zero(keyType), _value }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } _callback.Call([]reflect.Value{ _key, _value }) }) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(<span class="hljs-string"><span class="hljs-string">"foreach: the function should have 1 or 2 input arguments"</span></span>) } }</code> </pre> <br><p>  It should be noted that in the case where the callback function is waiting for the transfer of two arguments (key / value pairs), it is necessary to check the key's correctness, since  it may not be valid.  In the latter case, a null object is constructed based on the key type. </p><br><h2>  Examples </h2><br><p>  Now it's time to demonstrate what our approach gives.  If we return to the problem, we can now solve it in this way: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetTotalPrice</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vehicles </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">float64</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> total <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span> ForEach(vehicles, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vehicle Vehicle)</span></span></span></span> { total += <span class="hljs-keyword"><span class="hljs-keyword">float64</span></span>(vehicle.GetCount()) * vehicle.GetPrice() }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> total }</code> </pre> <br><p>  This function, in contrast to the one given at the beginning of the article, is much more flexible, since  allows you to calculate the amount regardless of the type of collection and does not require to bring the type of elements to the <code>Vehicle</code> interface: </p><br><pre> <code class="go hljs">vehicles := []Vehicle{ Car{<span class="hljs-string"><span class="hljs-string">"Banshee "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>}, Bike{<span class="hljs-string"><span class="hljs-string">"Sanchez"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5000</span></span>}, } cars := []Car{ Car{<span class="hljs-string"><span class="hljs-string">"Enforcer "</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">15000</span></span>}, Car{<span class="hljs-string"><span class="hljs-string">"Firetruck"</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">20000</span></span>}, } vehicleMap := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>]Vehicle{ <span class="hljs-number"><span class="hljs-number">1</span></span>: Car{<span class="hljs-string"><span class="hljs-string">"Banshee "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>}, <span class="hljs-number"><span class="hljs-number">2</span></span>: Bike{<span class="hljs-string"><span class="hljs-string">"Sanchez"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5000</span></span>}, } vehicleQueue := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> Vehicle, <span class="hljs-number"><span class="hljs-number">2</span></span>) vehicleQueue &lt;- Car{<span class="hljs-string"><span class="hljs-string">"Banshee "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>} vehicleQueue &lt;- Bike{<span class="hljs-string"><span class="hljs-string">"Sanchez"</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">5000</span></span>} <span class="hljs-built_in"><span class="hljs-built_in">close</span></span>(vehicleQueue) garage := <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{ MyCar Car MyBike Bike }{ Car{<span class="hljs-string"><span class="hljs-string">"Banshee "</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">10000</span></span>}, Bike{<span class="hljs-string"><span class="hljs-string">"Sanchez"</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5000</span></span>}, } fmt.Println(GetTotalPrice(vehicles)) <span class="hljs-comment"><span class="hljs-comment">// 20000 fmt.Println(GetTotalPrice(cars)) // 125000 fmt.Println(GetTotalPrice(vehicleMap)) // 20000 fmt.Println(GetTotalPrice(vehicleQueue)) // 20000 fmt.Println(GetTotalPrice(garage)) // 15000</span></span></code> </pre> <br><p>  And a small benchmark for two identical cycles, which clearly shows how flexibility is achieved: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// BenchmarkForEachVehicles1M total := 0.0 for _, v := range vehicles { total += v.GetPrice() }</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//BenchmarkForRangeVehicles1M total := 0.0 ForEach(vehicles, func(v Vehicle) { total += v.GetPrice() })</span></span></code> </pre> <br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">PASS</span></span> BenchmarkForEachVehicles1M-<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">20</span></span> ns/op BenchmarkForRangeVehicles1M-<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2000000000</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>.<span class="hljs-number"><span class="hljs-number">01</span></span> ns/op</code> </pre> <br><h2>  Conclusion </h2><br><p>  Yes, there is no parametric polyformism in Go.  But there is a package of <code>reflect</code> , which provides extensive opportunities in the field of metaprogramming.  The code using <code>reflect</code> course, looks much more complicated than the typical code on Go.  On the other hand, reflexive functions allow you to create more flexible solutions.  This is very important when writing application libraries, for example, when implementing the concept of <code>Active Record</code> . </p><br><p>  So, if you do not know in advance how other programmers will use your library and the speed limit for you is not the main goal, then, quite possibly, reflexive metaprogramming will be the best choice. </p><br><p> <a href="https://github.com/kreshikhin/foreach"><img src="https://github.com/favicon.ico" alt="github"></a>  <a href="https://github.com/kreshikhin/foreach">Github source code</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/306304/">https://habr.com/ru/post/306304/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../306292/index.html">We write HabraKvest on ASP.NET Core and Angular2</a></li>
<li><a href="../306294/index.html">Trolleybus from a loaf or alias analysis in LLVM</a></li>
<li><a href="../306296/index.html">The digest of interesting materials for Mobile Developer # 163 (July 18-24)</a></li>
<li><a href="../306298/index.html">Telegram writes in the syslog messages inserted from the clipboard, including in secret chats</a></li>
<li><a href="../306300/index.html">Simple sweet apps with Kivy</a></li>
<li><a href="../306306/index.html">The digest of fresh materials from the world of the frontend for the last two weeks ‚Ññ220 (July 11 - 24, 2016)</a></li>
<li><a href="../306308/index.html">Cambium ePMP 2000. Solving the problem of interference at base stations</a></li>
<li><a href="../306310/index.html">Object-Global Mapping or "ORM for globals." Direct Access with the Cach√© Globals Proxy Framework</a></li>
<li><a href="../306312/index.html">After logging on a VK user, you can get control of his page.</a></li>
<li><a href="../306318/index.html">Infectious distribution of advertising in social networks</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>