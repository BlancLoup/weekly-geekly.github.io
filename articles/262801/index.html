<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Magic of tensor algebra: Part 9 - Derivation of the angular velocity tensor through the parameters of the final rotation. Apply Maxima</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


1. What is a tensor and what is it for? 
2. Vector and tensor operations. Ranks of tensors 
3. Curved coordinates 
4. Dynamics of a point i...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Magic of tensor algebra: Part 9 - Derivation of the angular velocity tensor through the parameters of the final rotation. Apply Maxima</h1><div class="post__text post__text-html js-mediator-article"><h1>  Content </h1><br><ol><li>  <a href="http://habrahabr.ru/post/261421/">What is a tensor and what is it for?</a> </li><li>  <a href="http://habrahabr.ru/post/261615/">Vector and tensor operations.</a>  <a href="http://habrahabr.ru/post/261615/">Ranks of tensors</a> </li><li>  <a href="http://habrahabr.ru/post/261717/">Curved coordinates</a> </li><li>  <a href="http://habrahabr.ru/post/261803/">Dynamics of a point in the tensor representation</a> </li><li>  <a href="http://habrahabr.ru/post/261991/">Actions on tensors and some other theoretical questions</a> </li><li>  <a href="http://habrahabr.ru/post/262129/">Kinematics of free solid.</a>  <a href="http://habrahabr.ru/post/262129/">Nature of angular velocity</a> </li><li>  <a href="http://habrahabr.ru/post/262263/">The final turn of a solid.</a>  <a href="http://habrahabr.ru/post/262263/">Rotation tensor properties and method for calculating it</a> </li><li>  <a href="http://habrahabr.ru/post/262497/">On convolutions of the Levi-Civita tensor</a> </li><li>  <a href="http://habrahabr.ru/post/262801/">Conclusion of the angular velocity tensor through the parameters of the final rotation.</a>  <a href="http://habrahabr.ru/post/262801/">Apply head and maxima</a> </li><li>  <a href="http://habrahabr.ru/post/262957/">Get the angular velocity vector.</a>  <a href="http://habrahabr.ru/post/262957/">We work on the shortcomings</a> </li><li>  <a href="http://habrahabr.ru/post/263345/">Acceleration of the point of the body with free movement.</a>  <a href="http://habrahabr.ru/post/263345/">Solid Corner Acceleration</a> </li><li>  <a href="http://habrahabr.ru/post/263533/">Rodrig ‚Äì Hamilton parameters in solid kinematics</a> </li><li>  <a href="http://habrahabr.ru/post/263565/">SKA Maxima in problems of transformation of tensor expressions.</a>  <a href="http://habrahabr.ru/post/263565/">Angular velocity and acceleration in the parameters of Rodrig-Hamilton</a> </li><li>  <a href="http://habrahabr.ru/post/263687/">Non-standard introduction to solid body dynamics</a> </li><li>  <a href="http://habrahabr.ru/post/263853/">Non-free rigid motion</a> </li><li>  <a href="http://habrahabr.ru/post/264007/">Properties of the inertia tensor of a solid</a> </li><li>  <a href="http://habrahabr.ru/post/264099/">Sketch of nut Janibekov</a> </li><li>  <a href="http://habrahabr.ru/post/264381/">Mathematical modeling of the Janibekov effect</a> </li></ol><br><br><h1>  Introduction </h1><br>  The order of time has already flowed away, as I promised to get the tensor of the angular velocity of a solid body, expressing it through the parameters of the final rotation.  If you look at the KDPV, it will become clear why I thought so long - a stack of paper on the table, this is the course of my thoughts. <br><br>  <em>The transformation of tensor expressions is still a pleasure ...</em> <br><img src="https://habrastorage.org/files/3dc/0f1/6df/3dc0f16dfe2f4836b4d8ce6f64ed1858.jpg">
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Cruel tensors did not want to be simplified.  Rather, they wanted it, but during transformations, disclosure of parentheses, due to carelessness, minor errors occurred that did not allow to look at the whole picture.  As a result, the result was still obtained.  <abbr title="Computer Algebra System">SKA</abbr> Maxima, which I addressed, played a significant role in this, <a href="http://habrahabr.ru/post/262287/">thanks</a> in large part <a href="http://habrahabr.ru/post/262287/">to an article</a> by <a href="https://habrahabr.ru/users/eugenekalentev/" class="user_link">EugeneKalentev</a> .  The emphasis of the mentioned article shifted towards computational work with tensors, the components of which are represented by concrete data structures.  I was also interested in the question of working with abstract tensors.  It turned out that Maxima can work with them, although not as much as she could be, but still she has seriously simplified my life. <br><br>  So, we return to solid mechanics, and at the same time we will look at how to work with tensors in Maxima. <br><a name="habracut"></a><br><br><h1>  1. A little about the final expression of the rotation tensor </h1><br>  In the last article, we, having studied the principles of convolution of the product of Levi-Civita tensors, obtained this expression for the rotation tensor <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/B_k%5E%7B%5C%2Cm%7D%20%3D%20u%5E%7B%5C%2Cm%7D%20%5C%2C%20g_%7Bjk%7D%20%5C%2C%20u%5E%7B%5C%2Cj%7D%20-%20%5Ccos%5Cvarphi%20%5C%2C%20%5Cleft(%20%5Cdelta_%7Bj%7D%5E%7B%5C%2Cm%7D%20%5C%2C%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cq%7D%20-%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cm%7D%20%5C%2C%20%5Cdelta_%7Bj%7D%5E%7B%5C%2Cq%7D%20%5Cright)%20%5C%2C%20u_%7Bq%7D%20%5C%2C%20u%5Ej%20%2B%20%5Csin%5Cvarphi%20%5C%2C%20g%5E%7Bmi%7D%20%5C%2C%20U_%7Bik%7D%20%5Cright%20%5Cquad%20(1)" alt="B_k ^ {\, m} = u ^ {\, m} \, g_ {jk} \, u ^ {\, j} - \ cos \ varphi \, \ left (\ delta_ {j} ^ {\, m } \, \ delta_ {k} ^ {\, q} - \ delta_ {k} ^ {\, m} \, \ delta_ {j} ^ {\, q} \ right) \, u_ {q} \, u ^ j + \ sin \ varphi \, g ^ {mi} \, U_ {ik} \ right \ quad (1)"></div><br>  It can be simplified, for this we will work with the expression in brackets in the second term <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cleft(%20%5Cdelta_%7Bj%7D%5E%7B%5C%2Cm%7D%20%5C%2C%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cq%7D%20-%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cm%7D%20%5C%2C%20%5Cdelta_%7Bj%7D%5E%7B%5C%2Cq%7D%20%5Cright)%20%5C%2C%20u_%7Bq%7D%20%5C%2C%20u%5Ej%20%3D%20%5Cdelta_%7Bj%7D%5E%7B%5C%2Cm%7D%20%5C%2C%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cq%7D%20%5C%2C%20u_%7Bq%7D%20%5C%2C%20u%5Ej%20-%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cm%7D%20%5C%2C%20%5Cdelta_%7Bj%7D%5E%7B%5C%2Cq%7D%20%5C%2C%20u_%7Bq%7D%20%5C%2C%20u%5Ej%20%3D" alt="\ left (\ delta_ {j} ^ {\, m} \, \ delta_ {k} ^ {\, q} - \ delta_ {k} ^ {\, m} \, \ delta_ {j} ^ {\, q} \ right) \, u_ {q} \, u ^ j = \ delta_ {j} ^ {\, m} \, \ delta_ {k} ^ {\, q} \, u_ {q} \, u ^ j - \ delta_ {k} ^ {\, m} \, \ delta_ {j} ^ {\, q} \, u_ {q} \, u ^ j ="></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%3D%20u%5Em%20%5C%2C%20u_%7Bk%7D%20-%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cm%7D%20%5C%2C%20u%5Eq%20%5C%2C%20u_%7Bq%7D%20%3D%20u%5Em%20%5C%2C%20u_%7Bk%7D%20-%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cm%7D%20%5Cquad%20(2)" alt="= u ^ m \, u_ {k} - \ delta_ {k} ^ {\, m} \, u ^ q \, u_ {q} = u ^ m \, u_ {k} - \ delta_ {k} ^ {\, ‚Äã‚Äãm} \ quad (2)"></div><br>  And all because convolution of the tensor with the Kronecker delta leads to the replacement of the silent tensor index by the free Kronecker delta index, for example <img src="https://tex.s2cms.ru/svg/%5Cdelta_%7Bk%7D%5E%7B%5C%2Cq%7D%20%5C%2C%20u_%7Bq%7D%20%3D%20u_%7Bk%7D" alt="\ delta_ {k} ^ {\, q} \, u_ {q} = u_ {k}">  .  Acting in this way, and taking into account that the vector <img src="https://tex.s2cms.ru/svg/%5Cvec%7Bu%7D" alt="\ vec {u}">  has a length equal to one, which means convolution <img src="https://tex.s2cms.ru/svg/u%5E%7Bq%7D%20%5C%2C%20u_%7Bq%7D%20%3D%201" alt="u ^ {q} \, u_ {q} = 1">  we get (2).  Then the rotation tensor expression looks even simpler. <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/B_k%5E%7B%5C%2Cm%7D%20%3D%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)u%5E%7B%5C%2Cm%7D%20%5C%2C%20u_%7B%5C%2Ck%7D%20%2B%20%5Ccos%5Cvarphi%20%5C%2C%20%5Cdelta_%7Bk%7D%5E%7B%5C%2Cm%7D%20%2B%20%5Csin%5Cvarphi%20%5C%2C%20g%5E%7Bmi%7D%20%5C%2C%20U_%7Bik%7D%20%5Cright%20%5Cquad%20(3)" alt="B_k ^ {\, m} = \ left (1 - \ cos \ varphi \ right) u ^ {\, m} \, u _ {\, k} + \ cos \ varphi \, \ delta_ {k} ^ {\ , m} + \ sin \ varphi \, g ^ {mi} \, U_ {ik} \ right \ quad (3)"></div><br>  just the expression that I have long and tediously tried to derive in the <a href="http://habrahabr.ru/post/262263/">seventh article</a> .  Which again confirms the rule that nothing can be studied in half ... <br><br>  For what I did it all.  First, finally rehabilitated in the eyes of readers.  Secondly - so that we have something to compare the results that we get below with the help of Maxima.  And thirdly, to say that on expression (3) our sweet life ends and the hell of monstrous transformations begins. <br><br><h1>  2. We use Maxima to derive the angular velocity tensor </h1><br>  The <code>itensor</code> module, the documentation for which is presented in the <a href="http://maxima.sourceforge.net/docs/manual/maxima_25.html">original</a> , <a href="">translated into Russian</a> , and <a href="http://www.researchgate.net/publication/235217371____Maxima">another book</a> based on documentation, is responsible for working with abstract tensors in Maxima. <br><br>  We start Maxima, even in the console, even using one of its graphic frontends, and we write <br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">kill</span></span>(all); <span class="hljs-keyword"><span class="hljs-keyword">load</span></span>(itensor); imetric(g); idim(3);</code> </pre><br>  Here we clean the memory (the <code>kill()</code> function), removing all definitions and loaded modules from it, load the <code>itensor</code> package (the <code>load()</code> function), say that the metric tensor will be called <code>g</code> (the <code>imetric()</code> function), and also we indicate the dimension of the space ( <code>idim()</code> function), because by default, the SKA considers that it works in 4-dimensional space-time with the Riemann metric.  We are working in the three-dimensional space of classical mechanics, and our metric is any non-degenerate torsion-free. <br><br>  Enter the rotation tensor <br><pre> <code class="hljs matlab">B:ishow( u([],[l])*g([<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>,k],[])*u([],[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]) - <span class="hljs-built_in"><span class="hljs-built_in">cos</span></span>(phi)*<span class="hljs-string"><span class="hljs-string">'levi_civita([],[l,q,i])*u([q],[])*'</span></span>levi_civita([<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>,<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>,k],[])*u([],[<span class="hljs-built_in"><span class="hljs-built_in">j</span></span>]) + <span class="hljs-built_in"><span class="hljs-built_in">sin</span></span>(phi)*g([],[l,<span class="hljs-built_in"><span class="hljs-built_in">i</span></span>])*<span class="hljs-string"><span class="hljs-string">'levi_civita([i,j,k])*u([],[j]))$</span></span></code> </pre><br>  In <code>itensor</code> tensors are declared by an identifier, after which the lists of covariant and contravariant indices are indicated in brackets, separated by commas.  The <code>levi_civita()</code> function sets the Levi-Civita tensor, and the prime in front of it means that this tensor does not need to be calculated.  Maxima is known for her way of calculating and simplifying expressions if it is possible, and if the stroke is not set, then the Levi-Civita tensor will turn into a ‚Äúpumpkin‚Äù, and specifically, an attempt will be made to define it through the generalized Kronecker delta, which is not our plan. <br><br>  The <code>$</code> symbol is an alternative to the semicolon and prohibits the display of conversion results.  We will use <code>ishow()</code> to display the information.  The expression inserted into it is displayed on the screen in the usual index notation for recording tensors.  On the screen it looks like this <br><br><img src="https://habrastorage.org/files/fd0/2b4/1f6/fd02b41f61554fa9bdd89b2dc2b2f121.png"><br><br>  Moreover, we introduce its non-simplified form, with a double vector product, without introducing an antisymmetric tensor <img src="https://tex.s2cms.ru/svg/%5Cmathbf%7BU%7D" alt="\ mathbf {U}">  so that at the first stage we obtain (3) and check how the machine simplifies tensor expressions.  In human form, this expression looks like this. <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/g_%7Bj%5C%2Ck%7D%5C%2Cu%5E%7Bl%2Bj%7D-%5Cvarepsilon_%7Bi%5C%2Cj%5C%2Ck%7D%5C%2C%5Ccos%20%5CPhi%5C%2C%5Cvarepsilon%5E%7Bi%20%5C%2Cl%5C%2Cq%7D%5C%2Cu_%7Bq%7D%5C%2Cu%5E%7Bj%7D%2Bg%5E%7Bi%5C%2Cl%7D%5C%2C%5Cvarepsilon_%7Bi%5C%2Cj%5C%2Ck%7D%5C%2C%5Csin%20%5CPhi%5C%2Cu%20%5E%7Bj%7D" alt="g_ {j \, k} \, u ^ {l + j} - \ varepsilon_ {i \, j \, k} \, \ cos \ Phi \, \ varepsilon ^ {i \, l \, q} \, u_ {q} \, u ^ {j} + g ^ {i \, l} \, \ varepsilon_ {i \, j \, k} \, \ sin \ Phi \, u ^ {j}"></div><br>  although the sum of the indices in the first term leads to suspicions of some special magic that is unknown to us.  But this output is generated directly by Maxima, using the spell <br><pre> <code class="hljs lisp">load(<span class="hljs-name"><span class="hljs-name">tentex</span></span>)<span class="hljs-comment"><span class="hljs-comment">; tentex(B);</span></span></code> </pre><br>  which allows you to get the output in the form of code LaTeX.  Among the shortcomings - shamanism with indices and a capital letter indicating the angle of rotation, but both are correctable in principle, and Maxima pleased me with the fact that it generates a TeX output that is not as redundant as, for example, Maple. <br><br>  Go ahead.  Next we recall the expression that determines the angular velocity through the tensor of rotation <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5COmega_%7B%5C%2Cmk%7D%20%3D%20g_%7B%5C%2Cmp%7D%20%5C%2C%20B_%7Bl%7D%5E%7B'%5C%2Cp%7D%20%5C%2C%20%5Cdot%7BB%7D_%7Bk%7D%5E%7B%5C%2Cl%7D%20%5Cquad%20(4)" alt="\ Omega _ {\, mk} = g _ {\, mp} \, B_ {l} ^ {'\, p} \, \ dot {B} _ {k} ^ {\, l} \ quad (4)"></div><br>  Now imagine that we have to differentiate (3) by time, then multiply the derivative by the inverse matrix (3) and the metric tensor.  This can be done manually, but if I had brought this process to the end, the stack of sheets on the table would be three times thicker. <br><br>  First, simplify the introduced rotation tensor. <br><pre> <code class="hljs">B:ishow(expand(lc2kdt(B)))$</code> </pre><br>  The function <code>lc2kdt()</code> designed specifically to simplify expressions containing the Levi-Civita tensor.  She tries to minimize this tensor where it is possible, giving a combination of sums and works of Kronecker's deltas.  So the result looks like <br><br><img src="https://habrastorage.org/files/8a7/382/d15/8a7382d1546143c7819350234ef13729.png"><br><br>  The <code>expand()</code> function is also applied to the <code>lc2kdt()</code> result, which expands the parentheses.  Without this, Maxima performs the convolution very reluctantly. <br><br>  Now we will try to calculate the resulting expression by performing a convolution.  The <code>contract()</code> function is one of the most reliable ways to perform convolution. <br><pre> <code class="hljs">B01:ishow(contract(B))$</code> </pre><br>  At the output we get (where possible, I will bring LaTeX output generated by Maxima using the <code>tentex()</code> function) <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cdelta_%7Bk%7D%5E%7Bl%7D%5C%2C%5Ccos%20%5CPhi%5C%2Cu_%7Bq%7D%5C%2Cu%5E%7Bq%7D-u_%7Bk%7D%5C%2C%5Ccos%20%5CPhi%5C%2Cu%5E%7Bl%7D%2Bu_%7B%20k%7D%5C%2Cu%5E%7Bl%7D%2Bg%5E%7Bi%5C%2Cl%7D%5C%2C%5Cvarepsilon_%7Bi%5C%2Cj%5C%2Ck%7D%5C%2C%5Csin%20%5CPhi%5C%2Cu%5E%7Bj%7D" alt="\ delta_ {k} ^ {l} \, \ cos \ Phi \, u_ {q} \, u ^ {q} -u_ {k} \, \ cos \ Phi \, u ^ {l} + u_ {k } \, u ^ {l} + g ^ {i \, l} \, \ varepsilon_ {i \, j \, k} \, \ sin \ Phi \, u ^ {j}"></div><br>  which is similar to expression (3).  This convinced me of the correctness of the program and the correctness of their own actions.  So you can move on. <br><br>  The only thing that does not take into account Maxima is that the vector around which the rotation is made has a length equal to one.  Therefore, it does not minimize the expression <img src="https://tex.s2cms.ru/svg/u%5E%7Bq%7D%20%5C%2C%20u_%7Bq%7D" alt="u ^ {q} \, u_ {q}">  in the scalar.  I didn‚Äôt think up how to tell him about it and didn‚Äôt read it in the documentation, although I searched it carefully.  In the future, this will give serious difficulties, which we will discuss, but for the time being I got out with the help of a crutch, replacing the uncomfortable tensors with a unit <br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">B01:</span></span>ishow(subst(<span class="hljs-number"><span class="hljs-number">1</span></span>, u([],[q]), B01))$ <span class="hljs-symbol"><span class="hljs-symbol">B01:</span></span>ishow(subst(<span class="hljs-number"><span class="hljs-number">1</span></span>, u([q],[]), B01))$</code> </pre><br>  The expression of the rotation tensor through the parameters of the final rotation has the pleasant property that obtaining an inverse matrix is ‚Äã‚Äãreduced to the substitution in (3) of the angle of rotation with the opposite sign.  Indeed, turning in the other direction is the inverse transformation.  This can be proved strictly mathematically, based on the properties of the rotation matrix.  I have done this and consider it redundant in this article.  Just get the inverse transform tensor <br><pre> <code class="hljs">B10:ishow(subst(-phi, phi, B01))$</code> </pre><br><img src="https://habrastorage.org/files/3c8/a21/c54/3c8a21c54e454aa0a7d3d4961be2d038.png"><br><br>  Since we are going to take the derivative, Maxima needs to know which tensors and numerical parameters depend on time.  We indicate that the direction of the axis of rotation and the angle of rotation depend on time <br><pre> <code class="hljs lisp">depends([u,phi], <span class="hljs-literal"><span class="hljs-literal">t</span></span>)<span class="hljs-comment"><span class="hljs-comment">;</span></span></code> </pre><br>  To make our tensors correspond to formula (4), we will rename the indices <br><pre> <code class="hljs ruby"><span class="hljs-symbol"><span class="hljs-symbol">B10:</span></span>ishow(subst(p,l,B1<span class="hljs-number"><span class="hljs-number">0</span></span>))$ <span class="hljs-symbol"><span class="hljs-symbol">B10:</span></span>ishow(subst(l,k,B1<span class="hljs-number"><span class="hljs-number">0</span></span>))$ <span class="hljs-symbol"><span class="hljs-symbol">B10:</span></span>ishow(subst(i1,i,B1<span class="hljs-number"><span class="hljs-number">0</span></span>))$ <span class="hljs-symbol"><span class="hljs-symbol">B10:</span></span>ishow(subst(j1,j,B1<span class="hljs-number"><span class="hljs-number">0</span></span>))$ <span class="hljs-symbol"><span class="hljs-symbol">B10:</span></span>ishow(subst(s,q,B1<span class="hljs-number"><span class="hljs-number">0</span></span>))$</code> </pre><br><img src="https://habrastorage.org/files/5cf/5b0/b43/5cf5b0b43fe74aa09f1680cbf4fc6374.png"><br><br>  Thus, we changed the names of free indices, for correct multiplication in (4), and redefined the names of dumb indices.  According to the rules, it is assumed that the names of dumb indices in the multiplied tensors do not coincide. <br><br>  Now we take the time derivative of the rotation tensor <br><pre> <code class="hljs">dBdt:ishow(diff(B01,t))$</code> </pre><br>  getting out <br><br><img src="https://habrastorage.org/files/046/0cc/da6/0460ccda65b94bacadbb791449c6c97b.png"><br><br>  We are convinced that the differentiation was performed correctly.  Finally, we introduce formula (4), applying successively opening the brackets and simplification, taking into account the Levi-Civita tensor <br><pre> <code class="hljs markdown">exp1:ishow(lc2kdt(expand(g([m,p],[])<span class="hljs-emphasis"><span class="hljs-emphasis">*B10*</span></span>dBdt)))$</code> </pre><br>  What is the result, scary to show, but if you please <br><br><img src="https://habrastorage.org/files/333/213/8b8/3332138b878348879ff25c1deb7021aa.png"><br><br>  Understand anything in this mess is difficult.  But it is clear that the Kronecker delta combinations (the <code>kdelta()</code> function sets the Kronecker delta of any desired rank) with a strange designation of mute indices containing the number after <code>%</code> .  The fact is that Maxima, when converting, numbers the dumb indices.  Let's try to simplify it all. <br><br>  First, once again, we use the expression through simplification, taking into account the Levi-Civita tensor ( <code>lc2kdt()</code> ).  Then we perform the convolution ( <code>contract()</code> ).  After that, we will try to simplify our ‚Äúcrocodile‚Äù by applying the <code>canform()</code> function to it, which performs the numbering of the silent indices and the simplification of the tensor.  This feature is recommended by developers to perform simplifications. <br><pre> <code class="hljs">exp2:ishow(canform(contract(lc2kdt(exp1))))$</code> </pre><br>  As a result, we observe a serious slimming "crocodile" <br><br><img src="https://habrastorage.org/files/7b2/671/7ea/7b26717ea6624fc5a8ab6f3ee6ef2f63.png"><br><br>  But!  In the first term, we see the vector product of the orth axis of the axis of rotation on itself, and it must be equal to zero.  Maxima has not yet understood this, she must point out the possibility of such a simplification.  We make it a construction <br><pre> <code class="hljs">exp3:ishow(canform(contract(expand(applyb1(exp2,lc_l,lc_u)))))$</code> </pre><br>  The <code>applyb1()</code> function sets the rules for simplifying the subexpressions included in the simplified expression.  An expression and a list of rules are passed as arguments.  We have two rules: <code>lc_l</code> and <code>lc_u</code> are rules for converting subexpressions with the Levi-Civita symbol with lower ( <code>lc_l</code> ) and upper ( <code>lc_u</code> ) indices.  At the same time, we again open parentheses that may appear after transforming subexpressions, perform convolution and simplification.  As a result, we observe another reduction in the crocodile mass <br><br><img src="https://habrastorage.org/files/23d/b87/ba3/23db87ba310c47d5b19866aefb335ba5.png"><br><br>  Perhaps this is not the limit.  But I was surprised, probably due to ignorance and lack of experience following <br><ol><li>  Pay attention to the variable <code>kdelta</code> .  Experiments with Maxima made it possible to find out that this is a trace of the Kronecker delta of 2 ranks, equal to the dimension of space (the trace of the identity matrix).  In our case, this number is "3".  The three must stand in place of <code>kdelta</code> .  But for some reason it is not worth it; perhaps the configuration variables of the tensor package are somehow incorrectly configured.  If we take <code>kdelta</code> equal to three, then a bunch of various sign like terms is formed, which together give zero. <br></li><li>  All convolutions of the form <br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/u%5E%7Bi%7D%20%5C%2C%20u_%7Bi%7D" alt="u ^ {i} \, u_ {i}"></div><br>  This is the module of the orth of rotation, but it does not change and is equal to one.  How to say about this Maxima for me has not yet been clarified. <br></li><li>  It follows from the previous problem, for <br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/u%5Ei%20%5C%2C%20u_i%20%3D%201" alt="u ^ i \, u_i = 1"></div><br>  which means <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cdot%20u%5E%7Bi%7D%20%5C%2C%20u_%7Bi%7D%20%2B%20u%5E%7Bi%7D%20%5C%2C%20%5Cdot%20u_%7Bi%7D%20%3D%200%22" alt="\ dot u ^ {i} \, u_ {i} + u ^ {i} \, \ dot u_ {i} = 0 &amp; quot;"></div><br>  where, by virtue of the commutativity of the operation of scalar multiplication, we have <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5Cdot%20u%5E%7Bi%7D%20%5C%2C%20u_%7Bi%7D%20%3D%200%2C%20%5Cquad%20u%5E%7Bi%7D%20%5C%2C%20%5Cdot%20u_%7Bi%7D%20%3D%200%22" alt="\ dot u ^ {i} \, u_ {i} = 0, \ quad u ^ {i} \, \ dot u_ {i} = 0 &amp; quot;"></div><br>  The last expressions are often found in the above result. <br></li></ol><br>  I would be extremely grateful for the hint of those who know about the above problems, because studying the documentation has not yet shed light on the solution.  The replacement function <code>subst()</code> does not work here. <br><br>  In this regard, I again took up pen and paper in order to ‚Äúsupplement‚Äù the angular velocity tensor.  But Maxima has greatly facilitated my task, for which she thanks. <br><br><h1>  3. With a pen, paper, file and tambourine ... </h1><br>  We write out all nonzero terms, we give similar ones, we put the common factors out of the brackets.  Surprisingly, everything beautifully and quickly collapses into the formula <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%0A%5COmega_%7B%5C%2Ckm%7D%20%3D%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)%5Cleft(%5Cdot%20u_%7B%5C%2Ck%7D%20%5C%2C%20u_%7B%5C%2Cm%7D%20-%20u_%7B%5C%2Ck%7D%20%5C%2C%20%5Cdot%20u_%7B%5C%2Cm%7D%5Cright%20)%20%2B%20%5Csin%5Cvarphi%20%5C%2C%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)%20%5C%2C%20u%5E%7B%5C%2Ci%7D%20%5Cleft(%20%5Cvarepsilon_%7B%5C%2Cijk%7D%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cj%7D%20%5C%2C%20u_%7B%5C%2Cm%7D%20-%20%5Cvarepsilon_%7B%5C%2Cilm%7D%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cl%7D%20%5C%2C%20u_%7B%5C%2Ck%7D%20%5Cright%20)%20%2B" alt="\ Omega _ {\, km} = \ left (1 - \ cos \ varphi \ right) \ left (\ dot u _ {\, k} \, u _ {\, m} - u _ {\, k} \, \ dot u _ {\, m} \ right) + \ sin \ varphi \, \ left (1 - \ cos \ varphi \ right) \, u ^ {\, i} \ left (\ varepsilon _ {\, ijk} \, \ dot u ^ {\, j} \, u _ {\, m} - \ varepsilon _ {\, ilm} \, \ dot u ^ {\, l} \, u _ {\, k} \ right) +"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%2B%20%5Csin%5Cvarphi%20%5Ccos%5Cvarphi%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cj%7D%20%5Cvarepsilon_%7B%5C%2Cjkm%7D%20%2B%20%5Cdot%5Cvarphi%20%5C%2C%20%5Cvarepsilon_%7B%5C%2Cikm%7D%20%5C%2C%20u%5E%7Bi%7D%20%5Cquad%20(5)" alt="+ \ sin \ varphi \ cos \ varphi \, \ dot u ^ {\, j} \ varepsilon _ {\, jkm} + \ dot \ varphi \, \ varepsilon _ {\, ikm} \, u ^ {i} \ quad (five)"></div><br>  This expression painfully resembles, a similar one, obtained for an orthogonal basis and expressed in a matrix form. <br><br>  <em>Pogorelov D. Yu. Introduction to modeling the dynamics of systems of bodies.</em>  <em>Page</em>  <em>31.</em> <br><img src="https://habrastorage.org/files/9b8/54d/9c9/9b854d9c9f0a433a878d82a3c6d6c5c1.png"><br><br>  The tensor (5) is antisymmetric, we rearrange the indices, changing the signs of the corresponding expressions.  The first term is the difference of covariant tensor products, the second is the first transposed, and this sum gives an antisymmetric tensor at the output.  The remaining terms contain the Levi-Civita tensor, which changes sign when the indices are interchanged. <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5COmega_%7B%5C%2Cmk%7D%20%3D%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)%5Cleft(%5Cdot%20u_%7B%5C%2Cm%7D%20%5C%2C%20u_%7B%5C%2Ck%7D%20-%20u_%7B%5C%2Cm%7D%20%5C%2C%20%5Cdot%20u_%7B%5C%2Ck%7D%5Cright%20)%20%2B%20%5Csin%5Cvarphi%20%5C%2C%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)%20%5C%2C%20u%5E%7B%5C%2Ci%7D%20%5Cleft(%20%5Cvarepsilon_%7B%5C%2Cilk%7D%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cl%7D%20%5C%2C%20u_%7B%5C%2Cm%7D%20-%20%5Cvarepsilon_%7B%5C%2Cijm%7D%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cj%7D%20%5C%2C%20u_%7B%5C%2Ck%7D%20%5Cright%20)%20%2B" alt="\ Omega _ {\, mk} = \ left (1 - \ cos \ varphi \ right) \ left (\ dot u _ {\, m} \, u _ {\, k} - u _ {\, m} \, \ dot u _ {\, k} \ right) + \ sin \ varphi \, \ left (1 - \ cos \ varphi \ right) \, u ^ {\, i} \ left (\ varepsilon _ {\, ilk} \, \ dot u ^ {\, l} \, u _ {\, m} - \ varepsilon _ {\, ijm} \, \ dot u ^ {\, j} \, u _ {\, k} \ right) +"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/-%20%5Csin%5Cvarphi%20%5Ccos%5Cvarphi%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cj%7D%20%5Cvarepsilon_%7B%5C%2Cjmk%7D%20-%20%5Cdot%5Cvarphi%20%5C%2C%20%5Cvarepsilon_%7B%5C%2Cimk%7D%20%5C%2C%20u%5E%7Bi%7D" alt="- \ sin \ varphi \ cos \ varphi \, \ dot u ^ {\, j} \ varepsilon _ {\, jmk} - \ dot \ varphi \, \ varepsilon _ {\, imk} \, u ^ {i}"></div><br>  And once again, rearrange the indices in the last two terms. <br><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%5COmega_%7B%5C%2Cmk%7D%20%3D%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)%5Cleft(%5Cdot%20u_%7B%5C%2Cm%7D%20%5C%2C%20u_%7B%5C%2Ck%7D%20-%20u_%7B%5C%2Cm%7D%20%5C%2C%20%5Cdot%20u_%7B%5C%2Ck%7D%5Cright%20)%20%2B%20%5Csin%5Cvarphi%20%5C%2C%20%5Cleft(1%20-%20%5Ccos%5Cvarphi%20%5Cright%20)%20%5C%2C%20u%5E%7B%5C%2Ci%7D%20%5Cleft(%20%5Cvarepsilon_%7B%5C%2Cilk%7D%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cl%7D%20%5C%2C%20u_%7B%5C%2Cm%7D%20-%20%5Cvarepsilon_%7B%5C%2Cijm%7D%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cj%7D%20%5C%2C%20u_%7B%5C%2Ck%7D%20%5Cright%20)%20%2B" alt="\ Omega _ {\, mk} = \ left (1 - \ cos \ varphi \ right) \ left (\ dot u _ {\, m} \, u _ {\, k} - u _ {\, m} \, \ dot u _ {\, k} \ right) + \ sin \ varphi \, \ left (1 - \ cos \ varphi \ right) \, u ^ {\, i} \ left (\ varepsilon _ {\, ilk} \, \ dot u ^ {\, l} \, u _ {\, m} - \ varepsilon _ {\, ijm} \, \ dot u ^ {\, j} \, u _ {\, k} \ right) +"></div><br><div style="text-align:center;"><img src="https://tex.s2cms.ru/svg/%2B%20%5Csin%5Cvarphi%20%5Ccos%5Cvarphi%20%5C%2C%20%5Cvarepsilon_%7B%5C%2Cmjk%7D%20%5C%2C%20%5Cdot%20u%5E%7B%5C%2Cj%7D%20%2B%20%5Cdot%5Cvarphi%20%5C%2C%20%5Cvarepsilon_%7B%5C%2Cmik%7D%20%5C%2C%20u%5E%7Bi%7D%20%5Cquad%20(6)" alt="+ \ sin \ varphi \ cos \ varphi \, \ varepsilon _ {\, mjk} \, \ dot u ^ {\, j} + \ dot \ varphi \, \ varepsilon _ {\, mik} \, u ^ {i} \ quad (6)"></div><br>  so that their convolution gives skew-symmetric matrices, which are customary for the representation of the vector product in the matrix form. <br><br>  A further simplification (6) is possible if we take the base as Cartesian.  Then the covariant and contravariant components coincide, the nonzero elements of the Levi-Chevita tensor modulo become equal to one, and (6) can be simplified a little more.  We got this expression for an arbitrary basis. <br><br><h1>  Conclusion </h1><br>  So, thanks to Maxima tensor tools, I finally figured out the task of expressing the angular velocity tensor through the parameters of the final rotation.  And at the same time showed the reader a living example of working with tensors in the SKA. <br><br>  Next time, we will obtain from (6) the pseudovectors of angular velocity and angular acceleration and closely approach the tensor description of the kinematics of a solid body. <br><br>  Thank you for attention! <br><br>  <a href="http://habrahabr.ru/post/262957/">To be continued‚Ä¶</a> </div><p>Source: <a href="https://habr.com/ru/post/262801/">https://habr.com/ru/post/262801/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../262789/index.html">New DNS Server Features in Windows Server Technical Preview 2</a></li>
<li><a href="../262791/index.html">Making the code cleaner: Nuances of debugging output in Linux drivers</a></li>
<li><a href="../262793/index.html">Tax gopher. Features of the simplified tax system when working under contracts with Apple, Google and others</a></li>
<li><a href="../262795/index.html">Are developers of a programming conference needed?</a></li>
<li><a href="../262797/index.html">Video of reports from the conference "Russian Internet Technologies 2015"</a></li>
<li><a href="../262803/index.html">How to "feel" the results of software asset management and be satisfied</a></li>
<li><a href="../262805/index.html">C ++ 11/14/17 features in Visual Studio 2015 RTM</a></li>
<li><a href="../262807/index.html">Notes on distributed systems for beginners</a></li>
<li><a href="../262809/index.html">How can artificial intelligence be used to solve SEO problems?</a></li>
<li><a href="../262813/index.html">How to make beautiful documentation for the Web API, for which it will not be a shame</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>