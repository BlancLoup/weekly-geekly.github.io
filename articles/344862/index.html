<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tests alone are not enough, good architecture is needed.</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="We all understand what automatic tests are. We are developing software, and we want it to solve some user problems. Having written the test, we are co...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tests alone are not enough, good architecture is needed.</h1><div class="post__text post__text-html js-mediator-article">  We all understand what automatic tests are.  We are developing software, and we want it to solve some user problems.  Having written the test, we are convinced that a specific problem is solved by a specific piece of code.  Then the requirements change, we change the tests and change the code in accordance with the new requirements.  But it does not always save.  In addition to high test coverage, our code should be designed in such a way as to protect the developer from errors even while writing it. <br><br>  In the article, I tried to describe one of the problems that a good architecture can solve: related code sections can disperse among themselves, this can lead to bugs, and tests here will not save.  A good design can help. <br><a name="habracut"></a><br><h3>  Life example </h3><br>  We are developing marketing CRM-system for the aggregation of data buyers online stores.  In this platform, you can use the API to load orders, and then analyze what consumers are buying, what can be recommended, and the like.  You also need to be able to see in the interface the change history for each order. <br><br>  To begin with, we will present our domain model. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We have buyers, orders and order items.  The buyer may have many orders, the order may have many lines.  Each line contains the base price per item, price per line, quantity, product ID, link to the order in which the line is contained, and the line status (for example, ‚Äúcompleted‚Äù or ‚Äúcanceled‚Äù).  The order contains the order ID of the customer, the date and time of the order, the cost of the order, taking into account all discounts, shipping costs, a link to the store purchase, as well as a link to the consumer. <br>  We also have the requirement to view the order change history and the ban on deleting order data that was once loaded to us.  As a result, the following class structure is obtained: <br><br><div class="spoiler">  <b class="spoiler_title">Customer</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Customer</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Email { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Order</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Order</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ExternalId {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICollection&lt;OrderHistoryItem&gt; History {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;} }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Historical order status</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OrderHistoryItem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ICollection&lt;OrderHistoryLine&gt; OrderLines {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Order Order { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime OrderChangeDateTime { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> TotalAmountAfterDiscounts { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Customer Customer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> DeliveryCost { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ShopExternalId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Order Item</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OrderHistoryLine</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> BasePricePerItem { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OrderHistoryItem OrderHistoryItem { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> PriceOfLine { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> Quantity { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Status { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ProductExternalId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br></div></div><br>  Order (Order) - an aggregate, which may include many historical order states (OrderHistoryItem), each of which contains lines (OrderHistoryLine).  Thus, when changing an order, we will save its status before and after the change.  In this case, the current state of the order can always be obtained by ordering the historical state by time and taking the first one. <br><br>  Now we will describe the format of the API request that our customers could use to transfer orders: <br><br><div class="spoiler">  <b class="spoiler_title">API format</b> <div class="spoiler_text"><pre> <code class="hljs css">{ <span class="hljs-attribute"><span class="hljs-attribute">id</span></span>: ‚Äú<span class="hljs-number"><span class="hljs-number">123</span></span>‚Äù, customer: { id: <span class="hljs-number"><span class="hljs-number">1</span></span> }, <span class="hljs-selector-tag"><span class="hljs-selector-tag">dateTimeUtc</span></span>: ‚Äú21<span class="hljs-selector-class"><span class="hljs-selector-class">.08</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.2017</span></span> 11<span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:11</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:11</span></span>‚Äù, <span class="hljs-selector-tag"><span class="hljs-selector-tag">totalAmountAfterDiscounts</span></span>: 2000, <span class="hljs-selector-tag"><span class="hljs-selector-tag">shop</span></span>: ‚Äú<span class="hljs-selector-tag"><span class="hljs-selector-tag">shop-moscow</span></span>‚Äù, <span class="hljs-selector-tag"><span class="hljs-selector-tag">deliveryCost</span></span>: 0, <span class="hljs-selector-tag"><span class="hljs-selector-tag">items</span></span>: <span class="hljs-selector-attr"><span class="hljs-selector-attr">[{ basePricePerItem: 100, productId: ‚Äú456‚Äù, status: ‚ÄúPaid‚Äù, quantity: 20, priceOfLineAfterDiscounts: 2000 }]</span></span> }</code> </pre> <br></div></div><br>  Imagine that we implemented this API and wrote tests on it.  Our clients began to use it, and we realized the problem. <br><br>  The fact is that our API implies a fairly simple integration from the client (for example, an online store).  It is assumed that the order data transfer service should be called by the client for each order change on its side.  This reduces the complexity of integration, since there is no logic other than translation on the client side. <br>  However, it happens that our system is indifferent to some changes in orders that occur in the client system, since they are of no interest to marketing and analytics.  Such changes to the order on our side simply will not be anything different. <br><br>  In addition, there may be situations when, due to some network errors, the client uses our service several times for the same order change, and we save them all.  To defeat network plan errors, when the same transaction is transmitted several times, you can use the idempotency key, but it will not help to solve the problem of insignificant changes.  We really don't want to keep several order changes in business if they are no different. <br><br>  No sooner said than done.  Solution to the forehead: let's write a code that, when a new order changes, will among the already existing changes of the same order look for exactly the same, and if it exists, it simply will not save another one.  The code will look something like this (if you don‚Äôt think about hash optimizations): <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveOrder</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem historyItem</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (historyItem.Order.IsNew) { SaveOrderCore(historyItem.Order); SaveOrderHistoryCore(historyItem); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> doesSameHistoryItemExist = historyItem.Order.History .Where(h =&gt; h != historyItem) .Where(h =&gt; h.IsEquivalent(historyItem)) .Any(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doesSameHistoryItemExist) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; SaveOrderHistoryCore(historyItem); }</code> </pre> <br>  In this code, we go through all the historical records of the order and look for the same using the IsEquivalent method.  At the same time, IsEquivalent should compare each field of the order, and then look for the corresponding order lines and compare each field of these lines.  A naive implementation might look like this: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem otherHistoryItem</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> IsTotalPriceEquivalent(otherHistoryItem) &amp;&amp; IsDeliveryCostEquivalent(otherHistoryItem) &amp;&amp; IsShopEquivalent(otherHistoryItem) &amp;&amp; AreLinesEquivalent(otherHistoryItem); }</code> </pre> <br><h3>  Tests do not save </h3><br>  OrderHistoryItem.IsEquivalent is a fairly simple function, it is fairly easy to test.  Having written tests on it, we will make sure that the business requirement is being fulfilled that prohibits creating several identical states of the same order. <br><br>  However, there is a problem here, which is that in enterprise-systems, like the one we have just talked about, there is quite a lot of code.  Our company has 5 teams of 5 developers, we all develop the same product, and even at such scales it is quite difficult to organize the work so that each person in each team understands the subject area of ‚Äã‚Äãeach product feature well.  In principle, this is not very necessary, since teams are divided into features, but sometimes features intersect, and then difficulties arise.  The problem I'm talking about is the complexity of a large system, where there are many components that need to be interconnected. <br><br>  Imagine that you want to add another field to your order: type of payment. <br>  Fix the OrderHistoryItem class: <br><br><div class="spoiler">  <b class="spoiler_title">class OrderHistoryItem with added PaymentType property</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">OrderHistoryItem</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Order Order { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> DateTime OrderChangeDateTime { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> TotalAmountAfterDiscounts { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Customer Customer { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> DeliveryCost { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ShopExternalId { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PaymentType {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;<span class="hljs-keyword"><span class="hljs-keyword">set</span></span>;} }</code> </pre><br></div></div><br>  In addition, we must add the ability to transfer the type of payment to our service. <br><br>  Have we not forgotten anything?  Oh, yes, we need to fix IsEquivalent.  And this is very sad, since the feature ‚Äúnot to create duplicates of the same order changes‚Äù is quite invisible, it is difficult to remember about it.  Will the product owner write about how we should consider the type of payment when comparing orders?  Will the architect of this feature remember this?  Will the programmer think about this, who will implement the type of payment and add it to the service?  After all, if no one remembers this, then <b>no test will fall</b> , and in a situation where an order change comes to us, first with one type of payment, and then with another, the second change will not be saved. <br><br>  One of the most important criteria for the quality of the selected application architecture is the ease of application modification for changing business requirements.  Also, one of the pillars of developing non-trivial software is reducing complexity.  The problem, which I described above, is connected with high complexity and possibility of changes.  In short, the architecture should be one in which it would be impossible to forget about the need to somehow compare each of the properties of the order change history. <br><br><h3>  Declarative strategies as a way out </h3><br>  We wrote an imperative code to check the properties of the order, which is easy to test, but difficult to analyze.  Let's try to take advantage of the declarative approach.  Now the IsEquivalent method inside calls IsTotalPriceEquivalent, IsDeliveryCostEquivalent, etc. methods.  We introduce the interface of the comparison strategy of the order property IOrderHistoryItemPropertyEqualityStrategy: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IOrderHistoryItemPropertyEqualityStrategy</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArePropertiesEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem firstOrderHistoryItem, OrderHistoryItem secondOrderHistoryItem</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre> <br>  Let's do an implementation instead of each comparison method in IsEquivalent: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TotalPriceOrderHistoryItemPropertyEqualityStrategy</span></span> : <span class="hljs-title"><span class="hljs-title">IOrderHistoryItemPropertyEqualityStrategy</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArePropertiesEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem firstOrderHistoryItem, OrderHistoryItem secondOrderHistoryItem</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstOrderHistoryItem.TotalAmountAfterDiscounts == secondOrderHistoryItem.TotalAmountAfterDiscounts; } }</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DeliveryCostOrderHistoryItemPropertyEqualityStrategy</span></span> : <span class="hljs-title"><span class="hljs-title">IOrderHistoryItemPropertyEqualityStrategy</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArePropertiesEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem firstOrderHistoryItem, OrderHistoryItem secondOrderHistoryItem</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstOrderHistoryItem.DeliveryCost == secondOrderHistoryItem.DeliveryCost; } }</code> </pre> <br>  and make the comparison more declarative: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem otherHistoryItem</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TotalPriceOrderHistoryItemPropertyEqualityStrategy().ArePropertiesEquivalent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, otherHistoryItem) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeliveryCostOrderHistoryItemPropertyEqualityStrategy().ArePropertiesEquivalent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, otherHistoryItem) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ShopOrderHistoryItemPropertyEqualityStrategy().ArePropertiesEquivalent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, otherHistoryItem) &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinesOrderHistoryItemPropertyEqualityStrategy().ArePropertiesEquivalent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, otherHistoryItem); }</code> </pre> <br>  A little refactorim: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IOrderHistoryItemPropertyEqualityStrategy[] equalityStrategies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TotalPriceOrderHistoryItemPropertyEqualityStrategy(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DeliveryCostOrderHistoryItemPropertyEqualityStrategy(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ShopOrderHistoryItemPropertyEqualityStrategy(), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LinesOrderHistoryItemPropertyEqualityStrategy() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem otherHistoryItem</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> equalityStrategies.All(strategy =&gt; strategy.ArePropertiesEquivalent(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, otherHistoryItem)) }</code> </pre> <br>  Now, when adding a new property, you need to create a new property comparison strategy and add it to the array.  So far, nothing has changed, we are still not protected from the error.  But due to the fact that the code has become declarative, we can check something.  It would be great to be able to figure out for which property which strategy is responsible.  Then we could get all the properties at the order and check that they are all covered with strategies.  And it's pretty easy to modify.  Add the PropertyName property to the strategy interface and implement it in each of the strategies: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">IOrderHistoryItemPropertyEqualityStrategy</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PropertyName {<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>;} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArePropertiesEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem firstOrderHistoryItem, OrderHistoryItem secondOrderHistoryItem</span></span></span><span class="hljs-function">)</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">TotalPriceOrderHistoryItemPropertyEqualityStrategy</span></span> : <span class="hljs-title"><span class="hljs-title">IOrderHistoryItemPropertyEqualityStrategy</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PropertyName =&gt; <span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(OrderHistoryItem.TotalAmountAfterDiscounts); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArePropertiesEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem firstOrderHistoryItem, OrderHistoryItem secondOrderHistoryItem</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> firstOrderHistoryItem.TotalAmountAfterDiscounts == secondOrderHistoryItem.TotalAmountAfterDiscounts; } }</code> </pre> <br>  Now we will write a check: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CheckOrderHistoryEqualityStrategies</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> historyItemPropertyNames = <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(OrderHistoryItem) .GetProperties() .Select(p =&gt; p.Name); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> equalityStrategiesPropertyNames = equalityStrategies .Select(es =&gt; es.PropertyName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> propertiesWithoutCorrespondingStrategy = historyItemPropertyNames .Except(equalityStrategiesPropertyNames) .ToArray(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!propertiesWithoutCorrespondingStrategy.Any()) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> missingPropertiesString = <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">", "</span></span>, propertiesWithoutCorrespondingStrategy); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">$"  </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{missingPropertiesString}</span></span></span><span class="hljs-string">     "</span></span>); }</code> </pre> <br>  Now it‚Äôs enough to write a test for this check, and you can be sure that we forget something.  Separately, I note that the implementation shown is not complete.  First, the properties that do not need to be compared are not taken into account.  For them, you can use the following implementation of the strategy: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">NoCheckOrderHistoryItemPropertyEqualityStrategy</span></span> : <span class="hljs-title"><span class="hljs-title">IOrderHistoryItemPropertyEqualityStrategy</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> propertyName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NoCheckOrderHistoryItemPropertyEqualityStrategy</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.propertyName = propertyName; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> PropertyName =&gt; propertyName; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ArePropertiesEquivalent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OrderHistoryItem firstOrderHistoryItem, OrderHistoryItem secondOrderHistoryItem</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br>  Secondly, it is not shown how to make such a strategy for complex properties, such as lines.  Since this is done quite similarly, you can think it out yourself. <br><br>  In addition, adherence to defensive programming can suggest that it is worth checking that there is not more than one strategy registered for each property, and also that there are no registered strategies for unknown properties.  But these are details. <br><br><h3>  Other examples </h3><br><h4>  Consumer removal </h4><br>  Another example of a similar problem was the ‚Äúconsumer removal‚Äù functionality.  The problem with deletion was that quite a lot of things are connected with the consumer in our system, and when deleting you need to think about all the entities with which consumers are connected, perhaps indirectly through other entities, and this functionality also had to be polymorphic, because end customers may have more entities than in the main product. <br><br>  As you can see, the problem is the same: if you add a new entity or even just some kind of link and forget about the fact that there is a deletion, you can get a bug in the production of an FK violation when trying to delete. <br><br>  The solution is similar: a relatively complex reflexive code is quite possible to bypass the entire data model, including in the final implementations for a particular client, at the start of the application.  In this model, find which entities are related to consumers in some way.  After this, look for whether deletion strategies are registered for all of these entities, and if something is not present, simply fall. <br><br><h4>  Providers of recalculation time filtering conditions </h4><br>  Another example of the same problem: register filtering conditions.  We have a fairly flexible filter constructor in the UI: <br><br><img src="https://habrastorage.org/webt/ud/4z/nw/ud4znwjiidtwnlhw6-iyn0g3p5a.png"><br><br>  These filters are used both for filtering virtually all entities on the pages of the lists, as well as for setting up all sorts of automatically triggered mechanics - triggers. <br>  The trigger works like this: every 15 minutes, it selects all consumers on which it should work, using the complex filtering condition collected in the designer, and processes them in turn, sending them a letter, awarding points or giving out some kind of prize or discount. <br><br>  Over time, it became clear that this approach needs to be optimized, because there are many triggers, there are many consumers, and every 15 minutes it‚Äôs hard to choose them all.  Optimization, which suggested itself - let's not check consumers who have not changed, we will only look at changed consumers each time.  This would be a completely valid approach if it were not for one thing: some filtering conditions become true for the consumer not because something happened to him, but because the time just came.  Such conditions are all sorts of temporary conditions, such as ‚Äúthere are less than 5 days left before the birthday‚Äù. <br><br>  We identified all the filtering conditions, the truth of which may change from time to time, and decided that they should tell us the time during which it makes sense to recount them.  Roughly speaking, if we count in days, then it makes sense to recount every 12 hours, if in hours - then every hour. <br><br>  The problem is that the module, in which our filtering conditions are defined, is one of the most basic, and we would not like it to think about what the time for recalculation should be.  Therefore, the interface for obtaining the recalculation time for the filtering condition is separated from the filtering conditions themselves, and we again find ourselves in a situation where, when creating a new filtering condition, we can easily forget that it requires specifying the recalculation time. <br><br>  The solution is the same as before.  We have an application initialization stage when filtering conditions are added.  After that there is a stage when recalculation time providers are added for filtering conditions in another module.  After that, it is critical to verify that for all filtering conditions such providers are registered.  In no case can not rely on the default behavior: if the provider receiving the time is not registered, assume that the filter does not require recalculation.  This feature is very tempting, because refactoring in this situation looks much simpler: you need to register providers only for those filtering conditions that were selected.  If you choose this approach, you can save time now, but then someone will write a new filtering condition for time, forget about writing a time provider for recalculation for it, and a trigger with this filtering condition will not actually work. <br><br><h3>  Finally </h3><br>  That's all.  I tried to explain in the article my own vision of the problem of ‚Äúunwritten code‚Äù.  Unfortunately, we cannot verify the absence of any code in this way, we need to repel something, look for some inconsistencies in the configuration of a large system, and fall, fall, fall, as long as they exist. <br><br>  Try to make the architecture impenetrable, so that if used improperly, it always curses, so you can protect yourself from unpleasant mistakes in battle.  Try not to compromise with reliability: if you need to refactor a lot of code, in order to reduce the risks later, then you should still spend time. </div><p>Source: <a href="https://habr.com/ru/post/344862/">https://habr.com/ru/post/344862/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../344848/index.html">Irreparable consequences of HolyJS 2017 Moscow</a></li>
<li><a href="../344852/index.html">How to make friends with Skype and proxy</a></li>
<li><a href="../344856/index.html">Two analyst competencies</a></li>
<li><a href="../344858/index.html">Parcel - write plugin</a></li>
<li><a href="../344860/index.html">Morning Watch, or join Radio Robinhood</a></li>
<li><a href="../344864/index.html">Security variables in Kotlin for example Java</a></li>
<li><a href="../344866/index.html">Solving Open Day CrackMe, task Pizza</a></li>
<li><a href="../344868/index.html">Go there, I do not know where: in the wake of the conference SmartData</a></li>
<li><a href="../344872/index.html">RFC for wimps or the story of a single investigation</a></li>
<li><a href="../344876/index.html">JUnit logging tests</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>