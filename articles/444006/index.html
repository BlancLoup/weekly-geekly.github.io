<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Retro game console do it yourself</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is an introduction to my project of a "self-made" console video set-up made from scratch. I was inspired by both retro consoles and modern d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Retro game console do it yourself</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/getpro/habr/post_images/0b1/45a/7c0/0b145a7c0f4c0821cdb77654ef2a8cd3.jpg" alt="image"></p><br><p>  This post is an introduction to my project of a "self-made" console video set-up made from scratch.  I was inspired by both retro consoles and modern designs, but I had my own architecture.  My friends constantly told me that I should tell about my project, and not do everything exclusively ‚Äúfor myself,‚Äù so I publish this post. </p><a name="habracut"></a><br><p>  <strong>Attention, this is a translation</strong> </p><br><h1 id="kak-vsyo-nachalos">  How it all began </h1><br><p>  My name is Sergio Vieira (S√©rgio Vieira) I grew up in Portugal in the 80s and 90s, I have a long time nostalgia for retro gaming, especially for third and fourth generation consoles. </p><br><p>  A few years ago, I decided to get a better look at electronics and try to make my own console. </p><br><p>  I am a programmer by profession and have not had any experience as an electronics engineer, except for (and should not be considered) independent upgrades of my destkop. </p><br><p>  Although I didn‚Äôt have experience, I said to myself ‚Äúwhy not?‚Äù I bought several books, several sets of electronics and began to study based on my feelings about what exactly is worth studying. </p><br><p>  I wanted to make a console similar to those that make me feel nostalgic, I wanted something between <a href="https://wikipedia.org/wiki/Nintendo_Entertainment_System">NES</a> and <a href="https://wikipedia.org/wiki/Super_Nintendo_Entertainment_System">Super Nintendo</a> , or maybe between <a href="https://wikipedia.org/wiki/Master_System">Sega Master System</a> and <a href="https://wikipedia.org/wiki/Sega_Genesis">Mega Drive</a> . </p><br><p>  These consoles had a CPU, an original video chip (at that time they weren't called GPUs yet) and an audio chip, sometimes built-in, and sometimes external. </p><br><p>  The games were distributed on cartridges, which in general were extensions of iron, sometimes just ROM chips, and sometimes had additional components. </p><br><p>  The original plan was to make a prefix with the following characteristics: </p><br><ul><li>  Without emulation, games and programs should work on real hardware, not necessarily the same from those times, but fast enough for the task, and nothing more. </li><li>  With a real retro CPU. </li><li>  With analog TV output. </li><li>  With sound </li><li>  With support for two controllers </li><li>  Back scrolling and sprite animation </li><li>  With features to support platform games like Mario, and of course all sorts of other games. </li><li>  With the download of games and programs from SD cards. </li></ul><br><p>  Why SD cards, and not cartridges, well, basically just so much more practical, you can copy them from a computer.  And cartridges would mean, firstly, more iron in the console, and secondly, to produce iron for each program. </p><br><h1 id="proizvodstvo">  Production </h1><br><h2 id="video-signal">  Video signal </h2><br><p>  The first thing I do is generate a video signal. </p><br><p>  Any console from the period I took as the model had different proprietary graphics chips, which means they all had different specifications. <br>  For this reason, I didn‚Äôt want to use a ready-made graphics chip, I also wanted my console to have unique graphics specifications.  And since I could not make my own graphics chip, and at that time I could not use FPGA, I decided to limit myself to software generation of a graphic signal using an 8-bit, 20 MHz microcontroller. </p><br><p>  This is not overkill, and just enough powerful solution for graphics of the level that was interesting to me. </p><br><p>  And so, I started using the Atmega644 microcontroller on a clean 20 MHz to generate a <a href="https://wikipedia.org/wiki/PAL">PAL</a> video signal for the TV.  I had to <a href="https://ru.wikipedia.org/wiki/Bit-banging">beat the PAL</a> protocol, since the chip itself does not know how to do it. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/8ee/74d/d7b8ee74dbd4c844e65f2a1766e33a0a.jpg" alt="imageVPU Test 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/96b/d85/e5c/96bd85e5c323152604a68bb3c8341f69.jpg" alt="imageVPU Test 2"></p><br><p>  The microcontroller produces an 8-bit color (RGB332, 3 bits red, 3 bits green and 2 blue) and a passive DAC converts it all to RGB.  Fortunately, in Portugal, almost all TVs are equipped with a SCART connector and they support RGB input. </p><br><h2 id="pravilnaya-graficheskaya-podsistema">  The right graphics subsystem </h2><br><p>  Since the microcontroller is quite powerful, and I decided to use it exclusively for generating the video signal (I called it the VPU - Video Processing Unit), I decided to organize a double-buffer at the same time. </p><br><p>  It turned out that the second microcontroller (PPU, Picture Processing Unit, Atmega1284 chip is also 20 MHz) generated a picture in RAM chip number 1 (I called it VRAM1), and the first one at the same time sent the contents of the second chip (VRAM2) to the TV. </p><br><p>  After one frame, and two frames in the PAL system are 1/25 seconds, VPU switches VRAMs and they change places, PPU generates a picture in VRAM2, and VPU dumps VRAM1 to a TV output. </p><br><p>  The video card was very complicated because I had to use external hardware so that both microcontrollers could use both memory modules and to speed up access to RAM, because there is also bit-banging, so I had to add 74 series chips as counters, line selectors, transceivers, etc. . </p><br><p>  Firmware for VPU and PPU also turned out cumbersome because I had to write a lot of code to get the maximum speed out of the graphics.  At first everything was written in assembler, then a part was rewritten in C. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a2/43d/c87/7a243dc873ceaf16fe0e2d183d388dd1.jpg" alt="imageVideo Board 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a9/c59/cca/2a9c59cca5b2d64f25abdfd2f59912e5.jpg" alt="imageVideo Board 2"></p><br><p>  As a result, PPU generates a 224x192 pixel image, which is then sent to TV via VPU.  The resolution may seem low to you, but actually it is almost as much as the console of that time actually had, usually 256x224.  Somewhat lower resolution allowed me to add more features that the system manages to calculate per frame. </p><br><p>  As in the old days, PPU has its own hard mechanics which must be able to use.  The substrate (backing) is rendered from 8x8 pixel characters, also called tiles.  It turns out that the size of the background is 28x24 tiles. </p><br><p>  So that the backside can be scrolled smoothly, pixel by pixel, I made it so that there are 4 virtual screens each, each with 28x24 tiles that go in memory sequentially and wrapped around each other, in the picture it is clearer. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/666/41c/c14/66641cc14e799a0e4269d4b130490465.png" alt="imageBackground"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/500/971/e16/500971e169f1364520eb5004529cca3e.png" alt="imageVirtual Background"></p><br><p>  On top of the background, PPU can render 64 <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D1%2580%25D0%25B0%25D0%25B9%25D1%2582_(%25D0%25BA%25D0%25BE%25D0%25BC%25D0%25BF%25D1%258C%25D1%258E%25D1%2582%25D0%25B5%25D1%2580%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25B3%25D1%2580%25D0%25B0%25D1%2584%25D0%25B8%25D0%25BA%25D0%25B0)">sprites</a> that can be 8 or 16 pixels in height or width, that is, 1, 2 or 4 tiles and can still be flip horizontally and / or vertically. </p><br><p>  On top of the backup, you can still render an overlay of one 28x6 tile buffer, this was intended to draw HUDs, speeds so as not to interfere with the main sprites and scrolling backups. </p><br><p> One "advanced" feature is that the back can be scrolled not entirely, but each line separately, which allows all sorts of interesting effects like split screen or near- <a href="https://ru.wikipedia.org/wiki/Parallax_mapping">parallax</a> . </p><br><p>  There is also an attribute table that allows you to set a value from 0 to 3 for each tile, and then all tiles with one attribute can be set to a page of tiles or to increment their symbolic value.  This is convenient when there are parts of the back-up that need to be changed regularly and the CPU does not have to cheat each tile individually; all you need to do is say something like: "all tiles with an attribute 1 increment the numeric value of your character by 2", such things implemented by different technicians can Observe, for example, in block tiles in Mario where the question mark is animated or in games where there is a waterfall in which all tiles are constantly changing creating the effect of falling water. </p><br><h2 id="cpu">  CPU </h2><br><p>  When my video card was working, I started working with the CPU as which <a href="https://ru.wikipedia.org/wiki/Zilog_Z80">Zilog 80</a> was chosen for my console. </p><br><p>  One of the reasons why the Z80 was chosen, well, besides the fact that it is a cool retro CPU, is its ability to address two 16-bit spaces, one for memory and one for input / output ports, the equally legendary <a href="https://ru.wikipedia.org/wiki/MOS_Technology_6502">6502</a> , for example, cannot , it can only address one 16-bit space, and it is necessary to load both memory and various external devices, video, audio, joysticks, hardware random number generator, etc. into it.  It is more convenient to have two address spaces, one completely given to 64 kilobytes of code and data in memory and the second to access external devices. </p><br><p>  First, I connected the CPU to the EEPROM in which my test program was located and connected it via I / O space to the microcontroller that I installed so that you can communicate with my computer via <a href="https://ru.wikipedia.org/wiki/RS-232">RS232</a> , and monitor how the CPU works and everything else.  This Atmega324 microcontroller operating at 20 MHz I call the IO MCU - the input / output microcontroller unit, it is responsible for controlling access to the game controllers (joysticks), the SD card reader, the <a href="https://ru.wikipedia.org/wiki/PS/2_(%25D0%25BF%25D0%25BE%25D1%2580%25D1%2582)">PS / 2</a> keyboard and the communicator via RS232. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0e9/3fa/89a/0e93fa89aa467f7d400b032ba4932c1c.jpg" alt="imageCPU Board 1"></p><br><p>  The CPU is connected to a memory chip of 128 kilobytes, of which only 56 kilobytes are available, which is of course nonsense, but I could only get chips of 128 or 32 kilobytes.  It turned out that the memory consists of 8 kilobytes of ROM and 56 kilobytes of RAM. </p><br><p>  After that, I updated the firmware IO MCU with the help of <a href="http://www.roland-riegel.de/sd-reader/">this library</a> and I have added support for SD cards. </p><br><p>  Now the CPU could walk through directories, watch what was in them, open and read files.  All this is done by writing and reading to certain I / O space addresses. </p><br><h2 id="podklyuchenie-cpu-k-ppu">  CPU connection to PPU </h2><br><p>  The next thing I did was the connection between the CPU and PPU.  To do this, I applied a "simple solution" which consisted in the acquisition of dual-port RAM, this is such a RAM chip that can be connected directly to two different buses.  This allows him to get rid of additional chips like line selectors and, moreover, allows almost simultaneous access to memory from both chips.  Another PPU can directly access the CPU on each frame by activating its <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25B5%25D1%2580%25D1%258B%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">non-maskable interrupts</a> .  It turns out that the CPU receives an interrupt on each frame, which is useful for different timing tasks and for understanding when it's time to update graphics. </p><br><p>  Each frame of interaction between the CPU, PPU and VPU occurs according to the following scheme: </p><br><ol><li>  PPU copies information from PPU memory to internal memory. </li><li>  The PPU sends an interrupt signal to the CPU. </li><li>  At the same time: <br><ul><li>  The CPU jumps to the interrupt function and starts updating the PPU memory with a new graphical state.  The program should return from interrupt to the next frame. </li><li>  PPU renders a picture based on the information previously copied to one of the VRAM. </li><li>  VPU sends a picture from another VRAM to the TV output. </li></ul></li></ol><br><p>  About that time I started supporting game controllers, at first I wanted to use Nintendo controllers, but the sockets for them are proprietary and generally difficult to find, so I stopped at 6-button controllers compatible with Mega Drive / Genesis, they have standard DB-9 sockets which is everywhere. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9ed/e06/12a/9ede0612a51808d0d5e92c5765e9f4fd.jpg" alt="imageJoint Board 1"></p><br><h2 id="napisanie-pervoy-nastoyaschey-igry">  Writing the first real game </h2><br><p>  At that time, I already had a CPU capable of controlling PPU, working with joysticks, reading SD cards ... it was time to <a href="">write the first game</a> , of course, on the Z80 assembler, it took me a few days to spend my free time. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2Pcrg1fesBk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="dobavlyaem-dinamicheskuyu-grafiku">  Add dynamic graphics </h2><br><p>  Everything was super, I had my own game console, but this was not enough for me, because I had to use the graphics of the PPU in memory in the game and it was impossible to draw tiles for a particular game and it was possible to change it only by flashing the ROM.  I began to think how to add more memory so that the CPU could load symbols for tiles into it, and then PPU could read it all from there and how to do it easier since the prefix was already complex and big. </p><br><p>  And I came up with the following: only the PPU will have access to this new memory, and the CPU will load the data through the PPU there and while this boot process is in progress, this memory cannot be used for drawing, but at that time it will be possible to draw from the ROM. </p><br><p>  After the end of the CPU load, the internal memory will be switched to this new memory, which I called Character RAM (CHR-RAM) and in this mode PPU will start drawing dynamic graphics, this is probably not the best solution, but it works.  As a result, the new memory was installed 128 kilobytes and can store 1024 characters of 8x8 pixels each for the background and as many characters for the sprites. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ff8/47a/b6b/ff847ab6b2ae65bd21c0426283d2c6a7.jpg" alt="imageJoint Board 2"></p><br><h2 id="i-nakonec-zvuk">  And finally the sound </h2><br><p>  Hands reached the sound last.  At first I wanted a sound like the one in <a href="http://uzebox.org/">Uzebox</a> , that is, the microcontroller would generate 4 channels of PWM sound. </p><br><p>  However, it turned out that I can easily get vintage chips and I ordered several <a href="https://ru.wikipedia.org/wiki/FM-%25D1%2581%25D0%25B8%25D0%25BD%25D1%2582%25D0%25B5%25D0%25B7">FM synthesis</a> chips YM3438, these guys are fully compatible with the <a href="https://ru.wikipedia.org/wiki/Yamaha_YM2612">YM2612</a> that were used in Mega Drive / Genesis.  By installing them, you can get music quality Mega Drive and sound effects produced by the microcontroller. </p><br><p>  I installed another microcontroller and called it SPU (Sound Processor Unit), it controls the YM3438 and can generate sounds itself.  The CPU manages it through two-port memory, this time it is only 2 kilobytes. </p><br><p>  As in the graphics unit, the sound unit has 128 kilobytes of memory for storing PCM samples and sound patches, the CPU loads the data into this memory by referring to the SPU.  It turned out that the CPU either tells the SPU to execute commands from this memory or updates the commands for the SPU every frame. </p><br><p>  The CPU manages four PWM channels through the four circular buffers in the SPU's memory.  SPU passes through these buffers and executes commands written to them.  There is also one such buffer for the FM synthesis chip. </p><br><p>  So, as in the graph, the interaction between the CPU and the SPU goes according to the scheme: </p><br><ol><li>  SPU copies data from SPU memory to internal memory. </li><li>  SPU is waiting for the PPU interrupt signal (this is for synchronization) </li><li>  At the same time <br><ul><li>  The CPU updates the PWM channel buffers and FM synthesizer buffers. </li><li>  SPU executes commands in buffers according to the data in the internal memory. </li><li>  At the same time with all this, SPU updates the PWM sounds at 16 kilohertz. </li></ul></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d83/946/43e/d8394643e24f2c0771493bfbe1081157.jpg" alt="imageSound Board 1"></p><br><h1 id="chto-vyshlo-v-itoge">  What happened in the end </h1><br><p>  After all the blocks were ready, some went to the mockups. <br>  For the CPU unit, I was able to develop and order a custom PCB, I don‚Äôt know if it‚Äôs worth it for the other modules, I think I was really lucky that my PCB started working right away. </p><br><p>  On the breadboard, now only sound remains. <br>  Here is how it looks today: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b1/41e/828/5b141e82873999d9ce5a327d77770133.jpg" alt="imageConsole 1"></p><br><h2 id="arhitektura">  Architecture </h2><br><p>  The diagram illustrates the components in each block and how they interact with each other.  The only thing that is not shown is the signal from the PPU to the CPU on each frame in the form of an interrupt and the same signal that goes to the SPU. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b3a/9d1/4cbb3a9d121465d904518aceaee47045.png" alt="imageArchitecture"></p><br><ul><li>  CPU: Zilog Z80 at 10 MHz </li><li>  CPU-ROM: 8KB EEPROM, contains bootloader code </li><li>  CPU-RAM: 128KB RAM (56KB available), code and data for programs / games </li><li>  IO MCU: Atmega324, is the interface between the CPU and RS232, PS / 2 keyboard, joysticks and SD card file system </li><li>  PPU-RAM: 4 kilobytes of dual-port memory, intermediate memory between CPU and PPU </li><li>  CHR-RAM: 128KB RAM, stores dynamic tiles for backups (underlays) and sprites (in characters of 8x8 pixels). </li><li>  VRAM1, VRAM2: 128KB RAM (43008 is really available), are used for the framebuffer in them it writes PPU and reads VPU from them. </li><li>  PPU (Picture Processing Unit): Atmega1284, draws a frame into the framebuffer. </li><li>  VPU (Video Processing Unit): Atmega324, reads the framebuffer and generates the RGB and PAL signal and sync. </li><li>  SPU-RAM: 2KB dual-port RAM, serves as an interface between the CPU and the SPU. </li><li>  SNDRAM: 128KB RAM, stores PWM patches, PCM samples and instruction blocks for the FM synthesizer. </li><li>  YM3438: YM3438, FM synthesis chip. </li><li>  SPU (Sound Processing Unit): Atmega644, generates sounds on the principle of pulse-width modulation (PWM) and controls the YM3438. </li></ul><br><h2 id="okonchatelnye-specifikacii">  Final specifications </h2><br><p>  <strong>CPU:</strong> </p><br><ul><li>  8-bit CPU Zilog Z80 at a frequency of 10Mhz. </li><li>  8KB ROM for bootloader. </li><li>  56KB RAM. </li></ul><br><p>  <strong>IO:</strong> </p><br><ul><li>  Reading data from FAT16 / FAT32 SD card reader. </li><li>  Read / write to RS232 port. </li><li>  2 MegaDrive / Genesis-compatible gaming controllers. </li><li>  Keyboard PS2. </li></ul><br><p>  <strong>Video:</strong> </p><br><ul><li>  The resolution is 224x192 pixels. </li><li>  25 frames per second (half FPS from PAL). </li><li>  256 colors (RGB332). </li><li>  2x2 virtual substrate (448x384 pixels), with bidirectional pixel scrolling, based on four full-screen pages. </li><li>  64 sprites with a width and height of 8 or 16 pixels with the possibility of both vertical and horizontal flip. </li><li>  The substrate and sprites are made up of characters of 8x8 pixels each. </li><li>  Symbolic video memory for 1024 characters for the background and 1024 for sprites. </li><li>  64 independent horizontal scrolling along specified lines </li><li>  8 independent vertical scrolling on specified lines </li><li>  An overlay of 224x48 pixels with an optional transparency on the color key. </li><li>  The attribute table of the background. </li><li>  RGB and composite PAL via SCART connector. </li></ul><br><p>  <strong>Sound:</strong> </p><br><ul><li>  PWM on 8 bits and 4 channels, with built-in waveforms: square, sine, saw, noise and so on. </li><li>  Samples of 8 bits, 8 kHz in one of the PWM channels. </li><li>  Chip FM synthesis YM3438 downloadable instructions at a frequency of 50 hertz. </li></ul><br><h1 id="razrabotka-dlya-pristavki">  Console Development </h1><br><p>  For the console was written loader.  The loader is placed in the CPU ROM and can take up to 8 kilobytes.  It uses the first 256 bytes of RAM.  The loader is the first thing the CPU executes.  It is necessary to show the program located on the SD card. </p><br><p>  These programs are in files that contain compiled code and may also contain graphics and sound. </p><br><p>  After selecting a program, it is loaded into the CPU memory, the CHR memory and the SPU memory.  Then the program code is executed.  The maximum size of the code loaded into the console is 56 kilobytes, except for the first 256 bytes, and of course you need to take into account the space for the stack and data. <br>  And this bootloader and other programs written for this console were created in the same way described below. </p><br><h2 id="memoryio-mapping">  Memory / IO Mapping </h2><br><p>  What is important when developing for this console is to take into account how the CPU accesses various blocks, and correctly allocate the address space of the input-output and the address space of the memory. </p><br><p>  The CPU accesses the operational and permanent memory of the loader through the memory address space. </p><br><p>  Memory address space <br><img src="https://habrastorage.org/getpro/habr/post_images/f37/a98/86a/f37a9886acd53a6204b02a3f11b190b6.png" alt="imageMemory Mapping"></p><br><p>  And to PPU-RAM, SPU-RAM and IO MCU through the I / O address space. </p><br><p>  I / O address space <br><img src="https://habrastorage.org/getpro/habr/post_images/799/634/0c0/7996340c05682ff9eb4d060e6cc361c1.png" alt="imageIO Mapping"></p><br><p>  As can be seen from the table, addresses for all devices, IO MCU, PPU and SPU are allocated inside the address space of the I / O. </p><br><h2 id="upravlenie-ppu">  PPU control </h2><br><p>  From the information in the table it is clear that to manage the PPU, it is necessary to write to the PPU memory which is available at addresses 1000h-1FFFh in the I / O address space. </p><br><p>  PPU Address Space Allocation </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/304/1ca/ab33041ca0ac1a8d427cae75dcb736ff.png" alt="imagePPU Mapping"></p><br><p>  PPU Status can have the following values: </p><br><ol><li>  Embedded graphics mode </li><li>  Dynamic Graphics Mode (CHR-RAM) </li><li>  CHR write mode </li><li>  Recording is completed, waiting for confirmation mode from the CPU </li></ol><br><p>  Here, for example, how to work with sprites: <br>  The prefix can draw 64 sprites at the same time.  Data on them is available through the CPU through the address space I / O address 1004h-1143h (320 bytes), for each sprite has 5 bytes of information (5 * 64 = 320): </p><br><ol><li>  Bytes of different flags, each bit of this byte flag: Active, Flipped_X, Flipped_Y, PageBit0, PageBit1, AboveOverlay, Width16, Height16. </li><li>  The character byte, character number from the table (defined by the flags above). </li><li>  Color key byte (i.e. what color is transparency) </li><li>  X coordinate byte </li><li>  Y coordinate byte </li></ol><br><p>  In total, to see the sprite, you need to set the Active flag to 1, and set the X and Y coordinates within sight, the 32/32 coordinates put the sprite in the upper left corner of the screen, smaller values ‚Äã‚Äãhide it or make it partially visible. </p><br><p>  Then we can set the character code and transparency color. </p><br><p>  For example, if we need to show the sprite number 10, then the address will be 4145 (1004h + (5 x 9)), we write the value 1 for activation and coordinates, for example, x = 100 and y = 120, we write at 4148 the value 100 and by address 4149 is 120. </p><br><h2 id="ispolzuem-assembler">  We use the assembler </h2><br><p>  One of the programming methods for the console is an assembler. </p><br><p>  Here's an example of how to show one sprite and animate it so that it moves and repels from the edges of the screen. </p><br><pre><code class="plaintext hljs">ORG 2100h PPU_SPRITES: EQU $1004 SPRITE_CHR: EQU 72 SPRITE_COLORKEY: EQU $1F SPRITE_INIT_POS_X: EQU 140 SPRITE_INIT_POS_Y: EQU 124 jp main DS $2166-$ nmi: ;    (NMI) ld bc, PPU_SPRITES + 3 ld a, (sprite_dir) and a, 1 jr z, subX in a, (c) ;  X inc a out (c), a cp 248 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a jp updateY subX: in a, (c) ;  X dec a out (c), a cp 32 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a updateY: inc bc ld a, (sprite_dir) and a, 2 jr z, subY in a, (c) ;  Y inc a out (c), a cp 216 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a jp moveEnd subY: in a, (c) ;  Y dec a out (c), a cp 32 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a moveEnd: ret main: ld bc, PPU_SPRITES ld a, 1 out (c), a ;   0 inc bc ld a, SPRITE_CHR out (c), a ;    0 inc bc ld a, SPRITE_COLORKEY out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_X out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_Y out (c), a ;   Y  0 mainLoop: jp mainLoop sprite_dir: DB 0</code> </pre> <br><p>  <strong><em>Use of C language</em></strong> </p><br><p>  You can also use the C language, for this we need the SDCC compiler and some additional utilities. </p><br><p>  The C code may be slower, but it‚Äôs faster and easier to write. </p><br><p>  Here is an example of code that does the same thing as the assembler code above, which uses a library that helps make calls to the PPU: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;console.h&gt; #define SPRITE_CHR 72 #define SPRITE_COLORKEY 0x1F #define SPRITE_INIT_POS_X 140 #define SPRITE_INIT_POS_Y 124 struct s_sprite sprite = { 1, SPRITE_CHR, SPRITE_COLORKEY, SPRITE_INIT_POS_X, SPRITE_INIT_POS_Y }; uint8_t sprite_dir = 0; void nmi() { if (sprite_dir &amp; 1) { sprite.x++; if (sprite.x == 248) { sprite_dir ^= 1; } } else { sprite.x--; if (sprite.x == 32) { sprite_dir ^= 1; } } if (sprite_dir &amp; 2) { sprite.y++; if (sprite.y == 216) { sprite_dir ^= 2; } } else { sprite.y--; if (sprite.x == 32) { sprite_dir ^= 2; } } set_sprite(0, sprite); } void main() { while(1) { } }</span></span></span></span></code> </pre> <br><h2 id="dinamicheskaya-grafika">  Dynamic graphics </h2><br><p>  (In the original Custom graphics. Approx. Lane.) </p><br><p>  In the ROM, the prefix is ‚Äã‚Äãprotected by 1 page of tiles for the back-up and another page of ready-made sprites), by default you can only use this fixed schedule, but you can switch to dynamic. </p><br><p>  My goal was to ensure that all the necessary graphics in binary form were immediately loaded into the CHR RAM, and the code in the bootloader from the ROM can do this.  To do this, I made several pictures of the correct size with different useful characters: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ed7/636/39c/ed763639cda1cf8ba163c3c30d2f0ec7.png" alt="imageSample tile components"></p><br><p>  Since the dynamic graphics memory consists of 4 pages of 256 characters of 8x8 pixels each and 4 pages of the same characters for sprites, I translated the pictures into PNG format, deleted duplicate identical ones: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/052/39d/5e9/05239d5e93c3578b8b720eedbc1c9169.png" alt="imageSample character sheet"></p><br><p>  And then I used samopisnuyu tulzu to translate it all into a binary format RGB332 with blocks of 8x8. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a4c/8e7/4c6/a4c8e74c68c44e8f0f122002ebb021da.png" alt="imageGraphics command line"></p><br><p>  As a result, we have files with characters, where all characters go successively one after another and each occupies 64 bytes. </p><br><h2 id="zvuk">  Sound </h2><br><p>  Wave RAW samples are converted to 8-bit 8 kHz PCM samples. </p><br><p>  Patches for sound effects on PWM and music are written with special instructions. </p><br><p>  As for the Yamaha YM3438 FM synthesis chip, I found a program called DefleMask, which produces PAL-synchronized music intended for YM2612 chips from Genesis, which is compatible with YM3438. </p><br><p>  DefleMask exports music in VGM format and I will convert it with another self-written utility into my own binary format. </p><br><p>  All binaries of all three types of sound are combined into one binary file, which my loader can read and load into SDN RAM sound memory. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aee/fb5/fd5/aeefb5fd5918b0653557889b2b00972a.png" alt="imageSound command line"></p><br><h2 id="linkovka-okonchatelnogo-fayla">  Final File Link </h2><br><p>  The binary executable code, graphics and sound are combined into one PRG file.  The PRG file has a header in which everything is described, whether there is sound and image data, how much they occupy the data itself. </p><br><p>  Such a file can be written to the SD card and the prefix loader will read it and load everything into the appropriate places and run the executable program code. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/465/33e/43c/46533e43c8bca14c9cf9c36247b154eb.png" alt="imagePRG command line"></p><br><h2 id="emulyator">  Emulator </h2><br><p>  I wrote my C ++ emulator using <a href="https://www.wxwidgets.org/">wxWidgets</a> to make it easier to develop for it. </p><br><p>  The CPU is emulated by the <a href="https://github.com/ggambetta/libz80">libz80</a> library. </p><br><p>  Added features for debugging to the emulator, I can stop it at any time and do step-by-step debugging of the assembler, there is a mapping to the C source code if this language was used for the game. </p><br><p>  According to the graph, I can look in the video memory, in the character tables and in the CHR memory itself. </p><br><p>  Here is an example of a program running on an emulator with debugging tools enabled. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/090/b54/70d/090b5470d7476d47c7212452716e9d11.gif" alt="imageEmulator Demo"></p><br><h1 id="demka-programmirovaniya">  Programming demo </h1><br><p>  These videos were shot by a smartphone camera aimed at the CRT screen of the TV, I apologize for the non-ideal picture quality. </p><br><p>  BASIC interpreter programmable with PS / 2 keyboard, after the first program, I show how to write directly to the memory of the PPU through the I / O address space by activating and moving the sprite: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2UNjKx4uZGY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Graphics demo, in this video, 64 sprite 16x16 are programmatically jumping, against the background of a dynamic scrolling and overlay background that moves under and above sprites: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OA0q3_Krgxc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Sound demo shows the capabilities of YM3438 and PWM sound, the sound data of this demo and FM music and PWM sounds together occupy almost all available 128 kilobytes of sound memory. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xDsTGmqxLzM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tetris, almost all background features are used for graphics, music on YM3438, sound effects on PWM patches. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E77XZUwKd54" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="zaklyuchenie">  Conclusion </h1><br><p>  This project is truly a dream come true, I have been working on it for several years, with interruptions, looking at free time, I never thought that I would go so far in creating my own retro gaming video consoles.  Naturally, it is not perfect, I‚Äôm certainly not an expert in electronics, there were obviously too many elements in the console and undoubtedly it was possible to do better, and probably some readers think about it. </p><br><p>  But still, in the process of working on this project, I learned a lot about electronics, game consoles and computer design, assembly language and other interesting things, and most importantly I received great satisfaction in playing the games I myself wrote on hardware that I myself developed and collected. </p><br><p>  I have plans to do consoles / computers and more.  Actually, I am already doing a new set-top box, it is almost ready, and is a simplified retro set-up based on an FPGA board and a few additional components (much smaller than in this project, for sure), intended to be much cheaper and repeatable. </p><br><p>  Although I wrote a lot here about this project, there is undoubtedly much more to discuss, I barely mentioned how the sound engine works, how the CPU interacts with it, and about the graphics system and other inputs and outputs and about the entire console as a whole. it would tell. </p><br><p>  Looking at the reaction of the readers, I can write more articles focusing on updates, details about individual boxes of the console or other projects. </p><br><h2 id="proekty-sayty-kanaly-youtube-kotorye-vdohnovlyali-menya-i-pomogali-mne-s-tehnicheskimi-znaniyami">  Projects, sites, Youtube channels that inspired me and helped me with technical knowledge: </h2><br><p>  These sites / channels not only inspired, but also helped me find solutions to complex problems that arose in the course of working on this project. </p><br><ul><li>  <a href="http://uzebox.org/">Uzebox</a> </li><li>  <a href="http://benryves.com/">Ben ryves</a> </li><li>  <a href="http://blog.retroleum.co.uk/">Retroleum</a> </li><li>  <a href="http://www.z80.info/">Z80.info</a> </li><li>  <a href="https://www.youtube.com/channel/UC2DjFE7Xf11URZqWBigcVOQ">EEVBlog</a> </li><li>  <a href="https://www.youtube.com/channel/UCwRqWnW5ZkVaP_lZF7caZ-g">Retro Game Mechanics</a> </li></ul><br><p>  Thanks if you have read to here.  :) </p><br><p>  If you have questions or feedback, write in the <a href="https://internalregister.github.io/2019/03/14/Homebrew-Console.html">comments below</a> (Original article in English on Gitkhab. Note. Lane.) </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/444006/">https://habr.com/ru/post/444006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443994/index.html">US presidential candidate proposed to split the business of Amazon, Google and Facebook to stimulate competition</a></li>
<li><a href="../443998/index.html">New world record for calculating the number of pi: 31.4 trillion characters</a></li>
<li><a href="../444000/index.html">Where to start when recruiting for the first time</a></li>
<li><a href="../444002/index.html">At the IT-festival SXSW, the world's first ‚Äúgender-neutral‚Äù voice assistant is introduced.</a></li>
<li><a href="../444004/index.html">CLRium # 5: Everything is all about GC and not only. Peter and Moscow</a></li>
<li><a href="../444008/index.html">Google Play Store moves to standardize application icons</a></li>
<li><a href="../444018/index.html">As one configuration change, PostgreSQL improved the performance of slow queries 50 times.</a></li>
<li><a href="../444020/index.html">Karting in the USSR: how the passion of American pilots became a massive DIY hobby in the Soviet Union</a></li>
<li><a href="../444022/index.html">Beego is no longer Go</a></li>
<li><a href="../444024/index.html">How to implement a programming language in JavaScript. Part 3: CPS Interpreter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>