<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Architectural Patterns in iOS</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction to MVP, MVC, MVVM and VIPER. What is common between them and what is the difference. 

 Do everything in MVC, and it turns out ugly? Doub...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Architectural Patterns in iOS</h1><div class="post__text post__text-html js-mediator-article"><h3>  Introduction to MVP, MVC, MVVM and VIPER.  What is common between them and what is the difference. </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/files/b03/5f1/bc3/b035f1bc38454019ab1205428428ba57.jpeg"></div><br>  Do everything in MVC, and it turns out ugly?  Doubt whether to switch to MVVM?  Have you heard about VIPER, but are not sure whether it is worth it? <br><br>  In this article, I will briefly review some of the popular architectural patterns in iOS and compare them in theory and in practice.  You will find more information when clicking on the links indicated in the text. <br><a name="habracut"></a><br>  <i>Mastering patterns can be addictive, so be careful: in</i> <i><br></i>  <i>In the end, you may be asking yourself more questions than before reading this article, for example:</i> <i><br></i>  <i>- Who should own network requests: Model or Controller?</i> <i><br></i>  <i>- How can I transfer the Model to the ViewModel of the new View?</i> <i><br></i>  <i>- Who creates the new VIPER module: Router or Presenter?</i> <i><br></i> <br><div style="text-align:center;"><img src="https://habrastorage.org/files/c67/65a/014/c6765a01475b4f87a0a18aadb32b6dc6.png"></div><br><br><h3>  Why it is worth taking care of the choice of architecture? </h3><br>  Because if you do not do this, then one day, debugging a huge class with dozens of different methods and properties, you will not be able to find and correct mistakes in it.  Naturally, such a class is difficult to keep in mind as a whole, so you will always lose sight of any important details.  If you are already in this situation, then it is very likely that: <br><ul><li>  this class is a descendant of UIViewController; </li><li>  data is stored directly in UIViewController; </li><li>  UIView subclasses are not responsible for anything; </li><li>  Model is just a container for data; </li><li>  you are not doing unit tests. </li></ul><br>  And this can happen even if you follow Apple's recommendations and implement their <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">Cocoa MVC pattern</a> , so don't be upset.  ‚ÄúApple‚Äù <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html">MVC is</a> not all right, but we will return to it later. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      And now let's define the <b>signs of a</b> good architecture: <br><ul><li>  balanced <b>distribution of</b> responsibilities between entities with hard roles; </li><li>  <b>testability</b>  Usually it follows from the first feature (without panic, this is easy with the appropriate architecture); </li><li>  <b>ease of use</b> and low maintenance cost. </li></ul><br><h4>  Why distribution? </h4><br>  Distribution reduces the load on the brain when we try to figure out how this or that entity works.  If you think that the more you develop, the better the brain will adapt to understanding complex concepts - you are right.  But everything has a limit, and it is reached rather quickly.  Thus, the easiest way to reduce complexity is to divide responsibilities between multiple entities on the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">basis of shared responsibility</a> . <br><br><h4>  Why testability? </h4><br>  The testability of the architecture determines how easy it will be for us to write unit tests, and more often if we can write them in principle.  Is it worth testing at all?  As a rule, it is not a question for those who have <b>failed</b> unit tests after adding a new functionality or after refactoring some class subtleties.  This means that the tests have <b>saved the</b> developers from detecting problems in the runtime.  What could have happened to the application already on the users device, and the correction would be possible only <a href="http://appreviewtimes.com/">in a week</a> . <br><br><h4>  Why ease of use? </h4><br>  Everything is clear, but it is worth noting that the best code is the code that has never been written.  And the less code you have, the fewer errors.  Therefore, the desire to write less code does not mean that the developer is lazy.  And choosing the smartest solution, you should always consider the cost of its support. <br><br><h3>  The basics of MV (X) </h3><br>  Today we have many options for architectural design patterns: <br><ul><li>  <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593controller">MVC;</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593presenter">MVP;</a> </li><li>  <a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM;</a> </li><li>  <a href="https://www.objc.io/issues/13-architecture/viper/">VIPER.</a> </li></ul><br>  The first three of them involve assigning application entities to one of 3 categories: <br><ul><li>  <b>Models</b> ‚Äî responsible for the domain data or data access layer that manipulates data, for example, the <b>Person</b> class or <b>PersonDataProvider</b> ; </li><li>  <b>Views</b> - responsible for the presentation layer ( <b>GUI</b> );  For the iOS environment, this is all that begins with the <b>UI</b> prefix; </li><li>  <b>Controller / Presenter / ViewModel</b> - an intermediary between <b>Model</b> and <b>View</b> ;  In general, he is responsible for <b>Model</b> changes, reacting to user actions performed on the <b>View</b> , and updates the <b>View</b> using changes from the <b>Model</b> . </li></ul><br>  Having shared entities, we can: <br><ul><li>  understand them better; </li><li>  reuse them (mostly applicable to <b>View</b> and <b>Model</b> ); </li><li>  test them separately from each other. </li></ul><br>  <i>Let's start with the MV (X) patterns and return to VIPER later.</i> <br><br><h3>  MVC </h3><br><h4>  As it was before </h4><br>  Before discussing Apple‚Äôs MVC vision, let's look at the <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593controller">traditional version</a> . <br><div style="text-align:center;"><img src="https://habrastorage.org/files/f90/07e/965/f9007e96538d471f8186ae5b3d378876.png"></div><br><br>  In the traditional MVC <b>View</b> does not store state in itself.  <b>The controller</b> simply renders the <b>View</b> when the <b>Model</b> changes.  For example, a web page is completely reloaded after you click on a link to go to another location.  Although it is possible to implement traditional MVC in the iOS environment, this does not make much sense due to the architectural problem: all three entities are closely related, each entity <b>knows</b> about the other two.  This greatly reduces the ability to reuse each of the elements.  For this reason, we will not even try to write an example of canonical MVC. <br><br>  <i>Traditional MVC seems inapplicable to modern iOS development.</i> <br><br><h3>  Apple's MVC </h3><br><h4>  Expectations </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/8f5/a84/48b/8f5a8448befd4e788bd5a685c526d9b0.png"></div><br><br>  <b>Controller</b> is an intermediary between <b>View</b> and <b>Model</b> , therefore, the last two are not aware of the existence of each other.  Therefore, the <b>Controller is</b> difficult to reuse, but this, in principle, suits us, since we must have a place for that tricky business logic that does not fit into the <b>Model</b> . <br><br>  In theory, everything looks very simple, but you feel that something is wrong, right?  You have probably heard that people decipher MVC as <b>Massive View Controller</b> .  In addition, <a href="https://www.objc.io/issues/1-view-controllers/lighter-view-controllers/">ViewController unloading has</a> become an important topic for iOS developers.  Why does this happen if Apple just took the traditional MVC and improved it a little? <br><br><h4>  Reality </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/67e/d1f/3ca/67ed1f3ca77d43829bca88cee776c619.png"></div><br><br>  Cocoa MVC encourages you to write <b>Massive</b> View Controller, because the controller is so involved in the <b>View</b> life cycle that it is difficult to say that it is a separate entity.  Although you still have the opportunity to ship some of the business logic and data transformation in the <b>Model</b> , when it comes to shipping work in <b>View</b> , you have few options.  In most cases, the entire responsibility of the <b>View</b> is to send actions to the controller.  As a result, everything ends with the View Controller becoming a delegate and data source, as well as a place to start and cancel server requests and, in general, everything. <br><br>  How many times have you seen this code: <br><pre><code class="objectivec hljs">var userCell = tableView.dequeueReusableCellWithIdentifier(<span class="hljs-string"><span class="hljs-string">"identifier"</span></span>) as UserCell userCell.configureWithUser(user)</code> </pre> <br>  <b>View-</b> cell is configured directly from the <b>Model</b> .  Thus, the principles of MVC are violated, but such code can be seen very often, and, as a rule, people do not understand that this is wrong.  If you strictly follow MVC, you must configure the cell inside the controller and not transfer the <b>Model</b> to the View, which will increase the <b>Controller</b> even more. <br><br>  <i>Cocoa MVC is reasonably decoded as Massive View Controller.</i> <br><br>  The problem is not obvious until it comes to <a href="http://nshipster.com/unit-testing/">unit tests</a> (I hope that in your project it still comes).  Since the View Controller is closely connected with the <b>View</b> , it becomes difficult to test, and you have to go in a sophisticated way, replacing the <b>View with</b> <a href="https://ru.wikipedia.org/wiki/Mock-%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582">Mock objects</a> and simulating their life cycle, as well as writing the View Controller code so that the business logic is maximally separated from the code view layout. <br><br>  Let's look at a simple example from the playground: <br><pre> <code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Person { <span class="hljs-comment"><span class="hljs-comment">// Model let firstName: String let lastName: String } class GreetingViewController : UIViewController { // View + Controller var person: Person! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() { super.viewDidLoad() self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside) } func didTapButton(button: UIButton) { let greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName self.greetingLabel.text = greeting } // layout code goes here } // Assembling of MVC let model = Person(firstName: "David", lastName: "Blaine") let view = GreetingViewController() view.person = model;</span></span></code> </pre><br>  <i>The MVC build can be performed in a ‚Äúpresenting‚Äù View Controller.</i> <br><br>  It seems to be hard to test, right?  We can allocate the generation of greetings to the new <i>GreetingModel</i> class and test it separately, but we cannot test the presentation logic (even though there is not much of it in the example) inside the <i>GreetingViewController</i> without calling the <b>View</b> life cycle methods directly ( <i>viewDidLoad, didTapButton</i> ), which can lead to loading all UIView, and this is bad for unit tests. <br><br>  In fact, testing UIViews on one simulator (for example, iPhone 4S) does not guarantee that it will work properly on other devices (for example, iPad), so I recommend removing the <i>Host Application</i> tick from the unit test configuration and running it on simulator, not including the application itself. <br><br>  <i>The interaction between <b>View</b> and <b>Controller</b> is <a href="http://ashfurrow.com/blog/whats-worth-unit-testing-in-objective-c/">not really amenable to testing with unit tests</a> .</i> <br><br>  After all this, it may seem that Cocoa MVC is a rather bad choice of pattern.  But let's evaluate it in terms of <b>features of a good architecture</b> , defined at the beginning of the article: <br><ul><li>  <b>distribution</b> : <b>View</b> and <b>Model</b> are actually separated, but <b>View</b> and <b>Controller are</b> closely related; </li><li>  <b>testability</b> : due to poor distribution you are likely to test only the <b>Model</b> ; </li><li>  <b>ease of use</b> : the least amount of code among other patterns.  In addition, it looks understandable, so even an inexperienced developer can easily support it. </li></ul><br>  Cocoa MVC is a smart choice if you are not willing to invest a lot of time in your architecture and feel that the higher service cost pattern is not affordable for your small project or startup. <br><br>  <i>Cocoa MVC is the best architectural pattern in terms of speed of development.</i> <br><br><h3>  MVP </h3><br><h4>  Implementing Cocoa MVC Promises </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/files/887/424/d0c/887424d0c76f48acaf0e9897f6a0058e.png"></div><br><br>  Doesn't it look like an apple MVC?  In fact - very, and his name - <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593presenter">MVP</a> (option with a passive <b>View</b> ).  But does this mean that Apple's MVC is in fact MVP?  No, it is not, because, as you remember, <b>View</b> and <b>Controller are</b> closely related there, while the MVP intermediary <b>Presenter</b> is not related to the View Controller life cycle.  <b>The View</b> can be easily replaced by <a href="https://ru.wikipedia.org/wiki/Mock-%25D0%25BE%25D0%25B1%25D1%258A%25D0%25B5%25D0%25BA%25D1%2582">Mock objects</a> , so <b>Presenter has</b> no layout code, but it is responsible for updating the <b>View</b> with new data and state. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/996/bd3/696/996bd369630c4ac69e87abd4841b8d2f.jpeg"></div><br><br><blockquote>  - What if I tell you that the <b>UIViewController</b> is a <b>View</b> . </blockquote><br>  From the MVP point of view, the UIViewController subclasses are actually <b>View</b> , not <b>Presenter</b> .  This distinction provides excellent testability, which comes at the expense of development speed, because you have to manually link data and events between <b>View</b> and <b>Presenter</b> , as can be seen in the example below. <br><br><pre> <code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Person { <span class="hljs-comment"><span class="hljs-comment">// Model let firstName: String let lastName: String } protocol GreetingView: class { func setGreeting(greeting: String) } protocol GreetingViewPresenter { init(view: GreetingView, person: Person) func showGreeting() } class GreetingPresenter : GreetingViewPresenter { unowned let view: GreetingView let person: Person required init(view: GreetingView, person: Person) { self.view = view self.person = person } func showGreeting() { let greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName self.view.setGreeting(greeting) } } class GreetingViewController : UIViewController, GreetingView { var presenter: GreetingViewPresenter! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() { super.viewDidLoad() self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside) } func didTapButton(button: UIButton) { self.presenter.showGreeting() } func setGreeting(greeting: String) { self.greetingLabel.text = greeting } // layout code goes here } // Assembling of MVP let model = Person(firstName: "David", lastName: "Blaine") let view = GreetingViewController() let presenter = GreetingPresenter(view: view, person: model) view.presenter = presenter</span></span></code> </pre><br><h4>  Important note regarding assembly </h4><br>  MVP is the first pattern to reveal an assembly problem that occurs due to the presence of three <i>really</i> separate layers.  Since we do not need <b>View to</b> know about the <b>Model</b> , it is wrong to build in the presenting View Controller (which is actually <b>View</b> ), therefore, it needs to be done elsewhere.  For example, you can create a <b>Router</b> service that will be responsible for building and presenting a <b>View-to-View</b> .  This problem occurs not only in MVP, it also needs to be addressed in <b>all subsequent patterns</b> . <br><br>  Let's look at the <b>signs of a good architecture</b> for MVP: <br><ul><li>  <b>distribution</b> : most responsibility is shared between <b>Presenter</b> and <b>Model</b> , and <b>View</b> does nothing; </li><li>  <b>testability</b> : excellent, we can test most of the business logic through inaction View; </li><li>  <b>ease of use</b> : in our unrealistically simple example, the amount of code is twice as large as MVC, but at the same time the idea of ‚Äã‚ÄãMVP is very simple. </li></ul><br>  <i>MVP in iOS means excellent testability and a lot of code.</i> <br><br><h3>  MVP </h3><br><h4>  With Blackjack and Binding </h4><br>  There is another option MVP - MVP with a supervisory controller.  It includes the direct binding of <b>View</b> and <b>Model</b> , while the <b>Presenter</b> (supervisory controller) still handles the actions of the <b>View</b> and is able to modify it. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/89e/8f6/0e6/89e8f60e67ad456cb2936947cdc89ff4.png"></div><br><br>  But, as we learned earlier, the vague division of responsibility is bad in itself, as well as the close connection between <b>View</b> and <b>Model</b> .  And I see no point in writing an example for bad architecture. <br><br><h3>  MVVM </h3><br><h4>  The newest of the MV (X) species. </h4><br>  <a href="https://en.wikipedia.org/wiki/Model_View_ViewModel">MVVM</a> is the newest of the MV (X) patterns, so let's hope that it appeared with all the problems inherent in MV (X). <br><br>  In theory, the Model-View-ViewModel looks very good.  <b>View</b> and <b>Model are</b> already familiar to us, as is the <b>View Model</b> as an intermediary. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/77c/c2e/833/77cc2e8337dd4cafa5d93cef6bfe8fc8.png"></div><br><br>  It is very similar to MVP: <br><ul><li>  MVVM treats the View Controller as a <b>View</b> ; </li><li>  there is no close relationship between <b>View</b> and <b>Model</b> . </li></ul><br>  In addition, he does the binding as a supervising version of MVP, but not between <b>View</b> and <b>Model</b> , but between <b>View</b> and <b>View Model</b> . <br><br>  So what is a <b>View Model</b> in iOS?  This is a UIKit <b>independent</b> <b>View view</b> and its state.  <b>View Model</b> causes changes in the <b>Model</b> and independently updated with the already updated <b>Model</b> .  And since the binding occurs between the <b>View</b> and the <b>View Model</b> , the first one, respectively, is also updated. <br><br><h4>  Binding </h4><br>  I mention them, starting with the MVP part, but let's take a closer look at them.  Bindings are available out of the box for developing OS X, but they are not in the arsenal of an iOS developer.  Of course, we have KVO and Notifications, but they are not as comfortable as binding. <br><br>  Therefore, provided that we do not want to write them ourselves, you can choose: <br><ul><li>  one of the KVO-based binding libraries (for example, <a href="https://github.com/Raizlabs/RZDataBinding">RZDataBinding</a> or <a href="https://github.com/SwiftBond/Bond">SwiftBond</a> ); </li><li>  a full-sized framework for <a href="https://gist.github.com/JaviLorbada/4a7bd6129275ebefd5a6">functional reactive programming</a> , such as <a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a> , <a href="https://github.com/ReactiveX/RxSwift/">RxSwift,</a> or <a href="https://github.com/mxcl/PromiseKit">PromiseKit</a> . </li></ul><br>  Today, in fact, when you hear MVVM, you think about ReactiveCocoa, and vice versa.  Although you can do MVVM with simple bindings, ReactiveCocoa (or his classmates) will allow you to squeeze everything from the MVVM pattern. <br><br>  There is one bitter truth about FRP frameworks: great power comes with great responsibility.  It is very easy to break everything when you write <i>reactively</i> .  In other words, if something went wrong, you can spend a lot of time debugging the application.  Just take a look at this call stack. <br><div style="text-align:center;"><img src="https://habrastorage.org/files/01a/1a8/92c/01a1a892cbfe4e6b859378d3bf36088e.png"></div><br><br>  In our simple example, a reactive framework or even KVO is redundant.  We explicitly ask the <b>View Model</b> to update it using the <i>showGreeting</i> method, and use a simple property for the callback <i>greetingDidChange</i> function to learn about the changes. <br><br><pre> <code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Person { <span class="hljs-comment"><span class="hljs-comment">// Model let firstName: String let lastName: String } protocol GreetingViewModelProtocol: class { var greeting: String? { get } var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? { get set } // function to call when greeting did change init(person: Person) func showGreeting() } class GreetingViewModel : GreetingViewModelProtocol { let person: Person var greeting: String? { didSet { self.greetingDidChange?(self) } } var greetingDidChange: ((GreetingViewModelProtocol) -&gt; ())? required init(person: Person) { self.person = person } func showGreeting() { self.greeting = "Hello" + " " + self.person.firstName + " " + self.person.lastName } } class GreetingViewController : UIViewController { var viewModel: GreetingViewModelProtocol! { didSet { self.viewModel.greetingDidChange = { [unowned self] viewModel in self.greetingLabel.text = viewModel.greeting } } } let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() { super.viewDidLoad() self.showGreetingButton.addTarget(self.viewModel, action: "showGreeting", forControlEvents: .TouchUpInside) } // layout code goes here } // Assembling of MVVM let model = Person(firstName: "David", lastName: "Blaine") let viewModel = GreetingViewModel(person: model) let view = GreetingViewController() view.viewModel = viewModel</span></span></code> </pre><br>  And back to our assessment of <b>signs of good architecture</b> : <br><ul><li>  <b>distribution</b> : from our tiny example, this is unclear, but in fact in MVVM <b>View</b> has more responsibilities than <b>View</b> from MVP.  Because the first one updates its state with the View Model by setting up binders, while the second sends all events to the Presenter and does not update itself (this is done by the Presenter); </li><li>  <b>testability</b> : View Model does not know anything about the view, it allows us to easily test it.  The view can also be tested, but since it depends on UIKit, you can just skip this; </li><li>  <b>ease of use</b> : the same amount of code as in our MVP example, but in a real application, where you have to send all the events from View to Presenter and update the View manually, MVVM will be much slimmer (if you use binding). </li></ul><br>  <i>MVVM is a very attractive pattern, as it combines the advantages of the aforementioned approaches and does not require additional code for updating the View in connection with the side view bindings.</i>  <i>However, testability is still at a good level.</i> <br><br><h3>  VIPER </h3><br><h4>  Building experience from Lego cubes, transferred to the design of iOS applications </h4><br>  <a href="https://www.objc.io/issues/13-architecture/viper/">VIPER</a> is our last candidate, which is especially interesting because it is not from the category MV (X). <br><br>  By now you should already agree that the division of responsibilities is very good.  VIPER takes another step towards the separation of duties and instead of the usual three layers offers <b>five</b> . <br><div style="text-align:center;"><img src="https://habrastorage.org/files/66d/c26/871/66dc2687102a4df1aff7296d9321b476.png"></div><br><ul><li>  <b>Interactor</b> contains the business logic associated with data ( <b>Entities</b> ): for example, creating new instances of entities or getting them from the server.  For these purposes, you will use some Services and Managers, which are viewed more as external dependencies, and not as part of the VIPER module. </li><li>  <b>Presenter</b> contains UI-related business logic (but is UIKit-independent) that calls methods in an <b>Interactor</b> . </li><li>  <b>Entities</b> are simple data objects that are not a data access layer, because it is the responsibility of the <b>Interactor</b> layer. </li><li>  <b>Router</b> is responsible for transitions between VIPER <b>modules</b> . </li></ul><br>  In principle, the VIPER module can be a single screen or a whole user story of your application (for example, authentication can be on one screen or several related screens).  It‚Äôs up to you how small your ‚Äúlego-blocks‚Äù will be. <br><br>  If we compare VIPER with MV (X) -type patterns, we will see several differences in the distribution of responsibilities: <br><ul><li>  The logic from the <b>Model</b> (data interaction) is shifted to <b>Interactor</b> , and there are <b>Entities</b> , data structures that do nothing; </li><li>  from the <b>Controller</b> , <b>Presenter</b> , <b>ViewModel</b> , the UI view duties moved to the <b>Presenter</b> , but without the possibility of changing the data; </li><li>  <b>VIPER</b> is the first template that tries to solve the problem of navigation, there is a <b>Router</b> for this. </li></ul><br>  <i>The fact that MV (X) -patterns do not solve the routing problem does not mean that it does not exist for iOS applications.</i> <br><br>  In the example, there is no routing or interaction between modules, since these topics are not covered at all by the MV (X) -parts. <br><pre> <code class="objectivec hljs">import <span class="hljs-built_in"><span class="hljs-built_in">UIKit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Person { <span class="hljs-comment"><span class="hljs-comment">// Entity (usually more complex eg NSManagedObject) let firstName: String let lastName: String } struct GreetingData { // Transport data structure (not Entity) let greeting: String let subject: String } protocol GreetingProvider { func provideGreetingData() } protocol GreetingOutput: class { func receiveGreetingData(greetingData: GreetingData) } class GreetingInteractor : GreetingProvider { weak var output: GreetingOutput! func provideGreetingData() { let person = Person(firstName: "David", lastName: "Blaine") // usually comes from data access layer let subject = person.firstName + " " + person.lastName let greeting = GreetingData(greeting: "Hello", subject: subject) self.output.receiveGreetingData(greeting) } } protocol GreetingViewEventHandler { func didTapShowGreetingButton() } protocol GreetingView: class { func setGreeting(greeting: String) } class GreetingPresenter : GreetingOutput, GreetingViewEventHandler { weak var view: GreetingView! var greetingProvider: GreetingProvider! func didTapShowGreetingButton() { self.greetingProvider.provideGreetingData() } func receiveGreetingData(greetingData: GreetingData) { let greeting = greetingData.greeting + " " + greetingData.subject self.view.setGreeting(greeting) } } class GreetingViewController : UIViewController, GreetingView { var eventHandler: GreetingViewEventHandler! let showGreetingButton = UIButton() let greetingLabel = UILabel() override func viewDidLoad() { super.viewDidLoad() self.showGreetingButton.addTarget(self, action: "didTapButton:", forControlEvents: .TouchUpInside) } func didTapButton(button: UIButton) { self.eventHandler.didTapShowGreetingButton() } func setGreeting(greeting: String) { self.greetingLabel.text = greeting } // layout code goes here } // Assembling of VIPER module, without Router let view = GreetingViewController() let presenter = GreetingPresenter() let interactor = GreetingInteractor() view.eventHandler = presenter presenter.view = view presenter.greetingProvider = interactor interactor.output = presenter</span></span></code> </pre><br>  And yet, once again return to the <b>signs</b> . <br><ul><li>  <b>Distribution</b>  Undoubtedly, VIPER is a champion in the distribution of responsibilities. </li><li>  <b>Testability</b>  There is nothing surprising: better distribution - better testing. </li><li>  <b>Ease of use</b> .  As you may have guessed, the first two benefits come at the cost of escort.  You will have to write a huge number of interfaces for classes with minor responsibilities. </li></ul><br><h4>  So what about Lego? </h4><br>  When using VIPER, it may seem to you that you are building the Empire State Building from Lego cubes, and this suggests that you <a href="https://inessential.com/2014/03/16/smaller_please">have problems</a> .  Maybe you took up VIPER too early and it is worth looking at something simpler.  Some people ignore it and continue to shoot from a cannon on sparrows.  I assume that they believe that their applications will benefit from VIPER sometime in the future, even if the cost of service is now unreasonably high.  If you think it's worth it, then I recommend you try <a href="https://github.com/rambler-ios/Generamba">Generamba</a> , a tool for generating VIPER skeletons.  Although personally it seems to me that this is akin to using an <i>automatic sight</i> for shooting from the same gun instead of a <i>slingshot</i> . <br><br><h3>  Conclusion </h3><br>  We looked at several architectural patterns, and I hope that you have found answers to some of your questions.  I have no doubt that you understood that <b>there is no ‚Äúsilver bullet‚Äù</b> among the patterns, and the choice of architecture is a matter of weighing compromises in your particular situation. <br>  It seems to me quite natural to combine several architectures in one application.  For example, you started with MVC, but having understood that a particular screen (use case) became too difficult to maintain with MVC, you switched to MVVM, but only for that particular screen.  Because in fact there is no need to refactor other screens for which MVC work perfectly, especially since both architectures are easily compatible. <br><br><blockquote>  Make it as simple as possible, but not simpler.  (c) Albert Einstein </blockquote><br><br>  <i>An English version is available <a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">here</a> .</i>  <i>The slides that I presented at NSLondon are available <a href="http://slides.com/borlov/arch/fullscreen">here</a> .</i> <br><br>  Bogdan Orlov, <br>  iOS developer in Badoo </div><p>Source: <a href="https://habr.com/ru/post/281162/">https://habr.com/ru/post/281162/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../281152/index.html">Rust 1.8 Preview</a></li>
<li><a href="../281154/index.html">Boomstarter in the cloud - who helps launch new projects?</a></li>
<li><a href="../281156/index.html">Virtual Reality Market Analytics</a></li>
<li><a href="../281158/index.html">Cloud commercial object-oriented business application for a paid toilet or thinking about architecture</a></li>
<li><a href="../281160/index.html">Expanded PHPixie Project Skeleton with Authentication and Admin Panel</a></li>
<li><a href="../281164/index.html">Collecting Checkpoint Firewall Logs (OPSEC LEA)</a></li>
<li><a href="../281168/index.html">How to hack thousands of printers in the Russian Federation and print everything you want</a></li>
<li><a href="../281170/index.html">Ubuntu Russification console in 2016</a></li>
<li><a href="../281172/index.html">Welcome to Moscow Atlassian Meetup April 26</a></li>
<li><a href="../281176/index.html">His name is Bot. Statsbot</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>