<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Logs frontend developer Habr: refactor and reflex</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I have always been interested in how Habr works from the inside, how workflows are built, how communications are built, what standards are used and ho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Logs frontend developer Habr: refactor and reflex</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/bu/8e/tl/bu8etlfvktvmkcjotmzz6al7rgg.jpeg"><br><br>  I have always been interested in how Habr works from the inside, how workflows are built, how communications are built, what standards are used and how the code is written here.  Fortunately, I had this opportunity, because I recently became part of the habrakommando.  Using the example of a small mobile version of refactoring, I will try to answer the question: what is it like to work here in the front.  In the program: Node, Vue, Vuex and SSR with sauce from notes about personal experience in Habr√©. <a name="habracut"></a><br><br>  The first thing you need to know about the development team is that we are few.  It is not enough - these are three fronts, two backups and the techlide of all Habr - Baxley.  There are, of course, another tester, designer, three Vadim, miracle whisk, marketer and other Bumburums.  But there are only six direct contributors to Habr's sorties.  This is quite rare - a project with a multimillion audience, which looks like a giant enterprise from the outside, in fact looks more like a cozy startup with the most flat organizational structure. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Like many other IT companies, Habr professes Agile ideas, the practice of CI, and that's it.  But according to my feelings, Habr as a product develops in a wave rather than continuously.  So a few sprints in a row we diligently code something, design and redesign, break something and repair, fix tickets and start new ones, step on the rake and shoot ourselves at the feet to finally release the feature in the prod.  And then there comes a lull, a period of redevelopment, time to do what is in the quadrant ‚Äúimportant-indefinite.‚Äù <br><br>  Just about this "interseason" sprint and will be discussed below.  This time, the refactoring of the Habr mobile version got into it.  In general, the company has high hopes for it, and in the future it should replace the entire zoo of Habr's incarnations and become a universal cross-platform solution.  Someday there will be an adaptive layout, and PWA, and offline mode, and custom customization, and many interesting things. <br><br><h3>  Set the task </h3><br>  Once on an ordinary stand-up, one of the fronts spoke about the problems in the architecture of the component of comments of the mobile version.  With this submission, we organized a micro-meeting in the format of group psychotherapy.  Everyone took turns to say where he was in pain, everything was fixed on paper, sympathized, understood, unless no one clapped.  The output was a list of 20 problems, which made it clear that the mobile Habr has to go a long and thorny path to success. <br><br>  I was worried primarily about the efficiency of resource use and what is called the smooth interface.  Every day on the ‚Äúhome-work-home‚Äù route, I saw my old phone desperately trying to display 20 headers in a feed.  It looked like this: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nv/v8/zr/nvv8zr5uneyynf4ntntk9sp3gzs.gif" alt="image"></div>  <sub><font color="grey"><i>Mobile Habr interface before refactoring</i></font></sub> <br><br>  What's going on here?  In short, the server gave the HTML page the same to everyone, regardless of whether the user is logged in or not.  Then the client JS is loaded and re-requests the necessary data, but already adjusted for authorization.  That is, in fact, we did the same work twice.  The interface flickered, and the user downloaded a good hundred extra kilobytes.  In detail, everything looked even more terrible. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0k/py/d8/0kpyd8h81q0_sgb8dd2gt7wfhvw.jpeg"></div>  <sub><font color="grey"><i>Old SSR-CSR scheme.</i></font></sub>  <sub><font color="grey"><i>Authorization is possible only at steps C3 and C4, when Node JS is not busy generating HTML and can proxy API requests.</i></font></sub> <br><br>  One of Habr's users described our architecture of the time very precisely: <br><blockquote>  Mobile version is crap.  I say it as it is.  Awful SSR combination with CSR. </blockquote><br>  We had to admit it, no matter how sad it was. <br><br>  I figured out the options, set myself a ticket in ‚ÄúDjir‚Äù with a description at the level ‚Äúit‚Äôs bad now, make the rules‚Äù and with a broad brushstroke I decomposed the task: <br><br><ul><li>  reuse data </li><li>  minimize the number of redraws </li><li>  eliminate duplicate requests </li><li>  make the boot process more obvious. </li></ul><br><h3>  Reuse data </h3><br>  In theory, server-side rendering is designed to solve two problems: not to suffer from the limitations of search engines in terms of <a href="https://www.onely.com/blog/ultimate-guide-javascript-seo/">SPA indexing</a> and to improve the <a href="https://developers.google.com/web/tools/lighthouse/audits/first-meaningful-paint">FMP</a> metric (inevitably worsening <a href="https://developers.google.com/web/tools/lighthouse/audits/time-to-interactive">TTI</a> ).  In the classic scenario, which was finally <a href="https://medium.com/airbnb-engineering/isomorphic-javascript-the-future-of-web-apps-10882b7a2ebc">formulated in Airbnb in 2013</a> (backbone.js), SSR is the same isomorphic JS application running in the Node environment.  The server simply gives the generated layout as a response to the request.  Then there is a re-registration on the client side, and then everything works without reloading the page.  For Habr, as well as for many other text-filled resources, server-side rendering is a crucial element in building friendships with search engines. <br><br>  Despite the fact that more than six years have passed since the advent of technology, and during this time a lot of water has actually flowed into the world of the front-end, for many developers this idea is still covered with a veil of secrecy.  We did not stand aside, and rolled out a Vue-application with SSR support in the prod, having missed one small detail: we did not pass the initial state to the client. <br><br>  Why?  There is no exact answer to this question.  Either they didn‚Äôt want to increase the size of the response from the server, or because of a bunch of other architectural problems, or they simply didn‚Äôt take off.  One way or another, to throw a state and reuse everything that the server did seems to be quite appropriate and useful.  The task is actually trivial - the <a href="https://ssr.vuejs.org/guide/data.html">state is simply injected</a> into the execution context, and Vue automatically adds it to the generated layout as a global variable: <code>window.__INITIAL_STATE__</code> . <br><br>  One of the problems that has arisen is the inability to convert <a href="https://en.wikipedia.org/wiki/Circular_reference">circular reference</a> to JSON;  It was solved by simply replacing such structures with their flat counterparts. <br><br>  In addition, when dealing with UGC content, it should be remembered that the data should be transformed into HTML-entities, in order not to break the HTML.  For these purposes, we use <a href="https://www.npmjs.com/package/he">he</a> . <br><br><h3>  Minimize Redraws </h3><br>  As can be seen from the diagram above, in our case, one Node JS instance performs two functions: SSR and ‚Äúproxy‚Äù in the API, where the user is being authenticated.  This circumstance makes it impossible to authorize when the JS code is executed on the server, since the node is single-threaded, and the SSR function is synchronous.  That is, the server simply cannot send requests to itself while the callstack is busy with something.  It turned out that we prokinuli state, but the interface did not cease to twitch, because the data on the client should be updated to reflect the user session.  It was necessary to teach our application to put the correct data in the initial state, taking into account the user's login. <br><br>  There were only two solutions to the problem: <br><br><ul><li>  cling authorization data to cross-server requests; </li><li>  split Node JS layers into two separate instances. </li></ul><br>  The first solution required the use of global variables on the server, and the second stretched the deadlines for the task at least a month. <br><br>  How to make a choice?  Habr often moves along the path of least resistance.  Informally, there exists a certain common desire to reduce to a minimum the cycle from idea to prototype.  The model of attitude to the product is somewhat reminiscent of booking.com, with the only difference that Habr is much more serious about user feedback and trusts such decisions to you as a developer. <br><br>  Following this logic and my own desire to quickly solve the problem, I chose global variables.  And, as it often happens, sooner or later they have to pay for them.  We paid almost immediately: we worked at the weekend, scooped up the consequences, wrote <a href="https://habr.com/ru/company/habr/blog/443268/">post mortem</a> and started to divide the server into two parts.  The error was very stupid, and the bug with her participation was not easy to reproduce.  And yes, for such a shame, but somehow, stumbling and groaning, my PoC with global variables still went into production and quite successfully works in anticipation of moving to a new ‚Äútwo-tier‚Äù architecture.  It was an important step, because formally the goal was achieved - SSR learned to give the page completely ready for use, and the UI became much more relaxed. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/rm/rx/d-/rmrxd-fkzne7vbcj-jxxrbbwid8.gif" alt="image"></div>  <sub><font color="grey"><i>Mobile Habra interface after the first stage of refactoring</i></font></sub> <br><br>  Ultimately, the SSR-CSR architecture of the mobile version leads to this picture: <br><br>  Ôøº <div style="text-align:center;"><img src="https://habrastorage.org/webt/7t/jb/km/7tjbkmkiq4n5atanzsj3ylkwrke.jpeg" alt="image"></div>  <sub><font color="grey"><i>"Binary" SSR-CSR scheme.</i></font></sub>  <sub><font color="grey"><i>The Node JS API is always ready for asynchronous I / O and is not blocked by the SSR function, since the latter is in a separate instance.</i></font></sub>  <sub><font color="grey"><i>Query chain # 3 is not needed.</i></font></sub> <br><br><h3>  Eliminate duplicate requests </h3><br>  After the done manipulations, the initial render of the page stopped provoking epilepsy.  But the continued use of Habr in the SPA mode was still puzzling. <br><br>  Since the basis of user flow is made up of transitions like a <i>list of articles ‚Üí article ‚Üí comments</i> and back, it was important to optimize the consumption of resources of this chain in the first place. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/uk/eo/01/ukeo01u79_olhiv1eo9vxao4yv4.gif" alt="image"></div>  <sub><font color="grey"><i>Return to post feed triggers new data request</i></font></sub> <br><br>  I did not have to dig deep.  On the screencast above, it is clear that the application re-queries the list of articles when you swipe back, and we don‚Äôt see the articles at the time of the request, so the previous data disappears somewhere.  It looks as if the article list component uses a local state and loses it to destroy.  In fact, the application used a global state, but the Vuex architecture was built in the forehead: the modules are tied to pages, which in turn are tied to routes.  And all the modules are ‚Äúdisposable‚Äù - every next entry on the page rewrote the module entirely: <br><br><pre> <code class="javascript hljs">ArticlesList: [ { Article1 }, ... ], <span class="hljs-attr"><span class="hljs-attr">PageArticle</span></span>: { ArticleFull1 },</code> </pre><br>  So we had the <i>ArticlesList</i> module, which contains objects of type <i>Article</i> and the <i>PageArticle</i> module, which was an extended version of the object of <i>Article</i> , of its own kind <i>ArticleFull</i> .  By and large, this implementation does not carry anything terrible in itself - it is very simple, one can even say naively, but extremely understandable.  If you cut out the reset of the module at each change of the route, then you can even live with it.  However, the transition between articles feeds, for example <i>/ feed ‚Üí / all</i> , is guaranteed to throw away everything related to personalized feed, since we have only one <i>ArticlesList</i> in which we need to put new data.  This again leads us to duplicate requests. <br><br>  Having collected in a heap all that I managed to dig up on the topic, I formulated a new structure of the state and presented it to my colleagues.  The discussions were lengthy, but in the end the arguments ‚Äúfor‚Äù outweighed the doubts, and I started to implement it. <br><br>  The logic of the solution is best revealed in two stages.  First we try to untie the Vuex module from the pages and link it directly to the routes.  Yes, there will be a little more data in the store, the getters will become a bit more complicated, but we will not load the articles twice.  For the mobile version, this is probably the strongest argument.  It turns out like this: <br><br><pre> <code class="javascript hljs">ArticlesList: { <span class="hljs-attr"><span class="hljs-attr">ROUTE_FEED</span></span>: [ { Article1 }, ... ], <span class="hljs-attr"><span class="hljs-attr">ROUTE_ALL</span></span>: [ { Article2 }, ... ], }</code> </pre><br>  But what if article lists can intersect between several routes and what if we want to reuse the data of the <i>Article</i> object to render the post page, turning it into <i>ArticleFull</i> ?  In this case, it would be more logical to use such a structure: <br><br><pre> <code class="javascript hljs">ArticlesIds: { <span class="hljs-attr"><span class="hljs-attr">ROUTE_FEED</span></span>: [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, ... ], <span class="hljs-attr"><span class="hljs-attr">ROUTE_ALL</span></span>: [ <span class="hljs-string"><span class="hljs-string">'1'</span></span>, <span class="hljs-string"><span class="hljs-string">'2'</span></span>, ... ], }, <span class="hljs-attr"><span class="hljs-attr">ArticlesList</span></span>: { <span class="hljs-string"><span class="hljs-string">'1'</span></span>: { Article1 }, <span class="hljs-string"><span class="hljs-string">'2'</span></span>: { Article2 }, ... }</code> </pre><br>  <i>ArticlesList</i> here is just some kind of repository of articles.  All articles that were uploaded during the user session.  We treat them as carefully as possible, because this is traffic that may have been loaded through pain somewhere in the subway between stations, and we definitely don‚Äôt want to cause this pain to the user again, forcing him to load the data that he has already loaded.  The <i>ArticlesIds</i> object is simply an array of aids (like ‚Äúlinks‚Äù) to <i>Article</i> objects.  Such a structure allows us not to duplicate the data common to routes and reuse the <i>Article</i> object when rendering the post page by merging extended data into it. <br><br>  The listing of articles has also become more transparent: the iterator component iterates over the array with the IT records of the articles and draws the component of the teaser of the article, passing Id as a props, and the child component in turn retrieves the necessary data from <i>ArticlesList</i> .  When you go to the publication page, we retrieve the already existing date from the <i>ArticlesList</i> , make a request for obtaining the missing data and simply add it to the existing object. <br><br>  Why is this approach better?  As I wrote above, this approach is more careful with respect to the loaded data and allows you to reuse them.  But beyond that, it opens the way for some new features that perfectly fit into such an architecture.  For example, polling and uploading articles to the tape as they appear.  We can simply add fresh posts to the ‚Äústorage‚Äù of <i>ArticlesList</i> , save a separate list of new ID in <i>ArticlesIds</i> and notify the user about it.  When you click on the button "Show new publications", we simply insert the new Id at the beginning of the array of the current list of articles and everything will work almost magically. <br><br><h3>  Making the download more enjoyable </h3><br>  Cherry on the refactoring cake has become the concept of skeletons, which makes the process of downloading content on the slow Internet a little less disgusting.  There were no discussions on this score, the path from the idea to the prototype took literally two hours.  The design was drawn almost by itself, and we taught our components to render simple, barely flickering div-blocks while waiting for data.  Subjectively, such an approach to loading really reduces the amount of stress hormones in the user's body.  The skeleton looks like this: <br><br><img src="https://habrastorage.org/webt/yn/gn/ey/yngneyh8sftpmyyyj4ur_ihjo2c.jpeg" alt="image"><br>  <sub><font color="grey"><i>Habraloading</i></font></sub> <br><br><h3>  Reflecting </h3><br>  I have been working in Habr√© for half a year and my acquaintances still ask: well, how are you there?  Well, comfortable - yes.  But there is something that distinguishes this work from others.  I worked in teams that were absolutely indifferent to their product, did not know and did not understand who their users were.  And here everything is different.  Here you feel responsible for what you are doing.  In the process of developing a feature, you partially become its owner, take part in all the product meetings related to your functionality, make suggestions and make decisions yourself.  To make a product that you use yourself every day is very cool, and writing code for people who may know this better than you is just an incredible feeling (no sarcasm). <br><br>  After the release of all these changes, we received a positive feedback, and it was very, very nice.  It is inspiring.  Thank!  Write more. <br><br>  I recall that after the global variables, we decided to change the architecture and the selection of the proxying layer into a separate instance.  The ‚Äútwo-stage‚Äù architecture has already reached the release in the form of a public beta test.  Now anyone can switch to it and help us make mobile Habr better.  That's all for today.  I am pleased to answer all your questions in the comments. </div><p>Source: <a href="https://habr.com/ru/post/452098/">https://habr.com/ru/post/452098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45208/index.html">Down with the language barrier - 2</a></li>
<li><a href="../452086/index.html">What's in a pixel for you my: the creation of nanopixels using plasmon meta-surfaces</a></li>
<li><a href="../45209/index.html">The first test of the interplanetary Internet</a></li>
<li><a href="../452090/index.html">Creating a procedural puzzle generator</a></li>
<li><a href="../452092/index.html">In-App Updates: we accelerate the process of updating the application on Android</a></li>
<li><a href="../4521/index.html">How are the meetings at google</a></li>
<li><a href="../452106/index.html">We invite speakers to the summer DIY-mitap June 16, 2019</a></li>
<li><a href="../452108/index.html">Docker: Harmless Tips</a></li>
<li><a href="../452112/index.html">CRM ++</a></li>
<li><a href="../452118/index.html">The scientist breaks the code of the mysterious manuscript of Voinich</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>