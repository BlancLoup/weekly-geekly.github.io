<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Introduction to ReactiveUI: Collections</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi, Habr! 

 Part 1: Introduction to ReactiveUI: we pump properties in ViewModel 

 In the previous article we talked about properties in ViewModel, a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Introduction to ReactiveUI: Collections</h1><div class="post__text post__text-html js-mediator-article">  Hi, Habr! <br><br>  <a href="http://habrahabr.ru/post/303650/">Part 1: Introduction to ReactiveUI: we pump properties in ViewModel</a> <br><br>  In the previous article we talked about properties in ViewModel, and what we can do with them using ReactiveUI.  We managed to put in order the dependencies between the properties and collect in one place the model view the information about the dependencies between the properties in it. <br>  This time we will talk a little more about properties, and then proceed to the collections.  Let's try to understand what problems there are with ordinary collections, and why it was to create new ones, with notifications of changes.  And, of course, try to use them. <br><a name="habracut"></a><br><h4>  A few words about the properties </h4><br>  Before turning to the main topic, I will say a few words about the properties.  Last time we came up with the following syntax: <br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _firstName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _firstName; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.RaiseAndSetIfChanged(<span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> _firstName, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); } }</code> </pre> <br>  Spending 6 lines of code on each property is quite wasteful, especially if there are many such properties and the implementation is always the same.  In the C # language, auto-properties were added to solve this problem in due time, and it is easier to live stato.  What can we do in our case? <br>  <a href="https://github.com/Fody/Fody">Fody</a> was mentioned in the comments - a tool that can change the IL-code after assembling the project.  For example, in the implementation of auto-property add a notice of change.  And for ReactiveUI there is even a corresponding extension: <a href="">ReactiveUI.Fody</a> .  Let's try to use it.  By the way, for the classical implementation, there is also an extension: <a href="https://github.com/Fody/PropertyChanged">PropertyChanged</a> , but it does not suit us, since we need to call <i>RaiseAndSetIfChanged ()</i> . 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Install from NuGet:&gt; Install-Package ReactiveUI.Fody <br>  FodyWeavers.xml appears in the project.  Add the installed extension to it: <br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Weavers</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ReactiveUI</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Weavers</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  And change our properties: <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Reactive</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre><br>  With this tool you can also implement the FullName property based on ObservableAsPropertyHelper &lt;&gt;.  The way is described in documentation on GitHub, here we will lower it.  I think that two lines is quite an acceptable option, and I don‚Äôt really want to use a third-party method instead of ToProperty (), which allows ReactiveUI.Fody to implement this property correctly. <br><br>  Check that nothing is broken.  How?  I test unit tests.  ReactiveUI is friendly to them, no wonder he has a <i>MVVM framework &lt;...&gt; to create elegant, <b>testable</b> User Interfaces ....</i>  To check the triggering of the event, it is not necessary to subscribe to it with your hands, save the data somewhere when triggered, and then process it. <br>  <i>Observable.FromEventPattern ()</i> will help us, which will turn event triggering into IObservable &lt;&gt; with all the necessary information.  And to turn IObservable &lt;&gt; into a list of events and check it for correctness, it is convenient to use the extension method <i>.CreateCollection ()</i> .  It creates a collection in which, as long as the source does not call OnComplete () or we call Dispose (), the elements that came through IObservable &lt;&gt; will be added, in our case - information about the events that have been triggered. <br>  Notice that the collection returns to us immediately, and the elements are added to it later, asynchronously.  This behavior is different from, for example, .ToList (), which does not return control and, therefore, the collection itself to OnComplete (), which is fraught with perpetual waiting in the case of a regular subscription to the event. <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FirstName_WhenChanged_RaisesPropertyChangedEventForFirstNameAndFullNameProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PersonViewModel(<span class="hljs-string"><span class="hljs-string">"FirstName"</span></span>, <span class="hljs-string"><span class="hljs-string">"LastName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> evendObservable = Observable.FromEventPattern&lt;PropertyChangedEventHandler, PropertyChangedEventArgs&gt;( a =&gt; vm.PropertyChanged += a, a =&gt; vm.PropertyChanged -= a); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> raisedEvents = evendObservable.CreateCollection(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (raisedEvents) { vm.FirstName = <span class="hljs-string"><span class="hljs-string">"NewFirstName"</span></span>; } Assert.That(vm.FullName, Is.EqualTo(<span class="hljs-string"><span class="hljs-string">"NewFirstName LastName"</span></span>)); Assert.That(raisedEvents, Has.Count.EqualTo(<span class="hljs-number"><span class="hljs-number">2</span></span>)); Assert.That(raisedEvents[<span class="hljs-number"><span class="hljs-number">0</span></span>].Sender, Is.SameAs(vm)); Assert.That(raisedEvents[<span class="hljs-number"><span class="hljs-number">0</span></span>].EventArgs.PropertyName, Is.EqualTo(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(PersonViewModel.FirstName))); Assert.That(raisedEvents[<span class="hljs-number"><span class="hljs-number">1</span></span>].Sender, Is.SameAs(vm)); Assert.That(raisedEvents[<span class="hljs-number"><span class="hljs-number">1</span></span>].EventArgs.PropertyName, Is.EqualTo(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(PersonViewModel.FullName))); }</code> </pre><br>  The test script itself (setting a new property value) is executed inside using, and the checks after.  This is necessary so that during the test, some event does not accidentally work and does not spoil our collection.  Of course, it is often unnecessary to do this, but sometimes it can be important. <br><br>  Now let's check that IObservable &lt;&gt; Changed will return the same. <br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">Test</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FirstName_WhenChanged_PushesToPropertyChangedObservableForFirstNameAndFullNameProperties</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PersonViewModel(<span class="hljs-string"><span class="hljs-string">"FirstName"</span></span>, <span class="hljs-string"><span class="hljs-string">"LastName"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> notifications = vm.Changed.CreateCollection(); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (notifications) { vm.FirstName = <span class="hljs-string"><span class="hljs-string">"NewFirstName"</span></span>; } Assert.That(vm.FullName, Is.EqualTo(<span class="hljs-string"><span class="hljs-string">"NewFirstName LastName"</span></span>)); Assert.That(notifications, Has.Count.EqualTo(<span class="hljs-number"><span class="hljs-number">2</span></span>)); Assert.That(notifications[<span class="hljs-number"><span class="hljs-number">0</span></span>].Sender, Is.SameAs(vm)); Assert.That(notifications[<span class="hljs-number"><span class="hljs-number">0</span></span>].PropertyName, Is.EqualTo(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(PersonViewModel.FirstName))); Assert.That(notifications[<span class="hljs-number"><span class="hljs-number">1</span></span>].Sender, Is.SameAs(vm)); Assert.That(notifications[<span class="hljs-number"><span class="hljs-number">1</span></span>].PropertyName, Is.EqualTo(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(PersonViewModel.FullName))); }</code> </pre><br>  And ... The test fell.  But we just changed the source of information about changing properties!  Let's try to understand why the test failed: <br><pre> <code class="cs hljs">vm.Changed.Subscribe(n =&gt; Console.WriteLine(n.PropertyName)); vm.FirstName = <span class="hljs-string"><span class="hljs-string">"OMG"</span></span>;</code> </pre><br>  And we get: <br><blockquote>  FullName <br>  Firstname <br></blockquote><br>  Like this.  This does not seem to be a framework error, but rather an implementation detail.  This is understandable: both properties have already changed and the order of notification is unimportant.  On the other hand, it is inconsistent with the order of events and does not meet expectations, which may be fraught.  Of course, building application logic based on the order of notifications is obviously a bad idea.  But, for example, when reading the application log, we will see that the dependent property notified about the change BEFORE its dependency changes, which can be confusing.  So be sure to remember this feature. <br>  So, we made sure that ReactiveUI.Fody works properly and significantly reduces the amount of code.  We will continue to use it. <br><br><hr><br><h4>  And now for the collections. </h4><br>  The INotifyPropertyChanged interface, as we know, is used when changing view model properties, for example, to notify a visual element that something has changed and that the interface needs to be redrawn.  But what to do when there is a collection of many elements in the view model (for example, a news feed), and we need to add fresh entries to those already shown?  Notify that the property in which the collection is located has changed?  It is possible, but it will lead to rebuilding of the entire list in the interface, and this can be a slow operation, especially if we are talking about mobile devices.  No, that won't do.  It is necessary that the collection itself reports that something has changed in it.  Fortunately, there is a wonderful interface: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">INotifyCollectionChanged</span></span> { <span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">///</span></span></span><span class="hljs-comment"> </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;summary&gt;</span></span></span><span class="hljs-comment">Occurs when the collection changes.</span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">&lt;/summary&gt;</span></span></span><span class="hljs-comment"> event NotifyCollectionChangedEventHandler CollectionChanged; }</span></span></code> </pre><br>  If the collection implements it, then when adding / deleting / replacing, etc.  events triggered by CollectionChanged.  And now you do not need to rebuild the list of news again and generally look into the collection of records, it is enough just to supplement it with new elements that came through the event.  In .NET there are collections that implement it, but we are talking about ReactiveUI.  What is in it? <br>  A whole set of interfaces: IReactiveList &lt;T&gt;, IReadOnlyReactiveList &lt;T&gt;, IReadOnlyReactiveCollection &lt;T&gt;, IReactiveCollection &lt;T&gt;, IReactiveNotifyCollectionChanged &lt;T&gt;, IReactiveNotifyCollectionItemChanged &lt;T&gt;.  I will not give a description of each here, I think it should be clear by name what they are. <br>  But let's look at the implementation in more detail.  Meet ReactiveList &lt;T&gt;.  He implements them all and much more.  Since we are interested in tracking changes in the collection, we will look at the corresponding properties of this class. <br><img src="https://habrastorage.org/files/53b/677/a85/53b677a850424641bc8c5d0a278837be.png" alt="Properties for tracking changes in IReactiveList &amp; lt; T &amp; gt;"><br>  Quite a bit of!  The addition, removal, movement of elements, the number of elements, the collection emptiness and the need to reset are monitored.  Consider all this in more detail.  Of course, events from INotifyCollectionChanged, INotifyPropertyChanged and paired with * Changind are also implemented, but we will not talk about them, they work side-by-side with the ‚Äúobservable‚Äù properties shown in the picture and there is nothing unique there. <br>  For a start, a simple example.  Subscribe to some sources of notifications and work a little with the collection: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveList&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;(); list.BeforeItemsAdded.Subscribe(e =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Before added: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{e}</span></span></span><span class="hljs-string">"</span></span>)); list.ItemsAdded.Subscribe(e =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Added: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{e}</span></span></span><span class="hljs-string">"</span></span>)); list.BeforeItemsRemoved.Subscribe(e =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Before removed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{e}</span></span></span><span class="hljs-string">"</span></span>)); list.ItemsRemoved.Subscribe(e =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Removed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{e}</span></span></span><span class="hljs-string">"</span></span>)); list.CountChanging.Subscribe(e =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Count changing: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{e}</span></span></span><span class="hljs-string">"</span></span>)); list.CountChanged.Subscribe(e =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"Count changed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{e}</span></span></span><span class="hljs-string">"</span></span>)); list.IsEmptyChanged.Subscribe(e =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">$"IsEmpty changed: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{e}</span></span></span><span class="hljs-string">"</span></span>)); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"# Add 'first'"</span></span>); list.Add(<span class="hljs-string"><span class="hljs-string">"first"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"\n# Add 'second'"</span></span>); list.Add(<span class="hljs-string"><span class="hljs-string">"second"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"\n# Remove 'first'"</span></span>); list.Remove(<span class="hljs-string"><span class="hljs-string">"first"</span></span>);</code> </pre><br><br>  We get the result: <br><blockquote>  #Add 'first' <br>  Count changing: 0 <br>  Before added: first <br>  Count changed: 1 <br>  IsEmpty changed: False <br>  Added: first <br><br>  #Add 'second' <br>  Count changing: 1 <br>  Before added: second <br>  Count changed: 2 <br>  Added: second <br><br>  #Remove 'first' <br>  Count changing: 2 <br>  Before removed: first <br>  Count changed: 1 <br>  Removed: first <br></blockquote><br>  We are notified of what has been added or removed, as well as a change in the number of elements and the sign of the emptiness of the collection. <br>  Moreover: <br>  - ItemsAdded / ItemsRemoved / BeforeItemsAdded / BeforeItemsRemoved return the added / deleted item itself <br>  - CountChanging / CountChanged return the number of elements before and after the change. <br>  - IsEmptyChanged returns the new value of the collection empty sign <br><br><h4>  There is one subtlety </h4><br>  So far, everything is predictable.  Now imagine that we only want to count the number of records in the collection based on the addition and deletion notifications.  What could be easier? <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> count = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveList&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); list.ItemsAdded.Subscribe(e =&gt; count++); list.ItemsRemoved.Subscribe(e =&gt; count--); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { list.Add(i); } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i+=<span class="hljs-number"><span class="hljs-number">2</span></span>) { list.Remove(i); } Assert.That(count, Is.EqualTo(list.Count));</code> </pre><br>  The test was successful.  Let's change the principle of filling the collection, add many elements at once: <br><pre> <code class="cs hljs">list.AddRange(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>)); list.RemoveAll(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>).Select(i =&gt; i * <span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre><br>  Successfully.  It seems there is no dirty trick.  Although stand ... <br><pre> <code class="cs hljs">list.AddRange(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)); list.RemoveAll(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>).Select(i =&gt; i * <span class="hljs-number"><span class="hljs-number">2</span></span>));</code> </pre><br>  Oh!  The test failed and count == 0. It seems that we did not take into account something.  Let's figure it out. <br><br>  The thing is that ReactiveList &lt;T&gt; is implemented not as primitive as it may seem.  When the collection changes significantly, it disables notifications, makes all changes, turns notifications back on and sends a reset signal: <br><pre> <code class="cs hljs">list.ShouldReset.Subscribe(_ =&gt; Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"ShouldReset"</span></span>));</code> </pre><br>  Why is this done?  Sometimes the collection changes significantly: for example, 100 elements are added to an empty collection, half of the elements are removed from a large collection, or it is completely cleared.  In this case, there is no sense in reacting to every small change - it will be more expensive than waiting for the end of a series of changes and reacting as if the collection is completely new. <br>  In the last example, this is what happens.  ShouldReset is of type IObservable &lt;Unit&gt;.  Unit is essentially void, only in the form of an object.  It is used in situations where you need to notify the subscriber of a certain event, and it is only important that it happened, you do not need to transmit any additional data.  Just our case.  If we subscribed to it, we would see that after the insert and delete operations we received a reset signal.  Accordingly, to update the counter correctly, we need to slightly change our example: <br><pre> <code class="cs hljs">list.ItemsAdded.Subscribe(e =&gt; count++); list.ItemsRemoved.Subscribe(e =&gt; count--); list.ShouldReset.Subscribe(_ =&gt; count = list.Count);</code> </pre><br>  Now the test passes and everything is wonderful again.  Just do not forget that some notifications may not come, and handle these situations.  And, of course, do not forget to test such situations when collections change a lot. <br><br><h5>  Rules for Suppressing Change Notifications </h5><br>  We saw that with a strong change in the collection, a reset signal appears.  How can you control this process? <br>  There is one optional argument in the ReactiveList &lt;T&gt; constructor: double resetChangeThreshold = 0.3.  And after creating the list, you can change it through the ResetChangeThreshold property.  How is it used?  Notifications of changes will be suppressed if the result of dividing the number of elements added / removed by the number of elements in the collection itself is greater than this value, and if the number of elements added / removed is strictly greater than 10. This is evident from the source code and no one guarantees that these rules will not change in the future. <br>  In our example, <i>100/0&gt; 0.3</i> and <i>50/100&gt; 0.3</i> , so the notifications were suppressed both times.  Naturally, you can vary ResetChangeThreshold and substitute the collection for a specific place of use. <br><br><h5>  How do we suppress notifications ourselves? </h5><br>  In the first example with a counter, we saw the following code: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { list.Add(i); }</code> </pre><br>  Here, items are added one by one, so change notifications are always sent.  But we add a lot of elements and want to suppress notifications for a while.  How?  Using SuppressChangeNotifications ().  Anything inside using will not trigger change notifications: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (list.SuppressChangeNotifications()) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100</span></span>; i++) { list.Add(i); } }</code> </pre><br><br><h4>  What about changes to the elements of the collection? </h4><br>  We saw that in ReactiveList &lt;T&gt; there are sources of notifications ItemChanged and ItemChanging - changes to the elements themselves.  Let's try to use them: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveList&lt;PersonViewModel&gt;(); list.ItemChanged.Subscribe(e =&gt; Console.WriteLine(e.PropertyName)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> vm = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PersonViewModel(<span class="hljs-string"><span class="hljs-string">"Name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Surname"</span></span>); list.Add(vm); vm.FirstName = <span class="hljs-string"><span class="hljs-string">"NewName"</span></span>;</code> </pre><br>  Nothing has happened.  We were deceived, and ReactiveList doesn‚Äôt really follow the element changes?  Yes, but only by default.  In order for it to track changes inside its elements, you just need to enable this feature: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveList&lt;PersonViewModel&gt;() { ChangeTrackingEnabled = <span class="hljs-literal"><span class="hljs-literal">true</span></span> };</code> </pre><br>  Now everything works: <br><blockquote>  FullName <br>  Firstname <br></blockquote><br>  In addition, it can be turned on and off as you work.  When you turn off the existing internal subscriptions to the items will be deleted, when turned on - they will be created.  Naturally, when adding / removing items, subscriptions are also deleted and added. <br><br><hr><br><h4>  Inherited collections </h4><br>  How often do situations arise when you need to select only a part of the elements from an existing collection, or sort them, or convert?  And when you change the original collection to change dependent.  Such situations are not uncommon, and there is a tool in ReactiveUI that makes this easy to do.  His name is DerivedCollection.  They are inherited from ReactiveList and, therefore, the possibilities are the same, except that when trying to change such a collection an exception will be thrown.  A collection can change only when its base collection changes. <br>  We will not consider notifications of changes again, everything is as it was.  Let's see what transformations can be applied to the base collection. <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> list = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ReactiveList&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;(); list.AddRange(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">5</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> derived = list.CreateDerivedCollection( selector: i =&gt; i*<span class="hljs-number"><span class="hljs-number">2</span></span>, filter: i =&gt; i % <span class="hljs-number"><span class="hljs-number">2</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span>, orderer:(a, b) =&gt; b.CompareTo(a)); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">", "</span></span>, list)); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">", "</span></span>, derived)); list.AddRange(Enumerable.Range(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">", "</span></span>, list)); Console.WriteLine(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.Join(<span class="hljs-string"><span class="hljs-string">", "</span></span>, derived));</code> </pre><br>  We see that it is possible to transform the value, filter the original elements (before the transformation!) And pass a comparator for the transformed elements.  Moreover, only the selector is required, the rest is optional. <br>  There are also method overloads that allow using not only INotifyCollectionChanged as a base collection, but even IEnumerable &lt;&gt;.  But then you have to give the inherited collection a way to get a reset signal. <br>  Here, the inherited collection takes odd elements from the source, doubles their value and sorts from larger to smaller.  The console will be: <br><blockquote>  1, 2, 3, 4, 5 <br>  10, 6, 2 <br><br>  1, 2, 3, 4, 5, 2, 3, 4 <br>  10, 6, 6, 2 <br></blockquote><br><br><h4>  Stay tuned </h4><br>  This time we discussed some details of working with properties not described in the last part.  We ensured that the implementation of the property took one line, and found out that the order of notifications about their changes cannot be believed.  The main theme was the collection.  We figured out what notifications can be received from ReactiveList when it changes.  We found out why and under what conditions notifications are suppressed automatically, as well as how to suppress them with our own hands.  Finally, we tried to use inherited collections and made sure that they know how to filter, transform and sort the data of the basic collection, responding to its changes. <br>  In the next part we will talk about the teams and consider the question of testing the view model.  We will find out what problems are connected with this and how they are solved.  And then we move on to the View + ViewModel bundle and try to implement a small GUI application that uses the tools already described. <br><br>  See you! </div><p>Source: <a href="https://habr.com/ru/post/303898/">https://habr.com/ru/post/303898/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../303888/index.html">3DO and Android NDK and how not to get into anything ...</a></li>
<li><a href="../30389/index.html">And what are you after this professionals?</a></li>
<li><a href="../303890/index.html">Secrets of the most effective people (part 1)</a></li>
<li><a href="../303894/index.html">Configuring the Overrides URL in Keepass2</a></li>
<li><a href="../303896/index.html">How to become a professional web developer: a practical guide</a></li>
<li><a href="../3039/index.html">Book social network</a></li>
<li><a href="../30390/index.html">Profit flows "sinking business"</a></li>
<li><a href="../303900/index.html">We launch a simple blog on Wagtail CMS (Django) - part 1</a></li>
<li><a href="../303902/index.html">Cooking Open Build Service 2.6</a></li>
<li><a href="../303904/index.html">Apei Gaming - to be a project! (Part 2)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>