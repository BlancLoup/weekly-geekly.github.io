<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Conflict-Free Replication: CRDT in Theory and Practice</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In distributed repositories or editors of any data, support for making changes offline, without blocking or conflicts, is often needed. Different appr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Conflict-Free Replication: CRDT in Theory and Practice</h1><div class="post__text post__text-html js-mediator-article">  In distributed repositories or editors of any data, support for making changes offline, without blocking or conflicts, is often needed.  Different approaches are used for this, one of which is the conflict-free replicated data type (CRDT) algorithms and data types. <br><img src="https://habrastorage.org/files/a51/e03/6b8/a51e036b89dd4ee6a36ba8b3f25ccabf.png"><br><a name="habracut"></a><br><br><h1>  What for? </h1><br>  Make readonly-replica easy and everyone understands how.  The ability to write to the replica is a complicated thing.  There is such a <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D0%25B5%25D0%25BE%25D1%2580%25D0%25B5%25D0%25BC%25D0%25B0_CAP">CAP theorem</a> : data consistency ( <u>with</u> onsustency), accessibility ( <u>a</u> vailability), resistance to separation ( <u>p</u> artition tolerance) - select any two.  In CRDT, this problem is solved by providing strong eventual consistency ( <abbr title="translation of the term is strange, I will not try to do it">SEC</abbr> ) and state monotony. <br><br><h1>  Strong eventual consistency </h1><br>  Suppose that you can make changes to the replicas that they somehow exchange.  Eventual consistency is called the organization of interaction and storage of data, in which all replicas, after the termination of making changes to them, will eventually eventually come to an equivalent state. <br>  Strong Eventual Consistency imposes another restriction: replicas that receive the same updates (no matter in what order), come to an equivalent state immediately after receiving updates. <br>  Do not confuse SEC and sequential consistency: suppose that a list in which you can add and remove elements does not have to guarantee an add-delete sequence in order to satisfy the SEC (for example, the removal priority must be added). 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h1>  Conflict and monotony </h1><br>  There may be conflicts in the EC system.  Conflict - these are the changes that, when applied to different replicas, bring them to a consistent state, but when combining the states of the replicas, a certain system invariant is violated.  Conflicts are resolved by state rollbacks or in other ways that may even involve user interaction. <br>  In CRDT, it is assumed that the system provides the SEC and its state monotonously progresses, without leading to conflicts.  Monotony in this sense means the absence of kickbacks: operations cannot be canceled by returning the system to an earlier state.  The states of such a system are connected by a partial order relation; in mathematics, such a system with a join operation defined on it is called a semilattice. <br><br><h1>  Lattices and semilattices </h1><br>  A semilattice is a semigroup whose binary operation is commutative and idempotent (there is a formal explanation on Wikipedia, <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%2583%25D1%2580%25D0%25B5%25D1%2588%25D1%2591%25D1%2582%25D0%25BA%25D0%25B0">in Russian</a> and in <a href="https://en.wikipedia.org/wiki/Lattice_(order)">more detail in English</a> , <a href="http://www.math.hawaii.edu/~jb/math618/os2uh.pdf">and here with mathematics</a> ). <br>  A semilattice is a partially ordered set: the elements (not necessarily all) are related by the ‚Äúfollows‚Äù relation. <br>  The operation on the semilattice is: <br><ul><li>  idempotent: a ‚ãÅ a = a </li><li>  associative: (a ‚ãÅ b) ‚ãÅ c = a (b c) </li><li>  commutative: a ‚ãÅ b = b ‚ãÅ a </li></ul><br>  This operation can be either the exact upper bound (least upper bound, LUB) for the upper (join) semilattice, or the exact lower bound (the greatest lower bound) for the lower (meet) semilattice. <br>  Difference of a tree from a semilattice: <br><img src="https://habrastorage.org/files/b31/d14/6aa/b31d146aaf3143a5af139338b57bb5ce.png"><br>  And this is a complete lattice, on it both LUB and GLB are defined simultaneously: <br><img src="https://habrastorage.org/files/eb7/8e1/52f/eb78e152f0c045efaabe6e8e96955f8b.png"><br>  An example of an upper semilattice is depicted on the CDRV.  The difference is that a common ancestor is not necessary for combining elements.  These are the algebraic structures that interest us now. <br><br>  Many states in version control systems, such as git or svn, are in a sense a complete lattice: they have a partial order relation defined, revisions have a common ancestor and can be reduced.  With elements of the upper semilattice, you can perform the join operation, making their two elements from two elements. <br><br><h1>  CvRDT vs CmRDT </h1><br>  For different tasks, different ways of organizing interaction and data storage are convenient.  CRDT can be divided into two classes: <br><ul><li>  Commutative ( <u>c</u> o <u>m</u> mutative, CmRDT, op-based): suppose you have a list.  When you add an item, you send to all the replicas only this changed state (the added item).  Operations must be commutative so that the state of the replica does not depend on the order of receiving updates. </li><li>  Storage based states ( <u>c</u> on <u>v</u> ergent: CvRDT, state-based): in this case, it is not individual updates that are sent, but the entire data structure (that is, the entire list, in the case of a list).  The data structure must support operations: <br><ul><li>  query - read something without changing its state (for example: is there an item in the list?) </li><li>  update - change the structure (for example: add an item to the list) </li><li>  merge - to stop the state, which came from another replica.  This operation must be commutative, associative, and idemonet: all states in any direction in any direction do not ‚Äúreturn‚Äù the system to an earlier state, but monotonously increase the state of the system.  If you combine all the replicas, they must come to an equivalent state, combining all the changes made in the replicas. </li></ul><br></li></ul><br>  Visual comparison: <br><img src="https://habrastorage.org/files/315/67f/fa4/31567ffa4ae449eea88a226737c1484a.png"><br>  The classes CvRDT and CmRDT are equivalent (the proof of this theorem is in the work of Marc Shapiro in the "references" below).  Any CRDT structure can be represented as both CvRDT and CmRDT. <br>  However, from the point of view of the requirements for the data transfer method, they are different: CmRDT requires some way of delivering notifications to replicas, while all CvRDT needs is to write and read the state (but this state can be quite large). <br><br><h1>  CRDT Example and Record </h1><br>  Let's make a list in which you can add and remove items.  It is called 2P-Set. <br>  On the cue there are two sets: the added element (A) and the removed (R; this set is often called the tombstone set), initially empty.  When adding an element, we add it to A, when deleting it - to R. Checking the inclusion in the set consists in checking whether there is an element in R and whether it is in A. It turns out that deletion is more important than adding: once you delete an element, you cannot add it back: elements are not deleted from R and A. <br>  The math notation looks like this: <br><img src="https://habrastorage.org/files/644/e0d/85c/644e0d85c9d64c33b5fc6c0d79f52ca0.png"><br>  This is a CvRDT structure that, for each operation, passes the entire list.  In an obvious way, you can convert it to a CmRDT equivalent.  For simplicity, let's assume a very simple case when add is always delivered to remove.  The mathematical notation for CmRDT looks like this: <br><div class="spoiler">  <b class="spoiler_title">How to understand this</b> <div class="spoiler_text">  payload - what is located on the replica <br>  initial - its initial state <br>  query - a system status query that does not change it, is executed locally on the replica <br>  update - an operation that changes the state of the system <br>  atSource is the part of the update that runs on the initiator replica <br>  downstream - updates that will be performed on replicas for this operation </div></div><br><img src="https://habrastorage.org/files/a01/578/476/a015784762324c01a100c952347290f9.png"><br><br><h1>  Other structures </h1><br>  Of the known, described in the works and implemented in libraries, there are such structures: <br><ul><li>  G-Counter: (grow-only) monotonously increasing counter </li><li>  PN-Counter: (positive-negative) counter that can be reduced </li><li>  LWW-Register: (last-writer-wins) register with the principle of the last entry overriding </li><li>  MV-Register: (multi-value) multi-value register </li><li>  G-Set: many elements without deletion </li><li>  2P-Set: with priority deletion </li><li>  PN-Set: uses on-delete operation counter </li><li>  LWW-Set: priority time of operation </li><li>  OR-Set: (observed-remove) list with identifiers </li></ul><br>  There are also structures that describe vertices and links in columns, based on lists. <br><br><h1>  CRDT Optimization </h1><br>  The usual way to make a CRDT structure is to assemble it from others: for example, 2P-set consists of two lists: added and deleted.  In practice, there may be restrictions imposed on the operation or amount of data transfer.  In this case, you can make some concessions.  For example, if items are frequently added and removed to the list, the list of deleted items will grow dramatically over time.  You can make a garbage collector, which would delete deleted on some reasonable condition.  For example, those that were deleted more than a year ago, or those about which all replicas received notifications. <br><br><h1>  CRDT vs OT </h1><br>  Operational Transformation is an approach commonly used in text editing.  Both approaches provide consistency (EC).  OT has higher server requirements, more complex and less stable algorithms.  Also, some studies have shown that OT algorithms sometimes do not converge (converge), as stated in the implementation.  However, it is impossible to clearly make a choice and say ‚Äúwhat‚Äôs better‚Äù.  Of the known CRDT text editors, there are, for example, WOOT (WithOut Operational Transformation), Treedoc and Logoot. <br><br><h1>  CRDT at KeePass </h1><br>  In KeePass, there is a merge function with a file, in my <a href="https://github.com/antelle/keeweb">web version</a> I had to devote special attention to making human offline synchronized.  KeePass assigns unique identifiers to all objects and stores the ID of everything deleted in DeletedObjects.  To synchronize the directory graph, they store the date of the last position change (location change date). <br>  But there is a nuance.  Records still have a change history, from where you can delete items.  Entries in the history are identified only by time.  Deleted entries from history are not saved anywhere even during synchronization.  What does this work out?  If you delete an entry from history and zinkkat with the previous state, it will magically return.  It turns out that in terms of synchronization as the main scenario of the application, the story will often appear back. <br>  What to do? <br>  Since  other clients can not be affected, you can enter restrictions.  Consider the assumptions that we can make: <br><ul><li>  files are synchronized via central storage, not p2p </li><li>  together with the file you can always store any metadata on the replica </li></ul><br>  Based on this, it was decided to keep a list of deleted and added history states (local tombstone set) from the moment of making changes to the file before sending changes to the repository.  At the same time, of course, synchronization with arbitrary p2p files from the past will still be strange, but this is no longer the main scenario. <br>  To submit changes to the repository, the client must: <br><ol><li>  compare file revision (versionTag) with last received </li><li>  if it has changed, load and freeze </li><li>  if there are local changes, fill in with versionTag check </li><li>  in case of conflict goto 2 </li><li>  clear local state (tombstone set) </li></ol><br><br><h1>  Links </h1><br>  <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">CRDT</a> - Wikipedia <br>  <a href="http://christophermeiklejohn.com/crdt/2014/07/22/readings-in-crdts.html">Readings in CRDT</a> - many useful publications about CRDT <br>  <a href="https://github.com/ljwagerfield/crdt">CRDT - A digestible explanation with less math (GitHub)</a> - a small description of CRDT without mathematics <br>  <a href="https://github.com/pfraze/crdt_notes">crdt_notes (GitHub)</a> - CRDT algorithms collected on one page <br>  <a href="https://hal.inria.fr/inria-00609399">Conflict-free replicated data types (paper)</a> - introduction to CRDT <br>  <a href="http://hal.inria.fr/inria-00555588">A comprehensive study of the Convergent and Commutative Replicated Data Types (paper)</a> - detailed explanation in detail, with mathematics and pictures, 40 pages. <br>  <a href="">An optimized conflict-free replicated set</a> - an example of CRDT structure optimization <br>  <a href="https://github.com/antelle/kdbxweb">kdbxweb (GitHub)</a> - js-lib to work with the KeePass format with the support of merge, which was discussed </div><p>Source: <a href="https://habr.com/ru/post/272987/">https://habr.com/ru/post/272987/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../272965/index.html">About open data, projects based on them, and what happens with open government data in Russia</a></li>
<li><a href="../272967/index.html">Objective-C integration testing on the example of part of the RSS reader</a></li>
<li><a href="../272969/index.html">Persuasive web design</a></li>
<li><a href="../272971/index.html">Why do we need plain-text letters, and how they should be done: 6 tips</a></li>
<li><a href="../272983/index.html">Writing code for Node.js in the state machine style</a></li>
<li><a href="../272989/index.html">Screenshot game - the hard way</a></li>
<li><a href="../272993/index.html">Simple Blender. Part 4</a></li>
<li><a href="../272995/index.html">You can not use tools</a></li>
<li><a href="../272999/index.html">Audio and video in the Tox messenger</a></li>
<li><a href="../273001/index.html">Black PR Telegram. Who to believe?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>