<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Methods like first class citizens in C ++</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The other day, while walking on the bug tracker, gcc came across an interesting bug , it uses several C ++ 11 features at once: 


- std :: function -...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Methods like first class citizens in C ++</h1><div class="post__text post__text-html js-mediator-article">  The other day, while walking on the bug tracker, gcc came across an <a href="http://gcc.gnu.org/bugzilla/show_bug.cgi%3Fid%3D51927">interesting bug</a> , it uses several C ++ 11 features at once: <br><ul><li>  <b>std :: function</b> - the mechanism for creating functors - function objects </li><li>  <b>non static member initialisation</b> - a <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2628.html">mechanism for initializing class members outside the constructor</a> </li><li>  <b>lambda</b> - here and so everything is clear.  Exhaustive articles were <a href="http://habrahabr.ru/post/66021/">here</a> . </li></ul><br><br>  Analyzing this bug, I thought that now you can conveniently implement methods as first class citizens <a name="habracut"></a><br><br>  Actually, Wikipedia explains to us that such <a href="http://en.wikipedia.org/wiki/First-class_citizen">first class citizens</a> are an entity that can be created during the program‚Äôs work, passed as a parameter, assigned to a variable, can be the result of a function‚Äôs operation. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  Training </h4><br><h5>  Choosing a compiler </h5><br>  Since I didn‚Äôt have fresh gcc or msvc on hand, I decided to put together a fresh clang-3.1: <pre><code class="hljs ruby">mkdir llvm cd llvm svn co <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/llvm.org/svn</span></span><span class="hljs-regexp"><span class="hljs-regexp">/llvm-project/llvm</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tags/</span></span>RELEASE_31/final ./ cd tools svn co <span class="hljs-symbol"><span class="hljs-symbol">http:</span></span>/<span class="hljs-regexp"><span class="hljs-regexp">/llvm.org/svn</span></span><span class="hljs-regexp"><span class="hljs-regexp">/llvm-project/cfe</span></span><span class="hljs-regexp"><span class="hljs-regexp">/tags/</span></span>RELEASE_31/final clang cd ../../ mkdir build cd build cmake ../llvm -DCMAKE_INSTALL_PREFIX=<span class="hljs-regexp"><span class="hljs-regexp">/home/pixel</span></span><span class="hljs-regexp"><span class="hljs-regexp">/fakeroot -DCMAKE_BUILD_TYPE=Release make -j4 make check-all make install</span></span></code> </pre> <br><br><h5>  Choosing the libcxx library </h5><br>  I also decided to build the libcxx library to use all the features of the new compiler: <pre> <code class="hljs dos"><span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> libcxx <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> libcxx svn co http://llvm.org/svn/llvm-project/libcxx/trunk ./ <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../ <span class="hljs-built_in"><span class="hljs-built_in">mkdir</span></span> build_libcxx <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> build_libcxx CC=clang CXX=clang++ cmake ../libcxx -DCMAKE_INSTALL_PREFIX=/home/pixel/fakeroot -DCMAKE_BUILD_TYPE=Release make -j4 make install</code> </pre> <br><br>  A few words about libcxx build: I decided to get the latest version from the trunk, since the last release did not want to be assembled from me (I didn‚Äôt want to understand, so I took the trunk).  Also libcxx should be built using clang, for this I put the CC and CXX environment variables to replace the compiler with clang.  Also, for some reason, I did not want to run tests ( <b>make check-libcxx</b> ) <br><br><h5>  CMakeLists.txt example to use freshly picked clang and libcxx </h5><br><pre> <code class="hljs lisp">cmake_minimum_required(<span class="hljs-name"><span class="hljs-name">VERSION</span></span> <span class="hljs-number"><span class="hljs-number">2.8</span></span>) project (<span class="hljs-name"><span class="hljs-name">clang_haxxs</span></span>) add_definitions(<span class="hljs-name"><span class="hljs-name">-std=c++11</span></span> -nostdinc++) include_directories(<span class="hljs-name"><span class="hljs-name">/home/pixel/fakeroot/lib/clang/3</span></span>.<span class="hljs-number"><span class="hljs-number">1</span></span>/include) include_directories(<span class="hljs-name"><span class="hljs-name">/home/pixel/fakeroot/include/c++/v1</span></span>) link_directories(<span class="hljs-name"><span class="hljs-name">/home/pixel/fakeroot/lib</span></span>) add_executable(<span class="hljs-name"><span class="hljs-name">clang_haxxs</span></span> main.cpp) set_target_properties(<span class="hljs-name"><span class="hljs-name">clang_haxxs</span></span> PROPERTIES LINK_FLAGS -stdlib=libc++)</code> </pre><br><br>  Accordingly, for cmake, we redefine the CC and CXX environment variables in the same way as for libcxx. <br><br><h4>  Explanatory Example </h4><br>  So, the preparatory process is completed, go to the example: <br><pre> <code class="hljs kotlin">#include &lt;iostream&gt; #include &lt;functional&gt; using namespace std; struct FirstClass { FirstClass(): x(<span class="hljs-number"><span class="hljs-number">0</span></span>) { } int get_x() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } function&lt;int ()&gt; f1 = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() -&gt; int { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"called member function f1..."</span></span> &lt;&lt; endl; ++x; f1 = f2; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>; }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: function&lt;int ()&gt; f2 = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() -&gt; int { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"called member function f2..."</span></span> &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }; int x; }; int main() { FirstClass m; m.f1(); m.f1(); function&lt;int ()&gt; f3 = []() -&gt; int { cout &lt;&lt; <span class="hljs-string"><span class="hljs-string">"called free function f3..."</span></span> &lt;&lt; endl; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100500</span></span>; }; m.f1 = f3; m.f1(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre><br>  The output of the program: <br> <code>called member function f1... <br> called member function f2... <br> called free function f3...</code> <br> <br>  In fact, similar functionality can be implemented without c ++ 11, but it will look less readable.  The main contribution to the readability of the code is made by <b>non-static member initialisation</b> - we get a declaration and method implementation similar to the usual methods in C ++ - 03.  The remaining features are more or less emulated by C ++ - 03 tools and third-party libraries: boost :: function, boost :: lambda. <br><br><h4>  Immersion </h4><br>  Let's take a closer look at what we can do with such objects: <br><h5>  Emulation of static and non-static methods </h5><br>  Everything is simple, the method is not static if it has access to <b>this</b> .  Accordingly, when defining a lambda function in the body of a class, we add to the capture list <b>this</b> .  Now, from the lambda function, we can apply to all members of the class (including private members). <br><br>  Here it has a peculiarity: in fact, the concept of static functions is not quite correctly used here, since initially in C ++ they are defined as functions that can be called without a created object, here we still have to create an object in order to reach a function. <br><br><h5>  Setting methods outside the class </h5><br>  We figured out how to define a non-static function, now it remains to understand how to do it outside the class, it‚Äôs very simple - you need to pass the object to which this function is attached to the capture list: <pre> <code class="hljs markdown"> function<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag"> ()&gt;</span></span></span></span> f4 = [<span class="hljs-string"><span class="hljs-string">&amp;m</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) -&gt;int { cout <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">called</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">free</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">function</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">f4</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">with</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">capture</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">list...</span></span></span></span><span class="xml"><span class="hljs-tag">" &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">m.get_x</span></span></span></span><span class="xml"><span class="hljs-tag">() + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span><span class="xml"><span class="hljs-tag">; }; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">m.f1</span></span></span></span><span class="xml"><span class="hljs-tag"> = </span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">f4;</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">m.f1</span></span></span></span><span class="xml"><span class="hljs-tag">();</span></span></span></span></code> </pre> <br><br>  Here we must be careful when passing the object reference to the capture list, since the operation of defining the function and linking it to the object is separated in time, the following error can be made: <br>  "Snap to the wrong object as specified in the capture list." <br><br>  Also, one more restriction that is present here, if we attach a function outside the class declaration, then we lose access to the private class variables: <pre> <code class="hljs markdown"> function<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">int</span></span></span></span><span class="xml"><span class="hljs-tag"> ()&gt;</span></span></span></span> err = [<span class="hljs-string"><span class="hljs-string">&amp;m</span></span>](<span class="hljs-link"></span><span class="hljs-link"></span>) -&gt;int { cout <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;&lt; "</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">called</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">free</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">function</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">err</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">with</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">capture</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">list...</span></span></span></span><span class="xml"><span class="hljs-tag">" &lt;&lt; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">endl</span></span></span></span><span class="xml"><span class="hljs-tag">; </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">return</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">mx</span></span></span></span><span class="xml"><span class="hljs-tag"> + </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">1</span></span></span></span><span class="xml"><span class="hljs-tag">; };</span></span></span></span></code> </pre> <br>  In this case, the compiler curses: <code>/usr/src/projects/clang/usage/main.cpp:64:12: error: 'x' is a private member of 'FirstClass'</code> <br><br><h5>  Do not override a method </h5><br>  Everything is simple here, since the method is an ordinary member of the class, then adding const to its description, we just get what we need: <pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FirstClassConst</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> function &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>()&gt; f1 = []() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; }; }; FirstClassConst mc; mc.f1 = f3;</code> </pre><br>  The compiler scolds us: <code>/usr/src/projects/clang/usage/main.cpp:70:8: error: no viable overloaded '=' <br> mc.f1 = f3; <br> ~~~~~ ^ ~~</code> <code>/usr/src/projects/clang/usage/main.cpp:70:8: error: no viable overloaded '=' <br> mc.f1 = f3; <br> ~~~~~ ^ ~~</code> <br> <br><h5>  Lack of const methods </h5><br>  Fair C ++ methods have the ability to determine that a method does not change class members, and it can be applied to a constant object, such methods are marked with the const qualifier.  In the example, this is the get_x method. <br>  If we implement methods as objects, this possibility disappears; instead, we can change the terms of a constant object: <pre> <code class="hljs cpp"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MutableFirstClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; MutableFirstClass(): x(<span class="hljs-number"><span class="hljs-number">0</span></span>){} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonConstMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ ++x; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; } function &lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>()&gt; f1 = [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]() -&gt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;x = <span class="hljs-number"><span class="hljs-number">100500</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }; }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MutableFirstClass mm; mm.f1(); <span class="hljs-comment"><span class="hljs-comment">//mm.nonConstMethod();</span></span></code> </pre> <br>  If you uncomment the last call, the compiler swears as follows: <code>/usr/src/projects/clang/usage/main.cpp:93:2: error: member function 'nonConstMethod' not viable: 'this' argument has type 'const MutableFirstClass', but function is not marked const <br> mm.nonConstMethod(); <br> ^~</code> <code>/usr/src/projects/clang/usage/main.cpp:93:2: error: member function 'nonConstMethod' not viable: 'this' argument has type 'const MutableFirstClass', but function is not marked const <br> mm.nonConstMethod(); <br> ^~</code> <br>  Most likely, the following sequence of actions occurs: <br>  <b>non static member initialisation is</b> nothing more than syntactic sugar, and therefore <b>this</b> <b>capture</b> in the <b>capture list</b> takes place in the constructor, and in the constructor this has the type <b>MutableFirstClass * const</b> , and therefore we can change the values ‚Äã‚Äãof variables. <br><br>  As far as I remember, in constant objects, change the values ‚Äã‚Äãof members - UB (except for members marked with the mutable qualifier), so you need to carefully use such methods in constant objects. <br><br><h4>  What's next </h4><br>  In fact, the possibility of using this functionality is quite controversial - on the one hand, we can easily implement the ‚ÄúDecorator‚Äù pattern almost as in a python, and this is one of the strengths: we get rid of the tedious implementation of a heap of classes of heirs, as in GoF.  We can also decorate each object in an individual way: for example, we can write a <b>decorate</b> function that takes an object as input and adds a decorator to one of the methods.  This cannot be done using this pattern as described in GoF. <br><br>  On the other hand, the lack of protection for members of constant objects is a very serious drawback, so you need to seriously consider before applying this solution. <br><br>  Also, memory consumption increases, in the implementation of libcxx each such method takes 16 bytes, so with an increase in the number of methods, we will receive more and more bold objects. <br><br>  You should also take time measurements and compare the speed of calling such methods compared to native C ++ methods (you can compare speed with virtual methods). </div><p>Source: <a href="https://habr.com/ru/post/145673/">https://habr.com/ru/post/145673/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../145668/index.html">Buying a brand on the conveyor</a></li>
<li><a href="../145669/index.html">Students fined for the site with subtitles</a></li>
<li><a href="../145670/index.html">What is Red Hat CloudForms?</a></li>
<li><a href="../145671/index.html">Delivering e-books from Amazon costs more than delivering paper books</a></li>
<li><a href="../145672/index.html">Effective web development with Visual Studio 2012: innovations in the WebForms editor</a></li>
<li><a href="../145674/index.html">"Random Millionaire" received from the bank $ 7.7 million by mistake</a></li>
<li><a href="../145677/index.html">Connecting Access Points to a Cisco Wi-Fi Controller</a></li>
<li><a href="../145678/index.html">Practical tasks from unity3dstudent.com</a></li>
<li><a href="../145679/index.html">ObjectDB - database management system for Java applications</a></li>
<li><a href="../145680/index.html">Website development with responsive design</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>