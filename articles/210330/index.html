<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>We refuse callbacks: Generators in ECMAScript 6</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="I constantly hear people whining about asynchronous callbacks in JavaScript . Keeping in mind the order of execution in this language is a bit difficu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>We refuse callbacks: Generators in ECMAScript 6</h1><div class="post__text post__text-html js-mediator-article"> I constantly hear people whining about asynchronous callbacks in <code>JavaScript</code> .  Keeping in mind the order of execution in this language is a bit difficult (this is the case that is called ‚Äú <a href="http://callbackhell.com/">Callback Hell</a> ‚Äù or ‚Äú <a href="http://javascriptjabber.com/001-jsj-asynchronous-programming/">The Pyramid of Doom</a> ‚Äù), if you have dealt with synchronous programming before.  My usual answer was ‚Äúyou have to deal with it somehow.‚Äù  After all, do we expect all programming languages ‚Äã‚Äãto look and feel the same?  Of course not. <br><br>  Everything was changed by a recent review of the draft <code>ECMAScript 6</code> , which describes the generators - the possibility of a language that will completely change our way of writing both server-side and client-side <code>JavaScript</code> .  With the help of generators, we can turn nested callbacks into a similar synchronous code without blocking our only <code>event loop</code> . <br>  For example, this code: <br><pre> <code class="javascript hljs"> setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ _get(<span class="hljs-string"><span class="hljs-string">"/something.ajax?greeting"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, greeting</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } _get(<span class="hljs-string"><span class="hljs-string">"/else.ajax?who&amp;greeting="</span></span>+greeting, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, who</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting+<span class="hljs-string"><span class="hljs-string">" "</span></span>+who); }); }); }, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre><br>  can be written like this: <br><pre> <code class="javascript hljs"> sync(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resume</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> (e) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> setTimeout(resume, <span class="hljs-number"><span class="hljs-number">1000</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> greeting = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> _get(<span class="hljs-string"><span class="hljs-string">'/something.ajax?greeting'</span></span>, resume) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> who = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> _get(<span class="hljs-string"><span class="hljs-string">'/else.ajax?who&amp;greeting='</span></span> + greeting, resume) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(greeting + <span class="hljs-string"><span class="hljs-string">' '</span></span> + who) } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> e; } });</code> </pre><br>  Interesting, isn't it?  Centralized exception handling and clear order of execution. <br><a name="habracut"></a><br><br><h4>  Uh, ECMAScript 6? </h4><br>  The examples in this article will work in <code>Chrome Canary 33.0.1716.0</code> .  Examples, except for those with <code>XHR</code> , should work in <code>Node.js</code> with the <code>--harmony</code> flag (from version 0.11, <i>approx. Transl.</i> ).  The generator implementation proposed in <code>JavaScript 1.7+</code> does not follow <code>ECMAScript 6</code> draft ‚Äî so you will have to make some changes to make the examples work in <code>Firefox</code> .  If you want to run these examples in <code>Canary</code> , you can run them in the same way as here. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  ES6 Generators </h4><br>  In order to understand what is happening in the examples above, we need to talk about what are <code>ES6</code> generators and what they allow you to do. <br><br>  According to the <code>ECMAScript 6</code> draft, generators are ‚Äúfirst-class coroutines that are objects that encapsulate pending execution contexts.‚Äù  Simply put, generators are functions that can stop their execution (using the <code>yield</code> keyword) and continue their execution from the same place after calling their <code>next</code> method.  <code>JavaScript</code> still performs only one task at the same time, but it is now able to pause execution in the middle of the body of a generator function and switch the context to something else.  Generators do not allow parallel execution of code and they do not know how to handle threads. <br><br><h4>  Modest iterator </h4><br>  Now that we've figured out a bit, let's look at the code.  We will write a small iterator to demonstrate the stop / continue syntax. <br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fibonacci</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">0</span></span>, b = <span class="hljs-number"><span class="hljs-number">1</span></span>, c = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> a; c = a; a = b; b = c + b; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> seq = fibonacci(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(seq.next().value); <span class="hljs-comment"><span class="hljs-comment">// 0 console.log(seq.next().value); // 1 console.log(seq.next().value); // 1 console.log(seq.next().value); // 2 console.log(seq.next().value); // 3 console.log(seq.next().value); // 5 } run();</span></span></code> </pre><br>  What's going on here: <br><ol><li>  The <code>run</code> function initializes the Fibonacci number generator (it is described by the special syntax <code>funtion*</code> ).  Unlike the usual function, this call does not start the execution of its body, but returns a new object - the generator. </li><li>  When the <code>run</code> function calls the generator method <code>next</code> (a synchronous operation), the code is executed until it reaches the <code>yield</code> . </li><li>  Running the <code>yield</code> stops the generator and returns the result to the outside.  The operations following <code>yield</code> have not been performed at this point.  The value (operand <code>a</code> for <code>yield</code> ) will be available outside through the <code>value</code> property of the result of the execution. <br>  The next time the generator calls the <code>next</code> method, the execution of the code continues from where it stopped at the previous <code>yield</code> . </li></ol><br><br>  You are probably wondering if the generator will ever come out of a <code>while</code> .  No, it will be executed inside the loop until someone calls its <code>next</code> method. <br><br><h4>  We follow the execution of the code </h4><br>  As shown in the previous example, the code located in the body of the generator after <code>yield</code> will not be executed until the generator continues.  You can also pass an argument to the generator, which will be substituted instead of the <code>yield</code> on which the previous execution of the generator was interrupted. <br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">powGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">"a"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">"b"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> g = powGenerator(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(g.next().value); <span class="hljs-comment"><span class="hljs-comment">// "a", from the first yield console.log(g.next(10).value); // "b", from the second console.log(g.next(2).value); // 100, the result</span></span></code> </pre><br>  The first execution of the generator returns the value <code>"a"</code> as the <code>value</code> property of the execution result.  Then we continue execution by passing a value of <code>10</code> to the generator.  Use the substitution to demonstrate what happens: <br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">powGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(---<span class="hljs-number"><span class="hljs-number">-10</span></span>----, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">"b"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  Then the generator reaches the second <code>yield</code> and again suspends its execution.  The value <code>"b"</code> will be available in the returned object.  Finally, we continue execution again, passing in argument <code>2</code> .  Substitution again: <br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">powGenerator</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.pow(---<span class="hljs-number"><span class="hljs-number">-10</span></span>----, ---<span class="hljs-number"><span class="hljs-number">-2</span></span>----); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre><br>  After this, the <code>pow</code> method is called, and the generator returns the value stored in the <code>result</code> variable. <br><br><h4>  Unreal synchrony: blocking <code>Ajax</code> </h4><br>  The iterator, issuing the Fibonacci sequence, and the mathematical functions with a lot of entry points are interesting, but I promised to show you a way to get rid of callbacks in your <code>JavaScript</code> code.  As it turns out, we can take some ideas from previous examples. <br><br>  Before we look at the following example, pay attention to the <code>sync</code> function.  It creates a generator, passing it the <code>resume</code> function and calls the <code>next</code> method on it to start its execution.  When the generator needs an asynchronous call, it uses <code>resume</code> as a callback and performs a <code>yield</code> .  When an asynchronous call performs <code>resume</code> , it calls the <code>next</code> method, continuing the execution of the generator and passing the result of the asynchronous call to it. <br><br>  Back to code: <br><pre> <code class="javascript hljs"> <span class="hljs-comment"><span class="hljs-comment">// ************** // framework code function sync(gen) { var iterable, resume; resume = function(err, retVal) { if (err) iterable.raise(err); iterable.next(retVal); // resume! }; iterable = gen(resume); iterable.next(); } function _get(url, callback) { var x = new XMLHttpRequest(); x.onreadystatechange = function() { if (x.readyState == 4) { callback(null, x.responseText); } }; x.open("GET", url); x.send(); } // **************** // application code sync(function* (resume) { log('foo'); var resp = yield _get("blix.txt", resume); // suspend! log(resp); }); log('bar'); // not part of our generator function's body</span></span></code> </pre><br>  Can you guess what you see in the console?  The correct answer is ‚Äúfoo‚Äù, ‚Äúbar‚Äù and ‚Äúwhat‚Äôs in blix.txt‚Äù.  Placing the code inside the generator, we make it look like a normal synchronous code.  We do not block the <code>event loop</code> ;  we stop the generator and continue to execute the code located further after the <code>next</code> call.  The future callback, which will be called on another tick, will continue our generator, passing it the desired value. <br><br><h4>  Centralized error handling </h4><br>  Centralized error handling within multiple asynchronous callbacks is a pain.  Here is an example: <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { firstAsync(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, a</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } secondAsync(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, b</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } thirdAsync(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, c</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> err; } callback(a, b, c); }); }); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(e); }</code> </pre><br>  The <code>catch</code> will never be executed due to the fact that the execution of the callback is part of a completely different callstack, in another tick of the <code>event loop</code> .  Exception handling must be located inside the callback function itself.  You can implement a higher order function to get rid of some duplicate error checks and remove some attachments using a library like <code>async</code> .  If you follow the <code>Node.js</code> convention about the error as the first argument, you can write a common handler that will return all errors back to the generator: <br><pre> <code class="javascript hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sync</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">gen</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> iterable, resume; resume = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, retVal</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err) iterable.raise(err); <span class="hljs-comment"><span class="hljs-comment">// raise! iterable.next(retVal); }; iterable = gen(resume); iterable.next(); } sync(function* (resume) { try { var x = firstAsync(resume); var y = secondAsync(resume); var z = thirdAsync(resume); // ‚Ä¶ do something with your data } catch (e) { console.log(e); // will catch errors from any of the three calls } });</span></span></code> </pre><br>  Now the exceptions that occur within any of the three functions will be processed by a single <code>catch</code> .  And the exception that occurred in any of the three functions will not allow subsequent functions to be executed.  Very good. <br><br><h4>  Simultaneous operations. </h4><br>  The fact that the generator code is executed from top to bottom does not mean that you cannot work with several asynchronous operations simultaneously.  <code>genny</code> like <code>genny</code> and <code>gen-run</code> give this API: they simply perform a number of asynchronous operations before continuing the execution of the generator.  Example using <code>genny</code> : <br><pre> <code class="javascript hljs"> genny.run(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">* (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resume</span></span></span><span class="hljs-function">) </span></span>{ _get(<span class="hljs-string"><span class="hljs-string">"test1.txt"</span></span>, resume()); _get(<span class="hljs-string"><span class="hljs-string">"test2.txt"</span></span>, resume()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res1 = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> resume, res2 = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> resume; <span class="hljs-comment"><span class="hljs-comment">// step 1 var res3 = yield _get("test3.txt", resume()); // step 2 console.log(res1 + res2); });</span></span></code> </pre><br><h4>  Total </h4><br>  Asynchronous de facto callbacks have been the main pattern in <code>JavaScript</code> for a long time.  But now with the generators in the browser ( <code>Firefox</code> with <code>JavaScript 1.7</code> and <code>Chrome Canary</code> few months ago) everything is changing.  New execution control constructs make it possible to use a completely new programming style, one that can compete with the traditional nested callback style.  It remains to wait for the <code>ECMAScript 6</code> standard to be implemented in tomorrow's <code>JavaScript</code> engines. </div><p>Source: <a href="https://habr.com/ru/post/210330/">https://habr.com/ru/post/210330/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../210314/index.html">Switch between EDGE / 3G / LTE in iPhone 5S / 5C (jailbreak)</a></li>
<li><a href="../210316/index.html">Nginx + Google-authenticator or not everything is not so easy ...</a></li>
<li><a href="../210320/index.html">CRM: between heaven and earth</a></li>
<li><a href="../210322/index.html">Iceland is going to use new high-temperature wells for energy</a></li>
<li><a href="../210328/index.html">News digest from the world of mobile development for the last week ‚Ññ38 (January 20-26, 2014)</a></li>
<li><a href="../210332/index.html">The look of the advertiser on web design: the basics of creating an atypical design for a typical site</a></li>
<li><a href="../210334/index.html">The most difficult game of all time</a></li>
<li><a href="../210336/index.html">PVS-Studio, CppCat. Interview with Andrei Karpov, technical director of these projects</a></li>
<li><a href="../210338/index.html">A selection of tricks in analyzing the security of web applications</a></li>
<li><a href="../210344/index.html">Input throttling on AngularJS using debounce</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>