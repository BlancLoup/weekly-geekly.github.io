<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dagaz: Kicks to common sense (part 6)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... my twin is waiting in the house of Ihi, I meet him, I raise my chip to [him] 
 I meet him at the Beautiful House. 
 I pick up three chips and find...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">🔎</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">📜</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">⬆️</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">⬇️</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dagaz: Kicks to common sense (part 6)</h1><div class="post__text post__text-html js-mediator-article"><img align="left" src="https://habrastorage.org/getpro/habr/post_images/43e/794/3a3/43e7943a3e289a281570ab8b68d347b8.png" alt="image">  <i><b>... my twin is waiting in the house of Ihi, I meet him, I raise my chip to [him]</b></i> <i><b><br></b></i>  <i><b>I meet him at the Beautiful House.</b></i> <i><b><br></b></i>  <i><b>I pick up three chips and find two chips, my counterpart behind me.</b></i> <i><b><br></b></i>  <i><b>...</b></i> <i><b><br><br></b></i>  <i><b>papyrus since the time of Ramses III</b></i> <br><br>  Until now, I considered games in which each figure acts as if “by itself”.  The interaction of the figures, in such games, is reduced to "eating" the enemy figures.  But not all games are as follows.  There are many games in which one shape can “strengthen” or “weaken” another, thereby changing its properties.  This is what I want to talk about today. <br><a name="habracut"></a><br><h4>  <b>5. In unity, strength</b> </h4><br>  The idea that the properties of figures may depend on their relative position is not new.  Apparently, this principle was used in the ancient Egyptian game <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B5%25D0%25BD%25D0%25B5%25D1%2582">Senet</a> , known since 3500 BC.  Nowadays, no one knows the exact rules of this game, but there are several reconstructions based on the analysis of materials discovered by Egyptologists. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      According <a href="http://www.cs.brandeis.edu/~storer/JimPuzzles/GAMES/Senet/INFO/WalkersRulesKendal.pdf">to</a> Timothy Kendall, published in 1978, the battle of the figures in Seneta was carried out in a special way.  The beaten figure was not removed from the board, but was reversed from the one who performed the turn.  This idea fits well with the name of the <b>Ibau</b> figures - “dancers” (unlike most other games, Senet used the dance metaphor, not the fighting).  The game of Senet was considered as a “training” in passing the soul of its death tests (the ancient Egyptians were very serious about this issue). <br><br>  An important point of the rules of Kendall is the ability to "protect" the figures with each other.  It is forbidden to "beat" a chip that is part of a "pair" - two chips belonging to one player, located in the adjacent fields of the board.  Unfortunately, Kendall's reconstruction does not specify a number of important points.  Is it possible to jump over a pair?  Is it possible to break the "troika" and "four" chips?  These questions are not answered.  The rules for running chips in “houses” (special board margins) are also not very successful.  As a result, the game is pretty tedious: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/J__os22LliA%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhOyjdht_vktiPOwJgMw9sB13sylg" frameborder="0" allowfullscreen=""></iframe><br><br>  There are several "improvements" to Kendall's rules, among which I would like to highlight the <a href="http://skyruk.livejournal.com/183773.html">version of</a> <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BA%25D0%25B8%25D1%2580%25D1%258E%25D0%25BA,_%25D0%2594%25D0%25BC%25D0%25B8%25D1%2582%25D1%2580%25D0%25B8%25D0%25B9_%25D0%2598%25D0%25B3%25D0%25BE%25D1%2580%25D0%25B5%25D0%25B2%25D0%25B8%25D1%2587">Dmitry Skiryuk</a> .  In this version of the rules, "pairs" prevent the promotion of other chips.  Jump them can not be!  It is also impossible to break a “pair”, but if there are three or more chips in a row - this is no longer a “pair”.  A chip that has two neighbors can be “beaten” (a “troika” is thus easily “broken up” in the middle).  Simple rule changes make the Senet Kendall a very dynamic and exciting game.  As in the case of the “ <a href="http://habrahabr.ru/post/225631/">Game from the city of Ur,</a> ” Dmitry did a great job of checking the proposed version of the rules in practice. <br><br>  <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B8%25D0%25B4%25D0%25B6%25D0%25B0">Sija</a> is another Egyptian game in which the figures act "together".  In this ancient game, which has survived to the present day, the capture of an enemy figure is carried out by “pinching” it into “tongs” from two sides.  It is quite possible that other “clamping” games, such as <a href="http://skyruk.livejournal.com/246910.html">Hnefatafl,</a> originated from this game. <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Weaop9VKhuo%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhhZIFCQnqaTypsUrlkAqyV8iSrSsQ" frameborder="0" allowfullscreen=""></iframe><br><br>  The method of taking "clamp in pincers" allows you to take several enemy figures at once (up to three figures, in different directions), but this is not the only possibility of "increasing productivity".  In the Tibetan game " <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1819">Min Mang</a> " it is allowed to take several enemy pieces at once, lined up, "closing" the line with their own figures on both sides.  Taken pieces "change color", just as it does in <a href="https://ru.wikipedia.org/wiki/%25D0%25A0%25D0%25B5%25D0%25B2%25D0%25B5%25D1%2580%25D1%2581%25D0%25B8">Reversi</a> . <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/oc9dDCPgEc4%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhjnO3h-OlCFQlMX_HEkGfVnWwU_BQ" frameborder="0" allowfullscreen=""></iframe><br><br>  Some further regional variations of <a href="http://en.wikipedia.org/wiki/Hasami_shogi">Hasami Shogi</a> go even further.  The following video shows how a “compact” group of figures located in the corner of the board can be taken.  Frankly, I still find it difficult to formalize these rules.  For example, from the explanation it is not clear how to take the pieces at the edge of the board: <br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/5EcpCGDu1Bw%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhiJy3_qOWeBsZvWZGZnUe5xPfb8gA" frameborder="0" allowfullscreen=""></iframe><br><br>  The idea of ​​the "connectedness" of the figures reaches its highest development in another ancient game, <a href="http://geektimes.ru/post/240456/">Go</a> .  This game is based on the concept of a "group" of stones.  Stones located on adjacent points of the board (vertically or horizontally) form a single group.  The group must be adjacent to not captured points of the board ( <b>dame</b> ), otherwise, it “dies” and is completely removed from the board.  Surprisingly, such simple rules lead to an incredible variety of tactical combinations. <br><br><img src="https://habrastorage.org/files/50c/412/d2e/50c412d2e9a44d24ad41b5a2e3ba849e.PNG"><br><br>  Go - not the only game that uses the idea of ​​"connectivity".  In the game " <a href="http://www.iggamecenter.com/info/ru/ordo.html">Ordo</a> ", for example, players pursue two goals: a breakthrough to the opposite side of the board and the preservation of the "order" of their pieces.  Unlike Go, the figures are considered to be connected not only in orthogonal, but also in diagonal directions.  The moves "tearing" a single group of figures are not allowed.  If the group is broken, as a result of the attack of the enemy, its integrity must be restored in the next move (otherwise, the player is defeated).  In the video version of this game, allowing the movement of groups of figures connected diagonally: <br><br><iframe width="420" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/PeMJylAeNZg%3Ffeature%3Doembed&amp;xid=25657,15700022,15700186,15700191,15700248,15700253&amp;usg=ALkJrhgiUXux5G8jjXxCuqZTM_3oR-foSw" frameborder="0" allowfullscreen=""></iframe><br><br>  Of course, this is not the limit of where the inflamed fantasy of the inventor of board games can lead.  Connecting figures, it is not necessary to be limited to adjacent cells.  In the "war" game of Guy Deborah " <a href="http://gest.livejournal.com/1242924.html">Krigshpil</a> ", straight lines from "Arsenals" and "Transmitters" symbolize the supply lines.  Having lost contact with such a line (either directly or through a nearby figure), the figure “freezes”, losing the opportunity to move, until contact is restored.  I do not know how anyone, but it reminds me a lot of the “energy network” of the Starcraft protoss. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/d44/888/511/d448885110fc46c28fdc98c9efac5875.png"></div><br><br>  The simplicity of the formulation of Guo rules is deceptive.  Their correct implementation, in the language of <a href="http://www.zillions-of-games.com/">ZRF</a> , is as verbose as it is obscure.  I will give, as an example, a fragment of the implementation of " <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2070">Stoical Go</a> ": <br><br><div class="spoiler">  <b class="spoiler_title">A lot of incomprehensible code</b> <div class="spoiler_text"><pre><code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> adjacent-to (<span class="hljs-name"><span class="hljs-name">or</span></span> (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span> n) (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span> s) (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span> e) (<span class="hljs-name"><span class="hljs-name">position-flag</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span> w) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> set-danger-flag (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">and</span></span> (<span class="hljs-name"><span class="hljs-name">enemy</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">not-neutral</span></span>? $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">not-position-flag</span></span>? safe $<span class="hljs-number"><span class="hljs-number">1</span></span>)) (<span class="hljs-name"><span class="hljs-name">set-position-flag</span></span> danger true $<span class="hljs-number"><span class="hljs-number">1</span></span>) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> Changed true) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> stone (<span class="hljs-name"><span class="hljs-name">name</span></span> Stone) (<span class="hljs-name"><span class="hljs-name">image</span></span> Black <span class="hljs-string"><span class="hljs-string">"images\Stoical Go\pieces\b$1.bmp"</span></span> White <span class="hljs-string"><span class="hljs-string">"images\Stoical Go\pieces\w$1.bmp"</span></span> ) (<span class="hljs-name"><span class="hljs-name">attribute</span></span> makes-capture false) (<span class="hljs-name"><span class="hljs-name">drops</span></span> ( (<span class="hljs-name"><span class="hljs-name">verify</span></span> empty?) (<span class="hljs-name"><span class="hljs-name">verify</span></span> (<span class="hljs-name"><span class="hljs-name">not-position</span></span>? end)) (<span class="hljs-name"><span class="hljs-name">set-flag</span></span> Capturing false) <span class="hljs-comment"><span class="hljs-comment">; if next to enemy (if (or (and (enemy? n) (not-neutral? n) ) (and (enemy? s) (not-neutral? s) ) (and (enemy? e) (not-neutral? e) ) (and (enemy? w) (not-neutral? w) ) ) mark ; *** Initialize safe ; for each point ; if enemy ; if next to empty ; P[safe] = true a1 (while (not-position? end) (set-position-flag safe empty?) next ) back (set-position-flag safe false) a1 (while (not-position? end) (if (and enemy? not-neutral? (adjacent-to safe) ) (set-position-flag safe true) ) next ) ; *** Initialize danger ; for each adjacent ; if enemy ; P[danger] = true back (set-flag Changed false) (set-danger-flag n) (set-danger-flag s) (set-danger-flag e) (set-danger-flag w) (if (flag? Changed) ; *** Spread danger, safe ; Changed = true ; while Changed ; Changed = false ; for each point ; if enemy ; if !P[safe] ; if any adjacent is enemy with P[safe] ; P[safe] = true ; if !P[safe] and !P[danger] ; if any adjacent is enemy with P[danger] ; P[danger] = true ; Changed = true (while (flag? Changed) (set-flag Changed false) a1 (while (not-position? end) (if (and enemy? not-neutral?) (if (and (not-position-flag? safe) (adjacent-to safe)) (set-position-flag safe true) (set-flag Changed true) ) (if (and (not-position-flag? safe) (not-position-flag? danger) (adjacent-to danger) ) (set-position-flag danger true) (set-flag Changed true) ) ) next ) ) ; *** Add captures for stones ; for each point ; if P[danger] and !P[safe] ; capture a1 (while (not-position? end) (if (and (position-flag? danger) (not-position-flag? safe)) capture (set-flag Capturing true) ) next ) back ) ; if Changed ) ; if next to enemy ;!!!!!!! Find out if suicide ; if no captures (if (and (not-flag? Capturing) (not (or (empty? n) (empty? s) (empty? e) (empty? w) ) ) ) ; *** Initialize safe ; for each point ; P[safe] = empty and not-marked a1 (while (not-position? end) (set-position-flag safe empty?) next ) back (set-position-flag safe false) ; Changed = true ; while Changed and not adjacent to safe ; Changed = false ; for each point ; if friend ; if !P[safe] ; if any adjacent is friend with P[safe] ; P[safe] = true ; Changed = true (set-flag Valid (adjacent-to safe)) (set-flag Changed true) (while (and (not-flag? Valid) (flag? Changed) ) (set-flag Changed false) a1 (while (not-position? end) (if (and friend? (not-position-flag? safe) ) (if (adjacent-to safe) (set-position-flag safe true) (set-flag Changed true) ) ) next ) back (set-flag Valid (adjacent-to safe)) ) ; *** Add if not suicide ; verify next to safe square back (verify (flag? Valid)) ) ; if no captures ; *** Add stone (if (flag? Capturing) (go last-to) (if (piece? CapturingStone) (verify friend?) (change-type Stone) ) was-a-capture (change-type yes) back (add CapturingStone) else was-a-capture (if (piece? yes) (change-type no) (go last-to) (change-type Stone) ) back add ) ) ) ; drops )</span></span></code> </pre> <br></div></div><br>  Even with comments, it is extremely difficult to understand this (it is even more difficult to find errors in the code).  With the appearance of arrays in <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom</a> , the situation has improved somewhat (as much as possible, when using the ForthScript language).  Here is a snippet of code that checks the connectivity of groups from my <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D2345">Ordo</a> implementation: <br><br><div class="spoiler">  <b class="spoiler_title">Slightly more concise, but no less mysterious.</b> <div class="spoiler_text"><pre> <code class="lisp hljs"><span class="hljs-number"><span class="hljs-number">20</span></span> CONSTANT LS <span class="hljs-number"><span class="hljs-number">10</span></span> CONSTANT SS LS [] list[] VARIABLE list-size SS [] set[] VARIABLE set-size VARIABLE curr-pos : not-in-list? ( <span class="hljs-name"><span class="hljs-name">pos</span></span> - ? ) curr-pos ! TRUE list-size @ BEGIN <span class="hljs-number"><span class="hljs-number">1</span></span>- DUP <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;= IF DUP list[] @ curr-pos @ = IF <span class="hljs-number"><span class="hljs-number">2</span></span>DROP FALSE <span class="hljs-number"><span class="hljs-number">0</span></span> ENDIF ENDIF DUP <span class="hljs-number"><span class="hljs-number">0</span></span>&gt; NOT UNTIL DROP <span class="hljs-comment"><span class="hljs-comment">; : not-in-set? ( pos - ? ) curr-pos ! TRUE set-size @ BEGIN 1- DUP 0 &gt;= IF DUP set[] @ curr-pos @ = IF 2DROP FALSE 0 ENDIF ENDIF DUP 0&gt; NOT UNTIL DROP ; : add-position ( -- ) list-size @ LS &lt; IF here not-in-list? IF here list-size @ list[] ! list-size ++ ENDIF ENDIF ; : not-from? ( pos -- ? ) DUP from &lt;&gt; SWAP not-in-set? AND ; : check-dir ( 'dir -- ) EXECUTE here not-from? AND friend? AND IF add-position ENDIF ; : check-coherence ( -- ? ) here 0 list[] @ 0 BEGIN DUP list[] @ DUP to ['] n check-dir DUP to ['] s check-dir DUP to ['] w check-dir DUP to ['] e check-dir DUP to ['] nw check-dir DUP to ['] sw check-dir DUP to ['] ne check-dir to ['] se check-dir 1+ DUP list-size @ &gt;= UNTIL 2DROP to TRUE SIZE BEGIN 1- DUP 0 &gt;= IF DUP not-from? IF DUP from &lt;&gt; OVER friend-at? AND IF DUP not-in-list? IF 2DROP FALSE 0 ENDIF ENDIF ENDIF ENDIF DUP 0&gt; NOT UNTIL DROP 0 list-size ! ;</span></span></code> </pre><br></div></div><br>  In any case, now the whole board is not visible, but only a group of connected figures, which has a very beneficial effect on performance.  The algorithm for constructing a connected group requires a queue that allows you to add elements “to the tail” without stopping the search started “from the head”.  Having reached the elements added during processing, the looping cycle should process them as well as all previous elements.  This is how this algorithm should look like “in a new design”: <br><br><div class="spoiler">  <b class="spoiler_title">Dagaz connectivity check</b> <div class="spoiler_text"><pre> <code class="lisp hljs">(<span class="hljs-name"><span class="hljs-name">define</span></span> add-piece-neighbors (<span class="hljs-name"><span class="hljs-name">foreach</span></span> current-group (<span class="hljs-name"><span class="hljs-name">all</span></span> (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">any</span></span> nsew nw sw ne se) (<span class="hljs-name"><span class="hljs-name">check</span></span> is-friend?) (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">piece-contains</span></span> current-group)) (<span class="hljs-name"><span class="hljs-name">take-piece</span></span> current-group) ) ) ) ) ) (<span class="hljs-name"><span class="hljs-name">define</span></span> check-coherence (<span class="hljs-name"><span class="hljs-name">if</span></span> (<span class="hljs-name"><span class="hljs-name">exists</span></span>? any-position (<span class="hljs-name"><span class="hljs-name">check</span></span> is-friend?) (<span class="hljs-name"><span class="hljs-name">take-piece</span></span> current-group) add-piece-neighbors ) (<span class="hljs-name"><span class="hljs-name">check</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">exists</span></span>? any-position (<span class="hljs-name"><span class="hljs-name">check</span></span> is-friend?) (<span class="hljs-name"><span class="hljs-name">check</span></span> (<span class="hljs-name"><span class="hljs-name">not</span></span> (<span class="hljs-name"><span class="hljs-name">piece-contains</span></span> current-group))) ) ) ) ) )</code> </pre><br></div></div><br>  After the two previous listings, it may be hard to believe, but there is everything you need to solve the problem.  Select any friendly shape, add to the set of its neighbors, then the neighbors of its neighbors, and so on, until the neighbors run out.  If at the end of this procedure at least one friendly figure remains that does not belong to the constructed set, the invariant is broken.  It is a pity that in <a href="http://www.zillions-of-games.com/">ZoG</a> and <a href="http://www.zillions-of-games.com/cgi-bin/zilligames/submissions.cgi%3Fdo%3Dshow%3Bid%3D1452">Axiom</a> it is impossible to solve this problem as simply. <br></div><p>Source: <a href="https://habr.com/ru/post/256701/">https://habr.com/ru/post/256701/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../256685/index.html">Domashka by Yii2</a></li>
<li><a href="../256687/index.html">We send SMS from .Net applications to C #</a></li>
<li><a href="../256689/index.html">View Storwize Array Configuration with R - Shiny Dashboard</a></li>
<li><a href="../256695/index.html">Connect to the online translation Unified Communication User Community (UC2)</a></li>
<li><a href="../256697/index.html">How stable is your internet banking?</a></li>
<li><a href="../256703/index.html">Kurchatov Convergent Education Project</a></li>
<li><a href="../256711/index.html">How to know the effectiveness of the page in the App Store or Google Play?</a></li>
<li><a href="../256713/index.html">Testing math algorithms</a></li>
<li><a href="../256717/index.html">The best phone for games, game market development forecasts, Telegram competition - and other news of the week for a mobile developer</a></li>
<li><a href="../256719/index.html">Analysis of tasks of the 2nd qualifying round of the Russian Code Cup 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>