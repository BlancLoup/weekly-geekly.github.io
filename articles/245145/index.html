<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Expressive javascript: http</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Content 


- Introduction 
- Values, Types and Operators 
- Program structure 
- Functions 
- Data Structures: Objects and Arrays 
- Higher order func...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Expressive javascript: http</h1><div class="post__text post__text-html js-mediator-article"><h4>  Content </h4><br><ul><li>  <a href="http://habrahabr.ru/post/240219/">Introduction</a> </li><li>  <a href="http://habrahabr.ru/post/240223/">Values, Types and Operators</a> </li><li>  <a href="http://habrahabr.ru/post/240225/">Program structure</a> </li><li>  <a href="http://habrahabr.ru/post/240349/">Functions</a> </li><li>  <a href="http://habrahabr.ru/post/240813/">Data Structures: Objects and Arrays</a> </li><li>  <a href="http://habrahabr.ru/post/241155/">Higher order functions</a> </li><li>  <a href="http://habrahabr.ru/post/241587/">The secret life of objects</a> </li><li>  <a href="http://habrahabr.ru/post/241776/">Project: e-life</a> </li><li>  <a href="http://habrahabr.ru/post/242609/">Search and error handling</a> </li><li>  <a href="http://habrahabr.ru/post/242695/">Regular expressions</a> </li><li>  <a href="http://habrahabr.ru/post/243273/">Modules</a> </li><li>  <a href="http://habrahabr.ru/post/243277/">Project: programming language</a> </li><li>  <a href="http://habrahabr.ru/post/243311/">Javascript and browser</a> </li><li>  <a href="http://habrahabr.ru/post/243815/">Document Object Model</a> </li><li>  <a href="http://habrahabr.ru/post/244041/">Event handling</a> </li><li>  <a href="http://habrahabr.ru/post/244405/">Project: Platform Game</a> </li><li>  <a href="http://habrahabr.ru/post/244545/">Drawing on canvas</a> </li><li>  <a href="http://habrahabr.ru/post/245145/">HTTP</a> </li><li>  <a href="http://habrahabr.ru/post/245731/">Forms and form fields</a> </li><li>  <a href="http://habrahabr.ru/post/245767/">Project: Paint</a> </li><li>  <a href="http://habrahabr.ru/post/245775/">Node.js</a> </li><li>  <a href="http://habrahabr.ru/post/246331/">Project: website sharing experience</a> </li><li>  <a href="http://eloquentjavascript.net/code">Sandbox for code</a> </li></ul><br><br>  <i>The dream for which the Network was created is a common information space in which we communicate, sharing information.</i>  <i>Its versatility is its integral part: a hypertext link can lead anywhere, be it personal, local or global information, draft or verified text.</i> <i><br><br></i>  <i>Tim Bernes-Lee, The World Wide Web: A Very Short Personal Story</i> <br><a name="habracut"></a><br><h4>  Protocol </h4><br>  If you type eloquentjavascript.net/17_http.html in the address bar of your browser, the browser first recognizes the server address associated with the name eloquentjavascript.net and tries to open a TCP connection on port 80 - the default HTTP port.  If the server exists and accepts the connection, the browser sends something like: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      GET /17_http.html HTTP / 1.1 <br>  Host: eloquentjavascript.net <br>  User-Agent: Browser Name <br><br>  The server responds by the same connection: <br><br>  HTTP / 1.1 200 OK <br>  Content-Length: 65585 <br>  Content-Type: text / html <br>  Last-Modified: Wed, 09 Apr 2014 10:48:09 GMT <br><br>  &lt;! doctype html&gt; <br>  ... the remainder of the document <br><br>  The browser takes the part that follows the answer after the empty line and displays it as an HTML document. <br><br>  The information sent by the client is called a request.  It starts with the line: <br><br>  GET /17_http.html HTTP / 1.1 <br><br>  The first word is the query method.  GET means we need to get a certain resource.  Other common methods are DELETE to delete, PUT to replace, and POST to send information.  Note that the server is not required to fulfill every request received.  If you choose a random site and tell it to delete the main page, it will most likely refuse. <br><br>  The part after the method name is the path to the resource to which the request has been sent.  In the simplest case, the resource is just a file on the server, but the protocol is not limited to this feature.  A resource can be anything that can be transferred as a file.  Many servers create responses on the fly.  For example, if you open twitter.com/marijnjh, the server will look at the user‚Äôs database marijnjh, and if it finds it, it will create a profile page for this user. <br><br>  After the path to the resource, the first line of the request mentions HTTP / 1.1 to report the version of the HTTP protocol it uses. <br><br>  The server's response also begins with the protocol version, followed by the status of the response ‚Äî first a three-digit code, then a line. <br><br>  HTTP / 1.1 200 OK <br><br>  Status codes starting with 2 indicate successful requests.  Codes starting with 4 mean something went wrong.  404 is the most famous HTTP status, indicating that the requested resource was not found.  Codes starting with 5 indicate that an error has occurred on the server, but not the fault of the request. <br><br>  The first line of the request or response can be any number of header lines.  These are strings in the form ‚Äúname: value‚Äù that denote additional information about the request or response.  These headers were included in the example: <br><br>  Content-Length: 65585 <br>  Content-Type: text / html <br>  Last-Modified: Wed, 09 Apr 2014 10:48:09 GMT <br><br>  This determines the size and type of the document received in response.  In this case, this is an HTML document of 65'585 bytes.  It also indicates when the document was last modified. <br><br>  For the most part, the client or server determines which headers to include in the request or response, although some headers are required.  For example, Host, denoting the host name, should be included in the request, because one server can serve many host names at one ip-address, and without this header the server will not know which host the client is trying to communicate with. <br><br>  After the headers, both the request and the response can indicate an empty string followed by a body containing the data to be transmitted.  GET and DELETE requests do not send additional data, and PUT and POST send.  Some responses, such as error messages, do not require a body. <br><br><h4>  Browser and HTTP </h4><br>  As we saw in the example, the browser sends the request when we enter the URL in the address bar.  When the resulting HTML document contains references to other files, such as images or JavaScript files, they are also requested from the server. <br><br>  A medium-sized website can easily contain from 10 to 200 resources.  In order to be able to request them quickly, browsers make several requests at the same time, rather than waiting for the end of requests one by one.  Such documents are always requested through GET requests. <br><br>  HTML pages can have forms that allow users to enter information and send it to the server.  Here is an example of a form: <br><br><pre><code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">method</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"GET"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">action</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"example/message.html"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>: <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"name"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span>:<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">br</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">textarea</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"submit"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">form</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><br>  The code describes a form with two fields: a small one asks for a name, and a large one - a message.  When you click the ‚ÄúSend‚Äù button, the information from these fields will be encoded into a query string (query string).  When the element's method attribute is GET, or when it is not specified at all, the query string is placed in the URL from the action field, and the browser makes a GET request with this URL. <br><br>  GET /example/message.html?name=Jean&amp;message=Yes%3F HTTP / 1.1 <br><br>  The beginning of the query string is indicated by a question mark.  After that, there are pairs of names and values ‚Äã‚Äãcorresponding to the name attribute of the form fields and the contents of these fields.  Ampersand (&amp;) is used to separate them. <br><br>  The message sent in the example contains the string ‚ÄúYes?‚Äù, Although the question mark is replaced by some strange code.  Some characters in the query string must be escaped (escape).  The question mark is included, and it is represented by code% 3F.  There is some unwritten rule that every format must have a way to escape characters.  This rule, called URL coding, uses a percentage followed by two hexadecimal digits that represent the character code.  3F in decimal will be 63, and this is the code of the question mark.  JavaScript has encodeURIComponent and decodeURIComponent functions for encoding and decoding. <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">encodeURIComponent</span></span>(<span class="hljs-string"><span class="hljs-string">"Hello &amp; goodbye"</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí Hello%20%26%20goodbye console.log(decodeURIComponent("Hello%20%26%20goodbye")); // ‚Üí Hello &amp; goodbye</span></span></code> </pre><br><br>  If we change the method attribute in the form in the previous example to POST, the HTTP request with the form will be sent using the POST method, which sends the query string in the request body, instead of adding it to the URL. <br><br>  POST /example/message.html HTTP / 1.1 <br>  Content-length: 24 <br>  Content-type: application / x-www-form-urlencoded <br><br>  name = Jean &amp; message = Yes% 3F <br><br>  By convention, the GET method is used for queries that have no side effects, such as searching.  Requests that change something on the server ‚Äî create a new account or post a message ‚Äî should be sent using the POST method.  Browser-type client programs know that it is not necessary to simply make POST requests, and sometimes GET requests are made seamlessly by the user ‚Äî for example, to download content in advance that the user may soon need. <br><br>  In the next chapter, we‚Äôll go back to the forms and talk about how we can do them with JavaScript. <br><br><h4>  XMLHttpRequest </h4><br>  The interface through which JavaScript in the browser can make HTTP requests is called XMLHttpRequest (notice how the size of the letters jumps).  It was developed by Microsoft for the Internet Explorer browser in the late 1990s.  At this time, the XML format was very popular in the world of business software - and in this world, Microsoft always felt at home.  It was so popular that the XML abbreviation was attached to the interface name for working with HTTP, although the latter is not related to XML at all. <br><br>  And yet the name is not completely meaningless.  The interface allows you to parse your answers as if they were XML documents.  To mix two different things (request and answer analysis) into one is, of course, a disgusting design, but what can you do. <br><br>  When the XMLHttpRequest interface was added to Internet Explorer, it became possible to do things that were previously very difficult to do.  For example, sites began to show lists of prompts, while the user enters something in the text field.  The script sends the text to the server via HTTP simultaneously with the user typing.  The server, which has a database for possible input options, searches for suitable entries among the entries and returns them back for display.  It looked very cool - people used to wait for the rest of the page to reload after each interaction with the site. <br><br>  Another important browser of the time, Mozilla (later Firefox), did not want to lag behind.  To allow doing similar things, Mozilla copied the interface along with the name.  The next generation of browsers followed suit, and today XMLHttpRequest is a de facto standard. <br><br><h4>  Submit request </h4><br>  To send a simple request, we create a request object with the XMLHttpRequest constructor and call the open and send methods. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"example/data.txt"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.responseText); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí This is the content of data.txt</span></span></code> </pre><br><br>  The open method customizes the query.  In our case, we decided to make a GET request for the file example / data.txt.  URLs that do not begin with the protocol name (for example, http :) are referred to as relative, that is, they are interpreted relative to the current document.  When they begin with a slash (/), they replace the current path - the part after the server name.  Otherwise, a portion of the current path, up to the last slash, is placed before the relative URL. <br><br>  After opening the request, we can send it by the send method.  The argument is the request body.  For GET requests, use null.  If the third argument for open was false, then send will return only after the response to our request has been received.  To get the response body, we can read the responseText property of the request object. <br><br>  Other information can be obtained from the response object.  The status code is available in the status property, and the status text is available in statusText.  Headers can be read from getResponseHeader. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"example/data.txt"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.status, req.statusText); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 200 OK console.log(req.getResponseHeader("content-type")); // ‚Üí text/plain</span></span></code> </pre><br><br>  Title titles are not case sensitive.  They are usually capitalized at the beginning of each word, for example ‚ÄúContent-Type‚Äù, but the ‚Äúcontent-type‚Äù or ‚ÄúcOnTeNt-TyPe‚Äù will describe the same title. <br><br>  The browser itself will add some headers, such as ‚ÄúHost‚Äù and others that are needed by the server to calculate the size of the body.  But you can add your own headers with the setRequestHeader method.  This is necessary for special cases and requires the assistance of the server to which you are applying - it is free to ignore headers that it cannot handle. <br><br><h4>  Asynchronous requests </h4><br>  In the example, the request was completed when the send call ends.  This is convenient because properties like responseText are immediately available.  But this means that our program will wait until the browser and server communicate with each other.  With a bad connection, a weak server or a large file, this can take a long time.  This is also bad because no event handlers will work while the program is in standby mode - the document will stop responding to user actions. <br><br>  If the third argument to open is true, the request will be asynchronous.  This means that when you call send, the request is queued for sending.  The program continues to work, and the browser takes care of sending and receiving data in the background. <br><br>  But while the request is being processed, we will not receive an answer.  We need a notification mechanism that the data has arrived and is ready.  To do this, we will need to listen to the ‚Äúload‚Äù event. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"example/data.txt"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); req.addEventListener(<span class="hljs-string"><span class="hljs-string">"load"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Done:"</span></span>, req.status); }); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><br>  Just like calling requestAnimationFrame in Chapter 15, this code forces us to use an asynchronous programming style, wrapping the code that needs to be executed after the request and placing the call to this function at the right time into a function.  We will come back to this later. <br><br><h4>  Getting XML data </h4><br><br>  When the resource returned by the XMLHttpRequest object is an XML document, the responseXML property will contain a parsed view of the document.  It works in a manner similar to DOM, except that it does not have any inherent HTML functionality like the style property.  The object contained in responseXML corresponds to the document object.  Its documentElement property refers to the external tag of the XML document.  In the following document (example / fruit.xml), this tag will be: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fruits</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fruit</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"banana"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"yellow"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fruit</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"lemon"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"yellow"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fruit</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"cherry"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">color</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"red"</span></span></span><span class="hljs-tag">/&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">fruits</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br>  We can get this file like this: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"example/fruit.xml"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.responseXML.querySelectorAll(<span class="hljs-string"><span class="hljs-string">"fruit"</span></span>).length); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí 3</span></span></code> </pre><br><br>  XML documents can be used to exchange structured information with the server.  Their form ‚Äî nested tags ‚Äî is good for storing most data, or at least better than text files.  The DOM interface is clumsy in terms of extracting information, and XML documents are quite verbose.  It is usually best to communicate using data in JSON format that is easier to read and write, both to programs and to people. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"example/fruit.json"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse(req.responseText)); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí {banana: "yellow", lemon: "yellow", cherry: "red"}</span></span></code> </pre><br><br><h4>  HTTP sandbox </h4><br>  HTTP requests from a webpage raise security concerns.  The person controlling the script may have interests different from those of the user on whose computer it is running.  Specifically, if I went to themafia.org, I don‚Äôt want their scripts to make inquiries to mybank.com, using the information from my browser as an identifier, and giving the command to send all my money to some mafia account. <br><br>  Websites can protect themselves from such attacks, but this requires some effort, and many sites can not cope with this.  Because of this, browsers protect them by prohibiting scripts from making requests to other domains (names like themafia.org and mybank.com). <br><br>  This may interfere with the development of systems that need to have access to different domains for a good reason.  Fortunately, the server may include the following header in the response, explaining to browsers that the request may come from other domains: <br><br>  Access-Control-Allow-Origin: * <br><br><h4>  We abstract requests </h4><br>  In Chapter 10, in our implementation of the modular AMD system, we used the hypothetical backgroundReadFile function.  She accepted the file name and function, and called this function after reading the contents of the file.  Here is a simple implementation of this function: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">backgroundReadFile</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); req.addEventListener(<span class="hljs-string"><span class="hljs-string">"load"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.status &lt; <span class="hljs-number"><span class="hljs-number">400</span></span>) callback(req.responseText); }); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }</code> </pre><br><br>  Simple abstraction simplifies the use of XMLHttpRequest for simple GET requests.  If you are writing a program that makes HTTP requests, it will be a good idea to use a helper function so that you do not have to repeat the ugly XMLHttpRequest template all the time. <br><br>  The callback argument is a term often used to describe such functions.  The callback function is transferred to another code so that it can call us back later. <br><br>  It's easy to write your own HTTP helper function, tailored specifically for your program.  The previous one does only GET requests, and does not give us control over the headers or the body of the request.  You can write another option for the POST request, or more general, supporting different requests.  Many JavaScript libraries offer wrappers for XMLHttpRequest. <br><br>  The main problem with the given wrapper is error handling.  When a request returns a status code indicating an error (between 400 and above), it does nothing.  In some cases, this is normal, but imagine that we put a loading indicator on the page that indicates that we are receiving information.  If the request did not succeed, because the server fell or the connection was interrupted, the page will pretend that it is busy with something.  The user will wait a bit, then he will get bored and he decides that the site is some kind of stupid. <br><br>  We need an option in which we receive a warning about a failed request so that we can take action.  For example, we can remove the download message and inform the user that something has gone wrong. <br><br>  Error handling in asynchronous code is even more complicated than in synchronous.  Since we often have to separate part of the work and place it in a callback function, the scope of the try block is meaningless.  In the following code, the exception will not be caught, because the call to backgroundReadFile is returned immediately.  Then the control leaves the try block, and the function will not be called from it. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { backgroundReadFile(<span class="hljs-string"><span class="hljs-string">"example/data.txt"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (text != <span class="hljs-string"><span class="hljs-string">"expected"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"That was unexpected"</span></span>); }); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (e) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Hello from the catch block"</span></span>); }</code> </pre><br><br>  In order to handle unsuccessful requests, you will have to pass an additional function to our wrapper, and call it in case of problems.  Another option is to use the convention that if the request fails, an additional argument is passed to the callback function describing the problem.  Example: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getURL</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); req.addEventListener(<span class="hljs-string"><span class="hljs-string">"load"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.status &lt; <span class="hljs-number"><span class="hljs-number">400</span></span>) callback(req.responseText); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Request failed: "</span></span> + req.statusText)); }); req.addEventListener(<span class="hljs-string"><span class="hljs-string">"error"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ callback(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Network error"</span></span>)); }); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }</code> </pre><br><br>  We added an error event handler that will work if there is a problem with the call.  We also call the callback function with an error argument when the request completes with a status that indicates an error. <br><br>  Code using getURL should check if the error is returned and process it if it exists. <br><br><pre> <code class="javascript hljs">getURL(<span class="hljs-string"><span class="hljs-string">"data/nonsense.txt"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">content, error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (error != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Failed to fetch nonsense.txt: "</span></span> + error); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"nonsense.txt: "</span></span> + content); });</code> </pre><br><br>  With exceptions, this does not help.  When we perform several asynchronous actions in succession, an exception at any point in the chain in any case (unless you wrapped each handler in your try / catch block) will fall out at the top level and interrupt the entire chain. <br><br><h4>  Promises </h4><br>  It is difficult to write asynchronous code for complex projects in the form of simple callbacks.  It is very easy to forget error checking or to allow an unexpected exception to abruptly interrupt the program.  In addition, organizing proper error handling and passing errors through several consecutive callbacks is very tedious. <br><br>  Many attempts have been made to solve this problem with additional abstractions.  One of the most successful attempts is called promises.  Promises wrap an asynchronous action into an object that can be transmitted and that needs to do some things when the action ends or fails.  This interface has already become part of the current version of JavaScript, and for older versions it can be used as a library. <br><br>  The promise interface is not particularly intuitive, but powerful.  In this chapter we will only partially describe it.  More information can be found at <a href="http://www.promisejs.org/">www.promisejs.org</a> <br><br>  To create a promises object, we call the Promise constructor, giving it an initialization function for asynchronous action.  The constructor calls this function and passes it two arguments, which are also functions themselves.  The first should be called in a successful case, the other - in an unsuccessful one. <br><br>  And here is our GET request wrapper, which this time returns a promise.  Now we just call it get. <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">succeed, fail</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, url, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); req.addEventListener(<span class="hljs-string"><span class="hljs-string">"load"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (req.status &lt; <span class="hljs-number"><span class="hljs-number">400</span></span>) succeed(req.responseText); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fail(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Request failed: "</span></span> + req.statusText)); }); req.addEventListener(<span class="hljs-string"><span class="hljs-string">"error"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ fail(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Network error"</span></span>)); }); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); }</code> </pre><br><br>  Notice that the interface to the function itself is simplified.  We give her the URL, and she returns the promise.  It works as a handler for the request output.  It has a then method that is invoked with two functions: one to handle success, the other to fail. <br><br><pre> <code class="javascript hljs">get(<span class="hljs-string"><span class="hljs-string">"example/data.txt"</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"data.txt: "</span></span> + text); }, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"Failed to fetch data.txt: "</span></span> + error); });</code> </pre><br><br>  So far this is still one of the ways to express what we have already done.  Only when you have a chain of events does a noticeable difference become visible. <br><br>  The then call produces a new promise, whose result (the value passed to the handlers of successful results) depends on the value returned by the first function we pass to then.  This function can return another promise, indicating that additional asynchronous work is being done.  In this case, the promise returned by then itself will wait for the promise returned by the handler function, and success or failure will occur with the same value.  When a handler function returns a value that is not a promise, the promise returned by then becomes successful, using this value as the result. <br><br>  So you can use then to change the result of the promise.  For example, the following function returns a promise whose result is the content from the given URL, parsed as JSON: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getJSON</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">url</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(url).then(<span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.parse); }</code> </pre><br><br>  The last call to then did not identify the failure handler.  It is permissible.  The error will be transmitted to the promise returned through then, and this is what we need - getJSON does not know what to do when something goes wrong, but there is hope that its caller knows it. <br><br>  As an example showing the use of promises, we will write a program that receives the number of JSON files from the server and shows the word ‚Äúdownload‚Äù during the execution of the request.  The files contain information about people and links to other files with information about other people in properties such as father, mother, spouse. <br><br>  We need to get the name of the spouse's mother from example / bert.json.  In case of problems, we need to remove the text "download" and show an error message.  Here's how to do this with promises: <br><br><pre> <code class="javascript hljs">&lt;script&gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">msg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elt = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"div"</span></span>); elt.textContent = msg; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.appendChild(elt); } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loading = showMessage(<span class="hljs-string"><span class="hljs-string">"..."</span></span>); getJSON(<span class="hljs-string"><span class="hljs-string">"example/bert.json"</span></span>).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bert</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getJSON(bert.spouse); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">spouse</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getJSON(spouse.mother); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">mother</span></span></span><span class="hljs-function">) </span></span>{ showMessage(<span class="hljs-string"><span class="hljs-string">" - "</span></span> + mother.name); }).catch(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error</span></span></span><span class="hljs-function">) </span></span>{ showMessage(<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(error)); }).then(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.body.removeChild(loading); }); <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre><br><br>  The final program is relatively compact and readable.  The catch method is similar to then, but it expects only the handler for the unsuccessful result and, if successful, passes on the unchanged result.  Program execution will continue as usual after catching an exception - just as in the case of try / catch.  Thus, the last then deleting the boot message is executed anyway, even in case of failure. <br><br>  You can imagine that the promise interface is a separate language for asynchronous processing of program execution.  The additional calls to the methods and functions that are needed for its operation give the code a somewhat strange look, but not as inconvenient as handling all errors manually. <br><br><h4>  Appreciate http </h4><br>  When creating a system in which a JavaScript program in the browser (client) communicates with the server program, you can use several options for modeling such communication. <br><br>  A common method is remote procedure calls.  In this model, communication follows the pattern of normal function calls, only these functions are performed on another computer.  The challenge is to create a request to the server, which includes the function name and arguments.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The response to the request includes the return value. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">When using remote calls, HTTP procedures serve only as a transport for communication, and you will most likely write an abstraction layer that will hide it completely. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Another approach is to build your communication system on the concept of HTTP resources and methods. Instead of a remote procedure call called addUser, you make a PUT request to / users / larry. Instead of encoding user properties in function arguments, you specify the document format or use an existing format that will represent the user. The body of a PUT request that creates a new resource will simply be a document of this format. A resource is obtained through a GET request to its URL (/ user / larry), which returns a document representing this resource.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The second approach simplifies the use of some HTTP features, such as resource caching support (a copy of the resource is stored on the client side). </font><font style="vertical-align: inherit;">It also helps create a consistent interface, because thinking in terms of resources is easier than in terms of functions.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Security and HTTPS </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data travels on the Internet in a long and dangerous way. </font><font style="vertical-align: inherit;">To get to their destination, they need to jump through all sorts of places, ranging from a Wi-Fi coffee shop network to networks controlled by various organizations and states. </font><font style="vertical-align: inherit;">At any point in the way they can read or even change. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">If you need to keep something secret, such as passwords to an email, or data you need to arrive at your destination unchanged - for example, such as the bank account number to which you transfer money - simple HTTP is not enough.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The secure HTTP protocol, whose URLs begin with https: //, wraps HTTP traffic so that it is harder to read and change. First, the client confirms that the server is the one for whom it claims to be, demanding from the server to submit a cryptographic certificate issued by a reputable party, which is recognized by the browser. Then, all data passing through the connection is encrypted so as to prevent eavesdropping and alteration.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thus, when everything works correctly, HTTPS prevents both cases when someone pretends to be another website with which you are communicating, as well as cases of interception of your communication. It is not perfect, and there have already been cases where HTTPS did not cope with work due to fake or stolen certificates or broken programs. However, with HTTP it is very easy to do something bad, and hacking HTTPS requires such efforts that only state structures or very serious criminal organizations can apply (and there are sometimes no differences between these organizations).</font></font><br><br><h4>  Total </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In this chapter, we saw that HTTP is a protocol for accessing resources on the Internet. The client sends a request containing a method (usually GET) and a path that identifies the resource. The server decides what to do with the request and responds with the status code and the response body. Requests and responses may contain headers in which additional information is transmitted. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Browsers make GET requests to get the resources needed to display the page. The page may contain forms that allow the information entered by the user to be sent in a request that is created after the form is submitted. You will learn more about this in the next chapter.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The interface through which JavaScript makes HTTP requests from a browser is called XMLHttpRequest. </font><font style="vertical-align: inherit;">You can ignore the prefix ‚ÄúXML‚Äù (but you still need to write it). </font><font style="vertical-align: inherit;">It can be used in two ways: synchronous, which blocks all work until the end of the request, and asynchronous, which requires the installation of an event handler that tracks the end of the request. </font><font style="vertical-align: inherit;">In almost all cases, the asynchronous method is preferred. </font><font style="vertical-align: inherit;">Creating a query looks like this:</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> req = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest(); req.open(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"example/data.txt"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); req.addEventListener(<span class="hljs-string"><span class="hljs-string">"load"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.statusCode); }); req.send(<span class="hljs-literal"><span class="hljs-literal">null</span></span>);</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Asynchronous programming is not an easy thing. </font><font style="vertical-align: inherit;">Promises is an interface that makes it easier by helping to send error messages and exceptions to the right handler, and abstracting some duplicate error-prone elements.</font></font><br><br><h4>  Exercises </h4><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Content negotiation </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">One of the things that HTTP can do but which we have not discussed is called content negotiation. The Accept header in the request can be used to tell the server which types of documents the client wants to receive. Many servers ignore it, but when the server knows about different ways of coding a resource, it can look at the header and send the one that the client prefers. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The eloquentjavascript.net/author URL is configured to respond either in plain text or HTML or JSON, depending on the client‚Äôs request. These formats are defined by standardized content types text / plain, text / html, and application / json.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Send a request for all three formats of this resource. </font><font style="vertical-align: inherit;">Use the setRequestHeader method of the XMLHttpRequest object to set the Accept header to one of the desired content types. </font><font style="vertical-align: inherit;">Make sure you set the header after open, but before send. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Finally, try querying the contents of application / rainbows + unicorns type and see what happens.</font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Waiting for a few promises </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">The Promise constructor has an all method that, when it receives an array of promises, returns a promise that waits for the completion of all the promises specified in the array. </font><font style="vertical-align: inherit;">It then returns a successful result and returns an array with the results. </font><font style="vertical-align: inherit;">If some of the promises in the array failed, the total promise also returns failure (with the value of the failed promise from the array). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Try doing something like this by writing the function all. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notice that after the promise is completed (when it either completed successfully or with an error), it cannot rerun the error or success, and further function calls are ignored. </font><font style="vertical-align: inherit;">This can simplify error handling in your promise.</font></font><br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">all</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">promises</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">success, fail</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  . }); } //  . all([]).then(function(array) { console.log("   []:", array); }); function soon(val) { return new Promise(function(success) { setTimeout(function() { success(val); }, Math.random() * 500); }); } all([soon(1), soon(2), soon(3)]).then(function(array) { console.log("   [1, 2, 3]:", array); }); function fail() { return new Promise(function(success, fail) { fail(new Error("")); }); } all([soon(1), fail(), soon(3)]).then(function(array) { console.log("     "); }, function(error) { if (error.message != "") console.log(" :", error); });</span></span></code> </pre></div><p>Source: <a href="https://habr.com/ru/post/245145/">https://habr.com/ru/post/245145/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../245133/index.html">Millennium Challenge. Just about the complicated</a></li>
<li><a href="../245135/index.html">Comparison of data processing speed (ETS, DETS, Memcached, MongoDb) in Erlang (spherical in vacuum)</a></li>
<li><a href="../245137/index.html">CHIP - Arduino-compatible e-learning designer for kids</a></li>
<li><a href="../245139/index.html">Simple detection of objects by color</a></li>
<li><a href="../245141/index.html">Black screen in Creative Cloud application</a></li>
<li><a href="../245153/index.html">Brief history of web design</a></li>
<li><a href="../245155/index.html">How we wrote helpdesk (part 2)</a></li>
<li><a href="../245157/index.html">Meeting on cross-platform development for Windows, iOS, Android - December 18, Moscow</a></li>
<li><a href="../245159/index.html">Hacker found a way to read files on Facebook servers</a></li>
<li><a href="../245165/index.html">CloudFlare + nginx = we cache everything on a free plan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>