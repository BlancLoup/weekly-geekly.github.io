<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Subtleties of the value restriction in F #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the distinguishing features of the F # language, compared with the more common programming languages, is powerful and comprehensive automatic t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Subtleties of the value restriction in F #</h1><div class="post__text post__text-html js-mediator-article"><p>  One of the distinguishing features of the F # language, compared with the more common programming languages, is powerful and comprehensive automatic type inference.  Thanks to him, in F # programs you almost never specify types explicitly, type less text, and end up with a more concise, fantastically elegant code. </p><br><img src="https://habrastorage.org/webt/1w/fs/dg/1wfsdgt9e_up6kijsdhd5ivhxck.jpeg"><br><blockquote>  All materials from the translation series of the <a href="http://fsharplang.ru/">Russian-speaking community of F # -developers</a> can be found by the tag <a href="https://habrahabr.ru/search/%3Fq%3D%2523fsharplangru">#fsharplangru</a> . </blockquote><a name="habracut"></a><br><p>  Automatic type inference algorithms are an exciting topic;  behind them is an interesting and beautiful theory.  Today we will look at one curious aspect of automatic type inference in F #, which may give you an idea of ‚Äã‚Äãwhat difficulties arise in good modern algorithms of this kind, and hopefully explain one stumbling block that F # programmers face from time to time . </p><br><p>  Our topic today will be a <abbr title="value restriction"><em>limit on values</em></abbr> .  On MSDN there is a <a href="http://msdn.microsoft.com/en-us/library/dd233183(v%3DVS.100).aspx">good article</a> on the topic of value constraints and automatic type generalization in F #, which gives very reasonable practical advice if you encounter it in your code.  However, this article merely states dryly: " <em>The compiler performs automatic generalization only on full definitions of functions with explicitly specified arguments and on simple immutable values</em> ", and gives almost no explanation for this, which is quite fair, because MSDN is just reference material.  This post focuses on the reasoning underlying the restrictions on values ‚Äã‚Äã- I will answer the question "why?", And not "what to do?". </p><br><p>  <abbr title="automatic generalization"><em>Automatic generalization</em></abbr> is a powerful feature for automatic type inference of F #.  Define a simple function ‚Äî for example, an identity function: </p><br><pre><code class="hljs objectivec">let <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> x = x</code> </pre> <br><p>  There are no explicit <abbr title="type annotations">type annotations</abbr> , but the F # compiler prints the type <code>'a -&gt; 'a</code> for this function: the function takes an argument of some type and returns the result of exactly the same type.  This is not particularly difficult, but note that the F # compiler infers the implicit <abbr title="generic type parameter">parameter-type</abbr> <code>'a</code> for the function <code>id</code> . </p><br><p>  We can combine the <code>id</code> function with the <code>List.map</code> function, which itself is <abbr title="generic function">polymorphic</abbr> : </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listId l = <span class="hljs-type"><span class="hljs-type">List</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> id l</code> </pre> <br><p>  (Not a very useful feature, but for now, visibility is more important).  The F # compiler gives the <code>listId</code> function the correct type <code>'a list -&gt; 'a list</code> - automatic generalization occurred again.  Since <code>List.map</code> is a <code>List.map</code> function, we may be tempted to drop the <code>l</code> argument to the left and right: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listId = <span class="hljs-type"><span class="hljs-type">List</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> id</code> </pre> <br><p>  But the F # compiler unexpectedly resents: </p><br><pre> <code class="hljs pgsql">Program.fs(<span class="hljs-number"><span class="hljs-number">8</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): error FS0030: <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> restriction. The <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-string"><span class="hljs-string">'listId'</span></span> has been inferred <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have generic <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> val listId : (<span class="hljs-string"><span class="hljs-string">'_a list -&gt; '</span></span>_a list) Either make the arguments <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> <span class="hljs-string"><span class="hljs-string">'listId'</span></span> explicit <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> intend <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be generic, <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> annotation.</code> </pre> <br><p>  What's happening? </p><br><p>  An MSDN article offers 4 ways to correct the <code>let</code> -def, which is rejected by the compiler due to a restriction on values: </p><br><ul><li>  Restrict the type so that it ceases to be polymorphic by adding an explicit type annotation to the value or parameter. </li><li>  If the problem is caused by a <abbr title="nongeneralizable construct">non-generic construct</abbr> in the definition of a polymorphic function (such as the composition of functions or the partial application of arguments to a curried function), try rewriting the definition of the function to ordinary. </li><li>  If the problem is an expression that is too complicated to generalize, turn it into a function by adding an unused parameter. </li><li>  Add explicit polymorphic parameter types.  This is rarely used. </li></ul><br><p>  The first method is not for us - we want the <code>listId</code> function <code>listId</code> be polymorphic. </p><br><p>  The second way will bring us back to the explicit indication of the <code>list</code> parameter - and this is the canonical way of defining functions like <code>listId</code> in the F # language. </p><br><p>  The third way is applicable when you need to define something that is not a function, in our case it gives an unconvincing option: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listId () = <span class="hljs-type"><span class="hljs-type">List</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> id</code> </pre> <br><p>  In the working code, I would use the second solution and leave the function parameter explicit.  But for the sake of learning, let's try the "rarely used" fourth method: </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listId&lt;<span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>&gt; : <span class="hljs-symbol"><span class="hljs-symbol">'T</span></span> list -&gt; <span class="hljs-symbol"><span class="hljs-symbol">'T</span></span> list = List.map id</code> </pre> <br><p>  It compiles and works as expected.  At first glance it seems that this is a type inference error - the compiler cannot determine the type, so we added an annotation to help it.  But wait, the compiler almost brought out this type - it is also mentioned in the error message (with the mysterious <abbr title="type veriable">type variable</abbr> <code>'_a</code> )!  As if the compiler was stunned by this particular case - why? </p><br><p>  The reason is quite reasonable.  To see it, let's consider another case of a value constraint.  This <abbr title="reference cell">reference cell</abbr> does not compile to the list: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> []</code> </pre> <br><pre> <code class="hljs vhdl">Program.fs(<span class="hljs-number"><span class="hljs-number">16</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): <span class="hljs-literal"><span class="hljs-literal">error</span></span> FS0030: Value restriction. The value <span class="hljs-symbol"><span class="hljs-symbol">'v</span></span>' has been inferred <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> val v : '_a list ref Either define <span class="hljs-symbol"><span class="hljs-symbol">'v</span></span>' as a simple data term, make it a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> explicit arguments <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you do <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> intend <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span>, add a <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> annotation.</code> </pre> <br><p>  Let's get around this with explicit type annotations: </p><br><pre> <code class="hljs rust">&gt; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v&lt;<span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>&gt; : <span class="hljs-symbol"><span class="hljs-symbol">'T</span></span> list <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> [] val v&lt;<span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>&gt; : <span class="hljs-symbol"><span class="hljs-symbol">'T</span></span> list <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span></code> </pre> <br><p>  The compiler is satisfied.  Let's try to assign <code>v</code> some value: </p><br><pre> <code class="hljs scala">&gt; v := [<span class="hljs-number"><span class="hljs-number">1</span></span>];; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> it : unit = ()</code> </pre> <br><p>  True, <code>v</code> now refers to a list with a single element <code>1</code> ? </p><br><pre> <code class="hljs cpp">&gt; let x : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = !v;; val x : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-built_in"><span class="hljs-built_in">list</span></span> = []</code> </pre> <br><p>  Oh!  Content <code>v</code> is an empty list!  Where is our <code>[1]</code> ? </p><br><p>  That's what happened.  Our assignment can actually be rewritten as: </p><br><pre> <code class="hljs go">(v&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;):=[<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br><p>  The left side of this assignment is the application of <code>v</code> to an <abbr title="type argument">argument of type</abbr> <code>int</code> .  And <code>v</code> , in turn, is not a reference cell, but <abbr title="type finction">a type function</abbr> : having received a type argument as input, it will return a reference cell.  Our expression creates a new reference cell and assigns it to <code>[1]</code> .  Similarly, if we explicitly specify the type argument in the dereference <code>v</code> : </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = !(v&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;)</code> </pre> <br><p>  we will see that <code>v</code> again applied to the type argument, and returns a fresh reference cell containing an empty list. </p><br><p>  To flesh out a conversation about type functions, let's examine the resulting IL code.  If we compile the definition of <code>v</code> , our valid Reflector will show us that <code>v</code> is: </p><br><pre> <code class="hljs django"><span class="xml"><span class="xml">public static FSharpRef</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">FSharpList</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&gt; v</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">(){ return Operators.Ref</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">FSharpList</span></span></span></span><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">&gt;(FSharpList</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">T</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">.get_Empty()); }</span></span></code> </pre> <br><p>  What we perceive as a value in F # is actually a generic, parameterless method in the corresponding IL code.  Both assignment and dereference <code>v</code> call the IL method, which will return a new reference cell each time. </p><br><p>  However, nothing in the expression </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> []</code> </pre> <br><p>  does not hint at such behavior.  The name <code>v</code> looks like an ordinary value, and not at all a method or even a function.  If such a definition were allowed, F # developers would expect an unpleasant surprise.  That's why here the compiler stops displaying polymorphic parameters - the restriction on values ‚Äã‚Äãprotects you from unexpected behavior. </p><br><p>  So, when is automatic summarization safe?  It is difficult to give exact criteria, but one simple answer suggests itself: a generalization is safe when the right part of a <code>let</code> expression is at the same time: </p><br><ol><li>  Does not contain <em>side effects</em> (in other words, <em>clean</em> ) </li><li>  Returns an <em>immutable object</em> </li></ol><br><p>  Indeed, the bizarre behavior of <code>v</code> arises from the variability of the reference cell;  precisely because the reference cell is changeable, it was important to us whether one or different cells would be obtained as a result of different calls to <code>v</code> .  If the right part of the <code>let</code> expression does not contain side effects, we know that we always get equivalent objects, and since they are immutable, we don‚Äôt care if we get the same or different copies of them as a result of various calls. </p><br><p>  From the point of view of the compiler, it is difficult, even impossible, to determine whether the above conditions are fulfilled.  Therefore, the compiler uses a simple and crude, but natural and understandable approximation: it generalizes the definition only when it can deduce purity and immutability from the syntactic structure of the expression on the right side of <code>let</code> .  Therefore, an expression for which the original definition of <code>let listId l = List.map id l</code> is syntactic sugar </p><br><pre> <code class="hljs kotlin">let listId = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> l -&gt; List.map id</span></span></code> </pre> <br><p>  generalized - in the right part of the closure;  the creation of the circuit does not contain side effects and the circuit is immutable. </p><br><p>  Similarly with marked up associations: </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> q = <span class="hljs-literal"><span class="hljs-literal">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = []</code> </pre> <br><p>  and unchangeable entries: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">type</span></span> <span class="hljs-string"><span class="hljs-string">'ar = { x : '</span></span>a; <span class="hljs-attribute"><span class="hljs-attribute">y</span></span> : int } let r1 = { <span class="hljs-attribute"><span class="hljs-attribute">x</span></span> = []; <span class="hljs-attribute"><span class="hljs-attribute">y</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><p>  Here <code>r1</code> is of type <code>'a list r</code> .  However, if you try to initialize any fields of an immutable record by the result of a function call: </p><br><pre> <code class="hljs kotlin">let gen = let u = ref <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; u := !u + <span class="hljs-number"><span class="hljs-number">1</span></span>; !u let f = { x = []; y = gen() }</code> </pre> <br><p>  then the value of <code>f</code> will not be generalized.  In the example above, <code>gen</code> is an unconditionally <abbr title="non-pure">dirty</abbr> function;  it could be clean, but the compiler cannot know about it, so it returns an error as a precaution.  For the same reason </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> listId = <span class="hljs-type"><span class="hljs-type">List</span></span>.<span class="hljs-built_in"><span class="hljs-built_in">map</span></span> id</code> </pre> <br><p>  does not generalize - the compiler does not know if the pure <code>List.map</code> function <code>List.map</code> or not. </p><br><p>  Expressions for which the compiler at the syntax level can determine that they are clean and return immutable objects are called <em>syntactic values</em> .  So the restriction on values ‚Äã‚Äãgot its name - the <em>automatic generalization of the right side of the <code>let</code> expression is limited to syntactic values</em> .  The F # language description contains a complete list of syntactic values, but our discussion gives an idea of ‚Äã‚Äãwhat these expressions are - pure and returning immutable objects. </p><br><p>  The problem we are solving here is not new - all compilers of ML family languages ‚Äã‚Äãuse a restriction on values ‚Äã‚Äãin one form or another.  A unique, in my opinion, feature of F # is the ability to bypass the restriction on values ‚Äã‚Äãusing explicit type annotations, and this is safe from the point of view of F # semantics. </p><br><p>  When can this be useful?  The classic example is <code>lazy</code> and <code>lazy list</code> .  A typical definition of <code>lazy</code> (let's pretend that it is not in our language) </p><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> LazyInner = Delayed <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> (unit -&gt; <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>) | Value <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> | Exception <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> exn <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Lazy = <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> LazyInner ref let create f = ref (Delayed f) let <span class="hljs-keyword"><span class="hljs-keyword">force</span></span> (l : <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> Lazy) = ...</code> </pre> <br><p>  at first glance, full of side effects;  the compiler does not know the contract between <code>create</code> and <code>force</code> .  If we build the <code>lazy list</code> usual way using the <code>lazy</code> definition </p><br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> cell = Nil | CCons <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> * <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> lazylist <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> lazylist = <span class="hljs-symbol"><span class="hljs-symbol">'a</span></span> cell Lazy</code> </pre> <br><p>  and try to define an empty lazy list: </p><br><pre> <code class="hljs kotlin">let empty = create (<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; Nil)</code> </pre> <br><p>  restriction on values ‚Äã‚Äãwill not allow us to do this;  however, the polymorphic use of a lazy list is completely legal;  we can declare this by explicitly specifying the parameter of the polymorphic type: </p><br><pre> <code class="hljs kotlin">let empty&lt;<span class="hljs-string"><span class="hljs-string">'T&gt; : '</span></span>T lazylist = create (<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; Nil)</code> </pre> <br><p>  This is enough for the <code>empty</code> definition to compile, but if we try to use it: </p><br><pre> <code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> l = <span class="hljs-literal"><span class="hljs-literal">empty</span></span></code> </pre> <br><p>  the compiler will again be indignant: </p><br><pre> <code class="hljs vhdl">File1.fs(<span class="hljs-number"><span class="hljs-number">12</span></span>,<span class="hljs-number"><span class="hljs-number">5</span></span>): <span class="hljs-literal"><span class="hljs-literal">error</span></span> FS0030: Value restriction. The value <span class="hljs-string"><span class="hljs-string">'l'</span></span> has been inferred <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> have <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> val l : '_a lazylist Either define <span class="hljs-string"><span class="hljs-string">'l'</span></span> as a simple data term, make it a <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> explicit arguments <span class="hljs-keyword"><span class="hljs-keyword">or</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> you do <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> intend <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> be <span class="hljs-keyword"><span class="hljs-keyword">generic</span></span>, add a <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> annotation.</code> </pre> <br><p>  In fact, the compiler knows that <code>empty</code> is a type function that does not undergo automatic generalization, since it does not belong to a set of syntactic values.  F #, however, provides a loophole here - we can specify the <code>[&lt;GeneralizableValue&gt;]</code> attribute in the definition of <code>empty</code> : </p><br><pre> <code class="hljs kotlin">[&lt;GeneralizableValue&gt;] let empty&lt;<span class="hljs-string"><span class="hljs-string">'T&gt; : '</span></span>T lazylist = create (<span class="hljs-function"><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; Nil)</code> </pre> <br><p>  This forces the compiler to consider <code>empty</code> syntactic value, and the expression <code>let l = empty</code> compile. </p><br><p>  In fact, sometimes definitions like our polymorphic <code>v</code> can be useful: </p><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v&lt;<span class="hljs-symbol"><span class="hljs-symbol">'T</span></span>&gt; : <span class="hljs-symbol"><span class="hljs-symbol">'T</span></span> list <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> []</code> </pre> <br><p>  If you are writing a function that is <abbr title="type-parametrized">parameterizable by types</abbr> and returning mutable objects or having side effects, specify the <code>RequiresExplicitTypeArguments</code> attribute: </p><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">&lt;RequiresExplicitTypeArguments&gt;</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> v&lt;<span class="hljs-string"><span class="hljs-string">'T&gt; : '</span></span>T list <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> []</code> </pre> <br><p>  It completely corresponds to its name: now you cannot write <code>v := [1]</code> , only <code>v&lt;int&gt; := [1]</code> , and it will be clearer what is actually happening. </p><br><p>  If you have felt all this, I hope that you now have a clear understanding of the restrictions on values ‚Äã‚Äãin F #, and now you can control it with the help of explicit type annotations and the <code>GeneralizableValue</code> attribute if necessary.  Along with force, however, comes responsibility: as correctly stated in an article on MSDN, these features are rarely used in everyday programming in F #.  In my F # code, type functions appear only in cases similar to <code>lazylist</code> ‚Äî the basic cases of data structures;  In all other situations, I follow the tips from the article on MSDN: </p><br><ul><li>  Restrict the type so that it ceases to be polymorphic by adding an explicit type annotation to the value or parameter. </li><li>  If the problem is to use a non-generic construct to define a polymorphic function, such as a composition of functions or partial application of the arguments of a curried function, try rewriting the definition of the function to ordinary. </li><li>  If the problem is that the expression is too difficult to generalize, turn it into a function by adding an unused parameter. </li></ul><br><h1>  Additional resources </h1><br><p>  For F #, there are many tutorials, including materials for those who come with C # or Java experience.  The following links may be helpful as you learn more about F #: </p><br><ul><li>  <a href="https://docs.microsoft.com/ru-ru/dotnet/fsharp/%255D">F # Guide</a> </li><li>  <a href="https://swlaschin.gitbooks.io/fsharpforfunandprofit/content/">F # for Fun and Profit</a> </li><li>  <a href="https://en.wikibooks.org/wiki/F_Sharp_Programming">F # Wiki</a> </li><li>  <a href="https://learnxinyminutes.com/docs/fsharp/">Learn X in Y Minutes: F #</a> </li></ul><br><p>  Several other ways <a href="https://docs.microsoft.com/en-us/dotnet/fsharp/get-started/">to get started with learning F # are</a> also described. </p><br><p>  Finally, the F # community is very friendly to beginners.  There is a very active Slack chat, supported by the F # Software Foundation, with rooms for beginners that you <a href="http://foundation.fsharp.org/join">can freely join</a> .  We strongly recommend that you do this! </p><br><p>  Do not forget to visit the site of the <a href="http://fsharplang.ru/">Russian-speaking community F #</a> !  If you have any questions about learning the language, we will be happy to discuss them in chat rooms: </p><br><ul><li>  Room <code>#ru_general</code> in <a href="http://foundation.fsharp.org/join">Slack chat F # Software Foundation</a> </li><li>  <a href="https://t.me/Fsharp_chat">chat in Telegram</a> </li><li>  <a href="http://gitter.im/fsharplang_ru">chat in gitter</a> </li></ul><br><h2>  About authors of translation </h2><br><p>  Author translation <a href="https://habrahabr.ru/users/AnutaU/"><em>@AnutaU</em></a> . <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  Translation and editorial changes are made by the efforts of the <a href="http://fsharplang.ru/">Russian-speaking community of F # -developers</a> .  We also thank <a href="https://habrahabr.ru/users/schvepsss/"><em>@schvepsss</em></a> for preparing this article for publication. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/348460/">https://habr.com/ru/post/348460/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../348448/index.html">Web Apps: fast, cheap, cool</a></li>
<li><a href="../348450/index.html">Dissecting .xlsx files: editing a file with PL / SQL</a></li>
<li><a href="../348452/index.html">The man who with the Quantum "on you"</a></li>
<li><a href="../348454/index.html">How is the advanced protection against DDoS in Selectel</a></li>
<li><a href="../348458/index.html">Freeswitch: the path of least resistance</a></li>
<li><a href="../348462/index.html">Consilium in the smartphone: about the MegaFon.Health service and the development of telemedicine</a></li>
<li><a href="../348464/index.html">Operation "Y" and the new library ABI</a></li>
<li><a href="../348466/index.html">GopherCon Russia 2018: Conference Program Ready</a></li>
<li><a href="../348470/index.html">Corporate training at the Olympic Games in Sochi 2014</a></li>
<li><a href="../348472/index.html">What not to expect from 802.11ax?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>