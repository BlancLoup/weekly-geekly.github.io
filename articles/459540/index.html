<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Microntends: what are we talking about?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="All these years you, the frontend developer, have been writing monoliths, although you understood that this is a bad habit. You divided your code into...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Microntends: what are we talking about?</h1><div class="post__text post__text-html js-mediator-article"> All these years you, the frontend developer, have been writing monoliths, although you understood that this is a bad habit.  You divided your code into components, used <code>require</code> or <code>import</code> and defined npm packages in package.json or fetched git repositories in your project, but you still wrote a monolith. <br>  It's time to change the position. <br><a name="habracut"></a><br><h3>  <b>Why can your code be considered a monolith?</b> </h3><br>  By their nature, all frontend applications are monolithic - except for applications that implement micro-frontends.  The reason is that you are developing using the React library, and two teams are working.  Both must use the same version of React and keep each other informed of updates, which means they will always resolve conflicts when the code is merzh.  They are not completely independent of each other in the code base.  Probably, they generally use one repository and one build system.  Microservices can save from the solidity of the application!  But how so?  After all, they are for the backend!  * incredible surprise * <br><br><h3>  <b>What are microservices?</b> </h3><br>  In simple terms, microservices are a development technique that allows developers to make independent deliveries of functionality (releases) for different parts of the platform, and at the same time releases do not break each other.  Independent shipments allow them to collect isolated or loosely coupled services.  There are several rules that make such architecture more stable.  In short, they can be defined as follows: each service must be small and perform only one task.  Consequently, the team working on it should also be small.  How large the project and the team can be, <a href="https://martinfowler.com/articles/microservices.html">explains</a> James Lewis and Martin Fowler: <br><br><blockquote>  Developers interacting with microservices call different sizes.  The largest of them meet the strategy of Amazon about the " <i>team for two pizzas</i> " - no more than 10-12 people.  The reverse pole - a team of 5-6 people, where each supports one service. </blockquote><br>  Here is a diagram explaining the difference between a monolith and microservices: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/webt/jb/wa/hd/jbwahdgqhcgufovvsbd9yc_8wj0.jpeg"><br><br>  From the diagram it is clear that each service in the microservice system is a separate application, except for the UI - it remains a single whole!  When all services are supported by one team, the risk is great that as the company grows, the frontend team will no longer be able to keep up with the UI.  This is the vulnerability of this architecture. <br><br><img src="https://habrastorage.org/webt/sz/zs/to/szzsto67t102i-tdnrukvfcdx5w.jpeg"><br><br>  Architecture can bring organizational problems.  Suppose the company has grown and adopted flexible development methodologies (I‚Äôm talking about Agile).  They require small cross-functional teams.  Of course, in our abstract example, managers will begin to separate the tasks of the frontend and the backend, and the cross-functional teams will not be truly cross-functional.  And all efforts will be in vain: the team may look flexible, but in fact it will be very divided.  Managing such a team is not for the faint of heart.  At each scheduled meeting there will be a question: are there enough frontend tasks, are there enough backend tasks in the sprint?  To solve these and many other problems a couple of years ago the idea of ‚Äã‚Äãmicrofronted arose, which quickly gained popularity. <br><br><h3>  <b>Problem Solving: Microntends</b> </h3><br>  The solution looks pretty obvious, because similar principles have been successfully used for a long time in the work on backend-services: divide the monolithic frontend into small UI-fragments.  However, the UI is not quite similar to services - it is the interface between the end user and the product, it must be thoughtful and systemic.  Moreover, in the era of one-page applications, entire applications run through the browser on the client side.  These are no longer simple HTML files, these are complex components that can encompass different UI and business logic.  Now, perhaps, it is necessary to define micron-readings. <br><br><blockquote>  The microntend principle: the presentation of a website or web application as a <b>set of functions</b> for which independent teams are responsible.  Each team has its own mission, its own field of work, in which it specializes.  The team is cross-functional and develops <br>  <b>the whole cycle</b> - from the database to the user interface ( <a href="https://micro-frontends.org/">micro-fontend.org</a> ). </blockquote><br>  My current experience shows that many companies may find it difficult to accept the architecture proposed above.  To others - the load of the old code does not allow to switch to the new architecture.  Therefore, a smoother, easier and reliable way of migration is needed.  Having considered the architecture in detail, I will try to offer my own vision of the problem solution.  Before delving into the details, let's get acquainted with the terminology. <br><br>  <b>General structure and some more terminology</b> <br><br>  Imagine that we divide the structure of a monolithic application vertically, according to business functions.  We get several smaller applications with the same structure as the monolithic application.  But if we add a special application on top of these small monolithic applications, users will interact with it.  It, in turn, will integrate the UI of those small applications.  Let's call this level a binder, because it takes the UI-elements of each microservice and connects them into a single interface - this is the most direct implementation of the microfrontend.  * sincere admiration * <br><br><img src="https://habrastorage.org/webt/_z/uj/un/_zujun_sxd6nv5clohckbo5pgny.jpeg"><br><br>  To make it clearer, in the following I will call every small monolithic application a <b>microapplication</b> , since these are not just microservices, but standalone applications ‚Äî each of them has UI elements and each of them represents a full-fledged business function.  As you know, today's frontend ecosystem is very diverse and can be quite complex.  And such simple, obvious solutions may not be appropriate in the process of product implementation. <br><br><h3>  <b>Problems to solve</b> </h3><br>  When the idea of ‚Äã‚Äãthis article was born, I started a topic on Reddit to discuss it.  Thanks to the community members and their responses, I can provide a list of problems that need to be addressed. <br><br>  <b>Problem number 1:</b> achieve consistent and consistent behavior from the UI, when we have several completely autonomous micro applications <br><br>  There is no panacea, but there is an idea to create a common UI library, which would also be an independent micro application.  In this case, all other micro-applications will have to depend on this UI library.  And it kills their independence. <br><br>  Another option is to create common <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_custom_properties">CSS variables</a> at the root level.  The advantage of this solution is that we get a global custom theme for all applications. <br><br>  Or we can make SASS variables and impurities common to all commands.  Among the drawbacks of this approach will be the repeated implementation of UI-elements and the need to constantly check the design of similar elements in all micro applications. <br><br>  <b>Problem number 2:</b> make sure that one team does not rewrite the CSS of another team <br><br>  First, you can limit the scope of CSS using selectors, formed by the name of the micro application.  By placing this constraint on the link level, you can reduce the overall development time, but at the same time the link level responsibility will increase. <br><br>  Secondly, you can force each micro app to become a <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements">custom web component</a> .  The advantage of this approach is that the browser deals with the limitation.  However, everything has a price: with Shadow DOM it is almost impossible to render on the server side.  In addition, custom elements are <a href="https://caniuse.com/">not</a> 100% <a href="https://caniuse.com/">supported by browsers</a> - especially if you need IE support. <br><br>  <b>Problem number 3:</b> make global information common to different micro-applications <br><br>  This problem is one of the most common, but is solved quite easily.  HTML5 has a fairly powerful functionality, almost unknown to most front-end developers. <br>  One of these functions is custom events that allow you to make information common to micro applications. <br><br>  You may also be helped by the implementation of a pub-sub or T39.  If you need a more subtle global state handler, you can implement a small generic Redux - this results in a more reactive architecture. <br><br>  <b>Problem number 4:</b> if all micro-applications are autonomous, how to perform routing on the client side? <br><br>  Solving the problem depends on the implementation.  All major modern frameworks have powerful client-side routing mechanisms using the browser history state.  The problem is which application is responsible for the current route and when. <br><br>  My pragmatic approach is to create a common client router that is only responsible for the top-level routes, and the rest is given to the corresponding micro applications.  Suppose we have a route definition <code>/content/:id.</code>  The common router will decide the c <code>/content</code> , and the solved route will be transferred to ContentMicroApp.  ContentMicroApp is a standalone server that will be called only with <code>/:id</code> . <br><br>  <b>Problem number 5:</b> Do we really need SSR (server-side rendering), is it possible using microntend? <br><br>  Server side rendering is not an easy task.  If you want to associate micro-applications with iframes, forget about server-side rendering.  Similarly, web components for binding are not stronger than iframes.  However, if each of the micro applications is capable of rendering content on the server side, then the link layer will be responsible only for combining the HTML fragments on the server side. <br><br>  <b>Problem number 6:</b> ‚ÄúIntegration with the existing environment is necessary as air!  How to make it? <br><br>  To integrate with existing systems, I want to describe my vision, which I call ‚Äú <i>gradual introduction</i> ‚Äù. <br><br>  First of all, we need to implement the connecting layer so that it has the functionality of a transparent proxy server.  After that, we can define the existing system as a micro <i>application</i> ( <i>LegacyMicroApp</i> ), by declaring a special route to it.  All traffic arriving at the connecting level will transparently be proxied to the existing system, since we do not yet have other micro applications. <br><br>  The next stage is a gradual introduction.  We will take a small piece of <i>LegacyMicroApp</i> , removing the main navigation, replacing it with an addiction.  This dependency is a micro application implemented using a new brilliant technology, NavigationMicroApp. <br><br>  Now <i>LegacyMicroApp</i> will intercept all routes through the NavigationMicroApp dependency and process it internally. <br><br>  Then in the same way we redo the footer. <br><br>  So we will continue to bite off <i>LegacyMicroApp bit</i> by bit until nothing remains of it. <br><br>  <b>Problem number 7:</b> orchestrate the client side so that you do not have to reload the page <br><br>  The tie layer solves problems on the client side, but not on the server side.  On the client side, we can‚Äôt download single parts by loading a single HTML.  Therefore, we need a mechanism that loads fragments asynchronously.  The problem is that these fragments may have dependencies, and these dependencies need to be able to be resolved on the client side.  This means that the microntend solution should offer a mechanism for downloading micro applications and dependency injection. <br><br>  The problems listed above can be combined into the following topics: <br><br>  <b>Customer side</b> <br><br><ul><li>  Orchestration </li><li>  Routing </li><li>  Micro isolation </li><li>  Application Interaction </li><li>  Unity UI Micro Applications </li></ul><br>  <b>Server side</b> <br><br><ul><li>  Server rendering </li><li>  Routing </li><li>  Dependency management </li></ul><br><h3>  <b>Flexible and powerful but simple architecture</b> </h3><br>  For this, it was worth tasting the beginning of the article!  The basic elements and requirements of the microntend architecture have finally begun to emerge;) <br><br>  Guided by the identified requirements and concerns, I began to develop a solution called <b>microfe</b> .  * anticipation of feedback * <br>  Here I will outline the architecture of the project, describing in brief its main components. <br><br>  The easiest way to start is on the client side, which has three separate main structures: <i>AppsManager, Loader, Router</i> , as well as one additional, <i>MicroAppStore</i> . <br><br><img src="https://habrastorage.org/webt/av/xb/wm/avxbwmyjvlrs8zqwgf5jpbfpido.jpeg"><br><br>  <b>AppsManager</b> <br>  AppsManager is the core of micro client-side orchestration micro applications.  The main task of AppsManager is to create a dependency tree.  Once all dependencies are resolved, AppsManager runs the micro app. <br><br>  <b>Loader</b> <br>  Another important part of client side orchestration is Loader.  He is responsible for downloading applications for the client side. <br><br>  <b>Router</b> <br>  To perform client side routing, I implemented the Router in microfe.  Unlike conventional client-side routers, the microfe router has limited functionality.  It does not process pages, but micro-applications.  Suppose we have the URL <code>/content/detail/13</code> and ContentMicroApp.  In this case, the microfe router will process the URL to <code>/content/*</code> and invoke the ContentMicroApp <code>/detail/13</code> . <br><br>  <b>MicroAppStore</b> <br>  To solve client interactions between micro-applications, I implemented MicroAppStore into microfe.  It has similar functionality as the Redux library, but with one nuance: it is more flexible in terms of asynchronous data changes and reducer announcements. <br><br><h3>  <b>***</b> </h3><br>  The server side is perhaps a bit more complicated to implement, but it has a simpler structure.  It consists of two main parts - StitchingServer and MicroAppServer. <br><br><h3>  <b>MicroAppServer</b> </h3><br><img src="https://habrastorage.org/webt/ux/nl/wn/uxnlwnbgtmo0xr4-uryt6-tq2sq.jpeg"><br><br>  The minimum possible functionality of MicroAppServer can be expressed as: init and serve. <br>  When MicroAppServer is loaded, the first thing that it should do is call SticthingServer and register endpoint with the announced micro application.  It determines the dependencies, types, and URLs of the MicroAppServer schema. I think it‚Äôs unnecessary to talk about serve - there is nothing interesting here. <br><br><h3>  <b>Stitchingserver</b> </h3><br><img src="https://habrastorage.org/webt/i1/o6/n0/i1o6n0ititazoneaj1lcebo_syw.jpeg"><br><br>  StitchingServer allows you to register an endpoint with MicroAppServers.  When MicroAppServer registers with StichingServer, StichingServer records the MicroAppServer ad. <br><br>  Later, StitchingServer uses the ad to allow MicroAppServices from the required URL. <br><br>  Having resolved MicroAppServer and all its dependencies, the corresponding public URL appears in the names of all the corresponding paths in CSS, JS and HTML.  An additional step is to add the unique MicroAppServer prefix to the CSS selectors to prevent a conflict between micro applications on the client side. <br><br>  Then the main task of StitchingServer enters the scene: the layout of all the parts received and the return of the entire HTML page. <br><br><h3>  <b>A few words about other implementations</b> </h3><br>  Even before the term microfrontend appeared in 2016, many large companies tried to solve similar problems - for example, Facebook with its <a href="https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919/">BigPipe</a> . <br>  Now the idea is gaining momentum.  Companies of various sizes are interested in this topic, investing time and money in it.  For example, Zalando provided the open source code for its solution, <a href="https://www.mosaic9.org/">Project Mosaic</a> .  I can say that microfe and Project Mosaic follow similar approaches, but with some fundamental differences.  If microfe resorts to fully decentralized routing to make each microapplication more independent, Project Mosaic prefers centralized routing and pattern definition for each route.  By the way, Project Mosaic allows you to easily conduct AB testing and dynamic template generation on the fly. <br><br>  There are other approaches, in particular, the use of ifram as a link layer - obviously, not on the server side, but on the client side.  This is a very simple solution that does not require a special server structure and the involvement of DevOps.  It can be implemented by the front-end team independently, which means it creates less organizational problems for the company and costs less. <br><br>  There is also a <a href="https://single-spa.js.org/">single-spa</a> framework.  The project relies on naming conventions for each application to authorize and download micro applications.  Easily catch the idea and follow the patterns.  So the framework can be useful for dating and experimenting with the system in your local environment.  The minus of the project is that you have to build each microapplication in a strictly defined way - otherwise, the framework may not accept it. <br><br><h3>  <b>Conclusion (and links)</b> </h3><br>  I think that over time, the microntend theme will be considered in more detail.  If it starts to attract the attention of more and more companies, then this concept will become a development method in large teams by default.  For each front-end developer, it will be useful in the near future to get acquainted with this architecture and gain valuable experience working with it. <br><br>  <a href="https://github.com/onerzafer/microfe">micro fe app registry server</a> <br>  <a href="https://github.com/onerzafer/microfe-client">micro front end infrastructure</a> </div><p>Source: <a href="https://habr.com/ru/post/459540/">https://habr.com/ru/post/459540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../45953/index.html">Nikon introduces new flagship: D3X</a></li>
<li><a href="../459530/index.html">Microbiota Study history and research methods</a></li>
<li><a href="../459532/index.html">How to choose a random number from 1 to 10</a></li>
<li><a href="../459536/index.html">Develop plug-ins for JetBrains products and sell them on the JetBrains Marketplace</a></li>
<li><a href="../459538/index.html"># 18 Mosdroid Argon in Lamoda - Announcement</a></li>
<li><a href="../459542/index.html">Mechanics of gamification: skill tree</a></li>
<li><a href="../459544/index.html">Why the series "Chernobyl" so poorly described nuclear energy</a></li>
<li><a href="../45955/index.html">3g in the subway from MTS</a></li>
<li><a href="../459550/index.html">Backup Part 5: Testing Bacula and Veeam Backup for Linux</a></li>
<li><a href="../459552/index.html">How to lose access to the live system, simply by fumbling the source code</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>