<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ActiveRecord Query Interface 3.0</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This translation discusses innovations in the next version of ActiveRecrod for Ruby on Rails 3, and also describes a part of the module that will be e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>ActiveRecord Query Interface 3.0</h1><div class="post__text post__text-html js-mediator-article">  <i>This translation discusses innovations in the next version of ActiveRecrod for Ruby on Rails 3, and also describes a part of the module that will be excluded in favor of supporting new interfaces.</i> <br><br><h4>  What will lose support in Rails 3.1? </h4><br>  The following methods will be considered obsolete in the release of Rails 3.1 (but not Rails 3.0), and will be completely excluded from Rails 3.2 (although it will be possible to install a special plugin for their further use).  Keep in mind this warning because  it entails significant changes in the code. <br><br>  In short, passing the <code>options</code> hash containing <code>:conditions</code> <code>:include</code> <code>:joins</code> <code>:limit</code> <code>:offset</code> <code>:order</code> <code>:select</code> <code>:readonly</code> <code>:group</code> <code>having</code> <code>:from</code> <code>:lock</code> any method of the class provided by ActiveRecord ' This is now considered obsolete. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Consider this in more detail. <a name="habracut"></a>  Currently ActiveRecord provides the following methods for searching: <ul><li> <code>find(id_or_array_of_ids, options) find(:first, options) find(:all, options) first(options) all(options) update_all(updates, conditions, options)</code> </li> <li> <code>find(id_or_array_of_ids, options) find(:first, options) find(:all, options) first(options) all(options) update_all(updates, conditions, options)</code> </li> <li> <code>find(id_or_array_of_ids, options) find(:first, options) find(:all, options) first(options) all(options) update_all(updates, conditions, options)</code> </li> <li> <code>find(id_or_array_of_ids, options) find(:first, options) find(:all, options) first(options) all(options) update_all(updates, conditions, options)</code> </li> <li> <code>find(id_or_array_of_ids, options) find(:first, options) find(:all, options) first(options) all(options) update_all(updates, conditions, options)</code> </li> <li> <code>find(id_or_array_of_ids, options) find(:first, options) find(:all, options) first(options) all(options) update_all(updates, conditions, options)</code> </li> </ul>  As well as methods for computing: <ul><li> <code>count(column, options) average(column, options) minimum(column, options) maximum(column, options) sum(column, options) calculate(operation, column, options)</code> </li> <li> <code>count(column, options) average(column, options) minimum(column, options) maximum(column, options) sum(column, options) calculate(operation, column, options)</code> </li> <li> <code>count(column, options) average(column, options) minimum(column, options) maximum(column, options) sum(column, options) calculate(operation, column, options)</code> </li> <li> <code>count(column, options) average(column, options) minimum(column, options) maximum(column, options) sum(column, options) calculate(operation, column, options)</code> </li> <li> <code>count(column, options) average(column, options) minimum(column, options) maximum(column, options) sum(column, options) calculate(operation, column, options)</code> </li> <li> <code>count(column, options) average(column, options) minimum(column, options) maximum(column, options) sum(column, options) calculate(operation, column, options)</code> </li> </ul>  Starting with Rails 3.0, passing any options to these methods is considered obsolete, and will be completely excluded in Rails 3.2.  Moreover, the methods <code>find(:first)</code> and <code>find(:all)</code> (without any additional options) will also be excluded in favor of <code>first</code> and <code>all</code> .  As an exception to the rules, <code>count()</code> will still accept the <code>:distinct</code> option. <br><br>  The following code illustrates the use of options that are no longer supported: <blockquote> <code>User.find(:all, :limit =&gt; 1) <br> User.find(:all) <br> User.find(:first) <br> User.first(:conditions =&gt; {:name =&gt; 'lifo'}) <br> User.all(:joins =&gt; :items)</code> </blockquote> <br>  But such code will still work: <blockquote> <code>User.find(1) <br> User.find(1,2,3) <br> User.find_by_name('lifo')</code> </blockquote> <br>  On top of that, passing the options hash to the <code>named_scope</code> method will also lose support: <br><blockquote> <code>named_scope :red, :conditions =&gt; { :colour =&gt; 'red' } <br> named_scope :red, lambda {|colour| {:conditions =&gt; { :colour =&gt; colour }} } <br></code> </blockquote><br>  Support will also be lost by passing options with the methods <code>with_scope</code> , <code>with_exclusive_scope</code> and <code>default_scope</code> : <br><blockquote> <code>with_scope(:find =&gt; {:conditions =&gt; {:name =&gt; 'lifo'}) { ... } <br> with_exclusive_scope(:find =&gt; {:limit =&gt;1}) { ... } <br> default_scope :order =&gt; "id DESC" <br></code> </blockquote><br>  Dynamic <code>scoped_by_</code> will likewise go down in history: <blockquote> <code>red_items = Item.scoped_by_colour('red') <br> red_old_items = Item.scoped_by_colour_and_age('red', 2)</code> </blockquote> <br><h4>  New API </h4><br>  ActiveRecord in Rails 3 will get the following methods to search for (an existing equivalent of the <code>options</code> hash is shown in parentheses): <ul><li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> <li> <code>where (:conditions) select group order limit joins includes (:include) lock readonly from</code> </li> </ul><h5>  Chains </h5><br>  Each of the above methods returns an object of the <code>Relation</code> class.  In principle, <code>Relation</code> very similar to anonymous <code>named_scope</code> .  All of these methods are also defined in it itself, which makes it possible to create call chains: <blockquote> <code>lifo = User.where(:name =&gt; 'lifo') <br> new_users = User.order('users.id DESC').limit(20).includes(:items)</code> </blockquote> <br>  You can also apply several finders to existing Relations: <blockquote> <code>cars = Car.where(:colour =&gt; 'black') <br> rich_ppls_cars = cars.order('cars.price DESC').limit(10)</code> </blockquote> <br><h5>  Almost Model </h5><br>  Relation behaves exactly like a model when it comes to using primary <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a> methods.  Any of the following methods can be called on an object of the Relation class: <ul><li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> <li> <code>new (attributes) create (attributes) create! (attributes) find (id_or_array) destroy (id_or_array) destroy_all delete (id_or_array) delete_all update (ids, updates) update_all (updates) exists?</code> </li> </ul>  The following code works as expected: <br><blockquote> <code>red_items = Item.where(:colour =&gt; 'red') <br> red_items.find(1) <br> item = red_items.new <br> item.colour #=&gt; 'red' <br> <br> red_items.exists? #=&gt; true <br> red_items.update_all :colour =&gt; 'black' <br> red_items.exists? #=&gt; false</code> </blockquote> <br>  It is important to know that calling the <code>update</code> or <code>delete</code> / <code>destroy</code> method will ‚Äúreset‚Äù the <code>Relation</code> , i.e.  will remove cache entries used to optimize methods (such as <code>relation.size</code> ). <br><br><h5>  Lazy loading </h5><br>  Perhaps from the previous examples it has already become clear that <code>Relations</code> loaded ‚Äúlazily‚Äù - i.e.  above them it is necessary to call the methods of working with the collection.  This is very similar to how <code>associations</code> and <code>named_scope</code> 's already work. <blockquote> <code>cars = Car.where(:colour =&gt; 'black') # Relations ,      <br> cars.each {|c| puts c.name } #   "select *   cars  ..."</code> </blockquote> <br>  This is very useful along with fragment caching.  So, in the controller it is enough to call: <br><blockquote> <code>def index <br> @recent_items = Item.limit(10).order('created_at DESC') <br> end</code> </blockquote>  And in view: <br><blockquote> <code>&lt;% cache('recent_items') do %&gt; <br> &lt;% @recent_items.each do |item| %&gt; <br> ... <br> &lt;% end %&gt; <br> &lt;% end %&gt;</code> </blockquote> <br>  In the previous example, <code>@recent_items</code> filled from the database only at the moment of calling <code>@recent_items.each</code> from the <code>view</code> .  Since the controller does not execute the query from the database, fragment caching becomes much more efficient without requiring any additional work. <br><br><h5>  Forced download - <code>all</code> , <code>first</code> &amp; <code>last</code> </h5><br>  In the case when we do not need a lazy load, it is enough just to call, for example, <code>all</code> on an object of the Relation type: <br><blockquote> <code>cars = Car.where(:colour =&gt; 'black').all</code> </blockquote> <br>  It is important to remember that here <code>all</code> returns <code>Array</code> , not <code>Relation</code> .  This is similar to the way <code>named_scope</code> and <code>associations</code> work in Rails 2.3 now. <br>  Similarly, the <code>first</code> and <code>last</code> methods will return an object of type <code>ActiveRecord</code> (or <code>nil</code> ): <br><blockquote> <code>cars = Car.order('created_at ASC') <br> oldest_car = cars.first <br> newest_car = cars.last</code> </blockquote> <br><h5>  <code>named_scope</code> ‚Üí <code>scope</code> </h5><br>  <i>Using the <code>named_scope</code> method is considered obsolete in Rails 3.0, in favor of <code>scope</code> .</i>  <i>But the only thing that really changed is that now you don‚Äôt need to write the <code>named_</code> prefix.</i>  <i>Passing options for the search will be permanently excluded from Rails 3.1.</i> <br>  The <code>named_scope</code> method was simply renamed <code>scope</code> .  Those.  the following definition: <br><blockquote> <code>class Item <br> named_scope :red, :conditions =&gt; { :colour =&gt; 'red' } <br> named_scope :since, lambda {|time| {:conditions =&gt; ["created_at &gt; ?", time] }} <br> end</code> </blockquote> <br>  Now it looks like: <br><blockquote><pre>  class Item
     scope: red,: conditions =&gt; {: color =&gt; 'red'}
     scope: since, lambda {| time |  {: conditions =&gt; ["created_at&gt;?", time]}}
 end </pre></blockquote><br>  But, since the options hash will be excluded, in fact, you have to write using new methods for searching, i.e.  like this: <br><blockquote><pre>  class Item
     scope: red, where (: color =&gt; 'red')
     scope: since, lambda {| time |  where ("created_at&gt;?", time)}
 end </pre></blockquote><br>  Internally, <code>named scope</code> 's are add-ins over <code>Relation</code> , thereby making very simple variations for use in conjunction with <code>finder</code> methods: <br><blockquote> <code>red_items = Item.red <br> available_red_items = red_items.where("quantity &gt; ?", 0) <br> old_red_items = Item.red.since(10.days.ago)</code> </blockquote> <br><h5> <code>Model.scoped</code> </h5> <br>  If you need to build a complex query, starting with a "pure" Relation, you must use <code>Model.scoped</code> . <br><blockquote> <code>cars = Car.scoped <br> rich_ppls_cars = cars.order('cars.price DESC').limit(10) <br> white_cars = cars.where(:colour =&gt; 'red')</code> </blockquote> <br>  By the way, speaking of internals, <code>ActiveRecord::Base</code> now contains the following delegates: <br><blockquote> <code>delegate :find, :first, :last, :all, :destroy, :destroy_all, :exists?, :delete, :delete_all, :update, :update_all, :to =&gt; :scoped <br> delegate :select, :group, :order, :limit, :joins, :where, :preload, :eager_load, :includes, :from, :lock, :readonly, :having, :to =&gt; :scoped <br> delegate :count, :average, :minimum, :maximum, :sum, :calculate, :to =&gt; :scoped</code> </blockquote> <br>  The code above can give a more transparent view of what is happening inside <code>ActiveRecord</code> .  In addition to this, any dynamic methods, aka <code>find_by_name</code> , <code>find_all_by_name_and_colour</code> , are also delegated to the <code>Relation</code> 'y. <br><br><h5>  <code>with_scope</code> and <code>with_exclusive_scope</code> </h5><br>  <code>with_scope</code> and <code>with_exclusive_scope</code> now built on top of <code>Relation</code> 'a, providing the ability to use any relation with them: <br><blockquote><pre>  with_scope (where (: name =&gt; 'lifo')) do
    ...
 end </pre></blockquote><br>  Or even named scope: <br><blockquote><pre>  with_exclusive_scope (Item.red) do
    ...
 end </pre></blockquote></div><p>Source: <a href="https://habr.com/ru/post/82767/">https://habr.com/ru/post/82767/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../82759/index.html">Overview of initial server platforms in Hostkey.ru</a></li>
<li><a href="../82760/index.html">Research success IT projects</a></li>
<li><a href="../82764/index.html">Meeting of the group of users of Google technologies in Kiev - Kyiv GTUG Center</a></li>
<li><a href="../82765/index.html">HP OmniBook 2100</a></li>
<li><a href="../82766/index.html">Wacom's First Professional Wireless Tablet</a></li>
<li><a href="../82770/index.html">New common error: invalid form submission character</a></li>
<li><a href="../82771/index.html">The sea is worried once ..., or Captcha 4D</a></li>
<li><a href="../82772/index.html">Lost youtube client for sonyericsson w995 + instructions for picking up jar</a></li>
<li><a href="../82778/index.html">question in space: will there be a normal post markup language in Habr√©?</a></li>
<li><a href="../82779/index.html">k3b 2 went into beta</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>