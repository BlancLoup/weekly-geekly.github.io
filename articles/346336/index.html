<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Rust: ‚ÄúUnsafe Abstractions‚Äù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The unsafe keyword is an integral part of the design of the Rust language. For those who are not familiar with it: unsafe is a keyword that, in simple...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Rust: ‚ÄúUnsafe Abstractions‚Äù</h1><div class="post__text post__text-html js-mediator-article"><p> The <code>unsafe</code> keyword is an integral part of the design of the Rust language.  For those who are not familiar with it: <code>unsafe</code> is a keyword that, in simple terms, is a way to bypass Rust's <em>type checking</em> . </p><br><p>  The existence of the <code>unsafe</code> keyword is a surprise to many at first. <br>  In fact, except that the programs do not "fall" from errors when working with memory, <br>  Isn't it a feature of Rust?  If so, then why is there an easy way to get around <br>  type system?  This may seem like a language defect. </p><br><p>  But not everything is so simple, the details - under the cut. </p><a name="habracut"></a><br><p>  This note represents the <code>unsafe</code> keyword and the idea of ‚Äã‚Äãlimited "insecurity." <br>  In fact, this is a precursor of a <a href="http://smallcultfollowing.com/babysteps/blog/2016/05/27/the-tootsie-pop-model-for-unsafe-code/">note</a> that I hope to write a little later. <br>  She discusses the Rust memory model, which indicates what can and cannot be done in <code>unsafe</code> code. </p><br><p>  <code>unsafe</code> code adds 3 features: </p><br><ol><li>  Reading and writing a <em>static mutable</em> variable <br>  In C, this variable is denoted <code>extern</code> . <br>  Since a variable can be simultaneously accessed from multiple threads, <br>  then a <em>race condition</em> occurs when the variable is not synchronized. <br>  Rust by default prevents this, and <code>unsafe</code> code is used to get around this restriction. </li></ol><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> N: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one</span></span></span></span>(n: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { n + <span class="hljs-number"><span class="hljs-number">1</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { N = add_one(N); <span class="hljs-comment"><span class="hljs-comment">//  } // -   unsafe { println!("{}", N); //  } }</span></span></code> </pre> <br><ol><li>  Raw pointer dereference <br>  The compiler does not know in advance where the pointer is pointing. <br>  Responsibility assumes the programmer who checks <br>  that the value of the pointer points to a memory whose access is allowed. </li></ol><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_one_ptr</span></span></span></span>(n: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { *n = *n + <span class="hljs-number"><span class="hljs-number">1</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> n = <span class="hljs-number"><span class="hljs-number">5</span></span>; add_one_ptr(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> n <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  // -   // safe ,  n -  static mutable //      println!("{}", n); //  }</span></span></code> </pre> <br><p>  This code will call segmentation fault: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> ptr = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>; *ptr = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br><ol><li>  Call <code>unsafe</code> code <br>  Any <code>unsafe</code> code must be indicated by an <code>unsafe</code> block. <br>  In the case of a function whose signature contains the <code>unsafe</code> specifier, its entire code is considered <br>  not safe, so you need to wrap the call to this function in an <code>unsafe</code> block. </li></ol><br><p>  Like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_dangerous_thing</span></span></span></span>() { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, <span class="hljs-string"><span class="hljs-string">"in `unsafe` code"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { do_dangerous_thing(); } }</code> </pre> <br><p>  Yet, in my opinion, <code>unsafe</code> not a disadvantage.  In fact he is <br>  important part of the language.  <code>unsafe</code> plays the role of some kind of output valve - this means that we can use the type system in simple cases, but allowing us to use all sorts of tricks that you want to use in your code.  We only require that you hide these your tricks ( <code>unsafe</code> code) behind safe external abstractions. </p><br><h2 id="nebezopasnyy-kod-kak-plagin">  "Unsafe" code as a plugin </h2><br><p>  I think that how interpreted languages ‚Äã‚Äãlike Ruby (or Python) use C code is a good comparison to <code>unsafe</code> work in Rust.  Take, say, a JSON module in Ruby.  It includes both a Ruby implementation (JSON :: Pure) and an alternative C implementation (JSON :: Ext).  Usually when you use the JSON module, you run C code, but Ruby code <br>  does not interact with it as it does with regular Ruby code.  Externally, this code looks like this <br>  same as any other Ruby module, but inside it can use various clever tricks and perform optimizations that cannot be written only in the code on Ruby itself.  (You can read this excellent article on <a href="http://blog.skylight.io/introducing-helix/">Helix</a> to learn more, also there you can learn how to write Ruby plugins on Rust). </p><br><p>  Well, the same can happen in Rust, but on a slightly different scale.  For example, you can write a productive implementation of a hash table on a clean Rust.  Adding <code>unsafe</code> code will make this code even faster.  If this data structure will be used by many people or its work is very important for your program, <br>  then it may be worth it (Therefore, we use <code>unsafe</code> code in the implementation of the standard library).  However, in any case, the calling code on Rust refers to <code>unsafe</code> code in the same way as <code>unsafe</code> : the superimposed levels of abstraction provide a uniform <br>  external API. </p><br><p>  Of course, the fact that using <code>unsafe</code> code allows you to make a program faster does not mean that you should use it very often.  Just like most Ruby code written in Ruby, most Rust code is written in <em>safe</em> Rust.  This is also true because safe Rust code is very efficient, so the benefits of switching to using <code>unsafe</code> code to achieve high performance are rarely worth the effort. </p><br><p>  It seems that the most frequent use of <code>unsafe</code> code in Rust is the use of libraries in other languages ‚Äã‚Äãthrough the FFI ( <em>Foreign Function Interface</em> ).  Each C function call from Rust is <code>unsafe</code> , because the compiler cannot judge the "security" of the C code. </p><br><h2 id="rasshirenie-yazyka-posredstvom-unsafe-koda">  Expansion of the language through <code>unsafe</code> code. </h2><br><p>  I think the most interesting thing is to write <code>unsafe</code> code in Rust (or C module in Ruby) in order <br>  to empower the language.  Probably the most frequently cited example is the type <code>Vec</code> in the standard library, which uses <code>unsafe</code> code to manipulate uninitialized memory.  <code>Rc</code> and <code>Arc</code> , which are reference counters, <br>  are also a case in point.  However, there are much more interesting examples, such as: <em>CrossBeam</em> and <em>deque</em> use <code>unsafe</code> code to implement non-blocking ( <em>lock-free</em> ) data structures, or <em>Jobsteal</em> and <em>Rayon</em> use <code>unsafe</code> code to implement a thread pool (thread pool). </p><br><p>  In this article we will look at one simple example: the <code>split_at_mut</code> method, which is available in the standard library.  This method works with <em>mutable slices</em> .  It also takes an index ( <code>mid</code> ) and divides the slice into two parts at the specified index.  Subsequently, it returns two smaller slice: one with a range of <code>0..mid</code> , the second - in the <code>mid..</code> </p><br><p>  For convenience, you can imagine <code>split_at_mut</code> implemented as: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> [T] { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split_at_mut</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, mid: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; (&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T], &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) { (&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>..mid], &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>[mid..]) } }</code> </pre> <br><p>  This code will not be compiled for two reasons: </p><br><ul><li>  In the general case, the compiler does not consider the index too "intently", apart from the enclosing array.  This means that when he sees an index of the form <code>foo[i]</code> , he ignores the index and treats the array as if it were a single whole ( <code>foo[_]</code> ).  This means that it cannot reveal that <code>&amp;mut self[0..mid]</code> is a call to a different memory location than <code>&amp;mut self[mid..]</code> .  This is due to the fact that conducting a similar analysis would require a much more complex type system. </li><li>  In fact, the operator <code>[]</code> not part of the language - it is fully implemented in the standard library.  Therefore, even if the compiler knew that <code>0..mid</code> and <code>mid..</code> do not overlap, it would not follow from this that he <code>0..mid</code> that these ranges apply to non-overlapping memory areas. </li></ul><br><p>  One can imagine that it is possible, by changing the compiler, to ensure that the specified code sample will be compiled, and perhaps we will implement it once.  But at the moment we prefer to implement methods like <code>split_at_mut</code> using <code>unsafe</code> code.  This allows us to have a simple type system, having the ability to write an API like <code>split_at_mut</code> . </p><br><h2 id="granicy-abstrakcii">  Boundaries of abstraction </h2><br><p>  A look at <code>unsafe</code> code as a plug code allows you to clearly express the idea of ‚Äã‚Äã"boundaries of abstraction."  When you write a plugin in Rust, you expect that when the calling code in Ruby calls your functions, it will provide you with Ruby-related variables. <br>  Inside, you can do what you want, for example, use a C array instead of a <code>vector</code> in Ruby.  But when you go back to running Ruby code, you must convert your returned entities to standard Ruby variables. </p><br><p>  The same is true for <code>unsafe</code> code on Rust.  Client code seems that your code is <em>safe</em> .  This means that it can be assumed that the calling code will pass valid values ‚Äã‚Äãto the input.  It also means that all your values ‚Äã‚Äãthat you return must comply with the requirements of the Rust type system.  Being inside <code>unsafe</code> borders, you can bypass the rules at your own discretion (of course, the amount of additional features provided is a topic for discussion; I hope to discuss this in a later note). </p><br><p>  Let's look at the <code>split_at_mut</code> method that we saw in the last section.  To simplify the understanding, we will consider only the external interface of the function, represented by the signature: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> [T] { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split_at_mut</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, mid: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; (&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T], &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) { <span class="hljs-comment"><span class="hljs-comment">//   ,       //   .        //  ,   . } }</span></span></code> </pre> <br><p>  What can we understand from this signature? <br>  To begin with, <code>split_at_mut</code> relies on the fact that all its input data is valid (in safe code, the compiler checks that this is indeed the case).  <code>unsafe</code> semantics of the <code>split_at_mut</code> method can be expressed in the following rules: </p><br><ul><li>  <code>self</code> argument is of the type <code>mut [T]</code> .  From this it follows that we will get a link indicating some (N) number of elements of type T. This is a <em>mutable</em> link, so we know that no one else can access the memory addressed by <code>self</code> (while the mutable link is not will cease to exist).  We also know that memory is initialized. </li><li>  <code>mid</code> argument is of type <code>usize</code> .  All we know is that this variable is a non-negative integer. </li></ul><br><p>  There is another unmentioned moment.  Nowhere is it guaranteed that the <code>mid</code> index is a valid index for accessing <code>self</code> .  It follows from this that the <code>unsafe</code> code we are going to write will have to verify this. </p><br><p>  When <code>split_at_mut</code> completes, it should make the return value <br>  matched the signature.  Simply put, this means that the function should return <br>  two allowable (pointing to allocated memory) sub-array ( <em>slice</em> ). It is also important that these sub-arrays do not overlap, that is, they are two non-overlapping sections of memory. </p><br><h2 id="vozmozhnye-realizacii">  Possible implementations </h2><br><p>  Let's look at several possible implementations of <code>split_at_mut</code> and determine if they are working variants or not.  We have already seen that the implementation written in "pure" Rust does not work (does not compile).  Let's try to implement a function using raw pointers: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> [T] { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split_at_mut</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, mid: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; (&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T], &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::slice::from_raw_parts_mut; <span class="hljs-comment"><span class="hljs-comment">// `unsafe`       ** . //  `unsafe` ,  ,     //    UB(undefined behaviour). unsafe { //  **     let p: *mut T = &amp;mut self[0]; //    `mid`  let q: *mut T = p.offset(mid as isize); //    `mid` let remainder = self.len() - mid; // ""      `0..mid` let left: &amp;mut [T] = from_raw_parts_mut(p, mid); // ""      `mid..` let right: &amp;mut [T] = from_raw_parts_mut(q, remainder); (left, right) } } }</span></span></code> </pre> <br><p>  This version is closest to the <a href="">one that is implemented in the standard library.</a> <br>  However, this code is based on an assumption that is not justified by the input values: the code assumes that <code>mid</code> is within the bounds of the array.  Nowhere is it verified that <code>mid &lt;= len</code> .  This means that <code>q</code> can be outside the bounds of the array, it also means that calculating the <code>remainder</code> can cause type overflow and <em>wrap around</em> <br>  <strong>This is an incorrect implementation</strong> , because it requires more guarantees than is required <br>  from the calling code. </p><br><p>  We can fix this implementation by adding <em>assert to</em> the fact that <code>mid</code> is <br>  a valid index (note that <em>assert</em> in Rust is always executed, even in optimized code): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> [T] { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split_at_mut</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, mid: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; (&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T], &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) { <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> std::slice::from_raw_parts_mut; <span class="hljs-comment"><span class="hljs-comment">// ,  `mid`    : assert!(mid &lt;= self.len()); //   ,    unsafe { let p: *mut T = &amp;mut self[0]; let q: *mut T = p.offset(mid as isize); let remainder = self.len() - mid; let left: &amp;mut [T] = from_raw_parts_mut(p, mid); let right: &amp;mut [T] = from_raw_parts_mut(q, remainder); (left, right) } } }</span></span></code> </pre> <br><p>  Well, here we practically repeated the implementation of this function in the standard library (here we used several other auxiliary <br>  tools, but, in essence, the idea is the same). </p><br><h2 id="rasshiryaem-granicy-abstrakcii">  Expanding the boundaries of abstraction </h2><br><p>  Of course, it could happen that we actually wanted to assume that <code>mid</code> was within acceptable limits, and wanted to do without this check.  We cannot do this because <code>split_at_mut</code> is part of the standard library.  However, you can imagine a helper method for the calling code to validate this assumption, so that we would do without a costly check to find the index within the array at run time.  In this case, <code>split_at_mut</code> relies on the calling auxiliary code in order to ensure that the <br>  <code>mid</code> in array boundaries.  This means that <code>split_at_mut</code> no longer a safe code, because it has additional input requirements to ensure safe memory handling. </p><br><p>  Rust allows you to express that the entire function code is <code>unsafe</code> by placing the <code>unsafe</code> keyword in the function signature.  After such a move, the "insecurity" of the code is no longer an <strong>internal part of the implementation of the</strong> function; now it is part of <strong>the function interface</strong> .  So we can make the <code>split_at_mut</code> option - <code>split_at_mut_unchecked</code> - which does not check <code>split_at_mut_unchecked</code> <code>mid</code> within acceptable limits: </p><br><pre> <code class="rust hljs"> <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> [T] { <span class="hljs-comment"><span class="hljs-comment">//      `unsafe`.   //   `unsafe`    , //      : `mid &lt;= self.len()`. unsafe pub fn split_at_mut_unchecked(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) { use std::slice::from_raw_parts_mut; let p: *mut T = &amp;mut self[0]; let q: *mut T = p.offset(mid as isize); let remainder = self.len() - mid; let left: &amp;mut [T] = from_raw_parts_mut(p, mid); let right: &amp;mut [T] = from_raw_parts_mut(q, remainder); (left, right) } }</span></span></code> </pre> <br><p>  When <code>fn</code> declared <code>unsafe</code> just as it was done above, its call also becomes <code>unsafe</code> .  This means that the person who writes the calling code must review the documentation of the function and make sure that all conditions are met. <br>  And in this particular case, the calling code must make sure that <code>mid &lt;= self.len()</code> . </p><br><p>  If you think about the boundaries of abstraction, an <code>unsafe</code> declaration means that it is not part of the ‚Äúsafe‚Äù Rust area, where the compiler itself detects errors by performing static analysis at the compilation stage.  On the contrary, this means that a new abstraction appears, which becomes part of the <code>unsafe</code> abstraction of the calling code. </p><br><p>  Using <code>split_at_mut_unchecked</code> , we can change the implementation of <code>split_at_mut</code> so that it, inside of itself, carrying out the necessary checks, <code>split_at_mut_unchecked</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> [T] { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">split_at_mut</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, mid: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) -&gt; (&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T], &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> [T]) { <span class="hljs-built_in"><span class="hljs-built_in">assert!</span></span>(mid &lt;= <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.len()); <span class="hljs-comment"><span class="hljs-comment">//  `unsafe`-  ,  ,    //   ,   `split_at_mut_unchecked`, // ,        . unsafe { self.split_at_mut_unchecked(mid) } } // **NB:** ,  `mid &lt;= self.len()`. pub unsafe fn split_at_mut_unchecked(&amp;mut self, mid: usize) -&gt; (&amp;mut [T], &amp;mut [T]) { ... //   . } }</span></span></code> </pre> <br><h2 id="nebezopasnye-abstrakcii-i-privatnost">  Unsafe abstractions and privacy. </h2><br><p>  Despite the fact that there is nothing in the language that would explicitly link the rules of privacy and the boundaries of unsafe abstractions, yet they are naturally related to each other.  This is because privacy allows you to control a piece of code that can change <br>  field in your data, and this is the main building block used to build <code>unsafe</code> abstractions. </p><br><p>  Earlier, we noticed that the <code>Vec</code> type in the standard library is implemented using <code>unsafe</code> code.  It would not be possible without privacy.  If you look at the definition of <code>Vec</code> , you will see that it looks like this: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span></span>&lt;T&gt; { pointer: *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> T, <span class="hljs-comment"><span class="hljs-comment">//       capacity: usize, //    length: usize, //    }</span></span></code> </pre> <br><p>  The <code>Vec</code> implementation code carefully maintains the invariant that the <code>pointer</code> and the first <code>length</code> elements it refers to are always valid.  One would think that if <code>length</code> were an open ( <em>pub</em> ) field, then the upper invariant would not be possible: any calling external code could change the length of <code>Vec</code> to an arbitrary one. </p><br><p>  For this reason, the boundaries of "insecurity" tend to fall into one of two categories: </p><br><ul><li>  single functions like <code>split_at_mut</code> </li><li>  the type that is contained in its own module, for example, <code>Vec</code> <br><ul><li>  This type, as correctly, has private auxiliary functions. </li><li>  may also contain helper functions that are <code>unsafe</code> </li></ul></li></ul><br><h2 id="tipy-s-unsafe-interfeysami">  Types with <code>unsafe</code> interfaces </h2><br><p>  As we saw earlier, it can sometimes be useful to create <code>unsafe</code> functions like <code>split_at_mut_unchecked</code> , which can serve as a building block for safe abstractions.  This is also true for types.  Looking at the <code>Vec</code> implementation from the standard library, you will see that it looks like the code above. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span></span>&lt;T&gt; { buf: RawVec&lt;T&gt;, len: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, }</code> </pre> <br><p>  What is this type, <code>RawVec</code> ?  It turns out that this is <a href=""><code> unsafe</code> type</a> which contains a pointer ( <em>pointer</em> ) and a capacity ( <em>capacity</em> ): </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">RawVec</span></span></span></span>&lt;T&gt; { <span class="hljs-comment"><span class="hljs-comment">// `Unique`     `unsafe` , //   **    (uniquely owned). ptr: Unique&lt;T&gt;, cap: usize, }</span></span></code> </pre> <br><p>  What makes <code>RawVec</code> an auxiliary <code>unsafe</code> type?  Unlike functions, the concept of " <code>unsafe</code> type" is rather vague.  I define this type as a type that does not allow you to do anything useful without using <code>unsafe</code> code.  Safe ( <em>safe</em> ) code allows you to construct <code>RawVec</code> , it even allows you to change the size of the buffer that underlies <code>Vec</code> , but if you want to access the value that is in this buffer, you can only do this using <a href=""><code> ptr</code></a> that returns <code>*mut T</code>  This is a raw pointer, so dereferencing is <code>unsafe</code> action.  This means that in order to provide useful functionality, <code>RawVec</code> must be included in another <code>unsafe</code> abstraction (similar to <code>Vec</code> , which tracks initialization. </p><br><h2 id="vyvod">  Conclusion </h2><br><p>  <code>unsafe</code> abstractions are quite powerful tools.        ,      ,       ,           .   ""         ,       <code>Vec</code>  <code>Rc</code> .    <code>unsafe</code>    API,       . </p><br><h2 id="kak-daleko-mozhno-zayti">    ? </h2><br><p>   ,       ,  ,   ,      <code>unsafe</code> .  ,  <code>unsafe</code>    ,   ,       ?        ,   . <a href="https://github.com/rust-lang/rfcs/issues/1447"> ,    </a> .   RFC,   , ,  ,     ,          . </p><br><p>  <a href="https://github.com/rust-lang/rfcs/pull/1578">    RFC</a> ,     ,          .  ,  ,        ,       .      ,  <code>unsafe</code> ,    , <br>     ,    . </p><br><p>    .    <code>unsafe</code>  ,      .             aliasing         (statements reordering). </p><br><p>          ,     <code>unsafe</code> <br>       .  , ,  safe-    , ,        <code>unsafe</code> . </p><br><p>  Many thanks to everyone from the Rustycrate community who participated in the translation, proofreading and editing of this article.  : born2lose, ozkriff, vitvakatu. </p><br><p> <strong>UPD</strong> :   3  <code>unsafe</code> . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/346336/">https://habr.com/ru/post/346336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../346326/index.html">Analytics Guide for Startup Founder</a></li>
<li><a href="../346328/index.html">ITMO University Digest: the most interesting materials in our blog over the past year</a></li>
<li><a href="../346330/index.html">Architecture and programming Mattel Intellivision</a></li>
<li><a href="../346332/index.html">Visualization of discrete space: a torus versus a simplex</a></li>
<li><a href="../346334/index.html">Unlimited speech recognition. Or how I translate voice messages into text in a bot</a></li>
<li><a href="../346338/index.html">Using the inverse Laplace transform to analyze the dynamic links of control systems</a></li>
<li><a href="../346340/index.html">Flask Mega-Tutorial, Part 2: Patterns (Edition 2018)</a></li>
<li><a href="../346342/index.html">Flask Mega-Tutorial, Part 3: Web Forms (Edition 2018)</a></li>
<li><a href="../346344/index.html">Flask Mega-Tutorial, Part 4: Database (edition 2018)</a></li>
<li><a href="../346346/index.html">Flask Mega-Tutorial, Part 5: Custom Logins (Edition 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>