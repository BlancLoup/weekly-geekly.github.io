<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Syntax analysis in NLTK. Continuation</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hello. This is a small continuation of the previous article, where the basics of parsing were considered using the Natural Language Toolkit package (a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Syntax analysis in NLTK. Continuation</h1><div class="post__text post__text-html js-mediator-article">  Hello.  This is a small continuation of the previous article, where the basics of parsing were considered using the Natural Language Toolkit package (abbreviated NLTK).  As in the last article, in this one I will accompany the examples with Python code (version 2.7). <br><br><h2>  Introduction </h2><br>  In the <a href="https://habrahabr.ru/post/340574/">previous</a> article, we looked at parsers and grammar types.  I strongly recommend reading it if you have not done so.  You can also read the <a href="https://habrahabr.ru/post/340404/">first</a> article where we install and configure the NLTK package. <br><br>  Simple syntactic analyzers, which we have already considered, have a number of drawbacks, which impose significant limitations on both efficiency and the possibility of obtaining syntactic analysis results.  To solve these problems, algorithms based on dynamic programming are used. <br><a name="habracut"></a><br>  Dynamic programming involves the preservation of intermediate results and their use if necessary, which can significantly improve the efficiency of various algorithms. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Dynamic programming allows for the syntactic analysis of the sentence " <i>I shot an elephant in my pajamas</i> ", which, by the way, we have already considered, to build " <i>PP in my pajamas</i> " only once.  The result is stored in a special table <b>WFST</b> (well-formed substring table or ‚Äútable of regularities podstrochek‚Äù) and from the same table, you can take, if necessary, the components to build <i>NP</i> or <i>VP</i> . <br><br><h2>  Let's get started </h2><br><h4>  Well-Formed Substring Tables </h4><br>  Consider the sentence ‚ÄúI shot an elephant in my pajamas‚Äù as input.  This offer can be presented in the form shown in the figure.  This structure is called <i>Chart Data Structure</i> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/a7/za/8r/a7za8reaz2igwl26hmeerevytoy.png"></div><br>  In WFST, the positions of words are recorded by filling in the cells of a <a href="https://ru.wikipedia.org/wiki/%25D0%25A2%25D1%2580%25D0%25B5%25D1%2583%25D0%25B3%25D0%25BE%25D0%25BB%25D1%258C%25D0%25BD%25D0%25B0%25D1%258F_%25D0%25BC%25D0%25B0%25D1%2582%25D1%2580%25D0%25B8%25D1%2586%25D0%25B0">triangular matrix</a> , in which the initial positions of the substrings are recorded vertically, and the final positions horizontally (thus, the word <i>shot</i> will be answered by a cell with coordinates (1, 2)).  To simplify such a presentation, it is assumed that each word corresponds to only one unique lexical category (the tag of morphological characteristics) and that it is stored in the matrix cell (for example, cell (1, 2) contains <i>V</i> ). <br><br>  Tag for the word <i>shot</i> from the <i>text</i> list can be found on the basis of the grammar: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>grammar = nltk.parse_cfg(<span class="hljs-string"><span class="hljs-string">""" S -&gt; NP VP PP -&gt; P NP NP -&gt; Det N | Det N PP | 'I' VP -&gt; V NP | VP PP Det -&gt; 'an' | 'my' N -&gt; 'elephant' | 'pajamas' V -&gt; 'shot' P -&gt; 'in' """</span></span>) &gt;&gt;&gt; text = [<span class="hljs-string"><span class="hljs-string">'I'</span></span>, <span class="hljs-string"><span class="hljs-string">'shot'</span></span>, <span class="hljs-string"><span class="hljs-string">'an'</span></span>, <span class="hljs-string"><span class="hljs-string">'elephant'</span></span>, <span class="hljs-string"><span class="hljs-string">'in'</span></span>, <span class="hljs-string"><span class="hljs-string">'my'</span></span>, <span class="hljs-string"><span class="hljs-string">'pajamas'</span></span>] &gt;&gt;&gt; grammar.productions(rhs=text[<span class="hljs-number"><span class="hljs-number">1</span></span>]) [V -&gt; <span class="hljs-string"><span class="hljs-string">'shot'</span></span>]</code> </pre> <br>  To build a WFST, a matrix of dimension (n-1) on (n-1) is created.  In Python, the matrix is ‚Äã‚Äãbuilt as a list of lists.  In the following listing, we will create several methods to build, populate, and display the WFST table.  With the help of the <i>init_wfst ()</i> method, only the main diagonal is filled, where tags of all words of the sentence are present.  The <i>display ()</i> method is designed to display the results on the screen in a readable form. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init_wfst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(tokens, grammar)</span></span></span><span class="hljs-function">:</span></span> numtokens = len(tokens) wfst = [[<span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(numtokens+<span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(numtokens+<span class="hljs-number"><span class="hljs-number">1</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(numtokens): productions = grammar.productions(rhs=tokens[i]) wfst[i][i+<span class="hljs-number"><span class="hljs-number">1</span></span>] = productions[<span class="hljs-number"><span class="hljs-number">0</span></span>].lhs() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wfst <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">display</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wfst, tokens)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">'\nWFST '</span></span> + <span class="hljs-string"><span class="hljs-string">' '</span></span>.join([(<span class="hljs-string"><span class="hljs-string">"%-4d"</span></span> % i) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, len(wfst))]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(len(wfst)<span class="hljs-number"><span class="hljs-number">-1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%d "</span></span> % i, <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">1</span></span>, len(wfst)): <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"%-4s"</span></span> % (wfst[i][j] <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-string"><span class="hljs-string">'.'</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">print</span></span></code> </pre><br>  Immediately and check the work methods.  By the way, we will use the grammar described in the previous example. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>tokens = <span class="hljs-string"><span class="hljs-string">"I shot an elephant in my pajamas"</span></span>.split() &gt;&gt;&gt; wfst0 = init_wfst(tokens, grammar) &gt;&gt;&gt; display(wfst0, tokens) WFST <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> NP . . . . . . <span class="hljs-number"><span class="hljs-number">1</span></span> . V . . . . . <span class="hljs-number"><span class="hljs-number">2</span></span> . . Det . . . . <span class="hljs-number"><span class="hljs-number">3</span></span> . . . N . . . <span class="hljs-number"><span class="hljs-number">4</span></span> . . . . P . . <span class="hljs-number"><span class="hljs-number">5</span></span> . . . . . Det . <span class="hljs-number"><span class="hljs-number">6</span></span> . . . . . . N</code> </pre><br>  Now we add the <i>complete_wfst ()</i> method, which already fills the table in accordance with the specified grammar.  At the entrance it is given the initial WFST table with the main diagonal filled in, the grammar and the output flag (its work will be shown a little later). <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">complete_wfst</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(wfst, tokens, grammar, trace=False)</span></span></span><span class="hljs-function">:</span></span> index = dict((p.rhs(), p.lhs()) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> p <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> grammar.productions()) numtokens = len(tokens) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> span <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">2</span></span>, numtokens+<span class="hljs-number"><span class="hljs-number">1</span></span>): <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> start <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(numtokens+<span class="hljs-number"><span class="hljs-number">1</span></span>-span): end = start + span <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> mid <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(start+<span class="hljs-number"><span class="hljs-number">1</span></span>, end): nt1, nt2 = wfst[start][mid], wfst[mid][end] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nt1 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> nt2 <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> (nt1,nt2) <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> index: wfst[start][end] = index[(nt1,nt2)] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> trace: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"[%s] %3s [%s] %3s [%s] ==&gt; [%s] %3s [%s]"</span></span> % \ (start, nt1, mid, nt2, end, start, index[(nt1,nt2)], end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> wfst</code> </pre><br>  Check work: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>wfst1 = complete_wfst(wfst0, tokens, grammar) &gt;&gt;&gt; display(wfst1, tokens) WFST <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> NP . . S . . S <span class="hljs-number"><span class="hljs-number">1</span></span> . V . VP . . VP <span class="hljs-number"><span class="hljs-number">2</span></span> . . Det NP . . . <span class="hljs-number"><span class="hljs-number">3</span></span> . . . N . . . <span class="hljs-number"><span class="hljs-number">4</span></span> . . . . P . PP <span class="hljs-number"><span class="hljs-number">5</span></span> . . . . . Det NP <span class="hljs-number"><span class="hljs-number">6</span></span> . . . . . . N</code> </pre><br>  Let's look at the detailed output of the <i>complete_wfst</i> method: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>wfst1 = complete_wfst(wfst0, tokens, grammar, trace=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) [<span class="hljs-number"><span class="hljs-number">2</span></span>] Det [<span class="hljs-number"><span class="hljs-number">3</span></span>] N [<span class="hljs-number"><span class="hljs-number">4</span></span>] ==&gt; [<span class="hljs-number"><span class="hljs-number">2</span></span>] NP [<span class="hljs-number"><span class="hljs-number">4</span></span>] [<span class="hljs-number"><span class="hljs-number">5</span></span>] Det [<span class="hljs-number"><span class="hljs-number">6</span></span>] N [<span class="hljs-number"><span class="hljs-number">7</span></span>] ==&gt; [<span class="hljs-number"><span class="hljs-number">5</span></span>] NP [<span class="hljs-number"><span class="hljs-number">7</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>] V [<span class="hljs-number"><span class="hljs-number">2</span></span>] NP [<span class="hljs-number"><span class="hljs-number">4</span></span>] ==&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>] VP [<span class="hljs-number"><span class="hljs-number">4</span></span>] [<span class="hljs-number"><span class="hljs-number">4</span></span>] P [<span class="hljs-number"><span class="hljs-number">5</span></span>] NP [<span class="hljs-number"><span class="hljs-number">7</span></span>] ==&gt; [<span class="hljs-number"><span class="hljs-number">4</span></span>] PP [<span class="hljs-number"><span class="hljs-number">7</span></span>] [<span class="hljs-number"><span class="hljs-number">0</span></span>] NP [<span class="hljs-number"><span class="hljs-number">1</span></span>] VP [<span class="hljs-number"><span class="hljs-number">4</span></span>] ==&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>] S [<span class="hljs-number"><span class="hljs-number">4</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>] VP [<span class="hljs-number"><span class="hljs-number">4</span></span>] PP [<span class="hljs-number"><span class="hljs-number">7</span></span>] ==&gt; [<span class="hljs-number"><span class="hljs-number">1</span></span>] VP [<span class="hljs-number"><span class="hljs-number">7</span></span>] [<span class="hljs-number"><span class="hljs-number">0</span></span>] NP [<span class="hljs-number"><span class="hljs-number">1</span></span>] VP [<span class="hljs-number"><span class="hljs-number">7</span></span>] ==&gt; [<span class="hljs-number"><span class="hljs-number">0</span></span>] S [<span class="hljs-number"><span class="hljs-number">7</span></span>]</code> </pre><br>  The operation of the algorithm is completed if for the input sequence in the cell with coordinates (0, 7) S is received, indicating that a syntactic structure has been found that corresponds to the input sequence. <br><br>  By the way, the completed WFST table can be represented as Chart Data Structure: <br><br><img src="https://habrastorage.org/webt/jl/7l/ls/jl7llsdo14if4117h-m4-pmu0lq.png"><br><br>  The WFST build program is a simple chart parser that has several drawbacks: <br><br><ol><li>  The table we got is not a separate parse tree, but rather a recognition method or sentences generated (allowed) by the grammar </li><li>  The program requires that the rules of grammar, where the terminals on the right side are not binary, are binary.  Of course, any context-free grammar can be turned into such a form (Chomsky's normal form), but it is more convenient to work without such additional restrictions. </li><li>  The bottom-up approach is characterized by great redundancy when building components (it is proposed to place non-terminal symbols in cells) that are not provided for by the grammar. </li></ol><br><h4>  Dependencies and Dependencies Grammar </h4><br>  Grammar, which are based on the phrasal structure of the sentence, describing how words and their sequences are combined (combined) into components (direct components).  An alternative or complementary approach, called dependency grammar, is to establish relationships between individual words.  A binary asymmetric relationship is established between the pairs of words in the sentence, indicating the main word and the dependent one.  The main word in a sentence is usually considered a verb (predicate). <br><br>  The dependency tree is represented as a labeled oriented graph, in which the nodes are lexical units and the labeled arcs represent the relationship of dependencies between basic and and dependent words. <br><br>  The following figure shows such a graph.  The direction of the arrows indicates dependent words. <br><br><img src="https://habrastorage.org/webt/rj/uz/nw/rjuznwrmrb4ie17c4d92suhefoa.png"><br><br>  Each of the arcs in the figure is marked by the type of relationship that is established between the main and dependent words.  For example, <i>I</i> is <i>SBJ</i> (subject), <i>shot</i> (main word of the sentence), <i>in</i> - <i>NMOD</i> (noun modifier elephant).  In the grammar of dependencies, relationships between sentence members can be represented using dependency types. <br><br>  Consider building a grammar of dependencies without specifying the type of dependencies: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>grammar = nltk.parse_dependency_grammar(<span class="hljs-string"><span class="hljs-string">""" 'shot' -&gt; 'I' | 'elephant' | 'in' 'elephant' -&gt; 'an' | 'in' 'in' -&gt; 'pajamas' 'pajamas' -&gt; 'my' """</span></span>) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> groucho_dep_grammar Dependency grammar <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span> productions <span class="hljs-string"><span class="hljs-string">'shot'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'I'</span></span> <span class="hljs-string"><span class="hljs-string">'shot'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'elephant'</span></span> <span class="hljs-string"><span class="hljs-string">'shot'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'in'</span></span> <span class="hljs-string"><span class="hljs-string">'elephant'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'an'</span></span> <span class="hljs-string"><span class="hljs-string">'elephant'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'in'</span></span> <span class="hljs-string"><span class="hljs-string">'in'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'pajamas'</span></span> <span class="hljs-string"><span class="hljs-string">'pajamas'</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">'my'</span></span> &gt;&gt;&gt;</code> </pre><br>  The following example shows how an alternative approach is implemented in this grammar to take into account the ambiguity of a compound: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>pdp = nltk.ProjectiveDependencyParser(grammar) &gt;&gt;&gt; sent = <span class="hljs-string"><span class="hljs-string">'I shot an elephant in my pajamas'</span></span>.split() &gt;&gt;&gt; trees = pdp.parse(sent) &gt;&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> tree <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> trees: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> tree (shot I (elephant an (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (pajamas my)))) (shot I (elephant an) (<span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (pajamas my)))</code> </pre><br><h2>  Conclusion </h2><br>  Of course, these analyzers are somewhat more complicated than those previously considered.  But they provide new opportunities for parsing. <br><br>  Thanks for attention. <br><br><h2>  Links </h2><br><ol><li>  <a href="https://habrahabr.ru/post/340574/">NLTK parse</a> </li><li>  <a href="http://www.nltk.org/book/ch08.html">NLTK.</a>  <a href="http://www.nltk.org/book/ch08.html">Documentation</a> </li></ol></div><p>Source: <a href="https://habr.com/ru/post/342162/">https://habr.com/ru/post/342162/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../342152/index.html">Frontend distribution via CDN</a></li>
<li><a href="../342154/index.html">Simulator cars Breitenberg</a></li>
<li><a href="../342156/index.html">How self-taught programmers get jobs in reality</a></li>
<li><a href="../342158/index.html">How to legalize newsletter clients</a></li>
<li><a href="../342160/index.html">Operator << options for logger</a></li>
<li><a href="../342168/index.html">Internet: everything is very bad</a></li>
<li><a href="../342170/index.html">Java 9 overview</a></li>
<li><a href="../342172/index.html">Creating concept art in 3D</a></li>
<li><a href="../342174/index.html">How to follow trends on github</a></li>
<li><a href="../342176/index.html">Brilliance and misery of Artificial Intelligence</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>