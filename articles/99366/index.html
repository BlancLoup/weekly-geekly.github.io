<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Compilation. 3: bison</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This is the only post in the series, the center of attention of which is the old-believing sishny bison, which has become so annoying to some. Those w...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Compilation. 3: bison</h1><div class="post__text post__text-html js-mediator-article">  This is the only post in the series, the center of attention of which is the old-believing sishny bison, which has become so annoying to some.  Those who write not in C, the post should still be interesting, because generators of LR parsers, similar in their way of working, exist for very many languages.  Those who ideologically reject LR-parsers, I have nothing to attract today. <br><br><h3>  Further in the post: </h3><ol><li>  Grammar compilation </li><li>  Two-level parser </li><li>  What's inside? </li><li>  Conflicts in grammar </li><li>  How it works? </li></ol><a name="habracut"></a><br>  What have we been doing so far? <br>  Last time we <a href="http://habrahabr.ru/blogs/programming/99298/">compiled a grammar</a> for arithmetic expressions: <pre> EXPR: TERM |  EXPR '+' TERM |  EXPR '-' TERM;
 TERM: NUM |  TERM '*' NUM |  TERM '/' NUM;
 NUM: DIGIT |  NUM DIGIT;
 DIGIT: '0' |  '1' |  '2' |  '3' |  '4' |  '5' |  '6' |  '7' |  '8' |  '9' ;
</pre><br>  We ended up looking intently at the automaton that parses it. <br>  We do not know how to invent parsing machines themselves, and we don‚Äôt need to, because bison knows how to build them for us! <br>  With the help of bison, we can compile our parser, and see how it all really works. <br><br><h3>  Grammar compilation </h3><br>  The general principle is the same as with <code>flex</code> in the <a href="http://habrahabr.ru/blogs/programming/99162/">first part</a> : we list the grammar rules, and in front of each rule we write the sish code that will be executed during the rule folding. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Last time we mentioned that during the convolution we take out a set of characters (strings or variables) from the stack, look at their values, set the value for the coiled variable, and put it on the stack instead of the ones taken out. <br><br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;stdio.h&gt;</font> <br> <font color="#008000">int</font> yylex() <font color="#ff40ff">{</font> <font color="#808000">return</font> getc( <font color="#ff6060">stdin</font> ); <font color="#ff40ff">}</font> <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s) <font color="#ff40ff">{</font> <br> fprintf ( <font color="#ff6060">stderr</font> , <font color="#ff6060">"</font> <font color="#ff40ff">%s</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , s); <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">%}</font> <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">EVALUATE:</font> EXPR <font color="#ff40ff">'\n'</font> <font color="#ff40ff">{</font> printf( <font color="#ff6060">"</font> <font color="#ff40ff">%d</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , <font color="#808000">$$</font> ) <font color="#ff40ff">}</font> ; <br> <br> <font color="#7f9fbf">EXPR:</font> TERM <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'+'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> + <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'-'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> - <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">TERM:</font> NUM <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'*'</font> NUM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> * <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'/'</font> NUM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> / <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">NUM:</font> DIGIT <br> <font color="#7f9fbf">|</font> NUM DIGIT <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> * <font color="#ff6060">10</font> + <font color="#808000">$2</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">DIGIT:</font> <font color="#ff6060">'0'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">0</font> ; <font color="#ff40ff">}</font> | <font color="#ff6060">'1'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">1</font> ; <font color="#ff40ff">}</font> | <font color="#ff6060">'2'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">2</font> ; <font color="#ff40ff">}</font> | <font color="#ff6060">'3'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'4'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">4</font> ; <font color="#ff40ff">}</font> | <font color="#ff6060">'5'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">5</font> ; <font color="#ff40ff">}</font> | <font color="#ff6060">'6'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">6</font> ; <font color="#ff40ff">}</font> | <font color="#ff6060">'7'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">7</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> <font color="#ff6060">'8'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">8</font> ; <font color="#ff40ff">}</font> | <font color="#ff6060">'9'</font> <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#ff6060">9</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#808080">%%</font> <br></code> <br><h4>  Parsing code </h4> <a href=""><img src="https://habrastorage.org/getpro/habr/post_images/88f/15b/8ce/88f15b8ceb15201a4db37376c88e0db4.jpg" align="right"></a> <br>  Just like in <code>lex</code> files, the code in <b>% {%}</b> tags is copied into the parser unchanged.  There are two functions that need to be defined: <code>int yylex()</code> returns the next input character, and <code>void yyerror(char *s)</code> prints an error message.  Classic <code>yacc</code> included a ready-made implementation of <code>yyerror</code> , which could, if necessary, be redeclared;  but its <code>bison</code> GNU-clone requires an explicit implementation from the programmer. <br><br>  <b>%%</b> , as in <code>lex</code> files, divides the declaration area and the grammar rules area.  The rules are listed in the same way as we are used to;  at the end of the rule we add the convolution code.  In the convolutional code, to refer to the character values ‚Äã‚Äãon the parser stack, we use <b>$</b> -tags.  <code>$$</code> refers to a collapsible variable (the left side of the rule), <code>$1</code> to the leftmost character on the right side of the rule (the deepest in the parser stack), <code>$2</code> to the second left, and so on.  If the right side of the rule is <i>N</i> characters, then you can use values ‚Äã‚Äãfrom <code>$1</code> to <code>$N</code> <br>  If the convolution code is not specified, and the right side of the rule is one character, then by default the bison ‚Äúinherits‚Äù its value: <code>$$=$1</code> <br><br>  The very first variable declared is considered the ‚Äúroot‚Äù of the grammar, i.e.  all input text should eventually collapse into this root.  <code>EXPR</code> would be suitable as a root, but then the printing of the calculated expression would have to be put in an <code>EXPR</code> convolution;  which means that the value of each subexpression along the way would also be printed.  For the convenience of printing we will create a new variable, <code>EVALUATE</code> , which is used only as a root.  This at the same time makes it possible to read a line feed at the end of the expression - in addition to the convenience of printing, we get the convenience of input. <br><br>  When compiling a parser, you need to specify the <code>liby</code> library, which contains the standard <code>main()</code> bison. <br> <code>[tyomitch@home ~]$ <b>bison 2.y</b> <br> [tyomitch@home ~]$ <b>cc -ly 2.tab.c</b> <br> [tyomitch@home ~]$ <b>./a.out</b> <br> <b>22+3*4-5</b> <br> =29 <br> [tyomitch@home ~]$ <b>./a.out</b> <br> <b>2 + 2</b> <br> syntax error <br></code> <br>  Unlike the market calculator, which was able to ignore spaces and comments, the bison calculator understands a strictly defined syntax: numbers, operation signs, newline at the end.  To provide, for example, spaces between any pair of characters, we would have to explicitly add them to the grammar: <br> <code>EXPR: TERM | EXPR <b>WS</b> '+' <b>WS</b> TERM | EXPR <b>WS</b> '-' <b>WS</b> TERM ; <br> TERM: NUM | TERM <b>WS</b> '*' <b>WS</b> NUM | TERM <b>WS</b> '/' <b>WS</b> NUM ; <br> NUM: DIGIT | NUM DIGIT ; <br> DIGIT: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ; <br> <b>WS: | WS ' ' ;</b> <br></code> <br>  Clearly this is inconvenient.  And it is inconvenient to write for recognizing the digits of 10 different rules;  and if we needed Latin letters, for example, in variable names, we would set 52 rules ?! <br><br>  It would be great to combine the advantages of <code>flex</code> and <code>bison</code> !  It was <i>easy</i> to recognize simple expressions (numbers, spaces), and it was <i>possible</i> to recognize complex expressions. <br><br><h3>  Two-level parser </h3><br>  If we already have a <code>flex</code> parser that successfully recognizes numbers and deletes comments and spaces, then run the input text through it;  and what we succeed in, we will drive through the advanced bison parser.  In fact, there is no need to store an intermediate result: both steps can be completed in one pass.  <code>flex</code> reads the input text character by character, occasionally passing <i>tokens to the</i> bison, the terminal symbols of the grammar.  The values ‚Äã‚Äãfor tokens <code>flex</code> itself sets. <br><br>  In order for such a symbiosis to be possible, <code>flex</code> must somehow recognize the terminal characters of the bison grammar.  We will run <code>bison</code> with the <code>-d</code> key, then it will generate a <code>.h</code> file listing all terminals.  To do this, you need to declare (indicating <code>%token</code> ) the terminals in the grammar file - and all that remains is to refer to the generated <code>.h</code> file in the <code>.lex</code> file. <br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;stdio.h&gt;</font> <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s) <font color="#ff40ff">{</font> <br> fprintf ( <font color="#ff6060">stderr</font> , <font color="#ff6060">"</font> <font color="#ff40ff">%s</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , s); <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">%}</font> <br> <br> <b><font color="#808000">%token</font> NUM</b> <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">EVALUATE:</font> EXPR <font color="#ff40ff">{</font> printf( <font color="#ff6060">"=</font> <font color="#ff40ff">%d</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , <font color="#808000">$$</font> ); <font color="#ff40ff">}</font> ; <br> <br> <font color="#7f9fbf">EXPR:</font> TERM <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'+'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> + <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'-'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> - <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">TERM:</font> NUM <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'*'</font> NUM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> * <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'/'</font> NUM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> / <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#808080">%%</font> <br></code> <br>  The function <code>yylex</code> is no longer needed: now the input characters will not come from <code>stdin</code> , but from <code>flex</code> . <br>  In addition, erased <code>'\n'</code> after <code>EXPR</code> (it will be swallowed by <code>flex</code> ), and removed all the rules about <code>NUM</code> and <code>DIGIT</code> . <br><br>  Relevant <code>.lex</code> file: <br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">"3.tab.h"</font> <br> <font color="#ff40ff">%}</font> <br> <br> %option yylineno <br> %option noyywrap <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">[/][/]</font> <font color="#7f9fbf">.*\n</font> ; <font color="#8080ff">// comment</font> <br> <font color="#7f9fbf">[0-9]</font> <font color="#7f9fbf">+</font> <font color="#ff40ff">{</font> yylval = atoi(yytext); <br> <font color="#808000">return</font> NUM; <br> <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">[ \t\r\n]</font> ; <font color="#8080ff">// whitespace</font> <br> <font color="#7f9fbf">.</font> <font color="#ff40ff">{</font> <font color="#808000">return</font> * <font color="#7f9fbf">yytext</font> ; <font color="#ff40ff">}</font> <br> <br> <font color="#808080">%%</font> <br></code> <br>  The file with token definitions gets the suffix <code>.tab.h</code> <br>  The only thing in it is - <code>#define NUM 258</code> <br>  All tokens receive numbers higher than 256 to differ from "ordinary" characters. <br><br>  To transfer the token to the bison, we write its value to the global (oh, horror!) Variable <code>yylval</code> , and return the token code. <br>  We transfer ordinary characters in the usual way (we return the character code). <br><br>  The <code>noyywrap</code> option indicates that the input text is one, and after reading <code>EOF</code> do not need to try to go to the next text.  This option was set automatically while we were using <code>%option main</code> , which reads from <code>stdin</code> .  Now <code>main()</code> will be bison, so we do not need to ask <code>flex</code> standard <code>main()</code> , nor write our own. <br><br>  Compile a two-stage parser: <br> <code>[tyomitch@home ~]$ <b>lex 3.lex</b> <br> [tyomitch@home ~]$ <b>bison -d 3.y</b> <br> [tyomitch@home ~]$ <b>cc -ly lex.yy.c 3.tab.c</b> <br> [tyomitch@home ~]$ <b>./a.out</b> <br> <b>22+ // hello <br> 3*4 - 5 <br></b> =29 <br> [tyomitch@home ~]$ <b>./a.out</b> <br> <b>22+x</b> <br> syntax error <br></code> <br>  Regarding the terminology: in such a two-step model, the lower parser that recognizes tokens is traditionally called a <i>lexical analyzer</i> (‚Äúlexer‚Äù), and the upper one, recognizing constructions of tokens, is called a <i>parser</i> .  This is an indication of the role of the parser, and not its devices: other parsing systems can, for example, use shop-automatic parsers for both stages. <br><br><h3>  What's inside? </h3><br>  To see the generated automaton, you do not need to dive into the depths of the code: the bison has powerful tools for debugging grammars.  Specify the key <code>-v</code> , and look at the file with the suffix <code>.output</code> . <br>  After transferring the parsing of numbers to a lexer, there are 14 states left in the machine, and they are described like this: <br><pre> ...

 state 7

     4 EXPR: EXPR '-'.  TERM

     NUM shift, and go to state 1

     TERM go to state 11


 state 8

     6 TERM: TERM '*'.  NUM

     NUM shift, and go to state 12


 state 9

     7 TERM: TERM '/'.  NUM

     NUM shift, and go to state 13


 state 10

     3 EXPR: EXPR '+' TERM.
     6 TERM: TERM.  '*' NUM
     7 |  TERM.  '/' NUM

     '*' shift, and go to state 8
     '/' shift, and go to state 9

     $ default reduce using rule 3 (EXPR)

 ...
</pre><br>  For each state, the rules that are recognized in this state (along with their grammar numbers) are indicated, and the actions performed for each input symbol are listed.  The following state after convolution is not indicated;  instead, the automaton returns to the state read from the stack, and in it searches for the ‚Äúgo to‚Äù rule corresponding to the newly-flipped non-terminal.  Thus, the automaton transition table is two-dimensional: in each state, the <i>action</i> depends only on the input symbol, and does not depend on the contents of the stack.  (But the following state is taken from the stack after convolution.) <br><br>  In order not to crawl with a pencil on the printout of the machine, substituting into it symbol by symbol, you can ask the bison to print all transitions from state to state during parsing.  To do this, we compile the grammar with the <code>-t</code> key, and the global flag <code>yydebug</code> will appear in the parser.  It must be set to 1 - for example, in <code>main()</code> . <br>  If, in addition, we want the character values ‚Äã‚Äãto be printed, then we need to define the macro <code>YYPRINT</code> : <br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;stdio.h&gt;</font> <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s) <font color="#ff40ff">{</font> <br> fprintf ( <font color="#ff6060">stderr</font> , <font color="#ff6060">"</font> <font color="#ff40ff">%s</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , s); <br> <font color="#ff40ff">}</font> <br> <b><font color="#ff40ff">#define YYPRINT(file, type, value) fprintf(file,</font> <font color="#ff6060">"</font> <font color="#ff40ff">%d</font> <font color="#ff6060">"</font> <font color="#ff40ff">, value);</font></b> <br> <font color="#ff40ff">%}</font> <br> <br> <font color="#808000">%token</font> NUM <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">EVALUATE:</font> EXPR <font color="#ff40ff">{</font> printf( <font color="#ff6060">"=</font> <font color="#ff40ff">%d</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , <font color="#808000">$$</font> ); <font color="#ff40ff">}</font> ; <br> <br> <font color="#7f9fbf">EXPR:</font> TERM <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'+'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> + <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'-'</font> TERM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> - <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#7f9fbf">TERM:</font> NUM <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'*'</font> NUM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> * <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> TERM <font color="#ff6060">'/'</font> NUM <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> / <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#808080">%%</font> <br> <b><font color="#008000">int</font> main () <font color="#ff40ff">{</font> yydebug= <font color="#ff6060">1</font> ; <font color="#808000">return</font> yyparse(); <font color="#ff40ff">}</font></b> <br></code> <br>  The code after the second <b>%%</b> tag is copied into the parser unchanged, just as if it were in <b>% {%}</b> . <br>  Now, since we have defined <code>main()</code> ourselves, it is no longer necessary to connect <code>liby</code> when compiling: <br> <code>[tyomitch@home ~]$ <b>lex 3.lex</b> <br> [tyomitch@home ~]$ <b>bison -dt 3.y</b> <br> [tyomitch@home ~]$ <b>cc lex.yy.c 3.tab.c</b> <br> [tyomitch@home ~]$ <b>./a.out</b> <br> Starting parse <br> Entering state 0 <br> Reading a token: <b>22+3*4-5</b> <br> Next token is token NUM (22) <br> Shifting token NUM, Entering state 1 <br> Reducing stack by rule 5 (line 20), NUM -&gt; TERM <br> Stack now 0 <br> Entering state 4 <br> Reading a token: Next token is token '+' (22) <br> Reducing stack by rule 2 (line 15), TERM -&gt; EXPR <br> Stack now 0 <br> Entering state 3 <br> Next token is token '+' (22) <br> Shifting token '+', Entering state 6 <br> Reading a token: Next token is token NUM (3) <br> Shifting token NUM, Entering state 1 <br> Reducing stack by rule 5 (line 20), NUM -&gt; TERM <br> Stack now 0 3 6 <br> Entering state 10 <br> Reading a token: Next token is token '*' (3) <br> Shifting token '*', Entering state 8 <br> Reading a token: Next token is token NUM (4) <br> Shifting token NUM, Entering state 12 <br> Reducing stack by rule 6 (line 21), TERM '*' NUM -&gt; TERM <br> Stack now 0 3 6 <br> Entering state 10 <br> Reading a token: Next token is token '-' (4) <br> Reducing stack by rule 3 (line 16), EXPR '+' TERM -&gt; EXPR <br> Stack now 0 <br> Entering state 3 <br> Next token is token '-' (4) <br> Shifting token '-', Entering state 7 <br> Reading a token: Next token is token NUM (5) <br> Shifting token NUM, Entering state 1 <br> Reducing stack by rule 5 (line 20), NUM -&gt; TERM <br> Stack now 0 3 7 <br> Entering state 11 <br> Reading a token: Now at end of input. <br> Reducing stack by rule 4 (line 17), EXPR '-' TERM -&gt; EXPR <br> Stack now 0 <br> Entering state 3 <br> Now at end of input. <br> Reducing stack by rule 1 (line 13), EXPR -&gt; EVALUATE <br> =29 <br> Stack now 0 <br> Entering state 2 <br> Now at end of input. <br></code> <br>  Only states are printed from the stack;  the types of characters in the stack, and their meanings, are left to guess from the context. <br>  If the <code>YYPRINT</code> macro <code>YYPRINT</code> not specified, then it is necessary to guess the values ‚Äã‚Äãof the read tokens: the bison will print only empty brackets. <br><br><h3>  Conflicts in grammar </h3><br>  Last time, ambiguous grammars were mentioned, allowing for several expressions to be parsed. <br>  What will a bison say if we try to compile an ambiguous grammar? <br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;stdio.h&gt;</font> <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s) <font color="#ff40ff">{</font> <br> fprintf ( <font color="#ff6060">stderr</font> , <font color="#ff6060">"</font> <font color="#ff40ff">%s</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , s); <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">%}</font> <br> <br> <font color="#808000">%token</font> NUM <br> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">EVALUATE:</font> EXPR <font color="#ff40ff">{</font> printf( <font color="#ff6060">"=</font> <font color="#ff40ff">%d</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , <font color="#808000">$$</font> ) <font color="#ff40ff">}</font> ; <br> <br> <font color="#7f9fbf">EXPR:</font> NUM <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'+'</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> + <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'-'</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> - <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'*'</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> * <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'/'</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> / <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#808080">%%</font> <br> <br> [tyomitch@home ~]$ <b>bison 4.y</b> <br> 4.y: conflicts: 16 shift/reduce <br></code> <br>  When the grammar allows several continuations from one state, it is not clear to the buffalo what to perform.  In our case, it oscillates between shift and convolution.  You can correct the grammar, as we did last time;  or you can ‚Äúpush‚Äù the buffalo in the right direction, and hint what to do in the event of a conflict.  It is necessary to treat this as a quick hack: the parser starts working, but it becomes harder to debug the ‚Äúgrammar with hints‚Äù. <br><br>  Since the typical source of conflicts is arithmetic expressions, hints are given in the form of an indication of the precedence of operators (to perform multiplication before addition) and their associativity (from operators with equal priority, which they should perform before).  The lower the operator in the list, the higher the priority.  Operators in one line of the list receive the same priority. <br><br> <code><font color="#ff40ff">%{</font> <br> <font color="#ff40ff">#include</font> <font color="#ff6060">&lt;stdio.h&gt;</font> <br> <font color="#008000">void</font> yyerror( <font color="#008000">char</font> *s) <font color="#ff40ff">{</font> <br> fprintf ( <font color="#ff6060">stderr</font> , <font color="#ff6060">"</font> <font color="#ff40ff">%s</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , s); <br> <font color="#ff40ff">}</font> <br> <font color="#ff40ff">%}</font> <br> <br> <font color="#808000">%token</font> NUM <br> <br> <b><font color="#808000">%left</font> <font color="#ff6060">'+'</font> <font color="#ff6060">'-'</font> <br> <font color="#808000">%left</font> <font color="#ff6060">'*'</font> <font color="#ff6060">'/'</font> <br></b> <br> <font color="#808080">%%</font> <br> <br> <font color="#7f9fbf">EVALUATE:</font> EXPR <font color="#ff40ff">{</font> printf( <font color="#ff6060">"=</font> <font color="#ff40ff">%d</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , <font color="#808000">$$</font> ) <font color="#ff40ff">}</font> ; <br> <br> <font color="#7f9fbf">EXPR:</font> NUM <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'+'</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> + <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'-'</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> - <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'*'</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> * <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">|</font> EXPR <font color="#ff6060">'/'</font> EXPR <font color="#ff40ff">{</font> <font color="#808000">$$</font> = <font color="#808000">$1</font> / <font color="#808000">$3</font> ; <font color="#ff40ff">}</font> <br> <font color="#7f9fbf">;</font> <br> <br> <font color="#808080">%%</font> <br></code> <br>  For <code>%right</code> associative operators, there is a <code>%right</code> directive. <br>  The unnatural nature of hack with priorities can be assessed by the example of ambiguity <code>if (1) if (2) foo(); else bar();</code> <code>if (1) if (2) foo(); else bar();</code> <br>  So that it breaks up in the usual way - <code>if (1) { if (2) foo(); else bar(); }</code> <code>if (1) { if (2) foo(); else bar(); }</code>  <code>if (1) { if (2) foo(); else bar(); }</code> - it is necessary that the priority of <code>else</code> be higher than that of <code>')'</code> <br>  Both of these terminals are hard to call operators, and it is even more difficult to give them a ‚Äúnatural‚Äù priority. <br>  But it works! <br><br>  "Grammar with hints" is more compact and unambiguous in its original form (shorter than twice), and in the form of an automaton (saved one state). <br><br>  Even in the unambiguous grammar, there may be conflicts related to the principle of operation of the slot machine: during the execution of each action, he sees only one next character of input.  For example, grammar <pre> WORD: S1 'a' 'i' 'l' |  S2 'a' 'l' 'e';
 S1: 's';
 S2: 's';
</pre>  - unambiguous, and it corresponds to only two words - sail and sale.  When the parser has shifted the first letter of 's' and sees after it of 'a', it cannot make a choice, collapse <code>S1</code> or <code>S2</code> : the correct convolution depends on what letter will be after 'a';  but its machine does not yet see. <br>  This is the second reason why the parser is made in two steps: due to the fact that the lexer compresses the strings into tokens and discards unnecessary characters between tokens, the LR parser succeeds in looking ‚Äúfurther‚Äù: not one letter, but one token ahead. <br><br><h3>  How it works? </h3><br>  Like <code>flex</code> , the core of the parser is a transition table and a small loop.  Two parallel stacks are used: the <code>yyssa</code> state <code>yyssa</code> and the <code>yyvsa</code> value <code>yyvsa</code> ‚Äî all the same, the states and characters enter and leave the stack always in pairs. <br><br>  Like last time, symbols that are identical from the point of view of the parser are combined into classes.  In this case, classes 7, and they are listed in the <code>.output</code> file.  The <code>static const unsigned char yytranslate[259]</code> array <code>static const unsigned char yytranslate[259]</code> matches all terminals with a class.  (From 0 to 255 - ordinary characters; 258 - terminal <code>NUM</code> declared by us). <br><br>  Conversion tables are cleverly combined.  The main table stores descriptions of actions: for a shift (a positive number) - which state to go to;  for convolution (negative) - according to what rule to collapse. <pre> static const unsigned char yytable [] =
 {
        6, 7, 5, 8, 9, 10, 11, 1, 12, 13
 };
</pre>  It is surprising that the table is not only one-dimensional, but even the elements in it are smaller than our states (there are 14). <br>  The trick is that the index of the first action for each state is stored in a separate table: <pre> #define YYPACT_NINF -5
 static const yysigned_char yypact [] =
 {
        4, -5, 2, -4, -3, -5, 4, 4, 5, 6,
       -3, -3, -5, -5
 };
</pre>  <code>YYPACT_NINF</code> means that no <code>yytable</code> element <code>yytable</code> ;  in other words, the action performed does not depend on the input character. <br>  The default actions for each state are stored in another separate table: <pre> static const unsigned char yydefact [] =
 {
        0, 6, 0, 2, 3, 1, 0, 0, 0, 0,
        4, 5, 7, 8
 };
</pre>  Only the execution of the convolution can be independent of the input character, so the values ‚Äã‚Äãin <code>yydefact</code> are the numbers of the grammar rules by which to fold. <br><br>  By index from <code>yypact[n]</code> action is stored for state <i>n</i> and for character class 0. The action for character class <i>k</i> is stored in <code>yytable[yypact[n]+k]</code> ;  therefore, in <code>yypact</code> can be negative indices - this is just a ‚Äúbase‚Äù to which the class number will be added. <br><br>  To check to which symbol each action belongs in the <code>yytable</code> , there is another table: <pre> static const unsigned char yycheck [] =
 {
        4, 5, 0, 6, 7, 6, 7, 3, 3, 3
 };
</pre>  What do we see?  <code>yytable[0]</code> refers to class 4 characters, <code>yytable[1]</code> to class 5 characters, and so on. <br>  Let's try to find some action, for example, those listed above: <pre> ...

 state 7

     4 EXPR: EXPR '-'.  TERM

     NUM shift, and go to state 1

     TERM go to state 11


 state 8

     6 TERM: TERM '*'.  NUM

     NUM shift, and go to state 12

 ...
</pre><br>  Terminal class NUM - 3. <br>  We are looking for the first shift: <code>yytable[yypact[7]+3]==yytable[4+3]==1</code> (and indeed, <code>yycheck[yypact[7]+3]==3</code> ) <br>  Second shift: <code>yytable[yypact[8]+3]==yytable[5+3]==12</code> (and indeed, <code>yycheck[yypact[7]+3]==3</code> ) <br><br>  Similarly, the ‚Äúgo to‚Äù table is broken into three arrays, which specifies which state to go to after the convolution. <br><br>  Parser code itself: (uninteresting pieces are cut, and interesting ones are commented) <br> <code><font color="#808000">yynewstate</font> : <br> *++yyssp = yystate; <font color="#8080ff">//     </font> <br> <br> yyn = yypact[yystate]; <font color="#8080ff">//   </font> <br> <font color="#808000">if</font> (yyn == YYPACT_NINF) <br> <font color="#808000">goto</font> yydefault; <font color="#8080ff">//     </font> <br> <br> yychar = yylex(); <font color="#8080ff">//   </font> <br> yytoken = yytranslate[yychar]; <font color="#8080ff">//  </font> <br> yyn += yytoken; <font color="#8080ff">//   yytable</font> <br> <font color="#808000">if</font> (yyn &lt; <font color="#ff6060">0</font> || YYLAST &lt; yyn || yycheck[yyn] != yytoken) <br> <font color="#808000">goto</font> yydefault; <font color="#8080ff">//   </font> <br> yyn = yytable[yyn]; <br> <br> <font color="#808000">if</font> (yyn &lt;= <font color="#ff6060">0</font> ) { <br> yyn = -yyn; <br> <font color="#808000">goto</font> yyreduce; <br> } <br> <br> *++yyvsp = yylval; <font color="#8080ff">// </font> <br> yystate = yyn; <font color="#8080ff">//  </font> <br> <font color="#808000">goto</font> yynewstate; <br> <br> <font color="#808000">yydefault</font> : <br> yyn = yydefact[yystate]; <br> <font color="#808000">if</font> (yyn == <font color="#ff6060">0</font> ) <font color="#8080ff">//  :</font> <br> <font color="#808000">goto</font> yyerrlab; <font color="#8080ff">//      ,</font> <br> <font color="#8080ff">//      </font> <br> <font color="#808000">yyreduce</font> : <br> yylen = yyr2[yyn]; <font color="#8080ff">//    </font> <br> <br> yyval = yyvsp[ <font color="#ff6060">1</font> -yylen]; <font color="#8080ff">//  :  $1</font> <br> <br> <font color="#8080ff">//   :</font> <br> <font color="#8080ff">//  $-   yyval   yyvsp[] </font> <br> <br> <font color="#808000">switch</font> (yyn) { <br> <font color="#808000">case</font> <font color="#ff6060">2</font> : <br> { printf( <font color="#ff6060">"=</font> <font color="#ff40ff">%d</font> <font color="#ff40ff">\n</font> <font color="#ff6060">"</font> , yyval); } <br> <font color="#808000">break</font> ; <br> <br> <font color="#808000">case</font> <font color="#ff6060">4</font> : <br> { yyval = yyvsp[- <font color="#ff6060">2</font> ] + yyvsp[ <font color="#ff6060">0</font> ]; } <br> <font color="#808000">break</font> ; <br> <br> <font color="#808000">case</font> <font color="#ff6060">5</font> : <br> { yyval = yyvsp[- <font color="#ff6060">2</font> ] - yyvsp[ <font color="#ff6060">0</font> ]; } <br> <font color="#808000">break</font> ; <br> <br> <font color="#808000">case</font> <font color="#ff6060">7</font> : <br> { yyval = yyvsp[- <font color="#ff6060">2</font> ] * yyvsp[ <font color="#ff6060">0</font> ]; } <br> <font color="#808000">break</font> ; <br> <br> <font color="#808000">case</font> <font color="#ff6060">8</font> : <br> { yyval = yyvsp[- <font color="#ff6060">2</font> ] / yyvsp[ <font color="#ff6060">0</font> ]; } <br> <font color="#808000">break</font> ; <br> } <br> <br> yyvsp -= yylen; <font color="#8080ff">//   </font> <br> yyssp -= yylen; <br> <br> *++yyvsp = yyval; <font color="#8080ff">//   </font> <br> <br> yyn = yyr1[yyn]; <font color="#8080ff">//     </font> <br> <br> <font color="#8080ff">//     </font> <br> yystate = yypgoto[yyn - YYNTOKENS] + *yyssp; <br> <font color="#808000">if</font> ( <font color="#ff6060">0</font> &lt;= yystate &amp;&amp; yystate &lt;= YYLAST &amp;&amp; yycheck[yystate] == *yyssp) <br> yystate = yytable[yystate]; <br> <font color="#808000">else</font> <br> yystate = yydefgoto[yyn - YYNTOKENS]; <br> <br> <font color="#808000">goto</font> yynewstate; <br></code> <br>  Again, we see: the entire parser, along with the evaluation of the expression, fit into a couple of pages of code;  and even then, its third is a tricky search on compressed tables. <br><br>  Next time let's do a parsing of a <a href="http://habrahabr.ru/blogs/programming/99397/">toy programming language</a> . <br>  The dignity of a bison and others like it is that from complicating a language, only tables and a switch with convolution actions copied from a <code>.y</code> file will grow in the parser. <br>  The rest of the parser code is universal: no spaghetti, no recursive functions that call each other in tricky combinations.  The rules of grammar are really <i>compiled</i> , and not framed in the syntax of the high level language. </div><p>Source: <a href="https://habr.com/ru/post/99366/">https://habr.com/ru/post/99366/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../99361/index.html">Photos from Twitter "talked" in the hands of hackers</a></li>
<li><a href="../99362/index.html">Will the Russian market be closed for devices without a GLONASS chip?</a></li>
<li><a href="../99363/index.html">Announced Facebook C # SDK</a></li>
<li><a href="../99364/index.html">Habrafutbol-4: the beginning</a></li>
<li><a href="../99365/index.html">New version of IronRuby 1.1 released</a></li>
<li><a href="../99367/index.html">Using Intel AVX: writing the program of tomorrow</a></li>
<li><a href="../99368/index.html">On Monday, Valve released a new free (!) Game Alien Swarm</a></li>
<li><a href="../99369/index.html">Overview of the Chinese UMPC Gome FlyTouch</a></li>
<li><a href="../99371/index.html">We create PivotViewer site content in 10 minutes using the example of Habrahabr</a></li>
<li><a href="../99373/index.html">Making lines of multiple parts</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>