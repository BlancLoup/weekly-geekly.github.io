<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Myths and legends about overflowing integers in Rust</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Primitive integer types supported by processors are a limited approximation to an infinite set of integers that we used to operate in real life. This ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Myths and legends about overflowing integers in Rust</h1><div class="post__text post__text-html js-mediator-article"><p> Primitive integer types supported by processors are a limited approximation to an infinite set of integers that we used to operate in real life.  This limited representation does not always coincide with "real" numbers, for example <code>255_u8 + 1 == 0</code> .  Often, the programmer forgets about this difference, which can easily lead to bugs. <br><br>  Rust is a programming language whose purpose is to protect against bugs, it focuses on preventing the most insidious of them - memory errors, but also tries to help the programmer avoid other problems: <a href="https://habrahabr.ru/post/281370/">memory leaks</a> , <a href="https://doc.rust-lang.org/std/result/">ignoring errors,</a> and, as we will see, <a href="https://en.wikipedia.org/wiki/Integer_overflow">overflowing integers</a> . </p><a name="habracut"></a><br><br><h4>  Rust overflow </h4><br><p>  The policy of detecting and preventing overflow in Rust has changed several times on the way to the release 1.0.0, held last year.  As a result, there is a misunderstanding of how overflow is handled and what the consequences are. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Prior to version 1.0.0-alpha, the overflow was cyclical and the result was consistent with the use of the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25BE%25D0%25BF%25D0%25BE%25D0%25BB%25D0%25BD%25D0%25B8%25D1%2582%25D0%25B5%25D0%25BB%25D1%258C%25D0%25BD%25D1%258B%25D0%25B9_%25D0%25BA%25D0%25BE%25D0%25B4_(%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D1%2581%25D1%2582%25D0%25B0%25D0%25B2%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2587%25D0%25B8%25D1%2581%25D0%25BB%25D0%25B0)">add-on to two</a> (as most modern processors do).  However, this solution is not optimal: an unexpected and unnoticed overflow often leads to errors.  This is especially bad in C and C ++ due to the fact that overflow of signed integers is undefined behavior, which, together with inadequate protection against memory security violations, can easily lead to its damage.  However, in more safety-conscious languages ‚Äã‚Äãlike Rust, this still causes problems: there are many examples of overflow, they are found in video games ( <a href="http://www.gamasutra.com/blogs/MaxWoolf/20130508/191959/Diablo_III_Economy_Broken_by_an_Integer_Overflow_Bug.php">economics</a> , <a href="http://www.codeproject.com/Articles/802368/Integer-Overflow-in-Hearthstone">health indicators</a> , etc.), <a href="http://googleresearch.blogspot.com.au/2006/06/extra-extra-read-all-about-it-nearly.html">binary search</a> implementations <a href="http://googleresearch.blogspot.com.au/2006/06/extra-extra-read-all-about-it-nearly.html">,</a> and even software for <a href="http://www.nytimes.com/2015/05/01/business/faa-orders-fix-for-possible-power-loss-in-boeing-787.html%3F_r%3D1">aviation</a> .  Simply put, a code like <code>max(x - y, z)</code> occurs periodically and can give incorrect results if the numbers are unsigned and <code>x - y</code> causes overflow.  As a result, there was a desire to make Rust more secure in terms of overflowing integers. <br><br>  The current state of affairs is defined in <a href="https://github.com/rust-lang/rfcs/pull/560">RFC 560</a> : </p><br><ul><li>  In the debug build, arithmetic operations ( <code>+</code> , <code>-</code> , etc.) <strong>are checked</strong> for overflow and, if present, cause panic. </li><li>  In the release, checks for the result of overflow are absent, and the result <strong>guarantees</strong> cyclicity. </li></ul><br><p>  Overflow checks can be manually turned on or off regardless of the type of assembly, both globally and at the level of individual operations. <br>  However, you cannot influence some checks: <code> / 0</code> and <a href="http://blog.regehr.org/archives/887"><code>MIN / -1</code></a> (for signed integers) and similarly for <code>%</code> .  These calculations are indefinite behavior in C and LLVM, which is what caused rustc behavior, although it seems to me that Rust could theoretically consider <code>MIN / -1</code> as a normal overflow and return <code>MIN</code> with checks disabled. <br><br>  Hopefully, due to checks in debug mode, overflow errors in the Rust code will be detected earlier.  Moreover, if you really expect overflow, you will have to explicitly indicate this in the code, which reduces the number of false positives for both future static analyzers and for code that includes checking for overflow in all modes. <br><br></p><br><h4>  Myth: Overflow result undefined </h4><br><p>  The result of the overflow could be <em>indefinite</em> behavior, but one of the key objectives of Rust is to ensure the safety of working with memory, and such <em>uncertainty</em> (similar to indefinite behavior in C) clearly contradicts this goal.  A variable containing an undefined value is not required to maintain the same value between uses: </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// -Rust let x = undefined; let y = x; let z = x; assert_eq!(y, z); //  </span></span></code> </pre> <br><p>  This will lead to catastrophic consequences if security depends on such a value.  For example, when checking the output of the array <code>foo[x]</code> : </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = undefined; <span class="hljs-comment"><span class="hljs-comment">// let y = foo[x]; //   : let y = if x &lt; foo.len() { unsafe { *foo.get_unchecked(x) } } else { panic!("index out of bounds") };</span></span></code> </pre> <br><p>  If the value of the variable <code></code> different when comparing <code>x &lt; foo.len()</code> and with direct access to the array, then the guarantees may be violated: the comparison may be <code>0 &lt; foo.len()</code> , while accessing by index will <code>foo.get_unchecked(123456789)</code> .  Disorder! <br><br>  Thus, unlike signed integers in C, overflow in Rust cannot be undefined.  In other words, the compiler must assume that overflow can occur, unless it can prove otherwise.  This has unobvious consequences: <code>x + 1 &gt; x</code> not always true, while C compilers <em>assume</em> that this condition is always met if <code></code> is a signed integer. <br><br>  "But what about performance?"  I already have a presentiment of this question.  Indeed, undefined behavior simplifies optimizations by allowing the compiler to make assumptions.  Therefore, the rejection of such behavior can affect the speed.  Uncertainty overflow of integers is especially useful in C because such numbers are often used as inductive variables in cycles, respectively, the ability to make assumptions allows a more accurate analysis of the number of loop iterations: <code>for (int i = 0; i &lt; n; i++)</code> will be performed <code>n</code> times since it can be assumed that <code>n</code> does not contain a negative value.  Rust avoids most of these problems using positive numbers as indices ( <code>0..n</code> always gives <code>n</code> steps) and allowing lightweight iterators to directly bypass data structures, for example, <code>for x in some_array { ... }</code> .  These iterators can use knowledge about the internal structure of data structures, without forcing the user to deal with undefined behavior. <br><br>  Also Rust, unlike C, cannot reduce <code>x * 2 / 2</code> simply to <code>x</code> if <code>x</code> is a signed integer.  This optimization does not apply (unless you manually write <code>x</code> instead of a complex arithmetic expression), but in my practice these expressions are most often encountered when <code>x</code> is known at compile time, which means the whole expression will be replaced by a constant. <br><br></p><br><h4>  Myth: Overflow result is unspecified </h4><br><p>  The result of the overflow could be unspecified, in which case the compiler would have to assume that it could happen, but would have the right to return any value as a result (or not to return it at all).  Indeed, in the <a href="">first version of</a> <a href="https://github.com/rust-lang/rfcs/pull/560">RFC 560</a> for checking overflow of integers, it was proposed: </p><br><blockquote>  Change the behavior to an unspecified return or panic call, depending on whether the overflow is being checked. <br>  [...] <br><ul><li>  Theoretically, the implementation returns an unspecified value.  In practice, however, the result will be similar to cyclic overflow.  Implementations should avoid unnecessary unpredictability and unexpected behavior, so as not to provoke errors. </li><li>  And the most important: this is not indefinite behavior as understood by C. Unspecified will only be the result of the operation, and not the behavior of the entire program as a whole. As in C. The programmer cannot rely on any particular value during the overflow, but the compiler has no right to use the assumption about that no overflow occurs, for optimization. </li></ul><br></blockquote><br><p>  The RFC and and the "unspecified" result of the overflow (that is, <code>127_i8 + 1</code> can return <code>-128</code> or <code>0</code> or <code>127</code> or any other value) has been the subject of lively discussions that caused it to change. <br><br>  Thanks to the efforts of individuals, the RFC has taken on a modern look: as a result of overflow, the value will either not return at all (for example, panic will happen), or a cyclical result will be returned, corresponding to the use of the two addition.  Now the wording looks like this: </p><br><blockquote>  Operations +, -, * can lead to overflow (overflow) or the disappearance of the order (underflow).  If checks are enabled, then panic will occur.  Otherwise, the result will be a cyclic overflow. </blockquote><br><p>  A fixed overflow result is a protective measure: errors may have no effect, even if no overflow was detected.  The expression <code>x - y + z</code> calculated as <code>(x - y) + z</code> and, therefore, subtraction can lead to overflow (for example, <code>x = 0</code> and <code>y = 1</code> , both unsigned), but if <code>z</code> is large enough (in our example, <code>z &gt;= 1</code> ), the result will be similar to the use of "numbers from the real world." <br><br>  The change came closer to the end of the discussion, consisting of 160 comments, so it was easy to miss, which is why people can continue to think that the result of overflow is unspecified. <br><br></p><br><h4>  Myth: A programmer cannot control overflow handling. </h4><br><p>  One of the arguments against the introduction of overflow checking was the existence of programs and algorithms that <em>rely</em> on cyclical overflow, such as hash calculation algorithms, some data structures (for example, a ring buffer), and even codecs.  For these algorithms, using <code>+</code> in the debug mode will be incorrect: panic will occur, although this use of overflow has been conscious.  In addition, in some cases, there may be a desire to enable checks not only for the debug build. <br><br>  RFC and the standard library provide <em>four</em> sets of methods, in addition to the usual operators: </p><br><ul><li>  <a href="http://doc.rust-lang.org/std/primitive.i32.html">wrapping_add</a> , <a href="http://doc.rust-lang.org/std/primitive.i32.html">wrapping_sub</a> , ... </li><li>  <a href="http://doc.rust-lang.org/std/primitive.i32.html">saturating_add</a> , <a href="http://doc.rust-lang.org/std/primitive.i32.html">saturating_sub</a> , ... </li><li>  <a href="http://doc.rust-lang.org/std/primitive.i32.html">overflowing_add</a> , <a href="http://doc.rust-lang.org/std/primitive.i32.html">overflowing_sub</a> , .. </li><li>  <a href="http://doc.rust-lang.org/std/primitive.i32.html">checked_add</a> , <a href="http://doc.rust-lang.org/std/primitive.i32.html">checked_sub</a> , ... </li></ul><br><p>  This should cover all "special cases": </p><br><ul><li>  <code>wrapping_...</code> return the result of the addition to two. </li><li>  <code>saturating_...</code> returns the highest / lowest value when an overflow occurs. </li><li>  <code>overflowing_...</code> returns the result of the complement to two, along with a boolean value signaling the overflow that occurred. </li><li>  <code>checked_...</code> return <code>Option</code> , which takes the value <code>None</code> in case of overflow. </li></ul><br><p>  All these operations could be implemented in terms of <code>overflowing_...</code> , but the standard library tries to simplify the solution of the most frequently occurring problems. <br><br>  If you really want to use cyclic overflow, then you can write something like <code>x.wrapping_sub(y).wrapping_add(z)</code> .  This will give the expected result, and verbosity can be reduced by using the type from the standard <a href="http://doc.rust-lang.org/std/num/struct.Wrapping.html"><code>Wrapping</code></a> library. <br><br>  Perhaps this is not the final state: <a href="">potential improvements</a> are also mentioned in the RFC.  In the future, operators like cyclic <code>&amp;+</code> from Swift may be added to Rust.  This was not done immediately, as Rust tries to be conservative and, to a reasonable degree, minimalistic, and also because of the potential to turn off overflow checks (for example, a separate function may be explicitly marked and there will be no checks in its code in all modes) .  In particular, the most active (potential) users of <a href="https://github.com/rust-lang/cargo/issues/2262">Servo</a> and <a href="https://wiki.mozilla.org/Oxidation">Gecko are</a> interested in the latter. <br><br>  If you want to have overflow checks in all the code, then you have to either use <code>checked_add</code> everywhere (not very convenient!) Or explicitly enable them.  Although they by default only work in debug mode, overflow checks can be enabled by passing <code>-C debug-assertions=on</code> rustc (to the Rust compiler) or by setting the <code>debug-assertions</code> field in the <a href="http://doc.crates.io/manifest.html">cargo profile</a> .  Work is also being carried out whenever possible to enable them independently of other debug checks (at the moment rustc supports the unstable <code>-Z force-overflow-checks flag</code> option). <br><br></p><br><h4>  Myth: the selected approach to overflow checks slows down the code </h4><br><p>  Rust strives to be as fast as possible, and in designing overflow checks, performance issues were taken very seriously.  Performance is one of the main reasons why checks have been disabled for default release builds.  Of course, this means that speed was not sacrificed for the convenience of detecting errors during development. <br><br>  Unfortunately, overflow checks require more code and instructions: </p><br><pre> <code class="rust hljs">[no_mangle] <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">unchecked</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { x.wrapping_add(y) } <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checked</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { x + y }</code> </pre> <br><p>  With <code>-O -Z force-overflow-checks</code> on x86 (on 32-bit ARM LLVM currently generates redundant comparisons and register manipulations, so the performance loss is even more!) It compiles into the following (with some changes for clarity) : </p><br><pre> <code class="hljs perl">unchecked: leal (%rdi,%rsi), %eax retq checked: pushq %rax addl %esi, %edi jo .overflow_occurred movl %edi, %eax popq %rcx retq .overflow_occurred: leaq panic_loc2994(%rip), %rdi callq _ZN9panicking5panic20h4265c0105caa1121SaME@PLT</code> </pre> <br><p>  There are more instructions than there should be, provided that <code>checked</code> built in (which should be the case): in this case, working with registers with <code>pushq</code> / <code>pop</code> / <code>movl</code> not necessary.  I suppose that even without embedding, stack management via <code>pushq</code> / <code>popq</code> not required, but unfortunately, Rust is now using a version of LLVM that contains an <a href="https://llvm.org/bugs/show_bug.cgi%3Fid%3D25614">error</a> .  Of course, all these additional instructions are annoying, as is the need to use <code>add</code> instead of <code>lea</code> . </p><br><p>  On x86, using <code>lea</code> (load effective address) for arithmetic can be very useful: it allows you to perform relatively complex calculations and, as a rule, is calculated in a separate part of the CPU and its pipeline, in contrast to <code>add</code> , which contributes to higher parallelism at the instruction level.  x86 ISA allows dereferencing of the result of complex calculations with pointers: the general form is <code>A(r1, r2, B)</code> (in AT &amp; T syntax), which is equivalent to <code>r1 + B * r2 + A</code> where <code>r1</code> and <code>r2</code> are registers and <code>A</code> and <code>B</code> are constants.  As a rule, this is used directly in memory instructions such as <code>mov</code> (for example, <code>let y = array_of_u32[x];</code> can be compiled into something other than <code>mov (array_of_u32.as_ptr(), x, 4), y</code> , since each element has a size of 4), but <code>lea</code> allows you to perform arithmetic without affecting memory.  In general, the ability to use <code>lea</code> for arithmetic is quite useful.  The disadvantage is that <code>lea</code> does not integrate directly with overflow checks: it does not set the processor status flag to indicate this. </p><br><p>  However, an even greater impact on performance comes from the fact that overflow checks hinder other optimizations.  First, the checks themselves order the code (preventing things like the deployment, reordering, and vectoring of loops).  Secondly, the panic and unwinding of the stack causes the compiler to behave <a href="http://danluu.com/integer-overflow/">more conservatively</a> . <br><br>  All of these considerations explain why overflow checks are not included in the release build, where, as a rule, the highest possible performance is important. <br><br>  At the same time, even if overflow checks are included in the release mode, the performance loss can be reduced, as is the case with out-of-array checks.  On the one hand, compilers can perform range analysis and prove that individual operations never lead to overflow.  And <a href="http://blog.regehr.org/archives/1384">indeed</a> , this topic has <a href="">received</a> <a href="">much</a> <a href="">attention</a> .  On the other hand, problems caused by the use of panic can be partially resolved by <a href="">replacing panic with abnormal termination of the program</a> , if the subject area permits. <br><br>  The overflow RFC has the option of additional optimizations: ‚Äú <a href="">delayed panic</a> ‚Äù is allowed, that is, implementations can perform the sequence of operations <code>a + b + c + d</code> and panic once at the very end if any of the calculations led to overflow, instead of checking each separate operation <code>tmp = a + b</code> , then <code>tmp + c</code> , etc.  Although at the moment it is not implemented, this possibility exists. <br><br></p><br><h4>  Myth: checks do not detect errors </h4><br><p>  All efforts to develop, discuss, and implement this integer overflow handling scheme would be in vain if they did not help to detect errors in practice.  Personally, I found several problems in my code with expressions like <code>cmp::max(x - y, z)</code> (they did not hit the Internet, so there will be no links) almost immediately after writing, especially in conjunction with testing infrastructure, such as <a href="https://crates.io/crates/quickcheck">quickcheck</a> . <br><br>  Overflow checks found errors in our ecosystem, for example, such (the list is not complete!): </p><br><ul><li>  <a href="https://github.com/rust-lang/rust/pull/22532">standard library</a> </li><li>  <a href="https://github.com/rust-lang/rust/pull/31281">compiler</a> </li><li>  <a href="https://github.com/rust-lang/rust/pull/23127">embedded performance testing infrastructure</a> </li><li>  <a href="https://github.com/servo/servo/issues/6040">Servo</a> </li><li>  <a href="https://github.com/PistonDevelopers/image/pull/412">image</a> </li><li>  <a href="https://github.com/servo/rust-url/issues/124">url</a> </li><li>  <a href="https://github.com/servo/webrender/pull/243">webrender</a> </li></ul><br><p>  Outside of Rust, there are many other examples of the danger of overflow errors.  In 2011, they hit the <a href="http://cwe.mitre.org/top25/">list of the 25 most frequent CWE / SANS errors</a> .  Some languages, such as Swift, always perform overflow checks, while others, such as Python 3 and Haskell, avoid overflowing, using arbitrary precision numbers by default.  Moreover, some C compilers support options that replace undefined behavior with cyclic overflow ( <code>-fwrapv</code> ) and help detect overflow ( <code>-fsanitize=signed-integer-overflow</code> ). </p></div><p>Source: <a href="https://habr.com/ru/post/282958/">https://habr.com/ru/post/282958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../282944/index.html">About order management on the new 1C-Bitrix platform</a></li>
<li><a href="../282946/index.html">Quick transition to a new platform</a></li>
<li><a href="../282948/index.html">Component "Ordering" in the new version of the platform "1C-Bitrix" (part 1)</a></li>
<li><a href="../282950/index.html">5 worthy exploring open source projects at React Native</a></li>
<li><a href="../282954/index.html">Component "Ordering" in the new version of the platform "1C-Bitrix" (part 2)</a></li>
<li><a href="../282960/index.html">Android N: how Google "tightens the screws"</a></li>
<li><a href="../282962/index.html">Domains: Internet history</a></li>
<li><a href="../282968/index.html">Web performance: Why Performance Matters</a></li>
<li><a href="../282972/index.html">Uvloop released - advanced event loop implementation for asyncio in Python</a></li>
<li><a href="../282974/index.html">Graylog2 has become more convenient and faster.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>