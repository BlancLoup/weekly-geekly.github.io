<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Paginated data sampling - an alternative look at the long-known</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The problem of paging information from the database is as old as the database itself, and, accordingly, discussed more than one thousand times. No, pe...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Paginated data sampling - an alternative look at the long-known</h1><div class="post__text post__text-html js-mediator-article">  The problem of paging information from the database is as old as the database itself, and, accordingly, discussed more than one thousand times.  No, perhaps, not a single client-server system, in which this problem was somehow not addressed and solved.  Today I want to talk about one slightly non-standard way of interaction between the client layer and the MS SQL back-end when organizing a page-by-page sample in a typical public web application. <a name="habracut"></a><br><br>  To begin with, we outline the typical business requirements and derive the input conditions from them - we select data from a certain list (users, products, transactions) with pages of N records on each, starting with M.  Sampling is carried out with the acceptance of one or more filters and some sorting criterion.  The problems of purely client solutions such as interactive grids in javascript, in which you need to load all the data, will not be considered here, but we‚Äôll dwell on more moderate options in which page by page output is done on the server. <br><br>  How is this done traditionally?  The application layer transmits the filter values, the index of the first required record, and the required number of records per page to the backend.  In response, the database, applying filters to the entire sample, orders the entire filtered subset, and returns the entries from M to M + N-1.  How exactly this or that developer and / or this or that version of RDBMS will do this is not important for us now - it is only important that whatever method is used (temporary table in MS SQL 2000, ROW_NUMBER OVER () in 2005- 2008, or TOP / OFFSET in 2011), the need for issuing a numbered subset from a filtered <b>ordered</b> set necessarily means unwinding the entire intermediate result after the filter and sorting it.  It is also irrelevant where this unwinding will take place ‚Äî directly on the data space, or on the index field (for example, using full index coverage or INCLUDED columns) ‚Äîthis principle does not change the difference. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      It is clear that if the filtration coefficient is low and the filter is labor intensive (for example, full-text search), then the efficiency of this method will be very low, especially as it approaches the last pages of the sample.  And even if the filter is parametric (for example, by the type of user in the user table), and works on a specially created index, throwing almost 100% of the server‚Äôs efforts for each request for the last pages evokes a sincere pity for the piece of hardware on which the RDBMS itself and spinning. <br><br>  In real client-server applications, there are several other issues that complicate the situation: <br><br>  a) in order to properly render a page with pagination (I apologize for the term), the application layer must know the <b>total</b> number of records passing through the filter ‚Äî in order to divide it by N and round up (with an obvious qualification), get the number of pages needed for navigation menu.  In order to achieve this, the backend must actually either perform a search query at each page selection twice - the first time in a truncated version - simply choosing ... COUNT (1) ... WHERE, without partial sampling and sorting, and the second one - in full, with sampling the necessary set records.  Either perform COUNT at the first transition to the filtered output, and memorize this value. <br><br>  b) if during the user‚Äôs navigation through the pages, a new (or existing) entry will appear in the database, which falls under the filter condition - the navigation will go away, and the user has every chance to either skip or re-view one or more entries. <br><br>  c) generally speaking, the database is the least scalable link in public systems built on the ACID principle.  Hence the conclusion that if you once designed your system as reliably having all the data at the same time, then it is straightforward to save database resources in the first place, and everything that is possible to carry to easily scalable application servers. <br><br>  A typical algorithm of operations during page-by-page navigation looks like this in a C-like code (functions with a DB prefix are performed in the database): <br><pre><code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { create_filter(FormData, &amp;F, &amp;S); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   F     S /<span class="hljs-regexp"><span class="hljs-regexp">/      FormData DB_get_count(F, &amp;C); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/   -      while (1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,  F  S  (  ) { DB_get_records(F, N, M, S); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  N ,   M   F   S if (SORT_OR_FILTER_CHANGED == do_navigation(FormData, C, &amp;N, &amp;M, &amp;S)) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    { break; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      -   } } }</span></span></code> </pre> <br><br>  Now let's try to improve it, getting rid of re-filtering records in DB_get_records during the first viewing and each subsequent navigation.  To do this, instead of requesting a sample of the number of records matching the filter, select the entire array of their primary keys sorted in the required order.  Here it is assumed that the primary keys of records are compact (for example, int or bigint), and sampling, even with minimal filtering, gives a reasonable number of records.  If this is not the case, then in the first case it is possible to use surrogate keys (in the overwhelming majority of cases, this is done), and in the second case - to limit the sample to a reasonable number (say, 100,000), or to make a palliative solution, choosing keys in portions. <br><br>  By analogy with the pseudocode DB_get_count function, let's call it DB_get_keys <br><br>  The second step is to rewrite the data selection function from N to N + M-1 by the specified filters and sorting to a function that selects N records with keys corresponding to the key array sent to it strictly in the order in which they are in the array.  Let her be the signature <pre> <code class="hljs lisp">DB_get_records_by_keys(<span class="hljs-name"><span class="hljs-name">*K</span></span>, N)</code> </pre>  where K is the address of the array of keys from the desired point (that is, with M, and N is the number of records that must be selected by these keys. Our pseudo-algorithm will now look like this: <br><br><pre> <code class="hljs ruby"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>) { create_filter(FormData, &amp;F, &amp;S); <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>   F     S /<span class="hljs-regexp"><span class="hljs-regexp">/      FormData DB_get_keys(F, S, K); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    K   F   S while (1) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/ ,  F  S  (  ) { DB_get_records_by_keys(&amp;(K[M]), N); /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/  N ,   M if (SORT_OR_FILTER_CHANGED == do_navigation(FormData, C, &amp;N, &amp;M, &amp;S)) /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/    { break; /</span></span><span class="hljs-regexp"><span class="hljs-regexp">/      -   } } }</span></span></code> </pre><br><br>  Now we will try to give a qualitative assessment of the speed of its implementation relative to the classical one.  Let us assume that the transfer time of the selected key array from the backend is negligible compared to the search time for the necessary data (this is usually the case when transferring a small amount of them and a good network interface between the database server and the application servers).  Since the general algorithm of operation remains unchanged, we need only compare the difference between the DB_get_count ?? database functions ??  DB_get_keys and DB_get_records ??  DB_get_records_by_keys. <br><br>  Most likely, DB_get_count will work a little faster, mainly due to the fact that counting the rows selected by the filter (that is, counting the primary keys of the rows) does not require internal sorting, plus no need to issue these keys from the SQL engine to the outside.  For comparison - two execution planes: <img src="https://habrastorage.org/getpro/habr/post_images/000/a25/c1a/000a25c1a55ef7cd56fc923a9e9d57af.jpg" alt="image"><br><br>  Comparing DB_get_records and DB_get_records_by_keys, in any case, is clearly not in favor of the first method, since  selection of records by primary keys is only a small part of their search operations. <br><br>  As a result, we predict that the new method will give a gain, and the greater, the more laborious the filter and the greater the average number of page turning by the user per operation of changing the filter or sorting criterion.  Note also that changing the sorting criterion to the reverse of the same field (statistically quite frequent operation) with this method can be performed without reference to the database by simply inverting the movement of the pointer to the initial element during navigation and adding a parameter to DB_get_records_by_keys, which selects records by keys in the inverse transmitted order. <br><br>  From the point of view of the implementation of the whole idea of ‚Äã‚Äãa database, there remains only one thing - how to effectively transfer [under] an array of keys as a parameter to a state or procedure so that the resulting output preserves the order of the keys in the array? <br><br>  Splitting this task into two - transferring the array as a parameter to the database code and, in fact, maintaining order.  There are several solutions to the first task - based on XML or CSV-representation, or creating and filling in a table variable.  The SQL itself that converts an input array to a rowset can be executed as a dynamic SQL query, procedure, or table function. <br><br>  The most flexible is the version that was executed without dynamics as a table function (TF) using CTE - the so-called Common Table Expressions, which in MS SQL 2008 allow recursive queries to be built to process nested data. <br>  This CTE capability, along with the TF capability to be used as a table source in composite queries, is what we use. <br><br>  The task of preserving the sort order will be solved by adding the identity field to the structure returned by the TF table with the desired seed and increment values ‚Äã‚Äã(so that it can be sorted outside), and indicating the explicit order of inserting records into the returned table (inside).  The function ended up with this: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> [dbo].[TF_IDListToTableWithOrder] ( @ListString <span class="hljs-built_in"><span class="hljs-built_in">varchar</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>), @Delim <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> ( RowIdx <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>) PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> CLUSTERED, <span class="hljs-comment"><span class="hljs-comment">--     ID INT --     ) AS BEGIN SET @ListString = REPLACE(@ListString, ' ', '') IF LTRIM(RTRIM(ISNULL(@ListString, ''))) = '' RETURN --  ,     SET @ListString = @ListString + @Delim --   ,  CHARINDEX   &gt; 0,    ; -- CTE    WITH IDRows (ID, Pos) AS ( --   ( ) SELECT CONVERT(INT, SUBSTRING(@ListString, 1, CHARINDEX(@Delim, @ListString, 1) - 1)), CHARINDEX(@Delim, @ListString, 1) + 1 UNION ALL --   (   ,   ) SELECT CONVERT(INT, SUBSTRING(@ListString, Pos, CHARINDEX(@Delim, @ListString, Pos) - Pos)), CHARINDEX(@Delim, @ListString, Pos) + 1 FROM IDRows WHERE Pos &lt; LEN(@ListString) --    ) --   CTE    INSERT INTO @ID (ID) SELECT ID FROM IDRows ORDER BY Pos --     - ..       OPTION (MAXRECURSION 32767) --     100 (  ,    ) RETURN END</span></span></code> </pre> <br><br>  We illustrate the use of an example. <br><br>  Create a table with test data and make sure that they are quite diverse;): <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @testdata <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ID</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IDENTITY</span></span> PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> CLUSTERED, <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">128</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> @testdata <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1000</span></span> A.name + B.name <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sysobjects A <span class="hljs-keyword"><span class="hljs-keyword">CROSS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> sysobjects B <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> NEWID() <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> @testdata</code> </pre><br><br>  We simulate the selection of keys with our DB_get_keys function with reverse sorting by the required field and immediately convert it to CSV: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span> <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">MAX</span></span>) = <span class="hljs-string"><span class="hljs-string">''</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">20</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span> = @<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">CONVERT</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">ID</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> @testdata <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LIKE</span></span> <span class="hljs-string"><span class="hljs-string">'C%'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LEN</span></span>(@<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">RIGHT</span></span>(@<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">LEN</span></span>(@<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span></code> </pre><br><br>  And finally, imitate DB_get_records_by_keys: <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TD.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> @testdata TD <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> dbo.TF_IDListToTableWithOrder(@<span class="hljs-keyword"><span class="hljs-keyword">STR</span></span>, <span class="hljs-string"><span class="hljs-string">','</span></span>) LTT <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> TD.ID = LTT.ID <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> LTT.RowIdx</code> </pre><br><br>  To make it all work in conjunction with the application server, you need to save in the user context (for the web - in the session) an array of key values ‚Äã‚Äãduring navigation, which would seem to require a large amount of memory.  However, if the keys are integer, and are stored in a simple scalar array, and not in an array of objects (a fundamental difference!), Then say 100,000 keys will occupy only 400 kBytes on the application server, which by modern standards is quite a bit. <br><br>  Now about the sensitivity of the method to the added / deleted during the navigation records.  It is clear that the newly added records that fall under the filter criteria the user will not see - because  the values ‚Äã‚Äãof their keys will appear after the moment of sampling the entire list.  As for deletion, naturally, the missing record will not be returned, and the number of actually received records on the key set may be less than the requested one.  This situation can be handled on the application layer by comparing the ID of the received records with the requested ones and removing some blank of the ‚ÄúViewed record was deleted‚Äù in place of the missing ones in order not to disturb the layout due to the change in the total number.  And you can also make a LEFT JOIN result of a table function with a business table ‚Äî in this case, for remote recording, all fields will be NULL ‚Äî and this fact will be processed on the client.  In general, options are available. <br><br>  And the last.  This method was applied when upgrading an online auction system to view the lots selected by the filter (pages or one by one - back and forth) with the possibility of bidding and continuing navigation.  For such an application, the average number of navigations on a single filter is quite large, so replacing the classic pagination with this one was one of the effective measures that made it possible to noticeably ease the fate of the SQL server during peak times. </div><p>Source: <a href="https://habr.com/ru/post/189946/">https://habr.com/ru/post/189946/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../189922/index.html">NASA is going to explore the possibility of mining on asteroids</a></li>
<li><a href="../189930/index.html">Light well from a plastic bottle, water and sunlight</a></li>
<li><a href="../189932/index.html">The tale of how I would promote a website or not so scary SEO as it is painted</a></li>
<li><a href="../189940/index.html">I-gotU GT-820 Pro GPS Logger</a></li>
<li><a href="../189944/index.html">Science under lock and key. First part</a></li>
<li><a href="../189948/index.html">Scraper plate as an overclocker tool</a></li>
<li><a href="../189950/index.html">Crowdsourcing design: making the browser extension to quickly publish pictures on Habr√©</a></li>
<li><a href="../189960/index.html">HipHop VM: battle exploration for Debian 7 + Nginx + Symfony2</a></li>
<li><a href="../189962/index.html">Web panel Ajenti 1.0 at the finish line</a></li>
<li><a href="../189964/index.html">Hell with accounts - why in one company of users was 3 times more, than employees</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>