<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>How to stop debugging asynchronous code and start living</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Andrei Salomatin ( filipovskii_off ) 


 Today, every day there are new programming languages ‚Äã‚Äã- Go, Rust, CoffeeScript - whatever. I decided that I,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>How to stop debugging asynchronous code and start living</h1><div class="post__text post__text-html js-mediator-article"><h2>  Andrei Salomatin ( <a href="https://habrahabr.ru/users/filipovskii_off/" class="user_link">filipovskii_off</a> ) </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/3c5/792/17f/3c579217f44dd53f3f002800db6eec29.jpg" alt="Andrei Salomatin"><br><br>  Today, every day there are new programming languages ‚Äã‚Äã- Go, Rust, CoffeeScript - whatever.  I decided that I, too, would be ready to invent my own programming language, that the world lacks a new language ... <br><br>  Ladies and gentlemen, I present to you today Schlecht! Script - the freaky programming language.  We all need to start using it right now.  It has everything that we are used to - it has conditional operators, there are cycles, there are functions and functions of higher orders.  In general, it has everything that a normal programming language needs. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      What is not very common in it, which may even push away, at first glance, is that in Schlecht! Script functions have color. <a name="habracut"></a><br><br><img src="https://habrastorage.org/getpro/habr/post_images/218/8a9/f44/2188a9f446f005b40c0ca60f02cc8ad0.png"><br><br>  That is, when you declare a function, when you call it, you explicitly specify its color. <br><br>  Options are red and blue - two colors. <br><br>  The important point: inside the blue functions, you can only call other blue functions.  You cannot call red functions inside blue functions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2da/3f1/4f7/2da3f14f7a4fd2ca0263d83de3213a98.png"><br><br>  Inside the red functions, you can call both red and blue functions. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/de1/4bb/868/de14bb8682222237d754c2936fc7f041.png"><br><br>  I decided that it should be so.  Every language should be like this. <br><br>  Thin moment: red functions to write and cause pain!  What do I mean when I say "hurt"?  The fact is that now I am learning German, and I decided that we should all call the red functions only in German, otherwise the interpreter simply does not understand that you are trying to shove him, and he simply will not do it. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/22d/2fb/9ed/22d2fb9edd17b716a87f67a98f6214a0.png"><br><br>  This is how you should write functions in German: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bd7/3d5/28d/bd73d528d75186b66be37c841d0bf417.png"><br><br>  ‚Äú!‚Äù Is obligatory - we write in German, after all. <br><br>  How to write in such a language?  We have two ways.  We can only use blue functions, in which writing is not painful, but inside we cannot use red functions.  This approach will not work, because in a fit of inspiration I wrote half of the standard library on red functions, so, excuse me ... <br><br>  Question to you - would you use such a language?  Did I sell you Schlecht! Script? <br><br>  Well, you, however, have no choice.  Sorry‚Ä¶ <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://player.vimeo.com/video/151208421" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Javascript <br><br>  JavaScript is a great language, we all love it, we all gather here because we love JavaScript.  But the problem is that JavaScript inherits some of the features of the Schlecht! Script, and I certainly don‚Äôt want to brag, but I think they stole a couple of my ideas. <br><br>  What exactly do they inherit?  JavaScript has red and blue functions.  Red functions in JavaScript are asynchronous functions, blue - synchronous functions.  And everything is traced, the same chain ... Red functions to cause pain in Schlecht! Script, and asynchronous functions to cause pain in JavaScript. <br><br>  And inside the blue functions we cannot write red functions.  I will say more about this later. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f9/7d9/b51/5f97d9b518254247033060371a4aa63c.png"><br><br>  Why does it hurt?  Where does the pain come from when calling and writing asynchronous functions? <br><br>  We work differently conditional operators, cycles, return.  Try / catch does not work for us, and asynchronous functions break abstraction. <br><br>  About each item a little more. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9ae/1fd/d36/9ae1fdd368c4f5a4af2102b265c72444.png"><br><br>  This is how the synchronous code looks like, where shouldProcess and process are synchronous functions, and conditional operators work, works for, in general, everything is fine. <br><br>  The same, but asynchronous, will look like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fa2/294/a99/fa2294a9997aabd3eb8da5ef8ac5c0b9.png"><br><br>  A recursion appeared there, we pass the state to the parameters, to the function.  In general, looking downright unpleasant.  Try / catch does not work for us, and I think we all know that if we wrap the asynchronous block of code in try / catch, we will not catch the exception.  We will need to pass a callback, rewrite the event handler, in general, we do not have a try / catch ... <br><br>  And asynchronous functions break the abstraction.  What I mean?  Imagine that you wrote a cache.  You made a user cache in memory.  And you have a function that reads from this cache, which is naturally synchronous, because everything is in memory.  Tomorrow thousands, millions, billions of users will come to you, and you need to put this cache in Redis.  You put the cache in Redis, the function becomes asynchronous, because because of Redis, we can only read asynchronously.  And, accordingly, the entire stack, which called your synchronous function, will have to be rewritten, because now the whole stack becomes asynchronous.  If any function depended on the read function from the cache, it will now also be asynchronous. <br><br>  In general, speaking of asynchrony in JavaScript, we can say that everything is sad there. <br><br>  But what are we all about asynchrony?  Let's talk a little about me, finally. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/571/8b9/4b9/5718b94b9c13be7f9aed6e58e3b689e2.png"><br><br>  I came to save you all.  Well, I'll try to do it. <br><br>  My name is Andrey, I work in a startup ‚ÄúProductive Mobile‚Äù in Berlin.  I help with the organization of MoscowJS and I am a co-host of RadioJS.  I am very interested in the topic of asynchrony, and not only in JavaScript, I believe that, in principle, this is the defining moment of the language.  The way language works with asynchrony determines its success and how pleasant and comfortable it is for people to work with it. <br><br>  Speaking of asynchrony specifically in JavaScript, it seems to me that we have two scenarios with which we constantly interact.  This is the processing of multiple events and the processing of single asynchronous operations. <br><br>  A number of events ‚Äî for example, a DOM event or a connection to a server ‚Äî is something that emits a variety of several types of events. <br><br>  A single operation is, for example, reading from a database.  A single asynchronous operation returns either one result or returns an error.  There are no other options. <br><br>  And, speaking of these two scenarios, it is interesting to speculate: here, like, asynchrony is bad, in general, everything is sad ... And what do we really want?  What would an ideal asynchronous code look like? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/86c/635/ae6/86c635ae6c736459ae82435ce4225d23.png"><br><br>  And we want, I think, control flow of control.  We want our conditional operators, cycles, to work in synchronous code in the same way as in asynchronous. <br><br>  We want exception handling.  Why do we need try / catch if we cannot use it in asynchronous operations?  This is just weird. <br><br>  And it is desirable, of course, to have a single interface.  Why should an asynchronous function be written and called differently as compared to the synchronous function?  This should not be. <br><br>  That is what we want. <br><br>  And what do we have today, and what tools will we have in the future? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/221/f2d/e14/221f2de14ce1e75a51203151970e3cc5.png"><br><br>  If we are talking about ECMAScript 6 (this, in principle, what I'm going to talk about today), we have EventEmitter and Stream for working with many events, and Continuation Passing Style for working with single asynchronous operations (they are also callback ' and) Promises and Coroutines. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/909/895/e02/909895e02837a921318eb704eac8179e.png"><br><br>  In ECMAScript 7, we will have Async Generators for working with a variety of events and Async / Await for working with single asynchronous operations. <br><br>  About this and talk. <br><br>  Let's start with what we have in ECMAScript 6 for working with many asynchronous events.  I recall, for example, this is handling of mouse events or keystrokes.  We have an EventEmitter pattern, which is implemented in Node.js browser.  It is found in almost any API where we work with a variety of events.  The EventEmitter tells us that we can create an object that emits events, and hang handlers for each type of event. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34f/9b8/1f1/34f9b81f147c41756ce21942afda3245.png"><br><br>  The interface is very simple.  We can add EventListener, remove EventListener by event name, passing callback there. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f3e/e89/8b9/f3ee898b984c23e0a89bb3a64cd18e45.png"><br><br>  For example, in XMLHttpRequest, when I talk about a lot of events, I mean that we can have a lot of progress events.  Those.  as we load some data using an AJAX request, we fire up progress events, and once we fire up the load, abort and error events: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1b6/457/e06/1b6457e064e88520978f1f829c03eaa4.png"><br><br>  Error is a special event, a universal event in EventEmitters and Streams in order to notify the user about the error. <br><br>  There are many implementations: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eef/7d0/df3/eef7d0df31b5f18c638463176c6db549.png"><br><br>  Only a few are listed here, and at the end of the report there will be a link where all these implementations are. <br><br>  It is important to say that EventEmitter is built in by default in Node.js. <br><br>  So, this is what we have practically according to the standard in the API and browsers in Node.js. <br><br>  What else do we have to work with a variety of events?  Stream. <br><br>  Stream is a stream of data.  What is data?  This can be binary data, for example, data from a file, text data, or objects or events.  The most popular examples are: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6d4/1bc/2af/6d41bc2af575f144fd561119330219e5.png"><br><br>  There are several types of threads: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fdd/d72/4a2/fddd724a24063fa26b2c8a6c45a4043c.png"><br><br>  Here we look at the chain of conversions from the Stylus files to css files, adding an auto prefixer, because we all love Andrei Sitnik and his autoprefixer. <br><br>  You see that we have several types of streams - the source stream is gulp.src, which reads files and emits file objects, which then go to conversion streams.  The first conversion stream makes from the css stylus file, the second conversion stream adds prefixes.  And the last type of streams is a consumer stream that accepts these objects, writes something somewhere to disk, and emits nothing. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2df/f02/a76/2dff02a76d0ceb7020a4e823455ccb48.png"><br><br>  Those.  We have 3 types of streams - data source, conversion and consumer.  And these patterns can be traced everywhere, not only in the gulp, but also when observing DOM events.  We have threads that emit DOM events that transform them and something that, while consuming these DOM events, returns a specific result. <br><br>  This is what can be called a pipeline.  With the help of threads, we can build such chains, when an object is placed somewhere at the beginning of a pipeline, a chain of transformations passes, and when people come to it, they change something, add, delete, and eventually we get some car. <br><br>  There are several implementations of streams, or they are Observables: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a28/c81/d19/a28c81d197202f4b5497b8b668d08fd3.png"><br><br>  In Node.js, the embedded streams are Node Streams. <br><br>  So, we have an EventEmitter and Stream.  The default EventEmitter is in all APIs as well.  Stream is an add-on that we can use to unify the interface for handling multiple events. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/673/073/2d6/6730732d6f2e375c232d78dff09cf31a.png"><br><br>  When we talk about the criteria by which we compare asynchronous APIs, by and large, return operators and loop operators do not work for us, try / catch doesn‚Äôt work for us, of course, and we are still far from a single interface with synchronous operations . <br><br>  In general, everything is not very good for working with multiple events in ECMAScript 6. <br><br>  When we talk about single asynchronous operations, we have 3 approaches in ECMAScript 6: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a7c/bbd/2c3/a7cbbd2c38cb577a4c12a10a9c389344.png"><br><br>  Continuation Passing Style, they are also callbacks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0ae/358/fb5/0ae358fb5768b38885ff9db40c82584e.png"><br><br>  I think you are all used to it.  This is when we make an asynchronous request, pass a callback there, and the callback will be called either with an error or with a result.  This is a common approach, it is also in the browser in Node. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ca6/e16/b23/ca6e16b23df6ac778531dae274ec6f20.png"><br><br>  Problems with this approach, I think, you also understand everything. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ecd/ceb/513/ecdceb513cde73c1c2b1cf71387bbcc7.png"><br><br>  This is how we would receive a tape of user tweets asynchronously, if all functions were synchronous. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/966/a46/dd5/966a46dd58f0527047dee967c110338f.png"><br><br>  The same code, but synchronous, looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2aa/633/4fc/2aa6334fc1f9ae335d524e9b447e7135.png"><br><br>  You can increase the font to make it more visible.  And a little more increase ... And we are well aware that this is Schlecht! Script. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3e6/da2/8ec/3e6da28ecbae853f6608314023cb2d60.png"><br><br>  I said they stole my idea. <br><br>  Continuation Passing Style is the standard API in Node.js browser, we work with them all the time, but this is inconvenient.  Therefore we have Promises.  This is an object that represents an asynchronous operation. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/06e/373/93a/06e37393a308f3d2f70fd9ee9f57b14a.png"><br><br>  Promise is like a promise to do something in the future, asynchronously. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9b/8ff/2f2/c9b8ff2f2ce2613d2c712b1340ffde37.png"><br><br>  We can hang callbacks on an asynchronous operation using the then method, and this is, in principle, the main method in the API.  And we can, very importantly, check Promises, we can call then sequentially, and each function that is passed to then can also return Promises.  This is what a user's Twitter feed request for Promises looks like. <br><br>  If we compare this approach with the Continuation Passing Style, Promises, of course, it is more convenient to use - they give us the opportunity to write much less boilerplate. <br><br>  Continuation Passing Style is still used in all APIs by default, in Node.js, in io.js., and they don‚Äôt even plan to transition to Promises for several reasons.  At first, many said that the reasons are productivity.  And this is true, 2013 studies show that Promises are strongly behind callbacks.  But with the advent of such libraries as bluebird, we can already confidently say that this is not the case, because the Promises in bluebird are closer in performance to callbacks.  An important point: why don't Promises recommend using the API so far?  Because when you issue Promises from your API, you impose implementation. <br><br>  All library Promises must comply with the standard, but when issuing Promises, you also issue implementation, i.e.  if you have written your code using slow Promises, and are issuing slow Promises from the API, this will not be very pleasant for users.  Therefore, for external APIs, of course, still recommend using callbacks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/755/32a/89a/75532a89a2f64f69dc8fdedd4a8fca50.png"><br><br>  Promises implementations are a mass, and if you have not written your implementation, you are not a real JavaScript programmer.  I did not write my implementation of Promises, so I had to invent my own language. <br><br>  So, Promises are, in general, a little less than a boilerplate, but, nevertheless, still not so good. <br><br>  What about Coroutines?  Here the interesting things begin.  Imagine ... <br><br>  It is interesting.  We were at JSConf in Budapest, and there was a crazy person who programmed a quadcopter and something else in JavaScript, and half of what he tried to show us, he could not do.  Therefore, he constantly said: ‚ÄúOK, now imagine ... This quadcopter took off and everything turned out ...‚Äù. <br><br>  Imagine that we can pause a function at some point in its execution. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/069/dba/e16/069dbae163a8ab7627a933afc7356564.png"><br><br>  Here the function gets the user name, it climbs into the database, gets the user object, returns its name.  Naturally, ‚Äúclimb into the database‚Äù - the getUser function is asynchronous.  What if we could pause the getUserName function at the time getUser is called?  Here, we execute our getUserName function, get to getUser, and stop.  getUser went to the database, got the object, returned it to the function, we continue execution.  How cool would that be. <br><br>  The fact is that the Coroutines give us this opportunity.  Coroutines is a function that we can suspend and resume at any time.  Important point: we do not stop the whole program. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f1/a50/706/9f1a507067ff914ee936b173bca95f1a.png"><br><br>  This is not a blocking operation.  We stop the execution of a specific function in a particular place. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4b4/086/4b2/4b40864b27da22f263cfd0d6b8b87cab.png"><br><br>  What does getUserName look like using JavaScript generators?  We need to add ‚Äú*‚Äù to the function declaration to say that the function returns the generator.  We can use the keyword "yield" in the place where we want to pause the function.  And it is important to remember that getUser returns Promises here. <br><br>  Since  generators were originally invented in order to make lazy sequences in JavaScript, by and large, use them for synchronous code - this is a hack.  Therefore, we need libraries to somehow compensate for this. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1ba/2f5/43d/1ba2f543d9d839d54cba762f95bba59c.png"><br><br>  Here we use ‚Äúco‚Äù to wrap the generator and return the asynchronous function to us. <br><br>  Total, here's what we get: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/6e4/2fa/67a/6e42fa67a948388f052c16cc8f49ebb6.png"><br><br>  We have a function within which we can use if, for, and other operators. <br><br>  To return a value, we simply write return, just like in a synchronous function.  We can use try / catch inside, and we catch an exception. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8aa/c78/546/8aac785462b1b0d0648da7c676cce870.png"><br><br>  If Promises with getUser resolves with an error, it will be thrown as an exception. <br><br>  The getUserName function returns Promises, so we can work with it the same way as with any Promises, we can hang up a callback and using then, cheat, etc. <br><br>  But, as I said, using generators for asynchronous code is a hack.  Therefore, executing as an external API is undesirable.  But using inside the application is normal, so use it if you have the ability to translate your code. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/28d/45f/ef4/28d45fef486a925ed70d454a027f5e33.png"><br><br>  There are many implementations.  Some use generators that are already part of the standard, there are Fibers that work in Node.js and that do not use a generator, but they have their own problems. <br><br>  In general, this is the third approach for working with single asynchronous operations, and this is still a hack, but we can already use code that is close to synchronous.  We can use conditional statements, cycles, and try / catch blocks. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f98/20d/e10/f9820de1041f8164fe5074f901dec39a.png"><br><br>  Those.  ECMAScript 6 for working with single asynchronous operations brings us a little closer to the desired result, but the problem of a single interface is still not solved, even in Coroutines, because we need to write ‚Äú*‚Äù special and use the key operator ‚Äúyield‚Äù. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/749/daa/42d/749daa42dfd16ec7f869035d3984ad5c.png"><br><br>  So, in ECMAScript 6 for working with a variety of events, we have EventEmitter and Stream, for working with single asynchronous operations - CPS, Promises, Coroutines.  And all this seems to be great, but something is missing.  I want more, something brave, brave, new, I want a revolution. <br><br>  And the guys who write ES7 decided to give us a revolution and brought Async / Await and Async Generators for us. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53a/1f8/1c9/53a1f81c93e944362cf486315b0a7fca.png"><br><br>  Async / Await is a standard that allows us to work with single asynchronous operations, such as, for example, database queries. <br><br>  This is how we wrote getUserName on generators: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/937/394/24d/93739424dd4786bce5fad82c8ba34af4.png"><br><br>  And this is how the same code looks with Async / Await: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/944/ea9/496/944ea94967db91a9849ac8ce5fb0d356.png"><br><br>  Everything is very similar, by and large, this is a step away from the hack to the standard.  Here we have the keyword "async", which says that the function is asynchronous, and it will return Promise.  Inside the asynchronous function, we can use the ‚Äúawait‚Äù keyword, wherever we return Promise.  And we can wait for the execution of this Promise, we can pause the function and wait for the execution of this Promise. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1cb/b63/7fb/1cbb637fbc474e77857a872e264bafd6.png"><br><br>  And also conditional operators, cycles, and try / catch work for us, that is, asynchronous functions are legalized in ES7.  Now we explicitly say that if the function is asynchronous, then add the "async" keyword.  And this, in principle, is not so bad, but again, we do not have a single interface. <br><br>  What about a lot of events?  Here we have a standard called Async Generators. <br><br>  What is a lot of things?  How do we work with set in javascript? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d34/285/cec/d34285cec15e988a5e6f055ae1266ccf.png"><br><br>  With the set we work with the help of cycles, so let's work with a set of events with the help of cycles. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/34c/c25/a6f/34cc25a6fb7f75620b426f235439eb09.png"><br><br>  Inside the asynchronous function, we can use the key construction ‚Äúfor ... on‚Äù, which allows us to iterate over asynchronous collections.  As if. <br><br>  In this example, observe returns us something for which we can iterate, i.e.  each time the user moves the mouse, we will have a ‚Äúmousemove‚Äù event.  We fall into this cycle, and somehow handle this event.  In this case, draw the dash on the screen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/eb3/42a/a65/eb342aa6538ccf591b04881333ef20ac.png"><br><br>  Since  asynchronous function, it is important to understand that it returns Promise.  But what if we want to return a set of values, if we want, for example, to process somehow messages from a web socket, to filter them?  Those.  we get a lot and at the exit we have a lot.  Here we are assisted by asynchronous generators.  We write "async function *" and say that the function is asynchronous, and we return a set of some kind. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/31c/793/d9c/31c793d9ce6d6d50db6d2109d842c99d.png"><br><br>  In this case, we look at the Message event on the web socket, and every time it occurs, we do some kind of checking and, if the check passes, we are in the return collection.  How to add this Message. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a26/37a/83c/a2637a83c617c766d7730d5d26e5f0d9.png"><br><br>  At what, all this happens asynchronously.  Messages do not accumulate, they return as they arrive.  And here all our conditional statements, loops and try / catch work as well. <br><br>  Question: What does filterWSMessages return? <br><br><img src="https://habrastorage.org/getpro/habr/post_images/59b/a09/c45/59ba09c45503c70a66a42d70a4736c7e.png"><br><br>  This is definitely not a Promise, because this is some kind of collection, something like that ... But this is not an array. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/517/049/508/517049508a69598e42e1a25f31925402.png"><br><br>  Even more.  What do these observe return events that generate? <br><br>  And they return the so-called.  Observables objects.  This is a new word, but by and large, Observables are streams, this is Streams.  Thus, the circle closes. <br><br>  Total, we have to work with asynchronous single operations Async / Await, to work with many - Async Generators. <br><br>  Let's go and make a small retrospective of what we left and what we came to. <br><br>  To get a feed of tweets, we would write the following code in CPS: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f45/ea7/8d1/f45ea78d12f11e7a12f9ab62eb51fb8e.png"><br><br>  A lot of boilerplate, error handling, manual practically and, in general, not very pleasant. <br><br>  Using Promise, the code looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/0d7/af1/66d/0d7af166d49c1c22741b4414e629656d.png"><br><br>  The boilerplate is smaller, we can eliminate exceptions in one place, which is already good, but, nevertheless, there are these then ..., neither try / catch nor conditional operators work. <br><br>  With the help of Async / Await we get the following structure: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/412/144/8f5/4121448f537d2305c231aafd9df52385.png"><br><br>  And about the same give us the Coroutines. <br><br>  Everything is gorgeous here, except that we need to declare this function as ‚Äúasync‚Äù. <br><br>  As for the set of events, if we are talking about DOM events, we would process the mousemove like this and draw around the screen using an EventEmitter: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7a7/586/2fd/7a75862fd1b3ebb8d9267e0cdb9e94fc.png"><br><br>  The same code, but using the Streams and the Kefir library looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c71/b89/7f2/c71b897f2757b736c024813704f9a633.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">We create a stream from the mousemove events on the window, we somehow filter them, and for each value we call the callback function. </font><font style="vertical-align: inherit;">And when we call end of this stream, we automatically unsubscribe from events in the DOM, which is important </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async Generators looks like this: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/9f3/552/fda/9f3552fdac63a49ca68facb7a26673c3.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">This is just a loop, we iterate over the collection of asynchronous events and perform some operations on them. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In my opinion, this is a great way. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In conclusion, I would like to say a few words about how, in fact, to stop debugging asynchronous code and start living.</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Define your task, i.e. </font><font style="vertical-align: inherit;">if you are working with a lot of events, it makes sense to look at Streams or, perhaps, even on Async Generators, if you have a transpiler.</font></font></li><li>     , ,      AJAX-,    ,  ,  Promises. </li><li>   .     ,     Async/Await  Async Generators.    API, ,     Promise    API     callback'. </li><li>   ,    error     EventEmitter'. </li><li>      Promise.all  .. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> I know you all are interested in the fate of Schlecht! Script, when it will be posted on GitHub, etc., but the fact is that due to constant criticism, accusations of plagiarism, they say that there is already such a language, nothing new I did not invent it, I decided to close the project and devote myself to maybe something useful, important, interesting, maybe I would even write my Promises library. </font></font><br><br><h3>  Contacts </h3><br>  <a href="https://twitter.com/filipovskii">Twitter</a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">¬ª </font></font><a href="https://habrahabr.ru/users/filipovskii_off/" class="user_link"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Filipovskii_off</font></font></a> <br><br><blockquote> <font color="gray">  ‚Äî        - <a href="http://frontendconf.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">FrontendConf</a> .       2017 . <br><br>    <a href="http://frontendconf.ru/%3Futm_source%3Dhabr%26utm_medium%3Dmedia%26utm_campaign%3Dpast.articles%26utm_content%3Dcommon">Frontend Conf</a> , ,       . ,  8  , . <br><br>    HighLoad++  11    ¬´ ¬ª, : <br></font> <ul><li> <a href="http://www.highload.ru/2016/abstracts/2434.html">   NASA  JavaScript</a> /   (Liberty Global); </li><li> <a href="http://www.highload.ru/2016/abstracts/2431.html">  16 </a> /   (Beta Digital Production); </li><li> <a href="http://www.highload.ru/2016/abstracts/2295.html">  .     -</a> /   (SuperJob); </li></ul></blockquote></div><p>Source: <a href="https://habr.com/ru/post/311554/">https://habr.com/ru/post/311554/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../311542/index.html">Build your drum library for Hydrogen drum machines + projects in Ardour 4.6</a></li>
<li><a href="../311544/index.html">Product Design Digest, September 2016</a></li>
<li><a href="../311546/index.html">The digest of fresh materials from the world of the frontend for the last week ‚Ññ230 (September 26 - October 2, 2016)</a></li>
<li><a href="../311548/index.html">CompTIA certifications for IT professionals. Part 5 of 7. CompTIA CASP (Advanced Security Practitioner)</a></li>
<li><a href="../311552/index.html">The source code of the components of the Mirai IoT botnet is freely available.</a></li>
<li><a href="../311556/index.html">DDoS attacks and protection against them - how much does it cost Russian companies?</a></li>
<li><a href="../311558/index.html">AI Cradle</a></li>
<li><a href="../311560/index.html">Shared pointers and multithreading. And again about them, again</a></li>
<li><a href="../311562/index.html">Microcircuits from different sides: Nanometer ASIC, MIPSfpga and Connected MCU workshops in Russia, Ukraine and Kazakhstan</a></li>
<li><a href="../311566/index.html">Dot the ss</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>