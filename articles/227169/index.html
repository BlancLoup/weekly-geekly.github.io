<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The PVS-Studio team broadens the horizon by doing custom development</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="As you know, our main activity is the development of the PVS-Studio code analyzer. And although we have been doing this successfully for a long time a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The PVS-Studio team broadens the horizon by doing custom development</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/a7f/1bd/702/a7f1bd702f6110f556f0227f33e12a6e.png" alt="Outsourcing" align="left"><br>  As you know, our main activity is the development of the PVS-Studio code analyzer.  And although we have been doing this successfully for a long time and, as it seems to us, we recently had an unusual thought.  Still, we do not use our tools in the same way as our clients.  No, of course, we check the PVS-Studio code with the help of PVS-Studio.  But frankly, the PVS-Studio project is not that big.  And working with the PVS-Studio code is different in style and character from, for example, working with the Chromium or LLVM code. <br><br>  We wanted to be in the shoes of our clients in order to understand how our tool is used in long-term projects.  After all, checking projects that we do regularly and about which we write a lot of <a href="http://www.viva64.com/ru/a/0084/">articles</a> is just the style of using the analyzer that we actively oppose.  It is wrong to launch a one-time analyzer on a project, correct several errors and repeat it in a year.  When writing code, the analyzer should be used regularly, every day. <br><br>  Well, okay, what's all this?  Our theoretical desires to try ourselves in other projects coincided with practical proposals that gradually began to come to us.  Last year we decided to single out in our company a team that would be engaged - oh, horror!  - development to order.  That is, I participated in third-party projects as programmers.  Moreover, it was interesting for us to participate in long-term and rather large projects, i.e.  at least 2-3 developers and at least 6 months of development.  We had two goals: <ul><li>  try an alternative type of business (custom development in addition to product development); </li><li>  see for yourself how to use PVS-Studio in long-term projects. </li></ul><br>  Both the first and second tasks were successful.  But this article is not about custom development business, but about our experience.  This is not an organizational experience.  About this and so many articles.  Pro experience with the code of other projects.  About this we want to tell. <br><a name="habracut"></a><br><h2>  Seen interesting moments </h2><br>  Third-party projects teach us a lot.  I think we will dedicate more than one article to this topic.  And now we start with some interesting observations.  We noticed 3 bright features of the code, which showed themselves in large and old projects.  We are sure that over time there will be publications about other observations. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      We have quite a lot of <a href="http://www.viva64.com/ru/b/0188/">articles</a> devoted to changing the platform capacity from 32-bit to 64-bit.  A lot of errors are connected with porting, which start to manifest themselves in 64-bit programs.  We call them <a href="http://www.viva64.com/ru/t/0002/">64-bit errors</a> . <br><br>  But besides switching to 64-bit systems, there were other changes in the code that are not so noticeable.  This happened in connection with the development of compilers, libraries and the maturing of the projects themselves.  The consequences of these changes are well marked in the code, which has a long history of development.  We offer to discuss them.  I think it will be interesting and useful.  Perhaps someone will want to review their old code to identify similar problems. <br><br>  The considered error patterns were noticed by us, thanks to the PVS-Studio analyzer.  Many of these errors are hidden.  The code almost works due to lucky coincidence.  However, each such error is a small time bomb that can work at any time. <br><br>  <b>Note.</b>  To avoid NDA restrictions, we changed the names and edited the code.  Actually, this is not the code that was in the program.  However, "everything is based on real events." <br><br><h3>  Change in the behavior of the new operator </h3><br>  Long ago, the 'new' operator returned NULL in case of a memory allocation error.  Then the compilers began to support the modern C ++ standard, and throwing exceptions to std :: bad_alloc in such situations.  You can force the 'new' operator to return NULL, but this is not the case now. <br><br>  Apparently, these changes were noticed very superficially by the community of programmers.  We took note of this fact and began to write code taking into account the new behavior.  There are, of course, programmers who still do not know that the 'new' operator throws an exception.  But we are talking about normal, adequate programmers.  Individuals who do not want to know anything and continue to write in style, as they did 20 years ago, are not interested in us. <br><br>  However, even those who know that the 'new' operator has changed its behavior have not reviewed the existing code.  Someone just did not realize it.  Someone wanted, but he had no time, and then he forgot about it.  As a result, incorrect handlers of situations continue to live in a huge number of programs when memory cannot be allocated. <br><br>  Some code snippets are harmless: <br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> *x = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[N]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> MyMemoryException(); <span class="hljs-comment"><span class="hljs-comment">// 1 int *y = new int[M]; if (!y) return false; // 2</span></span></code> </pre> <br>  In the first case, instead of MyMemoryException, an exception std :: bad_alloc will be generated.  Most likely, these exceptions are handled in the same way.  No problem. <br><br>  In the second case, the check will not work.  The function will not return the value 'false'.  Instead, an exception will be thrown, which will somehow be handled later.  This is mistake.  The behavior of the program has changed.  But in practice, this almost never leads to problems.  Simply, the program will react a little differently to the lack of memory. <br><br>  It is more important to warn about cases where the behavior of the program does not change very slightly, but quite significantly.  Such situations in large old projects can be found a huge amount. <br><br>  Here are a couple of examples where certain actions must be performed when there is a shortage of memory: <br><pre> <code class="cpp hljs">image-&gt;SetBuffer(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[size]); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!image-&gt;GetBuffer()) { CloseImage(image); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>; } FormatAttribute *pAttrib = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FormatAttribute(sName, value, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pAttrib ) { m_attributes.Insert(pAttrib); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { TDocument* pDoc = m_state.GetDocument(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (pDoc) pDoc-&gt;SetErrorState(OUT_OF_MEMORY_ERROR, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); }</code> </pre> <br>  This code is much more dangerous.  For example, a user may lose the contents of his document in case of insufficient memory, although it was quite possible to give the opportunity to save the document to a file. <br><br>  <b>Recommendation.</b>  Find in your program all the 'new' statements.  Check if the program is going to take some action if the pointer is zero.  Rewrite such places. <br><br>  The PVS-Studio analyzer helps to detect meaningless checks using the <a href="http://www.viva64.com/ru/d/0293/">V668</a> diagnostics. <br><br><h3>  Replacing char * with std :: string </h3><br>  With the transition from C to C ++ and with the growing popularity of the standard library, string classes such as std :: string have become widely used in programs.  This is understandable and explainable.  It is easier and safer to work with a full line, and not with the "char *" pointer. <br><br>  The class of lines began to be used not only in the new code, but also to change some old fragments.  This is exactly what troubles may arise.  It is enough to weaken attention, and the code becomes dangerous or completely incorrect. <br><br>  But let's not start with the terrible, but rather amusing.  Sometimes there are such inefficient cycles: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-built_in"><span class="hljs-built_in">strlen</span></span>(str.c_str()); ++i)</code> </pre> <br>  Obviously, once the variable 'str' was an ordinary pointer.  It is bad to call the strlen () function at each iteration of the loop.  This is extremely inefficient on long lines.  However, after turning the pointer into std :: string, the code began to look even more stupid. <br><br>  It is immediately obvious that the replacement of types occurred thoughtlessly.  This can lead to such inefficient code or errors in general.  Let's talk about errors: <br><pre> <code class="cpp hljs">wstring databaseName; .... wprintf(<span class="hljs-string"><span class="hljs-string">"Error: cannot open database %s"</span></span>, databaseName); <span class="hljs-comment"><span class="hljs-comment">// 1 CString s; .... delete [] s; // 2</span></span></code> </pre> <br>  In the first case, the pointer 'wchar_t *' turned into 'wstring'.  The trouble will arise if you can not open the database, and you will need to print a message.  The code is compiled, but the screen will be printed abracadabra.  Or the program will fall at all.  The reason is that you forgot to add a call to the c_str () function.  Correct option: <br><pre> <code class="cpp hljs">wprintf(<span class="hljs-string"><span class="hljs-string">"Error: cannot open database %s"</span></span>, databaseName.c_str());</code> </pre> <br>  The second case is generally epic.  As it is not surprising, but such code is successfully compiled.  A very popular string class CString is used.  The CString class can be implicitly converted to a pointer.  That is what is happening here.  The result is a double buffer removal. <br><br>  <b>Recommendation.</b>  If you change pointers to a string class, do it carefully.  Do not use bulk replacement without viewing each case.  The fact that the code is compiled does not mean that it works.  It is better to leave the code using pointers alone, unless there is a clear need to edit it.  Let the code work better with pointers than incorrectly with classes. <br><br>  The PVS-Studio analyzer helps to detect some of the errors that occurred due to the replacement of pointers to classes.  The diagnostics of <a href="http://www.viva64.com/ru/d/0099/">V510</a> , <a href="http://www.viva64.com/ru/d/0104/">V515</a> , etc. can help in this.  But you should not completely rely on the analyzers.  An extremely creative code can be caught, in which not only the analyzer, but also an experienced programmer can hardly find an error. <br><br><h3>  Replacing char with wchar_t </h3><br>  The project is developing, there is a desire to make the application interface multilingual.  And at some point there is a massive replacement of char by wchar_t.  Fixed errors issued by the compiler.  "Ready" unicode version of the application. <br><br>  In practice, after such a replacement, the application turns into a sieve.  Errors that arise after such a replacement can manifest themselves for decades and are difficult to reproduce. <br><br>  How can this be?  Very simple.  Many code snippets are not ready for the character size to change.  The code is compiled without errors and without warnings.  But it works only on "50%".  Now you understand what we mean. <br><br>  <b>Note.</b>  Let me remind you that we do not intimidate the bad code received from students.  We talk about the harsh realities of programmer life.  In large and old projects, such errors inevitably appear.  And there are hundreds of them.  Seriously.  Hundreds. <br><br>  Examples: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">wchar_t</span></span> tmpBuffer[<span class="hljs-number"><span class="hljs-number">500</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(tmpBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">500</span></span>); <span class="hljs-comment"><span class="hljs-comment">// 1 TCHAR *message = new TCHAR[MAX_MSG_LENGTH]; memset(charArray, 0, MAX_MSG_LENGTH*sizeof(char)); // 2 LPCTSTR sSource = ...; LPTSTR sDestination = (LPTSTR) malloc (_tcslen(sSource) + 12); // 3 wchar_t *name = ...; fprintf(fp, "%i : %s", i, name); // 4</span></span></code> </pre> <br>  In the first case, the programmer did not think at all that the size of the symbol would change with time.  Therefore cleared only half of the buffer.  That's where my words about 50%. <br><br>  In the second case, the programmer guessed that the symbol size would change.  However, the hint "* sizeof (char)" did not help with the mass replacement of types.  It was necessary to do wrong.  The correct option is: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">memset</span></span>(charArray, <span class="hljs-number"><span class="hljs-number">0</span></span>, MAX_MSG_LENGTH * <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(charArray[<span class="hljs-number"><span class="hljs-number">0</span></span>]));</code> </pre> <br>  The third example.  Types are fine.  To calculate the length of a string, use the _tcslen () function.  At first glance, everything is fine.  However, when the characters began to have the type 'wchar_t', the program again began to work at 50%. <br><br>  Allocated 2 times less memory than necessary.  In fact, the program will work successfully until the message is longer than half the maximum possible length.  An unpleasant error that lingered in the code for a long time. <br><br>  Fourth example.  Corrected functions printf (), sprintf () and so on, but forgot to check frintf ().  As a result, garbage is written to the file.  It was necessary to do something like this: <br><pre> <code class="cpp hljs">fwprintf(fp, <span class="hljs-string"><span class="hljs-string">L"%i : %s"</span></span>, i, name);</code> </pre> <br>  Or so, if it is an ordinary ASCII file: <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span>(fp, <span class="hljs-string"><span class="hljs-string">"%i : %S"</span></span>, i, name);</code> </pre> <br>  Note.  Now I thought that I was talking about 50%, from the point of view of Windows.  In Linux, the wchar_t type occupies not 2, but 4 bytes.  So in the Linux world, the program will work only by 25% at all :). <br><br>  <b>Recommendation.</b>  If you have already replaced char with wchar_t en masse, we don‚Äôt know what can help.  This could make a lot of interesting mistakes.  Carefully review all the places where wcahr_t is used is not realistic.  In part, you will be helped by a static code analyzer.  Part of the mistakes he will reveal  The errors shown above will be found by the PVS-Studio analyzer.  The consequences of replacing char with wchar_t are quite diverse and are revealed by various diagnostics.  Enumerate them does not make sense.  As an example, you can call <a href="http://www.viva64.com/ru/d/0101/">V512</a> , <a href="http://www.viva64.com/ru/d/0176/">V576</a> , <a href="http://www.viva64.com/ru/d/0252/">V635</a> , etc. <br><br>  If you haven‚Äôt done a replacement yet, but you are planning to, then approach it seriously.  Replacing types automatically and correct compilation errors will take, for example, 2 days.  Making the same replacements manually, with viewing the code, will take an order of magnitude longer.  For example, you will spend on it 2 weeks.  But it is better than to catch all the new errors after 2 years: <ul><li>  incorrect formatting of strings; </li><li>  exceeding the bounds of allocated memory buffers; </li><li>  working with buffers cleared in half; </li><li>  work with buffers copied in half; </li><li>  and so on. </li></ul><br><h2>  Conclusion </h2><br>  We were pleased with our experience of participating in third-party custom development, so it allowed us to look at the world with different eyes.  We will continue our participation in third-party projects as developers, so if anyone is interested in chatting with us on this topic, please write.  If you are afraid that later there will be an exposing article about you (about the errors found), then anyway, <a href="http://www.viva64.com/ru/about-feedback/">write</a> - so help us all with the NDA! </div><p>Source: <a href="https://habr.com/ru/post/227169/">https://habr.com/ru/post/227169/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../227151/index.html">Screaming experience failures</a></li>
<li><a href="../227155/index.html">How we struggled with performance problems in Redmine. Who is to blame and how to help?</a></li>
<li><a href="../227159/index.html">mHealth - ‚Äúmobile‚Äù healthcare in the modern world</a></li>
<li><a href="../227161/index.html">CTOcast # 2: Ignatius Kolesnichenko (iBinom - analysis of the human genome)</a></li>
<li><a href="../227163/index.html">Symbiosis: after infection, the Trojan begins to protect the system from other malware</a></li>
<li><a href="../227171/index.html">X86 support added to Apportable SDK</a></li>
<li><a href="../227173/index.html">Smartphones and electronic inks: a difficult symbiosis</a></li>
<li><a href="../227175/index.html">Make the site work on touch devices.</a></li>
<li><a href="../227177/index.html">10 years ago, the first flight of a private spacecraft</a></li>
<li><a href="../227181/index.html">The use of sinter pastes in modern power semiconductor devices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>