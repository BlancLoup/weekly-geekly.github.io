<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>A complete guide to writing a utility for Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Some time ago I started making a utility that would simplify my life. It is called gomodifytags . The utility automatically fills the fields of struct...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>A complete guide to writing a utility for Go</h1><div class="post__text post__text-html js-mediator-article"><p><img src="https://habrastorage.org/webt/ji/t5/ik/jit5ikq3awfpuvm3-0oztkwp3z8.jpeg"></p><br><p>  Some time ago I started making a utility that would simplify my life.  It is called <strong>gomodifytags</strong> .  The utility automatically fills the fields of structural tags (struct tag) with the help of field names.  Example: </p><br><div class="spoiler">  <b class="spoiler_title">An example of using gomodifytags in vim-go</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/er/f3/vk/erf3vkcbbepu286dcplf_ffagyc.gif"></p></div></div><br><p>  This utility <strong>facilitates the management of</strong> multiple fields of the structure.  She can add and remove tags, manage their options (for example, omitempty), define transformation rules ( <em>snake_case, camelCase</em> , etc.) and much more.  How does this utility work?  What go-packages does she use?  You probably have a lot of questions. </p><br><p>  In this very long article I will talk in detail about how to write and build such a utility.  Here you will find a lot of tips and tricks, as well as Go code. </p><br><p>  Pour coffee and start reading! </p><a name="habracut"></a><br><p>  First, let's figure out what the utility should do: </p><br><ol><li>  Read the source file, understand it, convert to a Go-file. </li><li>  Find the appropriate structure. </li><li>  Get field names. </li><li>  Update structural tags with regard to field names (in accordance with the transformation rule, for example, <em>snake_case</em> ). </li><li>  And finally, make these changes to the file or give them to the programmer in a different, convenient way. </li></ol><br><p>  We begin with the <strong>definition of a structural tag</strong> , and then we will consistently build a utility, studying its parts and their interaction with each other. </p><br><p><img src="https://habrastorage.org/webt/mn/8w/gb/mn8wgbh7ey8lfxsh2bbyqbkxz3y.jpeg"></p><br><p> The <strong>value</strong> tag (for example, its contents is <code>json:"foo"</code> ) is <strong>not mentioned in the official specification</strong> .  But there is an informal specification in the package that defines this tag in a format that stdlib packages also use (like <em>encoding / json</em> ).  Made it through the type <a href="https://golang.org/pkg/reflect/">reflect.StructTag</a> : </p><br><p><img src="https://habrastorage.org/webt/wt/bb/xu/wtbbxuz7q6dnzoyysdjqhip9ytq.jpeg"></p><br><p>  Definition is not easy, let's look at it: </p><br><ul><li>  A structural tag is a string literal (because it refers to a string type). </li><li>  The key is a string literal, <strong>not enclosed in quotes</strong> . </li><li>  The value is a string literal <strong>enclosed in quotes</strong> . </li><li>  The key and value are separated by a <strong>colon (:)</strong> .  Everything is called <strong>a key-value pair</strong> . </li><li>  A structure tag can <strong>contain several key-value pairs</strong> (if desired).  Couples <strong>are separated by spaces</strong> . </li><li>  Setting options are not described in the definition.  Packages like <em>encoding / json</em> read values ‚Äã‚Äãin the form of a list, where commas are used as separators.  Everything that comes after the first comma is part of the options.  For example, the list ‚Äú <strong>foo,</strong> omitempty, string‚Äú lists the value <strong>‚Äúfoo‚Äù</strong> and the options <strong>[‚Äúomitempty‚Äù, ‚Äústring‚Äù]</strong> . </li><li>  Since the structure tag is a string literal, it must be enclosed in double quotes or back quotes (left single quotes). </li></ul><br><p>  We repeat all these rules: </p><br><p><img src="https://habrastorage.org/webt/p9/b9/_7/p9b9_7pjgalie2iw2yb-eho-s3i.jpeg"><br>  <em>There are <strong>many unclear details in the</strong> definition of structural tags.</em> </p><br><p>  Now we know what the structure tag is, and we can easily change it as we need it.  The question is, how can you now parse it so that it is easy to change?  Fortunately, <strong>reflect.StructTag</strong> also has a <strong>method</strong> that allows you to parse the tag and return values ‚Äã‚Äãfor the specified key.  Example: </p><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">package</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">import</span></span> ( "<span class="hljs-selector-tag"><span class="hljs-selector-tag">fmt</span></span>" "<span class="hljs-selector-tag"><span class="hljs-selector-tag">reflect</span></span>" ) <span class="hljs-selector-tag"><span class="hljs-selector-tag">func</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">main</span></span>() { <span class="hljs-attribute"><span class="hljs-attribute">tag </span></span>:= reflect.<span class="hljs-built_in"><span class="hljs-built_in">StructTag</span></span>(`species:<span class="hljs-string"><span class="hljs-string">"gopher"</span></span> color:<span class="hljs-string"><span class="hljs-string">"blue"</span></span>`) fmt.<span class="hljs-built_in"><span class="hljs-built_in">Println</span></span>(tag.Get(<span class="hljs-string"><span class="hljs-string">"color"</span></span>), tag.<span class="hljs-built_in"><span class="hljs-built_in">Get</span></span>(<span class="hljs-string"><span class="hljs-string">"species"</span></span>)) }</code> </pre> <br><p>  Displays: </p><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">blue</span></span> gopher</code> </pre> <br><p>  If the key does not exist, an empty string is returned. </p><br><p>  Very useful, <strong>but</strong> there are limitations that make this opportunity useless for us, because we need a more flexible solution.  List of restrictions: </p><br><ul><li>  Does not recognize <strong>errors</strong> in the tag (for example, key in quotes, value without quotes, etc.). </li><li>  Does not recognize the <strong>semantics of</strong> options. </li><li>  Can not <strong>pass on existing tags</strong> or return them.  You need to know in advance which tags we want to change.  And if the name is unknown? </li><li>  Cannot modify existing tags. </li><li>  You cannot <strong>build new structural tags</strong> from scratch. </li></ul><br><p>  I wrote my Go package that fixes all the listed flaws and provides an API that makes it easy to change any parts of the structure tag. </p><br><p><img src="https://habrastorage.org/webt/ii/oh/pf/iiohpfa22wha9_yk-lhaqaxviu0.jpeg"></p><br><p>  The package is called <strong>structtag</strong> , you can download it from here: <a href="https://github.com/fatih/structtag">github.com/fatih/structtag</a> .  A package can accurately <strong>parse and modify tags</strong> .  Below is a fully working example, you can copy it and test it: </p><br><pre> <code class="hljs pgsql">package main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( "fmt" "github.com/fatih/structtag" ) func main() { tag := `<span class="hljs-type"><span class="hljs-type">json</span></span>:"foo,omitempty,string" <span class="hljs-type"><span class="hljs-type">xml</span></span>:"foo"` // parse the tag tags, err := structtag.Parse(string(tag)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { panic(err) } // iterate <span class="hljs-keyword"><span class="hljs-keyword">over</span></span> <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> tags <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, t := range tags.Tags() { fmt.Printf("tag: %+v\n", t) } // <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> a single tag jsonTag, err := tags.<span class="hljs-keyword"><span class="hljs-keyword">Get</span></span>("json") <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { panic(err) } // change existing tag jsonTag.Name = "foo_bar" jsonTag.<span class="hljs-keyword"><span class="hljs-keyword">Options</span></span> = nil tags.<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>(jsonTag) // <span class="hljs-keyword"><span class="hljs-keyword">add</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> tag tags.<span class="hljs-keyword"><span class="hljs-keyword">Set</span></span>(&amp;structtag.Tag{ Key: "hcl", <span class="hljs-type"><span class="hljs-type">Name</span></span>: "foo", <span class="hljs-keyword"><span class="hljs-keyword">Options</span></span>: []string{"squash"}, }) // print the tags fmt.Println(tags) // Output: <span class="hljs-type"><span class="hljs-type">json</span></span>:"foo_bar" <span class="hljs-type"><span class="hljs-type">xml</span></span>:"foo" hcl:"foo,squash" }</code> </pre> <br><p>  Now we can parse the structure tag, modify it and create a new one.  Now you need to change the correct source Go file.  In the above example, the tag is already there, but how do we get it from the existing Go-structure? </p><br><p>  Answer: via <strong>AST</strong> .  AST ( <em>Abstract Syntax Tree, abstract syntax tree</em> ) allows you to extract any identifier (node) from the source code.  Below is a simplified tree of structural type: </p><br><p><img src="https://habrastorage.org/webt/el/c0/p2/elc0p2844y8zw8__v-ogxe5dhgk.jpeg"><br>  <em>Basic view of the go <strong>ast.Node</strong> structural type</em> </p><br><p>  In this tree, you can extract any identifier and manipulate it with a string, a bracket, etc. Each of them is represented by an <a href="https://golang.org/pkg/go/ast/">AST node</a> .  For example, you can change the field name from <strong>‚ÄúFoo‚Äù</strong> to <strong>‚ÄúBar‚Äù</strong> , replacing the node representing it.  The same with the structural tag. </p><br><p>  To get <strong>Go AST</strong> , you need to parse the source file and convert it to AST.  All this is done in one step. </p><br><p>  To <strong>parse the</strong> file, we will use the <a href="https://golang.org/pkg/go/parser">go / parser</a> package (to build the entire file tree), and then use the <a href="https://golang.org/pkg/go/ast">go / ast</a> package to <a href="https://golang.org/pkg/go/ast">go</a> through the tree (manually, but this is a topic for a separate article).  Here is a fully working example: </p><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"go/ast"</span></span> <span class="hljs-string"><span class="hljs-string">"go/parser"</span></span> <span class="hljs-string"><span class="hljs-string">"go/token"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { src := <span class="hljs-string"><span class="hljs-string">`package main type Example struct { Foo string`</span></span> + <span class="hljs-string"><span class="hljs-string">" `json:\"foo\"` }"</span></span> fset := token.NewFileSet() file, err := parser.ParseFile(fset, <span class="hljs-string"><span class="hljs-string">"demo"</span></span>, src, parser.ParseComments) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>(err) } ast.Inspect(file, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { s, ok := x.(*ast.StructType) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, field := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> s.Fields.List { fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Field: %s\n"</span></span>, field.Names[<span class="hljs-number"><span class="hljs-number">0</span></span>].Name) fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Tag: %s\n"</span></span>, field.Tag.Value) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> }) }</code> </pre> <br><p>  Result of performance: </p><br><pre> <code class="hljs pgsql">Field: Foo Tag: `<span class="hljs-type"><span class="hljs-type">json</span></span>:"foo"`</code> </pre> <br><p>  What are we doing: </p><br><ul><li>  Using a single structure, we define an example of a valid Go package. </li><li>  Use the <strong>go / parser</strong> package to parse this line.  The package can also read a file (or the entire package) from disk. </li><li>  After parsing the file, go to our node (assigned to the file variable) and look for the AST node defined by <a href="https://golang.org/pkg/go/ast/">* ast.StructType</a> (see the AST scheme).  Using the <code>ast.Inspect()</code> function, <code>ast.Inspect()</code> go down the tree.  The function iterates over all nodes until it finds the wrong value.  It turns out very convenient, because we do not need to memorize nodes. </li><li>  Display the structure field name and structure tag. </li></ul><br><p>  Now we can solve <strong>two important tasks</strong> .  First, we know <strong>how to parse the source Go file</strong> and extract the structure tag (using go / parser).  Secondly, we can <strong>parse the structure tag</strong> and modify it the way we need (using <a href="https://github.com/fatih/structtag">github.com/fatih/structtag</a> ). </p><br><p>  Now you can start <strong>building</strong> our utility <strong>(gomodifytags)</strong> using these two skills.  She must: </p><br><ol><li>  Get a configuration that indicates which structure needs to be changed. </li><li>  Find and modify this structure. </li><li>  Display the result. </li></ol><br><p>  Since <strong>gomodifytags</strong> will most often be executed by editors, we will transmit the configuration via CLI flags.  The second stage consists of several steps, such as parsing a file, finding the correct structure and modifying it (through AST).  Finally, we will output the result either to the original Go-file, or through some protocol (like JSON, we'll talk about it below). </p><br><p>  Simplified gomodifytags main function: </p><br><p><img src="https://habrastorage.org/webt/ok/ik/uo/okikuojyor2h9v2yg-t-vntxf90.jpeg"></p><br><p>  Let's take a closer look at each step.  I will try to tell simpler.  Although everything is the same here, and having finished reading, you will be able to deal with the source code without any help (links to the sources are given at the end of the manual). </p><br><p>  Let's start with <strong>getting the configuration</strong> .  Below is a configuration that has all the necessary information. </p><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> struct { // first section - <span class="hljs-built_in"><span class="hljs-built_in">input</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> file <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> modified <span class="hljs-built_in"><span class="hljs-built_in">io</span></span>.Reader <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">write</span></span> bool // second section - struct selection offset int structName <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> line <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> start, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> int // third section - struct modification <span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> []<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> add []<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> override bool transform <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> <span class="hljs-built_in"><span class="hljs-built_in">sort</span></span> bool clear bool addOpts []<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> removeOpts []<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> clearOpt bool }</code> </pre> <br><p>  The configuration consists of <strong>three</strong> sections. </p><br><p>  The <strong>first</strong> contains settings that describe how and what file to read.  This can be done through the file name from the local file system or directly from stdin (usually used when working in editors).  Also in the first section it is indicated how to output the results (to the source Go file or JSON) and whether the file should be rewritten instead of output to stdout. </p><br><p>  The second section shows how to choose a structure and its fields.  This can be done in different ways: using an offset (cursor position), a structure name, a single line (which simply selects a field), or a range of lines.  At the end, you must extract the starting and ending lines.  The following shows how we select a structure by its name, and then retrieve the starting and ending rows to select the correct fields: </p><br><p><img src="https://habrastorage.org/webt/gk/up/gy/gkupgypkr8qmnkrimydx8tznkzq.jpeg"></p><br><p>  At the same time, it is more convenient for editors to use a <strong>byte offset</strong> .  In the illustration below, the cursor stands immediately after the name of the field <code>"Port"</code> , where you can easily get the starting and ending lines: </p><br><p><img src="https://habrastorage.org/webt/zx/nl/e1/zxnle1rp08ikteavw7yohlpj3oe.jpeg"></p><br><p>  The third section of the configuration is dedicated to transferring data to our <code>structtag</code> package.  After reading all the fields, the configuration is transferred to the package <code>structtag</code> , which allows you to parse the structure tag and change its parts.  However, the structure fields are not overwritten and not updated. </p><br><p>  And how do we get the configuration?  Take the <code>flag</code> package, create flags for each field in the configuration, and link them to them.  For example: </p><br><pre> <code class="hljs go">flagFile := flag.String(<span class="hljs-string"><span class="hljs-string">"file"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Filename to be parsed"</span></span>) cfg := &amp;config{ file: *flagFile, }</code> </pre> <br><p>  Do the same <strong>for each field in the configuration</strong> .  A complete list of <a href="">flag definitions</a> can be found in the current gomodifytag wizard. </p><br><p>  After getting the configuration, let's perform a basic check: </p><br><pre> <code class="hljs lua">func main() { cfg := <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>{ ... } err := cfg.validate() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">log</span></span>.Fatalln(err) } // continue parsing } // validate validates whether the <span class="hljs-built_in"><span class="hljs-built_in">config</span></span> is valid <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> func (c *<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>) validate() <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.file == <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"no file is passed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.line == <span class="hljs-string"><span class="hljs-string">""</span></span> &amp;&amp; c.offset == <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; c.structName == <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"-line, -offset or -struct is not passed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.line != <span class="hljs-string"><span class="hljs-string">""</span></span> &amp;&amp; c.offset != <span class="hljs-number"><span class="hljs-number">0</span></span> || c.line != <span class="hljs-string"><span class="hljs-string">""</span></span> &amp;&amp; c.structName != <span class="hljs-string"><span class="hljs-string">""</span></span> || c.offset != <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; c.structName != <span class="hljs-string"><span class="hljs-string">""</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"-line, -offset or -struct cannot be used together. pick one"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (c.add == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(c.add) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (c.addOptions == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(c.addOptions) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; !c.clear &amp;&amp; !c.clearOption &amp;&amp; (c.removeOptions == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(c.removeOptions) == <span class="hljs-number"><span class="hljs-number">0</span></span>) &amp;&amp; (c.<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span> == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(c.<span class="hljs-built_in"><span class="hljs-built_in">remove</span></span>) == <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errors.New(<span class="hljs-string"><span class="hljs-string">"one of "</span></span> + <span class="hljs-string"><span class="hljs-string">"[-add-tags, -add-options, -remove-tags, -remove-options, -clear-tags, -clear-options]"</span></span> + <span class="hljs-string"><span class="hljs-string">" should be defined"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  If the check is performed in one function, then it is easier to test it. </p><br><p>  Let's go to the file parsing: </p><br><p><img src="https://habrastorage.org/webt/wn/i4/az/wni4az9a9nzypinyyqnylo6wehw.jpeg"></p><br><p>  In the beginning we already talked about how to parse the file.  In this case, the <strong>method</strong> in the <code>config</code> structure deals with parsing.  In fact, all methods are part of this structure: </p><br><pre> <code class="hljs lua">func main() { cfg := <span class="hljs-built_in"><span class="hljs-built_in">config</span></span>{} node, err := cfg.parse() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } // continue <span class="hljs-built_in"><span class="hljs-built_in">find</span></span> struct selection ... } func (c *<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>) parse() (ast.Node, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) { c.fset = token.NewFileSet() var contents interface{} <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.modified != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { archive, err := buildutil.ParseOverlayArchive(c.modified) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"failed to parse -modified archive: %v"</span></span>, err) } fc, ok := archive[c.file] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"couldn't find %s in archive"</span></span>, c.file) } contents = fc } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser.ParseFile(c.fset, c.file, contents, parser.ParseComments) }</code> </pre> <br><p>  The <code>parse</code> function can only <code>parse</code> source code and return <code>ast.Node</code> .  It's very simple, if we transfer the file, in our case the <code>parser.ParseFile()</code> function is used.  Notice the <code>token.NewFileSet()</code> , which creates the type <code>*token.FileSet</code> .  We store it in <code>c.fset</code> , but also pass it to the <code>parser.ParseFile()</code> function.  Why? </p><br><p>  Because the <strong>fileset is</strong> used to store information about the location of each node <strong>independently</strong> for each file.  Later it will be very useful to get the exact location of <code>ast.Node</code> .  <em>(Note that ast.Node uses compact location information called</em> <code>token.Pos</code> . <em>If you decrypt</em> <code>token.Pos</code> <em>with the</em> <code>token.FileSet.Position()</code> <em>function</em> , <em>you get</em> <code>token.Position</code> , <em>which contains more information.)</em> </p><br><p>  Go ahead.  The situation becomes more interesting if you transfer the source file through stdin.  The <code>config.modified</code> field is an <strong>io.Reader</strong> for easy testing, but in fact we pass stdin.  And how to determine what we want to read from stdin? </p><br><p>  We ask the user if he <strong>wants</strong> to transfer content via stdin.  In this case, the user needs to pass the <code>--modified</code> flag (this is a <strong>boolean</strong> flag).  If it passes, then we simply attach stdin to <code>c.modified</code> : </p><br><pre> <code class="hljs pgsql">flagModified = flag.Bool("modified", <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, "read an archive of modified files from standard input") <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *flagModified { cfg.modified = os.Stdin }</code> </pre> <br><p>  If you look again at the <code>config.parse()</code> function, you will see that it checks the attachment of the <code>.modified</code> field.  Stdin is an arbitrary data stream that needs to be parsed according to the selected protocol.  In our case, we assume that the archive contains: </p><br><ul><li>  File name, then a new line. </li><li>  File size in decimal, then a new line. </li><li>  File contents. </li></ul><br><p>  Once we know the size of the file, we can safely parse the contents.  If something turns out to be larger, then we simply stop parsing. </p><br><p>  This approach is used in several other utilities (for example, <strong>guru</strong> , <strong>gogetdoc</strong> , etc.), it is very convenient for editors, because they can transfer the contents of modified files <strong>without saving to the file system</strong> .  Therefore, the "modified". </p><br><p>  So, we have a node, let's look for a structure: </p><br><p><img src="https://habrastorage.org/webt/mt/0_/dc/mt0_dcjzf-bkqyi8bfguoxlvqpa.jpeg"></p><br><p>  In the main function, we are going to call the <code>findSelection()</code> function with ast.Node, which we parsed in the previous step: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... parse file and get ast.Node start, end, err := cfg.findSelection(node) if err != nil { return err } // continue rewriting the node with the start&amp;end position }</span></span></code> </pre> <br><p>  The <code>cfg.findSelection()</code> function, based on the configuration, returns the starting and ending positions of the structure, as well as the order in which the structure is selected.  It passes through a given node and returns the starting and ending positions (as explained in the section on configuration): </p><br><p><img src="https://habrastorage.org/webt/q_/bn/-k/q_bn-ke4mcuo-pbn0pahaejozds.jpeg"></p><br><p>  Then the function will iterate through all nodes until it finds * <strong>ast.StructType</strong> , and returns its starting and ending positions to the file. </p><br><p>  But how is this done?  Remember that we have three modes.  Select by <strong>line</strong> , by <strong>offset</strong> and by <strong>structure name</strong> : </p><br><pre> <code class="hljs pgsql">// findSelection <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> the <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> position <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> the fields that are // suspect <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> change. It <span class="hljs-keyword"><span class="hljs-keyword">depends</span></span> <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> the <span class="hljs-type"><span class="hljs-type">line</span></span>, struct <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> selection. func (c *config) findSelection(node ast.Node) (<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>, error) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.line != "" { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.lineSelection(node) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> != <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.offsetSelection(node) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.structName != "" { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> c.structSelection(node) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.<span class="hljs-built_in"><span class="hljs-built_in">New</span></span>("-line, -offset or -struct is not passed") } }</code> </pre> <br><p>  Select <strong>by line is</strong> easiest.  We simply return the value of the flag itself.  If the user passed the flag <code>"--line 3,50"</code> , the function returns <code>(3, 50, nil)</code> .  It simply selects the value and converts it into integers (and at the same time checks): </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lineSelection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error splitted := strings.Split(c.line, <span class="hljs-string"><span class="hljs-string">","</span></span>) start, err := strconv.Atoi(splitted[<span class="hljs-number"><span class="hljs-number">0</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, err } end := start <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(splitted) == <span class="hljs-number"><span class="hljs-number">2</span></span> { end, err = strconv.Atoi(splitted[<span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, err } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> start &gt; end { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"wrong range. start line cannot be larger than end line"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> start, end, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><p>  This mode is used by editors when you select a group of lines and select (highlight) them. </p><br><p>  Selecting by <strong>offset</strong> and by <strong>structure name</strong> requires more work.  First you need to collect all the available structures so that you can calculate the offset or search by name.  So, we collect all the structures: </p><br><pre> <code class="hljs lua">// collectStructs collects <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> maps structType nodes to their positions func collectStructs(node ast.Node) map[token.Pos]*structType { structs := make(map[token.Pos]*structType, <span class="hljs-number"><span class="hljs-number">0</span></span>) collectStructs := func(n ast.Node) bool { t, ok := n.(*ast.TypeSpec) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> t.Type == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } structName := t.Name.Name x, ok := t.Type.(*ast.StructType) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } structs[x.Pos()] = &amp;structType{ name: structName, node: x, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } ast.Inspect(node, collectStructs) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> structs }</code> </pre> <br><p>  The <code>ast.Inspect()</code> function <code>ast.Inspect()</code> down the AST and looks for structures. </p><br><p>  First we need <code>*ast.TypeSpec</code> so that the name can be retrieved.  Search <code>*ast.StructType</code> will give us the structure itself, but not its name.  Therefore, we use the <code>structType</code> type, which contains the name and node of the structure, which is convenient.  Since the position of each structure is unique, we will take the position as a key for the binding. </p><br><p>  Now we have all the structures, and we can return the starting and ending positions for modes with an offset and the name of the structure.  In the first case, we will check if the offset falls inside the given structure: </p><br><pre> <code class="hljs pgsql">func (c *config) offsetSelection(file ast.Node) (<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>, error) { structs := collectStructs(file) var encStruct *ast.StructType <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, st := range structs { structBegin := c.fset.Position(st.node.Pos()).<span class="hljs-keyword"><span class="hljs-keyword">Offset</span></span> structEnd := c.fset.Position(st.node.<span class="hljs-keyword"><span class="hljs-keyword">End</span></span>()).<span class="hljs-keyword"><span class="hljs-keyword">Offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> structBegin &lt;= c.<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &amp;&amp; c.<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &lt;= structEnd { encStruct = st.node break } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> encStruct == nil { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, errors.<span class="hljs-built_in"><span class="hljs-built_in">New</span></span>("offset is not inside a struct") } // <span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> mode selects <span class="hljs-keyword"><span class="hljs-keyword">all</span></span> fields <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> := c.fset.Position(encStruct.Pos()).Line <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> := c.fset.Position(encStruct.<span class="hljs-keyword"><span class="hljs-keyword">End</span></span>()).Line <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, nil }</code> </pre> <br><p>  We use <code>collectStructs()</code> to collect and then iterate over the structures.  Remember that we saved the initial <code>token.FileSet</code> that was used to parse the file? </p><br><p>  Now he will help us to obtain information about the <strong>displacement</strong> from each individual node of the structure (decipher it <em>in</em> <code>token.Position</code> <em>and get the</em> <code>.Offset</code> <em>field</em> ).  We simply check and iterate until we find our structure (in this case with the name <code>encStruct</code> ): </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, st := range structs { structBegin := c.fset.Position(st.node.Pos()).<span class="hljs-keyword"><span class="hljs-keyword">Offset</span></span> structEnd := c.fset.Position(st.node.<span class="hljs-keyword"><span class="hljs-keyword">End</span></span>()).<span class="hljs-keyword"><span class="hljs-keyword">Offset</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> structBegin &lt;= c.<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &amp;&amp; c.<span class="hljs-keyword"><span class="hljs-keyword">offset</span></span> &lt;= structEnd { encStruct = st.node break } }</code> </pre> <br><p>  Using this information, you can extract the starting and ending positions of the found structure: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">start</span></span> := c.fset.Position(encStruct.Pos()).Line <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> := c.fset.Position(encStruct.<span class="hljs-keyword"><span class="hljs-keyword">End</span></span>()).Line</code> </pre> <br><p>  We apply the same logic when choosing a structure name.  Simply, instead of checking whether the offset is within a given structure, we <strong>check the name of the structure</strong> until we find the one we need: </p><br><pre> <code class="hljs go"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(c *config)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">structSelection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... for _, st := range structs { if st.name == c.structName { encStruct = st.node } } // ... }</span></span></code> </pre> <br><p>  Received the initial and final positions, proceed to the modification of the structure fields: </p><br><p><img src="https://habrastorage.org/webt/r8/dr/xj/r8drxjit4doxhtlc2ev-saxc3pw.jpeg"></p><br><p>  In our main function, we call the function <code>cfg.rewrite()</code> with the node that was parsed in the previous step: </p><br><pre> <code class="hljs lua">func main() { // ... <span class="hljs-built_in"><span class="hljs-built_in">find</span></span> start <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> position of the struct to be modified rewrittenNode, errs := cfg.rewrite(node, start, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errs != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> _, ok := errs.(*rewriteErrors); !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> errs } } // continue outputting the rewritten node }</code> </pre> <br><p>  This is a key part of the utility.  The rewrite function rewrites the fields of all structures between the starting and ending positions. </p><br><pre> <code class="hljs sql">// rewrite rewrites the node for structs between the <span class="hljs-keyword"><span class="hljs-keyword">start</span></span> <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> // positions <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> the rewritten node func (c *config) rewrite(node ast.Node, <span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span>) (ast.Node, <span class="hljs-keyword"><span class="hljs-keyword">error</span></span>) { errs := &amp;rewriteErrors{errs: make([]<span class="hljs-keyword"><span class="hljs-keyword">error</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)} rewriteFunc := func(n ast.Node) <span class="hljs-built_in"><span class="hljs-built_in">bool</span></span> { // rewrite the node ... } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">len</span></span>(errs.errs) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node, nil } ast.Inspect(node, rewriteFunc) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node, errs }</code> </pre> <br><p>  As you can see, we again use <code>ast.Inspect()</code> to traverse down the tree for a given node.  Inside the <code>rewriteFunc</code> function <code>rewriteFunc</code> we rewrite the tags of each field (we'll talk more about this later). </p><br><p>  Since the function returned by <code>ast.Inspect()</code> does not return an error, we will create an error scheme (defined using the <code>errs</code> variable), and then we will collect them by passing down the tree and processing the fields.  Let's deal with <code>rewriteFunc</code> : </p><br><pre> <code class="hljs go">rewriteFunc := <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n ast.Node)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { x, ok := n.(*ast.StructType) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, f := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> x.Fields.List { line := c.fset.Position(f.Pos()).Line <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !(start &lt;= line &amp;&amp; line &lt;= end) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> f.Tag == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { f.Tag = &amp;ast.BasicLit{} } fieldName := <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(f.Names) != <span class="hljs-number"><span class="hljs-number">0</span></span> { fieldName = f.Names[<span class="hljs-number"><span class="hljs-number">0</span></span>].Name } <span class="hljs-comment"><span class="hljs-comment">// anonymous field if f.Names == nil { ident, ok := f.Type.(*ast.Ident) if !ok { continue } fieldName = ident.Name } res, err := c.process(fieldName, f.Tag.Value) if err != nil { errs.Append(fmt.Errorf("%s:%d:%d:%s", c.fset.Position(f.Pos()).Filename, c.fset.Position(f.Pos()).Line, c.fset.Position(f.Pos()).Column, err)) continue } f.Tag.Value = res } return true }</span></span></code> </pre> <br><p>  Remember that this function is called <strong>for each</strong> AST <strong>node</strong> .  Therefore, we are only looking for nodes of type <code>*ast.StructType</code> .  Then we start to iterate over the fields of the structure. </p><br><p>  Here we again use our favorite variables <code>start</code> and <code>end</code> .  This code determines whether we want to modify the field.  If his position is between <code>start‚Äîend</code> , then we continue, otherwise we do not pay attention: </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !(<span class="hljs-keyword"><span class="hljs-keyword">start</span></span> &lt;= <span class="hljs-type"><span class="hljs-type">line</span></span> &amp;&amp; <span class="hljs-type"><span class="hljs-type">line</span></span> &lt;= <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> // skip processing the field }</code> </pre> <br><p>  Next, check if there is a tag.  If the tag field is empty ( <code>nil</code> ), we <strong>initialize it</strong> with an empty tag.  Later, this will help avoid confusion in the <code>cfg.process()</code> function: </p><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> f.Tag == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { f.Tag = &amp;ast.BasicLit{} }</code> </pre> <br><p>  Before proceeding, let me explain something interesting.  <strong>gomodifytags</strong> tries to get the field name and process it.  And if the field is anonymous? </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span></span> string <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> Bar <span class="hljs-comment"><span class="hljs-comment">//this is an anonymous field }</span></span></code> </pre> <br><p>  In this case <strong>, the field has no name</strong> , and then we assume the name of the field based on the <strong>name of the type</strong> : </p><br><pre> <code class="hljs pgsql">// <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> a field <span class="hljs-type"><span class="hljs-type">name</span></span> use it fieldName := "" <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> len(f.Names) != <span class="hljs-number"><span class="hljs-number">0</span></span> { fieldName = f.Names[<span class="hljs-number"><span class="hljs-number">0</span></span>].Name } // <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> there <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">no</span></span> field <span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> it <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> typ<span class="hljs-string"><span class="hljs-string">e's name if f.Names == nil { ident, ok := f.Type.(*ast.Ident) if !ok { continue } fieldName = ident.Name }</span></span></code> </pre> <br><p>  After receiving the field name and tag value, you can begin processing the field.  The <code>cfg.process()</code> function is responsible for processing (if there is a field name and a tag value).  It returns the result (in our case, the formatting of the structured tag), which we use to overwrite the existing value of the tag: </p><br><pre> <code class="hljs pgsql">res, err := c.process(fieldName, f.Tag.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != nil { errs.Append(fmt.Errorf("%s:%d:%d:%s", c.fset.Position(f.Pos()).Filename, c.fset.Position(f.Pos()).Line, c.fset.Position(f.Pos()).<span class="hljs-keyword"><span class="hljs-keyword">Column</span></span>, err)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span> } // rewrite the field <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> the <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> result,ie: <span class="hljs-type"><span class="hljs-type">json</span></span>:"foo" f.Tag.<span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> = res</code> </pre> <br><p>  If you remember the structtag, then String () is actually returned here - the representation of the tag instance.  Before returning the final representation of the tag, we will use various methods of the struct struct for the desired structure modification.  : </p><br><p><img src="https://habrastorage.org/webt/b7/km/qd/b7kmqdzl2ofgvw1gkhq4bovu0w8.jpeg"><br> <em> <strong>structtag</strong>     </em> </p><br><p> ,    <code>removeTags()</code>  <code>process()</code> .           ( ),   : </p><br><pre> <code class="hljs vbscript">flagRemoveTags = flag.<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>(<span class="hljs-string"><span class="hljs-string">"remove-tags"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">"Remove tags for the comma separated list of keys"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *flagRemoveTags != <span class="hljs-string"><span class="hljs-string">""</span></span> { cfg.remove = strings.<span class="hljs-built_in"><span class="hljs-built_in">Split</span></span>(*flagRemoveTags, <span class="hljs-string"><span class="hljs-string">","</span></span>) }</code> </pre> <br><p>  <code>removeTags()</code>  ,   - <code>--remove-tags</code> .        <code>tags.Delete()</code>  structtag: </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">c</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *config)</span></span></span></span> removeTags(tags *structtag.<span class="hljs-type"><span class="hljs-type">Tags</span></span>) *structtag.<span class="hljs-type"><span class="hljs-type">Tags</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.remove == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> || len(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.remove) == <span class="hljs-number"><span class="hljs-number">0</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tags } tags.<span class="hljs-type"><span class="hljs-type">Delete</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.remove...) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> tags }</code> </pre> <br><p>          <code>cfg.Process()</code> . </p><br><p>   ,    :    . </p><br><p><img src="https://habrastorage.org/webt/l1/jn/hg/l1jnhg5s9zflrbyolcr95-mypym.jpeg"></p><br><p>       <code>cfg.format()</code>  ,      : </p><br><pre> <code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">// ... rewrite the node out, err := cfg.format(rewrittenNode, errs) if err != nil { return err } fmt.Println(out) }</span></span></code> </pre> <br><p>   <strong>stdout</strong> .      . -,     ‚Äî   ,      . -, stdout  <strong></strong> ,    ,       . </p><br><p>    <code>format()</code> : </p><br><pre> <code class="hljs lua">func (c *<span class="hljs-built_in"><span class="hljs-built_in">config</span></span>) <span class="hljs-built_in"><span class="hljs-built_in">format</span></span>(file ast.Node, rwErrs <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">error</span></span>) { switch c.<span class="hljs-built_in"><span class="hljs-built_in">output</span></span> { case <span class="hljs-string"><span class="hljs-string">"source"</span></span>: // <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Go source code case <span class="hljs-string"><span class="hljs-string">"json"</span></span>: // <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a custom JSON <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> default: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"unknown output mode: %s"</span></span>, c.<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>) } }</code> </pre> <br><p>   <strong>   </strong> . <br>   (¬´ ¬ª)  <code>ast.Node</code>  Go-.    ,  ,              . </p><br><p>   (‚ÄúJSON‚Äù)         (  ).          : </p><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> output struct { <span class="hljs-keyword"><span class="hljs-keyword">Start</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> `<span class="hljs-type"><span class="hljs-type">json</span></span>:"start"` <span class="hljs-keyword"><span class="hljs-keyword">End</span></span> <span class="hljs-type"><span class="hljs-type">int</span></span> `<span class="hljs-type"><span class="hljs-type">json</span></span>:"end"` Lines []string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"lines"` Errors []string `<span class="hljs-type"><span class="hljs-type">json</span></span>:"errors,omitempty"` }</code> </pre> <br><p>       ( ): </p><br><p><img src="https://habrastorage.org/webt/sj/-m/uz/sj-muzos97dphk8jfxjc4qcv-k4.jpeg"></p><br><p>    <code>format()</code> .   ,     .  ¬´ ¬ª   go/format   AST    Go-.      ,  <strong>gofmt</strong> .     ¬´ ¬ª: </p><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> buf bytes.<span class="hljs-type"><span class="hljs-type">Buffer</span></span> err := format.<span class="hljs-type"><span class="hljs-type">Node</span></span>(&amp;buf, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.fset, file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.write { err = ioutil.<span class="hljs-type"><span class="hljs-type">WriteFile</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">c</span></span>.file, buf.<span class="hljs-type"><span class="hljs-type">Bytes</span></span>(), <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, err } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> buf.<span class="hljs-type"><span class="hljs-type">String</span></span>(), <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br><p>  format  <code>io.Writer</code>   .      ( <code>var buf bytes.Buffer</code> ),      ,     <code>-write</code> .      ,     Go. </p><br><p>  JSON  .      ,    <strong> ,   </strong> .   <strong>  </strong> .    ,    <code>format.Node()</code>     <strong>    </strong> ,   <strong>lossy</strong> . </p><br><p>   <strong>lossy-</strong> ?  : </p><br><pre> <code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">example</span></span></span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> foo int <span class="hljs-comment"><span class="hljs-comment">// this is a lossy comment bar int }</span></span></code> </pre> <br><p>      <code>*ast.Field</code> .      <code>*ast.Field.Comment</code> ,     . </p><br><p>         ?  <strong>foo</strong>  <strong>bar</strong> ? </p><br><p>    <strong></strong> ,    .        <code>format.Node()</code> ,  <a href="https://play.golang.org/p/peHsswF4JQ">   </a> : </p><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> example <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { foo <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> bar <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> }</code> </pre> <br><p>   ,  lossy-  <strong></strong> <code>*ast.File</code>  <strong>  </strong> .    ,     .   ,     ,     ,      JSON: </p><br><pre> <code class="hljs lua">var buf bytes.Buffer err := <span class="hljs-built_in"><span class="hljs-built_in">format</span></span>.Node(&amp;buf, c.fset, file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, err } var <span class="hljs-built_in"><span class="hljs-built_in">lines</span></span> []<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> scanner := bufio.NewScanner(bytes.NewBufferString(buf.String())) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> scanner.Scan() { <span class="hljs-built_in"><span class="hljs-built_in">lines</span></span> = append(<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>, scanner.Text()) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> c.start &gt; <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"line selection is invalid"</span></span>) } out := &amp;<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>{ Start: c.start, End: c.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>, Lines: <span class="hljs-built_in"><span class="hljs-built_in">lines</span></span>[c.start<span class="hljs-number"><span class="hljs-number">-1</span></span> : c.<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>], // cut out <span class="hljs-built_in"><span class="hljs-built_in">lines</span></span> } o, err := json.MarshalIndent(out, <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-string"><span class="hljs-string">" "</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>(o), <span class="hljs-literal"><span class="hljs-literal">nil</span></span></code> </pre> <br><p>      . </p><br><p>  That's all! </p><br><p>     ,     ,   : </p><br><p><img src="https://habrastorage.org/webt/3v/va/gp/3vvagpq89pjwf62z-nmedbd_bfw.jpeg"></p><br><p> <strong>  gomodifytags</strong> </p><br><p> : </p><br><ul><li>   CLI- <strong></strong> . </li><li>  <strong></strong>     <code>go/parser</code> ,   <code>ast.Node</code> . </li><li>  <strong></strong> ( <em>   </em> ) <strong></strong>  <strong></strong>    ,  ,    . </li><li>  ,     <code>ast.Node</code>  <strong></strong>        (   structtag). </li><li>  <strong></strong>         Go,  JSON  . </li></ul><br><p>  <strong>gomodifytags</strong>    ,        : </p><br><ul><li> vim-go </li><li> atom </li><li> vscode </li><li> acme </li></ul><br><p> ‚Üí <a href="https://github.com/fatih/gomodifytags"> </a> </p><br><p>        <a href="https://youtu.be/T4AIQ4RHp-c">  Gophercon 2017</a> </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/341822/">https://habr.com/ru/post/341822/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../341810/index.html">Alt-text guide from a visually impaired web developer</a></li>
<li><a href="../341812/index.html">In the footsteps of CyberCrimeCon 2017: Trends and development of high-tech crime</a></li>
<li><a href="../341814/index.html">Welcome to Sberbank Data Science Day November 11</a></li>
<li><a href="../341816/index.html">Meet NoteCAD</a></li>
<li><a href="../341818/index.html">CI: continuous integration in 5 minutes</a></li>
<li><a href="../341824/index.html">Taming "dinosaur", or CI / CD and IBM System i</a></li>
<li><a href="../341826/index.html">Denis Litvinov (COO FunCorp): Product Metrics for US Mobile Applications</a></li>
<li><a href="../341828/index.html">UE4 for Unity developers: creating 2D games</a></li>
<li><a href="../341830/index.html">Using Singleton in Unity3D</a></li>
<li><a href="../341832/index.html">CSS history essays</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>