<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Implementing Common Lisp Condition System on C #</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="One of the most remarkable and compelling features of Common Lisp is, of course, its exception handling system. 

 Moreover, in my opinion, personally...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Implementing Common Lisp Condition System on C #</h1><div class="post__text post__text-html js-mediator-article">  One of the most remarkable and compelling features of Common Lisp is, of course, its exception handling system. <br><br>  Moreover, in my opinion, personally, the opinion that such an approach to exceptions is the only correct one for all imperative languages, and for this simple reason: <br><br>  The mechanism of "exceptions" (or, as they are called in the world of CL - conditions) in Common Lisp is separated from the mechanism of stack promotion, and this, respectively, allows you to handle any pop-up in the program exceptional (and not only exceptional) situations right in that place, where they originated, without losing the program execution context, which entails ease of development, debugging, and in general, ease of constructing the logic of the program. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Perhaps it should be said that the Common Lisp Condition System, despite its uniqueness in the environment of high-level programming languages, is very close to many low-level tools of modern operating systems known to many developers, namely, UNIX synchronous signals and, much closer, the mechanism of SEH (Structured Exception Handling) from windows.  Leading CL implementations base such flow control elements as an exception handling mechanism and stack promotion on them. <br><br>  Despite the absence of a similar mechanism in many other (if not all) imperative programming languages, it can be implemented in a more or less sane form on most of them.  In this article, I will describe the implementation in C #, sorting out the very concept of this approach to ‚Äúexceptions‚Äù. <br><a name="habracut"></a><br>  To fully implement CLCS from a programming language, or rather even from its runtime, several things are required: <br><ul><li>  <strong>Strict stack model execution.</strong>  Here I mean the absence of full-fledged "continuations" in the language.  This point is rather conditional, but since the continuations introduce a huge blur into the mechanism for controlling the flow of computations, and do not allow determining with sufficient accuracy the main primitives that the CLCS repels, their presence is highly undesirable. </li><li>  <strong>Higher order functions, anonymous functions, and closures.</strong>  Of course, if you try, you can implement everything through objects and classes, but in this case it will be extremely inconvenient to use all of this, in my opinion. </li><li>  <strong>Dynamic environments and, in particular, dynamic variables.</strong>  About dynamic environments and variables I wrote in more or less detail in my article on the semantics of modern Lisp: <a href="http://love5an.livejournal.com/371169.html">love5an.livejournal.com/371169.html</a> <br>  In the absence of a similar concept in a programming language, it is, however, emulated using the following two points: </li><li>  <strong>Operators try, catch and throw, or their analogs.</strong>  These statements are in any programming language that supports exceptions. </li><li>  <strong>Primitive UNWIND-PROTECT or its equivalent (block try-finally, RAII, etc.).</strong> </li></ul><br><br>  We will transfer the following CL exception handling primitives to C #: <br><ol><li>  <strong><a href="http://l1sp.org/cl/handler-bind">handler-bind</a></strong> - sets an exception handler for the duration of the operator‚Äôs body.  When catching an exception, the handler may decide to roll out the stack, but is not required to do so. </li><li>  <strong><a href="http://l1sp.org/cl/handler-case">handler-case</a></strong> - sets an exception handler for the execution time of the operator body.  When catching an exception, the stack is unwound and the operator returns the value calculated in the body of the handler. </li><li>  <strong><a href="http://l1sp.org/cl/signal">signal</a></strong> - signals the occurrence of an exception to the higher-level handler, if present. </li><li>  <strong><a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_error.htm">error</a></strong> - signals the occurrence of an exception to a higher-level handler, and in the absence of this, or in the case of failure of all handlers to cope with the exception, throws an exception using the usual method, i.e.  operator throw (This is in our implementation. In Common Lisp, the error function calls the debugger if it is connected, or, otherwise, it terminates a separate computational flow (thread) or the entire lisp system.) </li><li>  <strong><a href="http://l1sp.org/cl/restart-bind">restart-bind</a></strong> - installs a "restart", not causing the stack promotion mechanism.  Restarting is a function in the current dynamic environment (see the link to the article above) that can somehow respond to the exception that occurred.  Restarts are usually put in places in the program where you can somehow fix the error that occurred.  They are usually run from exception handlers (see below). </li><li>  <strong><a href="http://l1sp.org/cl/restart-case">restart-case</a></strong> - sets "restart", culminating in promotion of the stack. </li><li>  <strong><a href="http://l1sp.org/cl/find-restart">find-restart</a></strong> - finds ‚Äúrestart‚Äù by name. </li><li>  <strong><a href="http://l1sp.org/cl/find-restart">invoke-restart</a></strong> - finds a "restart" by name and launches it. </li><li>  <strong><a href="http://l1sp.org/cl/compute-restarts">compute-restarts</a></strong> - calculates a list of all ‚Äúrestarts‚Äù installed in the current dynamic environment. </li><li>  <strong><a href="http://l1sp.org/cl/unwind-protect">unwind-protect</a></strong> ‚Äî executes the operator‚Äôs body block, and after ‚Äî regardless of whether the execution completed in a normal way, or through forced stack promotion ‚Äî performs all the specified ‚Äúprotecting‚Äù blocks (functions). </li></ol><br><br>  In more detail about these, and other primitives connected with exception handling, it is possible to read in Peter Sibel's remarkable book "Practical Common Lisp", in chapter 19: <br>  <a href="http://lisper.ru/pcl/beyond-exception-handling-conditions-and-restarts">lisper.ru/pcl/beyond-exception-handling-conditions-and-restarts</a> <br><br>  All of our implementation will be contained in the static class <i>Conditions</i> .  Further I will describe his methods. <br>  But first you should describe a pair of static variables. <br><br>  In each program execution thread, exception handlers and restarts during installation form a stack.  Generally, formally speaking, the stack forms the dynamic environments of each thread, but since dynamic environments in C #, strictly speaking, are absent, we will ‚Äúhands‚Äù connect the data structure with a ‚Äústack‚Äù with each thread. <br><br><pre><code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ConditionalWeakTable&lt;Thread, Stack&lt;Tuple&lt;Type, HandlerBindCallback&gt;&gt;&gt; _handlerStacks; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> ConditionalWeakTable&lt;Thread, Stack&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, RestartBindCallback&gt;&gt;&gt; _restartStacks; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Conditions</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _handlerStacks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConditionalWeakTable&lt;Thread, Stack&lt;Tuple&lt;Type, HandlerBindCallback&gt;&gt;&gt;(); _restartStacks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConditionalWeakTable&lt;Thread, Stack&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, RestartBindCallback&gt;&gt;&gt;(); }</code> </pre> <br><br>  For the ‚Äúthread -&gt; stack‚Äù dictionary, I chose the ConditionalWeakTable class added in .NET 4.0, but you can use any other similar data structure.  ConditionalWeakTable is good because it is a hash label with ‚Äúweak pointers‚Äù (WeakPointer - hence the Weak in the class name) on the keys, and this, respectively, means that when you remove a thread object from the garbage collector, we will not leak of memory. <br><br><h4>  Exception Handlers and Signaling </h4><br><h5>  Handlerbind </h5><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandlerBind&lt;T&gt;(Type exceptionType, HandlerBindCallback handler, HandlerBody&lt;T&gt; body) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == exceptionType) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"exceptionType"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!exceptionType.IsSubclassOf(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(Exception))) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(<span class="hljs-string"><span class="hljs-string">"exceptionType is not a subtype of System.Exception"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == handler) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"handler"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == body) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"body"</span></span>); Thread currentThread = Thread.CurrentThread; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clusters = _handlerStacks.GetOrCreateValue(currentThread); clusters.Push(Tuple.Create(exceptionType, handler)); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> body(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { clusters.Pop(); } }</code> </pre><br>  The HandlerBind method takes three parameters in us - the type of exception that the handler is associated with (as can be seen from the body of the method, it must be a subclass of Exception), the callback defining the handler code, and another delegate defining the code executed in the operator's body. <br>  The types of delegates handler and body are: <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">delegate</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandlerBindCallback</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Exception exception</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> T HandlerBody&lt;T&gt;();</code> </pre><br>  The exception parameter passed to the handler in the arguments is the exception object itself. <br><br>  As you can see, the implementation of HandlerBind is simple - we add a new one to the stack of handlers associated with the current thread, then execute the operator's body code, and finally, in the body of finally, remove the handler from the stack.  Thus, the stack of exception handlers is associated with the stack of execution of the current thread, and each installed handler becomes invalid when it leaves the corresponding stack frame of the program execution thread. <br><br><h5>  Handlercase </h5><br><pre> <code class="hljs javascript">public <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T HandlerCase&lt;T&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Type exceptionType, HandlerCaseCallback&lt;T&gt; handler, HandlerBody&lt;T&gt; body</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == exceptionType</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"exceptionType"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">!exceptionType.IsSubclassOf(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typeof</span></span></span></span><span class="hljs-function"><span class="hljs-params">(Exception</span></span></span><span class="hljs-function">))) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">InvalidOperationException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"exceptionType is not a subtype of System.Exception"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == handler</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"handler"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == body</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"body"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">unwindTag</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnwindTag</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">HandlerBindCallback</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">handlerCallback</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> { unwindTag.Value = handler(e); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> unwindTag; }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> HandlerBind(exceptionType, handlerCallback, body); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (UnwindTag&lt;T&gt; e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == unwindTag) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre><br><br>  The implementation of HandlerCase is somewhat more complicated.  The difference from HandlerBind, I remind you, is that this operator spins the stack to the point where the handler is installed.  Since explicit escaping continuations are not allowed in C # (that is, roughly, we cannot make a goto or return from the lambda sent down the stack to an external block), we use regular try-catch to unwind the stack, and we identify the handler block <i>UnwindTag</i> helper class <i>object</i> <br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> UnwindTag&lt;T&gt; : <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">public</span></span> T <span class="hljs-keyword"><span class="hljs-keyword">Value</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br><br>  HandlerCaseCallback differs from HandlerBindCallback only in that it returns a value: <br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> delegate T HandlerCaseCallback&lt;T&gt;(<span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>);</code> </pre><br><br><h5>  Signalal </h5><br>  Signal is the heart of the CL exception handling system.  Unlike throw and associates from other programming languages, it does not promote the call stack, but merely signals an exception that has occurred, that is, it simply calls a suitable handler. <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> Signal&lt;T&gt;(T <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">null</span></span> == <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>) throw <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> ArgumentNullException("exception"); Thread currentThread = Thread.CurrentThread; var clusters = _handlerStacks.GetOrCreateValue(currentThread); var i = clusters.GetEnumerator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i.MoveNext()) { var <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> = i.<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>.Item1; var <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span> = i.<span class="hljs-keyword"><span class="hljs-keyword">Current</span></span>.Item2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">type</span></span>.IsInstanceOfType(<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">handler</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>); break; } } }</code> </pre><br><br>  As you can see - everything is very simple.  From the current stack of exception handlers, we take the first one that is able to work with the exception class, the instance of which is the object passed to us in the exception parameter. <br><br><h5>  Error </h5><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static <span class="hljs-type"><span class="hljs-type">void</span></span> Error&lt;T&gt;(T <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : <span class="hljs-keyword"><span class="hljs-keyword">Exception</span></span> { Signal(<span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>); throw <span class="hljs-keyword"><span class="hljs-keyword">exception</span></span>; }</code> </pre><br><br>  Error differs from Signal only in that it interrupts the normal flow of program execution if there is no suitable handler.  If we were writing a full-fledged implementation of Common Lisp under .NET, instead of a ‚Äúthrow exception,‚Äù there would be something like ‚ÄúInvokeDebuggerOrDie (exception);‚Äù <br><br><h4>  Restarts </h4><br><h5>  RestartBind and RestartCase </h5><br>  RestartBind and RestartCase are very similar to HandlerBind and HandlerCase, with the difference that they work with the restart stack, and assign the exception delegate to the handler delegate, but the string, the restart name. <br><pre> <code class="hljs javascript">public delegate object RestartBindCallback(object param); public delegate T RestartCaseCallback&lt;T&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">object param</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">public</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">static</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RestartBind</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string name, RestartBindCallback restart, HandlerBody&lt;T&gt; body</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == name</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"name"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == restart</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"restart"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == body</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"body"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Thread</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentThread</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Thread</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">CurrentThread</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clusters</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">_restartStacks</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GetOrCreateValue</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">currentThread</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clusters</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Push</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Tuple.Create(name, restart</span></span></span><span class="hljs-function">)); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">try</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">finally</span></span></span><span class="hljs-function"> { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">clusters</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Pop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; } } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">public</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">static</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RestartCase</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">string name, RestartCaseCallback&lt;T&gt; restart, HandlerBody&lt;T&gt; body</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == name</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"name"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == restart</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"restart"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">if</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">null</span></span></span></span><span class="hljs-function"><span class="hljs-params"> == body</span></span></span><span class="hljs-function">) </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">throw</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ArgumentNullException</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"body"</span></span></span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">var</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">unwindTag</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">UnwindTag</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">RestartBindCallback</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">restartCallback</span></span></span><span class="hljs-function"> = (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">param</span></span></span><span class="hljs-function">) =&gt;</span></span> { unwindTag.Value = restart(param); <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> unwindTag; }; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> RestartBind(name, restartCallback, body); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (UnwindTag&lt;T&gt; e) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (e == unwindTag) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Value; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; } }</code> </pre><br><br><h5>  FindRestart and InvokeRestart </h5><br>  FindRestart and InvokeRestart, in turn, are very similar to the Signal method - the first function finds a restart in the corresponding stack of the current thread by name, and the second not only finds it, but also starts it immediately. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> RestartBindCallback </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindRestart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> throwOnError</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == name) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"name"</span></span>); Thread currentThread = Thread.CurrentThread; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clusters = _restartStacks.GetOrCreateValue(currentThread); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = clusters.GetEnumerator(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (i.MoveNext()) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> restartName = i.Current.Item1; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> restart = i.Current.Item2; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name == restartName) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restart; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (throwOnError) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RestartNotFoundException(name); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">object</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InvokeRestart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> name, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> param</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> restart = FindRestart(name, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> restart(param); }</code> </pre><br><br><h5>  ComputeRestarts </h5><br>  ComputeRestarts simply returns a list of all the restarts currently set ‚Äî this can be useful, for example, to an exception handler, so that when called, it can select the appropriate restart for a particular situation. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> IEnumerable&lt;Tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, RestartBindCallback&gt;&gt; ComputeRestarts() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> restarts = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, RestartBindCallback&gt;(); Thread currentThread = Thread.CurrentThread; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> clusters = _restartStacks.GetOrCreateValue(currentThread); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clusters.AsEnumerable(); }</code> </pre><br><br><h4>  UnwindProtect </h4><br>  Our implementation of UnwindProtect simply wraps a try-finally block. <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> T UnwindProtect&lt;T&gt;(HandlerBody&lt;T&gt; body, <span class="hljs-keyword"><span class="hljs-keyword">params</span></span> Action[] actions) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == body) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"body"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-literal"><span class="hljs-literal">null</span></span> == actions) actions = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Action[<span class="hljs-number"><span class="hljs-number">0</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> body(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> actions) a(); } }</code> </pre><br><br>  Finally - a few examples of use. <br><br><ol><li>  Use HandlerBind with an exception signaling function. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DivSignal</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == y) { Conditions.Signal(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DivideByZeroException()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / y; }</code> </pre><br><pre> <code class="hljs coffeescript">int r = Conditions.HandlerBind( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DivideByZeroException), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> =&gt;</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering handler callback"</span></span>); }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering HandlerBind with DivSignal"</span></span>); var rv = DivSignal(<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Returning {0} from body"</span></span>, rv); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Return value: {0}\n"</span></span>, r);</code> </pre><br>  Here, the DivSignal function, when the divider is equal to zero, signals a situation that has arisen, but nevertheless, it itself ‚Äúcopes‚Äù with it (returns zero).  In this case, neither the handler nor the function itself interrupts the normal course of the program. <br>  The output to the console is as follows: <br><pre> <code class="lisp hljs">Entering HandlerBind with DivSignal Entering handler callback Returning <span class="hljs-number"><span class="hljs-number">0</span></span> from body Return value: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br></li><li>  Using HandlerCase and UnwindProtect with an error signal via Error. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DivError</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-number"><span class="hljs-number">0</span></span> == y) Conditions.Error(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DivideByZeroException()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / y; }</code> </pre><br><pre> <code class="hljs coffeescript">int r = Conditions.HandlerCase( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DivideByZeroException), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> =&gt;</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering handler callback"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Returning 0 from handler"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering HandlerCase with DivError and UnwindProtect"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conditions.UnwindProtect( <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering UnwindProtect"</span></span>); var rv = DivError(<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"This line should not be printed"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rv; }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"UnwindProtect exit point"</span></span>); }); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Return value: {0}\n"</span></span>, r);</code> </pre><br>  In this case, the DivError function throws an exception, but the handler intercepts it, spins the stack, and returns its value (in this case, 0).  In the course of stack promotion, the computation flow passes through UnwindProtect. <br>  This example, unlike the others, could be rewritten using ordinary try, catch and finally. <br>  Output to console: <br><pre> <code class="lisp hljs">Entering HandlerCase with DivError and UnwindProtect Entering UnwindProtect Entering handler callback Returning <span class="hljs-number"><span class="hljs-number">0</span></span> from handler UnwindProtect exit point Return value: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br></li><li>  Use HandlerBind with the function in which the restart is set. <br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DivRestart</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Conditions.RestartCase( <span class="hljs-string"><span class="hljs-string">"ReturnValue"</span></span>, (param) =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering restart ReturnValue"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Returning {0} from restart"</span></span>, param); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)param; }, () =&gt; { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering RestartCase"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DivError(x, y); }); }</code> </pre><br>  DivRestart sets up a restart with the name ‚ÄúReturnValue‚Äù, which, when activated, simply returns the value passed to it through the (param) parameter.  The body RestartCase calls the DivError described in the previous example. <br><pre> <code class="hljs coffeescript">int r = Conditions.HandlerBind( <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(DivideByZeroException), <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e)</span></span></span><span class="hljs-function"> =&gt;</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering handler callback"</span></span>); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Invoking restart ReturnValue with param = 0"</span></span>); Conditions.InvokeRestart(<span class="hljs-string"><span class="hljs-string">"ReturnValue"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Entering HandlerBind with DivRestart"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DivRestart(<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); }); Console.WriteLine(<span class="hljs-string"><span class="hljs-string">"Return value: {0}"</span></span>, r);</code> </pre><br>  The handler installed in HandlerBind, when called, searches for the restart of ‚ÄúReturnValue‚Äù and sends it the number 0 to the parameter, then ‚ÄúReturnValue‚Äù is activated, unwinds the stack to its level, and returns this same number from the RestartCase installed in DivRestart, as seen above. <br>  Conclusion: <br><pre> <code class="lisp hljs">Entering HandlerBind with DivRestart Entering RestartCase Entering handler callback Invoking restart ReturnValue with param = <span class="hljs-number"><span class="hljs-number">0</span></span> Entering restart ReturnValue Returning <span class="hljs-number"><span class="hljs-number">0</span></span> from restart Return value: <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br></li></ol><br><br>  The full source code for the library and examples is available on github: <a href="http://github.com/Lovesan/ConditionSystem">github.com/Lovesan/ConditionSystem</a> </div><p>Source: <a href="https://habr.com/ru/post/150198/">https://habr.com/ru/post/150198/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../150191/index.html">We meet Veracity - a new distributed version control system</a></li>
<li><a href="../150192/index.html">Windows 8 tells Microsoft about any installable programs.</a></li>
<li><a href="../150193/index.html">Cheat Sheet by SCJP. Part two</a></li>
<li><a href="../150194/index.html">Quality takeoff after the "fall". Or why "lay" many bytes</a></li>
<li><a href="../150197/index.html">A jury found Samsung guilty of infringing Apple patents</a></li>
<li><a href="../150199/index.html">Implementing RESTful Web Service on Scala</a></li>
<li><a href="../150200/index.html">Be optimistic - depression leads to Alzheimer's disease</a></li>
<li><a href="../150201/index.html">Vulnerability in Kohana?</a></li>
<li><a href="../150203/index.html">My view on Scrum</a></li>
<li><a href="../150204/index.html">Solving the problem of installing Cloud9 ide on Ubuntu 12.04</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>