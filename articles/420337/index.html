<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Detection of vulnerabilities in theory and practice, or why there is no perfect static analyzer</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Today, the development of high-quality software is difficult to imagine without the use of static code analysis methods . Static code analysis can be ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Detection of vulnerabilities in theory and practice, or why there is no perfect static analyzer</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/webt/4o/sp/ej/4ospejeehs7v_tobj7glemsmj_a.png"><br><br>  Today, the development of high-quality software is difficult to imagine without the use <a href="https://en.wikipedia.org/wiki/Static_program_analysis">of static code analysis methods</a> .  Static code analysis can be embedded in the development environment (using standard methods or using plug-ins), can be performed by specialized software before running the code into commercial operation or ‚Äúmanually‚Äù by a full-time or external expert. <br><a name="habracut"></a><br>  Often there is a reasoning that <a href="https://en.wikipedia.org/wiki/Dynamic_program_analysis">dynamic code analysis</a> or <a href="https://en.wikipedia.org/wiki/Penetration_test">penetration tests</a> can replace static analysis, since these verification methods will reveal real problems and there will be no false positives.  However, this is a controversial issue, because dynamic analysis, in contrast to static analysis, does not check all the code, but only checks the software's resistance to a set of attacks that mimic the actions of an attacker.  An attacker may be more inventive than the verifier, regardless of who performs the verification: the person or the machine. <br><br>  Dynamic analysis will be complete only if it is performed on full test coverage, which, as applied to real-world applications, is a difficult task.  The proof of the completeness of the test coverage is an algorithmically unsolvable problem. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Mandatory static analysis of software code is one of the necessary steps when commissioning software with increased requirements for information security. <br><br>  At the moment, there are many different static code analyzers on the market, and more and more new ones are constantly appearing.  In practice, there are cases when several static analyzers are used together to improve the quality of checking, since different analyzers look for different defects. <br><br>  Why is there no universal static analyzer that completely checks any code and finds all defects in it without false positives and at the same time works quickly and does not require a lot of resources (CPU time and memory)? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hv/sq/zt/hvsqztaqcgmhuw4x8l8-9xawgba.png"></div><br><br><h3>  A little bit about the architecture of static analyzers <br></h3><br>  The answer to this question lies in the architecture of static analyzers.  Almost all static analyzers are somehow built according to the principle of compilers, that is, there are steps in the transformation of the source code in their work - the same as the compiler does. <br><br>  It all starts with a <a href="https://en.wikipedia.org/wiki/Lexical_analysis">lexical analysis</a> , which receives the input of the program text in a high-level language, and a stream of tokens delivers to the output.  Next, the resulting stream of tokens is passed to the input of the <a href="https://en.wikipedia.org/wiki/Parsing">syntax analyzer</a> , which parses the language constructs and transfers the result of the parsing to the <a href="https://en.wikipedia.org/wiki/Semantic_analysis_(linguistics)">semantic analyzer</a> , which as a result of its work performs the preparation for constructing an internal representation.  This internal representation is a feature of each static analyzer.  The efficiency of the analyzer depends on how successful it is. <br><br><img src="https://habrastorage.org/webt/gx/by/x1/gxbyx1fcaoktxglgx8g5wwmbbr8.jpeg"><br><br>  Many manufacturers of static analyzers state that they use a universal internal representation for all programming languages ‚Äã‚Äãsupported by the analyzer.  In this way, they can analyze software code developed in several languages ‚Äã‚Äãas a whole, rather than as separate components.  The ‚Äúholistic approach‚Äù to the analysis allows you to avoid missing defects that arise at the interface between the individual components of the software product. <br><br>  In theory, this is true, but in practice, a universal internal representation for all programming languages ‚Äã‚Äãis difficult and inefficient.  Every programming language is special.  The internal representation is usually a tree whose vertices store attributes.  By traversing such a tree, the analyzer collects and converts information.  Therefore, each vertex of the tree must contain a uniform set of attributes.  Since each language is unique, uniformity of attributes can be maintained only by redundancy of the components.  The more heterogeneous the programming languages, the more heterogeneous components in the characteristics of each vertex, and therefore, the internal representation is inefficient in memory.  A large number of heterogeneous characteristics also affect the complexity of tree walkers, and therefore entails inefficiency in performance. <br><br><h3>  Optimization Conversions for Static Analyzers <br></h3><br>  In order for a static analyzer to work efficiently in memory and time, one must have a compact universal internal representation, and this can be achieved by the fact that the internal representation is divided into several trees, each of which is developed for related programming languages. <br><br>  The optimization work is not limited to the division of the internal representation into related programming languages.  Next, manufacturers use various optimization pre- <a href="https://en.wikipedia.org/wiki/Loop_optimization">transformations</a> - the same as in compiler technologies, in particular, <a href="https://en.wikipedia.org/wiki/Loop_optimization">optimization transformations of cycles</a> .  The point is that the goal of static analysis ideally is to carry out the promotion of data on the program in order to evaluate their transformation during the execution of programs.  Therefore, the data must be "advanced" through each turn of the cycle.  So, if you save on these very turns and make them significantly less, then we will get significant benefits both in memory and in performance.  It is for this purpose that such transformations are actively used, which with some probability carry out an extrapolation of data transformation to all turns of the cycle by the minimum number of passes. <br><br>  You can also save on branching by calculating the likelihood that program execution will follow a particular branch.  If the probability of passing through a branch is lower than the specified one, then this branch of the program is not considered. <br><br>  Obviously, each of these transformations "loses" the defects that the analyzer must detect, but this is a "fee" for efficiency in terms of memory and performance. <br><br><h3>  What is a static code analyzer looking for? <br></h3><br>  Conventionally, defects that in one way or another interest intruders and, consequently, auditors, can be divided into the following groups: <br><br><ul><li>  validation errors </li><li>  information leakage errors </li><li>  authentication errors. </li></ul><br>  <b>Validation errors</b> result from the fact that the input data are not adequately checked for correctness.  An attacker may slip in as input data is not what the program expects, and thereby gain unauthorized access to control.  The most common data validation errors are in injections and <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> .  Instead of valid data, the attacker delivers to the program's input specially prepared data that carries a small program.  This program, being processed, is executed.  The result of its execution can be the transfer of control to another program, data corruption and much, much more.  Also, as a result of validation errors, substitution of the site with which the user works can be performed.  Validation errors can be detected qualitatively by static code analysis methods. <br><br>  <b>Information leakage</b> errors are errors due to the fact that sensitive information from the user as a result of processing was intercepted and transmitted to the attacker.  It may be the opposite: sensitive information that is stored in the system, in the process of its movement to the user, is intercepted and transmitted to the attacker. <br><br>  Such vulnerabilities are just as difficult to detect as validation errors.  Detection of such errors requires tracking in the statics of promotion and data conversion throughout the program code.  This requires the implementation of methods such as <a href="http://shell-storm.org/blog/Taint-analysis-and-pattern-matching-with-Pin/">taint analysis</a> and <a href="http://shell-storm.org/blog/Taint-analysis-and-pattern-matching-with-Pin/">interprocedural data analysis</a> .  The accuracy of the analysis depends on how well these methods are developed, namely, the minimization of false positives and missed errors. <br><br>  Also, a significant role in the accuracy of the static analyzer is played by the library of defect detection rules, in particular, the format for describing these rules.  All this is a competitive advantage of each analyzer and is carefully guarded from competitors. <br><br>  <b>Authentication errors</b> are the most interesting errors for an attacker, since they are difficult to detect because they occur at the junction of components and are difficult to formalize.  Attackers exploit these kinds of errors to escalate access rights.  Authentication errors are not automatically detected, since it is not clear what to look for - these are errors of the program building logic. <br><br><h3>  Memory errors <br></h3><br>  They are difficult to detect, because for accurate identification it is required to solve a cumbersome system of equations, and this is expensive both in memory and in performance.  Consequently, the system of equations is reduced, and therefore, accuracy is lost. <br><br>  Typical memory errors include <a href="https://www.webopedia.com/TERM/U/use-after-free.html">use-after-free</a> , <a href="https://www.webopedia.com/TERM/U/use-after-free.html">double-free</a> , <a href="https://www.owasp.org/index.php/Null_Dereference">null-pointer-dereference</a> and their variations, for example, <a href="https://cwe.mitre.org/data/definitions/125.html">out-of-bounds-Read</a> and <a href="https://cwe.mitre.org/data/definitions/787.html">out-of-bounds-Write</a> . <br><br>  When another analyzer fails to detect a memory leak, you can hear that such defects are difficult to exploit.  The attacker must be highly qualified and apply a lot of skill to, first, to find out about the presence of such a defect in the code, and, secondly, to make an exploit.  Well, and further the argument is: ‚ÄúAre you sure that your software product is interesting for a guru of this level?‚Äù ... However, history knows cases when memory errors were successfully exploited and caused considerable damage.  Examples of such well-known situations include: <br><br><ol><li>  <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3Dcve-2014-0160">CVE-2014-0160</a> - error in the openssl library - potential compromise of private keys required reissuance of all certificates and regeneration of passwords. </li><li>  <a href="https://nvd.nist.gov/vuln/detail/CVE-2015-2712">CVE-2015-2712</a> - Error in js implementation in mozilla firefox - bounds check. </li><li>  <a href="https://cve.mitre.org/cgi-bin/cvename.cgi%3Fname%3DCVE-2010-1117">CVE-2010-1117</a> - use after free in internet explorer - remotely exploitable. </li><li>  <a href="https://nvd.nist.gov/vuln/detail/CVE-2018-4913">CVE-2018-4913</a> - Acrobat Reader - code execution. </li></ol><br>  More attackers like to exploit the defects associated with incorrect synchronization of the threads or processes.  Such defects are difficult to identify in statics, because it is not an easy task to model the state of a machine without the concept of ‚Äútime‚Äù.  This is due to <a href="https://en.wikipedia.org/wiki/Race_condition">race-condition</a> errors.  Today, parallelism is used everywhere, even in very small applications. <br><br>  Summarizing the above, it should be noted that the static analyzer is useful in the development process, if it is properly used.  During operation, it is necessary to understand what to expect from it and how to deal with those defects that the static analyzer cannot identify in principle.  If they say that a static analyzer is not needed during the development process, then it simply does not know how to exploit it. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lu/90/kx/lu90kxj_uabzysjjxievhgctnpa.png"></div><br>  How to properly operate a static analyzer, correctly and effectively work with the information that it gives out, read on in our blog. </div><p>Source: <a href="https://habr.com/ru/post/420337/">https://habr.com/ru/post/420337/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../420327/index.html">LLTR Part 1: First steps in OMNeT ++ and INET</a></li>
<li><a href="../420329/index.html">‚ÄúReality in Question‚Äù: the main theses of the book by Jane McGonigal on the role of games in modern society</a></li>
<li><a href="../420331/index.html">Demopati in Helsinki "Assembly 2018" photo report, the second day</a></li>
<li><a href="../420333/index.html">Large do-it-yourself portal gantry milling machine</a></li>
<li><a href="../420335/index.html">Your reading style says a lot about your intellect - and this is why</a></li>
<li><a href="../420339/index.html">Smartphone Surveillance - Pros and Cons</a></li>
<li><a href="../420341/index.html">On-site running and web development</a></li>
<li><a href="../420343/index.html">LED lights OK</a></li>
<li><a href="../420345/index.html">Overview of IXcellerate data center (the largest machine building in the Russian Federation)</a></li>
<li><a href="../420347/index.html">Learn how to create your own bash commands in less than 4 minutes.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>