<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Ramda Thinking: Partial Application (Currying)</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="This post is the third part of a series of articles on functional programming called ‚ÄúThinking in the Ramda Style‚Äù. 

 1. First steps 
 2. We combine ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Ramda Thinking: Partial Application (Currying)</h1><div class="post__text post__text-html js-mediator-article">  This post is the third part of a series of articles on functional programming called ‚ÄúThinking in the Ramda Style‚Äù. <br><br>  <a href="https://habrahabr.ru/post/348868/">1. First steps</a> <br>  <a href="https://habrahabr.ru/post/348976/">2. We combine functions</a> <br>  <a href="https://habrahabr.ru/post/349140/"><b>3. Partial application (currying)</b></a> <br>  <a href="https://habrahabr.ru/post/349674/">4. Declarative programming</a> <br>  <a href="https://habr.com/post/358452/">5. Ruleless Notation</a> <br>  <a href="https://habr.com/post/414337/">6. Immutability and objects</a> <br>  <a href="https://habr.com/post/415025/">7. Immutability and arrays</a> <br>  <a href="https://habr.com/post/415035/">8. Lenses</a> <br>  <a href="https://habr.com/post/415037/">9. Conclusion</a> <br><br>  In the <a href="https://habrahabr.ru/post/348976/">second part,</a> we talked about the combination of functions in different ways, ending on the functions <a href="http://ramdajs.com/docs/">compose</a> and <a href="http://ramdajs.com/docs/">pipe</a> , which allow the use of a series of functions in the conveyor mode. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      In that post, we looked at simple functions that take only one argument.  But what if we want to use functions that take more than one argument? <a name="habracut"></a><br><br>  For example, let's say that we have a collection of book objects and we want to find the names of all the books published in a particular year.  Let's solve this problem using only the iterative Ramda functions: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book, year</span></span></span><span class="hljs-function">) =&gt;</span></span> book.year === year <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books, year</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selected = filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> publishedInYear(book, year), books) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title, selected) }</code> </pre> <br>  It will be good if we combine <a href="http://ramdajs.com/docs/">filter</a> and <a href="http://ramdajs.com/docs/">map</a> in a pipeline, but we don‚Äôt know how to do this, because filter and map take two arguments. <br><br>  It will also be good if we do not need to use the arrow functions in filter.  Let's solve this problem first, as it will let us know some things that we can use when creating pipelines: <br><br><h2>  Higher order functions </h2><br>  In the <a href="https://habrahabr.ru/post/348868/">first part of</a> this series, we talked about functions as first-class constructions.  Similar functions can be passed as parameters to other functions and returned as a result from other functions.  We have done a lot of the first, but have not yet applied the last. <br><br>  Functions that accept or return other functions are also called ‚Äúhigher order functions. <br><br>  In the example above, we pass the arrow function to filter: book =&gt; publishedInYear (book, year), and it would be nice to get rid of it.  In order to do this, we need a function that accepts a book and returns true if the book was published in the desired year.  But we also need to pass the number of the year to make it flexible. <br><br>  The way we can solve this problem is to create a function that will return another function.  I will write it in the usual syntax of functions, so that you understand what is happening here, but then we move on to a shorter version with a switch syntax: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    function publishedInYear(year) { return function(book) { return book.year === year } } //  : const publishedInYear = year =&gt; book =&gt; book.year === year</span></span></code> </pre><br>  This is the new version of the function publishedInYear, we can rewrite the call to filter, excluding the arrow function: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year</span></span></span><span class="hljs-function"> =&gt;</span></span> book =&gt; book.year === year <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books, year</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selected = filter(publishedInYear(year), books) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title, selected) }</code> </pre><br>  Now that we call filter, publishedInYear (year) is immediately called and returns a function that takes the book, which is exactly what is needed for filter. <br><br><h2>  Partially applied functions </h2><br>  We can rewrite a function with several arguments in a similar way, if we wish, but not all of our functions should work this way.  Also, we may wish to use functions with several arguments in the usual way. <br><br>  For example, if we had some other code that just wanted to check that the book was published in a certain year, we would like to write like this: publishedInYear (book, 2012), but we cannot write in this way.  Instead, we have to write a little differently: publishedInYear (2012) (book).  It is less readable and more annoying. <br><br>  Fortunately, Ramda provides two functions to help us with this: <a href="http://ramdajs.com/docs/">partial</a> and <a href="http://ramdajs.com/docs/">partialRight</a> . <br><br>  These two functions allow you to call another function with a smaller number of arguments that it needs.  They both return a new function that will accept the remaining arguments and call the original function already when all the arguments have been provided. <br><br>  The difference between partial and partialRight is that the arguments we supply will be substituted with the leftmost or rightmost arguments necessary for the original function. <br><br>  Let's go back to our original example and try to use these functions instead of rewriting publishedInYear.  Since we only need to provide a year, and this is the rightmost argument, we need to use partialRight: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book, year</span></span></span><span class="hljs-function">) =&gt;</span></span> book.year === year <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books, year</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selected = filter(partialRight(publishedInYear, [year]), books) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title, selected) }</code> </pre><br>  If we wrote publishedInYear, the host (year, book) instead of (book, year), we would use partial instead of partialRight. <br><br>  Note that the arguments that we pass to partial and partialRight should always be in an array, even if you pass only one of them there.  I can‚Äôt say how many times I‚Äôve forgotten about it and got a confusing error message: <br><br><pre> <code class="javascript hljs">First argument to _arity must be a non-negative integer no greater than ten</code> </pre><br><h2>  Currying </h2><br>  The need to use partial and partialRight everywhere leads to verbosity and fatigue.  But the need to call functions with many arguments as a series of single-argument functions has long been badly bad. <br><br>  Fortunately, Ramda provides us with a solution: currying. <br><br>  <a href="http://ramdajs.com/docs/">curry</a> is another basic concept of functional programming.  Technically, a curried function is always a series of single-argument functions that I have just complained about.  In pure functional languages, the syntax looks like in such a way that it has no difference from calling functions with several arguments. <br><br>  But because Ramda is a JavaScript library, and JavaScript does not have a good syntax for calling a series of single-argument functions, the authors have somewhat softened the traditional definition of currying. <br><br>  In Ramda, a curried function can be called with a subset of its arguments, and it will return a new function that will wait for the remaining arguments.  If you call a curried function with all its arguments, it will trigger a normal function call. <br><br>  You can think of curried functions as the best of two worlds: you can call them with all the arguments, and they will just work.  Or you can call them with part of the arguments, and they will work in partial application mode. <br><br>  Please note that this flexibility has little effect on performance, because for currying it is necessary to determine how the function was called and then determine what needs to be done.  In general, I use currying functions when I see that I need to use partial binding in more than one place. <br><br>  Let's apply the currying capabilities to our publishedInYear function.  Note that currying always works as if we were using the partial function, and there is no way to use a version like partialRight.  Next, we'll talk a little more on this topic, but for now we will simply change the arguments to reverse order in publishedInYear, so that the year begins to go first. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year, book</span></span></span><span class="hljs-function">) =&gt;</span></span> book.year === year) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books, year</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selected = filter(publishedInYear(year), books) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title, selected) }</code> </pre><br>  Now we can call publishedInYear once a year only and get back the function that will take the book and call our original function.  However, we can still call the usual publishedInYear (2012, book) without annoying) (syntax. The best of two worlds! <br><br><h2>  Argument order </h2><br>  Please note that in order to make currying work for us, we need to reverse the order of the arguments.  This is extremely common in functional programming, so almost every Ramda function is written so that the data it ultimately works with is the most recent in the argument list. <br><br>  You can think of the first parameters as a configuration for the operation.  So, for publishedInYear, the year parameter is a configuration (what are we looking for?), And a book parameter is data (where are we looking for?). <br><br>  We have already seen examples of this with iterative functions.  They all used the collection as a final argument, because it makes this programming style simpler. <br><br><h2>  Arguments in incorrect order </h2><br>  What if we leave the order of the publishedInYear function arguments unchanged?  How can we still benefit from the nature of currying? <br><br>  Ramda provides several options. <br><br><h2>  <a href="http://ramdajs.com/docs/">Flip</a> </h2><br>  The first option is flip.  Flip takes a function with two or more arguments and returns a new function that takes the same arguments, but reverses the first two arguments.  In most cases, it is used with two-argument functions, but is more general in use. <br><br>  Using flip, we can return to the original order of the arguments for publishedInYear: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book, year</span></span></span><span class="hljs-function">) =&gt;</span></span> book.year === year) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books, year</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selected = filter(flip(publishedInYear)(year), books) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title, selected) }</code> </pre><br>  In most cases, I would prefer to use a more convenient order of arguments, but, for example, if you need to use a function that you do not control, then flip is a useful option. <br><br><h2>  Aggregate </h2><br>  A more general option is the placeholder argument <a href="http://ramdajs.com/docs/">(__)</a> . <br><br>  What if we have a curried function with three arguments, and we want to pass the first and last arguments, leaving the one in the middle - for the future?  We can use the placeholder for the middle argument: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> threeArgs = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleArgumentLater = threeArgs(<span class="hljs-string"><span class="hljs-string">'value for a'</span></span>, __, <span class="hljs-string"><span class="hljs-string">'value for c'</span></span>)</code> </pre><br>  We can also use a substitute more than once in a call.  For example, what if we want to pass only the middle argument? <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> threeArgs = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b, c</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> middleArgumentOnly = threeArgs(__, <span class="hljs-string"><span class="hljs-string">'value for b'</span></span>, __)</code> </pre><br>  We can use the placeholder style instead of the flip if we want: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book, year</span></span></span><span class="hljs-function">) =&gt;</span></span> book.year === year) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books, year</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selected = filter(publishedInYear(__, year), books) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title, selected) }</code> </pre><br>  I find this version more readable, but if I need to reuse the ‚Äúinverted‚Äù version of publishedInYear, I can define an additional function using flip and then use it everywhere.  You may see some examples in future posts. <br><br>  Note that __ works only with curried functions, when partial, partialRight and flip work with any function.  If you need to use __ with a normal function, you can always wrap it with a curry call before that. <br><br><h2>  Let's do the conveyor </h2><br>  Let's see how we can move our filter and map calls to the inside of the pipeline.  This is the current state of the code, with a convenient order of arguments for publishedInYear: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year, book</span></span></span><span class="hljs-function">) =&gt;</span></span> book.year === year) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books, year</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selected = filter(publishedInYear(year), books) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title, selected) }</code> </pre><br>  We learned about pipe and compose in the last post, but we need to learn another piece of information to get the full benefit from this study. <br><br>  The last piece of information is as follows: almost every Ramda function is curried by default.  This includes filter and map.  So filter (publishedInYear (year)) fits perfectly and returns a new function that just waits for books to be transferred later, as well as map (book =&gt; book.title). <br><br>  And now we can write a pipeline: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year, book</span></span></span><span class="hljs-function">) =&gt;</span></span> book.year === year) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">books, year</span></span></span><span class="hljs-function">) =&gt;</span></span> pipe( filter(publishedInYear(year)), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title) )(books)</code> </pre><br>  Let's take a step forward and invert the arguments for titlesForYear to match the Ramda data agreements last.  We can also curry a function to allow it to be used in subsequent pipelines. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> publishedInYear = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year, book</span></span></span><span class="hljs-function">) =&gt;</span></span> book.year === year) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> titlesForYear = curry(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">year, books</span></span></span><span class="hljs-function">) =&gt;</span></span> pipe( filter(publishedInYear(year)), map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">book</span></span></span><span class="hljs-function"> =&gt;</span></span> book.title) )(books) )</code> </pre><br><h2>  Conclusion </h2><br>  This post may be the deepest part of this series of articles.  Partial application and currying may take some time and effort to keep within your head.  But when you ‚Äúget‚Äù them once, they will introduce you to a very powerful way to convert data in a functional way. <br><br>  They force us to make transformations on the basis of pipelines consisting of small simple building blocks. <br><br><h2>  Further </h2><br>  In order to start writing in a functional style, we need to start thinking ‚Äúdeclaratively‚Äù instead of ‚Äúimperatively‚Äù.  To do this, we will have to find ways to express imperative constructions in a functional style.  <a href="https://habrahabr.ru/post/349674/">An article on declarative programming</a> will discuss these ideas. </div><p>Source: <a href="https://habr.com/ru/post/349140/">https://habr.com/ru/post/349140/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../349128/index.html">Monitor communication channels via Juniper RPM and Zabbix</a></li>
<li><a href="../349130/index.html">How we helped digitize the age-old history of weather observations in Brazil</a></li>
<li><a href="../349134/index.html">Rust: We get acquainted with the language on the example of "Guess-ki"</a></li>
<li><a href="../349136/index.html">Universal React + Express Applications (continued)</a></li>
<li><a href="../349138/index.html">Comparison: Docker swarm, Kubernetes, Rancher and D2C</a></li>
<li><a href="../349144/index.html">TOP-10. Analysis of the best reports in the public domain. Heisenbug 2017 Moscow</a></li>
<li><a href="../349146/index.html">Configuring Zones on Solaris 11.3</a></li>
<li><a href="../349148/index.html">Answers to common questions about the render prop template</a></li>
<li><a href="../349150/index.html">How to get to the top of Product Hunt</a></li>
<li><a href="../349154/index.html">11 more useful tools for developers and designers with Product Hunt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>