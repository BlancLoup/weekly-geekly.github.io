<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Tuples in programming languages. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Now in many programming languages ‚Äã‚Äãthere is such a construction as tuples. Somewhere tuples in one way or another are built into the language, someti...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Tuples in programming languages. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Now in many programming languages ‚Äã‚Äãthere is such a construction as tuples.  Somewhere tuples in one way or another are built into the language, sometimes - again in one way or another - are implemented by means of libraries.  C ++, C #, D, Python, Ruby, Go, Rust, Swift (as well as Erlang, F #, Groovy, Haskell, Lisp, OCaml and many others) ... <br>  What is a tuple?  Wikipedia gives a fairly precise <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25BE%25D1%2580%25D1%2582%25D0%25B5%25D0%25B6_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">definition</a> : a tuple is an ordered set of fixed length.  The definition, though accurate, is useless for us, and here's why: do most programmers think, why was this entity necessary?  In programming, there are many data structures, both fixed and variable length;  they allow you to store different values ‚Äã‚Äã- both single-type and different types.  Various arrays, associative arrays, lists, structures ... why else and tuples?  And in languages ‚Äã‚Äãwith weak typing - and even more so, the difference between tuples and lists / vectors is completely blurry ... well, you cannot add elements to a tuple, so what?  This may be misleading.  Therefore, it is worthwhile to dig deeper and figure out why tuples are really needed, how they differ from other language constructs, and how to form an ideal syntax and semantics of tuples in an ideal (or close to ideal) programming language. <br><br>  In the first part, we will consider tuples and tuple-like constructions in common and not very programming languages.  In the second part, I will try to summarize and expand and propose the most universal syntax and semantics of tuples. <br><a name="habracut"></a><br>  The first important thing that was not mentioned on Wikipedia: a tuple is a compile-time structure.  In other words, it is a kind of entity that unites some objects at the compilation stage.  And this is very important.  Tuples are implicitly used in all programming languages, even in C and Assembler.  Let's look for them in the same C, C ++, in any compiled language. <br>  So, the function argument list is a tuple; <br>  The initialization list of a structure or array is also a tuple; <br>  The argument list of the template or macro is also a tuple. <br>  The structure description, and even the usual code block, is also a tuple;  only its elements are not objects, but syntactic constructions. <br><br>  The tuples in the program are much larger than they appear at first glance.  But they are all implicit;  anyway, they are tightly bolted to some syntactic constructs.  Explicit use of tuples in the old languages ‚Äã‚Äãwas not provided.  In more modern languages, some possibilities of explicit use have begun to appear - but by no means all.  Here we will consider mainly tuples of values ‚Äã‚Äã- either variables or constants.  Perhaps in the following sections I will consider the tuples of arbitrary syntax elements. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Let's start with the most obvious - returning multiple values ‚Äã‚Äãfrom a function.  Ever since school, I was surprised at such an injustice: why can a function take as many values ‚Äã‚Äãas it wants, and return only one?  Indeed, why is y = x * x a normal parabola, and y = sqrt (x) is some kind of trimmed half garbage?  Is this not a violation of mathematical harmony?  In programming, of course, you can return a structural object, but the essence remains the same: one object is returned, not several. <br><br>  Direct implementation of multiple returns is in <b>Go</b> .  A function can explicitly return multiple values.  The syntax allows you to assign these multiple values ‚Äã‚Äãto several variables, as well as perform group assignments and even permutations of the arguments in one operation.  However, no other group actions other than assignment are provided. <br><pre><code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r1 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, r2 </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span> } x, y := foo() x, y = <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span> x, y = y, x</code> </pre> <br>  An interesting feature that you should pay attention to is the ‚Äúbatch‚Äù transfer of several return values ‚Äã‚Äãof one function to another function. <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, y </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { } bar(foo())</code> </pre> <br><br>  Such a packet transmission is in itself extremely interesting.  On the one hand, she seems quite elegant;  but on the other hand, it is too ‚Äúimplicit‚Äù, non-universal.  For example, if you try to add a third argument to bar, and try to combine the ‚Äúpacket‚Äù transmission and the normal <br><pre> <code class="go hljs">bar(foo(), <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  then it won't work - compile error. <br><br>  Another interesting aspect is the non-use of return values.  Recall C / C ++.  In them (as well as in the overwhelming majority of other languages ‚Äã‚Äã- Java, C #, ObjC, D ...) you could safely ignore the returned values ‚Äã‚Äãwhen calling the function.  In Go, this is also possible, and you can ignore both the single return value and the group.  However, attempting to use the first return value and implicitly ignore the second results in a compilation error.  It is possible to ignore, but explicitly - using the special character "_": <br><pre> <code class="go hljs">x, _ := foo()</code> </pre> <br>  Those.  the ‚Äúall or nothing‚Äù principle works: you can either ignore all return values, or use ‚Äî but also everything. <br><br>  <b>Rust</b> has similar features.  Similarly, functions can return multiple values;  You can also initialize them with new values.  In this case, the multiple assignment as such is absent, only initialization is possible.  Similarly, you can use the "_" symbol for unused values.  Similarly, you can ignore the returned values ‚Äã‚Äãcompletely, or get them all completely.  Also tuples can be compared: <br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> x = (<span class="hljs-number"><span class="hljs-number">1</span></span>i, <span class="hljs-number"><span class="hljs-number">2</span></span>i, <span class="hljs-number"><span class="hljs-number">3</span></span>i); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = (<span class="hljs-number"><span class="hljs-number">2</span></span>i, <span class="hljs-number"><span class="hljs-number">3</span></span>i, <span class="hljs-number"><span class="hljs-number">4</span></span>i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x == y { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"yes"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"no"</span></span>); }</code> </pre> <br>  We note this fact: we encountered the first operation on tuples, different from assignment.  Also here there is another interesting possibility - the creation of named tuples and their subsequent use "as a whole". <br><br>  In <b>Swift, the</b> possibilities are generally similar.  Of the interesting - access to the elements of the tuple at a constant index through the point;  the ability to assign names to elements of a tuple and access elements through them. <br><br><pre> <code class="hljs lisp">let httpStatus = (<span class="hljs-name"><span class="hljs-name">statusCode</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, description: <span class="hljs-string"><span class="hljs-string">"OK"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"The status code is \(httpStatus.0)"</span></span>) print(<span class="hljs-string"><span class="hljs-string">"The status code is \(httpStatus.statusCode)"</span></span>)</code> </pre> <br><br>  Such tuples are already close to structures, but all the same structures are not.  And here I would like to move away from the examples and move on to my own thoughts.  The difference between tuples and structures is that a tuple is not a data type, it is something lower level;  it can be said that a tuple is simply a (possibly named) group of (possibly named) compile-time objects.  In this place, recall the languages ‚Äã‚ÄãC / C ++.  The simplest array initialization structures and structures look like this: <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}; Point3D pt = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> <br>  Note that the initialization lists are generally identical in this case.  And yet, they initialize completely different data objects.  This behavior is generally not typical of a data type.  But on the other hand, it is close to another interesting feature, which is sometimes (but rarely) found in programming languages ‚Äã‚Äã- <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural typing</a> .  The construction in braces is a typical tuple.  By the way, in C there is a named initialization of the structure fields (the idea is very similar to Swift, by the way), which has not yet been dragged into C ++ 17: <br><pre> <code class="cpp hljs">Point3D pt = {.x=<span class="hljs-number"><span class="hljs-number">1</span></span>, .y=<span class="hljs-number"><span class="hljs-number">2</span></span>, .z=<span class="hljs-number"><span class="hljs-number">3</span></span>};</code> </pre> <br><br>  In <b>C ++, we</b> went a bit in a different direction: we introduced the concept of "unified initialization syntax and initialization lists".  Syntactically, these are the same tuples that can be used to initialize objects;  In addition to the old features, the unified initialization syntax allows you to transfer objects to functions and return them from functions as tuples. <br><pre> <code class="cpp hljs"> Point3D pt{<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>,<span class="hljs-number"><span class="hljs-number">30</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//    Point3D foo(Point3D a) { return {1, 2, 3}; //  "" } foo( {3,2,1} ); //  ""</span></span></code> </pre> <br><br>  Another interesting feature is initialization lists. They are used to initialize dynamic data structures, such as vectors and lists.  Initialization lists in C ++ must be uniform, that is, all elements of the list must be of the same type.  Technically, such lists form constant arrays in memory, for access to which the iterators std :: initializer_list are used.  We can say that the template type std :: initializer_list is a special interface defined on the compiler level for uniform tuples (and in fact to constant arrays).  Of course, initialization lists can be used not only in constructors, but also as arguments of any functions and methods.  I think if in C ++ there would initially be some kind of template data type corresponding to a literal array and containing information about the length of this array, it would be quite suitable for the role of std :: initializer_list. <br><br>  Also in the standard C ++ library (and in Boost) there are tuples implemented using templates.  Since this implementation is not part of the language, the syntax is slightly cumbersome and non-universal.  Thus, the type of a tuple has to be declared explicitly with the types of all fields indicated;  to construct objects, use the function std :: make_tuple;  to create a tuple "on the fly" (from existing variables), another pattern is used - tie, and accessing elements is done using a special template method that requires a constant index. <br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tuple&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>,<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>&gt; t1(<span class="hljs-number"><span class="hljs-number">10</span></span>,<span class="hljs-string"><span class="hljs-string">'x'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t2 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_tuple (<span class="hljs-string"><span class="hljs-string">"test"</span></span>, <span class="hljs-number"><span class="hljs-number">3.1</span></span>, <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-string"><span class="hljs-string">'y'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> myint; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> mychar; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::tie (myint, mychar) = t1; <span class="hljs-comment"><span class="hljs-comment">// unpack elements std::tie (std::ignore, std::ignore, myint, mychar) = t2; // unpack (with ignore) std::get&lt;2&gt;(t2) = 100; char mychr = std::get&lt;3&gt;(t2);</span></span></code> </pre> <br>  The example uses unpacking with the special value std :: ignore.  This exactly corresponds to the underscore "_" used for the same purpose for group returns from functions in Go and Rust. <br><br>  In a similar way (although simplified compared to C ++), tuples are implemented in <b>C #</b> .  For the creation, the methods Tuple.Create (), a set of template classes Tuple &lt;&gt; are used, for access to the elements - fields with fixed names Item1 ... item8 (which is used to achieve index constancy). <br><br>  In the <b>D</b> language there is a rather rich support of tuples.  Using the tuple construct, you can form a tuple, and - including - perform multiple returns from a function.  To access elements of a tuple, indexing with constant indices is used.  You can also construct a tuple using the Tuple pattern, which allows you to create a tuple with named fields. <br><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t = Tuple!(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-string"><span class="hljs-string">"number"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-string"><span class="hljs-string">"message"</span></span>)(<span class="hljs-number"><span class="hljs-number">123</span></span>, <span class="hljs-string"><span class="hljs-string">"hello"</span></span>); writeln(<span class="hljs-string"><span class="hljs-string">"by index 0 : "</span></span>, t[<span class="hljs-number"><span class="hljs-number">0</span></span>]); writeln(<span class="hljs-string"><span class="hljs-string">"by .number : "</span></span>, t.number); writeln(<span class="hljs-string"><span class="hljs-string">"by index 1 : "</span></span>, t[<span class="hljs-number"><span class="hljs-number">1</span></span>]); writeln(<span class="hljs-string"><span class="hljs-string">"by .message: "</span></span>, t.message);</code> </pre> <br><br>  Tuples can be passed to functions.  For this, indexing with a range is applied.  Syntactically, it looks as if one argument is being passed, and in fact, the tuple is expanded into several arguments at once.  At the same time, in D, unlike Go, there is no requirement for exact equality of the number of arguments of the function and elements of the tuple, that is, you can mix the transmission of single arguments and tuples. <br><pre> <code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bar</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> i, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params"> d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> c)</span></span></span><span class="hljs-function"> </span></span>{ } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> t = tuple(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"2"</span></span>, <span class="hljs-number"><span class="hljs-number">3.3</span></span>, <span class="hljs-string"><span class="hljs-string">'4'</span></span>); bar(t[<span class="hljs-number"><span class="hljs-number">0</span></span>], t[$<span class="hljs-number"><span class="hljs-number">-2.</span></span>.$]);</code> </pre> <br>  In D, there are still many possibilities associated with tuples ‚Äî Compile-time foreach to bypass the tuples at compile time, the AliasSeq template, the tupleof operator ... in general, all this requires a separate large article. <br><br>  And finally, let's consider the implementation of tuples in a little-known extension of the C language - CForAll or C‚àÄ ( <i>funny, but at the time of writing this article I could not google the language site - it is very likely that it was closed long ago and there were simply no references left; that is why I regularly scan the network for New programming languages ‚Äã‚Äãand downloading everything I can reach</i> ). <br><br>  Tuples in C‚àÄ can be declared at the language level, enclosing the list of objects in square brackets.  A tuple type is created in the same way - a list of types is enclosed in square brackets.  Objects and types of tuples can be declared explicitly.  Tuples can be passed to functions, where they are expanded into argument lists (as opposed to Go, where this is possible only if the tuple exactly coincides with the function argument list). <br><pre> <code class="hljs pgsql">[ <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> ] w1; // -    [ <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span> ] w2; // -    <span class="hljs-type"><span class="hljs-type">void</span></span> f (<span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>, <span class="hljs-type"><span class="hljs-type">int</span></span>); // ,    f( <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> ); //   f( [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> ] ); // -     f( w1, <span class="hljs-number"><span class="hljs-number">3</span></span> ) //    f( w2 ) // -</code> </pre> <br>  Another interesting topic is nested tuples and the rules for their disclosure.  C / C ++ also uses nesting - when initializing arrays of structures whose elements are also arrays and structures.  In C‚àÄ, there are rules called ‚Äútuple coercions‚Äù, in particular, disclosure of tuples with internal structure (flattering) and vice versa, structuring, when a ‚Äúflat‚Äù tuple adapts to a complex internal structure (although this possibility is quite controversial, the discussion will be in the next part).  And all this applies only to assignment, there is no mention of using these features with other operations. <br><pre> <code class="hljs swift">[ a, b, <span class="hljs-built_in"><span class="hljs-built_in">c</span></span>, d ] = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, [ <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> ], <span class="hljs-number"><span class="hljs-number">4</span></span> ];</code> </pre> <br>  C‚àÄ provides both group and multiple assignments. <br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta"> x, y, z </span></span>] = <span class="hljs-number"><span class="hljs-number">1.5</span></span>; [ x, y, z ] = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span> ];</code> </pre> <br>  and even using tuples to access structure fields <br><pre> <code class="hljs">obj.[ f3, f1, f2 ] = [ x , 11, 17 ];</code> </pre> <br>  Due to the lack of a compiler, it was not possible to test all these possibilities in practice, but this is certainly an excellent food for thought.  Actually, the next part of the article will be devoted to these reflections. </div><p>Source: <a href="https://habr.com/ru/post/276871/">https://habr.com/ru/post/276871/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../276859/index.html">Foster Day at the Foreign Ministry</a></li>
<li><a href="../276863/index.html">ARP: Cisco equipment features and interesting cases. Part 1</a></li>
<li><a href="../276865/index.html">Bind additional one-time passwords to the Windows logon window</a></li>
<li><a href="../276867/index.html">Study of virtual hosting tariffs</a></li>
<li><a href="../276869/index.html">And again about storing files, and how to quickly find the right one.</a></li>
<li><a href="../276873/index.html">43 useful project management services. No epithets</a></li>
<li><a href="../276877/index.html">PCs, laptops and everything.</a></li>
<li><a href="../276879/index.html">Wifi-radio with a warm lamp display. Part 1. Display</a></li>
<li><a href="../276881/index.html">Meet Jack and Jill on x86</a></li>
<li><a href="../276883/index.html">Nuget ++ for the poor</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>