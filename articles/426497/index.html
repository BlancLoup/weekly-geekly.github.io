<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>CPU cores or what SMP is and what it is eaten with</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Good day, today I would like to touch on a fairly simple topic that almost no ordinary programmer knows, but each of you, most likely, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>CPU cores or what SMP is and what it is eaten with</h1><div class="post__text post__text-html js-mediator-article"><h2>  Introduction </h2><br>  Good day, today I would like to touch on a fairly simple topic that almost no ordinary programmer knows, but each of you, most likely, used it. <br>  It will be about symmetric multiprocessing (SMP in the people) - an architecture that is found in all multi-tasking operating systems, and of course, is an integral part of them.  Everyone knows that the more cores the processor has - the more powerful the processor will be, yes it is, but how can the OS use several cores at the same time?  Some programmers do not descend to this level of abstraction - they simply don‚Äôt need it, but I think everyone will be interested in how SMP works. <br><a name="habracut"></a><br><h2>  Multitasking and its implementation </h2><br>  Those who have ever studied computer architecture know that the processor itself is not able to perform several tasks at once, multitasking gives us only the operating system, which switches these tasks.  There are several types of multitasking, but the most adequate, convenient and widely used is preemptive multitasking (you can read its main aspects on wikipedia).  It is based on the fact that each process (task) has its own priority, which affects how much processor time it will be allocated.  Each task is given one quantum of time, during which the process does something, after the expiration of the quantum of time, the OS transfers control to another task.  The question arises - how to allocate computer resources, such as memory, devices, etc.  between processes?  Everything is very simple: Windows does it itself, Linux uses the semaphore system.  But one core is not serious, we go further. <br><br><h3>  Interrupts and PICs </h3><br>  Perhaps for some it will be news, for someone it will not, but the i386 architecture (I‚Äôll talk about x86 architecture, ARM doesn‚Äôt count, because I haven‚Äôt studied this architecture, and I have never come across it (even at the level of writing some service or resident program)) uses interrupts (we will only talk about hardware interrupts, IRQ) in order to notify the OS or program of a particular event.  For example, there is a 0x8 interrupt (for the protected and long modes, for example, 0x20, depending on how to configure the PIC, more on this later), which is called by PIT, which, for example, can generate interrupts with any necessary frequency.  Then the work of the operating system for distributing time slices is reduced to 0, when an interrupt is called, the program stops working, and control is given, for example, to the kernel, which in turn stores the current program data (registers, flags, etc.) and gives control to the next process . <br><br>  As you probably understood, interrupts are functions (or procedures) that are called at any time by the hardware, or by the program itself.  In total, the processor supports 16 interrupts on two PICs.  The processor has flags, and one of them - the flag "I" - Interrupt Control.  By setting this flag to 0, the processor will not trigger any hardware interrupts.  But, I also want to note that there are so-called NMI - Non-Maskable Interrupts - these interrupts will still be called, even if the I bit is set to 0. Using the PIC programming, you can disable these interrupts, but after returning from any interrupt using IRET - they will not be banned again.  I note that you cannot track an interrupt call from under a normal program ‚Äî your program stops running and it doesn‚Äôt even notice it after some time (yes, you can check what caused the interruption ‚Äî but why? 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h5>  PIC - Programmable Interrupt Controller </h5><br>  From wiki: <br><blockquote>  As a rule, it is an electronic device, sometimes made as part of the processor itself, or else its complex microcircuits, whose inputs are electrically connected to the corresponding outputs of various devices.  The input number of the interrupt controller is indicated by "IRQ".  This number should be distinguished from the interrupt priority, as well as from the number of the entry in the interrupt vector table (INT).  For example, in the IBM PC in real mode of operation (in this mode MS-DOS works) of the processor, the interrupt from the standard keyboard uses IRQ 1 and INT 9. <br><br>  The original IBM PC platform uses a very simple interrupt scheme.  The interrupt controller is a simple counter that either sequentially goes through the signals of different devices or is reset to the beginning when a new interrupt is found.  In the first case, the devices have equal priority, in the second device with a smaller (or larger when counting back) sequence number have a higher priority. </blockquote><br>  As you understand, this is an electronic circuit that allows devices to send interrupt requests, usually exactly 2. <br><br>  Now let's move on to the topic of the article itself. <br><br><h2>  SMP </h2><br>  To implement this standard, motherboards began to install new schemes: APIC and ACPI.  Let's talk about the first. <br><br>  APIC - Advanced Programmable Interrupt Controller, an improved version of the PIC.  It is used in multiprocessor systems and is an integral part of all the latest Intel processors (and compatible).  APIC is used for complex interrupt redirection and for sending interrupts between processors.  These things were not possible using the older PIC specification. <br><br><h3>  Local APIC and IO APIC </h3><br>  In an APIC-based system, each processor consists of a ‚Äúcore‚Äù and a ‚Äúlocal APIC‚Äù.  Local APIC is responsible for processing a processor-specific interrupt configuration.  In addition, it contains a local vector table (LVT), which translates events, such as ‚Äúinternal clock‚Äù and other ‚Äúlocal‚Äù interrupt sources, into an interrupt vector (for example, the LocalINT1 contact can raise an NMI exception, keeping ‚Äú 2 "to the appropriate input LVT). <br><br>  More information about local APIC can be found in the ‚ÄúSystem Programming Guide‚Äù for modern Intel processors. <br><br>  In addition, there is an APIC IO (for example, intel 82093AA), which is part of a chipset and provides multiprocessor interrupt control, including both static and dynamic symmetric distribution of interrupts for all processors.  In systems with multiple I / O subsystems, each subsystem can have its own set of interrupts. <br><br>  Each interrupt pin is individually programmed ‚Äúas either edge or level triggered‚Äù.  The interrupt vector and interrupt control information can be specified for each interrupt.  An indirect case access scheme optimizes the memory space required to access the internal APIC I / O registers.  To increase the flexibility of the system in assigning memory usage, the space of the two APIC I / O registers is relocatable, but by default it is 0xFEC00000. <br><br><h3>  Initialization of the ‚Äúlocal‚Äù APIC </h3><br>  Local APIC is activated at boot time and can be disabled by resetting bit 11 IA32_APIC_BASE (MSR) (this only works with processors with a family&gt; 5, since the Pentium does not have such MSR), The processor then receives its interrupts directly from the 8259 compatible PIC .  However, Intel‚Äôs software development guide states that after you turn off the local APIC via IA32_APIC_BASE, you will not be able to turn it on until it is completely reset.  The IO APIC can also be configured to work in legacy mode so that it emulates an 8259 device. <br><br>  Local APIC registers are mapped to the physical page FEE00xxx (see table 8-1 of the Intel P4 SPG).  This address is the same for each local APIC that exists in the configuration, which means that you can directly access the registers of the local APIC core where your code is currently running.  Please note that there is an MSR that defines the actual APIC base (available only for processors with a family&gt; 5).  MADT contains the local APIC base, and on 64-bit systems it may also contain a field defining a 64-bit redefinition of the base address, which you should use instead.  You can leave the local APIC database only where you find it, or move it to where you want.  Note: I do not think that you can move it further than the 4th GB RAM. <br><br>  To enable local APIC for receiving interrupts, you must configure the ‚ÄúSpurious Interrupt Vector Register‚Äù.  The correct value for this field is the IRQ number that you want the false interrupts to associate with the lower 8 bits, and the 8th bit, set to 1 to actually enable APIC (for more information, see the specification).  You must select the interrupt number, which is set to the lower 4 bits;  The easiest way to use is 0xFF.  This is important for some older processors, because for these values, the lower 4 bits must be set to 1. <br><br>  Disable the 8259 pic correctly.  This is almost as important as setting up an APIC.  You do this in two stages: masking all interrupts and reassigning the IRQ.  Masking all interrupts disables them in the PIC.  Interrupt re-mapping is something you probably already did when you used the PIC: you want interrupt requests to start at 32 instead of 0 to avoid conflicts with exceptions (in protected and long (Long) processor modes, because The first 32 interrupts are exceptions).  Then you should avoid using these interrupt vectors for other purposes.  This is necessary because, despite the fact that you masked all PIC interrupts, it could still produce false interrupts, which would then be incorrectly processed in your kernel as exceptions. <br>  Let's go to SMP. <br><br><h3>  Symmetric multitasking: initialization </h3><br>  The startup sequence is different for different CPUs.  The Intel Programmer's Guide (Section 7.5.4) contains an initialization protocol for Intel Xeon processors and does not cover older processors.  For a generic "all processor types" algorithm, see Intel's Multiprocessor Specification. <br><br>  For 80486 (with external APIC 8249DX), you must use IPIT INIT followed by IPI "INIT level de-assert" without any SIPI.  This means that you cannot tell them where to start executing your code (the SIPI vector part), and they always start executing the BIOS code.  In this case, you set the CMOS BIOS reset value to ‚Äúwarm start with far jump‚Äù (i.e. Set CMOS 0x0F to 10) for the BIOS to perform jmp far ~ [0: 0x0469] ‚Äù, and then set the segment and offset AP entry points at 0x0469. <br><br>  ‚ÄúINIT level de-assert‚Äù IPI is not supported on new processors (Pentium 4 and Intel Xeon), and AFAIK is completely ignored on these processors. <br><br>  For newer processors (P6, Pentium 4), one SIPI is enough, but I'm not sure that older Intel processors (Pentium) or processors from other manufacturers need a second SIPI.  It is also possible that a second SIPI exists in the event of a delivery failure for the first SIPI (bus noise, etc.). <br><br>  I usually send the first SIPI, and then wait to see if the AP increases the number of running processors.  If he does not increase this counter within a few milliseconds, I will send the second SIPI.  This is different from Intel‚Äôs general algorithm (which has a delay of 200 microseconds between SIPI), but trying to find a time source that can accurately measure a delay of 200 microseconds during early loading is not so easy.  I also found that on real hardware, if the delay between SIPI is too long (and you are not using my method), the master AP can run the early AP startup code for the OS twice (which in my case will cause the OS to think that we have two times more processors than we actually do). <br><br>  You can broadcast these signals over the bus to run each device present.  However, you can also turn on processors that were turned off specifically (because they were ‚Äúdefective‚Äù). <br><br><h3>  We are looking for information using the MT table </h3><br>  Some information (which may not be available on newer machines) for multiprocessing.  First you need to find the structure of the floating pointer MP.  It is aligned on a 16-byte boundary and contains a signature at the beginning of "_MP_" or 0x5F504D5F.  The OS should search in EBDA, BIOS ROM space and in the last kilobyte of the ‚Äúbase memory‚Äù;  the size of the base memory is specified in a 2-byte value in 0x413 in kilobytes, minus 1 KB.  Here is the structure: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_floating_pointer_structure</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> configuration_table; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> length; <span class="hljs-comment"><span class="hljs-comment">// In 16 bytes (eg 1 = 16 bytes, 2 = 32 bytes) uint8_t mp_specification_revision; uint8_t checksum; // This value should make all bytes in the table equal 0 when added together uint8_t default_configuration; // If this is not zero then configuration_table should be // ignored and a default configuration should be loaded instead uint32_t features; // If bit 7 is then the IMCR is present and PIC mode is being used, otherwise // virtual wire mode is; all other bits are reserved }</span></span></code> </pre> <br>  Here is the configuration table, which is indicated by a floating pointer structure: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">mp_configuration_table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> signature[<span class="hljs-number"><span class="hljs-number">4</span></span>]; <span class="hljs-comment"><span class="hljs-comment">// "PCMP" uint16_t length; uint8_t mp_specification_revision; uint8_t checksum; // Again, the byte should be all bytes in the table add up to 0 char oem_id[8]; char product_id[12]; uint32_t oem_table; uint16_t oem_table_size; uint16_t entry_count; // This value represents how many entries are following this table uint32_t lapic_address; // This is the memory mapped address of the local APICs uint16_t extended_table_length; uint8_t extended_table_checksum; uint8_t reserved; }</span></span></code> </pre><br>  After the configuration table entries are entry_count, which contain more information about the system, followed by an extended table.  Entries are either 20 bytes to represent the processor, or 8 bytes for something else.  Here's what the APIC and I / O entries look like. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_processor</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 0 uint8_t local_apic_id; uint8_t local_apic_version; uint8_t flags; // If bit 0 is clear then the processor must be ignored // If bit 1 is set then the processor is the bootstrap processor uint32_t signature; uint32_t feature_flags; uint64_t reserved; }</span></span></code> </pre><br>  Here is the IO APIC entry. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">entry_io_apic</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> type; <span class="hljs-comment"><span class="hljs-comment">// Always 2 uint8_t id; uint8_t version; uint8_t flags; // If bit 0 is set then the entry should be ignored uint32_t address; // The memory mapped address of the IO APIC is memory }</span></span></code> </pre><br><h3>  We are looking for information using APIC </h3><br>  You can find the MADT (APIC) table in ACPI.  The table lists the local APICs, the number of which should correspond to the number of cores on your processor.  Details of this table are not here, but you can find them on the Internet. <br><br><h3>  Run AP </h3><br>  After you have gathered the information, you need to disable the PIC and prepare for APIC I / O.  You also need to configure the local APIC's BSP.  Then start the AP using SIPI. <br><br>  <b>Startup code:</b> <br><br>  I note that the vector that you specify at startup says the starting address: vector 0x8 - address 0x8000, vector 0x9 - address 0x9000, etc. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ------------------------------------------------------------------------------------------------ static u32 LocalApicIn(uint reg) { return MmioRead32(*g_localApicAddr + reg); } // ------------------------------------------------------------------------------------------------ static void LocalApicOut(uint reg, u32 data) { MmioWrite32(*g_localApicAddr + reg, data); } // ------------------------------------------------------------------------------------------------ void LocalApicInit() { // Clear task priority to enable all interrupts LocalApicOut(LAPIC_TPR, 0); // Logical Destination Mode LocalApicOut(LAPIC_DFR, 0xffffffff); // Flat mode LocalApicOut(LAPIC_LDR, 0x01000000); // All cpus use logical id 1 // Configure Spurious Interrupt Vector Register LocalApicOut(LAPIC_SVR, 0x100 | 0xff); } // ------------------------------------------------------------------------------------------------ uint LocalApicGetId() { return LocalApicIn(LAPIC_ID) &gt;&gt; 24; } // ------------------------------------------------------------------------------------------------ void LocalApicSendInit(uint apic_id) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, ICR_INIT | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } // ------------------------------------------------------------------------------------------------ void LocalApicSendStartup(uint apic_id, uint vector) { LocalApicOut(LAPIC_ICRHI, apic_id &lt;&lt; ICR_DESTINATION_SHIFT); LocalApicOut(LAPIC_ICRLO, vector | ICR_STARTUP | ICR_PHYSICAL | ICR_ASSERT | ICR_EDGE | ICR_NO_SHORTHAND); while (LocalApicIn(LAPIC_ICRLO) &amp; ICR_SEND_PENDING) ; } void SmpInit() { kprintf("Waking up all CPUs\n"); *g_activeCpuCount = 1; uint localId = LocalApicGetId(); // Send Init to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) { LocalApicSendInit(apicId); } } // wait PitWait(200); // Send Startup to all cpus except self for (uint i = 0; i &lt; g_acpiCpuCount; ++i) { uint apicId = g_acpiCpuIds[i]; if (apicId != localId) LocalApicSendStartup(apicId, 0x8); } // Wait for all cpus to be active PitWait(10); while (*g_activeCpuCount != g_acpiCpuCount) { kprintf("Waiting... %d\n", *g_activeCpuCount); PitWait(10); } kprintf("All CPUs activated\n"); }</span></span></code> </pre><br><pre> <code class="hljs cs">[<span class="hljs-meta"><span class="hljs-meta">org 0x8000</span></span>] AP: jmp <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> bsp ;     -   BSP xor ax,ax mov ss,ax mov sp, <span class="hljs-number"><span class="hljs-number">0x7c00</span></span> xor ax,ax mov ds,ax ; Mark CPU <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> active <span class="hljs-keyword"><span class="hljs-keyword">lock</span></span> inc <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> [ds:g_activeCpuCount] ;   ,   jmp zop bsp: xor ax,ax mov ds,ax mov dword[ds:g_activeCpuCount],<span class="hljs-number"><span class="hljs-number">0</span></span> mov dword[ds:g_activeCpuCount],<span class="hljs-number"><span class="hljs-number">0</span></span> mov word [ds:<span class="hljs-number"><span class="hljs-number">0x8000</span></span>], <span class="hljs-number"><span class="hljs-number">0x9090</span></span> ;  JMP   <span class="hljs-number"><span class="hljs-number">2</span></span> NOP<span class="hljs-string"><span class="hljs-string">' ;   ,  </span></span></code> </pre><br>  Now, as you understand, in order for the OS to use many cores, you need to configure the stack for each core, each core, its interrupts, etc., but the most important thing is that when using symmetric multiprocessing, all the resources of the cores are the same: one memory one PCI, etc., and the OS can only parallelize tasks between cores. <br><br>  I hope that the article was not tedious enough, and quite informative.  Next time, I think you can talk about how you used to draw on the screen (and now draw), without using shaders and cool video cards. <br><br>  Good luck! </div><p>Source: <a href="https://habr.com/ru/post/426497/">https://habr.com/ru/post/426497/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../426487/index.html">Test automation from scratch. Part 1</a></li>
<li><a href="../426489/index.html">On the relationship of prime and irrational numbers</a></li>
<li><a href="../426491/index.html">Security Week 39: on the death of Google+</a></li>
<li><a href="../426493/index.html">Permanent discounts from hosters for VPS and VPS.today Search visitors</a></li>
<li><a href="../426495/index.html">Solo designer. How to build a career when you work alone</a></li>
<li><a href="../426499/index.html">Educational program for working with punch cards (or the story of how ‚Äúbig data‚Äù were processed from 1890 to 1970)</a></li>
<li><a href="../426501/index.html">Lamoda Inside: Why Online Store 300 Engineers</a></li>
<li><a href="../426503/index.html">SAP HANA functionality as a database for SAP HANA Data Management Suite</a></li>
<li><a href="../426505/index.html">Digital events in Moscow from October 15 to October 21</a></li>
<li><a href="../426507/index.html">Architecture creation: working with iOS Coordinator pattern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>