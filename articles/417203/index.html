<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Break STM8 stack</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the process of writing the STM8uLoader loader for STM8 microcontrollers, it became necessary to measure the stack depth. 

 Let us ask questions: 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Break STM8 stack</h1><div class="post__text post__text-html js-mediator-article">  In the process of writing the STM8uLoader loader for STM8 microcontrollers, it became necessary to measure the stack depth. <br><br>  Let us ask questions: <br><br><ul><li>  What happens if you try to push more information onto the stack than its depth? </li><li>  What happens if you try to extract more information from the stack than you put it? </li><li>  What will happen if I initialize the SP pointer of the stack address beyond the stack boundaries? </li></ul><a name="habracut"></a><br>  The amount of RAM memory and the depth of the stack for different models STM8 may vary. <br>  Model STM8S103F3 was selected for the study. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The documentation on the STM8S103F3 gives the following data: <br>  - stack depth 513 bytes; <br>  - when reset, the SP pointer is initialized to the value 0x03FF (RAM END); <br>  - the stack grows towards decreasing addresses. <br><br>  The calculation shows that the lower limit of the stack is: <br><br><pre><code class="hljs">0x03FF - 513 = 0x01FF</code> </pre> <br>  To break this boundary, you need to push a few more than 513 bytes on the stack. <br><br>  The contents of the stack itself do not interest us.  It is enough to know the contents of the SP stack pointer which should contain the address of the next RAM cell not occupied by the stack. <br>  We will consistently place the bytes with any ‚Äúpush‚Äù command (for example, ‚Äúpush A‚Äù) and send the contents of the higher SPH and lower SPL byte of the SP pointer to the UART before each step. <br><br>  Algorithm procedure: <br><br>  1 Initialize the stack pointer with the value 0x03FF and configure the UART; <br>  2 We are waiting for any byte from the terminal program; <br>  3 Bytes received; <br>  4 Send the contents of the SP pointer to the UART; <br>  5 We push the contents of the battery with the command ‚Äúpush A‚Äù; <br>  6 If the send cycles are less than 64, go to step 4; <br>  7 If the send cycle is 64, go to step 2. <br><br><pre> <code class="hljs haskell">;  <span class="hljs-type"><span class="hljs-type">UART</span></span> <span class="hljs-number"><span class="hljs-number">9600</span></span>/<span class="hljs-number"><span class="hljs-number">8</span></span>N1 mov <span class="hljs-type"><span class="hljs-type">UART1_BRR2</span></span>, #$<span class="hljs-number"><span class="hljs-number">00</span></span> ;     mov <span class="hljs-type"><span class="hljs-type">UART1_BRR1</span></span>, #$<span class="hljs-number"><span class="hljs-number">0</span></span>D ;  / mov <span class="hljs-type"><span class="hljs-type">UART1_CR2</span></span>, #%<span class="hljs-number"><span class="hljs-number">00001100</span></span> ;   <span class="hljs-type"><span class="hljs-type">SP</span></span>  $<span class="hljs-number"><span class="hljs-number">03</span></span>FF ldw <span class="hljs-type"><span class="hljs-type">X</span></span>, #$<span class="hljs-number"><span class="hljs-number">03</span></span>FF ; <span class="hljs-type"><span class="hljs-type">X</span></span> &lt;= <span class="hljs-type"><span class="hljs-type">RAM</span></span> <span class="hljs-type"><span class="hljs-type">END</span></span> ldw <span class="hljs-type"><span class="hljs-type">SP</span></span>, <span class="hljs-type"><span class="hljs-type">X</span></span> ; <span class="hljs-type"><span class="hljs-type">SP</span></span> &lt;= <span class="hljs-type"><span class="hljs-type">X</span></span> ;     wait_rx_byte: btjf <span class="hljs-type"><span class="hljs-type">UART1_SR</span></span>, #<span class="hljs-number"><span class="hljs-number">5</span></span>, wait_rx_byte ; ld <span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">UART1_DR</span></span> ;   bset <span class="hljs-type"><span class="hljs-type">PB_DDR</span></span>,#<span class="hljs-number"><span class="hljs-number">5</span></span> bset <span class="hljs-type"><span class="hljs-type">PB_CR1</span></span>,#<span class="hljs-number"><span class="hljs-number">5</span></span> ldw <span class="hljs-type"><span class="hljs-type">Y</span></span>, #<span class="hljs-number"><span class="hljs-number">64</span></span> ; <span class="hljs-type"><span class="hljs-type">Y</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">64</span></span> stack_cycle: ldw <span class="hljs-type"><span class="hljs-type">X</span></span>, <span class="hljs-type"><span class="hljs-type">SP</span></span> ; <span class="hljs-type"><span class="hljs-type">X</span></span> &lt;= <span class="hljs-type"><span class="hljs-type">SP</span></span> ;  <span class="hljs-type"><span class="hljs-type">SPH</span></span>  <span class="hljs-type"><span class="hljs-type">UART</span></span> ; rlwa <span class="hljs-type"><span class="hljs-type">X</span></span> ; <span class="hljs-type"><span class="hljs-type">A</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">XH</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">XL</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">A</span></span> ld <span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">XH</span></span> ; <span class="hljs-type"><span class="hljs-type">A</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">XH</span></span> ld <span class="hljs-type"><span class="hljs-type">UART1_DR</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span> ; <span class="hljs-type"><span class="hljs-type">UART1_DR</span></span> &lt;= <span class="hljs-type"><span class="hljs-type">A</span></span> wait_tx_byte_XH: btjf <span class="hljs-type"><span class="hljs-type">UART1_SR</span></span>, #<span class="hljs-number"><span class="hljs-number">7</span></span>, wait_tx_byte_XH ;  <span class="hljs-type"><span class="hljs-type">SPL</span></span>  <span class="hljs-type"><span class="hljs-type">UART</span></span> ; rlwa <span class="hljs-type"><span class="hljs-type">X</span></span> ; <span class="hljs-type"><span class="hljs-type">A</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">XH</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">XL</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">A</span></span> ld <span class="hljs-type"><span class="hljs-type">A</span></span>, <span class="hljs-type"><span class="hljs-type">XL</span></span> ; <span class="hljs-type"><span class="hljs-type">A</span></span> &lt;- <span class="hljs-type"><span class="hljs-type">XL</span></span> ld <span class="hljs-type"><span class="hljs-type">UART1_DR</span></span>, <span class="hljs-type"><span class="hljs-type">A</span></span> ; <span class="hljs-type"><span class="hljs-type">UART1_DR</span></span> &lt;= <span class="hljs-type"><span class="hljs-type">A</span></span> wait_tx_byte_XL: btjf <span class="hljs-type"><span class="hljs-type">UART1_SR</span></span>, #<span class="hljs-number"><span class="hljs-number">7</span></span>, wait_tx_byte_XL ;  <span class="hljs-type"><span class="hljs-type">A</span></span>   push <span class="hljs-type"><span class="hljs-type">A</span></span> ; <span class="hljs-type"><span class="hljs-type">M</span></span>(<span class="hljs-type"><span class="hljs-type">SP</span></span><span class="hljs-comment"><span class="hljs-comment">--) &lt;= A decw Y jrne stack_cycle ;   bres PB_DDR,#5 bres PB_CR1,#5 jra wait_rx_byte</span></span></code> </pre><br>  Observe how the terminal program consistently receives the contents of the SP pointer, starting with 0x03FF: <br><br><pre> <code class="hljs"> 03 FF 03 FE 03 FD 03 FC 03 FB 03 FA 03 F9 03 F8 03 F7 03 F6 03 F5 03 F4 03 F3 03 F2 03 F1 03 F0 03 EF 03 EE 03 ED 03 EC 03 EB 03 EA 03 E9 03 E8 03 E7 03 E6 03 E5 03 E4 03 E3 03 E2 03 E1 03 E0 03 DF 03 DE 03 DD 03 DC 03 DB 03 DA 03 D9 03 D8</code> </pre><br>  After the value has reached 0x01FF (previously calculated stack boundary) <br>  SP again took the value 0x03FF (stack closed in the ring) <br>  and began to overwrite the oldest data <br><br><pre> <code class="hljs"> 02 0F 02 0E 02 0D 02 0C 02 0B 02 0A 02 09 02 08 02 07 02 06 02 05 02 04 02 03 02 02 02 01 02 00 01 FF 03 FF 03 FE 03 FD 03 FC 03 FB 03 FA 03 F9 03 F8 03 F7 03 F6 03 F5 03 F4 03 F3 03 F2 03 F1 03 F0 03 EF 03 EE 03 ED 03 EC 03 EB 03 EA 03 E9</code> </pre><br>  Now consider how the contents of the SP pointer will behave if you try to unload the contents from the stack indefinitely. <br><br>  Algorithm procedure: <br><br>  1 Initialize the stack pointer with the value 0x03FF and configure the UART; <br>  2 We are waiting for any byte from the terminal program; <br>  3 Bytes received; <br>  4 Extract the contents of the stack with the command "pop A" in the battery; <br>  5 Sends the contents of the SP pointer to the UART; <br>  6 If the send cycles are less than 64, go to step 3; <br>  7 If the send cycle is 64, go to step 2. <br><br>  Paragraphs 4 and 5 of the algorithm and the ‚Äúpush A‚Äù command to the ‚Äúpop A‚Äù command were reversed. <br>  Despite the fact that we initialized the SP pointer to 0x03FF already after the first ‚Äúpop A‚Äù command, the pointer took the value 0x01FF and continued to increase towards 0x03FF. <br><br><pre> <code class="hljs"> 01 FF 02 00 02 01 02 02 02 03 02 04 02 05 02 06 02 07 02 08 02 09 02 0A 02 0B 02 0C 02 0D 02 0E 02 0F 02 10 02 11 02 12 02 13 02 14 02 15 02 16 02 17 02 18 02 19 02 1A 02 1B 02 1C 02 1D 02 1E 02 1F 02 20 02 21 02 22 02 23 02 24 02 25 02 26</code> </pre><br>  Reaching the value of 0x03FF.  after the next ‚Äúpop A‚Äù command, the pointer again took the value 0x01FF and continued to increase towards 0x03FF. <br><br><pre> <code class="hljs"> 03 EF 03 F0 03 F1 03 F2 03 F3 03 F4 03 F5 03 F6 03 F7 03 F8 03 F9 03 FA 03 FB 03 FC 03 FD 03 FE 03 FF 01 FF 02 00 02 01 02 02 02 03 02 04 02 05 02 06 02 07 02 08 02 09 02 0A 02 0B 02 0C 02 0D 02 0E 02 0F 02 10 02 11 02 12 02 13 02 14 02 15</code> </pre><br>  In the opposite direction, with an excessive number of pop (w) commands, the stack is also closed into a ring with a length of 513 bytes. <br><br>  The stack in STM8S103F3 is linear until you break one of its bounds 0x01FF or 0x03FF. <br><br>  As soon as you break one of the boundaries, the stack becomes a ring with a length of 513 bytes. <br>  No matter where in the ring (in the addresses 0x01FF ... 0x03FF) there will be the top / bottom of the stack, we can put an unlimited number of bytes on the stack, but we can extract no more than 513 not damaged bytes (the most "fresh"). <br><br>  Now that the stack is localized in the addresses 0x01FF ... 0x03FF, it is time to break this range when initializing the SP pointer. <br><br>  In paragraph 1 of the first procedure, we replace the value 0x03FF of the initialization of the SP pointer by the value 0x01FE. <br><br>  We observe how the stack from the address 0x01FE went in the direction of decreasing addresses. <br><br><pre> <code class="hljs"> 01 FE 01 FD 01 FC 01 FB 01 FA 01 F9 01 F8 01 F7 01 F6 01 F5 01 F4 01 F3 01 F2 01 F1 01 F0 01 EF 01 EE 01 ED 01 EC 01 EB 01 EA 01 E9 01 E8 01 E7 01 E6 01 E5 01 E4 01 E3 01 E2 01 E1 01 E0 01 DF 01 DE 01 DD 01 DC 01 DB 01 DA 01 D9 01 D8 01 D7</code> </pre><br>  Reaching the address 0x0000, the stack went out of the RAM memory and penetrated the FLASH ‚Äúmemory‚Äù cells inaccessible for the STM8S103F3. <br><br><pre> <code class="hljs"> 00 16 00 15 00 14 00 13 00 12 00 11 00 10 00 0F 00 0E 00 0D 00 0C 00 0B 00 0A 00 09 00 08 00 07 00 06 00 05 00 04 00 03 00 02 00 01 00 00 FF FF FF FE FF FD FF FC FF FB FF FA FF F9 FF F8 FF F7 FF F6 FF F5 FF F4 FF F3 FF F2 FF F1 FF F0 FF EF</code> </pre><br>  No calls of subroutines or interrupts are possible after the pointer leaves the RAM memory.  True, somewhere in the depths of the stack, the most ‚Äúancient‚Äù data still remained, which were fortunate enough to remain in RAM memory. <br><br>  Now we will try to extract data from the stack with ‚Äúforbidden‚Äù (outside the range 0x01FF ... 0x03FF) initialization of the SP pointer. <br><br>  Let's start with addresses outside of RAM.  In paragraph 1 of the second procedure, we replace the value 0x03FF of the initialization of the SP pointer by the value 0xFFF8. <br><br>  Observe how the stack went into RAM memory. <br><br><pre> <code class="hljs nginx"> <span class="hljs-attribute"><span class="hljs-attribute">FF</span></span> E9 FF EA FF EB FF EC FF ED FF EE FF EF FF F0 FF F1 FF F2 FF F3 FF F4 FF F5 FF F6 FF F7 FF F8 FF F9 FF FA FF FB FF FC FF FD FF FE FF FF <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">01</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">02</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">03</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">04</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">05</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">06</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">07</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">08</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">09</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span> 0A <span class="hljs-number"><span class="hljs-number">00</span></span> 0B <span class="hljs-number"><span class="hljs-number">00</span></span> 0C <span class="hljs-number"><span class="hljs-number">00</span></span> 0D <span class="hljs-number"><span class="hljs-number">00</span></span> 0E <span class="hljs-number"><span class="hljs-number">00</span></span> 0F <span class="hljs-number"><span class="hljs-number">00</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Crossing the lower border 0x01FF, the stack entered its territory. <br><br><pre> <code class="hljs"> 01 E9 01 EA 01 EB 01 EC 01 ED 01 EE 01 EF 01 F0 01 F1 01 F2 01 F3 01 F4 01 F5 01 F6 01 F7 01 F8 01 F9 01 FA 01 FB 01 FC 01 FD 01 FE 01 FF 02 00 02 01 02 02 02 03 02 04 02 05 02 06 02 07 02 08 02 09 02 0A 02 0B 02 0C 02 0D 02 0E 02 0F 02 10</code> </pre><br>  Reaching the address 0x03FF, the stack is closed in a ring. <br><br><pre> <code class="hljs"> 03 E9 03 EA 03 EB 03 EC 03 ED 03 EE 03 EF 03 F0 03 F1 03 F2 03 F3 03 F4 03 F5 03 F6 03 F7 03 F8 03 F9 03 FA 03 FB 03 FC 03 FD 03 FE 03 FF 01 FF 02 00 02 01 02 02 02 03 02 04 02 05 02 06 02 07 02 08 02 09 02 0A 02 0B 02 0C 02 0D 02 0E 02 0F</code> </pre><br>  Findings: <br><br>  The stack in STM8S103F3 is capable of performing its duties only within the range 0x01FF ... 0x03FF. <br><br>  To get the greatest linear depth of the SP stack pointer in the STM8S103F3, you need to initialize with the value 0x03FF. <br><br>  The stack in STM8S103F3 is linear until you break the lower bound 0x01FF. <br>  As soon as you break the lower bound, the stack becomes a ring length of 513 bytes. </div><p>Source: <a href="https://habr.com/ru/post/417203/">https://habr.com/ru/post/417203/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../417185/index.html">Ultra-high-energy neutrinos emitted by radiant galaxies at the other end of the universe were first detected.</a></li>
<li><a href="../417189/index.html">How people "drowned" New Orleans</a></li>
<li><a href="../417193/index.html">Overview of the IT-market of cloud solutions for business</a></li>
<li><a href="../417197/index.html">What astronomers have already learned from the new map of the Milky Way from the Gaia space telescope</a></li>
<li><a href="../417201/index.html">Alexey Zinoviev about BigData + ML on jug.msk.ru</a></li>
<li><a href="../417207/index.html">Reference: Hyperloop Superfast Trains</a></li>
<li><a href="../417209/index.html">Neural networks from scratch. Overview of courses and articles in Russian, free of charge and without registration</a></li>
<li><a href="../417211/index.html">Nastolka for learning the basics of electrical circuits. Why not?</a></li>
<li><a href="../417215/index.html">Everything you need to know about the Python garbage collector</a></li>
<li><a href="../417219/index.html">Forget burger king! There is a leak of documents is more dangerous</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>