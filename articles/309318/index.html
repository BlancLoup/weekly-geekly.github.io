<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>4 types of memory leaks in javascript and how to deal with them</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article, we will look at common types of memory leaks in client-side JavaScript. We will also learn how to detect them using the Chrome Develo...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>4 types of memory leaks in javascript and how to deal with them</h1><div class="post__text post__text-html js-mediator-article"><p>  In this article, we will look at common types of memory leaks in client-side JavaScript.  We will also learn how to detect them using the Chrome Development Tools. </p><br><p><img src="https://habrastorage.org/files/5ef/6c3/71b/5ef6c371b76042f088becf369de4db2c.jpg" alt="timeline in Chrome Dev Tools"></p><a name="habracut"></a><br><p>  <em>Translator's note: the</em> first part of the article is full of translator's notes.  During the analysis of the material, it became clear that some points should be clarified separately. </p><br><h2>  Introduction </h2><br><p>  Memory leaks belong to the kind of tasks that each developer sooner or later faces.  Languages ‚Äã‚Äãwith automatic memory management do not solve all problems at once - there are still situations where memory leaks.  Leaks cause a whole class of different problems: user interface delays, freezes and even problems with other applications. </p><br><h3>  What is a memory leak? </h3><br><p>  Memory leak - memory that is no longer required by the application, but for some reason is not returned to the operating system or the <a href="https://ru.wikipedia.org/wiki/%25D0%2594%25D0%25B8%25D0%25BD%25D0%25B0%25D0%25BC%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25BE%25D0%25B5_%25D1%2580%25D0%25B0%25D1%2581%25D0%25BF%25D1%2580%25D0%25B5%25D0%25B4%25D0%25B5%25D0%25BB%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D0%25B8">pool of available memory</a> ( <em>translator's note:</em> <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%2583%25D1%2587%25D0%25B0_(%25D0%25BF%25D0%25B0%25D0%25BC%25D1%258F%25D1%2582%25D1%258C)">in a heap</a> ).  Programming languages ‚Äã‚Äãuse different approaches that reduce the risk of memory leaks, but the very problem of whether a specific piece of memory is still needed or not is <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_Management">algorithmically unsolvable</a> ( <em>translator's note:</em> it comes down to the <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8">problem of stopping</a> ).  In other words, only the developer can determine whether it is possible to return a specific piece of memory to the operating system.  Memory management in programming languages ‚Äã‚Äãis divided into manual and automatic.  The first type provides the developer with a set of tools to help directly interact with the memory.  In the second, there is a special process called the ‚Äúgarbage collector‚Äù ( <em>eng.</em> Garbage collector) that is called automatically and deletes the memory. </p><br><p>  <em>Translator's note:</em> this is described in more detail in Wikipedia: <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25B1%25D0%25BE%25D1%2580%25D0%25BA%25D0%25B0_%25D0%25BC%25D1%2583%25D1%2581%25D0%25BE%25D1%2580%25D0%25B0">garbage collection</a> , <a href="https://en.wikipedia.org/wiki/Manual_memory_management">manual memory management</a> , <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">garbage collection</a> . </p><br><h3>  Javascript memory management </h3><br><p>  JavaScript is a programming language with a built-in garbage collector.  The collector periodically checks which of the chunks allocated to the application remain ‚Äúreachable‚Äù from various parts of this application.  In other words, the garbage collector translates the question ‚Äúwhat memory is still needed?‚Äù To the question ‚Äúwhat memory can I access?‚Äù.  The difference seems insignificant, but this is not the case: although only the developer knows whether a fragment of allocated memory is required in the future or not, unreachable memory can be calculated algorithmically and marked for return to the OS. </p><br><p>  Languages ‚Äã‚Äãthat do not have garbage collectors work on different principles.  For example, there is an explicit memory management: the developer directly tells the compiler that this piece of memory can be deleted.  There is also a reference counting algorithm, in which the number of its uses is associated with each memory block (and when it is reset, the block returns to the OS).  These techniques have their pros and cons, and can lead to memory leaks. </p><br><p>  <em>Translator's note:</em> the reference counting algorithm is also used in garbage collectors.  In addition, it is worth noting that the operation of this algorithm in its basic form can lead to the emergence of circular references, in which unused objects link to each other, mutually blocking the deletion.  Read more - <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25B4%25D1%2581%25D1%2587%25D1%2591%25D1%2582_%25D1%2581%25D1%2581%25D1%258B%25D0%25BB%25D0%25BE%25D0%25BA">on Wikipedia</a> . </p><br><h2>  Javascript memory leaks </h2><br><p>  The main cause of memory leaks in languages ‚Äã‚Äãwith garbage collectors are <em>unwanted links</em> .  To understand what it is, let's first consider how the garbage collector checks the reachability of objects. </p><br><h3>  Mark-and-sweep algorithm </h3><br><p>  Most garbage collectors use the <em>mark-and-sweep</em> algorithm: </p><br><ol><li><p> The garbage collector builds a list of "root objects", or "roots."  As a rule, they become global variables declared in the code.  In JavaScript, the typical root is the <code>window</code> object.  Since the <code>window</code> exists throughout the entire operation of the page, the garbage collector will understand that this object and its descendants will always be present in the execution environment of the program (that is, they will not become garbage). </p><br></li><li><p>  The collector recursively circumvents the roots and their descendants, marking them as active (ie, not trash).  Everything that can be reached from the root is not considered as garbage. </p><br></li><li>  After the second step, fragments of memory that are not marked as active can be considered garbage.  Now the collector can free this memory and return it to the OS. </li></ol><br><p>  Modern garbage collectors improve this algorithm, but its essence remains the same: mark accessible fragments of memory, and declare the rest as garbage.  Now it is possible to define <em>unwanted links</em> ‚Äî these are links that are reachable from the root, but refer to fragments of memory that will never be needed again.  In JavaScript, <em>unwanted links</em> will become outdated variables, forgotten in the code, retaining in memory more unnecessary objects.  By the way, some believe that these are the mistakes of the developers, not the language. </p><br><p>  So, to figure out what usually causes memory leaks in JavaScript, we need to understand which situations lead to <em>unwanted links</em> . </p><br><p>  <em>Translator's note:</em> before reading further, I recommend to look at the MDN article on <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_Management">memory management</a> , which reveals the topic in more detail. </p><br><h2>  The four most common types of memory leaks in JavaScript </h2><br><p>  <em>Translator's note:</em> hereinafter in the examples we will consider client-side JavaScript.  It will be considered, without unnecessary clarifications and reservations, that we have a global <code>window</code> object.  In a different execution environment, the JavaScript <code>window</code> may not be present, but the reasons for the leaks discussed in the article will be relevant. </p><br><h3>  1: Random global variables </h3><br><p>  One of the goals in the development of JavaScript was to create a language similar to Java, but so weak that even beginners could work with it.  One of the easing of the language was the handling of undeclared variables: accessing such a variable will create a new variable in the <em>global</em> object.  Thus, if we consider the code: </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(arg)</span></span></span><span class="hljs-function"> </span></span>{ bar = <span class="hljs-string"><span class="hljs-string">"  "</span></span>; }</code> </pre> <br><p>  In fact, it means: </p><br><pre> <code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.bar = <span class="hljs-string"><span class="hljs-string">"   "</span></span>; }</code> </pre> <br><p>  If you want <code>bar</code> contain a reference to a variable only inside the scope of the <code>foo</code> function, but forget to specify <code>var</code> in the declaration, then a global variable will be created.  In this case, a simple string will create a memory leak.  It will not do much harm, but, of course, the situation could be much worse. </p><br><p>  Another way to create a random global variable is to use <code>this</code> : </p><br><pre> <code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.variable = <span class="hljs-string"><span class="hljs-string">"potential accidental global"</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//  foo    , this   //    (window), //  ,   undefined. foo();</span></span></code> </pre> <br><p>  To avoid such errors, add <code>'use strict'</code> ;  to the top of the javascript files.  This is a directive that includes a strict JavaScript parsing mode that prevents the occurrence of random global variables. </p><br><h4>  Note on global variables </h4><br><p>  Let's talk not about random, but about explicitly declared global variables.  By definition, they are not handled by the garbage collector, unless you equate them to <code>null</code> or reassign.  In particular, this applies to global variables used for the temporary storage and processing of large data blocks.  If you need a global variable to write a large amount of information into it, make sure that at the end of working with the data its value will be set to <code>null</code> or redefined. </p><br><p>  An example of increased memory consumption associated with global variables are <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D1%258D%25D1%2588">caches</a> ‚Äî objects that store reused data.  To work effectively, they should be limited in size.  If the cache grows without limits, it can lead to high memory consumption, since its contents cannot be cleared by the garbage collector. </p><br><h3>  2: Forgotten timers and callbacks </h3><br><p>  Such usage of the <code>setInterval</code> function is quite common: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> someResource = getData(); setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'Node'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(node) { <span class="hljs-comment"><span class="hljs-comment">//  -  node  someResource. node.innerHTML = JSON.stringify(someResource)); } }, 1000);</span></span></code> </pre> <br><p>  This example shows how harmful timers (that access nodes and data that are no longer needed) are harmful.  If you delete a node, the entire block inside the handler function becomes unnecessary.  But, as long as <code>setInterval</code> active, the handler is also active and cannot be cleared by the garbage collector (after all, to do this, you must first stop the interval).  So, its dependencies also can not be removed from memory.  We obtain that <code>someResource</code> , which probably stores a large amount of data, cannot be cleared by the garbage collector. </p><br><p>  Let's talk about callbacks.  Most often they are used in event handlers and in third-party libraries.  Libraries usually create their own event handlers and other support tools that handle callbacks.  Usually they also provide ways to remove external handlers after an object becomes unreachable. </p><br><p>  Now consider the situation with event handlers.  Handlers should be deleted when they are no longer needed, or the objects associated with them become unavailable.  In the past, this was critical, as some browsers (Internet Explorer 6) did not know how to correctly handle circular links (see note below).  Most modern browsers remove event handlers as soon as objects become unreachable.  However, it is still the rule of good taste to explicitly remove event handlers before deleting the object itself.  For example: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> element = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">event</span></span></span><span class="hljs-function">) </span></span>{ element.innerHtml = <span class="hljs-string"><span class="hljs-string">'text'</span></span>; } element.addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, onClick); <span class="hljs-comment"><span class="hljs-comment">// - . element.removeEventListener('click', onClick); element.parentNode.removeChild(element); // ,      , //      ,  onClick. //       , //      .</span></span></code> </pre> <br><h4>  A note about event handlers and circular references </h4><br><p>  Event handlers and circular references have long been considered a problem for JavaScript developers.  This was due to an error (or design solution) of the garbage collector in Internet Explorer.  Older versions of Internet Explorer could not detect circular references between DOM elements and JavaScript code.  Add to this that event handlers usually contain a reference to the event object (as in the example above).  This means that every time a listener was added to the DOM node in Internet Explorer, a memory leak occurred.  Therefore, web developers began to explicitly delete event handlers before removing DOM nodes or reset the links inside the handlers.  Modern browsers (including Internet Explorer and Microsoft Edge) use algorithms that find circular links and correctly process them.  Now it is not necessary to call <code>removeEventListener</code> before removing the node. </p><br><p>  Frameworks and libraries, such as jQuery, remove handlers before removing the node itself if the library API was used to create them.  This is done by the libraries themselves and ensures that there are no leaks, even when working with problem browsers, such as the old Internet Explorer. </p><br><h3>  3: Links to deleted items from DOM </h3><br><p>  Sometimes it is useful to store DOM nodes inside data structures.  Suppose you want to dot-update the contents of several rows in a table.  It makes sense to keep a reference to each DOM row in a dictionary or array.  In this case, two links will point to the same DOM element ‚Äî one in the DOM tree and the other in the dictionary.  If in the future you decide to delete these lines, you will need to make both links and other links unreachable. </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> elements = { <span class="hljs-attr"><span class="hljs-attr">button</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>), <span class="hljs-attr"><span class="hljs-attr">image</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'image'</span></span>), <span class="hljs-attr"><span class="hljs-attr">text</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'text'</span></span>) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doStuff</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ elements.image.src = <span class="hljs-string"><span class="hljs-string">'http://some.url/image'</span></span>; elements.button.click(); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(elements.text.innerHTML); <span class="hljs-comment"><span class="hljs-comment">//  . } function removeButton() { //     body. document.body.removeChild(document.getElementById('button')); //         #button //    elements. // ..        //       . }</span></span></code> </pre> <br><p>  In addition to this, you need to do something with references to the internal nodes of the DOM tree.  Suppose that we store in the code a link to some specific table cell (to the <code>&lt;td&gt;</code> ).  In the future, we decide to remove the table from the DOM, but save the reference to this cell.  Intuitively, we expect the garbage collector to clean everything except this cell.  However, in practice it will be different: since the cell is a descendant of the table, it stores references to its parents.  It turns out that a reference to a table cell will force the entire table to be stored in memory.  Consider this when you save references to DOM elements. </p><br><h3>  4: Closures </h3><br><p>  The core of JavaScript is closures: functions that receive variables from parent scopes.  The developers of Meteor <a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak">discovered a situation</a> in which, due to the nature of the implementation of the JavaScript runtime, you can create a memory leak in such a tricky way: </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> theThing = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> replaceThing = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> originalThing = theThing; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> unused = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (originalThing) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"hi"</span></span>); }; theThing = { <span class="hljs-attr"><span class="hljs-attr">longStr</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000000</span></span>).join(<span class="hljs-string"><span class="hljs-string">'*'</span></span>), <span class="hljs-attr"><span class="hljs-attr">someMethod</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(someMessage); } }; }; setInterval(replaceThing, <span class="hljs-number"><span class="hljs-number">1000</span></span>);</code> </pre> <br><p>  This example does one simple thing: each time <code>replaceThing</code> is <code>replaceThing</code> , <code>theThing</code> receives a new object containing a large string and a new closure ( <code>someMethod</code> ).  In this case, the <code>unused</code> variable contains a closure referencing <code>originalThing</code> (and this is <code>theThing</code> from the previous <code>replaceThing</code> call).  Already something confuses, right? </p><br><p>  It is important to note that since the scope is created for closures that are still in the same parent scope, this scope will be common.  In this case, the scope created to close <code>someMethod</code> is shared with <code>unused</code> .  <code>unused</code> stores the link to <code>originalThing</code> .  Although <code>unused</code> and not used, <code>someMethod</code> can be used in <code>theThing</code> .  Since <code>someMethod</code> shares the scope with <code>unused</code> , even if <code>unused</code> never used, its reference to the <code>originalThing</code> causes it to always remain active (that is, protect it from the garbage collector). </p><br><p>  With this code, you can observe a constant increase in memory usage.  The amount of memory does not decrease even when the garbage collector comes into play.  In fact, we create a list of associated closures (with the root as the <code>theThing</code> variable), and each of these closures contains a direct reference to the large string, which represents a significant memory leak.  This is an implementation artifact.  With a different implementation of closures, it is potentially possible to handle this situation, which is explained in the Meteor blog. </p><br><h2>  Non-obvious behavior of garbage collectors </h2><br><p>  Although garbage collectors are useful, they have their drawbacks, one of which is <em>non-determinism</em> .  This means that garbage collectors are unpredictable - it is usually impossible to determine when garbage collection will be made.  As a result, sometimes the program takes up more memory than is required.  There may also be short pauses, which will be especially noticeable in programs that quickly respond to actions. </p><br><p>  Non-determinism means that we cannot say for sure when garbage collection will take place, however, most implementations of garbage collectors have similar behavior.  If no memory allocation is performed, the garbage collector does not manifest itself.  Consider the following scenario: </p><br><ol><li>  There was a significant amount of memory allocation. </li><li>  Most of the items (and possibly all) were marked as unreachable (for example, we assigned <code>null</code> values ‚Äã‚Äãto links to unnecessary cache). </li><li>  Subsequent allocations are not performed. </li></ol><br><p>  In this case, most garbage collectors will not take further action.  In other words, although there are unreachable links that can be processed, the garbage collector will not affect them.  Due to such minor leaks, the application will consume more memory than necessary.  Google gave a great example of this behavior - <a href="https://developer.chrome.com/devtools/docs/demos/memory/example2">JavaScript Memory Profiling docs, example # 2</a> . </p><br><h2>  An overview of the profiling tools in Chrome </h2><br><p>  Chrome provides a set of tools for <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D1%2584%25D0%25B8%25D0%25BB%25D0%25B8%25D1%2580%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5_(%25D0%25B8%25D0%25BD%25D1%2584%25D0%25BE%25D1%2580%25D0%25BC%25D0%25B0%25D1%2582%25D0%25B8%25D0%25BA%25D0%25B0)">profiling</a> memory consumption in JavaScript.  There are two important tools for working with memory: the timeline tab and the profiles tab. </p><br><h3>  Timeline tab </h3><br><p><img src="https://habrastorage.org/files/89f/ca4/4e5/89fca44e5bc84bcba184a1419d66937e.png" alt="Timeline tab"></p><br><p>  The timeline tab is invaluable for detecting unusual memory behavior.  When searching for large leaks, pay attention to periodic jumps, slightly decreasing after garbage collection.  The screenshot shows the continuous growth of objects causing memory leaks.  Even after a large sweep at the end, the total amount of memory occupied is greater than at the beginning.  The number of DOM nodes also increases.  Everything indicates that there is a leak in the code associated with DOM nodes. </p><br><h3>  Profiles Tab </h3><br><p><img src="https://habrastorage.org/files/714/0b2/b13/7140b2b132824448b6357ddbe5894241.png" alt="Profiles Tab"></p><br><p>  You will spend most of your time working with this tab.  Profiles allow you to make memory snapshots and compare them with each other.  You can also record the process of distributing memory.  In any of the modes, different types of output are available, but most of all we are interested in the general list and the comparison list. </p><br><p>  The general list provides an overview of the different types of related objects and their set of sizes: <em>shallow size</em> (surface size, the sum of all objects of a particular type) and <em>retained size</em> (held size, surface size plus the size of other objects associated with a given).  It also gives us an idea of ‚Äã‚Äãhow far an object is from its root ( <em>distance</em> field). </p><br><p>  The comparison list provides us with the same information and makes it possible to compare different snapshots.  This is especially important for memory leak searches. </p><br><h2>  Example: Looking for bugs with Chrome </h2><br><p>  There are two main types of memory leaks: leaks that cause periodic increases in used memory and single leaks that do not cause further increases in memory.  Obviously, the easiest way to track periodic leaks.  In addition, they are the most dangerous: if the memory consumed is constantly increasing, in the end such leaks will slow down the browser or stop the execution of the script.  Non-periodic leaks are easy to find if they are large enough to recognize them among others.  Usually they do not cause serious problems, so they often remain undetected.  Leaks that happen only once can be considered only as optimization problems.  But periodic leaks are full-fledged bugs that need to be fixed. </p><br><p>  Consider the code from the <a href="https://developer.chrome.com/devtools/docs/demos/memory/example1">examples in the Chrome documentation</a> : </p><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">createSomeNodes</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> div, i = <span class="hljs-number"><span class="hljs-number">100</span></span>, frag = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createDocumentFragment(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (;i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; i--) { div = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">"div"</span></span>); div.appendChild(<span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createTextNode(i + <span class="hljs-string"><span class="hljs-string">" - "</span></span>+ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>().toTimeString())); frag.appendChild(div); } <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"nodes"</span></span>).appendChild(frag); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">grow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ x.push(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>(<span class="hljs-number"><span class="hljs-number">1000000</span></span>).join(<span class="hljs-string"><span class="hljs-string">'x'</span></span>)); createSomeNodes(); setTimeout(grow,<span class="hljs-number"><span class="hljs-number">1000</span></span>); }</code> </pre> <br><p>  The <code>grow</code> function, when invoked, will start creating <code>&lt;div&gt;</code> nodes and adding them to the DOM.  It will also associate a large string with them and attach it to an array created in the global scope.  This will cause a steady increase in memory, which can be detected using the tools we considered. </p><br><p>  For languages ‚Äã‚Äãwith garbage collectors, fluctuations in the memory schedule are characteristic.  This is expected if memory distribution is cyclical, as it usually happens.  We will look at periodic memory increases that do not return to their original state after a garbage collector has been processed. </p><br><h3>  How to detect a periodic increase in memory </h3><br><p>  For this we need the <em>timeline</em> tab.  <a href="https://developer.chrome.com/devtools/docs/demos/memory/example1">Open the example</a> in Chrome, open the Dev Tools, select the <em>timeline</em> , select the <em>memory</em> and click on the record.  Then go to the page and click <code>The Button</code> .  A memory leak will begin.  After some time, stop recording and look at the results. </p><br><p><img src="https://habrastorage.org/files/9ab/248/8d4/9ab2488d4afa493596e5ab0df0d92c53.png" alt="Timeline example"></p><br><p>  This example will continue to create memory leaks every second.  After stopping the recording, set a breakpoint in the <code>grow</code> function so that the script stops and prevents Chrome from closing the page.  In this screenshot, there are two large signs of memory leaks: the nodes graph (nodes, green line) and the JavaScript code graph (blue line).  DOM nodes are always increasing and never decreasing.  This is an occasion to think. </p><br><p>  A graph of javascript code also shows a constant increase in consumed memory.  It is more difficult to recognize because of the work of the garbage collector.  You can see how the memory initially increases, then its reduction follows, and then again an increase and a jump, followed by another decrease in memory, etc.  What is important in this situation is that after each memory clearing, its total size still remains larger than the previous one.  That is, although the garbage collector manages to free a significant amount of memory, anyway, some part of it leaks regularly. </p><br><p>  So now it is clear that we have a leak.  Let's find her. </p><br><h4>  Make two snapshots </h4><br><p>  To find a leak, move to the <em>profile</em> section.  To control the amount of memory, reload the page.  We need the function <em>Take Heap Snapshot</em> . </p><br><p>  Reload the page and take a picture immediately after it has finished downloading.  This picture we take as a basis.  After that, press <code>The Button</code> again, wait a couple of seconds and take a second shot.  After the snapshot is taken, it is better to put a breakpoint in the script to stop further memory consumption. </p><br><p><img src="https://habrastorage.org/files/fde/8cd/3ac/fde8cd3ac053400787f14e6da8e10804.png" alt="Snapshot example 1"></p><br><p>  There are two ways to track the spread of memory between two snapshots.  You can select <em>Summary</em> and then right-click on <em>Objects allocated between Snapshot 1 and Snapshot 2</em> or choose <em>Comparison</em> instead of <em>Summary</em> .  In both cases, we will see a list of objects that have emerged between the two snapshots. </p><br><p>  In this example, it is quite simple to detect leaks: they are large.  Pay attention to the <em>Size Delta</em> constructor <code>(string)</code> .  8 MB and 58 new objects.  :   ,   ,  8 MB. </p><br><p>         <code>(string)</code> ,       .   .    - ,  -    <em>retainers</em> . </p><br><p><img src="https://habrastorage.org/files/892/900/1c7/8929001c77c44c6c93582c0387efcd48.png" alt=" snapshot 2"></p><br><p>  ,       .   ,     <code>x</code>    .  ,         ‚Äî ,     .    .  Fine.     ‚Äî       .    DOM-,   .        ,        . Chrome   ,       ‚Äî  <em>Record Heap Allocations</em> . </p><br><h4>     Record Heap Allocations </h4><br><p>    ,  ,    .       .  <em>Record Allocation Timeline</em> .            ,   .        .     ,    (   ,  Chrome   ). </p><br><p><img src="https://habrastorage.org/files/98d/72e/1b0/98d72e1b0b6a4c86b4b6814c09fb9554.png" alt=" Record Heap Allocations"></p><br><p>   ,    :      ,       .      .       :        ( <code>(string)</code> ),  ‚Äî     DOM-,   ‚Äî  <code>Text</code> (  DOM-). </p><br><p>     <code>HTMLDivElement</code>     <em>Allocation stack</em> . </p><br><p><img src="https://habrastorage.org/files/f52/9ed/58a/f529ed58afd74dd298f5054d6464937b.png" alt="Record Heap Allocations ‚Äî  "></p><br><p>  Bingo!   ,      ( <code>grow</code> -&gt; <code>createSomeNodes</code> ).        ,  ,   <code>HTMLDivElement</code>   .        ,  ,       ,    . ,     ,          .    .   ,   ,       ( <code>createSomeNodes</code> ).        . </p><br><h4>     </h4><br><p> <em> :</em>    ,  Dev Tools -&gt; Settings   <em>"record heap allocation stack traces"</em> . </p><br><p>     <em>Allocation</em>  <em>Summary</em> : </p><br><p><img src="https://habrastorage.org/files/b99/ace/bd3/b99acebd3804479e985762dae93c723b.png" alt="  "></p><br><p>           .     <code>grow</code>  <code>createSomeNodes</code> .   <code>grow</code> ,      .   <code>(string)</code> , <code>HTMLDivElement</code>  <code>Text</code> , ,    ,   . </p><br><p>         .  Use them.        (       ). ,     ,  ,   ,   (  ). </p><br><h2>  Additional materials </h2><br><p> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management">Memory Management ‚Äî Mozilla Developer Network</a> <br> <a href="http://javascript.crockford.com/memory/leak.html">JScript Memory Leaks ‚Äî Douglas Crockford (old, in relation to Internet Explorer 6 leaks)</a> <br> <a href="https://developer.chrome.com/devtools/docs/javascript-memory-profiling">JavaScript Memory Profiling ‚Äî Chrome Developer Docs</a> <br> <a href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/memory-diagnosis">Memory Diagnosis ‚Äî Google Developers</a> <br> <a href="http://info.meteor.com/blog/an-interesting-kind-of-javascript-memory-leak">An Interesting Kind of JavaScript Memory Leak ‚Äî Meteor blog</a> <br> <a href="http://mrale.ph/blog/2012/09/23/grokking-v8-closures-for-fun.html">Grokking V8 closures</a> </p><br><h2>  Conclusion </h2><br><p>       , ,  JavaScript,   .     ,      .  ,    .          .       ,       .   ,      . </p><br><hr><br><p> <em>:</em> <a href="https://auth0.com/blog/four-types-of-leaks-in-your-javascript-code-and-how-to-get-rid-of-them/">4 Types of Memory Leaks in JavaScript and How to Get Rid Of Them</a> , <em>:</em> <a href="https://twitter.com/speyrott">Sebasti√°n Peyrott</a> . </p><br><p> <em>:</em> <a href="https://habrahabr.ru/users/aalexeev/" class="user_link">aalexeev</a> , <em>:</em> <a href="https://habrahabr.ru/users/iamo0/" class="user_link">iamo0</a> , <a href="https://habrahabr.ru/users/jabher/" class="user_link">jabher</a> , <a href="https://habrahabr.ru/users/spearance/" class="user_link">spearance</a> , <a href="https://habrahabr.ru/users/zeckson/" class="user_link">zeckson</a> ,  ,  . </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/309318/">https://habr.com/ru/post/309318/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../309308/index.html">Wi-Fi positioning "cheap and cheerful." About the frequency of measurements or is Wi-Fi positioning possible in real time?</a></li>
<li><a href="../309310/index.html">The main business of Google began to suffer due to the high popularity of mobile applications.</a></li>
<li><a href="../309312/index.html">The network published a database of 98 million Rambler accounts</a></li>
<li><a href="../309314/index.html">Cisco DNA Architecture - IT in Digital Business</a></li>
<li><a href="../309316/index.html">Clear boy Zone.js</a></li>
<li><a href="../309320/index.html">Mail of Russia: in e-commerce-future with cautious optimism</a></li>
<li><a href="../309324/index.html">Anatomy of a web service</a></li>
<li><a href="../309326/index.html">How does MySQL replication work?</a></li>
<li><a href="../309328/index.html">The basics of indexing and EXPLAIN in MySQL</a></li>
<li><a href="../309330/index.html">Database scaling through sharding and partitioning</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>