<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Writing a parser from scratch: is the devil so bad?</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In the past topic, I talked about how my friend and I decided to write my embedded programming language for the .NET platform for fun. The first versi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Writing a parser from scratch: is the devil so bad?</h1><div class="post__text post__text-html js-mediator-article">  In the <a href="http://habrahabr.ru/post/184498/">past topic,</a> I talked about how my friend and I decided to write my <a href="http://github.com/impworks/lens">embedded programming language for the .NET platform</a> for fun.  The first version had a serious drawback - the parser was implemented on F # using a third-party library.  Because of this, a lot of dependencies were needed, the parser was slow, and its support was extremely dreary. <br><br>  Obviously, the parser needed to be rewritten in C #, but at the thought of writing the parser from scratch, there were suddenly a dozen other urgent tasks.  Thus, the task was thrown over and postponed for almost half a year and seemed overwhelming, and in the end was made in 4 days.  Under the cat, I will tell you about a convenient way, which allowed you to implement a parser of a rather complex grammar without using third-party libraries and not moving with your mind, as well as how it improved LENS language. <br><br>  But first things first. <br><a name="habracut"></a><br><h2>  First pancake </h2><br>  As mentioned above, we used the <a href="http://www.quanttec.com/fparsec/">FParsec</a> library as the core of the parser.  The reasons for this choice are more historical than objective: I liked the lightweight syntax, I wanted to practice using F #, and the author of the library very quickly answered a few questions by email. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      The main disadvantage of this library for our project was external dependencies: <br><br><ul><li>  Approximately ten megabyte F # Runtime </li><li>  450 kb assemblies of FParsec itself </li></ul><br>  In addition, the compiler itself crashed into 3 assemblies: a parser, a syntax tree, and an entry point.  Building the parser took an impressive 130 KB.  For <i>embedded</i> language, this is absolutely indecent. <br><br>  Another problem was the display of errors.  A laconic grammar record on a local DSL with an incorrectly entered program produced an unreadable error with a listing of the expected lexemes: <br><br><pre><code class="hljs 1c">&gt; let x = &gt; :   <span class="hljs-keyword"><span class="hljs-keyword"></span></span> <span class="hljs-built_in"><span class="hljs-built_in"></span></span> <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   <span class="hljs-keyword"><span class="hljs-keyword"></span></span> 'new' <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ...</code> </pre> <br>  Although custom error handling is possible, DSL is not intended for it.  The description of the grammar is ugly swelling and becomes completely unsupported. <br><br>  Another unpleasant moment was the speed of work.  With the ‚Äúcold start‚Äù compilation of any, even the simplest script, took about 350-380 milliseconds on my machine.  Judging by the fact that the rerun of the same script took only 5-10 milliseconds, the delay was caused by JIT compilation. <br><br>  At once I will make a reservation - for most real-time tasks, development time is much more critical than a couple of additional libraries or hundreds of milliseconds spent on parsing.  From this point of view, writing a hand-to-hand parser is rather a learning or esoteric exercise. <br><br><h2>  Some theory </h2><br>  A spherical parser in a vacuum is a function that accepts the source code, and returns some intermediate representation, according to which it will be convenient to generate code for the virtual machine or processor being used.  Most often, this representation has a tree structure and is called an <i>abstract syntax tree</i> - ASD (in the foreign literature - abstract syntactic tree, AST). <br><br>  The tree structure is especially good in that its crawl in depth fits perfectly with the stack organization used in many modern virtual machines (for example, JVM or .NET).  Code generation in this article will not be considered, but the elements of the syntax tree, as a result of the parser, will be mentioned from time to time. <br><br>  So, at the entrance we have a string.  Character set  Working with it in this form directly is not very convenient - you have to take into account spaces, line breaks and comments.  To simplify their lives, parser developers usually divide the parsing into several <i>passes</i> , each of which performs one simple task and transfers the result of its work to the following: <br><br><ol><li>  Lexical analyzer: <code>string -&gt; IEnumerable&lt;Lexem&gt;</code> </li><li>  Parser: <code>IEnumerable&lt;Lexem&gt; -&gt; IEnumerable&lt;Node&gt;</code> </li><li>  Semantic analyzer: <code>IEnumerable&lt;Node&gt; -&gt; ?</code> </li></ol><br>  Since the semantic analyzer is a purely individual thing, its description is not included in this article.  However, I will share some useful tricks for the first two analyzers. <br><br><h2>  Lexical analyzer </h2><br>  Requirements: <br><br><ul><li>  Work speed </li><li>  Ease of expansion </li><li>  Ease of implementation </li><li>  Position tracking in source code </li></ul><br>  The lexer algorithm is simple: it scans the string from left to right, trying to match the current position in the string with each lexeme it knows.  With a successful match, the lexer shifts the string to the right for as many characters as the previous lexeme took, and continues the search for a new one to the end of the string.  Spaces, tabs, and line breaks can be ignored for most grammars. <br><br>  All tokens should initially be divided into 2 types - <i>static</i> and <i>dynamic</i> .  The first are those tokens that can be expressed in the usual line - keywords and operators.  Tokens such as identifiers, numbers, or strings are easier to describe with a regular expression. <br><br>  Static lexemes, in turn, have a reason to divide into <i>operators</i> and <i>keywords</i> .  Keywords are matched only if the character following them is not valid for the identifier (or further - the end of the line).  Otherwise, there will be problems with identifiers whose beginning coincides with the keyword: for example, <code>"information" -&gt; keyword(in), keyword(for), identifier(mation)</code> . <br><br><div class="spoiler">  <b class="spoiler_title">Implementation example</b> <div class="spoiler_text"><pre> <code class="hljs cpp"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> LexemKind { Var, Print, Plus, Minus, Multiply, Divide, Assign, Semicolon, Identifier, Number } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LocationEntity</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Offset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Length; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lexem</span></span></span><span class="hljs-class"> :</span></span> LocationEntity { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LexemKind Kind; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Value; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LexemDefinition</span></span></span><span class="hljs-class">&lt;T&gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> LexemKind Kind { get; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> T Representation { get; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StaticLexemDefinition</span></span></span><span class="hljs-class"> :</span></span> LexemDefinition&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsKeyword; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StaticLexemDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rep, LexemKind kind, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> isKeyword = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">false</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ Representation = rep; Kind = kind; IsKeyword = isKeyword; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DynamicLexemDefinition</span></span></span><span class="hljs-class"> :</span></span> LexemDefinition&lt;Regex&gt; { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DynamicLexemDefinition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> rep, LexemKind kind)</span></span></span><span class="hljs-function"> </span></span>{ Representation = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Regex(@<span class="hljs-string"><span class="hljs-string">"\G"</span></span> + rep, RegexOptions.Compiled); Kind = kind; } } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LexemDefinitions</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StaticLexemDefinition[] Statics = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"var"</span></span>, LexemKind.Var, <span class="hljs-literal"><span class="hljs-literal">true</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"print"</span></span>, LexemKind.Print, <span class="hljs-literal"><span class="hljs-literal">true</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"="</span></span>, LexemKind.Assign), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"+"</span></span>, LexemKind.Plus), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"-"</span></span>, LexemKind.Minus), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"*"</span></span>, LexemKind.Multiply), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">"/"</span></span>, LexemKind.Divide), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticLexemDefinition(<span class="hljs-string"><span class="hljs-string">";"</span></span>, LexemKind.Semicolon), }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> DynamicLexemDefinition[] Dynamics = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicLexemDefinition(<span class="hljs-string"><span class="hljs-string">"[a-zA-Z_][a-zA-Z0-9_]*"</span></span>, LexemKind.Identifier), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DynamicLexemDefinition(<span class="hljs-string"><span class="hljs-string">"(0|[1-9][0-9]*)"</span></span>, LexemKind.Number), }; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Lexer</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>[] SpaceChars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> [] { <span class="hljs-string"><span class="hljs-string">' '</span></span>, <span class="hljs-string"><span class="hljs-string">'\n'</span></span>, <span class="hljs-string"><span class="hljs-string">'\r'</span></span>, <span class="hljs-string"><span class="hljs-string">'\t'</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Source; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Offset; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> IEnumerable&lt;Lexem&gt; Lexems { get; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-built_in"><span class="hljs-built_in">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Lexer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> src)</span></span></span><span class="hljs-function"> </span></span>{ Source = src; Parse(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Parse</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ var lexems = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Lexem&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(InBounds()) { SkipSpaces(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!InBounds()) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; var lex = ProcessStatic() ?? ProcessDynamic(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lex == null) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Exception(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(<span class="hljs-string"><span class="hljs-string">"Unknown lexem at {0}"</span></span>, Offset)); lexems.Add(lex); } Lexems = lexems; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SkipSpaces</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(InBounds() &amp;&amp; Source[Offset].IsAnyOf(SpaceChars)) Offset++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Lexem </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessStatic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foreach(var def in LexemDefinitions.Statics) { var rep = def.Representation; var len = rep.Length; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Offset + len &gt; Source.Length || Source.Substring(Offset, len) != rep) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(Offset + len &lt; Source.Length &amp;&amp; def.IsKeyword) { var nextChar = Source[Offset + len]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(nextChar == <span class="hljs-string"><span class="hljs-string">'_'</span></span> || <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>.IsLetterOrDigit(nextChar)) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } Offset += len; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexem { Kind = def.Kind, Offset = Offset, Length = len }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> Lexem </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProcessDynamic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ foreach(var def in LexemDefinitions.Dynamics) { var match = def.Representation.Match(Source, Offset); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!match.Success) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; Offset += match.Length; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Lexem { Kind = def.Kind, Offset = Offset, Length = match.Length, Value = match.Value }; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> null; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InBounds</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Offset &lt; Source.Length; } }</code> </pre><br></div></div><br>  Benefits: <br><br><ul><li>  Works fast </li><li>  Elementary device, you can write for half an hour </li><li>  New lexemes are added very simply. </li><li>  The method is suitable for many grammars </li></ul><br>  Disadvantages: <br><br><ul><li>  Dances with a tambourine when parsing a language with significant spaces </li><li>  The order of the declaration of tokens is important: it is desirable to sort by length </li></ul><br><h2>  Syntactical analyzer </h2><br>  Requirements: <br><br><ul><li>  Ease of expansion when changing grammar </li><li>  Ability to describe detailed error messages </li><li>  The ability to look forward to an unlimited number of positions </li><li>  Automatic tracking of the position in the source code </li><li>  Conciseness, proximity to the original grammar </li></ul><br>  In order to simplify your life when writing a parser, you should arrange the grammar in a special way.  No complicated designs!  All rules can be divided into 3 types: <br><br><ul><li>  <b>Description</b> - one specific node: <br> <code>(var_expr = "var" identifier "=" expr)</code> <br> </li><li>  <b>Repetition</b> - one specific node is repeated many times, possibly with a separator: <br> <code>main = { stmt ";" }</code> <br> </li><li>  <b>Alternative</b> - select from multiple nodes <br> <code>(stmt = var_expr | print_expr | assign_expr | other)</code> <br> </li></ul><br>  The description rule is sorted out in steps: checked the type of the current token, moved to the next one, and so on until the end of the rule.  With each checked lexeme, you can take some action: give a detailed error in the event of a mismatch, save its value in the node, etc. <br><br>  The enumeration rule is a cycle.  To return a sequence of values, in C # there is a very convenient functionality for creating generators using <code>yield return</code> . <br><br>  The alternate rule in turn calls the variant rules using a special wrapper that allows you to roll back to its original state.  The rules are simply called in order, until at least one of them matches, connected by the coalesce ( <code>??</code> ) operator. <br><br>  Here an inquisitive reader will ask: <br>  <i>- How is it, just called in order?</i>  <i>But what about advanced checks?</i>  <i>For example:</i> <br><pre> <code class="hljs vhdl"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CurrentLexem.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> == LexemType.Var) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseVar(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(CurrentLexem.<span class="hljs-keyword"><span class="hljs-keyword">Type</span></span> == LexemType.<span class="hljs-keyword"><span class="hljs-keyword">For</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parseFor(); ...</code> </pre><br>  I admit, I wrote my first serious parser that way.  However, this is a bad idea! <br><br>  First, you can only look at a fixed number of characters.  For any <code>for</code> or <code>var</code> , of course, fit.  But, let's say, we have such rules in grammar: <br><br><pre> <code class="hljs objectivec"><span class="hljs-keyword"><span class="hljs-keyword">assign</span></span> = id_assign | member_assign | index_assign id_assign = identifier <span class="hljs-string"><span class="hljs-string">"="</span></span> expr member_assign = lvalue <span class="hljs-string"><span class="hljs-string">"."</span></span> identifier <span class="hljs-string"><span class="hljs-string">"="</span></span> expr index_assign = lvalue <span class="hljs-string"><span class="hljs-string">"["</span></span> expr <span class="hljs-string"><span class="hljs-string">"]"</span></span> <span class="hljs-string"><span class="hljs-string">"="</span></span> expr</code> </pre><br>  If everything is clear with <code>id_assign</code> , then the other two rules start with a non-terminal <code>lvalue</code> , which can hide a kilometer expression.  Obviously, there are no advance checks here. <br><br>  Another problem is the mixing of areas of responsibility.  For grammar to be extensible, the rules must be as independent as possible from each other.  This approach requires that the external rule is aware of the composition of the internal ones, which increases coherence and complicates support when changing grammar. <br><br>  So why do we need advanced checks?  Let every rule itself know how far you need to look ahead to make sure that it is the most appropriate. <br><br>  Consider the example above.  Suppose we have the text: <code>a.1 = 2</code> : <br><br><ol><li>  The first is the alternative called <code>id_assign</code> . </li><li>  Identifier <code>a</code> successfully matches. </li><li>  Next comes the point, and the expected is an equal sign.  However, other rules may begin with an identifier, so the error is not thrown away. </li><li>  The assign rule rolls back the state and tries further. </li><li>  An alternative to <code>member_assign</code> . </li><li>  Identifier and dot successfully match.  There are no other rules in the grammar that start with an identifier and a dot, so it makes no sense to try to make further errors by rolling back the state. </li><li>  The number <code>1</code> not an identifier, so an error is thrown out. </li></ol><br>  First, we write several useful methods: <br><br><div class="spoiler">  <b class="spoiler_title">Hidden text</b> <div class="spoiler_text"><pre> <code class="hljs kotlin">partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> List&lt;Lexem&gt; Lexems; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> int LexemId; #region Lexem handlers [DebuggerStepThrough] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool Peek(params LexemType[] types) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = Math.Min(LexemId, Lexems.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lex = Lexems[id]; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lex.Type.IsAnyOf(types); } [DebuggerStepThrough] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Lexem Ensure(LexemType type, string msg, params <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>[] args) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lex = Lexems[LexemId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(lex.Type != type) error(msg, args); Skip(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lex; } [DebuggerStepThrough] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> bool Check(LexemType lexem) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lex = Lexems[LexemId]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lex.Type != lexem) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; Skip(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } [DebuggerStepThrough] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> void Skip(int count = <span class="hljs-number"><span class="hljs-number">1</span></span>) { LexemId = Math.Min(LexemId + count, Lexems.Length - <span class="hljs-number"><span class="hljs-number">1</span></span>); } #endregion #region Node handlers [DebuggerStepThrough] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T Attempt&lt;T&gt;(Func&lt;T&gt; getter) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : LocationEntity { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> backup = LexemId; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = Bind(getter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) LexemId = backup; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } [DebuggerStepThrough] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T Ensure&lt;T&gt;(Func&lt;T&gt; getter, string msg) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : LocationEntity { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = Bind(getter); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> new Exception(msg); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } [DebuggerStepThrough] <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> T Bind&lt;T&gt;(Func&lt;T&gt; getter) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : LocationEntity { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> startId = LexemId; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> start = Lexems[LexemId]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> result = getter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { result.StartLocation = start.StartLocation; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> endId = LexemId; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (endId &gt; startId &amp;&amp; endId &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) result.EndLocation = Lexems[LexemId - <span class="hljs-number"><span class="hljs-number">1</span></span>].EndLocation; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } #endregion }</code> </pre></div></div><br>  With their help, the implementation of the above grammar becomes almost trivial: <br><br><pre> <code class="hljs kotlin">partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node ParseAssign() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Attempt(ParseIdAssign) ?? Attempt(ParseMemberAssign) ?? Ensure(ParseIndexAssign, <span class="hljs-string"><span class="hljs-string">"  !"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node ParseIdAssign() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id = TryGetValue(LexemType.Identifier); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Check(LexemType.Assign)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = Ensure(ParseExpr, <span class="hljs-string"><span class="hljs-string">"  !"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new IdAssignNode { Identifier = id, Expression = expr }; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node ParseMemberAssign() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lvalue = Attempt(ParseLvalue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lvalue == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Check(LexemType.Dot)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> member = TryGetValue(LexemType.Identifier); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (member == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Check(LexemType.Assign)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = Ensure(ParseExpr, <span class="hljs-string"><span class="hljs-string">"  !"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new MemberAssignNode { Lvalue = lvalue, MemberName = member, Expression = expr }; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Node ParseIndexAssign() { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lvalue = Attempt(ParseLvalue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lvalue == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!Check(LexemType.SquareBraceOpen)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> index = Ensure(ParseExpr, <span class="hljs-string"><span class="hljs-string">"  !"</span></span>); Ensure(LexemType.SquareBraceClose, <span class="hljs-string"><span class="hljs-string">"  !"</span></span>); Ensure(LexemType.Assign, <span class="hljs-string"><span class="hljs-string">"  !"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> expr = Ensure(ParseExpr, <span class="hljs-string"><span class="hljs-string">"  !"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> new IndexAssignNode { Lvalue = lvalue, Index = index, Expression = expr }; } }</code> </pre><br>  The <a href="http://msdn.microsoft.com/ru-ru/library/system.diagnostics.debuggerstepthroughattribute(v%3Dvs.110).aspx"><code>DebuggerStepThrough</code></a> attribute helps a lot when debugging.  Since all calls to nested rules somehow pass through Attempt and Ensure, without this attribute, they will always be noticeable during Step Into and fill in the call stack. <br><br>  The advantages of this method: <br><br><ul><li>  Status rollback is a very cheap operation. </li><li>  Easy to control where to roll back </li><li>  Easy to display detailed error messages. </li><li>  No external libraries required. </li><li>  Small amount of generated code </li></ul><br>  Disadvantages: <br><br><ul><li>  Manual implementation of the parser takes time </li><li>  The complexity of writing and optimal performance depend on the quality of the grammar </li><li>  Left-recursive grammars should be resolved independently </li></ul><br><h2>  Operators and Priorities </h2><br>  Repeatedly I have seen in the descriptions of grammar the following rules, which indicate the priority of operations: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">expr</span></span> = expr_1 { <span class="hljs-attribute"><span class="hljs-attribute">op_1</span></span> expr_1 } expr_1 = exp2_2 { <span class="hljs-attribute"><span class="hljs-attribute">op_2</span></span> expr_2 } expr_2 = exp2_3 { <span class="hljs-attribute"><span class="hljs-attribute">op_3</span></span> expr_3 } expr_3 = int | float | identifier op_1 = <span class="hljs-string"><span class="hljs-string">"+"</span></span> | <span class="hljs-string"><span class="hljs-string">"-"</span></span> op_2 = <span class="hljs-string"><span class="hljs-string">"*"</span></span> | <span class="hljs-string"><span class="hljs-string">"/"</span></span> | <span class="hljs-string"><span class="hljs-string">"%"</span></span> op_3 = <span class="hljs-string"><span class="hljs-string">"**"</span></span></code> </pre><br>  Now imagine that we still have boolean operators, comparison operators, shift operators, binary operators, or some proper ones.  How many rules are obtained, and how much will you have to change, if you suddenly have to add a new operator with priority somewhere in the middle? <br><br>  Instead, you can remove from the grammar in general all the description of priorities and code it declaratively. <br><br><div class="spoiler">  <b class="spoiler_title">Implementation example</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">expr = sub_expr { op sub_expr } sub_expr = <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> | identifier</code> </pre><br><pre> <code class="hljs php">partial <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Parser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Dictionary&lt;LexemType, Func&lt;Node, Node, Node&gt;&gt;&gt; Priorities = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">List</span></span>&lt;Dictionary&lt;LexemType, Func&lt;Node, Node, Node&gt;&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;LexemType, Func&lt;Node, Node, Node&gt;&gt; { { LexemType.Plus, (a, b) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AddNode(a, b) }, { LexemType.Minus, (a, b) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SubtractNode(a, b) } }, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;LexemType, Func&lt;Node, Node, Node&gt;&gt; { { LexemType.Divide, (a, b) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DivideNode(a, b) }, { LexemType.Multiply, (a, b) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MultiplyNode(a, b) }, { LexemType.Remainder, (a, b) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> RemainderNode(a, b) } }, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Dictionary&lt;LexemType, Func&lt;Node, Node, Node&gt;&gt; { { LexemType.Power, (a, b) =&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PowerNode(a, b) } }, }; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> NodeBase ProcessOperators(Func&lt;Node&gt; next, int priority = <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (priority == Priorities.Count) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getter(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> node = ProcessOperators(next, priority + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ops = Priorities[priority]; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Lexems[LexemId].IsAnyOf(ops.Keys)) { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> curr in ops) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (check(curr.Key)) { node = curr.Value( node, ensure(() =&gt; ProcessOperators(next, priority + <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-string"><span class="hljs-string">" !"</span></span>) ); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> node; } }</code> </pre></div></div><br>  Now, to add a new operator, it is only necessary to add the appropriate line to initialize the list of priorities. <br><br>  Adding support for unary prefix operators is left as a training for particularly curious. <br><br><h2>  What did it give us? </h2><br>  The handwritten parser, oddly enough, has become much easier to maintain.  Added a rule to the grammar, found the appropriate place in the code, added its use.  Backtracking hell, which often arose when adding a new rule in the old parser and caused a sudden heap of a seemingly unrelated test, was left in the past. <br><br>  Total comparative table of results: <br><table><tbody><tr><td>  <b>Parameter</b> </td><td>  <b>FParsec Parser</b> </td><td>  <b>Pure C #</b> </td></tr><tr><td>  Parsing time at 1 run </td><td>  220 ms </td><td>  90 ms </td></tr><tr><td>  Parsing time during further runs </td><td>  5 ms </td><td>  6 ms </td></tr><tr><td>  Library size required </td><td>  800 KB + F # Runtime </td><td>  260 KB </td></tr></tbody></table>  Most likely, it is possible to optimize and squeeze more performance out of the parser, but so far this result is quite satisfactory. <br><br>  Having got rid of a headache with changes in grammar, we were able to wash down some pleasant things in <a href="https://github.com/impworks/lens">LENS</a> : <br><br><h4>  Cycle for </h4><br>  It is used both to bypass sequences, and for ranges: <br><br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> data = new [<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-number"><span class="hljs-number">5</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> data <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span> <span class="hljs-string"><span class="hljs-string">"value = {0}"</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>..<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span> <span class="hljs-string"><span class="hljs-string">"square = {0}"</span></span> x</code> </pre><br><h4>  Composition of functions </h4><br>  With the help of the operator <code>:&gt;</code> you can create new functions, ‚Äústringing‚Äù the existing ones: <br><br><pre> <code class="hljs rust"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invConcat = (a:string b:string) -&gt; b + a <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> invParse = incConcat :&gt; int::Parse invParse <span class="hljs-string"><span class="hljs-string">"37"</span></span> <span class="hljs-string"><span class="hljs-string">"13"</span></span> <span class="hljs-comment"><span class="hljs-comment">// 1337</span></span></code> </pre><br>  Partial application is possible using anonymous functions: <br><br><pre> <code class="hljs kotlin"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> add:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">y</span></span></span></span><span class="hljs-function"><span class="hljs-params">:</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> -&gt; x + y let addTwo = int::TryParse&lt;string&gt; :&gt; (x:int -&gt; add <span class="hljs-number"><span class="hljs-number">2</span></span> x) addTwo <span class="hljs-string"><span class="hljs-string">"40"</span></span> <span class="hljs-comment"><span class="hljs-comment">// 42</span></span></code> </pre><br><h4>  Syntax improvements </h4><br><ul><li>  Single line comments: <br><pre> <code class="hljs objectivec">somecode () <span class="hljs-comment"><span class="hljs-comment">// comment</span></span></code> </pre> <br></li><li>  Uninitialized variables: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x : <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br></li><li>  The brackets around the single lambda argument are optional: <br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> inc = x:<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> -&gt; x + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br></li><li>  The brackets in the control structures are removed: <br><pre> <code class="hljs swift"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> x then a () <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> b () <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> a &lt; b <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-built_in"><span class="hljs-built_in">println</span></span> <span class="hljs-string"><span class="hljs-string">"a = {0}"</span></span> a a = a + <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br></li><li>  A <code>try/finally</code> block appeared. <br></li><li>  The brackets when passing an index or field to a function are optional: <br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"{0} = {1}"</span></span> a[<span class="hljs-number"><span class="hljs-number">1</span></span>] SomeType::b</code> </pre> </li></ul><br>  The project, though slowly, is developing.  There are still many interesting tasks.  The following version is planned: <br><br><ul><li>  Declaration of generic types and functions </li><li>  Ability to mark functions or types of attributes </li><li>  Event support </li></ul><br>  You can also download the <a href="">collected demos under Windows</a> . </div><p>Source: <a href="https://habr.com/ru/post/202622/">https://habr.com/ru/post/202622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../202610/index.html">Linux Mint 16 RC "Petra" released</a></li>
<li><a href="../202612/index.html">Announcement: Habrawriter</a></li>
<li><a href="../202614/index.html">Legal basis for ensuring information security in a commercial organization</a></li>
<li><a href="../202618/index.html">Payoneer mobile app update</a></li>
<li><a href="../202620/index.html">Technology gets closer to the body</a></li>
<li><a href="../202626/index.html">Interview with Michael Basnight, technical manager of the OpenStack Trove project</a></li>
<li><a href="../202628/index.html">Javascript Tetris (in 30+ lines)</a></li>
<li><a href="../202630/index.html">A game (idea and alpha version) for those who played the war game as a child</a></li>
<li><a href="../202632/index.html">Does it make sense in articles for those who are starting to learn symfony</a></li>
<li><a href="../202634/index.html">NASA held a successful launch of a satellite to study the atmosphere of Mars</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>