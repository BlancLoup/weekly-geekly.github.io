<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Process tracking and error handling, part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="0 Preamble 
 Agree pleasantly when everything is under control and everything is in order in the household, each thing stands in its place and clearly...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Process tracking and error handling, part 1</h1><div class="post__text post__text-html js-mediator-article"><h4>  0 Preamble </h4><br>  Agree pleasantly when everything is under control and everything is in order in the household, each thing stands in its place and clearly fulfills its universal purpose.  Today we will consider the organization of order in a huge variety of Erlang processes.  Basic concepts about erlang processes can be found in this <a href="http://habrahabr.ru/blogs/erlang/114232/">post</a> . <br><a name="habracut"></a><br><h4>  1 You follow me - I follow you </h4><br>  Anyone who somehow got acquainted with the Erlang, heard the phrase: "Let the process fall, while the other will do something about it or deal with the problem."  You must admit that when something breaks is bad, and if we still don‚Äôt know about it for a long time, it‚Äôs doubly bad.  Your cat broke its bowl of milk and hid this terrible fact from you - bad!  Let the bowl watch the cat, and the cat behind the bowl.  Forgive the readers of the author for such a rough comparison.  So let's get down to business. <br><br>  Communication processes to monitor the status of each other - this is one of the basic concepts of Erlang.  In a complex and well-designed system, no process should ‚Äúhang in the air‚Äù.  All processes should be built into the control tree, the leaves of which are workflows, and the internal nodes monitor workers (controllers) [2 | see  OTP principles (Open Telecom Platform)].  Although it is possible to have two workers connected. <br><br><img src="https://habrastorage.org/storage/d2ef30c7/ee39aad4/f2d9ec57/e79dbbe5.png"><br>  Picture 1 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      If you do not rise to the level of abstraction that OTP provides, there are two mechanisms for communication of processes in an erlang: <br><ol><li>  Link (link) - bidirectional communication between two processes. </li><li>  Monitors - unidirectional communication of the observer process and the observed. </li></ol><br><h4>  1.1 Links </h4><br>  To create connections between processes, the following functions are used: <br><ul><li>  erlang: link / 1 - creating a link between the caller of the function and another process; </li><li>  erlang: spawn_link / 1/2/3/4 (there is also the proc_lib alias: spawn_link / 1/2/3/4) - creating a new process and linking it to the process that calls the function; </li><li>  erlang: unlink / 1 - remove the connection between the process calling the function and the one specified in the arguments; </li><li>  pool: pspawn_link / 3 - creating a new process on one of the nodes in the pool and linking it to the process that calls the function. </li></ul><br>  What does bidirectional communication between processes give us?  Links determine the path of error propagation.  One process died, the second found out about it and in a number of cases, which we will consider below, it will also complete its work, having sent a signal to all other processes that are also attached to it.  This mechanism allows you to remotely handle errors, i.e.  A handler can be a separate process (controller) to which all these errors will ‚Äúflow‚Äù along the links, and the handler process can be located on another node.  And all these goodies are almost free - everything is already implemented in the platform, we only need to correctly build our mega-super-fail-distributed system. <br><br><img src="https://habrastorage.org/storage/c27f1e22/d6df04c6/495d18a2/09677f0a.png"><br>  Figure 2 <br><br>  When a process crashes (see Figure 2), an output signal is sent to all linked processes, this signal contains information about which process and for what reason died in battle.  The signal is a tuple {'EXIT', Pid, ‚Äã‚ÄãReason}. <br><br>  There are two predefined values ‚Äã‚Äãfor the Reason variable: <br><ul><li>  normal - the given value of the cause is set if the process has performed all the work with which we have loaded it, i.e.  simply reached the end of the function with which it was called.  In this case, the processes that are linked to it will not complete their work. </li><li>  kill is a non-intercepted signal that always kills a process, even a system one, is used to force termination of failed processes. </li></ul><br>  In order for a process to intercept output signals, it must be made systemic by setting the trap_exit flag by calling the process_flag function (trap_exit, true). <br><br>  So, enough of the theory, let's try everything in practice.  Open our favorite editor and create a small module.  Let's first test the normal completion of the process.  For simplicity, the experiment as one of the processes we will have a shell. <br><br><pre><code class="lisp hljs">-module(<span class="hljs-name"><span class="hljs-name">links_test</span></span>). -export([start_n/1, loop_n/1]). start_n(<span class="hljs-name"><span class="hljs-name">Sysproc</span></span>) -&gt; %% test normal reason process_flag(<span class="hljs-name"><span class="hljs-name">trap_exit</span></span>, Sysproc), io:format(<span class="hljs-string"><span class="hljs-string">"Shell Pid: ~p~n"</span></span>, [self()]), Pid = spawn_link(<span class="hljs-name"><span class="hljs-name">links_test</span></span>, loop_n, [self()]), io:format(<span class="hljs-string"><span class="hljs-string">"Process started with Pid: ~p~n"</span></span>, [Pid]). loop_n(<span class="hljs-name"><span class="hljs-name">Shell</span></span>) -&gt; %% loop for test normal reason receive after <span class="hljs-number"><span class="hljs-number">5000</span></span> -&gt; Shell ! timeout end.</code> </pre> <br><br>  Two functions are defined in the module: the first start_n creates a new process and links it with the calling process (in our case it will be a shell), takes the value boolean as the parameter, which makes the process systemic.  The second loop_n is the body of the process being created; as an argument we pass to it the Pid of the calling process (shell).  5 seconds after starting the process, he sends a timeout message to the shell.  Compile and run our process. <br><br><pre> <code class="bash hljs">(emacs@aleksio-mobile)2&gt; links_test:start_n(<span class="hljs-literal"><span class="hljs-literal">false</span></span>). Shell Pid: &lt;0.36.0&gt; Process started with Pid: &lt;0.43.0&gt; ok (emacs@aleksio-mobile)3&gt; flush(). Shell got timeout ok (emacs@aleksio-mobile)4&gt;</code> </pre><br><br>  Call the function links_test: start_n with the parameter false, i.e.  The shell is not a system process and it cannot catch exit signals.  We see that the process was successfully created, because  There is no tail recursion in the loop_n function, it will successfully execute and the process will end.  Call the flush () function to reset all messages from the shell mailbox, and see that a message was received from our ‚ÄúShell got timeout‚Äù process.  We do not see any output signals, since the flag for processing this type of signals has not been set.  Now we will make the shell a system process. <br><br><pre> <code class="bash hljs">(emacs@aleksio-mobile)5&gt; links_test:start_n(<span class="hljs-literal"><span class="hljs-literal">true</span></span>). Shell Pid: &lt;0.36.0&gt; Process started with Pid: &lt;0.51.0&gt; ok (emacs@aleksio-mobile)6&gt; flush(). Shell got timeout Shell got {<span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>,&lt;0.51.0&gt;,normal} ok (emacs@aleksio-mobile)8&gt;</code> </pre><br><br>  After executing the function, we see that, in addition to the timeout message, a message about normal termination was received from our process {'EXIT', &lt;0.51.0&gt;, normal}.  A wonderful mechanism allows us to save on the amount of code when you need to know that the process has done its work (do not send the ‚ÄúI have done everything‚Äù signal myself). <br><br>  Now let's try to generate an error other than normal.  Modify the module code as in the listing below. <br><br><pre> <code class="lisp hljs">-module(<span class="hljs-name"><span class="hljs-name">links_test</span></span>). -export([start_n/1, loop_n/1]). start_n(<span class="hljs-name"><span class="hljs-name">Sysproc</span></span>) -&gt; %% test abnormal reason process_flag(<span class="hljs-name"><span class="hljs-name">trap_exit</span></span>, Sysproc), io:format(<span class="hljs-string"><span class="hljs-string">"Shell Pid: ~p~n"</span></span>, [self()]), Pid = spawn_link(<span class="hljs-name"><span class="hljs-name">links_test</span></span>, loop_n, [self()]), io:format(<span class="hljs-string"><span class="hljs-string">"Process started with Pid: ~p~n"</span></span>, [Pid]). loop_n(<span class="hljs-name"><span class="hljs-name">Shell</span></span>) -&gt; %% loop for test abnormal reason receive after <span class="hljs-number"><span class="hljs-number">5000</span></span> -&gt; Shell ! timeout, <span class="hljs-number"><span class="hljs-number">1</span></span> / <span class="hljs-number"><span class="hljs-number">0</span></span> end.</code> </pre><br><br>  We are very harsh and decided to divide by zero, the compiler will naturally warn us that we are wrong, but we simply ignore its warning. <br><br><pre> <code class="bash hljs">(emacs@aleksio-mobile)33&gt; links_test:start_n(<span class="hljs-literal"><span class="hljs-literal">false</span></span>). Shell Pid: &lt;0.117.0&gt; Process started with Pid: &lt;0.120.0&gt; ok (emacs@aleksio-mobile)34&gt; ** exception error: bad argument <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> an arithmetic expression <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> links_test:loop_n/1 (emacs@aleksio-mobile)34&gt; =ERROR REPORT==== 25-Feb-2011::16:22:48 === Error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> process &lt;0.120.0&gt; on node <span class="hljs-string"><span class="hljs-string">'emacs@aleksio-mobile'</span></span> with <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> value: {badarith,[{links_test,loop_n,1}]} (emacs@aleksio-mobile)34&gt; flush(). ok (emacs@aleksio-mobile)35&gt; self(). &lt;0.122.0&gt; (emacs@aleksio-mobile)36&gt;</code> </pre><br><br>  Note Shell Pid = &lt;0.117.0&gt;.  After 5 seconds, an error falls out explaining that after all we were wrong.  Let's try to see what is in the queue at the shell, and there it is empty.  Where is our timeout letter?  Execute the self () command, Shell Pid is now &lt;0.122.0&gt; - this means that our failed process sent a shell exit signal with a reason {badarith, [{links_test, loop_n, 1}]}, and since the shell is in this example not a system process, it safely crashed and was restarted by some controller (as we may consider in the following articles).  Now turn on the output signal processing flag. <br><br><pre> <code class="bash hljs">(emacs@aleksio-mobile)40&gt; links_test:start_n(<span class="hljs-literal"><span class="hljs-literal">true</span></span>). Shell Pid: &lt;0.132.0&gt; Process started with Pid: &lt;0.139.0&gt; ok (emacs@aleksio-mobile)41&gt; =ERROR REPORT==== 25-Feb-2011::16:34:19 === Error <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> process &lt;0.139.0&gt; on node <span class="hljs-string"><span class="hljs-string">'emacs@aleksio-mobile'</span></span> with <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> value: {badarith,[{links_test,loop_n,1}]} (emacs@aleksio-mobile)41&gt; flush(). Shell got timeout Shell got {<span class="hljs-string"><span class="hljs-string">'EXIT'</span></span>,&lt;0.139.0&gt;,{badarith,[{links_test,loop_n,1}]}} ok (emacs@aleksio-mobile)42&gt; self(). &lt;0.132.0&gt; (emacs@aleksio-mobile)43&gt;</code> </pre><br><br>  I think comments on the results are unnecessary, everything is clear. <br><br>  We analyzed four cases: <br><table><tbody><tr><th>  Trap_exit signal </th><th>  Process reason </th><th>  The action process, which remained "alive" </th></tr><tr><td>  true </td><td>  normal </td><td>  The message comes in the mailbox {'EXIT', Pid, ‚Äã‚Äãnormal} </td></tr><tr><td>  false </td><td>  normal </td><td>  The process continues its work </td></tr><tr><td>  true </td><td>  Anything other than normal and kill </td><td>  The message comes in the mailbox {'EXIT', Pid, ‚Äã‚ÄãReason} </td></tr><tr><td>  false </td><td>  Anything other than normal and kill </td><td>  The process dies, sending out the output signal to all of its connections (i.e., error propagates) </td></tr></tbody></table><br><h4>  Conclusion </h4><br>  In the following articles ( <a href="http://habrahabr.ru/blogs/erlang/114753/">part 2</a> , <a href="http://habrahabr.ru/blogs/erlang/114812/">part 3</a> ) we will look at the mechanism of monitors and shoot at the processes with the kill signals.  I would like to hear the opinions of habrobitel, articles on what topics erlang you would be most interesting? <br><br><h4>  Bibliography </h4><br>  1. <a href="http://erldocs.com/">Excellent online documentation</a> . <br>  2. <a href="http://erlanger.ru/wiki/index.php/OTP_Overview">Principles of OTP</a> . <br>  3. ERLANG Programming by Francesco Cesarini and Simon Thompson. <br>  4. Programming Erlang: Software for a Concurrent World by Joe Armstrong. </div><p>Source: <a href="https://habr.com/ru/post/114620/">https://habr.com/ru/post/114620/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../114610/index.html">TeX Varieties</a></li>
<li><a href="../114612/index.html">Living Typography</a></li>
<li><a href="../114616/index.html">Conference "Make IT" in Krasnoyarsk + competition for web developers</a></li>
<li><a href="../114618/index.html">150 thousand Google Mail users lost access to mail</a></li>
<li><a href="../114619/index.html">Layout e-mail newsletters - "pitfalls". Part two</a></li>
<li><a href="../114622/index.html">Simple protection against double cron jobs</a></li>
<li><a href="../114623/index.html">Holywar: iOS vs Android</a></li>
<li><a href="../114626/index.html">QIWI and Payoneer collaboration</a></li>
<li><a href="../114628/index.html">"Up!" - from heaven to earth</a></li>
<li><a href="../114629/index.html">OpenGL is easy!</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>