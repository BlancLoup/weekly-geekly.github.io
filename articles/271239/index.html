<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Testing a web service on Go</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In this article I would like to share one of the ways of simple and convenient integration testing of the http service written on Go. Integration test...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Testing a web service on Go</h1><div class="post__text post__text-html js-mediator-article">  In this article I would like to share one of the ways of simple and convenient integration testing of the http service written on Go.  Integration tests can be difficult to create in such a way as to avoid complex scripts, but Docker, the package from the standard httptest library and build tags, will come to our aid.  For example, we will use a MySQL database with migrations managed by the goose package.  The final goal is to get simple and convenient cross-platform integration testing by simply running the go test command, be it a working laptop or a Continuous Integration server. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f25/bdd/451/f25bdd4517e73bb454c7682618612ce0.png" alt="image"><br><a name="habracut"></a><br><h4>  The basics </h4><br>  So, for a start, let's remember how Go relates to testing.  Since the authors of Go emphasize that Go promotes good practices - and testing is one of perhaps the best practices for programmers in general, testing in Go is an integral part of the toolkit and comes out of the box.  In addition, to use it, you need to remember the very <a href="https://golang.org/pkg/testing/">minimum</a> . <br><br>  Here is the minimum: <br><ul><li>  command to run tests - <b>go test</b> </li><li>  tests are in the * _test.go files.  The code in these files is not used in the assembly, only in tests. </li><li>  a function called TestXxx (t * testing.T) will be launched during testing </li><li>  in the standard <a href="https://golang.org/pkg/testing/">testing</a> library package there is everything necessary for tests </li></ul>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Say, if you wrote a function to calculate the area of ‚Äã‚Äãa circle, the Go test will look like this: <br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"math"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { area := CircleArea(<span class="hljs-number"><span class="hljs-number">10</span></span>) want := <span class="hljs-number"><span class="hljs-number">100</span></span> * math.Pi <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> area != want { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"Want %v, but got %v"</span></span>, want, area) } }</code> </pre> <br>  Of course, for those who are accustomed to smart assertions and testing wrappers that simplify testing, such code may seem too verbose.  But the ‚Äúsmart comparison‚Äù of different types is not such a trivial task, and is completely left to third-party packages, which I will discuss below.  The same minimalistic approach allows you to start writing tests with or without a reason with a minimum entry threshold.  Many even claim that they love <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a> (Testing Driven Development) in Go.  However, there are no excuses for not writing tests - it has become too easy. <br><br>  At the same time, so that you understand, quite complicated things happen under the hood.  go test takes your code, puts it in a temporary directory, modifies it so that you get a self-contained program that runs the tests, compiles, runs and displays the results with a time count.  All this happens in a fraction of a second, and this approach became possible and convenient only thanks to a simple grammar of the language and super-fast compilation. <br><br>  go test can do much more out of the box, including recording coverage (coverage), memory profiling and a processor, the same simple benchmarks (func BenchmarkXxx), parallel execution, flight detector and many other things.  You can find out everything by running the <b>go help test</b> and <b>go help testflag commands</b> . <br><br><h4>  Testing frameworks </h4><br>  Of course, for large programs, it makes sense to use more powerful testing methods.  For Go, there are many frameworks that easily and simply connect to your tests, and are compatible with the go test command.  I like <a href="http://goconvey.co/">GoConvey</a> most of all, adding DSL-like syntax for BDD tests.  The above example would look like this with GoConvey: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"math"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> . <span class="hljs-string"><span class="hljs-string">"github.com/smartystreets/goconvey/convey"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TestCircle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { Convey(<span class="hljs-string"><span class="hljs-string">"Circle should work correctly"</span></span>, t, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { Convey(<span class="hljs-string"><span class="hljs-string">"Area should be calculated correctly"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { area := CircleArea(<span class="hljs-number"><span class="hljs-number">10</span></span>) So(area, ShouldEqual, <span class="hljs-number"><span class="hljs-number">100</span></span> * math.Pi) }) }) }</code> </pre><br><img src="https://habrastorage.org/files/a71/042/c33/a71042c33b1a422e91b3ee1560323a9c.png"><img src="https://habrastorage.org/files/70d/94a/f9c/70d94af9c9b6414ab4d068325e82be6e.png"><br><br>  GoConvey can do a lot of <a href="https://github.com/smartystreets/goconvey/wiki/Assertions">assertions</a> , including for a deep comparison of structures and complex types, can work with time and so on.  If you start to use it, be sure to read about the <a href="https://github.com/smartystreets/goconvey/wiki/Execution-order">order of execution of the</a> nested Convey-functions - this is an important feature. <br><br>  As a bonus, Goconvey has a fancy web UI that can monitor changes in the code and restart tests, send Desktop notifications and, in general, looks like a shuttle launch control panel.  Very cool in fact, it is convenient to bring to the second monitor.  How many respond, GoConvey will make you love testing even more :) <br><img src="https://habrastorage.org/files/fc5/e02/d83/fc5e02d83ce3494a9118cf67f571dd6d.png"><br><br>  There are also popular frameworks like <a href="https://onsi.github.io/ginkgo/">Ginkgo</a> , <a href="https://github.com/stretchr/testify/">testify</a> , <a href="http://labix.org/gocheck">gocheck</a> , <a href="http://agouti.org/">Agouti</a> , <a href="http://onsi.github.io/gomega/">GoMega</a> and others.  Here is a <a href="https://github.com/shageman/gotestit">good comparison</a> . <br><br>  As you can see, the Go approach on the principle ‚Äúthe most necessary is out of the box, everything else is at the mercy of the community‚Äù justifies itself in testing as well as possible. <br><br><h4>  Integration tests </h4><br>  As noted above, integration tests, which involve testing the entire system as a whole, rather than individual parts of the code, can be a daunting task.  Often they require complex scripts that are far from always cross-platform, take a lot of time and so on.  But even with Go, such tasks become much easier. <br><br>  I will consider the following example: <br><ul><li>  web backend using <a href="https://github.com/gin-gonic/gin">gin</a> framework </li><li>  data for the service - in the MySQL database </li><li>  base scheme is built using migration utility - <a href="https://bitbucket.org/liamstask/goose/">goose</a> </li></ul><br>  This can be either a typical REST backend, or any service that follows the principles of the <a href="http://12factor.net/">12-factor app</a> , there can be much more dependencies and services.  Now the goal is to show the approach. <br><br>  For external services (in this case, MySQL databases), I will use, however trite it may be, Docker.  While the whole world tells each other that Docker is not a panacea and you don‚Äôt need to use it where you don‚Äôt need it (and the truth says the same), using containers to quickly raise dependencies in integration tests is the very thing. <br><br><h4>  Migrations and Dockerfile </h4><br>  First, we will deal with the non-Go part, namely the writing of the Dockerfile, and we will figure out how to work with the migrations. <br><br>  goose is a binary file that, when launched, searches for the db / directory, and in it: <br><ul><li>  dbconf.yml file </li><li>  folder migrations / </li></ul><br>  The yaml file describes various database configurations with which goose can work, and in the migrations / folder, the SQL code created using goose create.  On the page of the project it is described in more detail, I will not dwell in detail. <br><br>  Our task is to create a container with MySQL, with the build of the container, start it, bring up migrations to the latest version using the goose up command, and prepare the container for further work. <br>  Dockerfile might look like this: <br><div class="spoiler">  <b class="spoiler_title">Dockerfile</b> <div class="spoiler_text">  FROM debian <br><br>  ENV DEBIAN_FRONTEND noninteractive <br>  RUN apt-get update <br>  RUN apt-get install -y mysql-server <br><br>  RUN sed -i -e "s / ^ bind-address \ s * = \ s * 127.0.0.1 / bind-address = 0.0.0.0/" /etc/mysql/my.cnf <br><br>  RUN apt-get install -y golang git ca-certificates gcc <br>  ENV GOPATH / root <br>  RUN go get bitbucket.org/liamstask/goose/cmd/goose <br><br>  ADD.  / db <br>  RUN \ <br>  service mysql start &amp;&amp; \ <br>  sleep 10 &amp;&amp; \ <br>  while true;  do mysql -e "SELECT 1" &amp;&gt; / dev / null;  [$?  -eq 0] &amp;&amp; break;  echo -n ".";  sleep 1;  done &amp;&amp; \ <br>  mysql -e "GRANT ALL ON *. * to 'root' @ '%';  FLUSH PRIVILEGES; "&amp;&amp; \ <br>  mysql -e "CREATE DATABASE mydb DEFAULT COLLATE utf8_general_ci;" &amp;&amp; \ <br>  / root / bin / goose -env = default up &amp;&amp; \ <br>  service mysql stop <br><br>  EXPOSE 3306 <br>  Cmd ["mysqld_safe"] <br></div></div><br>  We collect the container with the command ‚Äúdocker build -t mydb_test.‚Äù Now, when you start docker run -p 3306: 3306 mydb_test - we will get the newly-launched database, with the latest migrations and in the fresh state. <br><br><h4>  We write Go tests </h4><br>  To begin with, put a build tag so that this test does not run every time, but only when we are forced to ask to run ‚Äúintegration tests‚Äù. <br>  Let's start our service_test.go: <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// +build integration package main import ( "testing" )</span></span></code> </pre><br>  Now, the usual call go test will not touch this particular test, but go test -tag = integration will.  By the way, in go test there is a -short mode - you can use it, only it, on the contrary, is turned off by default: <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> testing.Short() { t.Skip(<span class="hljs-string"><span class="hljs-string">"skipping test in short mode."</span></span>) }</code> </pre> <br><br><h4>  We lift the Docker-container from tests </h4><br>  First of all, we will want to lift our Docker container at the start of the test.  For Docker there are convenient Go-libraries, I will use the <a href="http://github.com/fsouza/go-dockerclient">client</a> from fsouza, which I have been using for more than 1.5 years.  To start the container, you need to perform three steps: <br><pre> <code class="go hljs"> client, err := docker.NewClientFromEnv() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"Cannot connect to Docker daemon: %s"</span></span>, err) } c, err := client.CreateContainer(createOptions()) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"Cannot create Docker container: %s"</span></span>, err) } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err := client.RemoveContainer(docker.RemoveContainerOptions{ ID: c.ID, Force: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }); err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"cannot remove container: %s"</span></span>, err) } }() err = client.StartContainer(c.ID, &amp;docker.HostConfig{}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"Cannot start Docker container: %s"</span></span>, err) }</code> </pre><br>  createOptions () returns a structure with parameters for a container creation operation.  This is where we specify the name of our container that will be used for testing - mydb_test. <br><div class="spoiler">  <b class="spoiler_title">code of these functions</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reateOptions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">docker</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateContainerOptions</span></span></span></span> { ports := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[docker.Port]<span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) ports[<span class="hljs-string"><span class="hljs-string">"3306"</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} opts := docker.CreateContainerOptions{ Config: &amp;docker.Config{ Image: <span class="hljs-string"><span class="hljs-string">"mydb_test"</span></span>, ExposedPorts: ports, }, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> opts }</code> </pre></div></div><br><br>  All we have to do is write the code that will wait for the database to be raised, and return the IP address or the formatted DSN immediately for use with the Go mysql driver. <br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// wait for container to wake up if err := waitStarted(client, c.ID, 5*time.Second); err != nil { t.Fatalf("Couldn't reach MySQL server for testing, aborting.") } c, err = client.InspectContainer(c.ID) if err != nil { t.Fatalf("Couldn't inspect container: %s", err) } // determine IP address for MySQL ip = strings.TrimSpace(c.NetworkSettings.IPAddress) // wait MySQL to wake up if err := waitReachable(ip+":3306", 5*time.Second); err != nil { t.Fatalf("Couldn't reach MySQL server for testing, aborting.") } // pass IP to DB connect code</span></span></code> </pre><br>  The code is not very interesting, so I will also hide it under the spoiler: <br><div class="spoiler">  <b class="spoiler_title">wait code</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// waitReachable waits for hostport to became reachable for the maxWait time. func waitReachable(hostport string, maxWait time.Duration) error { done := time.Now().Add(maxWait) for time.Now().Before(done) { c, err := net.Dial("tcp", hostport) if err == nil { c.Close() return nil } time.Sleep(100 * time.Millisecond) } return fmt.Errorf("cannot connect %v for %v", hostport, maxWait) } // waitStarted waits for container to start for the maxWait time. func waitStarted(client *docker.Client, id string, maxWait time.Duration) error { done := time.Now().Add(maxWait) for time.Now().Before(done) { c, err := client.InspectContainer(id) if err != nil { break } if c.State.Running { return nil } time.Sleep(100 * time.Millisecond) } return fmt.Errorf("cannot start container %s for %v", id, maxWait) }</span></span></code> </pre><br></div></div><br>  All this is enough to move on, but there is one thing - I want this code to work on both MacOS X and Windows, which means that you need to be able to distinguish Linux and non-Linux environments, and be able to support docker-machine or boot2docker (if someone has not moved to the docker-machine yet). <br><br>  Fortunately, this is also a trivial task - you need only a few functions.  In order to find the IP address of the virtual machine in which Docker is running.  You can use the following code: <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// DockerMachineIP returns IP of docker-machine or boot2docker VM instance. // // If docker-machine or boot2socker is running and has IP, it will be used to // connect to dockerized services (MySQL, etc). // // Basically, it adds support for MacOS X and Windows. func DockerMachineIP() string { // Docker-machine is a modern solution for docker in MacOS X. // Try to detect it, with fallback to boot2docker var dockerMachine bool machine := os.Getenv("DOCKER_MACHINE_NAME") if machine != "" { dockerMachine = true } var buf bytes.Buffer var cmd *exec.Cmd if dockerMachine { cmd = exec.Command("docker-machine", "ip", machine) } else { cmd = exec.Command("boot2docker", "ip") } cmd.Stdout = &amp;buf if err := cmd.Run(); err != nil { // ignore error, as it's perfectly OK on Linux return "" } return buf.String() }</span></span></code> </pre><br>  You will also have to pass the port forwarding parameters to CreateContainerOptions. <br><br>  As a result, it will be more convenient to put all this code in a separate package, in a separate subdirectory.  In order not to make this package available outside, I will put it in the <a href="https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit">internal</a> subdirectory - this ensures that only my package can (re) use it. <br><br>  The complete code for this package is: <a href="http://pastebin.com/faUUN0M1">pastebin.com/faUUN0M1</a> <br><br>  Now it can be safely imported into our project, into the code for testing and with one function to get a ready-made DSN for connection. <br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// start db in docker container dsn, deferFn, err := dockertest.StartMysql() if err != nil { t.Fatalf("cannot start mysql in container for testing: %s", err) } defer deferFn() db, err := sql.Open("mysql", dsn) if err != nil { t.Fatalf("Couldn't connect to test database: %s", err) } defer db.Close()</span></span></code> </pre><br>  And transfer db to a further code that will work with the database.  Please note that we call the deferFn () function as expected, but we don‚Äôt even have a clue what it does - it‚Äôs on the conscience of the dockertest package that knows how to clean it and remove the container. <br><br><h4>  Testing http requests </h4><br>  The next step is to check HTTP requests - whether they return the necessary error codes, return the expected data, transfer the necessary headers and the like.  Of course, you can start a real service, and run ‚Äúoutside‚Äù curl requests, but this is awkward, inconvenient and ugly.  Go has a great way to test http handlers - this is the <a href="httptest/">net / http / httptest package.</a> <br><br>  httptest was probably one of the first moments that had a wow effect on me in Go.  The very architecture of building http applications in Go can already cause a similar effect, but it was completely successful here.  How the net / http package is arranged I will not talk about in this article, this is material for a separate article, but in short - there is a standard http.Handler interface that any type that has the ServeHttp method (http.ResponseWriter, * http.Request) satisfies : <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Handler <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { ServeHTTP(ResponseWriter, *Request) }</code> </pre> <br>  The gin web framework, as befits all civilized http frameworks in Go, implements these interfaces, so to test it we can easily construct arbitrary objects satisfying http.ResponseWriter (this is also the interface), send the desired Request and look at the answer!  You do not need to open any external ports, everything will happen in the address space of the test program.  And this is very cool. <br><br>  This is how it looks (I will immediately use the GoConvey described above): <br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db *sql.DB)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gin</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Engine</span></span></span></span> { r := gin.Default() r.Use(cors.Middleware(cors.Options{})) <span class="hljs-comment"><span class="hljs-comment">// more middlewares ... // Health check r.GET("/ping", ping) // CRUD resources usersRes := &amp;UsersResource{db: db} // Define routes api := r.Group("/api") { v1 := api.Group("/v1") { rest.CRUD(v1, "/users", usersRes) } } return r } ... r := NewServer(db) Convey("Users endpoints should respond correctly", t, func() { Convey("User should return empty list", func() { // it's safe to ignore error here, because we're manually entering URL req, _ := http.NewRequest("GET", "http://localhost/api/v1/users", nil) w := httptest.NewRecorder() r.ServeHTTP(w, req) So(w.Code, ShouldEqual, http.StatusOK) body := strings.TrimSpace(w.Body.String()) So(body, ShouldEqual, "[]") }) })</span></span></code> </pre><br>  Now you can add more calls, and check the status ‚Äî say, add a user, and check the list again: <br><pre> <code class="go hljs"> Convey(<span class="hljs-string"><span class="hljs-string">"Create should return ID of newly created user"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { user := &amp;User{Name: <span class="hljs-string"><span class="hljs-string">"Test user"</span></span>} data, err := json.Marshal(user) So(err, ShouldBeNil) buf := bytes.NewBuffer(data) req, err := http.NewRequest(<span class="hljs-string"><span class="hljs-string">"POST"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://localhost/api/v1/users"</span></span>, buf) So(err, ShouldBeNil) w := httptest.NewRecorder() r.ServeHTTP(w, req) So(w.Code, ShouldEqual, http.StatusOK) body := strings.TrimSpace(w.Body.String()) So(body, ShouldEqual, <span class="hljs-string"><span class="hljs-string">"1"</span></span>) }) Convey(<span class="hljs-string"><span class="hljs-string">"List should return one user with name 'Test user'"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { req, _ := http.NewRequest(<span class="hljs-string"><span class="hljs-string">"GET"</span></span>, <span class="hljs-string"><span class="hljs-string">"http://localhost/api/v1/users"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) w := httptest.NewRecorder() r.ServeHTTP(w, req) So(w.Code, ShouldEqual, http.StatusOK) body := w.Body.Bytes() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> users []*User err := json.Unmarshal(body, &amp;users) So(err, ShouldBeNil) user := &amp;User{ ID: <span class="hljs-number"><span class="hljs-number">1</span></span>, Name: <span class="hljs-string"><span class="hljs-string">"Test user"</span></span>, } So(<span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(users), ShouldEqual, <span class="hljs-number"><span class="hljs-number">1</span></span>) So(users[<span class="hljs-number"><span class="hljs-number">0</span></span>], ShouldResemble, user) })</code> </pre><br>  And so on, for any other stateful or not so requests. <br><br><h4>  findings </h4><br>  As you see, Go not only simplifies writing unit tests, creating an incentive to write them at every step, and turning Go programmers into BDD and TDD methodologies, but also opens up new possibilities for more complex integration and acceptance tests. <br><br>  The example given in the article serves only as a demonstration, although it is based on real code, which has been tested in this way for more than 1.5 years in production.  On my Macbook, in which the docker runs inside the virtual machine (through the docker-machine), the entire test (compile the code for the test, pick up the container, drive ~ 35 http requests) takes three seconds.  As for me, it is quite good for this level of test, given the almost complete isolation from the system and cross-platform.  On Linux, this, of course, will be even faster. <br><br>  Of course, different services require different testing scenarios, but this example does not try to answer all cases (remark specifically for the main lair habrrollroll), but is a demonstration of how you can use the Go potential to speed up the integration testing cycle. <br><br>  So, write tests!  With Go, it's so simple that there are no more excuses not to write. </div><p>Source: <a href="https://habr.com/ru/post/271239/">https://habr.com/ru/post/271239/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../271229/index.html">HP P2000 MSA G3 Performance Testing</a></li>
<li><a href="../271231/index.html">Downloading tracks from Autotravel.ru</a></li>
<li><a href="../271233/index.html">We pick up an audio stream from Twilio via SIP and send it to RTMP CDN for further distribution</a></li>
<li><a href="../271235/index.html">How we tested the Russian workflow system on the Scala-R convergent platform</a></li>
<li><a href="../271237/index.html">Features of creating a turnkey web project from Startup Makers</a></li>
<li><a href="../271241/index.html">Forecasting in the gaming industry. Part 3: Forecasts for the forecast industry</a></li>
<li><a href="../271243/index.html">ActiveRecord-based Ruby REST API for accessing tables in a database</a></li>
<li><a href="../271245/index.html">Risks and problems of password hashing</a></li>
<li><a href="../271249/index.html">Modular ASP.NET 5 Application</a></li>
<li><a href="../271255/index.html">Objective-C: how blocks work</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>