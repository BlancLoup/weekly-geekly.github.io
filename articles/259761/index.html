<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>The device of the game engine for NES on the example of the games "Capcom"</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In my third article about NES-games, I will show the techniques used to create game engines, namely the implementation of screen scrolling, switching ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>The device of the game engine for NES on the example of the games "Capcom"</h1><div class="post__text post__text-html js-mediator-article">  In my third article about NES-games, I will show the techniques used to create game engines, namely the implementation of screen scrolling, switching memory banks, organizing the list of objects, device character animation system, game object update functions (and collision processing), the main card device .  In order not to be unfounded in the descriptions, I will cite a disassembled code from specific games (beloved by everyone ‚ÄúDarkwing Duck‚Äù, with references to ‚ÄúChip &amp; Dale‚Äù and ‚ÄúDuck Tales‚Äù);  As an example, we consider the engine from Capcom, which has at least a <a href="https://ru.wikipedia.org/wiki/%25D0%25A1%25D0%25BF%25D0%25B8%25D1%2581%25D0%25BE%25D0%25BA_%25D0%25B8%25D0%25B3%25D1%2580_Capcom">couple of dozen games to work on</a> . <br><br>  Some of the topics are not related, so the article will be divided into several sections.  Also, because of the vastness, the material would be enough for a small book, so sometimes I will give links to articles for those who want to understand the details, and describe only general things relating to the architecture of engines. <br><a name="habracut"></a><br>  For the research, the disassembler built into the <b>FCEUX</b> emulator will be used, as well as the well-known <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA</a> disassembler for working with the code base (you can do without it using the notebook and pen).  Here (the cycle ‚ÄúDocumentation for FCEUd‚Äù) there are several articles on using the debugger.  The idea of ‚Äã‚Äãthe search is known, probably, to anyone who was engaged in reverse engineering - you need to find in the memory any address whose purpose is known and refers directly or indirectly to the studied functionality, and set a stopping point at this address in the debugger.  Next, the researcher starts the game, waits for the breakpoint to work and learns the code that led to the triggering, thus obtaining information about what is happening in the game ‚Äúunder the hood‚Äù.  Below are examples of studies of the engine. <br><br><h2>  Screen scrolling implementation </h2><br>  If the game has more than one screen per level, then as the player approaches its boundaries, it is necessary to constantly update the picture.  You can run the game ‚ÄúDarkwing Duck‚Äù in the emulator, load the first level and open the <i><b>Debug-&gt; Name table viewer</b></i> screen <i><b>viewer</b></i> .  If you now go to the right one step and observe the changes in this window, then you will notice that the game updates 2 blocks (2x2 tiles each, only 8 tiles of video memory) each emergency step: 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <img src="https://habrastorage.org/files/a9d/9f9/ddb/a9d9f9ddb08546a78a2c91ba61e93589.png"><br>  (This time I will use screenshots from game hacks for a change) <br><br>  Thus, in 16 steps of the Black Raincoat, a scrolling on one line takes place, which will be ready completely by this moment.  The NES video processor is able to display the screen portion of the screen with an offset, so the screen continues to be built to the right, avoiding copying all the tiles that have already been drawn.  Also for the video processor there are several option flags that allow you to adjust the cyclical repetition of the page horizontally.  So after completing the screen to the right border, the next row will simply be built on the left. <br><br>  You can check how scrolling works technically.  To do this, you need to set a stop point in the debugger to write to the video memory at the address range of <i>$ 2007- $ 23BF</i> (option <b><i>PPU MEM</i></b> in the debugger) at the moment when the level is already loaded.  Then the game starts, and the state of emergency is sent forward so that the scrolling will work and the emulator will stop the game and show the debugger window: <br><br><pre><code class="hljs pgsql">ROM:C119 loc_C119:; CODE XREF: ROM:C137 ROM:C119 LDA <span class="hljs-meta"><span class="hljs-meta">$360</span></span>,X ROM:C11C BMI locret_C139 ROM:C11E STA byte_2006 ROM:C121 LDA <span class="hljs-meta"><span class="hljs-meta">$361</span></span>,X ROM:C124 STA byte_2006 ROM:C127 LDY <span class="hljs-meta"><span class="hljs-meta">$362</span></span>,X ROM:C12A ROM:C12A loc_C12A:; CODE XREF: ROM:C132 ROM:C12A LDA <span class="hljs-meta"><span class="hljs-meta">$363</span></span>,X &gt;ROM:C12D STA byte_2007 ROM:C130 INX ROM:C131 DEY ROM:C132 BPL loc_C12A ROM:C134 INX ROM:C135 INX ROM:C136 INX ROM:C137 BNE loc_C119</code> </pre> <br>  Communication with video memory in NES occurs through the address space of the processor, address <i>$ 2006</i> is used for addressing, and address <i>$ 2007</i> is for reading and writing values ‚Äã‚Äãto memory.  Then you can understand the logic of the code above - this is the function of reading records about where, from where, and how many bytes to copy to the video memory from RAM.  The entries themselves start at <i>$ 360</i> and have the following format: <br>  <b>COPY_TO_VIDEO_REC | stop byte 0xFF</b> , where <i>COPY_TO_VIDEO_REC</i> = <b>(write address in video memory, how many bytes to copy, bytes to copy)</b> . <br><br>  Next, the stopping point is rearranged to write to the region <i>0x360-0x36F</i> , in which this data is stored, and the debugger shows a large scroll function at <i>$ DB40- $ DD09</i> (457 bytes).  The function is multipurpose and is used in all types of scrolling in the game (right, up, down), there are many branches in it depending on the setting of different bits.  At the input of the function - the scrolling value of the character in the cells <i>$ 23</i> and <i>$ 25</i> (two-byte). <br>  Then I will skip part of the research (it consists in rearranging the breakpoints and checking where the data originally came from and what transformations they undergo) and lay out the graph of the transformation functions: <br><br><img src="https://habrastorage.org/files/424/fe1/304/424fe1304ae54eaebd443b41f53d6dc7.png"><br><br>  As you can see from the graph, I did not understand the whole function, but focused on its lower part ‚Äî at the address <i>$ 140</i> and further in RAM there are selected block indices from those macroblocks that will be displayed on the screen, and then, from this series of data, records are made for copying to video memory (row <i>0x360</i> ) is enough to understand the device scrolling, the upper part describes the transformation of coordinates and the selection of data on the number of the active screen in the ROM image. <br><br>  In other engines, the device is similar - there are a number of addresses for copying and a number for storing indexes of macroblocks, sometimes located at the same address. <br><br><h2>  Level Configs and Memory Bank Switching </h2><br>  Dealing with the flow of data about the level further and further, one can come to the original storage locations - the place of their recording in the ROM image.  Often, data records of all levels are grouped together and are called level <b><i>configs</i></b> . <br>  For example, configs of levels and doors for the game "Chip &amp; Dale": <br>  Door description (25 records) <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">1</span></span>E673 -    . <span class="hljs-number"><span class="hljs-number">1</span></span>E68B - Y . <span class="hljs-number"><span class="hljs-number">1</span></span>E6A3 - X . <span class="hljs-number"><span class="hljs-number">1</span></span>E6BB -    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> . <span class="hljs-number"><span class="hljs-number">1</span></span>E6D3 -    <span class="hljs-keyword"><span class="hljs-keyword"></span></span> . <span class="hljs-number"><span class="hljs-number">1</span></span>E6EB -   . <span class="hljs-number"><span class="hljs-number">1</span></span>E703 -    (          <span class="hljs-keyword"><span class="hljs-keyword"></span></span> ). <span class="hljs-number"><span class="hljs-number">1</span></span>E71B -     (<span class="hljs-keyword"><span class="hljs-keyword"></span></span>    ). <span class="hljs-number"><span class="hljs-number">1</span></span>E734 -    Y. <span class="hljs-number"><span class="hljs-number">1</span></span>E74C -    X.</code> </pre> <br>  Description of levels (15 entries) <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">101</span></span>B2, <span class="hljs-number"><span class="hljs-number">101</span></span>A3 -      X  ( ). <span class="hljs-number"><span class="hljs-number">101</span></span>D0, <span class="hljs-number"><span class="hljs-number">101</span></span>C1 -      X  (  ). <span class="hljs-number"><span class="hljs-number">101</span></span>EE, <span class="hljs-number"><span class="hljs-number">101</span></span>DF -      Y  ( ). <span class="hljs-number"><span class="hljs-number">1020</span></span>C, <span class="hljs-number"><span class="hljs-number">101</span></span>FD -      Y  (  ). <span class="hljs-number"><span class="hljs-number">1022</span></span>A, <span class="hljs-number"><span class="hljs-number">1021</span></span>B -   <span class="hljs-built_in"><span class="hljs-built_in"></span></span> . <span class="hljs-number"><span class="hljs-number">10248</span></span>, <span class="hljs-number"><span class="hljs-number">10239</span></span> -       <span class="hljs-keyword"><span class="hljs-keyword"></span></span>    . <span class="hljs-number"><span class="hljs-number">1</span></span>E201 -       ( <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  ). <span class="hljs-number"><span class="hljs-number">1</span></span>E26A -    . <span class="hljs-number"><span class="hljs-number">1</span></span>E2A6, <span class="hljs-number"><span class="hljs-number">1</span></span>E297 -    ( ). <span class="hljs-number"><span class="hljs-number">1</span></span>E2C4, <span class="hljs-number"><span class="hljs-number">1</span></span>E2B5 -    (  +  ). <span class="hljs-number"><span class="hljs-number">1</span></span>E210 -     . <span class="hljs-number"><span class="hljs-number">1</span></span>E23D -    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  (<span class="hljs-number"><span class="hljs-number">8</span></span>x=enemy gfx, <span class="hljs-number"><span class="hljs-number">9</span></span>x=tile gfx). <span class="hljs-number"><span class="hljs-number">1</span></span>E24C -    <span class="hljs-keyword"><span class="hljs-keyword"></span></span>  (<span class="hljs-number"><span class="hljs-number">8</span></span>x=enemy gfx, <span class="hljs-number"><span class="hljs-number">9</span></span>x=tile gfx). <span class="hljs-number"><span class="hljs-number">1</span></span>E25B -  ,   . <span class="hljs-number"><span class="hljs-number">1</span></span>E279 -   ,   . <span class="hljs-number"><span class="hljs-number">1</span></span>E288 -     (<span class="hljs-keyword"><span class="hljs-keyword"></span></span>    ). <span class="hljs-number"><span class="hljs-number">1</span></span>E22E -  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   . <span class="hljs-number"><span class="hljs-number">1</span></span>E21F -  <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   .</code> </pre><br>  Hence, observant readers have a question, why do all the pointers occupy only two bytes, because with the help of 16 bits only 64 kb of memory can be addressed, and the size of ROM images can be much more?  The answer is that NES uses special chips in cartridges that control the connection of different banks of memory, the mappers, to bypass this limitation.  They determine which ROM memory bank will be read from when accessing the processor's address space, which is responsible for reading from the ROM.  About pointers to NES can be read in the <a href="http://cah4e3.shedevr.org.ru/nes_inside.php">article cah4e3'a</a> . <br><br>  Memory banks are a serious limitation of NES when programming (often for a certain task you need free space in a particular bank, even if it is still enough in others) and additional difficulties in the study (you need to compare pointers and banks in which they address the memory). <br><br>  From this architecture, there are two possible ways to distribute data among banks - either to store all data of one level in one bank, or to store all data sets of one type in one bank (macroblocks in one, blocks in another, screens in the third).  In various engines, both the first and second approaches are encountered.  In Capcom, most often they store data of the same level in one bank ‚Äî in Mega Man 4, for example, even all pointers to blocks and macroblocks are the same, that is, when switching banks, data is mapped to the same addresses in the processor's address space.  Even so, however, the switching of banks is carried out several times per frame, that is, the necessary data is still scattered in different places of the ROM image. <br><br><h2>  Organization of the list of objects </h2><br>  In addition to the level card, a full-fledged game also requires specifying a list of game objects - bonuses, enemies, destructible objects, animation objects for decoration, doors and other logical elements of the game.  In the previous two paragraphs it was shown how to get to the configs of the levels, where you can most likely find a pointer to the beginning of the list of game objects.  You can also find this list in another way - to calculate the places in the RAM, which store information about the objects on the screen, and start searching for the address from them.  There are several ways to ‚Äúhook‚Äù on these addresses in memory: <br><ul><li>  When an enemy appears on the screen, slow down the time and check its X, Y coordinates or other parameters ( <b><i>Tools-&gt; Ram Search ...</i></b> menu).  So it is found that the parameters of enemies on the screen for ‚ÄúDarkwing Duck‚Äù in RAM are stored by columns <i>0x580</i> (for the first area, <i>0x581</i> for the second, <i>0x582</i> - for the third, etc.) - direction of movement of the object, <i>0x5A0</i> - remaining health, etc. .  Among them you can find the number of the object </li><li>  Observe the counter of objects that appear on the screen.  It increases by 1 when the next object appears.  By the way, it can be viewed without searching in memory, and from directly looking into RAM (in FCEUX, this is convenient due to the feature of recently modified cells ( <i><b>Tool-&gt; Hex Editor</b></i> menu): <br><br><img src="https://habrastorage.org/files/8d8/f13/c53/8d8f13c53ec84b4082d1fde16fe2eb00.png"><br>  The <i>0x70</i> cell grows at the same time as a new object appears on the screen (both in Darkwing Duck and Chip &amp; Dale). <br></li><li>  In games with scoring for killing enemies, you can put a stopping point to increase the points counter and so go to the scoring function, which also uses data on the number of the enemy to calculate the number </li><li>  Other methods, limited only by the imagination of the researcher </li></ul><br>  Regardless of the method chosen from the above, sooner or later the study leads to the configs of the levels, from where you can find the addresses of the beginning of the list of objects.  For Darkwing Duck, the address of the object descriptions is: <br><pre> <code class="hljs">1  ‚Äî 0x10315-0x10347 2  ‚Äî 0x10438-0x10473 3  ‚Äî 0x10584-0x105C7 6  ‚Äî 0x106A0-0x106D5 4  ‚Äî 0x10816-0x10865 5  ‚Äî 0x10962-0x109A0 7  ‚Äî 0x10A89-0x10AC2</code> </pre><br>  After some experiments on <a href="http://habrahabr.ru/post/259483/">data corruption</a> in the neighborhood of these addresses, their structure becomes clear - there are 4 arrays of the same length in front of the list of objects themselves, with a pair of X and Y coordinates of the objects.  The high byte indicates the coordinate of the screen on which the object appears, and the low byte indicates the coordinate of the object itself on the screen.  Thus, the entire description of the position and type of object takes 5 bytes. <br>  It also becomes clear that the objects in the list should be sorted in the order in which they appear on the screen, as there is a procedure in the engine that checks the appearance of the next object in the list, and only then increases the counter by 1 and checks the next object.  If he is behind the player (and there is no scrolling back in the game), he will never appear on the screen.  There are several other features of the engine that relate to the list of objects that need to be considered when sorting objects, for example, after entering the door, the counter is reset and the engine searches for the first object in the list that matches the Y coordinate of the screen, starting with the first one.  This allows you to build levels with several alternative transitions that were not in the original game. <br><br>  In other engines, the device of the list of objects is very similar, sometimes there are features, such as encoding one of the object's coordinates with one byte (either multiplying it by a constant, or using a fixed address as the base for a whole set of objects, for example, in ‚ÄúDuck Tales 2‚Äù) or variable length of entries in the list of objects (for example, ‚ÄúNew Ghostbusters 2‚Äù, where coordinates are stored for enemies, while for the doors there is an additional room to which the transition will be made). <br><br>  Decode all types of objects for Duck Tales: <a href="https://gist.github.com/spiiin/5524555">gist.github.com/spiiin/5524555</a> <br><br><h2>  Device animation system </h2><br>  The object number is not just a constant, but an index in the array of records for all objects. <br>  The write stop point for the address range <i>0x05A4 - 0x05AF</i> (it contains object numbers on the screen) shows the place where the characteristics of the objects are loaded from: <br><pre> <code class="hljs erlang-repl">LDA (<span class="hljs-number"><span class="hljs-number">06</span></span>), y. [cpu addr <span class="hljs-number"><span class="hljs-number">0</span></span>x8C57-&gt;rom addr <span class="hljs-number"><span class="hljs-number">0</span></span>x10C67] - <span class="hljs-number"><span class="hljs-number">4</span></span>   () LDA (<span class="hljs-number"><span class="hljs-number">04</span></span>), y. [cpu addr <span class="hljs-number"><span class="hljs-number">0</span></span>x8AB3-&gt;rom addr <span class="hljs-number"><span class="hljs-number">0</span></span>x10AC0] - <span class="hljs-number"><span class="hljs-number">4</span></span>   ()</code> </pre><br>  The first array stores the number of lives of the object and 3 empty fields (apparently inherited from the Mega Man 4 engine, where the characteristics were greater), and in the second: <br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">1</span></span>-  - <span class="hljs-built_in"><span class="hljs-built_in"></span></span> . <span class="hljs-number"><span class="hljs-number">2</span></span>-  -     (         ). <span class="hljs-number"><span class="hljs-number">3</span></span>-  -    . <span class="hljs-number"><span class="hljs-number">4</span></span>-  -   -   <span class="hljs-keyword"><span class="hljs-keyword"></span></span>   .</code> </pre><br>  Next, the animation number is examined, which in a few steps leads to an understanding of the storage device of the animation system of objects. <br><br>  Each animation consists of several frames and the time it plays: <br><pre> <code class="hljs 1c"><span class="hljs-built_in"><span class="hljs-built_in"></span></span> : { <span class="hljs-number"><span class="hljs-number">1</span></span>  - -  N. <span class="hljs-number"><span class="hljs-number">1</span></span> . . N  -  . }</code> </pre> <br><br>  Timer frame switches to the following: <br><pre> <code class="hljs 1c"><span class="hljs-built_in"><span class="hljs-built_in"></span></span> : {          ( <span class="hljs-number"><span class="hljs-number">1</span></span>.  -  ) }</code> </pre> <br>  (The frame array is divided into two parts in the ROM image due to its large size in order to divide it into different banks). <br><br>  All frame tiles are displayed on the screen using standard tools for NES - in addition to the screen pages, the video processor can draw tiles on the screen (8x8 in size) in arbitrary places on the screen, for more information on displaying sprites on the screen, see the <a href="http://dendy.migera.ru/nes/g02.html">article</a> ‚ÄúSprites.  DMA controller. <br><br>  This animation system is used in the games ‚ÄúDarkwing Duck‚Äù, ‚ÄúChip &amp; Dale‚Äù, ‚ÄúDuck Tales‚Äù (first parts, in ‚ÄúChip &amp; Dale 2‚Äù and ‚ÄúDuck Tales 2‚Äù its own system), ‚ÄúLittle Mermaid‚Äù, ‚ÄúTale Spin‚Äù "," Mega Man "(from second to fifth parts)," Mighty Final Fight ". <br>  To edit animations, you can use the <a href="https://github.com/spiiin/CadEditor">CadEditor</a> editor or the <a href="http://www.romhacking.net/utilities/983/">Capcom Sprite Assembler</a> utility: <br><br><img src="https://habrastorage.org/files/698/390/bdc/698390bdc81a4e3e8ad24534310e42c2.png"><br><br><h2>  Functions for updating game objects </h2><br>  When a game object appears in the frame, each game cycle for it calls the update function, which is responsible for all the game logic - moving it around the screen, spawning new objects (for example, bullets), handling collisions between walls, floor and other objects, as well as switching logical phases and animations (for example, <i>walking-&gt; jumping-&gt; landing</i> ). <br><br>  The search for the update function number can be viewed in the previous section. Further, it is necessary to examine the memory cells in which the current parameters of the object are stored.  For Darkwing Duck, this is: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-number"><span class="hljs-number">4</span></span>D0 -  (<span class="hljs-regexp"><span class="hljs-regexp">/  /</span></span><span class="hljs-regexp"><span class="hljs-regexp">//</span></span> etc.). <span class="hljs-number"><span class="hljs-number">420</span></span> -   <span class="hljs-number"><span class="hljs-number">580</span></span> -   <span class="hljs-number"><span class="hljs-number">5</span></span>A0 -   (<span class="hljs-number"><span class="hljs-number">80</span></span>,   ) <span class="hljs-number"><span class="hljs-number">410</span></span> -   <span class="hljs-number"><span class="hljs-number">430</span></span> -     <span class="hljs-number"><span class="hljs-number">400</span></span> -  ( , ,   , etc.)  .</code> </pre> <br>  This is followed by painstaking work on understanding the logic of each function of objects (usually difficult only for the first two or three, then everything repeats). <br>  For an example, the code of the update function of the first enemy of the Black <a href="https://gist.github.com/spiiin/14197bc6b8889a0dd4f0">Raincoat</a> , Robot: <a href="https://gist.github.com/spiiin/14197bc6b8889a0dd4f0">gist.github.com/spiiin/14197bc6b8889a0dd4f0</a> <br><br>  The robot has two phases, in the first ( <b>‚ÄúPatrol‚Äù</b> ) it does not leave its post and walks in a small radius from it, sometimes stopping to turn its head in search of the Black Coat.  If the distance to the player decreases to 32 pixels, or the health of the Robot decreases, he moves into the <b>‚ÄúAttack‚Äù</b> phase, in which he begins to move in the direction from which the player is located, and he changes direction only if he gets into a deadlock from which can get a jump. <br><br>  There are no special tools for creating your objects, you need to rewrite the code, preferably getting into the size limit on the update function.  However, this does not prevent the creation of such fantastic hacks as <a href="http://www.romhacking.net/hacks/910/">"Rockman Minus Infinity"</a> . <br><br><h2>  Main card device </h2><br>  The bonus will be a small section about the main card device.  For her, ‚ÄúDarkwing Duck‚Äù uses not a block method, but a descriptive method (for methods of storing data, see the <a href="http://habrahabr.ru/post/259171/">first article of the cycle</a> ). <br>  At the same time, in order to change the card, apart from parsing the storage method (which I will skip in order not to overload the article with the assembler code), you must also write a way to save the card back into the ROM image.  The descriptive method of storage means that all chains of zeros are thrown out of the map, and instead of them, before each chain of data, the address from which it starts is indicated, so that it is clear where to enter the data into the card: <br><br><img src="https://habrastorage.org/files/91b/184/156/91b184156b2d4d319530d7efb3c1ba24.png"><br><br>  Packer code in C #: <a href="https://gist.github.com/spiiin/8738491">gist.github.com/spiiin/8738491</a> <br><br>  Now you can add a map to the editor: <br><br><img src="https://habrastorage.org/files/5a1/392/ccd/5a1392ccd89647f794e98985dac3b376.png"><br><br>  ... and, for example, to resettle the Black Raincoat from Saint-Canard to another city: <br><br><img src="https://habrastorage.org/files/457/679/d99/457679d994724a1489c9d7105aa7452d.png"><br><br><h2>  Afterword </h2><br>  For those who are not satisfied with this, I can offer to continue the independent research of the engine, or study the disassembled commented code of the <a href="http://www.romhacking.net/documents/363/">‚ÄúMega Man 4‚Äù</a> engine, similar to ‚ÄúDarkwing Duck‚Äù.  From there you can learn some information that is not disassembled in the article, for example, the sound engine device or the device of special effects, such as background animation by switching palettes, and others. <br><br>  If someone is interested in other aspects of the device game engines, welcome to the comments, I will try to help you figure it out. </div><p>Source: <a href="https://habr.com/ru/post/259761/">https://habr.com/ru/post/259761/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../259739/index.html">The digest of interesting materials for the mobile developer # 106 (June 1-7)</a></li>
<li><a href="../259745/index.html">Google expands its data centers in Asia</a></li>
<li><a href="../259747/index.html">Flickr Image Gallery with Shortcode API</a></li>
<li><a href="../259749/index.html">Installing vmware tools for debian 8 in a virtual machine [manual]</a></li>
<li><a href="../259755/index.html">Oberon system implemented on an affordable FPGA board</a></li>
<li><a href="../259763/index.html">Confusion with job titles</a></li>
<li><a href="../259765/index.html">Views on Zend PHP Certification</a></li>
<li><a href="../259767/index.html">The digest of interesting materials from the world of web development and IT for the last week ‚Ññ163 (June 1 - 7, 2015)</a></li>
<li><a href="../259771/index.html">As I was increasing machine learning conversion</a></li>
<li><a href="../259773/index.html">Digest of grocery design, May 2015</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>