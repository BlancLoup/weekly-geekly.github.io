<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Isomorphic JavaScript - the future of web applications</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="At Airbnb, we have learned a lot over the past few years, creating powerful web applications. We plunged into the world of one-page applications in 20...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Isomorphic JavaScript - the future of web applications</h1><div class="post__text post__text-html js-mediator-article">  At Airbnb, we have learned a lot over the past few years, creating powerful web applications.  We plunged into the world of one-page applications in 2011, doing a <a href="https://m.airbnb.com/">mobile version of our site</a> , since then, among other things, we launched <a href="https://www.airbnb.com/wishlists">Wish Lists</a> and a new <a href="https://www.airbnb.com/s">search</a> .  These are all large JavaScript applications, which means that tons of code are launched in the browser to provide a modern, interactive user experience. <br><br>  This is the usual approach today when libraries such as backbone.js, ember.js and angular.js help developers create powerful JavaScript applications.  We realized, however, that such applications have several critical limitations.  To make it clear, let's take a little tour of the history of web applications. <br><img src="https://habrastorage.org/getpro/habr/post_images/46c/ac6/aaa/46cac6aaae1f39653489190e697eefdb.png"><br>  <sub>Picture from the article to attract attention</sub> <br><br><a name="habracut"></a><br><h4>  Javascript matures </h4><br>  At the dawn, Web interaction with browsers was like this: a web browser requested each page (for example, <a href="http://www.geocities.com/">www.geocities.com</a> ) forcing a server somewhere on the Internet to generate HTML and send it back.  This was a good approach, since browsers were not particularly powerful at that time, and the HTML pages were mostly static and autonomous.  JavaScript, created to allow web pages to be more dynamic, did not allow anything more complex than a slideshow or a date picker. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      After several years of computer technology, enthusiastic developers pushed the web beyond its limitations, forcing it to evolve.  Now the web is so developed that it has become a full-fledged platform for applications - and fast JavaScript and html5 standard allow developers to create powerful applications that could only be done under a specific platform. <br><br><h4>  Single Page Applications </h4><br>  After some time, developers began to create entire applications in the browser, using JavaScript and new features.  Applications like Gmail (a classic example of a one-page application) can instantly react to user actions, no longer need to run full circle to the server, just to display a new page. <br><br>  Libraries like backbone.js, ember.js, and angular.js are often referred to as client MVC or MVVM libraries.  The classic MVC client architecture looks like this: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/795/0d0/aad/7950d0aad9d3e5feba0fdfaaef616a54.png" alt="image"><br><br>  A large amount of application logic (views, templates, controllers, models, internationalization, etc.) lives on the client, a special API is used for the data.  The server can be written in any language, such as Ruby, Python or Java.  In most cases, their role is to give away a frame page.  As soon as the JavaScript files are loaded by the browser, they are executed, the client application is initialized, the data is loaded via the corresponding API, and the rest of the HTML is drawn. <br><br>  This is good for users, because once loaded, the application can quickly switch between pages without reloading, and, if done correctly, even work offline. <br><br>  This is also good for developers, as the ideal one-page application has a clear separation of tasks into client and server, which provides an excellent development process and prevents the need to duplicate too much logic between two environments, which are also often written in different languages. <br><br><h4>  Trouble in Paradise </h4><br>  In practice, however, this approach has several fatal flaws that prevent it from being used in many cases. <br><br><h5>  Search engine optimization </h5><br>  An application that works only on the client cannot interact normally with search robots, that is, it is ill suited for SEO by default.  Search robots work by creating requests to the web server and interpreting the results, but if the server returns only a blank page, this is of little use.  There are of course and workarounds, but not without dancing with a tambourine. <br><br><h5>  Performance </h5><br>  For the same reason, if the server does not generate the entire page, and instead have to wait for JavaScript to load on the client, users see a blank page or download icon for a few critical seconds.  A lot of research has been conducted studying the effect of slow websites on users, and, accordingly, on profits.  <a href="http://www.strangeloopnetworks.com/resources/infographics/web-performance-and-ecommerce/amazon-100ms-faster-1-revenue-increase/">Amazon claims</a> that every 100 ms load reduction increases profits by 1%.  Twitter spent a year of working together 40 developers reworking the site to <a href="https://blog.twitter.com/2012/improving-performance-twittercom">generate pages entirely on the server instead of the client</a> , receiving a 5-fold improvement in perceived load time. <br><br><h5>  Support </h5><br>  This should ideally be a nice, well-separated code in life; t inevitably, part of the application logic or display logic is duplicated between the client and the server, often written in different languages.  The standard example is date or currency formatting, form validation and routing logic.  All this makes support a nightmare, especially in the case of complex applications. <br><br>  Some developers, including me, are lumping here - often only after you have spent a lot of time and effort creating a one-page application - these flaws float out. <br><br><h4>  Hybrid approach </h4><br>  As a result, we need a hybrid of new and old approaches: we want to get fully formed HTML from the server for reasons of performance and SEO, but we also need the speed and flexibility of the client-side applications. <br><br>  To achieve this, we, in Airbnb, are experimenting with ‚Äúisomorphic JavaScript applications‚Äù, JavaScript applications that can work both on the client and on the server. <br><br>  An isomorphic application looks like this.  Captioned ‚ÄúClient Server MVC‚Äù: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/314/bf6/7fb/314bf67fb1bb504a92ac74c14b87c46b.png" alt="image"><br><br>  Here, part of the application or mapping logic can be executed both on the server and on the client.  This provides many options: runtime optimization, better support, default SEO, and more controlled web applications. <br><br>  C <a href="http://nodejs.org/">node.js</a> is a fast, stable server-side JavaScript part, we can finally turn this dream into a reality.  Having created the necessary abstractions, we can write the logic of our application such that it runs both on the server and on the client ‚Äî this is isomorphic JavaScript. <br><br><h4>  Isomorphic javascript in the wild </h4><br>  The idea is not new - Nodejitsu made a <a href="http://blog.nodejitsu.com/scaling-isomorphic-javascript-code">good description of the</a> architecture of isomorphic JavaScript back in 2011 - but it was difficult to adapt.  Since then, several more isomorphic frameworks have emerged. <br><br>  Mojito was the first known open source isomorphic framework.  It is an advanced, full-stack framework based on node.js, but it depended on yui, and yahoo fads did not contribute to its particular popularity in the JavaScript community since it <a href="http://developer.yahoo.com/blogs/ydn/yahoo-mojito-now-open-source-52490.html">became open</a> in April 2012. <br><br>  <a href="http://www.meteor.com/">Meteor</a> is probably the most widely known isomorphic project today.  Meteor was created from scratch to support real-time applications, and its team created a whole ecosystem around its batch system and deployment tools.  Like Mojito, this is a large, overconfident node.js framework.  However, a lot has been done to attract the JavaScript community, and their most anticipated release 1.0 is just around the corner (approx. Trans. In early 2014).  Meteor is a project to watch out for - a star team, $ 11.2 million financing from Andreessen Horowitz is unheard of for a company that is fully focused on the release of an open source product. <br><br>  <a href="https://asana.com/">Asana</a> , a Facebook based task management app with co-founder Dustin Moskowitz, has an interesting isomorphic history.  Without having problems with financing, considering the status of Moskowitz as the youngest billionaire in the world, Asana conducted years of research, developing her own closed source code <a href="https://asana.com/luna">Luna</a> - one of the most advanced examples of isomorphic JavaScript.  Luna, originally created on <a href="https://code.google.com/p/v8cgi/">v8cgi</a> (in the days preceding node.js), allowed to run a copy of the application on the server for each user session.  For each user, a separate server process was launched, executing the same JavaScript code running on the client.  This gave all the advantages of advanced optimization, such as offline resistance and fast response. <br><br>  We also created our isomorphic library this year.  It is called <a href="http://nerds.airbnb.com/weve-launched-our-first-nodejs-app-to-product/">Rendr</a> .  It allows you to create backbone.js + handlebars.js one-page applications that can also completely form pages on the server.  Rendr is the result of our experience reworking the <a href="https://m.airbnb.com/">mobile version of Airbnb</a> to improve download speed, which is especially important for mobile users who have high data transfer delays.  Rendr is a library rather than a framework that solves several problems (if you compare it with Mojito or Meteor), but it is easy to change and expand. <br><br><h4>  Abstractions, abstractions, abstractions </h4><br>  All of these projects are quite large - which means that full-stack frameworks face rather difficult problems.  The client and server are quite different environments, so you need to create a specific set of abstractions that will separate the application logic from the underlying implementations, so that you can create a single API for application developers ... <br><br><h5>  Routing </h5><br>  We need a single set of routes that match certain URI patterns to the appropriate handlers.  These handlers should have access to: HTTP headers, cookies, information from URIs and the possibility of redirection without direct access to windows.location (in the browser) and req and res (in node.js). <br><br><h5>  Loading and saving data </h5><br>  It is necessary to somehow describe the resources needed to render specific pages or components, regardless of loading mechanisms.  The resource description must be a simple URI pointing to a specific JSON, or, for large applications, it may be useful to encapsulate resources into models and collections and determine the model class and primary key that would somehow be translated into a URI. <br><br><h5>  Page generation </h5><br>  Are we going to change the DOM manually, or using HTML template engines, or using any component library that abstracts from the DOM, in any case, we need to be able to generate markup isomorphically.  It should be possible to generate any presentation on both the server and the client, depending on the needs of the application. <br><br><h5>  Assembly and packaging </h5><br>  It turns out that writing isomorphic application code is only half the battle.  Tools such as <a href="http://gruntjs.com/">grunt</a> and <a href="http://browserify.org/">browserify</a> are an integral part of creating and running applications.  Assembly usually requires several steps: compiling templates, including client dependencies, applying transformations, minifying, etc.  In the simplest case, you need to collect all the application code, presentation and templates into a single package, but for large applications, this may turn into the need to transfer hundreds of kilobytes to the client.  A more advanced approach is to create a dynamic bundle and provide the possibility of deferred loading, but in this case, the complexity quickly increases.  Statistical code analysis tools such as <a href="http://esprima.org/">Esprima</a> allow aspiring developers to perform advanced optimization and <a href="http://en.wikipedia.org/wiki/Metaprogramming">metaprogramming</a> to reduce the amount of template code. <br><br><h4>  We assemble from small modules </h4><br>  Entering the market with the first isomorphic framework means that you managed to solve all these problems.  But the result may be a huge, unwieldy framework that will be difficult to adapt and integrate into existing applications.  As more and more developers are connecting to solving these problems, we will soon face the emergence of a large number of small, reusable modules that can be put together to create isomorphic applications. <br><br>  Obviously, most JavaScript modules can already be used isomorphically, either without or with minor modifications.  For example, such popular libraries as undrscore, backbone, handlebars, moment and even jquery can already be used on the server. <br><br>  To demonstrate all this, I created a small application called an <a href="https://github.com/spikebrehm/isomorphic-tutorial">isomorphic tutorial</a> that you can take from GitHub.  By combining several modules together, each of which can be used isomorphically, it is quite simple to create a small isomorphic application in a hundred lines of code.  Here are used: <a href="https://github.com/flatiron/director">Director</a> for server and browser routing, <a href="https://github.com/visionmedia/superagent">Superagent</a> for HTTP requests and <a href="">handlebars</a> for templating, all this is built on top of the usual <a href="https://github.com/visionmedia/express">express.js</a> application.  Of course, as the complexity of the application grows, you will need to add additional layers of abstraction, but I hope that the more developers experiment with this approach, the more new libraries and standards will appear. <br><br><h4>  Look around </h4><br>  The more organizations will run node.js in production, the more relentless it will be that more and more code will be shared between the client and the server.  It is important to remember that isomorphic JavaScript can be used both locally for narrow and wide tasks ‚Äî you can start by separating the templates, moving on to separating the entire display subsystem, and completing the business logic of the application with a complete separation.  The specific way in which JavaScript is divided between environments depends entirely on how the application is created and on its features. <br><br>  Nicholas C. Zakas perfectly <a href="http://www.nczonline.net/blog/2013/10/07/node-js-and-the-new-web-front-end/">described</a> how, in his opinion, applications will transition the UI layer from client to server, giving a performance gain and better support.  To use isomorphic JavaScript, you will not need to abandon the existing backend and replace its node.js, throwing out the child with water.  Instead, by creating the right API and using the RESTful approach, the traditional backend can live peacefully next to node.js. <br><br>  In Airbnb, we have already begun to redo the process of creating the client side using node-based tools such as grunt and browserify.  Our main rails application can never be completely displaced by node.js, but using them together makes it even easier to share certain parts of JavaScript between environments. </div><p>Source: <a href="https://habr.com/ru/post/203444/">https://habr.com/ru/post/203444/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../203432/index.html">We analyze the interface details-errors on the example of one bank client</a></li>
<li><a href="../203434/index.html">How to reinstall Windows 8 Single Language pre-installed on a laptop?</a></li>
<li><a href="../203438/index.html">Northern Lights right in your browser as a panoramic movie</a></li>
<li><a href="../203440/index.html">Layout for the smallest. We impose a page on BEM</a></li>
<li><a href="../203442/index.html">National Cloud Platform. Where is the money, Zin?</a></li>
<li><a href="../203446/index.html">UrtheCast starts!</a></li>
<li><a href="../203448/index.html">LinkMeUp. Release 9. Intelligent Network Control Systems and the NOC project</a></li>
<li><a href="../203450/index.html">Microsoft Xbox One Complete Parsing</a></li>
<li><a href="../203452/index.html">Softphone 3CXPhone for Mac OS released</a></li>
<li><a href="../203454/index.html">An example of the implementation of call history for IP-PBX 3CX Phone System</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>