<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>As I wrote a custom locker</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hi to habrastarezilam from habranovichka. Exactly a year ago, I decided to write a custom locker (lock screen) for my old Samsung Galaxy Gio in the st...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>As I wrote a custom locker</h1><div class="post__text post__text-html js-mediator-article"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/b1b/824/7a4b1b824294dbe02e93eb67d2078cb3.png"><br><br>  Hi to habrastarezilam from habranovichka.  Exactly a year ago, I decided to write a custom locker (lock screen) for my old Samsung Galaxy Gio in the style of the then popular Samsung Galaxy s3.  What reasons have forced me to do this, I will not write, but I will add only that I did not intend to upload the program on Google Play and did not plan to make money on it in any other way.  This post is dedicated to the consequences of my decision. <br><a name="habracut"></a><br><br>  I'll start from afar.  Many praise Android for its openness and the ability to replace and customize firmware to fit their needs.  What is there to say?  Compared to other popular operating systems, this is certainly true, but if you dig deeper into the Android architecture, difficulties and questions arise.  Lockscreen (in Android, this is called keyguard) just raises questions: why Google did not do with it, because with launchers, why didn‚Äôt they make a dialogue with all the lockers available on the device and with the option to choose the default one?  Somewhere in the depths of the brain someone answers in a low indecisive voice: maybe Google (Android Ink. To be more precise) did so for security reasons.  This voice is probably right and many locker developers and me (modesty did not allow to attribute themselves to them) had to reinvent the wheel, and not one. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <h4>  We study the source code </h4><br>  I started using one of the advantages of Android - from exploring the sources.  I am one of those conservatives who have been sitting on the stock firmware for 2.5 years (2.3.6), therefore I studied the relevant sources.  The classes responsible for locking the screen are in android.policy.jar, which is in the system / framework.  The original goal was to find the ‚Äúentry point‚Äù, i.e.  where and when the locker is called.  Searched <a href="https://github.com/android/platform_frameworks_policies_base/tree/master/phone/com/android/internal/policy">here</a> . <br><br>  The PhoneWindowManager.java class has a screenTurnedOff (int why) method that calls the KeyguardViewMediator class method of the same name.  Having traced who is calling whom, I found a method in the KeyguardViewManager class that creates the View Locker directly. <br><br><pre><code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">synchronized</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEBUG) Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"show(); mKeyguardView=="</span></span> + mKeyguardView); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKeyguardHost == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEBUG) Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"keyguard host is null, creating it..."</span></span>); mKeyguardHost = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyguardViewHost(mContext, mCallback); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> stretch = ViewGroup.LayoutParams.MATCH_PARENT; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> flags = WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN | WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER | WindowManager.LayoutParams.FLAG_KEEP_SURFACE_WHILE_ANIMATING <span class="hljs-comment"><span class="hljs-comment">/*| WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN | WindowManager.LayoutParams.FLAG_LAYOUT_INSET_DECOR*/</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!mNeedsInput) { flags |= WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM; } WindowManager.LayoutParams lp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WindowManager.LayoutParams( stretch, stretch, WindowManager.LayoutParams.TYPE_KEYGUARD, flags, PixelFormat.TRANSLUCENT); lp.softInputMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN; lp.windowAnimations = com.android.internal.R.style.Animation_LockScreen; lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR; lp.setTitle(<span class="hljs-string"><span class="hljs-string">"Keyguard"</span></span>); mWindowLayoutParams = lp; mViewManager.addView(mKeyguardHost, lp); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mKeyguardView == <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (DEBUG) Log.d(TAG, <span class="hljs-string"><span class="hljs-string">"keyguard view is null, creating it..."</span></span>); mKeyguardView = mKeyguardViewProperties.createKeyguardView(mContext, mUpdateMonitor, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); mKeyguardView.setId(R.id.lock_screen); mKeyguardView.setCallback(mCallback); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> ViewGroup.LayoutParams lp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT); mKeyguardHost.addView(mKeyguardView, lp); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mScreenOn) { mKeyguardView.onScreenTurnedOn(); } } mKeyguardHost.setVisibility(View.VISIBLE); mKeyguardView.requestFocus(); }</code> </pre> <br>  Well, all ingenious is simple.  I decided to repeat this code for my application and got an error - there is no necessary permission.  A little googling added the following <a href="http://developer.android.com/intl/ru/reference/android/Manifest.permission.html">permissions</a> : SYSTEM_ALERT_WINDOW and INTERNAL_SYSTEM_WINDOW.  It did not help. <br><br>  Returned to the study of the class PhoneWindowManager.java: <br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">checkAddPermission</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(WindowManager.LayoutParams attrs)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> type = attrs.type; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (type &lt; WindowManager.LayoutParams.FIRST_SYSTEM_WINDOW || type &gt; WindowManager.LayoutParams.LAST_SYSTEM_WINDOW) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> WindowManagerImpl.ADD_OKAY; } String permission = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TYPE_TOAST: <span class="hljs-comment"><span class="hljs-comment">// XXX right now the app process has complete control over // this... should introduce a token to let the system // monitor/control what they are doing. break; case TYPE_INPUT_METHOD: case TYPE_WALLPAPER: // The window manager will check these. break; case TYPE_PHONE: case TYPE_PRIORITY_PHONE: case TYPE_SYSTEM_ALERT: case TYPE_SYSTEM_ERROR: case TYPE_SYSTEM_OVERLAY: permission = android.Manifest.permission.SYSTEM_ALERT_WINDOW; break; default: permission = android.Manifest.permission.INTERNAL_SYSTEM_WINDOW; } if (permission != null) { if (mContext.checkCallingOrSelfPermission(permission) != PackageManager.PERMISSION_GRANTED) { return WindowManagerImpl.ADD_PERMISSION_DENIED; } } return WindowManagerImpl.ADD_OKAY; }</span></span></code> </pre><br>  For the required TYPE_KEYGUARD window, you need the second of my added permissions.  Back end of the body began to feel that not everything is as simple as I imagined.  It was decided to look at the description of this permission.  Here is an excerpt from the AndroidManifest.xml package framework-res.apk. <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">permission</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/permlab_internalSystemWindow"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:name</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"android.permission.INTERNAL_SYSTEM_WINDOW"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:protectionLevel</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"signature"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:description</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@string/permdesc_internalSystemWindow"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  Here it is - a black stripe in life.  After all, I understood ‚Äúsignature‚Äù - this means that only a package signed with the same key as the package that issued this permission (in our case, framework-res.apk) can use this perm.  Okay, we get the tools for making bicycles. <br><br><h4>  Version one </h4><br>  The first solution was to use activity as loxgrin.  On stackoverflow, it is advised to use the following code: <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onAttachedToWindow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ getWindow().setType(WindowManager.LayoutParams.TYPE_KEYGUARD); <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onAttachedToWindow(); }</code> </pre><br>  I admit, in the first versions I used this method.  It has significant drawbacks: the statusbar is not blocked, since version API11 this method does not work. <br><br>  The solution to the first flaw ( <a href="http://stackoverflow.com/questions/7457730/preventing-status-bar-expansion">overflow of the stack</a> again helped) the following.  A transparent View is drawn on top of the statusbar using <a href="http://developer.android.com/intl/ru/reference/android/view/WindowManager.html">WindowManager</a> , which intercepts all TouchEvents.  Here is a service that implements this: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatusbarService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ View v; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStart(intent, id); Bundle e = intent.getExtras(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(e != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> statusBarHeight = (Integer) e.get(<span class="hljs-string"><span class="hljs-string">"SBH"</span></span>); WindowManager.LayoutParams lp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WindowManager.LayoutParams(WindowManager.LayoutParams.FILL_PARENT, statusBarHeight, WindowManager.LayoutParams.TYPE_SYSTEM_ALERT, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN, PixelFormat.TRANSLUCENT); lp.gravity = Gravity.TOP; WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE); v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> View(getBaseContext()); wm.addView(v, lp); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE); wm.removeView(v); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IBinder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent arg0)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> statusBarHeight, WindowManager.LayoutParams.TYPE_SYSTEM_ALERT, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN, PixelFormat.TRANSLUCENT); <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StatusbarService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ View v; <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent intent, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStart(intent, id); Bundle e = intent.getExtras(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(e != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> statusBarHeight = (Integer) e.get(<span class="hljs-string"><span class="hljs-string">"SBH"</span></span>); WindowManager.LayoutParams lp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> WindowManager.LayoutParams(WindowManager.LayoutParams.FILL_PARENT, statusBarHeight, WindowManager.LayoutParams.TYPE_SYSTEM_ALERT, WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN, PixelFormat.TRANSLUCENT); lp.gravity = Gravity.TOP; WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE); v = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> View(getBaseContext()); wm.addView(v, lp); } } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy(); WindowManager wm = (WindowManager) getSystemService(WINDOW_SERVICE); wm.removeView(v); } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> IBinder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onBind</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Intent arg0)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; } }</code> </pre><br>  There was no second drawback for me, this code worked perfectly on Gingerbread.  On w3bsit3-dns.com, where I recklessly laid out my creation, users complained that on many phones my locker rolled up like a normal application.  For them, found such a solution.  A dummy is installed as a standard launcher.  When I press the HOME button, the system calls up my empty-launcher.  If the custom locker is active, the launcher is immediately closed in the onCreate () method, i.e.  Visually pressing the HOME button leads to nothing.  If the custom locker is not active, my launcher immediately calls another correct launcher, which the user has specified in the settings. <br><br>  Here is the dummy code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HomeActivity</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Activity</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bundle savedInstanceState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(MainService.unlocked != <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>{ SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(getBaseContext()); String pn = pref.getString(<span class="hljs-string"><span class="hljs-string">"settings_launcher_pn"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); String an = pref.getString(<span class="hljs-string"><span class="hljs-string">"settings_launcher_an"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); Intent launch = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(Intent.ACTION_MAIN); launch.addCategory(Intent.CATEGORY_HOME); launch.addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS); launch.setClassName(pn, an); startActivity(launch); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(Exception e){ Intent i = <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>; PackageManager pm = getPackageManager(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(ResolveInfo ri:pm.queryIntentActivities(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(Intent.ACTION_MAIN).addCategory(Intent.CATEGORY_HOME), PackageManager.MATCH_DEFAULT_ONLY)){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!getPackageName().equals(ri.activityInfo.packageName)){ i = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent().addCategory(Intent.CATEGORY_HOME).setAction(Intent.ACTION_MAIN).addFlags(Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS).setClassName(ri.activityInfo.packageName, ri.activityInfo.name); } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(i != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) startActivity(i); } } finish(); } }</code> </pre><br>  It looked like this: <br><img src="https://habrastorage.org/getpro/habr/post_images/b57/5c8/884/b575c88849cf88f7624e667e6a10a796.png"><img src="https://habrastorage.org/getpro/habr/post_images/f4f/ce5/36d/f4fce536dfc4a03228a6ed2364d9e1e0.png"><br><br>  These bikes drove long and well, until I decided to make the "correct" loxgreen, and already in the style of the Samsung Galaxy S4. <br><br><h4>  Version two </h4><br>  When does the system need to run a custom locker?  Obviously, when you turn off the screen.  Create a service registering BroadcastReceiver, because  from the manifest, this filter does not work. <br><br>  It is necessary to consider two features: <br><br>  1. The service must be started at the time of loading the device.  Create a BroadcastReseiver with an IntentFilter "android.intent.action.BOOT_COMPLETED."  There is one BUT: the service at startup should disable the standard screen lock.  A feature of Android is that the standard PIN entry window is part of the stock lock screen.  Therefore, the service should only be started when a PIN is entered. <br><br>  The maximum that was enough for my imagination: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BootReceiver</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BroadcastReceiver</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onReceive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context context, Intent intent)</span></span></span><span class="hljs-function"> </span></span>{ TelephonyManager tm = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(PreferenceManager.getDefaultSharedPreferences(context).getBoolean(<span class="hljs-string"><span class="hljs-string">"unlock_screen_enable"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>)){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(tm.getSimState() != TelephonyManager.SIM_STATE_PIN_REQUIRED &amp;&amp; tm.getSimState() != TelephonyManager.SIM_STATE_PUK_REQUIRED){ context.startService(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, KeyguardService.class)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { AlarmManager alarms = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE); Intent intentToFire = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Intent(context, BootReceiver.class); PendingIntent alarmIntent = PendingIntent.getBroadcast(context, <span class="hljs-number"><span class="hljs-number">0</span></span>, intentToFire, <span class="hljs-number"><span class="hljs-number">0</span></span>); alarms.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + <span class="hljs-number"><span class="hljs-number">10000</span></span>, alarmIntent); } } } }</code> </pre><br>  2. After analyzing PhoneWindowManager, you can see that the screenTurnedOff (int why) method passes the variable why, which takes 3 values: <br>  - the screen turned off after a timeout (in this case, the stock locker starts with a delay), <br>  - the screen turned off when the proximity sensor was triggered (during a telephone conversation), <br>  - The screen turns off when you press a button. <br>  In my case, there is no such diversity.  Therefore, the service monitors the status of the phone, and when an incoming call or during a call, the screen is not blocked. <br><br>  Here is the main service code: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyguardService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service</span></span></span><span class="hljs-class"> </span></span>{ KeyguardMediator keyguardMediator; KeyguardManager.KeyguardLock keyguardLock; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> telephone = <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-comment"><span class="hljs-comment">//false - no call, true - in call boolean wasLocked = false; @Override public void onCreate() { super.onCreate(); TelephonyManager telephonyManager = (TelephonyManager)getSystemService(Context.TELEPHONY_SERVICE); telephonyManager.listen(new MyPhoneStateListener(), PhoneStateListener.LISTEN_CALL_STATE); keyguardLock = ((KeyguardManager)getSystemService(KEYGUARD_SERVICE)).newKeyguardLock("Custom keyguard by Arriva"); keyguardLock.disableKeyguard(); IntentFilter filter = new IntentFilter(); filter.addAction(Intent.ACTION_SCREEN_OFF); registerReceiver(receiver, filter); keyguardMediator = new KeyguardMediator(this); } @Override public void onDestroy() { super.onDestroy(); unregisterReceiver(receiver); keyguardLock.reenableKeyguard(); keyguardLock = null; keyguardMediator.destroy(); } void changeTelephoneState(int state){ if(state == TelephonyManager.CALL_STATE_IDLE){ telephone = false; if(wasLocked){ wasLocked = false; keyguardMediator.visibility(true); } } else { telephone = true; if(keyguardMediator.isShowing){ wasLocked = true; keyguardMediator.visibility(false); } } } private BroadcastReceiver receiver = new BroadcastReceiver(){ @Override public void onReceive(Context context, Intent intent) { String settingsLock = PreferenceManager.getDefaultSharedPreferences(context).getString("screen_lock", "2"); if(!settingsLock.equals("1")){ keyguardMediator.show(); } } }; class MyPhoneStateListener extends PhoneStateListener { @Override public void onCallStateChanged(int state, String incomingNumber){ super.onCallStateChanged(state, incomingNumber); changeTelephoneState(state); } } }</span></span></code> </pre><br>  The idea of ‚Äã‚Äãnot using activity, but using WindowManager was still strong.  Of the five types of windows that use the SYSTEM_ALERT_WINDOW permission, I was approached by TYPE_SYSTEM_ALERT.  Moreover, he had obvious advantages: the status bar was blocked (at least on Gingerbread) and the HOME button was intercepted (it even works on Jelly Bean). <br><br>  The intermediary between the service and KeyguardView is the KeyguardMediator class: <br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">KeyguardMediator</span></span></span><span class="hljs-class"> </span></span>{ WindowManager windowManager; KeyguardHost keyguardHost; KeyguardView keyguardView; Context context; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> isShowing; String[] prefShortcutsArray; String prefScreenLock; String prefUnlockEffect; String prefPatternPassword; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> prefMultipleWidgets; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> prefShortcuts; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> prefHelpText; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> prefPatternVisible; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> prefWallpaper; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> drawWallpaperView; <span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> drawWallpaperViewSqueeze; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KeyguardMediator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Context con)</span></span></span></span>{ context = con; windowManager = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); <span class="hljs-comment"><span class="hljs-comment">//          } void onResume(){ if(keyguardView != null){ keyguardView.onResume(); } } void onPause(){ if(keyguardView != null){ keyguardView.onPause(); } } void show(){ if(isShowing){ visibility(true); return; } keyguardView = new KeyguardView(context, this); isShowing = true; int flags = WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN; if(!drawWallpaperView) { flags |= WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER; } int format = PixelFormat.OPAQUE; if(!drawWallpaperView) { format = PixelFormat.TRANSLUCENT; } WindowManager.LayoutParams lp = new WindowManager.LayoutParams(WindowManager.LayoutParams.FILL_PARENT, WindowManager.LayoutParams.FILL_PARENT, WindowManager.LayoutParams.TYPE_SYSTEM_ALERT, flags, format); if(drawWallpaperView){ lp.windowAnimations = android.R.style.Animation_Toast; //      } lp.screenOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR; lp.setTitle("Custom keyguard"); keyguardHost = new KeyguardHost(context); keyguardHost.addView(keyguardView); windowManager.addView(keyguardHost, lp); } void hide(){ if(!isShowing){ return; } isShowing = false; keyguardHost.setVisibility(View.GONE); //    View    ,      windowManager.removeView(keyguardHost); keyguardHost = null; keyguardView = null; } void visibility(boolean visible){ //    View   keyguardHost.setVisibility(visible ? View.VISIBLE : View.GONE); if(keyguardView != null){ if(visible){ keyguardView.onResume(); } else { keyguardView.onPause(); } } } void startWidgetPicker(){ //  activity   } void finishWidgetPicker(){ //   layout'   } void destroy(){ if(keyguardHost != null){ windowManager.removeView(keyguardHost); keyguardHost = null; keyguardView = null; } } }</span></span></code> </pre><br>  Then the story becomes less interesting, so to speak, everyday.  You can add application shortcuts to my locker (everything is standard and simple here) and widgets (but this moment is worthy of a separate article). <br><br>  Now everything began to look more modern: <br><img src="https://habrastorage.org/getpro/habr/post_images/c6d/ce3/2f7/c6dce32f787bf02e4266a5e197ed7195.png"><img src="https://habrastorage.org/getpro/habr/post_images/e4e/4e1/a94/e4e4e1a948fdb3f1c98817aefb9e3471.png"><br><br><iframe width="560" height="315" src="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=en&amp;u=https://www.youtube.com/embed/Who13mx0LwM%3Ffeature%3Doembed&amp;xid=17259,15700002,15700022,15700186,15700190,15700253&amp;usg=ALkJrhioTHtcr7SbvTjx89T9jqf4mfh1rQ" frameborder="0" allowfullscreen=""></iframe><br><br><h4>  Conclusion </h4><br>  With this post, I did not want to promote myself.  This is not a guide for writing lockers.  I just wanted to show how a person who was too lazy to read at least one book on the basics of Java, but practicing writing programs for two years, can contrive to get a specific result. </div><p>Source: <a href="https://habr.com/ru/post/220689/">https://habr.com/ru/post/220689/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../220675/index.html">Customer interaction with an outsourcing company</a></li>
<li><a href="../220679/index.html">Application launch in Vkontakte</a></li>
<li><a href="../220681/index.html">Common Web Designer Mistakes or How to Please the Layout Designer</a></li>
<li><a href="../220685/index.html">Network between offices with VLANs based on Mikrotik equipment</a></li>
<li><a href="../220687/index.html">Custom types in Qt over D-Bus</a></li>
<li><a href="../220695/index.html">HR research. The most popular programming language in the Siberian region, the average wage level and where our programmers want to move</a></li>
<li><a href="../220697/index.html">My [Credit] Cards for Android application</a></li>
<li><a href="../220699/index.html">How we increased conversion</a></li>
<li><a href="../220701/index.html">Fody and its plugins</a></li>
<li><a href="../220703/index.html">Kitten care device via the Internet</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>