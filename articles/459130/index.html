<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Careful error handling in microservices</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="The article shows how to go in Go to implement error handling and logging on the principle of "Do and forget." The method is designed for Go microserv...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Careful error handling in microservices</h1><div class="post__text post__text-html js-mediator-article"><p>  The article shows how to go in Go to implement error handling and logging on the principle of "Do and forget."  The method is designed for Go microservices running in a Docker container and built in compliance with the principles of Clean Architecture. </p><a name="habracut"></a><br><p>  This article is a detailed version of the report from the recent <a href="https://www.meetup.com/ru-RU/GolangKazan/events/262238140/">Go meeting in Kazan</a> .  If you are interested in the language of Go and you live in Kazan, Innopolis, the beautiful Yoshkar-Ola or in another city nearby, you should visit the community page: <a href="https://golangkazan.github.io/">golangkazan.github.io</a> . </p><br><p>  At the mitap, our team in two reports showed how we develop microservices on Go ‚Äî which principles we follow and how we simplify our lives.  This article is devoted to our concept of error handling, which we now extend to all our new microservices. </p><br><h2 id="soglasheniya-o-strukture-mikroservisa">  Agreement on the structure of microservice </h2><br><p>  Before touching on the rules of error handling, it is worth deciding what limitations we follow when designing and coding.  For this it is worth telling how our microservices look like. </p><br><p>  First of all, we maintain pure architecture.  The code is divided into three levels and we follow the rule of dependencies: packages at a deeper level do not depend on external packages and there are no cyclic dependencies.  Fortunately, in Go, direct cyclic dependencies of packages are prohibited.  Indirect dependencies through borrowing terminology, assumptions about behavior or coercion to type can still appear, they should be avoided. </p><br><p>  This is how our levels look like: </p><br><ol><li>  The domain level contains the business logic rules dictated by the subject area. <br><ul><li>  sometimes we go without a domain if the task is simple </li><li>  <em>rule:</em> code at the domain level depends only on the capabilities of Go, the standard Go library and selected libraries that extend the Go language </li></ul></li><li>  The app level contains business logic rules dictated by application tasks. <br><ul><li>  <em>rule:</em> code at app level may depend on domain </li></ul></li><li>  The infrastructure level contains the infrastructure code that connects the application with various storage technologies (MySQL, Redis), transport (GRPC, HTTP), interaction with the external environment and with other services. <br><ul><li>  <em>rule:</em> code at infrastructure level may depend on domain and app </li><li>  <em>rule:</em> only one technology per go package </li></ul></li><li>  The main package creates all the objects - "life time singltons", connects them to each other and runs long-lived coroutines - for example, starts processing HTTP requests from port 8081 </li></ol><br><p>  This is the microservice directory tree (the part where the code is on Go): </p><br><p><img src="https://habrastorage.org/webt/dk/ft/id/dkftidhxmqh30yy9zbdaeajfbgy.png" alt="Image: Go Project Tree"></p><br><p>  For each of the application contexts (modules), the package structure looks like this: </p><br><ul><li> The app package declares the Service interface, which contains all possible actions at a given level, the service structure that implements the interface, and the <code>func NewService(...) Service</code> function </li><li>  isolation of work with the database is achieved due to the fact that the domain or app package declares the Repository interface, which is implemented at the infrastructure level in the package with the descriptive name "mysql" </li><li>  the transport code is located in the <code>infrastructure/transport</code> package <br><ul><li>  we use GRPC, so we have server stubs generated from a proto-file (i.e. server interface, Response / Request structures and all client interaction code) </li></ul></li></ul><br><p>  All this is shown in the diagram: </p><br><p><img src="https://habrastorage.org/webt/-p/gm/hi/-pgmhid0ohkvijl2zmghnlokz7y.png" alt="Image: Go Project Package Diagram"></p><br><h2 id="principy-obrabotki-oshibok">  Error handling principles </h2><br><p>  Everything is simple: </p><br><ol><li>  We believe that errors and panic occur when processing requests to the API - it means that an error or panic should affect only one request. </li><li>  We believe that logs are needed only for analyzing incidents (and for debugging there is a debugger), so the log contains information about requests, and above all unexpected errors when processing requests </li><li>  We believe that a whole infrastructure is built for processing logs (for example, based on ELK) - and microservice plays a passive role in it, writing logs to stderr </li></ol><br><p>  We will not focus on panic: just do not forget to handle the panic in every horizontal and while processing every request, every message, every asynchronous task started by the request.  Almost always, a panic can be turned into an error in order not to allow the entire application to be completed. </p><br><h2 id="idioma-sentinel-errors">  Idiom Sentinel Errors </h2><br><p>  At the business logic level, only the expected errors that are determined by business rules are processed.  Sentinel Errors will help you identify such errors - we use this particular idiom instead of writing our own data types for errors.  Example: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNoCake = errors.New(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><p>  Here we declare a global variable, which, according to our gentlemen's agreement, we should not change anywhere.  If you do not like global variables and you use a linter to detect them, then you can do with constants alone, as Dave Cheney suggests in the post <a href="https://dave.cheney.net/2016/04/07/constant-errors">Constant errors</a> : </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>(e) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ErrNoCake = Error(<span class="hljs-string"><span class="hljs-string">"no cake found"</span></span>)</code> </pre> <br><blockquote>  If you like this approach, you may need to add the <code>ConstError</code> type to <code>ConstError</code> Go corporate library. </blockquote><br><h2 id="kompoziciya-oshibok">  Error composition </h2><br><p>  The main advantage of Sentinel Errors is the ability to easily compose errors.  In particular, when creating an error or when receiving an error from the outside it would be good to add stacktrace to it.  For such purposes there are two popular solutions. </p><br><ul><li>  the xerrors package, which will be included in the standard library as an experiment in Go 1.13 </li><li>  package <a href="https://github.com/pkg/errors">github.com/pkg/errors by</a> Dave Cheney <br><ul><li>  the package is frozen and does not expand, but nevertheless it is good </li></ul></li></ul><br><p>  Our team still uses <code>github.com/pkg/errors</code> and the <code>errors.WithStack</code> functions (when we have nothing to add except stacktrace) or <code>errors.Wrap</code> (when we have something to say about this error).  Both functions accept an error at the input and return a new error, but now with stacktrace.  Example from infrastructure layer: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> mysql <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/pkg/errors"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(r *repository)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FindOne</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span></span> { row := r.client.QueryRow(sql, params...) <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> err := row.Scan(...) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> sql.ErrNoRows: <span class="hljs-comment"><span class="hljs-comment">//     stacktrace return nil, errors.WithStack(app.ErrNoCake) } }</span></span></code> </pre> <br><p>  We recommend that every mistake be wrapped only once.  This is easy to do if you follow the rules: </p><br><ul><li>  any external errors are wrapped once in one of the infrastructure packages </li><li>  any errors generated by the rules of business logic are complemented by stacktrace at the time of creation </li></ul><br><h2 id="pervoprichina-oshibki">  The root cause of the error </h2><br><p>  All errors are expectedly divided into expected and unexpected.  To handle the expected error, you need to get rid of the effects of the composition.  The xerrors and <code>github.com/pkg/errors</code> packages have everything you need: in particular, the errors package contains the <code>errors.Cause</code> function, which returns the root cause of the error.  This function, in a loop, one after the other, extracts earlier errors, while the next extracted error has the <code>Cause() error</code> method. </p><br><p>  An example to which we extract the root cause and directly compare it with the sentinel error: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { state, err := s.repo.FindOne(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Cause(err) == ErrNoCake { err = <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-comment"><span class="hljs-comment">// No cake is OK, create a new one // ... } else if err != nil { // ... } }</span></span></code> </pre> <br><h2 id="obrabotka-oshibok-v-defer">  Error handling in defer </h2><br><p>  Perhaps you are using linter, which makes you manic checking all errors.  In this case, you are probably infuriated when linter asks you to check for errors in the <code>.Close()</code> methods and other methods that you call only in the <code>defer</code> .  Have you ever tried to correctly handle the error in defer, especially if before that there was another error?  And we tried and hurried to share the recipe. </p><br><p>  Imagine that we have all the work with the database is strictly through the transaction.  According to the dependency rule, the app and domain levels should not directly or indirectly depend on infrastructure and SQL technology.  This means that <strong>at the app and domain levels there is no word "transaction"</strong> . </p><br><p>  The simplest solution is to replace the word "transaction" with something abstract;  This is how the Unit of Work pattern is born.  In our implementation, the service in the app package receives a factory through the UnitOfWorkFactory interface, and during each operation creates a UnitOfWork object hiding the transaction.  The UnitOfWork object allows you to get Repository. </p><br><div class="spoiler">  <b class="spoiler_title">More about UnitOfWork</b> <div class="spoiler_text"><p>  To better understand the use of Unit of Work, take a look at the diagram: </p><br><p><img src="https://habrastorage.org/webt/08/hi/iy/08hiiyavd51o3_aof9ys_s9noue.png" alt="Image Go Unit of Work"></p><br><ul><li>  Repository is an abstract persistent collection of objects (for example, domain-level aggregates) of a defined type. </li><li>  UnitOfWork hides the transaction and creates the Repository objects. </li><li>  UnitOfWorkFactory simply allows the service to create new transactions without knowing anything about transactions. </li></ul><br><p>  Is it not excessive to create a transaction for every operation, even initially atomic?  You decide;  We believe that maintaining the independence of business logic is more important than saving on transaction creation. </p><br><p>  Can UnitOfWork and Repository be combined?  It is possible, but we believe that this will violate the principle of Single Responsibility. </p></div></div><br><p>  This is the interface: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> UnitOfWork <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Repository() Repository Complete(err *error) }</code> </pre> <br><p>  The UnitOfWork interface provides the Complete method, which accepts one in-out parameter: a pointer to the error interface.  Yes, it is the pointer, and it is the in-out parameter - in any other cases the code on the caller will be much more complicated. </p><br><p>  Example operation with unitOfWork: </p><br><blockquote>  Warning: the error <strong>must</strong> be declared as a named return value.  If instead of a named return value err you use the local variable err, then you cannot use it in defer!  And no linter will detect this yet - see <a href="https://github.com/go-critic/go-critic/issues/801">go-critic # 801</a> </blockquote><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CookCake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span></span> { unitOfWork, err := s.unitOfWorkFactory.New() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> unitOfWork.Complete(&amp;err) repo := unitOfWork.Repository() } <span class="hljs-comment"><span class="hljs-comment">// ...  </span></span></code> </pre> <br><p>  So is the completion <del>  transactions </del>  UnitOfWork: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u *unitOfWork)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Complete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err *error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> *err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">//     -  commit txErr := u.tx.Commit() *err = errors.Wrap(txErr, "cannot complete transaction") } else { //    -  rollback txErr := return u.tx.Rollback() //  rollback   ,    *err = mergeErrors(*err, errors.Wrap(txErr, "cannot rollback transaction")) } }</span></span></code> </pre> <br><p>  The <code>mergeErrors</code> function merges two errors, but will process nil instead of one or both errors without any problems.  At the same time, we believe that both errors occurred when performing one operation at different stages, and the first error is more important - therefore, when both errors are not nil, we save the first, and the second error saves only the message: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> errors <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mergeErrors</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error, nextErr error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = nextErr } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> nextErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { err = errors.Wrap(err, nextErr.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><blockquote>  Perhaps you should add the function <code>mergeErrors</code> to your corporate library for the Go language. </blockquote><br><h2 id="podsistema-logirovaniya">  Logging subsystem </h2><br><p>  <a href="https://habr.com/ru/post/438064/">Check-list</a> article <a href="https://habr.com/ru/post/438064/">: what to do before running microservices in prod</a> advises: </p><br><ul><li>  logs are written in stderr </li><li>  logs must be in JSON, one compact JSON object per line </li><li>  There should be a standard set of fields: <br><ul><li>  timestamp - the time of the event with <strong>milliseconds</strong> , preferably in RFC 3339 format (example: "1985-04-12T23: 20: 50.52Z") </li><li>  level - the level of importance, for example, "info" or "error" </li><li>  app_name - the name of the application </li><li>  and other fields </li></ul></li></ul><br><p>  We prefer to add two more fields to the error messages: <code>"error"</code> and <code>"stacktrace"</code> . </p><br><p>  For the Golang language there are many quality logging libraries, for example, <a href="https://github.com/sirupsen/logrus">sirupsen / logrus</a> , which we use.  But we do not use the library directly.  First of all, in our <code>log</code> package we reduce the extensive library interface to a single Logger interface: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Logger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { WithField(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Logger WithFields(Fields) Logger Debug(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Info(...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) Error(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><p>  If a programmer wants to write logs, he should receive a Logger interface from the outside, and this should be done at the infrastructure level, not app or domain.  The logger interface is concise: </p><br><ul><li>  it reduces the number of importance levels to debug, info and error, as the article suggests. <a href="https://habr.com/ru/post/440200/">Let's talk about logging.</a> </li><li>  it introduces specific rules for the Error method: the method always accepts an error object </li></ul><br><p>  This rigor allows you to send programmers in the right direction: if someone wants to make an improvement in the logging system itself, it must do so taking into account the entire infrastructure of their collection and processing, which only begins in microservice (and usually ends somewhere in Kibana and Zabbix). </p><br><p>  However, there is another interface in the log package that allows you to interrupt the program when a fatal error occurs and therefore can only be used in the main package: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> log <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MainLogger <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Logger FatalError(error, ...<span class="hljs-keyword"><span class="hljs-keyword">interface</span></span>{}) }</code> </pre> <br><h2 id="paket-jsonlog">  Jsonlog package </h2><br><p>  Logger interface implements our <code>jsonlog</code> package, which configures the logrus library and abstracts work with it.  Schematically looks like this: </p><br><p><img src="https://habrastorage.org/webt/g4/we/6m/g4we6m81oxxtd1nlvwklblru6eq.png" alt="Image Logger Package Diagram"></p><br><p>  <code>log.Logger</code> own package allows you to link the needs of microservice (expressed by the interface <code>log.Logger</code> ), the possibilities of the logrus library and the features of your infrastructure and the creation of logs. </p><br><p>  For example, we use ELK (Elastic Search, Logstash, Kibana), and therefore in the jsonlog package we: </p><br><ul><li>  set logrus format for <code>logrus.JSONFormatter</code> <br><ul><li>  at the same time, we set the FieldMap option, with which we turn the <code>"time"</code> field into <code>"@timestamp"</code> , and the <code>"msg"</code> field - into <code>"message"</code> </li></ul></li><li>  choose log level </li><li>  add a hook that extracts the stacktrace from the <code>Error(error, ...interface{})</code> object passed to the <code>Error(error, ...interface{})</code> method </li></ul><br><p>  Microservice initializes the logger in the main function: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initLogger</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(config Config)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(log.MainLogger, error)</span></span></span></span> { logLevel, err := jsonlog.ParseLevel(config.LogLevel) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.Wrap(err, <span class="hljs-string"><span class="hljs-string">"failed to parse log level"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> jsonlog.NewLogger(&amp;jsonlog.Config{ Level: logLevel, AppName: <span class="hljs-string"><span class="hljs-string">"cookingservice"</span></span> }), <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br><h2 id="obrabotka-oshibok-i-logirovanie-s-pomoschyu-middleware">  Error Handling and Logging Using Middleware </h2><br><p>  We are switching to GRPC in our microservices on Go.  But even if you use the HTTP API, the general principles will suit you. </p><br><p>  First of all, error handling and logging should occur at the <code>infrastructure</code> level in the transport package, because it combines the knowledge of the rules of the transport protocol and the knowledge of the <code>app.Service</code> interface <code>app.Service</code> .  Recall what the packet interconnection looks like: </p><br><p><img src="https://habrastorage.org/webt/fw/zn/hz/fwznhzsxd35ydgajmotnvprqbum.png" alt="Image GRPC Package Diagram"></p><br><p>  It is convenient to handle errors and logs using the Middleware pattern (Middleware is the name of the Decorator pattern in the world of Golang and Node.js): </p><br><p>  Where should I add Middleware?  How many should there be? </p><br><p>  There are various options for adding Middleware, you choose: </p><br><ul><li>  You can decorate the <code>app.Service</code> interface, but we do not recommend doing so, because this interface does not receive transport-level information, such as client IP </li><li>  With GRPC, you can hang one handler for all requests (more precisely, two - unary and steam), but then all API methods will be logged in the same style with the same set of fields </li><li>  With GRPC, the code generator creates for us a server interface, in which we call the <code>app.Service</code> method - we decorate this interface, because it contains information of the transport level and the ability to log various API methods in different ways </li></ul><br><p>  Schematically looks like this: </p><br><p><img src="https://habrastorage.org/webt/vn/dl/eh/vndlehx5hogpu09hj3zekrzmyie.png" alt="Image GRPC Middleware Package Diagram"></p><br><p>  You can create different middleware for error handling (and panic) and for logging.  You can cross it all in one.  We will consider an example in which everything is mated into one Middleware, which is created like this: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewMiddleware</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(next api.BackendService, logger log.Logger)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BackendService</span></span></span></span> { server := &amp;errorHandlingMiddleware{ next: next, logger: logger, } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> server }</code> </pre> <br><p>  We receive the <code>api.BackendService</code> interface as <code>api.BackendService</code> and decorate it, returning our <code>api.BackendService</code> interface implementation as <code>api.BackendService</code> . </p><br><p>  An arbitrary API method in Middleware is implemented as follows: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ListCakes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( ctx context.Context, req *api.ListCakesRequest)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*api.ListCakesResponse, error)</span></span></span></span> { start := time.Now() res, err := m.next.ListCakes(ctx, req) m.logCall(start, err, <span class="hljs-string"><span class="hljs-string">"ListCakes"</span></span>, log.Fields{ <span class="hljs-string"><span class="hljs-string">"cookIDs"</span></span>: req.CookIDs, }) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res, translateError(err) }</code> </pre> <br><p>  Here we perform three tasks: </p><br><ol><li>  Call the ListCakes method of the object to be decorated. </li><li>  Call your <code>logCall</code> method, passing all the important information to it, including an individually selected set of fields that are logged </li><li>  At the end, we replace the error by calling translateError. </li></ol><br><p>  Error broadcast will be discussed later.  And the log entry is performed by the <code>logCall</code> method, which simply calls the correct Logger method: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(m *errorHandlingMiddleware)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">logCall</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(start time.Time, err error, method </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, fields log.Fields)</span></span></span></span> { fields[<span class="hljs-string"><span class="hljs-string">"duration"</span></span>] = fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%v"</span></span>, time.Since(start)) fields[<span class="hljs-string"><span class="hljs-string">"method"</span></span>] = method logger := m.logger.WithFields(fields) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { logger.Error(err, <span class="hljs-string"><span class="hljs-string">"call failed"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { logger.Info(<span class="hljs-string"><span class="hljs-string">"call finished"</span></span>) } }</code> </pre> <br><h2 id="translyaciya-oshibok">  Broadcast errors </h2><br><p>  We must get the root cause of the error and turn it into an error that is understandable at the transport level and documented in the API of your service. </p><br><p>  In GRPC, this is easy - use the <code>status.Errorf</code> function to create an error with a status code.  If you have an HTTP API (REST API), you can create your own type of error, which the <strong>app and domain levels do not need to know</strong> about </p><br><p>  In the first approximation, the error broadcast looks like this: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// ! ! -   err  status.Error func translateError(err error) error { switch errors.Cause(err) { case app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) default: err = status.Errorf(codes.Internal, err.Error()) } return err }</span></span></code> </pre> <br><p>  The decorated interface can return an error of type <code>status.Status</code> with a status code when validating input arguments, and the first version of translateError will lose this status code. </p><br><p>  Make an improved version using the interface type conversion (long live duck typing!): </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> statusError <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GRPCStatus() *status.Status } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isGrpcStatusError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(er error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { _, ok := err.(statusError) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ok } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">translateError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> isGrpcStatusError(err) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> errors.Cause(err) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> app.ErrNoCake: err = status.Errorf(codes.NotFound, err.Error()) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: err = status.Errorf(codes.Internal, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> err }</code> </pre> <br><p>  The <code>translateError</code> function is created individually for each context (independent module) in your microservice and translates business logic errors into transport level errors. </p><br><h2 id="podvedyom-itogi">  Let's sum up </h2><br><p>  We offer you a few rules for error handling and working with logs.  To follow them or not, you decide. </p><br><ol><li>  Follow the principles of Clean Architecture, do not allow direct or indirect violation of the dependency rule.  Business logic should depend only on the programming language, and not on external technologies. </li><li>  Use a package that offers error composition and stacktrace creation.  For example, "github.com/pkg/errors" or the xerrors package, which will soon be included in the standard Go library </li><li>  Do not use third-party logging libraries in microservice - create your own library with the log and jsonlog packages, which will hide the details of the logging implementation </li><li>  Use the Middleware pattern to handle errors and write logs on the transport direction of the infrastructure level of the program </li></ol><br><p>  Here we didn‚Äôt say anything about query tracing technologies (for example, OpenTracing), monitoring of metrics (for example, database query performance) and other things like logging.  You yourself will figure it out, we believe in you. </p></div>
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
    <p>Source: <a href="https://habr.com/ru/post/459130/">https://habr.com/ru/post/459130/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459118/index.html">How we designed and implemented a new network on Huawei in the Moscow office, part 2</a></li>
<li><a href="../45912/index.html">Setting up backup in Ubuntu</a></li>
<li><a href="../459120/index.html">Modular Embedded Computers UNO-1000/2000 Series</a></li>
<li><a href="../459128/index.html">Japanese interfaces in the real world</a></li>
<li><a href="../45913/index.html">Live cook book: our culinary and software hobby</a></li>
<li><a href="../459134/index.html">Experience using BDD</a></li>
<li><a href="../459136/index.html">Fake Blue Pill</a></li>
<li><a href="../459138/index.html">How Huawei secret key got into Cisco router firmware</a></li>
<li><a href="../45914/index.html">Using third-party brands in a startup</a></li>
<li><a href="../459140/index.html">Implant placement: how is it done?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>