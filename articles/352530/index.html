<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>Dependency injection patterns. Part 1</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Let's look at the implementation of dependencies in .Net, since this topic is one of the must-haves for writing high-quality, flexible to change and t...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>Dependency injection patterns. Part 1</h1><div class="post__text post__text-html js-mediator-article">  Let's look at the implementation of dependencies in .Net, since this topic is one of the must-haves for writing high-quality, flexible to change and tested code.  We start with the necessary and basic patterns of dependency injection - implementation through the constructor and through the property.  So let's go! <br><a name="habracut"></a><br><h2>  Implementation through the designer </h2><br><h3>  Purpose </h3><br>  Break the rigid connection between the class and its <b>required</b> dependencies. <br><br><h3>  Description </h3><br>  The essence of the pattern is that all the dependencies required by a certain class are transferred to it as <b>constructor parameters</b> , represented as <b>interfaces</b> or <b>abstract classes</b> . <br><br>  <i>How can you ensure that the required dependency is always available to the developed class?</i> 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      This is ensured if <b>all</b> callers pass the dependency as a constructor parameter. <br><br>  A class requiring a dependency must have a constructor with a <b>public</b> access <b>modifier</b> (public) that receives an instance of the required dependency as an argument to the constructor: <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> IFoo _foo; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Foo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">IFoo foo</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (foo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(foo)); _foo = foo; }</code> </pre> <br>  Dependency is a <b>required</b> constructor argument.  <b>The code of any client that does not provide a dependency instance cannot be compiled.</b>  However, since both the <b>interface</b> and the <b>abstract class</b> are <b>reference</b> types, the calling code can pass a special <b>null</b> value to the argument, which makes the application compiled.  Therefore, the class checks for <b>null</b> , which protects the class from such incorrect use.  Since the compiler and protection block work together (checking for <b>null</b> ) ensures that the constructor argument is correct (unless an exception is <b>thrown</b> ), the constructor can simply keep the dependency for future use without figuring out the details of the actual implementation. <br><br>  It is good practice to declare a field storing the value of a dependency as ‚Äú <b>Read-only</b> ‚Äù.  So we guarantee that it runs, and only <b>once</b> , the initialization logic in the constructor: the <b>field cannot be modified</b> .  This is not necessary to implement dependency injection, but in this way the code is protected from accidental field modifications (for example, from setting its value to <b>null</b> ) in some other place in the class code. <br><br><h3>  When and how should a deployment be used through a constructor </h3><br>  <b>Implementation through the designer</b> should be used by default with the implementation of dependencies.  It implements the most popular scenario when a class needs one or more dependencies, and there are no suitable local defaults. <br><br>  Consider the most best tips and practices on the use of implementation through the designer: <br><br><ul><li>  If possible, limit the class to one constructor. </li><li>  Overloaded constructors provoke ambiguities: which designer should use dependency injection? </li><li>  Do not add any other logic to the constructor. </li><li>  Nowhere else in the class does a dependency need to be checked for null, since the constructor guarantees its existence </li></ul><br><table><tbody><tr><td>  <strong>Virtues</strong> </td><td>  <strong>disadvantages</strong> </td></tr><tr><td>  Implementation guaranteed </td><td>  In some frameworks, it is difficult to use implementation through the constructor. </td></tr><tr><td>  Ease of implementation </td><td>  The requirement for immediate initialization of the entire dependency graph <strong>(*)</strong> </td></tr><tr><td>  Providing a clear contract between the class and its customers (it‚Äôs easier to think about the current class, without thinking about where the dependencies of the higher-level class come from) </td><td>  - </td></tr><tr><td>  The complexity of the class becomes apparent. </td><td>  - </td></tr></tbody></table>  (*) The obvious disadvantage of implementing a constructor is the requirement to <b>immediately initialize the entire dependency graph</b> ‚Äî often already when the application is started.  Nevertheless, although it seems that this disadvantage reduces the efficiency of the system, in practice it rarely becomes a problem.  Even for complex object graphs, creating an object instance is an action that the <b>.NET</b> framework performs extremely quickly.  In very rare cases, this problem can be really serious.  Then we use the life cycle parameter, called <b>Delayed</b> , which is quite suitable for solving this problem. <br><br>  A potential problem with using a constructor to pass dependencies may be an excessive increase in constructor parameters.  <a href="http://blog.ploeh.dk/2010/02/02/RefactoringtoAggregateServices">Here</a> you can read more. <br><br>  Another reason for the large number of constructor parameters is that too many <b>abstractions are</b> allocated.  <b>This state of affairs may indicate that we began to abstract away even from what we do not need to abstract from</b> : we began to create interfaces for objects that simply store data, or classes whose behavior is stable does not depend on the external environment and must clearly hide inside the class. instead of being exposed outside. <br><br><h3>  Examples of using </h3><br>  <b>Constructor Injection</b> is the basic pattern of dependency injection and is used extensively by most programmers, even if they don‚Äôt think about it.  One of the main goals of the majority of ‚Äústandard‚Äù design patterns (GoF patterns) is to obtain a <b>loosely coupled</b> design, so it is not surprising that most of them use dependency injection in one form or another. <br><br>  So, the <b>decorator</b> uses dependency injection through the constructor;  <b>the strategy</b> is passed through the constructor or ‚Äúimplemented‚Äù to the desired method;  <b>the command</b> can be passed as a parameter, or it can take the <b>surrounding context</b> through the constructor.  <b>An abstract factory is</b> often passed through a constructor and, by definition, is implemented via an interface or an abstract class;  the <b>State</b> pattern takes as a dependency the necessary context, etc. <br><br>  Two examples demonstrating the use of a constructor implementation in <b>BCL</b> are the <b>System.IO.StreamReader</b> and <b>System.IO.StreamWriter</b> classes. <br><br>  Both of them get an instance of the <b>System.IO.Stream</b> class in the constructor. <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StreamWriter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stream stream</span></span></span><span class="hljs-function">)</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">StreamReader</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Stream stream</span></span></span><span class="hljs-function">)</span></span>;</code> </pre> <br>  The <b>Stream</b> class is an abstract class that acts as the abstraction with which <b>StreamWriter</b> and <b>StreamReader</b> perform their tasks.  You can pass any implementation of the <b>Stream</b> class to their constructors, and they will use it.  But if you try to pass a <b>null</b> value to the constructor as a <b>Stream</b> , <b>ArgumentNullExceptions</b> will be generated. <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//  var ms = new MemoryStream(); var bs = new BufferedStream(ms); //   var sortedArray = new SortedList&lt;int, string&gt;( new CustomComparer()); //  ResourceReader  Stream Stream ms = new MemoryStream(); var resourceReader = new ResourceReader(ms); // BinaryReader/BinaryWriter, StreamReader/StreamWriter //   Stream   var textReader = new StreamReader(ms); // Icon  Stream var icon = new System.Drawing.Icon(ms);</span></span></code> </pre> <br>  <b>Conclusion</b> <br><br>  Regardless of whether you use <b>DI containers</b> or not, implementation through a constructor ( <b>Constructor Injection</b> ) should be the first way to manage dependencies.  Its use will not only make the relationship between classes more explicit, but also allow you to identify design problems when the number of constructor parameters exceeds a certain limit.  In addition, all modern dependency deployment containers <b>support</b> this pattern. <br><br><h2>  Property Injection </h2><br><h3>  Purpose </h3><br>  Break the rigid connection between a class and its <b>optional</b> dependencies. <br><br><h3>  Description </h3><br>  <i>How can I allow dependency injection as an option in a class if there is a suitable local default?</i> <br><br>  Using a writable property, which allows the caller to set its value if it wants to replace the default behavior. <br><br>  A class using a dependency must have a writable property with a <b>public</b> modifier: the type of this property must match the type of dependency. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISomeInterface Dependency { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre> <br>  Here, <b>SomeClass is</b> dependent on <b>ISomeInterface</b> .  Clients can pass <b>ISomeInterface</b> interface <b>implementations</b> through the <b>Dependency</b> property.  Note that, in contrast to the implementation of the constructor, you <b>can</b> not mark the <b>Dependency</b> property field as ‚Äú <b>Read Only</b> ‚Äù, since the caller is allowed to change the value of this property at <b>any</b> time during the <b>SomeClass</b> life cycle. <br><br>  Other members of the dependent class can use the injected dependency to perform their functions, for example: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> message</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Dependency.DoStuff(message); }</code> </pre> <br>  However, such an implementation is <b>unreliable</b> , since the <b>Dependency</b> property does not guarantee the return of an <b>ISomeInterface</b> instance.  For example, the code shown below will generate a <b>NullReferenceException</b> , since the value of the <b>Dependency</b> property is <b>null</b> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeClass(); sc.DoSomething(<span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>);</code> </pre> <br>  This problem can be fixed by setting in the default instance dependency constructor for a property combined with adding a <b>null</b> test to the property's setter method. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ISomeInterface _dependency; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { _dependency = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultSomeInterface(); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISomeInterface Dependency { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; _dependency; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> =&gt; _dependency = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> ?? <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)); } }</code> </pre> <br>  The difficulty arises if customers are allowed to <b>change the</b> value of a dependency during the life cycle of a class. <br><br>  <i>What should happen if a client tries to change the value of a dependency during the life cycle of a class?</i> <br><br>  The consequence of this may be contradictory or unexpected behavior of the class, so it is better to protect against such a turn of events. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ISomeInterface _dependency; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ISomeInterface Dependency { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; _dependency ?? (_dependency = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> DefaultDependency()); <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-comment"><span class="hljs-comment">//  1    if (_dependency != null) throw new InvalidOperationException(nameof(value)); _dependency = value ?? throw new ArgumentNullException(nameof(value)); } } }</span></span></code> </pre> <br>  Creating <b>DefaultDependency</b> can be delayed until the property is requested for the first time.  In this case, pending initialization will occur.  Note that the local default is assigned through a <b>setter</b> with the <b>public</b> modifier, which ensures that all security blocks are executed.  The first protection block ensures that the dependency you are installing is not <b><b>null</b></b> (we can use <b>NRE</b> when using it).  The next security block is responsible for ensuring that the dependency is installed only once. <br><br>  You may also notice that the dependency will be <b>blocked</b> after the property is read.  This is done to protect customers from situations where the dependency later changes without any notice, while the customer thinks the dependency remains the same. <br><br><h3>  When to use property injection </h3><br>  Implementing a property should be used only if there is a suitable <b>local default</b> for the developed class, but you would like to leave the caller the opportunity to use another implementation of the dependency type.  Implementing a property is best applied if the dependency is <b>optional</b> .  It should be assumed that the properties are <b>optional</b> , because it is easy to forget to assign a value to them, and the compiler does not react to this. <br><br>  It may be tempting to set this default implementation for this class at design time.  However, if such a proactive default is implemented in another Assembly ( <b>Assembly</b> ), using it in this way will inevitably create an <b>immutable reference</b> to it, which negates many of the advantages of <b>weak binding</b> . <br><br><h3>  Cautions </h3><br><ul><li>  <b>Use Property Injection for required dependencies.</b>  This is one of the most common mistakes of using this pattern.  If a class necessarily needs some dependency, then it should be passed through the constructor so that immediately after the object is created it is in a valid state. </li><li>  <b>Use Foreign Default instead of Local Default.</b>  One of the dangers of using default dependency implementations is using a particular dependency located in an assembly that our service should not be aware of ( <b>Foreign Default</b> ).  If there are many such services, we will get dozens of extra physical links that will complicate understanding and maintenance.  The default implementation must be in the same assembly ( <b>Local Default</b> ). </li><li>  <b>Complexity.</b>  The problem of using <b>Property Injection</b> for mandatory dependencies is that it greatly increases the complexity of the class.  A class with three fields, each of which may be null, results in 8 different combinations of the object's state.  Attempting to check the state in the body of each open method leads to an unnecessary jump in complexity. </li><li>  <b>Attachment to the container.</b>  In most cases, we must use the container in a <b>minimum</b> number of places.  Using <b>Constructor Injection</b> as a whole allows this, because using it does not tie your class to any particular container.  However, the situation changes when using <b>Property Injection</b> .  Most containers contain a set of specialized attributes for managing dependencies through properties ( <b>SetterAttribute</b> for <b>StructureMap</b> , <b>Dependency</b> for <b>Unity</b> , <b>DoNotWire</b> for <b>Castle Windsor</b> , etc.).  Such a hard link will not allow you to ‚Äúchange your mind‚Äù and move to another container or refuse to use them at all. </li><li>  <b>Write-only properties.</b>  Not always, we want to expose a property that returns a dependency.  In this case, we will have to either do the property only for writing ( <b>set-only property</b> ), which contradicts the generally accepted design principles on the <b>.NET</b> platform or use the method instead of the property ( <b>Setter Method Injection</b> ). <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ISomeInterface _dependency; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetDependency</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISomeInterface dependency</span></span></span><span class="hljs-function">)</span></span> { _dependency = dependency; } }</code> </pre> </li></ul><br><h3>  Alternatives </h3><br>  If we have a class that contains an <b>optional</b> dependency, then we can use the old approach with two constructors: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SomeClass</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> ISomeInterface _dependency; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) : </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">this</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new DefaultSomeInterface(</span></span></span><span class="hljs-function">))</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SomeClass</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ISomeInterface dependency</span></span></span><span class="hljs-function">)</span></span> { _dependency = dependency; } }</code> </pre> <br><h3>  Conclusion </h3><br>  <b>Property Injection is</b> ideal for <b>optional</b> dependencies.  They are quite suitable for strategies with the default implementation, but still, I would recommend using <b>Constructor Injection</b> and consider other options only if necessary. </div><p>Source: <a href="https://habr.com/ru/post/352530/">https://habr.com/ru/post/352530/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../352518/index.html">Heading "We read articles for you." February - March 2018</a></li>
<li><a href="../352520/index.html">Java Learning Framework for Deep Learning</a></li>
<li><a href="../352524/index.html">Conference DEFCON 16. "Cisco iOS Development Crime." Felix Lindner, head of Recurity Labs</a></li>
<li><a href="../352526/index.html">Pot vari or 4 methods of creative approach to solving problems</a></li>
<li><a href="../352528/index.html">Anatomical code metaphor. Where does muscle code</a></li>
<li><a href="../352532/index.html">Bitcoin & AI. Victory is inevitable</a></li>
<li><a href="../352534/index.html">Creating an Asymmetric Mesh with Grid Layout</a></li>
<li><a href="../352536/index.html">Thymeleaf tutorial: Chapter 14. A few more pages of our groceries</a></li>
<li><a href="../352538/index.html">DEFCON 23. "Let'sEncrypt: chasing free encryption certificates for the Internet." Yang Zhu, Peter Eckersley, James Kasten</a></li>
<li><a href="../352540/index.html">4 tips on working with Vue.js</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>