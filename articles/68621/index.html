<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134931760-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134931760-1');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>JSON vs. XML and a bit of refactoring</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduction 
 Working in the field of RIA creation, sooner or later, you have to think about the choice of protocols for transferring data between a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  <script>
       (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-6974184241884155",
            enable_page_level_ads: true
       });
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly.github.io/index.html"></a>
    <div class="page-header-text">Geekly Articles each Day</div>
  </header>
  <nav class="page-headings-container js-page-headings-container"></nav>
  <div class="tools-bar js-tools-bar">
    <!-- <a href="../../search.html" title="Search">üîé</a> -->
    <a class="js-list-of-headings-button" data-state="closed" href="#" title="Headings">üìú</a>
    <a class="js-go-to-top-button" href="#" title="Go to Top">‚¨ÜÔ∏è</a>
    <a class="js-go-to-bottom-button" href="#" title="Go to Bottom">‚¨áÔ∏è</a>
  </div>
  <a href="http://bit.ly/donateToWeeklyGeekly" class="donate-btn">DONATE</a>
  <section class="page js-page"><h1>JSON vs. XML and a bit of refactoring</h1><div class="post__text post__text-html js-mediator-article"><h4>  Introduction </h4><br>  Working in the field of RIA creation, sooner or later, you have to think about the choice of protocols for transferring data between a server and its clients.  If earlier I unconditionally used XML, now I‚Äôve increasingly thought about changing my priority on this issue in favor of JSON.  Above, I was not mistaken when I talked about clients; increasingly, for their service, customers require a mobile version and therefore we have to think about creating a server infrastructure capable of supporting several clients (a browser and, say, an iPhone application) and their versions.  It seems that XML fits all the parameters, but doubts arise. <br><a name="habracut"></a><br><h4>  Doubts </h4><br>  Over the past couple of years, I have cautiously noticed the ubiquitous use of XML - yes, the format is universal, but you need to know the measure.  The main XML flag is machine-readable and human-readable data storage format, I note that it is easy to read.  In the literature, you will find a reference to the fact that XML is a hierarchical structure for storing any data; visually, the structure can be represented as a tree. <br><br>  And here comes the first doubt: but if you take a small tree, two hundred nodes and save it as XML, it will be so easy to read it.  A person without a special editor with a backlight is almost impossible to read such files (especially if they are written in one line without hyphens or tabs).  It is difficult to disagree with this statement. <br><br>  Thus, one should discard human readability of the format as an advantage and consider XML primarily as a means of communication between services, programs or platforms, a kind of platform-independent means of communication between systems. 
      <br>
        <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
        <ins class="adsbygoogle"
          style="display:block; text-align:center;"
          data-ad-layout="in-article"
          data-ad-format="fluid"
          data-ad-client="ca-pub-6974184241884155"
          data-ad-slot="8945601208"></ins>
        <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
      <br>
      Based on the above reasoned position, a second doubt arises.  Isn't it expensive?  In this case, processor time is estimated.  In the last project, we had to measure the performance (you can say hard to ‚Äúprofile‚Äù) and, I must say, one of the bottlenecks was the serialization of objects into XML and their reincarnation from it.  It can be assumed that the hands should be washed more often, but for almost a month of struggle for the cleanliness of the rows, the performance has risen, but not enough to please the development team. <br><br>  The last of the stones of doubt, the easiest and, at the same time, fundamentally irreparable, is associated with the volume of transmitted data, that is, the volume of generated traffic.  As long as there were few customers, this problem did not exist.  However, when a mobile client appeared to the service and at the same time crowds of corporate employees rushed into the system, the volume of generated traffic clearly indicated XML redundancy (white noise generation) as a protocol for working with client applications (with their large mass). <br><br>  It can be concluded that the complexity of using XML exceeds the complexity of the problems that this technology solves.  You yourself can come up with a lot of pros and cons, as even the creators of XML [TB, TB2] do.  But in favor of XML, I want to note the following: using it as a protocol for synchronizing servers is almost perfect, and development automation tools allow you to relax and have fun.  But the problem of client traffic made us pay attention to the JSON data presentation format. <br><br><h4>  Alternative </h4><br>  The main source of information about JSON is the official [JSON] site, containing the following definition: JSON (JavaScript Object Notation) is a simple data exchange format that is easy to read and write by both humans and computers.  Noting the definition that is focused on promoting JSON to the masses, we note that the format is: textual, open, simple and well documented [JSONdoc]. <br><br>  In my opinion, the ease of human readability of the JSON format is even lower compared to XML.  To verify this claim, execute any request to the twitter.com API, for example: <a href="">search.twitter.com/search.json?q=golodnyj</a> , and try to interpret the result without familiarizing yourself with the API itself.  You will have difficulties, at least due to the fact that JSON does not transfer semantics, but is intended to represent content.  Based on the foregoing, JSON should be defined as a text-based, open, lightweight protocol for interfacing client-server applications, focused on transferring objects. <br><br>  The transition to the use of JSON really significantly (up to 25-30%) reduced the volume of user traffic and allowed to significantly reduce the load on the network infrastructure of the service.  However, as you understand, it was necessary to replace the generation and parsing from XML with JSON.  It would seem that there is nothing good in this - significant code refactoring, debugging and lengthy testing, but we were lucky. <br><br><h4>  Hero of the day </h4><br>  The savior of mankind in its individual areas was the XStream [XS] framework, which, by a happy coincidence, was used to work with XML in that part of the system on which the experiment was conducted. <br><br>  As an example, consider the Client class (see the full source code in Appendix 1), which has three attributes, a constructor, a getter, and a setter: <br><br><blockquote><code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">package ru.golodnyj.lection.json; <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> Client { <br> <font color="#0000ff">private</font> <font color="#2B91AF">String</font> userName; <br> <font color="#0000ff">private</font> boolean verified; <br> <font color="#0000ff">private</font> <font color="#0000ff">int</font> userId; <br> <br> <font color="#0000ff">public</font> Client( <font color="#2B91AF">String</font> userName, boolean verified, <font color="#0000ff">int</font> userId) { <br> <font color="#0000ff">this</font> .userName = userName; <br> <font color="#0000ff">this</font> .verified = verified; <br> <font color="#0000ff">this</font> .userId = userId; <br> } <br> ... <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  As well as the ConsoleJSON class (Appendix 2), which first demonstrates the serialization of an instance of the Client class into XML format, and then into JSON: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">package ru.golodnyj.lection.json; <br> ... <br> <br> <font color="#0000ff">public</font> <font color="#0000ff">class</font> ConsoleJSON { <br> <font color="#0000ff">public</font> <font color="#0000ff">static</font> <font color="#0000ff">void</font> main( <font color="#2B91AF">String</font> [] args) { <br> Client c = <font color="#0000ff">new</font> Client( <font color="#A31515">"name"</font> , <font color="#0000ff">true</font> , 5); <br> <br> <font color="#008000">//  XML</font> <br> XStream xstream = <font color="#0000ff">new</font> XStream( <font color="#0000ff">new</font> DomDriver()); <br> <font color="#2B91AF">String</font> xml = xstream.toXML(c ); <br> System. <font color="#0000ff">out</font> .println( <font color="#A31515">"xml "</font> + xml.length() + <font color="#A31515">" : \n"</font> + xml); <br> <br> <font color="#008000">//  JSON</font> <br> XStream xstream1 = <font color="#0000ff">new</font> XStream( <font color="#0000ff">new</font> JsonHierarchicalStreamDriver()); <br> <font color="#2B91AF">String</font> json = xstream1.toXML(c ); <br> System. <font color="#0000ff">out</font> .println( <font color="#A31515">"json "</font> + json.length() + <font color="#A31515">" : \n"</font> + json); <br> } <br> }</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  After starting the program, you will receive a message in the console like: <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">xml 145 : <br> <font color="#0000ff">&lt;</font> <font color="#800000">ru.golodnyj.lection.json.Client</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">userName</font> <font color="#0000ff">&gt;</font> name <font color="#0000ff">&lt;/</font> <font color="#800000">userName</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">verified</font> <font color="#0000ff">&gt;</font> true <font color="#0000ff">&lt;/</font> <font color="#800000">verified</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;</font> <font color="#800000">userId</font> <font color="#0000ff">&gt;</font> 5 <font color="#0000ff">&lt;/</font> <font color="#800000">userId</font> <font color="#0000ff">&gt;</font> <br> <font color="#0000ff">&lt;/</font> <font color="#800000">ru.golodnyj.lection.json.Client</font> <font color="#0000ff">&gt;</font> <br> json 96 : <br> {"ru.golodnyj.lection.json.Client": { <br> "userName": "name", <br> "verified": true, <br> "userId": 5 <br> }}</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  First, XML is displayed - the resulting string is 145 characters, and then JSON is 96 characters long.  The difference in the length of the lines when serializing such a simple object is significant, what to say about complex constructions.  Of course, the output for XML and for JSON can be made compact, for example, the full canonical name of the class and the formatted output are completely irrelevant for data transfer. <br><br>  To improve the output, you can use the alias mechanism in XStream, which allows you to match a string variable with the class name.  Also, for the JSON format, you need to change the driver from JsonHierarchicalStreamDriver (), which provides formatted output, to JettisonMappedXmlDriver (), which is intended for streaming output. <br><br><blockquote> <code><a href="http://virtser.net/blog/post/source-code-highlighter.aspx"></a> <font color="black">XStream xstream1 = <font color="#0000ff">new</font> XStream( <font color="#0000ff">new</font> JettisonMappedXmlDriver()); <br> xstream1.alias(¬´client¬ª, Client. <font color="#0000ff">class</font> );</font> <br> <br> <font color="gray">* This source code was highlighted with <font color="gray">Source Code Highlighter</font> .</font></code> </blockquote> <br>  In this case, the JSON variant for an instance of the Client object will be 57 characters long and look like this: <br><br><blockquote> <code>{"client":{"userName":"name","verified":true,"userId":5}}</code> </blockquote> <br>  The process of deserialization from XML to POJO is also simple and consists of calling the fromXML () method of an instance of the XStream class, which has a JSON string passed as a parameter, followed by the casting of data types. <br><br><h4>  findings </h4><br>  If you look again at the ConsoleJSON class, you will notice how little is required to replace the output from XML with JSON.  As a result, we have significant savings in the volume of generated traffic.  In this particular case, from the server side, the refactoring process, which aimed at replacing the XML data transfer protocol with JSON, was very simple and did not require much effort. <br><br><h4>  LITERATURE </h4><br>  [TB] Tim Bray <a href="http://www.tbray.org/ongoing/When/200x/2003/03/16/XML-Prog">www.tbray.org/ongoing/When/200x/2003/03/16/XML-Prog</a> <br>  [TB2] Tim Bray <a href="http://www.tbray.org/ongoing/When/200x/2003/03/24/XMLisOK">www.tbray.org/ongoing/When/200x/2003/03/24/XMLisOK</a> <br>  [JSON] <a href="http://www.json.org/">www.json.org</a> <br>  [JSONdoc] <a href="http://www.json.org/json-ru.html">www.json.org/json-ru.html</a> <br>  [XS] <a href="http://xstream.codehaus.org/">xstream.codehaus.org</a> <br><br><h4>  Applications </h4><br>  Application 1 <a href="http://dumpz.org/12012/">dumpz.org/12012</a> <br>  Application 2 <a href="http://dumpz.org/12013/">dumpz.org/12013</a> </div><p>Source: <a href="https://habr.com/ru/post/68621/">https://habr.com/ru/post/68621/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../68616/index.html">Creating an installer using WiX</a></li>
<li><a href="../68617/index.html">Software RAID1 (mirroring) on ‚Äã‚ÄãXenServer 5.5</a></li>
<li><a href="../68618/index.html">Clone Twitter from Yahoo !: Yahoo Meme</a></li>
<li><a href="../68619/index.html">AMD six-core dragon in 2010</a></li>
<li><a href="../68620/index.html">Looking for a book</a></li>
<li><a href="../68622/index.html">Football, hockey etc. on google calendar</a></li>
<li><a href="../68624/index.html">How Opera Turbo Saved the Internet ...</a></li>
<li><a href="../68626/index.html">Imagine Cup 2010 - YOU Can Change The World!</a></li>
<li><a href="../68630/index.html">Windows 7 - Start Sales</a></li>
<li><a href="../68636/index.html">CNews opened an information resource and its own assembly IE8</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter52496797 = new Ya.Metrika({
                  id:52496797,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/52496797" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134931760-1', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

  <footer class="page-footer">
    <div class="page-footer-legal-info-container page-footer-element">
      <p>
        Weekly-Geekly | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
      </p>
    </div>
    <div class="page-footer-counters-container page-footer-element">
      <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=6iCFw7uJz0zcOaoxz5k5PcLCJUzv2WG8G5V8M3U6Rc4&co=3a3a3a&ct=ffffff'/></a>
    </div>
  </footer>
</body>

</html>